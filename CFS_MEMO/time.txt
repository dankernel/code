
/* 
 * 시간 관련.. 타이머 인터럽트 핸들러..? 
 */

tick_handle_periodic()

/* 책에서 설명하는 함수 */ 
/* 특정 주기(초장 100 ~ 1000)마다 실행되는 함수 */
tick_periodic()

  /* 지피값 증가. */
  do_timer(1);

  /* 벽에 걸려있는 실제 시간(?) */
  update_wall_time()
  
  /* 시간 관련 처리를 함. */
  /* 어느 모드(유저/시스템)에서 틱이 발생 했는지 알아옴. */
  update_process_times()

    1. get current and cpu(number)

    /* 책 : 실제 프로세서 시간 갱신 작업을 함, 진동주기 전체동안 발생 한 것으로 인식(?) */
    /* 1에서 구한 current와 cpu로 갱신작업을 수행 함 */
    account_process_tick();
      1-1. vtime_account_user()을 task를 인자로 바로 매핑 함.
        1-1-1. 쓰레드 정보를 갖고 옴.
        1-1-2. 델타 타임을 구함.
        1-1-3. TODO : ...???
        /* ..? Task의 실행 시간을 cpu시간만큼 더함. */

    /* 책 : softirq 발생.(?) */
    run_local_timers()
      hrtimer_run_queues()
      raise_softirq()
  
    /* ...? */
    rcu_check_callbacks()

    /* 스케줄러 틱! */
    /* 타임슬라이스 감소 시킨다고 함. */
    scheduler_tick()
      1. get CPU, rq, curr
      2. lock
      3. update_rq_clock
      4. curr->sched_class->task_tick()
        4-1. (= task_tick_fair)
        4-2. entity_tick();
          4-2-1. update_curr() //저번주에 했던... 업데이트 커런트 ..//
          4-2-2. ...??
          4-2-3. resched_task() //리스케줄링 ..//
      5. update_cpu_load_active()
      6. unlock

      7. trigger_load_balance()
    
    /* 중요한 것 같은데, 모르겠당 */
    run_posix_cpu_timers()

 
