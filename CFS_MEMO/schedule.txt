
1. 배경

1-1. 스케줄러
리눅스 시스템에서는 여러가지의 프로세스가 동시에 작동 할 수 있다. (멀티테스킹)
더 구체적으로는, 여러 프로세스가 매우 짧은 시간동안 조금씩 실행되기 때문에
동시에 실행 하는 것 처럼 보인다.

(웹서핑을 하면서 음악을 듣는 예제를 많이 든다.)

스케줄러는 여러 프로세스를 적절히 조금씩 실행 시키는 일을 한다.
여러 일(task)를 잘 스케줄링 해서 좋은 성능을 낸다.

스케줄러의 종류에 따라서 스케줄링 정책과 알고리즘이 다르다.

1-2. 타임슬라이스
프로세스를 나누어 실행 할 '작은 시간'을 타임슬라이스(타임쿼텀)이라고 하며,
이는 스케줄러마다 정하는 방법이 다르다.

타임슬라이스는 프로세스마다의 우선순위나 가중치와 큰 관계가 있다.
우선순위가 높고 가중치가 큰 프로세스에게 오랜 시간동안 자원(CPU)를 할당하기 때문이다.
즉, 타임슬라이스가 크다는 것은 그만큼의 오랜 시간동안 CPU를 쓴다는 것이고.
이상적인 스케줄러라면 CPU를 많이 쓰는 프로세스에게 긴 타임슬라이스를 할당 해야 할 것이다.

(작동중인 프로세스가 영상 인코더 같이 프로세스(연산)중심의 프로세스인지,
vim같이 입출력 중심의 프로세스인지에 따라서 적절한 시간 배분이 필요하다.)

타임슬라이스의 기본값이 너무 크다면 반응과 응답속도가 느려질 것이며,
너무 작다면 콘텍스트스위치 비용이 과다하기 때문에 성능 저하가 있을 것이다.

1-3. 나이스 우선순위
우선순위에 따라서 다른 타임슬라이스 배분을 위해서
프로세스마다 나이스라는 가중치 값이 존재한다.

나이스값은 -19 ~ 0 ~ 20 의 정수로 이루어져 있다.
나이스 값이 클수록 점유시간이 길고(양보를 함), 낮을수록 점유시간이 길다(양보를 안함).
(우선순위가 높을수록 나이스하지 않아서 숫자가 적을 것이다.)

2. O(1) 스케줄러
과거의 스케줄러는 단순히 우선순위(가중치)를 기준으로 타임슬라이스를 계산해 냈다.
가령, 우선순위가 두배 높은 프로세스가 있다면 타임슬라이스도 두배 차이가 났다.

단순한 연산에 의해 이루어졌기 때문에 시간복잡도는 O(1)이다.

2-1. O(1) 스케줄러의 한계
단순 연산을 했기 때문에 적절한 타임슬라이스 값이 나오지 않았다.

3. 스케줄링 발생
프로세스는 타임슬라이스를 할당받아서 그 시간을 다 쓸 때 까지 실행된다.
할당받은 타임슬라이스를 다 사용했는가 여부를 수시로 체크 해야 하는데,
그것은 타이머 인터럽트에서 처리한다.

3-1. 타이머 인터럽트
타이머 인터럽트는 특정 주기(초당 100 ~ 1000회)마다 실행된다.
매우 짧은 시간동안에 반복적으로 실행되기 때문에 핸들러 구현이 비교적 간단하다.

(인터럽트에 대한 문서는 외부문서 참조, 본 문서에서는 별도 설명 없음)


4. CFS

vruntime

DISK I/O가 있는 경우.

구현










