list print :      (nil) ( 0x185a040       INIT)  0x185a060 
list print :  0x185a040 ( 0x185a060         if)  0x185a080 
list print :  0x185a060 ( 0x185a080        for)  0x185a0a0 
list print :  0x185a080 ( 0x185a0a0      while)      (nil) 
[ OK ] open : 3 ok... 
str :  *  kernel/sched/core.c[23]
strstr : INIT :  *  kernel/sched/core.c : 
2
strstr : if :  *  kernel/sched/core.c : 
2
strstr : for :  *  kernel/sched/core.c : 
2
strstr : while :  *  kernel/sched/core.c : 
2
str :  *  Kernel scheduler and related syscalls[41]
strstr : INIT :  *  Kernel scheduler and related syscalls : 
2
strstr : if :  *  Kernel scheduler and related syscalls : 
2
strstr : for :  *  Kernel scheduler and related syscalls : 
2
strstr : while :  *  Kernel scheduler and related syscalls : 
2
str :  *  Copyright (C) 1991-2002  Linus Torvalds[43]
strstr : INIT :  *  Copyright (C) 1991-2002  Linus Torvalds : 
2
strstr : if :  *  Copyright (C) 1991-2002  Linus Torvalds : 
2
strstr : for :  *  Copyright (C) 1991-2002  Linus Torvalds : 
2
strstr : while :  *  Copyright (C) 1991-2002  Linus Torvalds : 
2
str :  *  1996-12-23  Modified by Dave Grothe to fix bugs in semaphores and[69]
strstr : INIT :  *  1996-12-23  Modified by Dave Grothe to fix bugs in semaphores and : 
2
strstr : if :  *  1996-12-23  Modified by Dave Grothe to fix bugs in semaphores and : 
2
strstr : for :  *  1996-12-23  Modified by Dave Grothe to fix bugs in semaphores and : 
2
strstr : while :  *  1996-12-23  Modified by Dave Grothe to fix bugs in semaphores and : 
2
str :  *		make semaphores SMP safe[28]
strstr : INIT :  *		make semaphores SMP safe : 
2
strstr : if :  *		make semaphores SMP safe : 
2
strstr : for :  *		make semaphores SMP safe : 
2
strstr : while :  *		make semaphores SMP safe : 
2
str :  *  1998-11-19	Implemented schedule_timeout() and related stuff[63]
strstr : INIT :  *  1998-11-19	Implemented schedule_timeout() and related stuff : 
2
strstr : if :  *  1998-11-19	Implemented schedule_timeout() and related stuff : 
2
strstr : for :  *  1998-11-19	Implemented schedule_timeout() and related stuff : 
2
strstr : while :  *  1998-11-19	Implemented schedule_timeout() and related stuff : 
2
str :  *		by Andrea Arcangeli[23]
strstr : INIT :  *		by Andrea Arcangeli : 
2
strstr : if :  *		by Andrea Arcangeli : 
2
strstr : for :  *		by Andrea Arcangeli : 
2
strstr : while :  *		by Andrea Arcangeli : 
2
str :  *  2002-01-04	New ultra-scalable O(1) scheduler by Ingo Molnar:[64]
strstr : INIT :  *  2002-01-04	New ultra-scalable O(1) scheduler by Ingo Molnar: : 
2
strstr : if :  *  2002-01-04	New ultra-scalable O(1) scheduler by Ingo Molnar: : 
2
strstr : for :  *  2002-01-04	New ultra-scalable O(1) scheduler by Ingo Molnar: : 
2
strstr : while :  *  2002-01-04	New ultra-scalable O(1) scheduler by Ingo Molnar: : 
2
str :  *		hybrid priority-list and round-robin design with[52]
strstr : INIT :  *		hybrid priority-list and round-robin design with : 
2
strstr : if :  *		hybrid priority-list and round-robin design with : 
2
strstr : for :  *		hybrid priority-list and round-robin design with : 
2
strstr : while :  *		hybrid priority-list and round-robin design with : 
2
str :  *		an array-switch method of distributing timeslices[53]
strstr : INIT :  *		an array-switch method of distributing timeslices : 
2
strstr : if :  *		an array-switch method of distributing timeslices : 
2
strstr : for :  *		an array-switch method of distributing timeslices : 
2
strstr : while :  *		an array-switch method of distributing timeslices : 
2
str :  *		and per-CPU runqueues.  Cleanups and useful suggestions[59]
strstr : INIT :  *		and per-CPU runqueues.  Cleanups and useful suggestions : 
2
strstr : if :  *		and per-CPU runqueues.  Cleanups and useful suggestions : 
2
strstr : for :  *		and per-CPU runqueues.  Cleanups and useful suggestions : 
2
strstr : while :  *		and per-CPU runqueues.  Cleanups and useful suggestions : 
2
str :  *		by Davide Libenzi, preemptible kernel bits by Robert Love.[62]
strstr : INIT :  *		by Davide Libenzi, preemptible kernel bits by Robert Love. : 
2
strstr : if :  *		by Davide Libenzi, preemptible kernel bits by Robert Love. : 
2
strstr : for :  *		by Davide Libenzi, preemptible kernel bits by Robert Love. : 
2
strstr : while :  *		by Davide Libenzi, preemptible kernel bits by Robert Love. : 
2
str :  *  2003-09-03	Interactivity tuning by Con Kolivas.[51]
strstr : INIT :  *  2003-09-03	Interactivity tuning by Con Kolivas. : 
2
strstr : if :  *  2003-09-03	Interactivity tuning by Con Kolivas. : 
2
strstr : for :  *  2003-09-03	Interactivity tuning by Con Kolivas. : 
2
strstr : while :  *  2003-09-03	Interactivity tuning by Con Kolivas. : 
2
str :  *  2004-04-02	Scheduler domains code by Nick Piggin[52]
strstr : INIT :  *  2004-04-02	Scheduler domains code by Nick Piggin : 
2
strstr : if :  *  2004-04-02	Scheduler domains code by Nick Piggin : 
2
strstr : for :  *  2004-04-02	Scheduler domains code by Nick Piggin : 
2
strstr : while :  *  2004-04-02	Scheduler domains code by Nick Piggin : 
2
str :  *  2007-04-15  Work begun on replacing all interactivity tuning with a[71]
strstr : INIT :  *  2007-04-15  Work begun on replacing all interactivity tuning with a : 
2
strstr : if :  *  2007-04-15  Work begun on replacing all interactivity tuning with a : 
2
strstr : for :  *  2007-04-15  Work begun on replacing all interactivity tuning with a : 
2
strstr : while :  *  2007-04-15  Work begun on replacing all interactivity tuning with a : 
2
str :  *              fair scheduling design by Con Kolivas.[54]
strstr : INIT :  *              fair scheduling design by Con Kolivas. : 
2
strstr : if :  *              fair scheduling design by Con Kolivas. : 
2
strstr : for :  *              fair scheduling design by Con Kolivas. : 
2
strstr : while :  *              fair scheduling design by Con Kolivas. : 
2
str :  *  2007-05-05  Load balancing (smp-nice) and other improvements[64]
strstr : INIT :  *  2007-05-05  Load balancing (smp-nice) and other improvements : 
2
strstr : if :  *  2007-05-05  Load balancing (smp-nice) and other improvements : 
2
strstr : for :  *  2007-05-05  Load balancing (smp-nice) and other improvements : 
2
strstr : while :  *  2007-05-05  Load balancing (smp-nice) and other improvements : 
2
str :  *              by Peter Williams[33]
strstr : INIT :  *              by Peter Williams : 
2
strstr : if :  *              by Peter Williams : 
2
strstr : for :  *              by Peter Williams : 
2
strstr : while :  *              by Peter Williams : 
2
str :  *  2007-05-06  Interactivity improvements to CFS by Mike Galbraith[67]
strstr : INIT :  *  2007-05-06  Interactivity improvements to CFS by Mike Galbraith : 
2
strstr : if :  *  2007-05-06  Interactivity improvements to CFS by Mike Galbraith : 
2
strstr : for :  *  2007-05-06  Interactivity improvements to CFS by Mike Galbraith : 
2
strstr : while :  *  2007-05-06  Interactivity improvements to CFS by Mike Galbraith : 
2
str :  *  2007-07-01  Group scheduling enhancements by Srivatsa Vaddagiri[67]
strstr : INIT :  *  2007-07-01  Group scheduling enhancements by Srivatsa Vaddagiri : 
2
strstr : if :  *  2007-07-01  Group scheduling enhancements by Srivatsa Vaddagiri : 
2
strstr : for :  *  2007-07-01  Group scheduling enhancements by Srivatsa Vaddagiri : 
2
strstr : while :  *  2007-07-01  Group scheduling enhancements by Srivatsa Vaddagiri : 
2
str :  *  2007-11-29  RT balancing improvements by Steven Rostedt, Gregory Haskins,[77]
strstr : INIT :  *  2007-11-29  RT balancing improvements by Steven Rostedt, Gregory Haskins, : 
2
strstr : if :  *  2007-11-29  RT balancing improvements by Steven Rostedt, Gregory Haskins, : 
2
strstr : for :  *  2007-11-29  RT balancing improvements by Steven Rostedt, Gregory Haskins, : 
2
strstr : while :  *  2007-11-29  RT balancing improvements by Steven Rostedt, Gregory Haskins, : 
2
str :  *              Thomas Gleixner, Mike Kravetz[45]
strstr : INIT :  *              Thomas Gleixner, Mike Kravetz : 
2
strstr : if :  *              Thomas Gleixner, Mike Kravetz : 
2
strstr : for :  *              Thomas Gleixner, Mike Kravetz : 
2
strstr : while :  *              Thomas Gleixner, Mike Kravetz : 
2
str :  */[3]
strstr : INIT :  */ : 
2
strstr : if :  */ : 
2
strstr : for :  */ : 
2
strstr : while :  */ : 
2
str : #include <linux/mm.h>[21]
strstr : INIT : #include <linux/mm.h> : 
2
strstr : if : #include <linux/mm.h> : 
2
strstr : for : #include <linux/mm.h> : 
2
strstr : while : #include <linux/mm.h> : 
2
str : #include <linux/module.h>[25]
strstr : INIT : #include <linux/module.h> : 
2
strstr : if : #include <linux/module.h> : 
2
strstr : for : #include <linux/module.h> : 
2
strstr : while : #include <linux/module.h> : 
2
str : #include <linux/nmi.h>[22]
strstr : INIT : #include <linux/nmi.h> : 
2
strstr : if : #include <linux/nmi.h> : 
2
strstr : for : #include <linux/nmi.h> : 
2
strstr : while : #include <linux/nmi.h> : 
2
str : #include <linux/init.h>[23]
strstr : INIT : #include <linux/init.h> : 
2
strstr : if : #include <linux/init.h> : 
2
strstr : for : #include <linux/init.h> : 
2
strstr : while : #include <linux/init.h> : 
2
str : #include <linux/uaccess.h>[26]
strstr : INIT : #include <linux/uaccess.h> : 
2
strstr : if : #include <linux/uaccess.h> : 
2
strstr : for : #include <linux/uaccess.h> : 
2
strstr : while : #include <linux/uaccess.h> : 
2
str : #include <linux/highmem.h>[26]
strstr : INIT : #include <linux/highmem.h> : 
2
strstr : if : #include <linux/highmem.h> : 
2
strstr : for : #include <linux/highmem.h> : 
2
strstr : while : #include <linux/highmem.h> : 
2
str : #include <asm/mmu_context.h>[28]
strstr : INIT : #include <asm/mmu_context.h> : 
2
strstr : if : #include <asm/mmu_context.h> : 
2
strstr : for : #include <asm/mmu_context.h> : 
2
strstr : while : #include <asm/mmu_context.h> : 
2
str : #include <linux/interrupt.h>[28]
strstr : INIT : #include <linux/interrupt.h> : 
2
strstr : if : #include <linux/interrupt.h> : 
2
strstr : for : #include <linux/interrupt.h> : 
2
strstr : while : #include <linux/interrupt.h> : 
2
str : #include <linux/capability.h>[29]
strstr : INIT : #include <linux/capability.h> : 
2
strstr : if : #include <linux/capability.h> : 
2
strstr : for : #include <linux/capability.h> : 
2
strstr : while : #include <linux/capability.h> : 
2
str : #include <linux/completion.h>[29]
strstr : INIT : #include <linux/completion.h> : 
2
strstr : if : #include <linux/completion.h> : 
2
strstr : for : #include <linux/completion.h> : 
2
strstr : while : #include <linux/completion.h> : 
2
str : #include <linux/kernel_stat.h>[30]
strstr : INIT : #include <linux/kernel_stat.h> : 
2
strstr : if : #include <linux/kernel_stat.h> : 
2
strstr : for : #include <linux/kernel_stat.h> : 
2
strstr : while : #include <linux/kernel_stat.h> : 
2
str : #include <linux/debug_locks.h>[30]
strstr : INIT : #include <linux/debug_locks.h> : 
2
strstr : if : #include <linux/debug_locks.h> : 
2
strstr : for : #include <linux/debug_locks.h> : 
2
strstr : while : #include <linux/debug_locks.h> : 
2
str : #include <linux/perf_event.h>[29]
strstr : INIT : #include <linux/perf_event.h> : 
2
strstr : if : #include <linux/perf_event.h> : 
2
strstr : for : #include <linux/perf_event.h> : 
2
strstr : while : #include <linux/perf_event.h> : 
2
str : #include <linux/security.h>[27]
strstr : INIT : #include <linux/security.h> : 
2
strstr : if : #include <linux/security.h> : 
2
strstr : for : #include <linux/security.h> : 
2
strstr : while : #include <linux/security.h> : 
2
str : #include <linux/notifier.h>[27]
strstr : INIT : #include <linux/notifier.h> : 
2
strstr : if : #include <linux/notifier.h> : 
2
strstr : for : #include <linux/notifier.h> : 
2
strstr : while : #include <linux/notifier.h> : 
2
str : #include <linux/profile.h>[26]
strstr : INIT : #include <linux/profile.h> : 
2
strstr : if : #include <linux/profile.h> : 
2
strstr : for : #include <linux/profile.h> : 
2
strstr : while : #include <linux/profile.h> : 
2
str : #include <linux/freezer.h>[26]
strstr : INIT : #include <linux/freezer.h> : 
2
strstr : if : #include <linux/freezer.h> : 
2
strstr : for : #include <linux/freezer.h> : 
2
strstr : while : #include <linux/freezer.h> : 
2
str : #include <linux/vmalloc.h>[26]
strstr : INIT : #include <linux/vmalloc.h> : 
2
strstr : if : #include <linux/vmalloc.h> : 
2
strstr : for : #include <linux/vmalloc.h> : 
2
strstr : while : #include <linux/vmalloc.h> : 
2
str : #include <linux/blkdev.h>[25]
strstr : INIT : #include <linux/blkdev.h> : 
2
strstr : if : #include <linux/blkdev.h> : 
2
strstr : for : #include <linux/blkdev.h> : 
2
strstr : while : #include <linux/blkdev.h> : 
2
str : #include <linux/delay.h>[24]
strstr : INIT : #include <linux/delay.h> : 
2
strstr : if : #include <linux/delay.h> : 
2
strstr : for : #include <linux/delay.h> : 
2
strstr : while : #include <linux/delay.h> : 
2
str : #include <linux/pid_namespace.h>[32]
strstr : INIT : #include <linux/pid_namespace.h> : 
2
strstr : if : #include <linux/pid_namespace.h> : 
2
strstr : for : #include <linux/pid_namespace.h> : 
2
strstr : while : #include <linux/pid_namespace.h> : 
2
str : #include <linux/smp.h>[22]
strstr : INIT : #include <linux/smp.h> : 
2
strstr : if : #include <linux/smp.h> : 
2
strstr : for : #include <linux/smp.h> : 
2
strstr : while : #include <linux/smp.h> : 
2
str : #include <linux/threads.h>[26]
strstr : INIT : #include <linux/threads.h> : 
2
strstr : if : #include <linux/threads.h> : 
2
strstr : for : #include <linux/threads.h> : 
2
strstr : while : #include <linux/threads.h> : 
2
str : #include <linux/timer.h>[24]
strstr : INIT : #include <linux/timer.h> : 
2
strstr : if : #include <linux/timer.h> : 
2
strstr : for : #include <linux/timer.h> : 
2
strstr : while : #include <linux/timer.h> : 
2
str : #include <linux/rcupdate.h>[27]
strstr : INIT : #include <linux/rcupdate.h> : 
2
strstr : if : #include <linux/rcupdate.h> : 
2
strstr : for : #include <linux/rcupdate.h> : 
2
strstr : while : #include <linux/rcupdate.h> : 
2
str : #include <linux/cpu.h>[22]
strstr : INIT : #include <linux/cpu.h> : 
2
strstr : if : #include <linux/cpu.h> : 
2
strstr : for : #include <linux/cpu.h> : 
2
strstr : while : #include <linux/cpu.h> : 
2
str : #include <linux/cpuset.h>[25]
strstr : INIT : #include <linux/cpuset.h> : 
2
strstr : if : #include <linux/cpuset.h> : 
2
strstr : for : #include <linux/cpuset.h> : 
2
strstr : while : #include <linux/cpuset.h> : 
2
str : #include <linux/percpu.h>[25]
strstr : INIT : #include <linux/percpu.h> : 
2
strstr : if : #include <linux/percpu.h> : 
2
strstr : for : #include <linux/percpu.h> : 
2
strstr : while : #include <linux/percpu.h> : 
2
str : #include <linux/proc_fs.h>[26]
strstr : INIT : #include <linux/proc_fs.h> : 
2
strstr : if : #include <linux/proc_fs.h> : 
2
strstr : for : #include <linux/proc_fs.h> : 
2
strstr : while : #include <linux/proc_fs.h> : 
2
str : #include <linux/seq_file.h>[27]
strstr : INIT : #include <linux/seq_file.h> : 
2
strstr : if : #include <linux/seq_file.h> : 
2
strstr : for : #include <linux/seq_file.h> : 
2
strstr : while : #include <linux/seq_file.h> : 
2
str : #include <linux/sysctl.h>[25]
strstr : INIT : #include <linux/sysctl.h> : 
2
strstr : if : #include <linux/sysctl.h> : 
2
strstr : for : #include <linux/sysctl.h> : 
2
strstr : while : #include <linux/sysctl.h> : 
2
str : #include <linux/syscalls.h>[27]
strstr : INIT : #include <linux/syscalls.h> : 
2
strstr : if : #include <linux/syscalls.h> : 
2
strstr : for : #include <linux/syscalls.h> : 
2
strstr : while : #include <linux/syscalls.h> : 
2
str : #include <linux/times.h>[24]
strstr : INIT : #include <linux/times.h> : 
2
strstr : if : #include <linux/times.h> : 
2
strstr : for : #include <linux/times.h> : 
2
strstr : while : #include <linux/times.h> : 
2
str : #include <linux/tsacct_kern.h>[30]
strstr : INIT : #include <linux/tsacct_kern.h> : 
2
strstr : if : #include <linux/tsacct_kern.h> : 
2
strstr : for : #include <linux/tsacct_kern.h> : 
2
strstr : while : #include <linux/tsacct_kern.h> : 
2
str : #include <linux/kprobes.h>[26]
strstr : INIT : #include <linux/kprobes.h> : 
2
strstr : if : #include <linux/kprobes.h> : 
2
strstr : for : #include <linux/kprobes.h> : 
2
strstr : while : #include <linux/kprobes.h> : 
2
str : #include <linux/delayacct.h>[28]
strstr : INIT : #include <linux/delayacct.h> : 
2
strstr : if : #include <linux/delayacct.h> : 
2
strstr : for : #include <linux/delayacct.h> : 
2
strstr : while : #include <linux/delayacct.h> : 
2
str : #include <linux/unistd.h>[25]
strstr : INIT : #include <linux/unistd.h> : 
2
strstr : if : #include <linux/unistd.h> : 
2
strstr : for : #include <linux/unistd.h> : 
2
strstr : while : #include <linux/unistd.h> : 
2
str : #include <linux/pagemap.h>[26]
strstr : INIT : #include <linux/pagemap.h> : 
2
strstr : if : #include <linux/pagemap.h> : 
2
strstr : for : #include <linux/pagemap.h> : 
2
strstr : while : #include <linux/pagemap.h> : 
2
str : #include <linux/hrtimer.h>[26]
strstr : INIT : #include <linux/hrtimer.h> : 
2
strstr : if : #include <linux/hrtimer.h> : 
2
strstr : for : #include <linux/hrtimer.h> : 
2
strstr : while : #include <linux/hrtimer.h> : 
2
str : #include <linux/tick.h>[23]
strstr : INIT : #include <linux/tick.h> : 
2
strstr : if : #include <linux/tick.h> : 
2
strstr : for : #include <linux/tick.h> : 
2
strstr : while : #include <linux/tick.h> : 
2
str : #include <linux/debugfs.h>[26]
strstr : INIT : #include <linux/debugfs.h> : 
2
strstr : if : #include <linux/debugfs.h> : 
2
strstr : for : #include <linux/debugfs.h> : 
2
strstr : while : #include <linux/debugfs.h> : 
2
str : #include <linux/ctype.h>[24]
strstr : INIT : #include <linux/ctype.h> : 
2
strstr : if : #include <linux/ctype.h> : 
2
strstr : for : #include <linux/ctype.h> : 
2
strstr : while : #include <linux/ctype.h> : 
2
str : #include <linux/ftrace.h>[25]
strstr : INIT : #include <linux/ftrace.h> : 
2
strstr : if : #include <linux/ftrace.h> : 
2
strstr : for : #include <linux/ftrace.h> : 
2
strstr : while : #include <linux/ftrace.h> : 
2
str : #include <linux/slab.h>[23]
strstr : INIT : #include <linux/slab.h> : 
2
strstr : if : #include <linux/slab.h> : 
2
strstr : for : #include <linux/slab.h> : 
2
strstr : while : #include <linux/slab.h> : 
2
str : #include <linux/init_task.h>[28]
strstr : INIT : #include <linux/init_task.h> : 
2
strstr : if : #include <linux/init_task.h> : 
2
strstr : for : #include <linux/init_task.h> : 
2
strstr : while : #include <linux/init_task.h> : 
2
str : #include <linux/binfmts.h>[26]
strstr : INIT : #include <linux/binfmts.h> : 
2
strstr : if : #include <linux/binfmts.h> : 
2
strstr : for : #include <linux/binfmts.h> : 
2
strstr : while : #include <linux/binfmts.h> : 
2
str : #include <linux/context_tracking.h>[35]
strstr : INIT : #include <linux/context_tracking.h> : 
2
strstr : if : #include <linux/context_tracking.h> : 
2
strstr : for : #include <linux/context_tracking.h> : 
2
strstr : while : #include <linux/context_tracking.h> : 
2
str : #include <asm/switch_to.h>[26]
strstr : INIT : #include <asm/switch_to.h> : 
2
strstr : if : #include <asm/switch_to.h> : 
2
strstr : for : #include <asm/switch_to.h> : 
2
strstr : while : #include <asm/switch_to.h> : 
2
str : #include <asm/tlb.h>[20]
strstr : INIT : #include <asm/tlb.h> : 
2
strstr : if : #include <asm/tlb.h> : 
2
strstr : for : #include <asm/tlb.h> : 
2
strstr : while : #include <asm/tlb.h> : 
2
str : #include <asm/irq_regs.h>[25]
strstr : INIT : #include <asm/irq_regs.h> : 
2
strstr : if : #include <asm/irq_regs.h> : 
2
strstr : for : #include <asm/irq_regs.h> : 
2
strstr : while : #include <asm/irq_regs.h> : 
2
str : #include <asm/mutex.h>[22]
strstr : INIT : #include <asm/mutex.h> : 
2
strstr : if : #include <asm/mutex.h> : 
2
strstr : for : #include <asm/mutex.h> : 
2
strstr : while : #include <asm/mutex.h> : 
2
str : #ifdef CONFIG_PARAVIRT[22]
strstr : INIT : #ifdef CONFIG_PARAVIRT : 
2
strstr : if : #ifdef CONFIG_PARAVIRT : 
2
strstr : for : #ifdef CONFIG_PARAVIRT : 
2
strstr : while : #ifdef CONFIG_PARAVIRT : 
2
str : #include <asm/paravirt.h>[25]
strstr : INIT : #include <asm/paravirt.h> : 
2
strstr : if : #include <asm/paravirt.h> : 
2
strstr : for : #include <asm/paravirt.h> : 
2
strstr : while : #include <asm/paravirt.h> : 
2
str : #endif[6]
strstr : INIT : #endif : 
2
strstr : if : #endif : 
2
strstr : for : #endif : 
2
strstr : while : #endif : 
2
str : #include "sched.h"[18]
strstr : INIT : #include "sched.h" : 
2
strstr : if : #include "sched.h" : 
2
strstr : for : #include "sched.h" : 
2
strstr : while : #include "sched.h" : 
2
str : #include "../workqueue_internal.h"[34]
strstr : INIT : #include "../workqueue_internal.h" : 
2
strstr : if : #include "../workqueue_internal.h" : 
2
strstr : for : #include "../workqueue_internal.h" : 
2
strstr : while : #include "../workqueue_internal.h" : 
2
str : #include "../smpboot.h"[23]
strstr : INIT : #include "../smpboot.h" : 
2
strstr : if : #include "../smpboot.h" : 
2
strstr : for : #include "../smpboot.h" : 
2
strstr : while : #include "../smpboot.h" : 
2
str : #define CREATE_TRACE_POINTS[27]
strstr : INIT : #define CREATE_TRACE_POINTS : 
2
strstr : if : #define CREATE_TRACE_POINTS : 
2
strstr : for : #define CREATE_TRACE_POINTS : 
2
strstr : while : #define CREATE_TRACE_POINTS : 
2
str : #include <trace/events/sched.h>[31]
strstr : INIT : #include <trace/events/sched.h> : 
2
strstr : if : #include <trace/events/sched.h> : 
2
strstr : for : #include <trace/events/sched.h> : 
2
strstr : while : #include <trace/events/sched.h> : 
2
str : void start_bandwidth_timer(struct hrtimer *period_timer, ktime_t period)[72]
strstr : INIT : void start_bandwidth_timer(struct hrtimer *period_timer, ktime_t period) : 
2
strstr : if : void start_bandwidth_timer(struct hrtimer *period_timer, ktime_t period) : 
2
strstr : for : void start_bandwidth_timer(struct hrtimer *period_timer, ktime_t period) : 
2
strstr : while : void start_bandwidth_timer(struct hrtimer *period_timer, ktime_t period) : 
2
str : 	unsigned long delta;[21]
strstr : INIT : 	unsigned long delta; : 
2
strstr : if : 	unsigned long delta; : 
2
strstr : for : 	unsigned long delta; : 
2
strstr : while : 	unsigned long delta; : 
2
str : 	ktime_t soft, hard, now;[25]
strstr : INIT : 	ktime_t soft, hard, now; : 
2
strstr : if : 	ktime_t soft, hard, now; : 
2
strstr : for : 	ktime_t soft, hard, now; : 
2
strstr : while : 	ktime_t soft, hard, now; : 
2
str : 	for (;;) {[11]
strstr : INIT : 	for (;;) { : 
2
strstr : if : 	for (;;) { : 
2
strstr : for : 	for (;;) { : 
2
strstr : while : 	for (;;) { : 
2
str : 		if (hrtimer_active(period_timer))[35]
strstr : INIT : 		if (hrtimer_active(period_timer)) : 
2
strstr : if : 		if (hrtimer_active(period_timer)) : 
2
strstr : for : 		if (hrtimer_active(period_timer)) : 
2
strstr : while : 		if (hrtimer_active(period_timer)) : 
2
str : 			break;[9]
strstr : INIT : 			break; : 
2
strstr : if : 			break; : 
2
strstr : for : 			break; : 
2
strstr : while : 			break; : 
2
str : 		now = hrtimer_cb_get_time(period_timer);[42]
strstr : INIT : 		now = hrtimer_cb_get_time(period_timer); : 
2
strstr : if : 		now = hrtimer_cb_get_time(period_timer); : 
2
strstr : for : 		now = hrtimer_cb_get_time(period_timer); : 
2
strstr : while : 		now = hrtimer_cb_get_time(period_timer); : 
2
str : 		hrtimer_forward(period_timer, now, period);[45]
strstr : INIT : 		hrtimer_forward(period_timer, now, period); : 
2
strstr : if : 		hrtimer_forward(period_timer, now, period); : 
2
strstr : for : 		hrtimer_forward(period_timer, now, period); : 
2
strstr : while : 		hrtimer_forward(period_timer, now, period); : 
2
str : 		soft = hrtimer_get_softexpires(period_timer);[47]
strstr : INIT : 		soft = hrtimer_get_softexpires(period_timer); : 
2
strstr : if : 		soft = hrtimer_get_softexpires(period_timer); : 
2
strstr : for : 		soft = hrtimer_get_softexpires(period_timer); : 
2
strstr : while : 		soft = hrtimer_get_softexpires(period_timer); : 
2
str : 		hard = hrtimer_get_expires(period_timer);[43]
strstr : INIT : 		hard = hrtimer_get_expires(period_timer); : 
2
strstr : if : 		hard = hrtimer_get_expires(period_timer); : 
2
strstr : for : 		hard = hrtimer_get_expires(period_timer); : 
2
strstr : while : 		hard = hrtimer_get_expires(period_timer); : 
2
str : 		delta = ktime_to_ns(ktime_sub(hard, soft));[45]
strstr : INIT : 		delta = ktime_to_ns(ktime_sub(hard, soft)); : 
2
strstr : if : 		delta = ktime_to_ns(ktime_sub(hard, soft)); : 
2
strstr : for : 		delta = ktime_to_ns(ktime_sub(hard, soft)); : 
2
strstr : while : 		delta = ktime_to_ns(ktime_sub(hard, soft)); : 
2
str : 		__hrtimer_start_range_ns(period_timer, soft, delta,[53]
strstr : INIT : 		__hrtimer_start_range_ns(period_timer, soft, delta, : 
2
strstr : if : 		__hrtimer_start_range_ns(period_timer, soft, delta, : 
2
strstr : for : 		__hrtimer_start_range_ns(period_timer, soft, delta, : 
2
strstr : while : 		__hrtimer_start_range_ns(period_timer, soft, delta, : 
2
str : 					 HRTIMER_MODE_ABS_PINNED, 0);[34]
strstr : INIT : 					 HRTIMER_MODE_ABS_PINNED, 0); : 
2
strstr : if : 					 HRTIMER_MODE_ABS_PINNED, 0); : 
2
strstr : for : 					 HRTIMER_MODE_ABS_PINNED, 0); : 
2
strstr : while : 					 HRTIMER_MODE_ABS_PINNED, 0); : 
2
str : DEFINE_MUTEX(sched_domains_mutex);[34]
strstr : INIT : DEFINE_MUTEX(sched_domains_mutex); : 
2
strstr : if : DEFINE_MUTEX(sched_domains_mutex); : 
2
strstr : for : DEFINE_MUTEX(sched_domains_mutex); : 
2
strstr : while : DEFINE_MUTEX(sched_domains_mutex); : 
2
str : DEFINE_PER_CPU_SHARED_ALIGNED(struct rq, runqueues);[52]
strstr : INIT : DEFINE_PER_CPU_SHARED_ALIGNED(struct rq, runqueues); : 
2
strstr : if : DEFINE_PER_CPU_SHARED_ALIGNED(struct rq, runqueues); : 
2
strstr : for : DEFINE_PER_CPU_SHARED_ALIGNED(struct rq, runqueues); : 
2
strstr : while : DEFINE_PER_CPU_SHARED_ALIGNED(struct rq, runqueues); : 
2
str : static void update_rq_clock_task(struct rq *rq, s64 delta);[59]
strstr : INIT : static void update_rq_clock_task(struct rq *rq, s64 delta); : 
2
strstr : if : static void update_rq_clock_task(struct rq *rq, s64 delta); : 
2
strstr : for : static void update_rq_clock_task(struct rq *rq, s64 delta); : 
2
strstr : while : static void update_rq_clock_task(struct rq *rq, s64 delta); : 
2
str : void update_rq_clock(struct rq *rq)[35]
strstr : INIT : void update_rq_clock(struct rq *rq) : 
2
strstr : if : void update_rq_clock(struct rq *rq) : 
2
strstr : for : void update_rq_clock(struct rq *rq) : 
2
strstr : while : void update_rq_clock(struct rq *rq) : 
2
str : 	s64 delta;[11]
strstr : INIT : 	s64 delta; : 
2
strstr : if : 	s64 delta; : 
2
strstr : for : 	s64 delta; : 
2
strstr : while : 	s64 delta; : 
2
str : 	if (rq->skip_clock_update > 0)[31]
strstr : INIT : 	if (rq->skip_clock_update > 0) : 
2
strstr : if : 	if (rq->skip_clock_update > 0) : 
2
strstr : for : 	if (rq->skip_clock_update > 0) : 
2
strstr : while : 	if (rq->skip_clock_update > 0) : 
2
str : 		return;[9]
strstr : INIT : 		return; : 
2
strstr : if : 		return; : 
2
strstr : for : 		return; : 
2
strstr : while : 		return; : 
2
str : 	delta = sched_clock_cpu(cpu_of(rq)) - rq->clock;[49]
strstr : INIT : 	delta = sched_clock_cpu(cpu_of(rq)) - rq->clock; : 
2
strstr : if : 	delta = sched_clock_cpu(cpu_of(rq)) - rq->clock; : 
2
strstr : for : 	delta = sched_clock_cpu(cpu_of(rq)) - rq->clock; : 
2
strstr : while : 	delta = sched_clock_cpu(cpu_of(rq)) - rq->clock; : 
2
str : 	rq->clock += delta;[20]
strstr : INIT : 	rq->clock += delta; : 
2
strstr : if : 	rq->clock += delta; : 
2
strstr : for : 	rq->clock += delta; : 
2
strstr : while : 	rq->clock += delta; : 
2
str : 	update_rq_clock_task(rq, delta);[33]
strstr : INIT : 	update_rq_clock_task(rq, delta); : 
2
strstr : if : 	update_rq_clock_task(rq, delta); : 
2
strstr : for : 	update_rq_clock_task(rq, delta); : 
2
strstr : while : 	update_rq_clock_task(rq, delta); : 
2
str :  * Debugging: various feature bits[34]
strstr : INIT :  * Debugging: various feature bits : 
2
strstr : if :  * Debugging: various feature bits : 
2
strstr : for :  * Debugging: various feature bits : 
2
strstr : while :  * Debugging: various feature bits : 
2
str :  */[3]
strstr : INIT :  */ : 
2
strstr : if :  */ : 
2
strstr : for :  */ : 
2
strstr : while :  */ : 
2
str : #define SCHED_FEAT(name, enabled)	\[35]
strstr : INIT : #define SCHED_FEAT(name, enabled)	\ : 
2
strstr : if : #define SCHED_FEAT(name, enabled)	\ : 
2
strstr : for : #define SCHED_FEAT(name, enabled)	\ : 
2
strstr : while : #define SCHED_FEAT(name, enabled)	\ : 
2
str : 	(1UL << __SCHED_FEAT_##name) * enabled |[41]
strstr : INIT : 	(1UL << __SCHED_FEAT_##name) * enabled | : 
2
strstr : if : 	(1UL << __SCHED_FEAT_##name) * enabled | : 
2
strstr : for : 	(1UL << __SCHED_FEAT_##name) * enabled | : 
2
strstr : while : 	(1UL << __SCHED_FEAT_##name) * enabled | : 
2
str : const_debug unsigned int sysctl_sched_features =[48]
strstr : INIT : const_debug unsigned int sysctl_sched_features = : 
2
strstr : if : const_debug unsigned int sysctl_sched_features = : 
2
strstr : for : const_debug unsigned int sysctl_sched_features = : 
2
strstr : while : const_debug unsigned int sysctl_sched_features = : 
2
str : #include "features.h"[21]
strstr : INIT : #include "features.h" : 
2
strstr : if : #include "features.h" : 
2
strstr : for : #include "features.h" : 
2
strstr : while : #include "features.h" : 
2
str : 	0;[3]
strstr : INIT : 	0; : 
2
strstr : if : 	0; : 
2
strstr : for : 	0; : 
2
strstr : while : 	0; : 
2
str : #undef SCHED_FEAT[17]
strstr : INIT : #undef SCHED_FEAT : 
2
strstr : if : #undef SCHED_FEAT : 
2
strstr : for : #undef SCHED_FEAT : 
2
strstr : while : #undef SCHED_FEAT : 
2
str : #ifdef CONFIG_SCHED_DEBUG[25]
strstr : INIT : #ifdef CONFIG_SCHED_DEBUG : 
2
strstr : if : #ifdef CONFIG_SCHED_DEBUG : 
2
strstr : for : #ifdef CONFIG_SCHED_DEBUG : 
2
strstr : while : #ifdef CONFIG_SCHED_DEBUG : 
2
str : #define SCHED_FEAT(name, enabled)	\[35]
strstr : INIT : #define SCHED_FEAT(name, enabled)	\ : 
2
strstr : if : #define SCHED_FEAT(name, enabled)	\ : 
2
strstr : for : #define SCHED_FEAT(name, enabled)	\ : 
2
strstr : while : #define SCHED_FEAT(name, enabled)	\ : 
2
str : 	#name ,[8]
strstr : INIT : 	#name , : 
2
strstr : if : 	#name , : 
2
strstr : for : 	#name , : 
2
strstr : while : 	#name , : 
2
str : static const char * const sched_feat_names[] = {[48]
strstr : INIT : static const char * const sched_feat_names[] = { : 
2
strstr : if : static const char * const sched_feat_names[] = { : 
2
strstr : for : static const char * const sched_feat_names[] = { : 
2
strstr : while : static const char * const sched_feat_names[] = { : 
2
str : #include "features.h"[21]
strstr : INIT : #include "features.h" : 
2
strstr : if : #include "features.h" : 
2
strstr : for : #include "features.h" : 
2
strstr : while : #include "features.h" : 
2
str : #undef SCHED_FEAT[17]
strstr : INIT : #undef SCHED_FEAT : 
2
strstr : if : #undef SCHED_FEAT : 
2
strstr : for : #undef SCHED_FEAT : 
2
strstr : while : #undef SCHED_FEAT : 
2
str : static int sched_feat_show(struct seq_file *m, void *v)[55]
strstr : INIT : static int sched_feat_show(struct seq_file *m, void *v) : 
2
strstr : if : static int sched_feat_show(struct seq_file *m, void *v) : 
2
strstr : for : static int sched_feat_show(struct seq_file *m, void *v) : 
2
strstr : while : static int sched_feat_show(struct seq_file *m, void *v) : 
2
str : 	int i;[7]
strstr : INIT : 	int i; : 
2
strstr : if : 	int i; : 
2
strstr : for : 	int i; : 
2
strstr : while : 	int i; : 
2
str : 	for (i = 0; i < __SCHED_FEAT_NR; i++) {[40]
strstr : INIT : 	for (i = 0; i < __SCHED_FEAT_NR; i++) { : 
2
strstr : if : 	for (i = 0; i < __SCHED_FEAT_NR; i++) { : 
2
strstr : for : 	for (i = 0; i < __SCHED_FEAT_NR; i++) { : 
2
strstr : while : 	for (i = 0; i < __SCHED_FEAT_NR; i++) { : 
2
str : 		if (!(sysctl_sched_features & (1UL << i)))[44]
strstr : INIT : 		if (!(sysctl_sched_features & (1UL << i))) : 
2
strstr : if : 		if (!(sysctl_sched_features & (1UL << i))) : 
2
strstr : for : 		if (!(sysctl_sched_features & (1UL << i))) : 
2
strstr : while : 		if (!(sysctl_sched_features & (1UL << i))) : 
2
str : 			seq_puts(m, "NO_");[22]
strstr : INIT : 			seq_puts(m, "NO_"); : 
2
strstr : if : 			seq_puts(m, "NO_"); : 
2
strstr : for : 			seq_puts(m, "NO_"); : 
2
strstr : while : 			seq_puts(m, "NO_"); : 
2
str : 		seq_printf(m, "%s ", sched_feat_names[i]);[44]
strstr : INIT : 		seq_printf(m, "%s ", sched_feat_names[i]); : 
2
strstr : if : 		seq_printf(m, "%s ", sched_feat_names[i]); : 
2
strstr : for : 		seq_printf(m, "%s ", sched_feat_names[i]); : 
2
strstr : while : 		seq_printf(m, "%s ", sched_feat_names[i]); : 
2
str : 	seq_puts(m, "\n");[19]
strstr : INIT : 	seq_puts(m, "\n"); : 
2
strstr : if : 	seq_puts(m, "\n"); : 
2
strstr : for : 	seq_puts(m, "\n"); : 
2
strstr : while : 	seq_puts(m, "\n"); : 
2
str : 	return 0;[10]
strstr : INIT : 	return 0; : 
2
strstr : if : 	return 0; : 
2
strstr : for : 	return 0; : 
2
strstr : while : 	return 0; : 
2
str : #ifdef HAVE_JUMP_LABEL[22]
strstr : INIT : #ifdef HAVE_JUMP_LABEL : 
2
strstr : if : #ifdef HAVE_JUMP_LABEL : 
2
strstr : for : #ifdef HAVE_JUMP_LABEL : 
2
strstr : while : #ifdef HAVE_JUMP_LABEL : 
2
str : #define jump_label_key__true  STATIC_KEY_INIT_TRUE[50]
strstr : INIT : #define jump_label_key__true  STATIC_KEY_INIT_TRUE : 
2
strstr : if : #define jump_label_key__true  STATIC_KEY_INIT_TRUE : 
2
strstr : for : #define jump_label_key__true  STATIC_KEY_INIT_TRUE : 
2
strstr : while : #define jump_label_key__true  STATIC_KEY_INIT_TRUE : 
2
str : #define jump_label_key__false STATIC_KEY_INIT_FALSE[51]
strstr : INIT : #define jump_label_key__false STATIC_KEY_INIT_FALSE : 
2
strstr : if : #define jump_label_key__false STATIC_KEY_INIT_FALSE : 
2
strstr : for : #define jump_label_key__false STATIC_KEY_INIT_FALSE : 
2
strstr : while : #define jump_label_key__false STATIC_KEY_INIT_FALSE : 
2
str : #define SCHED_FEAT(name, enabled)	\[35]
strstr : INIT : #define SCHED_FEAT(name, enabled)	\ : 
2
strstr : if : #define SCHED_FEAT(name, enabled)	\ : 
2
strstr : for : #define SCHED_FEAT(name, enabled)	\ : 
2
strstr : while : #define SCHED_FEAT(name, enabled)	\ : 
2
str : 	jump_label_key__##enabled ,[28]
strstr : INIT : 	jump_label_key__##enabled , : 
2
strstr : if : 	jump_label_key__##enabled , : 
2
strstr : for : 	jump_label_key__##enabled , : 
2
strstr : while : 	jump_label_key__##enabled , : 
2
str : struct static_key sched_feat_keys[__SCHED_FEAT_NR] = {[54]
strstr : INIT : struct static_key sched_feat_keys[__SCHED_FEAT_NR] = { : 
2
strstr : if : struct static_key sched_feat_keys[__SCHED_FEAT_NR] = { : 
2
strstr : for : struct static_key sched_feat_keys[__SCHED_FEAT_NR] = { : 
2
strstr : while : struct static_key sched_feat_keys[__SCHED_FEAT_NR] = { : 
2
str : #include "features.h"[21]
strstr : INIT : #include "features.h" : 
2
strstr : if : #include "features.h" : 
2
strstr : for : #include "features.h" : 
2
strstr : while : #include "features.h" : 
2
str : #undef SCHED_FEAT[17]
strstr : INIT : #undef SCHED_FEAT : 
2
strstr : if : #undef SCHED_FEAT : 
2
strstr : for : #undef SCHED_FEAT : 
2
strstr : while : #undef SCHED_FEAT : 
2
str : static void sched_feat_disable(int i)[37]
strstr : INIT : static void sched_feat_disable(int i) : 
2
strstr : if : static void sched_feat_disable(int i) : 
2
strstr : for : static void sched_feat_disable(int i) : 
2
strstr : while : static void sched_feat_disable(int i) : 
2
str : 	if (static_key_enabled(&sched_feat_keys[i]))[45]
strstr : INIT : 	if (static_key_enabled(&sched_feat_keys[i])) : 
2
strstr : if : 	if (static_key_enabled(&sched_feat_keys[i])) : 
2
strstr : for : 	if (static_key_enabled(&sched_feat_keys[i])) : 
2
strstr : while : 	if (static_key_enabled(&sched_feat_keys[i])) : 
2
str : 		static_key_slow_dec(&sched_feat_keys[i]);[43]
strstr : INIT : 		static_key_slow_dec(&sched_feat_keys[i]); : 
2
strstr : if : 		static_key_slow_dec(&sched_feat_keys[i]); : 
2
strstr : for : 		static_key_slow_dec(&sched_feat_keys[i]); : 
2
strstr : while : 		static_key_slow_dec(&sched_feat_keys[i]); : 
2
str : static void sched_feat_enable(int i)[36]
strstr : INIT : static void sched_feat_enable(int i) : 
2
strstr : if : static void sched_feat_enable(int i) : 
2
strstr : for : static void sched_feat_enable(int i) : 
2
strstr : while : static void sched_feat_enable(int i) : 
2
str : 	if (!static_key_enabled(&sched_feat_keys[i]))[46]
strstr : INIT : 	if (!static_key_enabled(&sched_feat_keys[i])) : 
2
strstr : if : 	if (!static_key_enabled(&sched_feat_keys[i])) : 
2
strstr : for : 	if (!static_key_enabled(&sched_feat_keys[i])) : 
2
strstr : while : 	if (!static_key_enabled(&sched_feat_keys[i])) : 
2
str : 		static_key_slow_inc(&sched_feat_keys[i]);[43]
strstr : INIT : 		static_key_slow_inc(&sched_feat_keys[i]); : 
2
strstr : if : 		static_key_slow_inc(&sched_feat_keys[i]); : 
2
strstr : for : 		static_key_slow_inc(&sched_feat_keys[i]); : 
2
strstr : while : 		static_key_slow_inc(&sched_feat_keys[i]); : 
2
str : #else[5]
strstr : INIT : #else : 
2
strstr : if : #else : 
2
strstr : for : #else : 
2
strstr : while : #else : 
2
str : static void sched_feat_disable(int i) { };[42]
strstr : INIT : static void sched_feat_disable(int i) { }; : 
2
strstr : if : static void sched_feat_disable(int i) { }; : 
2
strstr : for : static void sched_feat_disable(int i) { }; : 
2
strstr : while : static void sched_feat_disable(int i) { }; : 
2
str : static void sched_feat_enable(int i) { };[41]
strstr : INIT : static void sched_feat_enable(int i) { }; : 
2
strstr : if : static void sched_feat_enable(int i) { }; : 
2
strstr : for : static void sched_feat_enable(int i) { }; : 
2
strstr : while : static void sched_feat_enable(int i) { }; : 
2
str : #endif /* HAVE_JUMP_LABEL */[28]
strstr : INIT : #endif /* HAVE_JUMP_LABEL */ : 
2
strstr : if : #endif /* HAVE_JUMP_LABEL */ : 
2
strstr : for : #endif /* HAVE_JUMP_LABEL */ : 
2
strstr : while : #endif /* HAVE_JUMP_LABEL */ : 
2
str : static int sched_feat_set(char *cmp)[36]
strstr : INIT : static int sched_feat_set(char *cmp) : 
2
strstr : if : static int sched_feat_set(char *cmp) : 
2
strstr : for : static int sched_feat_set(char *cmp) : 
2
strstr : while : static int sched_feat_set(char *cmp) : 
2
str : 	int i;[7]
strstr : INIT : 	int i; : 
2
strstr : if : 	int i; : 
2
strstr : for : 	int i; : 
2
strstr : while : 	int i; : 
2
str : 	int neg = 0;[13]
strstr : INIT : 	int neg = 0; : 
2
strstr : if : 	int neg = 0; : 
2
strstr : for : 	int neg = 0; : 
2
strstr : while : 	int neg = 0; : 
2
str : 	if (strncmp(cmp, "NO_", 3) == 0) {[35]
strstr : INIT : 	if (strncmp(cmp, "NO_", 3) == 0) { : 
2
strstr : if : 	if (strncmp(cmp, "NO_", 3) == 0) { : 
2
strstr : for : 	if (strncmp(cmp, "NO_", 3) == 0) { : 
2
strstr : while : 	if (strncmp(cmp, "NO_", 3) == 0) { : 
2
str : 		neg = 1;[10]
strstr : INIT : 		neg = 1; : 
2
strstr : if : 		neg = 1; : 
2
strstr : for : 		neg = 1; : 
2
strstr : while : 		neg = 1; : 
2
str : 		cmp += 3;[11]
strstr : INIT : 		cmp += 3; : 
2
strstr : if : 		cmp += 3; : 
2
strstr : for : 		cmp += 3; : 
2
strstr : while : 		cmp += 3; : 
2
str : 	for (i = 0; i < __SCHED_FEAT_NR; i++) {[40]
strstr : INIT : 	for (i = 0; i < __SCHED_FEAT_NR; i++) { : 
2
strstr : if : 	for (i = 0; i < __SCHED_FEAT_NR; i++) { : 
2
strstr : for : 	for (i = 0; i < __SCHED_FEAT_NR; i++) { : 
2
strstr : while : 	for (i = 0; i < __SCHED_FEAT_NR; i++) { : 
2
str : 		if (strcmp(cmp, sched_feat_names[i]) == 0) {[46]
strstr : INIT : 		if (strcmp(cmp, sched_feat_names[i]) == 0) { : 
2
strstr : if : 		if (strcmp(cmp, sched_feat_names[i]) == 0) { : 
2
strstr : for : 		if (strcmp(cmp, sched_feat_names[i]) == 0) { : 
2
strstr : while : 		if (strcmp(cmp, sched_feat_names[i]) == 0) { : 
2
str : 			if (neg) {[13]
strstr : INIT : 			if (neg) { : 
2
strstr : if : 			if (neg) { : 
2
strstr : for : 			if (neg) { : 
2
strstr : while : 			if (neg) { : 
2
str : 				sysctl_sched_features &= ~(1UL << i);[41]
strstr : INIT : 				sysctl_sched_features &= ~(1UL << i); : 
2
strstr : if : 				sysctl_sched_features &= ~(1UL << i); : 
2
strstr : for : 				sysctl_sched_features &= ~(1UL << i); : 
2
strstr : while : 				sysctl_sched_features &= ~(1UL << i); : 
2
str : 				sched_feat_disable(i);[26]
strstr : INIT : 				sched_feat_disable(i); : 
2
strstr : if : 				sched_feat_disable(i); : 
2
strstr : for : 				sched_feat_disable(i); : 
2
strstr : while : 				sched_feat_disable(i); : 
2
str : 			} else {[11]
strstr : INIT : 			} else { : 
2
strstr : if : 			} else { : 
2
strstr : for : 			} else { : 
2
strstr : while : 			} else { : 
2
str : 				sysctl_sched_features |= (1UL << i);[40]
strstr : INIT : 				sysctl_sched_features |= (1UL << i); : 
2
strstr : if : 				sysctl_sched_features |= (1UL << i); : 
2
strstr : for : 				sysctl_sched_features |= (1UL << i); : 
2
strstr : while : 				sysctl_sched_features |= (1UL << i); : 
2
str : 				sched_feat_enable(i);[25]
strstr : INIT : 				sched_feat_enable(i); : 
2
strstr : if : 				sched_feat_enable(i); : 
2
strstr : for : 				sched_feat_enable(i); : 
2
strstr : while : 				sched_feat_enable(i); : 
2
str : 			}[4]
strstr : INIT : 			} : 
2
strstr : if : 			} : 
2
strstr : for : 			} : 
2
strstr : while : 			} : 
2
str : 			break;[9]
strstr : INIT : 			break; : 
2
strstr : if : 			break; : 
2
strstr : for : 			break; : 
2
strstr : while : 			break; : 
2
str : 		}[3]
strstr : INIT : 		} : 
2
strstr : if : 		} : 
2
strstr : for : 		} : 
2
strstr : while : 		} : 
2
str : 	return i;[10]
strstr : INIT : 	return i; : 
2
strstr : if : 	return i; : 
2
strstr : for : 	return i; : 
2
strstr : while : 	return i; : 
2
str : static ssize_t[14]
strstr : INIT : static ssize_t : 
2
strstr : if : static ssize_t : 
2
strstr : for : static ssize_t : 
2
strstr : while : static ssize_t : 
2
str : sched_feat_write(struct file *filp, const char __user *ubuf,[60]
strstr : INIT : sched_feat_write(struct file *filp, const char __user *ubuf, : 
2
strstr : if : sched_feat_write(struct file *filp, const char __user *ubuf, : 
2
strstr : for : sched_feat_write(struct file *filp, const char __user *ubuf, : 
2
strstr : while : sched_feat_write(struct file *filp, const char __user *ubuf, : 
2
str : 		size_t cnt, loff_t *ppos)[27]
strstr : INIT : 		size_t cnt, loff_t *ppos) : 
2
strstr : if : 		size_t cnt, loff_t *ppos) : 
2
strstr : for : 		size_t cnt, loff_t *ppos) : 
2
strstr : while : 		size_t cnt, loff_t *ppos) : 
2
str : 	char buf[64];[14]
strstr : INIT : 	char buf[64]; : 
2
strstr : if : 	char buf[64]; : 
2
strstr : for : 	char buf[64]; : 
2
strstr : while : 	char buf[64]; : 
2
str : 	char *cmp;[11]
strstr : INIT : 	char *cmp; : 
2
strstr : if : 	char *cmp; : 
2
strstr : for : 	char *cmp; : 
2
strstr : while : 	char *cmp; : 
2
str : 	int i;[7]
strstr : INIT : 	int i; : 
2
strstr : if : 	int i; : 
2
strstr : for : 	int i; : 
2
strstr : while : 	int i; : 
2
str : 	if (cnt > 63)[14]
strstr : INIT : 	if (cnt > 63) : 
2
strstr : if : 	if (cnt > 63) : 
2
strstr : for : 	if (cnt > 63) : 
2
strstr : while : 	if (cnt > 63) : 
2
str : 		cnt = 63;[11]
strstr : INIT : 		cnt = 63; : 
2
strstr : if : 		cnt = 63; : 
2
strstr : for : 		cnt = 63; : 
2
strstr : while : 		cnt = 63; : 
2
str : 	if (copy_from_user(&buf, ubuf, cnt))[37]
strstr : INIT : 	if (copy_from_user(&buf, ubuf, cnt)) : 
2
strstr : if : 	if (copy_from_user(&buf, ubuf, cnt)) : 
2
strstr : for : 	if (copy_from_user(&buf, ubuf, cnt)) : 
2
strstr : while : 	if (copy_from_user(&buf, ubuf, cnt)) : 
2
str : 		return -EFAULT;[17]
strstr : INIT : 		return -EFAULT; : 
2
strstr : if : 		return -EFAULT; : 
2
strstr : for : 		return -EFAULT; : 
2
strstr : while : 		return -EFAULT; : 
2
str : 	buf[cnt] = 0;[14]
strstr : INIT : 	buf[cnt] = 0; : 
2
strstr : if : 	buf[cnt] = 0; : 
2
strstr : for : 	buf[cnt] = 0; : 
2
strstr : while : 	buf[cnt] = 0; : 
2
str : 	cmp = strstrip(buf);[21]
strstr : INIT : 	cmp = strstrip(buf); : 
2
strstr : if : 	cmp = strstrip(buf); : 
2
strstr : for : 	cmp = strstrip(buf); : 
2
strstr : while : 	cmp = strstrip(buf); : 
2
str : 	i = sched_feat_set(cmp);[25]
strstr : INIT : 	i = sched_feat_set(cmp); : 
2
strstr : if : 	i = sched_feat_set(cmp); : 
2
strstr : for : 	i = sched_feat_set(cmp); : 
2
strstr : while : 	i = sched_feat_set(cmp); : 
2
str : 	if (i == __SCHED_FEAT_NR)[26]
strstr : INIT : 	if (i == __SCHED_FEAT_NR) : 
2
strstr : if : 	if (i == __SCHED_FEAT_NR) : 
2
strstr : for : 	if (i == __SCHED_FEAT_NR) : 
2
strstr : while : 	if (i == __SCHED_FEAT_NR) : 
2
str : 		return -EINVAL;[17]
strstr : INIT : 		return -EINVAL; : 
2
strstr : if : 		return -EINVAL; : 
2
strstr : for : 		return -EINVAL; : 
2
strstr : while : 		return -EINVAL; : 
2
str : 	*ppos += cnt;[14]
strstr : INIT : 	*ppos += cnt; : 
2
strstr : if : 	*ppos += cnt; : 
2
strstr : for : 	*ppos += cnt; : 
2
strstr : while : 	*ppos += cnt; : 
2
str : 	return cnt;[12]
strstr : INIT : 	return cnt; : 
2
strstr : if : 	return cnt; : 
2
strstr : for : 	return cnt; : 
2
strstr : while : 	return cnt; : 
2
str : static int sched_feat_open(struct inode *inode, struct file *filp)[66]
strstr : INIT : static int sched_feat_open(struct inode *inode, struct file *filp) : 
2
strstr : if : static int sched_feat_open(struct inode *inode, struct file *filp) : 
2
strstr : for : static int sched_feat_open(struct inode *inode, struct file *filp) : 
2
strstr : while : static int sched_feat_open(struct inode *inode, struct file *filp) : 
2
str : 	return single_open(filp, sched_feat_show, NULL);[49]
strstr : INIT : 	return single_open(filp, sched_feat_show, NULL); : 
2
strstr : if : 	return single_open(filp, sched_feat_show, NULL); : 
2
strstr : for : 	return single_open(filp, sched_feat_show, NULL); : 
2
strstr : while : 	return single_open(filp, sched_feat_show, NULL); : 
2
str : static const struct file_operations sched_feat_fops = {[55]
strstr : INIT : static const struct file_operations sched_feat_fops = { : 
2
strstr : if : static const struct file_operations sched_feat_fops = { : 
2
strstr : for : static const struct file_operations sched_feat_fops = { : 
2
strstr : while : static const struct file_operations sched_feat_fops = { : 
2
str : 	.open		= sched_feat_open,[26]
strstr : INIT : 	.open		= sched_feat_open, : 
2
strstr : if : 	.open		= sched_feat_open, : 
2
strstr : for : 	.open		= sched_feat_open, : 
2
strstr : while : 	.open		= sched_feat_open, : 
2
str : 	.write		= sched_feat_write,[28]
strstr : INIT : 	.write		= sched_feat_write, : 
2
strstr : if : 	.write		= sched_feat_write, : 
2
strstr : for : 	.write		= sched_feat_write, : 
2
strstr : while : 	.write		= sched_feat_write, : 
2
str : 	.read		= seq_read,[19]
strstr : INIT : 	.read		= seq_read, : 
2
strstr : if : 	.read		= seq_read, : 
2
strstr : for : 	.read		= seq_read, : 
2
strstr : while : 	.read		= seq_read, : 
2
str : 	.llseek		= seq_lseek,[22]
strstr : INIT : 	.llseek		= seq_lseek, : 
2
strstr : if : 	.llseek		= seq_lseek, : 
2
strstr : for : 	.llseek		= seq_lseek, : 
2
strstr : while : 	.llseek		= seq_lseek, : 
2
str : 	.release	= single_release,[27]
strstr : INIT : 	.release	= single_release, : 
2
strstr : if : 	.release	= single_release, : 
2
strstr : for : 	.release	= single_release, : 
2
strstr : while : 	.release	= single_release, : 
2
str : static __init int sched_init_debug(void)[40]
strstr : INIT : static __init int sched_init_debug(void) : 
2
strstr : if : static __init int sched_init_debug(void) : 
2
strstr : for : static __init int sched_init_debug(void) : 
2
strstr : while : static __init int sched_init_debug(void) : 
2
str : 	debugfs_create_file("sched_features", 0644, NULL, NULL,[56]
strstr : INIT : 	debugfs_create_file("sched_features", 0644, NULL, NULL, : 
2
strstr : if : 	debugfs_create_file("sched_features", 0644, NULL, NULL, : 
2
strstr : for : 	debugfs_create_file("sched_features", 0644, NULL, NULL, : 
2
strstr : while : 	debugfs_create_file("sched_features", 0644, NULL, NULL, : 
2
str : 			&sched_feat_fops);[21]
strstr : INIT : 			&sched_feat_fops); : 
2
strstr : if : 			&sched_feat_fops); : 
2
strstr : for : 			&sched_feat_fops); : 
2
strstr : while : 			&sched_feat_fops); : 
2
str : 	return 0;[10]
strstr : INIT : 	return 0; : 
2
strstr : if : 	return 0; : 
2
strstr : for : 	return 0; : 
2
strstr : while : 	return 0; : 
2
str : late_initcall(sched_init_debug);[32]
strstr : INIT : late_initcall(sched_init_debug); : 
2
strstr : if : late_initcall(sched_init_debug); : 
2
strstr : for : late_initcall(sched_init_debug); : 
2
strstr : while : late_initcall(sched_init_debug); : 
2
str : #endif /* CONFIG_SCHED_DEBUG */[31]
strstr : INIT : #endif /* CONFIG_SCHED_DEBUG */ : 
2
strstr : if : #endif /* CONFIG_SCHED_DEBUG */ : 
2
strstr : for : #endif /* CONFIG_SCHED_DEBUG */ : 
2
strstr : while : #endif /* CONFIG_SCHED_DEBUG */ : 
2
str :  * Number of tasks to iterate in a single balance run.[54]
strstr : INIT :  * Number of tasks to iterate in a single balance run. : 
2
strstr : if :  * Number of tasks to iterate in a single balance run. : 
2
strstr : for :  * Number of tasks to iterate in a single balance run. : 
2
strstr : while :  * Number of tasks to iterate in a single balance run. : 
2
str :  * Limited because this is done with IRQs disabled.[51]
strstr : INIT :  * Limited because this is done with IRQs disabled. : 
2
strstr : if :  * Limited because this is done with IRQs disabled. : 
2
strstr : for :  * Limited because this is done with IRQs disabled. : 
2
strstr : while :  * Limited because this is done with IRQs disabled. : 
2
str :  */[3]
strstr : INIT :  */ : 
2
strstr : if :  */ : 
2
strstr : for :  */ : 
2
strstr : while :  */ : 
2
str : const_debug unsigned int sysctl_sched_nr_migrate = 32;[54]
strstr : INIT : const_debug unsigned int sysctl_sched_nr_migrate = 32; : 
2
strstr : if : const_debug unsigned int sysctl_sched_nr_migrate = 32; : 
2
strstr : for : const_debug unsigned int sysctl_sched_nr_migrate = 32; : 
2
strstr : while : const_debug unsigned int sysctl_sched_nr_migrate = 32; : 
2
str :  * period over which we average the RT time consumption, measured[65]
strstr : INIT :  * period over which we average the RT time consumption, measured : 
2
strstr : if :  * period over which we average the RT time consumption, measured : 
2
strstr : for :  * period over which we average the RT time consumption, measured : 
2
strstr : while :  * period over which we average the RT time consumption, measured : 
2
str :  * in ms.[9]
strstr : INIT :  * in ms. : 
2
strstr : if :  * in ms. : 
2
strstr : for :  * in ms. : 
2
strstr : while :  * in ms. : 
2
str :  * default: 1s[14]
strstr : INIT :  * default: 1s : 
2
strstr : if :  * default: 1s : 
2
strstr : for :  * default: 1s : 
2
strstr : while :  * default: 1s : 
2
str :  */[3]
strstr : INIT :  */ : 
2
strstr : if :  */ : 
2
strstr : for :  */ : 
2
strstr : while :  */ : 
2
str : const_debug unsigned int sysctl_sched_time_avg = MSEC_PER_SEC;[62]
strstr : INIT : const_debug unsigned int sysctl_sched_time_avg = MSEC_PER_SEC; : 
2
strstr : if : const_debug unsigned int sysctl_sched_time_avg = MSEC_PER_SEC; : 
2
strstr : for : const_debug unsigned int sysctl_sched_time_avg = MSEC_PER_SEC; : 
2
strstr : while : const_debug unsigned int sysctl_sched_time_avg = MSEC_PER_SEC; : 
2
str :  * period over which we measure -rt task cpu usage in us.[57]
strstr : INIT :  * period over which we measure -rt task cpu usage in us. : 
2
strstr : if :  * period over which we measure -rt task cpu usage in us. : 
2
strstr : for :  * period over which we measure -rt task cpu usage in us. : 
2
strstr : while :  * period over which we measure -rt task cpu usage in us. : 
2
str :  * default: 1s[14]
strstr : INIT :  * default: 1s : 
2
strstr : if :  * default: 1s : 
2
strstr : for :  * default: 1s : 
2
strstr : while :  * default: 1s : 
2
str :  */[3]
strstr : INIT :  */ : 
2
strstr : if :  */ : 
2
strstr : for :  */ : 
2
strstr : while :  */ : 
2
str : unsigned int sysctl_sched_rt_period = 1000000;[46]
strstr : INIT : unsigned int sysctl_sched_rt_period = 1000000; : 
2
strstr : if : unsigned int sysctl_sched_rt_period = 1000000; : 
2
strstr : for : unsigned int sysctl_sched_rt_period = 1000000; : 
2
strstr : while : unsigned int sysctl_sched_rt_period = 1000000; : 
2
str : __read_mostly int scheduler_running;[36]
strstr : INIT : __read_mostly int scheduler_running; : 
2
strstr : if : __read_mostly int scheduler_running; : 
2
strstr : for : __read_mostly int scheduler_running; : 
2
strstr : while : __read_mostly int scheduler_running; : 
2
str :  * part of the period that we allow rt tasks to run in us.[58]
strstr : INIT :  * part of the period that we allow rt tasks to run in us. : 
2
strstr : if :  * part of the period that we allow rt tasks to run in us. : 
2
strstr : for :  * part of the period that we allow rt tasks to run in us. : 
2
strstr : while :  * part of the period that we allow rt tasks to run in us. : 
2
str :  * default: 0.95s[17]
strstr : INIT :  * default: 0.95s : 
2
strstr : if :  * default: 0.95s : 
2
strstr : for :  * default: 0.95s : 
2
strstr : while :  * default: 0.95s : 
2
str :  */[3]
strstr : INIT :  */ : 
2
strstr : if :  */ : 
2
strstr : for :  */ : 
2
strstr : while :  */ : 
2
str : int sysctl_sched_rt_runtime = 950000;[37]
strstr : INIT : int sysctl_sched_rt_runtime = 950000; : 
2
strstr : if : int sysctl_sched_rt_runtime = 950000; : 
2
strstr : for : int sysctl_sched_rt_runtime = 950000; : 
2
strstr : while : int sysctl_sched_rt_runtime = 950000; : 
2
str :  * __task_rq_lock - lock the rq @p resides on.[46]
strstr : INIT :  * __task_rq_lock - lock the rq @p resides on. : 
2
strstr : if :  * __task_rq_lock - lock the rq @p resides on. : 
2
strstr : for :  * __task_rq_lock - lock the rq @p resides on. : 
2
strstr : while :  * __task_rq_lock - lock the rq @p resides on. : 
2
str :  */[3]
strstr : INIT :  */ : 
2
strstr : if :  */ : 
2
strstr : for :  */ : 
2
strstr : while :  */ : 
2
str : static inline struct rq *__task_rq_lock(struct task_struct *p)[62]
strstr : INIT : static inline struct rq *__task_rq_lock(struct task_struct *p) : 
2
strstr : if : static inline struct rq *__task_rq_lock(struct task_struct *p) : 
2
strstr : for : static inline struct rq *__task_rq_lock(struct task_struct *p) : 
2
strstr : while : static inline struct rq *__task_rq_lock(struct task_struct *p) : 
2
str : 	__acquires(rq->lock)[21]
strstr : INIT : 	__acquires(rq->lock) : 
2
strstr : if : 	__acquires(rq->lock) : 
2
strstr : for : 	__acquires(rq->lock) : 
2
strstr : while : 	__acquires(rq->lock) : 
2
str : 	struct rq *rq;[15]
strstr : INIT : 	struct rq *rq; : 
2
strstr : if : 	struct rq *rq; : 
2
strstr : for : 	struct rq *rq; : 
2
strstr : while : 	struct rq *rq; : 
2
str : 	lockdep_assert_held(&p->pi_lock);[34]
strstr : INIT : 	lockdep_assert_held(&p->pi_lock); : 
2
strstr : if : 	lockdep_assert_held(&p->pi_lock); : 
2
strstr : for : 	lockdep_assert_held(&p->pi_lock); : 
2
strstr : while : 	lockdep_assert_held(&p->pi_lock); : 
2
str : 	for (;;) {[11]
strstr : INIT : 	for (;;) { : 
2
strstr : if : 	for (;;) { : 
2
strstr : for : 	for (;;) { : 
2
strstr : while : 	for (;;) { : 
2
str : 		rq = task_rq(p);[18]
strstr : INIT : 		rq = task_rq(p); : 
2
strstr : if : 		rq = task_rq(p); : 
2
strstr : for : 		rq = task_rq(p); : 
2
strstr : while : 		rq = task_rq(p); : 
2
str : 		raw_spin_lock(&rq->lock);[27]
strstr : INIT : 		raw_spin_lock(&rq->lock); : 
2
strstr : if : 		raw_spin_lock(&rq->lock); : 
2
strstr : for : 		raw_spin_lock(&rq->lock); : 
2
strstr : while : 		raw_spin_lock(&rq->lock); : 
2
str : 		if (likely(rq == task_rq(p)))[31]
strstr : INIT : 		if (likely(rq == task_rq(p))) : 
2
strstr : if : 		if (likely(rq == task_rq(p))) : 
2
strstr : for : 		if (likely(rq == task_rq(p))) : 
2
strstr : while : 		if (likely(rq == task_rq(p))) : 
2
str : 			return rq;[13]
strstr : INIT : 			return rq; : 
2
strstr : if : 			return rq; : 
2
strstr : for : 			return rq; : 
2
strstr : while : 			return rq; : 
2
str : 		raw_spin_unlock(&rq->lock);[29]
strstr : INIT : 		raw_spin_unlock(&rq->lock); : 
2
strstr : if : 		raw_spin_unlock(&rq->lock); : 
2
strstr : for : 		raw_spin_unlock(&rq->lock); : 
2
strstr : while : 		raw_spin_unlock(&rq->lock); : 
2
str :  * task_rq_lock - lock p->pi_lock and lock the rq @p resides on.[64]
strstr : INIT :  * task_rq_lock - lock p->pi_lock and lock the rq @p resides on. : 
2
strstr : if :  * task_rq_lock - lock p->pi_lock and lock the rq @p resides on. : 
2
strstr : for :  * task_rq_lock - lock p->pi_lock and lock the rq @p resides on. : 
2
strstr : while :  * task_rq_lock - lock p->pi_lock and lock the rq @p resides on. : 
2
str :  */[3]
strstr : INIT :  */ : 
2
strstr : if :  */ : 
2
strstr : for :  */ : 
2
strstr : while :  */ : 
2
str : static struct rq *task_rq_lock(struct task_struct *p, unsigned long *flags)[75]
strstr : INIT : static struct rq *task_rq_lock(struct task_struct *p, unsigned long *flags) : 
2
strstr : if : static struct rq *task_rq_lock(struct task_struct *p, unsigned long *flags) : 
2
strstr : for : static struct rq *task_rq_lock(struct task_struct *p, unsigned long *flags) : 
2
strstr : while : static struct rq *task_rq_lock(struct task_struct *p, unsigned long *flags) : 
2
str : 	__acquires(p->pi_lock)[23]
strstr : INIT : 	__acquires(p->pi_lock) : 
2
strstr : if : 	__acquires(p->pi_lock) : 
2
strstr : for : 	__acquires(p->pi_lock) : 
2
strstr : while : 	__acquires(p->pi_lock) : 
2
str : 	__acquires(rq->lock)[21]
strstr : INIT : 	__acquires(rq->lock) : 
2
strstr : if : 	__acquires(rq->lock) : 
2
strstr : for : 	__acquires(rq->lock) : 
2
strstr : while : 	__acquires(rq->lock) : 
2
str : 	struct rq *rq;[15]
strstr : INIT : 	struct rq *rq; : 
2
strstr : if : 	struct rq *rq; : 
2
strstr : for : 	struct rq *rq; : 
2
strstr : while : 	struct rq *rq; : 
2
str : 	for (;;) {[11]
strstr : INIT : 	for (;;) { : 
2
strstr : if : 	for (;;) { : 
2
strstr : for : 	for (;;) { : 
2
strstr : while : 	for (;;) { : 
2
str : 		raw_spin_lock_irqsave(&p->pi_lock, *flags);[45]
strstr : INIT : 		raw_spin_lock_irqsave(&p->pi_lock, *flags); : 
2
strstr : if : 		raw_spin_lock_irqsave(&p->pi_lock, *flags); : 
2
strstr : for : 		raw_spin_lock_irqsave(&p->pi_lock, *flags); : 
2
strstr : while : 		raw_spin_lock_irqsave(&p->pi_lock, *flags); : 
2
str : 		rq = task_rq(p);[18]
strstr : INIT : 		rq = task_rq(p); : 
2
strstr : if : 		rq = task_rq(p); : 
2
strstr : for : 		rq = task_rq(p); : 
2
strstr : while : 		rq = task_rq(p); : 
2
str : 		raw_spin_lock(&rq->lock);[27]
strstr : INIT : 		raw_spin_lock(&rq->lock); : 
2
strstr : if : 		raw_spin_lock(&rq->lock); : 
2
strstr : for : 		raw_spin_lock(&rq->lock); : 
2
strstr : while : 		raw_spin_lock(&rq->lock); : 
2
str : 		if (likely(rq == task_rq(p)))[31]
strstr : INIT : 		if (likely(rq == task_rq(p))) : 
2
strstr : if : 		if (likely(rq == task_rq(p))) : 
2
strstr : for : 		if (likely(rq == task_rq(p))) : 
2
strstr : while : 		if (likely(rq == task_rq(p))) : 
2
str : 			return rq;[13]
strstr : INIT : 			return rq; : 
2
strstr : if : 			return rq; : 
2
strstr : for : 			return rq; : 
2
strstr : while : 			return rq; : 
2
str : 		raw_spin_unlock(&rq->lock);[29]
strstr : INIT : 		raw_spin_unlock(&rq->lock); : 
2
strstr : if : 		raw_spin_unlock(&rq->lock); : 
2
strstr : for : 		raw_spin_unlock(&rq->lock); : 
2
strstr : while : 		raw_spin_unlock(&rq->lock); : 
2
str : 		raw_spin_unlock_irqrestore(&p->pi_lock, *flags);[50]
strstr : INIT : 		raw_spin_unlock_irqrestore(&p->pi_lock, *flags); : 
2
strstr : if : 		raw_spin_unlock_irqrestore(&p->pi_lock, *flags); : 
2
strstr : for : 		raw_spin_unlock_irqrestore(&p->pi_lock, *flags); : 
2
strstr : while : 		raw_spin_unlock_irqrestore(&p->pi_lock, *flags); : 
2
str : static void __task_rq_unlock(struct rq *rq)[43]
strstr : INIT : static void __task_rq_unlock(struct rq *rq) : 
2
strstr : if : static void __task_rq_unlock(struct rq *rq) : 
2
strstr : for : static void __task_rq_unlock(struct rq *rq) : 
2
strstr : while : static void __task_rq_unlock(struct rq *rq) : 
2
str : 	__releases(rq->lock)[21]
strstr : INIT : 	__releases(rq->lock) : 
2
strstr : if : 	__releases(rq->lock) : 
2
strstr : for : 	__releases(rq->lock) : 
2
strstr : while : 	__releases(rq->lock) : 
2
str : 	raw_spin_unlock(&rq->lock);[28]
strstr : INIT : 	raw_spin_unlock(&rq->lock); : 
2
strstr : if : 	raw_spin_unlock(&rq->lock); : 
2
strstr : for : 	raw_spin_unlock(&rq->lock); : 
2
strstr : while : 	raw_spin_unlock(&rq->lock); : 
2
str : static inline void[18]
strstr : INIT : static inline void : 
2
strstr : if : static inline void : 
2
strstr : for : static inline void : 
2
strstr : while : static inline void : 
2
str : task_rq_unlock(struct rq *rq, struct task_struct *p, unsigned long *flags)[74]
strstr : INIT : task_rq_unlock(struct rq *rq, struct task_struct *p, unsigned long *flags) : 
2
strstr : if : task_rq_unlock(struct rq *rq, struct task_struct *p, unsigned long *flags) : 
2
strstr : for : task_rq_unlock(struct rq *rq, struct task_struct *p, unsigned long *flags) : 
2
strstr : while : task_rq_unlock(struct rq *rq, struct task_struct *p, unsigned long *flags) : 
2
str : 	__releases(rq->lock)[21]
strstr : INIT : 	__releases(rq->lock) : 
2
strstr : if : 	__releases(rq->lock) : 
2
strstr : for : 	__releases(rq->lock) : 
2
strstr : while : 	__releases(rq->lock) : 
2
str : 	__releases(p->pi_lock)[23]
strstr : INIT : 	__releases(p->pi_lock) : 
2
strstr : if : 	__releases(p->pi_lock) : 
2
strstr : for : 	__releases(p->pi_lock) : 
2
strstr : while : 	__releases(p->pi_lock) : 
2
str : 	raw_spin_unlock(&rq->lock);[28]
strstr : INIT : 	raw_spin_unlock(&rq->lock); : 
2
strstr : if : 	raw_spin_unlock(&rq->lock); : 
2
strstr : for : 	raw_spin_unlock(&rq->lock); : 
2
strstr : while : 	raw_spin_unlock(&rq->lock); : 
2
str : 	raw_spin_unlock_irqrestore(&p->pi_lock, *flags);[49]
strstr : INIT : 	raw_spin_unlock_irqrestore(&p->pi_lock, *flags); : 
2
strstr : if : 	raw_spin_unlock_irqrestore(&p->pi_lock, *flags); : 
2
strstr : for : 	raw_spin_unlock_irqrestore(&p->pi_lock, *flags); : 
2
strstr : while : 	raw_spin_unlock_irqrestore(&p->pi_lock, *flags); : 
2
str :  * this_rq_lock - lock this runqueue and disable interrupts.[60]
strstr : INIT :  * this_rq_lock - lock this runqueue and disable interrupts. : 
2
strstr : if :  * this_rq_lock - lock this runqueue and disable interrupts. : 
2
strstr : for :  * this_rq_lock - lock this runqueue and disable interrupts. : 
2
strstr : while :  * this_rq_lock - lock this runqueue and disable interrupts. : 
2
str :  */[3]
strstr : INIT :  */ : 
2
strstr : if :  */ : 
2
strstr : for :  */ : 
2
strstr : while :  */ : 
2
str : static struct rq *this_rq_lock(void)[36]
strstr : INIT : static struct rq *this_rq_lock(void) : 
2
strstr : if : static struct rq *this_rq_lock(void) : 
2
strstr : for : static struct rq *this_rq_lock(void) : 
2
strstr : while : static struct rq *this_rq_lock(void) : 
2
str : 	__acquires(rq->lock)[21]
strstr : INIT : 	__acquires(rq->lock) : 
2
strstr : if : 	__acquires(rq->lock) : 
2
strstr : for : 	__acquires(rq->lock) : 
2
strstr : while : 	__acquires(rq->lock) : 
2
str : 	struct rq *rq;[15]
strstr : INIT : 	struct rq *rq; : 
2
strstr : if : 	struct rq *rq; : 
2
strstr : for : 	struct rq *rq; : 
2
strstr : while : 	struct rq *rq; : 
2
str : 	local_irq_disable();[21]
strstr : INIT : 	local_irq_disable(); : 
2
strstr : if : 	local_irq_disable(); : 
2
strstr : for : 	local_irq_disable(); : 
2
strstr : while : 	local_irq_disable(); : 
2
str : 	rq = this_rq();[16]
strstr : INIT : 	rq = this_rq(); : 
2
strstr : if : 	rq = this_rq(); : 
2
strstr : for : 	rq = this_rq(); : 
2
strstr : while : 	rq = this_rq(); : 
2
str : 	raw_spin_lock(&rq->lock);[26]
strstr : INIT : 	raw_spin_lock(&rq->lock); : 
2
strstr : if : 	raw_spin_lock(&rq->lock); : 
2
strstr : for : 	raw_spin_lock(&rq->lock); : 
2
strstr : while : 	raw_spin_lock(&rq->lock); : 
2
str : 	return rq;[11]
strstr : INIT : 	return rq; : 
2
strstr : if : 	return rq; : 
2
strstr : for : 	return rq; : 
2
strstr : while : 	return rq; : 
2
str : #ifdef CONFIG_SCHED_HRTICK[26]
strstr : INIT : #ifdef CONFIG_SCHED_HRTICK : 
2
strstr : if : #ifdef CONFIG_SCHED_HRTICK : 
2
strstr : for : #ifdef CONFIG_SCHED_HRTICK : 
2
strstr : while : #ifdef CONFIG_SCHED_HRTICK : 
2
str :  * Use HR-timers to deliver accurate preemption points.[55]
strstr : INIT :  * Use HR-timers to deliver accurate preemption points. : 
2
strstr : if :  * Use HR-timers to deliver accurate preemption points. : 
2
strstr : for :  * Use HR-timers to deliver accurate preemption points. : 
2
strstr : while :  * Use HR-timers to deliver accurate preemption points. : 
2
str :  */[3]
strstr : INIT :  */ : 
2
strstr : if :  */ : 
2
strstr : for :  */ : 
2
strstr : while :  */ : 
2
str : static void hrtick_clear(struct rq *rq)[39]
strstr : INIT : static void hrtick_clear(struct rq *rq) : 
2
strstr : if : static void hrtick_clear(struct rq *rq) : 
2
strstr : for : static void hrtick_clear(struct rq *rq) : 
2
strstr : while : static void hrtick_clear(struct rq *rq) : 
2
str : 	if (hrtimer_active(&rq->hrtick_timer))[39]
strstr : INIT : 	if (hrtimer_active(&rq->hrtick_timer)) : 
2
strstr : if : 	if (hrtimer_active(&rq->hrtick_timer)) : 
2
strstr : for : 	if (hrtimer_active(&rq->hrtick_timer)) : 
2
strstr : while : 	if (hrtimer_active(&rq->hrtick_timer)) : 
2
str : 		hrtimer_cancel(&rq->hrtick_timer);[36]
strstr : INIT : 		hrtimer_cancel(&rq->hrtick_timer); : 
2
strstr : if : 		hrtimer_cancel(&rq->hrtick_timer); : 
2
strstr : for : 		hrtimer_cancel(&rq->hrtick_timer); : 
2
strstr : while : 		hrtimer_cancel(&rq->hrtick_timer); : 
2
str :  * High-resolution timer tick.[30]
strstr : INIT :  * High-resolution timer tick. : 
2
strstr : if :  * High-resolution timer tick. : 
2
strstr : for :  * High-resolution timer tick. : 
2
strstr : while :  * High-resolution timer tick. : 
2
str :  * Runs from hardirq context with interrupts disabled.[54]
strstr : INIT :  * Runs from hardirq context with interrupts disabled. : 
2
strstr : if :  * Runs from hardirq context with interrupts disabled. : 
2
strstr : for :  * Runs from hardirq context with interrupts disabled. : 
2
strstr : while :  * Runs from hardirq context with interrupts disabled. : 
2
str :  */[3]
strstr : INIT :  */ : 
2
strstr : if :  */ : 
2
strstr : for :  */ : 
2
strstr : while :  */ : 
2
str : static enum hrtimer_restart hrtick(struct hrtimer *timer)[57]
strstr : INIT : static enum hrtimer_restart hrtick(struct hrtimer *timer) : 
2
strstr : if : static enum hrtimer_restart hrtick(struct hrtimer *timer) : 
2
strstr : for : static enum hrtimer_restart hrtick(struct hrtimer *timer) : 
2
strstr : while : static enum hrtimer_restart hrtick(struct hrtimer *timer) : 
2
str : 	struct rq *rq = container_of(timer, struct rq, hrtick_timer);[62]
strstr : INIT : 	struct rq *rq = container_of(timer, struct rq, hrtick_timer); : 
2
strstr : if : 	struct rq *rq = container_of(timer, struct rq, hrtick_timer); : 
2
strstr : for : 	struct rq *rq = container_of(timer, struct rq, hrtick_timer); : 
2
strstr : while : 	struct rq *rq = container_of(timer, struct rq, hrtick_timer); : 
2
str : 	WARN_ON_ONCE(cpu_of(rq) != smp_processor_id());[48]
strstr : INIT : 	WARN_ON_ONCE(cpu_of(rq) != smp_processor_id()); : 
2
strstr : if : 	WARN_ON_ONCE(cpu_of(rq) != smp_processor_id()); : 
2
strstr : for : 	WARN_ON_ONCE(cpu_of(rq) != smp_processor_id()); : 
2
strstr : while : 	WARN_ON_ONCE(cpu_of(rq) != smp_processor_id()); : 
2
str : 	raw_spin_lock(&rq->lock);[26]
strstr : INIT : 	raw_spin_lock(&rq->lock); : 
2
strstr : if : 	raw_spin_lock(&rq->lock); : 
2
strstr : for : 	raw_spin_lock(&rq->lock); : 
2
strstr : while : 	raw_spin_lock(&rq->lock); : 
2
str : 	update_rq_clock(rq);[21]
strstr : INIT : 	update_rq_clock(rq); : 
2
strstr : if : 	update_rq_clock(rq); : 
2
strstr : for : 	update_rq_clock(rq); : 
2
strstr : while : 	update_rq_clock(rq); : 
2
str : 	rq->curr->sched_class->task_tick(rq, rq->curr, 1);[51]
strstr : INIT : 	rq->curr->sched_class->task_tick(rq, rq->curr, 1); : 
2
strstr : if : 	rq->curr->sched_class->task_tick(rq, rq->curr, 1); : 
2
strstr : for : 	rq->curr->sched_class->task_tick(rq, rq->curr, 1); : 
2
strstr : while : 	rq->curr->sched_class->task_tick(rq, rq->curr, 1); : 
2
str : 	raw_spin_unlock(&rq->lock);[28]
strstr : INIT : 	raw_spin_unlock(&rq->lock); : 
2
strstr : if : 	raw_spin_unlock(&rq->lock); : 
2
strstr : for : 	raw_spin_unlock(&rq->lock); : 
2
strstr : while : 	raw_spin_unlock(&rq->lock); : 
2
str : 	return HRTIMER_NORESTART;[26]
strstr : INIT : 	return HRTIMER_NORESTART; : 
2
strstr : if : 	return HRTIMER_NORESTART; : 
2
strstr : for : 	return HRTIMER_NORESTART; : 
2
strstr : while : 	return HRTIMER_NORESTART; : 
2
str : #ifdef CONFIG_SMP[17]
strstr : INIT : #ifdef CONFIG_SMP : 
2
strstr : if : #ifdef CONFIG_SMP : 
2
strstr : for : #ifdef CONFIG_SMP : 
2
strstr : while : #ifdef CONFIG_SMP : 
2
str : static int __hrtick_restart(struct rq *rq)[42]
strstr : INIT : static int __hrtick_restart(struct rq *rq) : 
2
strstr : if : static int __hrtick_restart(struct rq *rq) : 
2
strstr : for : static int __hrtick_restart(struct rq *rq) : 
2
strstr : while : static int __hrtick_restart(struct rq *rq) : 
2
str : 	struct hrtimer *timer = &rq->hrtick_timer;[43]
strstr : INIT : 	struct hrtimer *timer = &rq->hrtick_timer; : 
2
strstr : if : 	struct hrtimer *timer = &rq->hrtick_timer; : 
2
strstr : for : 	struct hrtimer *timer = &rq->hrtick_timer; : 
2
strstr : while : 	struct hrtimer *timer = &rq->hrtick_timer; : 
2
str : 	ktime_t time = hrtimer_get_softexpires(timer);[47]
strstr : INIT : 	ktime_t time = hrtimer_get_softexpires(timer); : 
2
strstr : if : 	ktime_t time = hrtimer_get_softexpires(timer); : 
2
strstr : for : 	ktime_t time = hrtimer_get_softexpires(timer); : 
2
strstr : while : 	ktime_t time = hrtimer_get_softexpires(timer); : 
2
str : 	return __hrtimer_start_range_ns(timer, time, 0, HRTIMER_MODE_ABS_PINNED, 0);[77]
strstr : INIT : 	return __hrtimer_start_range_ns(timer, time, 0, HRTIMER_MODE_ABS_PINNED, 0); : 
2
strstr : if : 	return __hrtimer_start_range_ns(timer, time, 0, HRTIMER_MODE_ABS_PINNED, 0); : 
2
strstr : for : 	return __hrtimer_start_range_ns(timer, time, 0, HRTIMER_MODE_ABS_PINNED, 0); : 
2
strstr : while : 	return __hrtimer_start_range_ns(timer, time, 0, HRTIMER_MODE_ABS_PINNED, 0); : 
2
str :  * called from hardirq (IPI) context[36]
strstr : INIT :  * called from hardirq (IPI) context : 
2
strstr : if :  * called from hardirq (IPI) context : 
2
strstr : for :  * called from hardirq (IPI) context : 
2
strstr : while :  * called from hardirq (IPI) context : 
2
str :  */[3]
strstr : INIT :  */ : 
2
strstr : if :  */ : 
2
strstr : for :  */ : 
2
strstr : while :  */ : 
2
str : static void __hrtick_start(void *arg)[37]
strstr : INIT : static void __hrtick_start(void *arg) : 
2
strstr : if : static void __hrtick_start(void *arg) : 
2
strstr : for : static void __hrtick_start(void *arg) : 
2
strstr : while : static void __hrtick_start(void *arg) : 
2
str : 	struct rq *rq = arg;[21]
strstr : INIT : 	struct rq *rq = arg; : 
2
strstr : if : 	struct rq *rq = arg; : 
2
strstr : for : 	struct rq *rq = arg; : 
2
strstr : while : 	struct rq *rq = arg; : 
2
str : 	raw_spin_lock(&rq->lock);[26]
strstr : INIT : 	raw_spin_lock(&rq->lock); : 
2
strstr : if : 	raw_spin_lock(&rq->lock); : 
2
strstr : for : 	raw_spin_lock(&rq->lock); : 
2
strstr : while : 	raw_spin_lock(&rq->lock); : 
2
str : 	__hrtick_restart(rq);[22]
strstr : INIT : 	__hrtick_restart(rq); : 
2
strstr : if : 	__hrtick_restart(rq); : 
2
strstr : for : 	__hrtick_restart(rq); : 
2
strstr : while : 	__hrtick_restart(rq); : 
2
str : 	rq->hrtick_csd_pending = 0;[28]
strstr : INIT : 	rq->hrtick_csd_pending = 0; : 
2
strstr : if : 	rq->hrtick_csd_pending = 0; : 
2
strstr : for : 	rq->hrtick_csd_pending = 0; : 
2
strstr : while : 	rq->hrtick_csd_pending = 0; : 
2
str : 	raw_spin_unlock(&rq->lock);[28]
strstr : INIT : 	raw_spin_unlock(&rq->lock); : 
2
strstr : if : 	raw_spin_unlock(&rq->lock); : 
2
strstr : for : 	raw_spin_unlock(&rq->lock); : 
2
strstr : while : 	raw_spin_unlock(&rq->lock); : 
2
str :  * Called to set the hrtick timer state.[40]
strstr : INIT :  * Called to set the hrtick timer state. : 
2
strstr : if :  * Called to set the hrtick timer state. : 
2
strstr : for :  * Called to set the hrtick timer state. : 
2
strstr : while :  * Called to set the hrtick timer state. : 
2
str :  * called with rq->lock held and irqs disabled[46]
strstr : INIT :  * called with rq->lock held and irqs disabled : 
2
strstr : if :  * called with rq->lock held and irqs disabled : 
2
strstr : for :  * called with rq->lock held and irqs disabled : 
2
strstr : while :  * called with rq->lock held and irqs disabled : 
2
str :  */[3]
strstr : INIT :  */ : 
2
strstr : if :  */ : 
2
strstr : for :  */ : 
2
strstr : while :  */ : 
2
str : void hrtick_start(struct rq *rq, u64 delay)[43]
strstr : INIT : void hrtick_start(struct rq *rq, u64 delay) : 
2
strstr : if : void hrtick_start(struct rq *rq, u64 delay) : 
2
strstr : for : void hrtick_start(struct rq *rq, u64 delay) : 
2
strstr : while : void hrtick_start(struct rq *rq, u64 delay) : 
2
str : 	struct hrtimer *timer = &rq->hrtick_timer;[43]
strstr : INIT : 	struct hrtimer *timer = &rq->hrtick_timer; : 
2
strstr : if : 	struct hrtimer *timer = &rq->hrtick_timer; : 
2
strstr : for : 	struct hrtimer *timer = &rq->hrtick_timer; : 
2
strstr : while : 	struct hrtimer *timer = &rq->hrtick_timer; : 
2
str : 	ktime_t time = ktime_add_ns(timer->base->get_time(), delay);[61]
strstr : INIT : 	ktime_t time = ktime_add_ns(timer->base->get_time(), delay); : 
2
strstr : if : 	ktime_t time = ktime_add_ns(timer->base->get_time(), delay); : 
2
strstr : for : 	ktime_t time = ktime_add_ns(timer->base->get_time(), delay); : 
2
strstr : while : 	ktime_t time = ktime_add_ns(timer->base->get_time(), delay); : 
2
str : 	hrtimer_set_expires(timer, time);[34]
strstr : INIT : 	hrtimer_set_expires(timer, time); : 
2
strstr : if : 	hrtimer_set_expires(timer, time); : 
2
strstr : for : 	hrtimer_set_expires(timer, time); : 
2
strstr : while : 	hrtimer_set_expires(timer, time); : 
2
str : 	if (rq == this_rq()) {[23]
strstr : INIT : 	if (rq == this_rq()) { : 
2
strstr : if : 	if (rq == this_rq()) { : 
2
strstr : for : 	if (rq == this_rq()) { : 
2
strstr : while : 	if (rq == this_rq()) { : 
2
str : 		__hrtick_restart(rq);[23]
strstr : INIT : 		__hrtick_restart(rq); : 
2
strstr : if : 		__hrtick_restart(rq); : 
2
strstr : for : 		__hrtick_restart(rq); : 
2
strstr : while : 		__hrtick_restart(rq); : 
2
str : 	} else if (!rq->hrtick_csd_pending) {[38]
strstr : INIT : 	} else if (!rq->hrtick_csd_pending) { : 
2
strstr : if : 	} else if (!rq->hrtick_csd_pending) { : 
2
strstr : for : 	} else if (!rq->hrtick_csd_pending) { : 
2
strstr : while : 	} else if (!rq->hrtick_csd_pending) { : 
2
str : 		__smp_call_function_single(cpu_of(rq), &rq->hrtick_csd, 0);[61]
strstr : INIT : 		__smp_call_function_single(cpu_of(rq), &rq->hrtick_csd, 0); : 
2
strstr : if : 		__smp_call_function_single(cpu_of(rq), &rq->hrtick_csd, 0); : 
2
strstr : for : 		__smp_call_function_single(cpu_of(rq), &rq->hrtick_csd, 0); : 
2
strstr : while : 		__smp_call_function_single(cpu_of(rq), &rq->hrtick_csd, 0); : 
2
str : 		rq->hrtick_csd_pending = 1;[29]
strstr : INIT : 		rq->hrtick_csd_pending = 1; : 
2
strstr : if : 		rq->hrtick_csd_pending = 1; : 
2
strstr : for : 		rq->hrtick_csd_pending = 1; : 
2
strstr : while : 		rq->hrtick_csd_pending = 1; : 
2
str : static int[10]
strstr : INIT : static int : 
2
strstr : if : static int : 
2
strstr : for : static int : 
2
strstr : while : static int : 
2
str : hotplug_hrtick(struct notifier_block *nfb, unsigned long action, void *hcpu)[76]
strstr : INIT : hotplug_hrtick(struct notifier_block *nfb, unsigned long action, void *hcpu) : 
2
strstr : if : hotplug_hrtick(struct notifier_block *nfb, unsigned long action, void *hcpu) : 
2
strstr : for : hotplug_hrtick(struct notifier_block *nfb, unsigned long action, void *hcpu) : 
2
strstr : while : hotplug_hrtick(struct notifier_block *nfb, unsigned long action, void *hcpu) : 
2
str : 	int cpu = (int)(long)hcpu;[27]
strstr : INIT : 	int cpu = (int)(long)hcpu; : 
2
strstr : if : 	int cpu = (int)(long)hcpu; : 
2
strstr : for : 	int cpu = (int)(long)hcpu; : 
2
strstr : while : 	int cpu = (int)(long)hcpu; : 
2
str : 	switch (action) {[18]
strstr : INIT : 	switch (action) { : 
2
strstr : if : 	switch (action) { : 
2
strstr : for : 	switch (action) { : 
2
strstr : while : 	switch (action) { : 
2
str : 	case CPU_UP_CANCELED:[22]
strstr : INIT : 	case CPU_UP_CANCELED: : 
2
strstr : if : 	case CPU_UP_CANCELED: : 
2
strstr : for : 	case CPU_UP_CANCELED: : 
2
strstr : while : 	case CPU_UP_CANCELED: : 
2
str : 	case CPU_UP_CANCELED_FROZEN:[29]
strstr : INIT : 	case CPU_UP_CANCELED_FROZEN: : 
2
strstr : if : 	case CPU_UP_CANCELED_FROZEN: : 
2
strstr : for : 	case CPU_UP_CANCELED_FROZEN: : 
2
strstr : while : 	case CPU_UP_CANCELED_FROZEN: : 
2
str : 	case CPU_DOWN_PREPARE:[23]
strstr : INIT : 	case CPU_DOWN_PREPARE: : 
2
strstr : if : 	case CPU_DOWN_PREPARE: : 
2
strstr : for : 	case CPU_DOWN_PREPARE: : 
2
strstr : while : 	case CPU_DOWN_PREPARE: : 
2
str : 	case CPU_DOWN_PREPARE_FROZEN:[30]
strstr : INIT : 	case CPU_DOWN_PREPARE_FROZEN: : 
2
strstr : if : 	case CPU_DOWN_PREPARE_FROZEN: : 
2
strstr : for : 	case CPU_DOWN_PREPARE_FROZEN: : 
2
strstr : while : 	case CPU_DOWN_PREPARE_FROZEN: : 
2
str : 	case CPU_DEAD:[15]
strstr : INIT : 	case CPU_DEAD: : 
2
strstr : if : 	case CPU_DEAD: : 
2
strstr : for : 	case CPU_DEAD: : 
2
strstr : while : 	case CPU_DEAD: : 
2
str : 	case CPU_DEAD_FROZEN:[22]
strstr : INIT : 	case CPU_DEAD_FROZEN: : 
2
strstr : if : 	case CPU_DEAD_FROZEN: : 
2
strstr : for : 	case CPU_DEAD_FROZEN: : 
2
strstr : while : 	case CPU_DEAD_FROZEN: : 
2
str : 		hrtick_clear(cpu_rq(cpu));[28]
strstr : INIT : 		hrtick_clear(cpu_rq(cpu)); : 
2
strstr : if : 		hrtick_clear(cpu_rq(cpu)); : 
2
strstr : for : 		hrtick_clear(cpu_rq(cpu)); : 
2
strstr : while : 		hrtick_clear(cpu_rq(cpu)); : 
2
str : 		return NOTIFY_OK;[19]
strstr : INIT : 		return NOTIFY_OK; : 
2
strstr : if : 		return NOTIFY_OK; : 
2
strstr : for : 		return NOTIFY_OK; : 
2
strstr : while : 		return NOTIFY_OK; : 
2
str : 	return NOTIFY_DONE;[20]
strstr : INIT : 	return NOTIFY_DONE; : 
2
strstr : if : 	return NOTIFY_DONE; : 
2
strstr : for : 	return NOTIFY_DONE; : 
2
strstr : while : 	return NOTIFY_DONE; : 
2
str : static __init void init_hrtick(void)[36]
strstr : INIT : static __init void init_hrtick(void) : 
2
strstr : if : static __init void init_hrtick(void) : 
2
strstr : for : static __init void init_hrtick(void) : 
2
strstr : while : static __init void init_hrtick(void) : 
2
str : 	hotcpu_notifier(hotplug_hrtick, 0);[36]
strstr : INIT : 	hotcpu_notifier(hotplug_hrtick, 0); : 
2
strstr : if : 	hotcpu_notifier(hotplug_hrtick, 0); : 
2
strstr : for : 	hotcpu_notifier(hotplug_hrtick, 0); : 
2
strstr : while : 	hotcpu_notifier(hotplug_hrtick, 0); : 
2
str : #else[5]
strstr : INIT : #else : 
2
strstr : if : #else : 
2
strstr : for : #else : 
2
strstr : while : #else : 
2
str :  * Called to set the hrtick timer state.[40]
strstr : INIT :  * Called to set the hrtick timer state. : 
2
strstr : if :  * Called to set the hrtick timer state. : 
2
strstr : for :  * Called to set the hrtick timer state. : 
2
strstr : while :  * Called to set the hrtick timer state. : 
2
str :  * called with rq->lock held and irqs disabled[46]
strstr : INIT :  * called with rq->lock held and irqs disabled : 
2
strstr : if :  * called with rq->lock held and irqs disabled : 
2
strstr : for :  * called with rq->lock held and irqs disabled : 
2
strstr : while :  * called with rq->lock held and irqs disabled : 
2
str :  */[3]
strstr : INIT :  */ : 
2
strstr : if :  */ : 
2
strstr : for :  */ : 
2
strstr : while :  */ : 
2
str : void hrtick_start(struct rq *rq, u64 delay)[43]
strstr : INIT : void hrtick_start(struct rq *rq, u64 delay) : 
2
strstr : if : void hrtick_start(struct rq *rq, u64 delay) : 
2
strstr : for : void hrtick_start(struct rq *rq, u64 delay) : 
2
strstr : while : void hrtick_start(struct rq *rq, u64 delay) : 
2
str : 	__hrtimer_start_range_ns(&rq->hrtick_timer, ns_to_ktime(delay), 0,[67]
strstr : INIT : 	__hrtimer_start_range_ns(&rq->hrtick_timer, ns_to_ktime(delay), 0, : 
2
strstr : if : 	__hrtimer_start_range_ns(&rq->hrtick_timer, ns_to_ktime(delay), 0, : 
2
strstr : for : 	__hrtimer_start_range_ns(&rq->hrtick_timer, ns_to_ktime(delay), 0, : 
2
strstr : while : 	__hrtimer_start_range_ns(&rq->hrtick_timer, ns_to_ktime(delay), 0, : 
2
str : 			HRTIMER_MODE_REL_PINNED, 0);[31]
strstr : INIT : 			HRTIMER_MODE_REL_PINNED, 0); : 
2
strstr : if : 			HRTIMER_MODE_REL_PINNED, 0); : 
2
strstr : for : 			HRTIMER_MODE_REL_PINNED, 0); : 
2
strstr : while : 			HRTIMER_MODE_REL_PINNED, 0); : 
2
str : static inline void init_hrtick(void)[36]
strstr : INIT : static inline void init_hrtick(void) : 
2
strstr : if : static inline void init_hrtick(void) : 
2
strstr : for : static inline void init_hrtick(void) : 
2
strstr : while : static inline void init_hrtick(void) : 
2
str : #endif /* CONFIG_SMP */[23]
strstr : INIT : #endif /* CONFIG_SMP */ : 
2
strstr : if : #endif /* CONFIG_SMP */ : 
2
strstr : for : #endif /* CONFIG_SMP */ : 
2
strstr : while : #endif /* CONFIG_SMP */ : 
2
str : static void init_rq_hrtick(struct rq *rq)[41]
strstr : INIT : static void init_rq_hrtick(struct rq *rq) : 
2
strstr : if : static void init_rq_hrtick(struct rq *rq) : 
2
strstr : for : static void init_rq_hrtick(struct rq *rq) : 
2
strstr : while : static void init_rq_hrtick(struct rq *rq) : 
2
str : #ifdef CONFIG_SMP[17]
strstr : INIT : #ifdef CONFIG_SMP : 
2
strstr : if : #ifdef CONFIG_SMP : 
2
strstr : for : #ifdef CONFIG_SMP : 
2
strstr : while : #ifdef CONFIG_SMP : 
2
str : 	rq->hrtick_csd_pending = 0;[28]
strstr : INIT : 	rq->hrtick_csd_pending = 0; : 
2
strstr : if : 	rq->hrtick_csd_pending = 0; : 
2
strstr : for : 	rq->hrtick_csd_pending = 0; : 
2
strstr : while : 	rq->hrtick_csd_pending = 0; : 
2
str : 	rq->hrtick_csd.flags = 0;[26]
strstr : INIT : 	rq->hrtick_csd.flags = 0; : 
2
strstr : if : 	rq->hrtick_csd.flags = 0; : 
2
strstr : for : 	rq->hrtick_csd.flags = 0; : 
2
strstr : while : 	rq->hrtick_csd.flags = 0; : 
2
str : 	rq->hrtick_csd.func = __hrtick_start;[38]
strstr : INIT : 	rq->hrtick_csd.func = __hrtick_start; : 
2
strstr : if : 	rq->hrtick_csd.func = __hrtick_start; : 
2
strstr : for : 	rq->hrtick_csd.func = __hrtick_start; : 
2
strstr : while : 	rq->hrtick_csd.func = __hrtick_start; : 
2
str : 	rq->hrtick_csd.info = rq;[26]
strstr : INIT : 	rq->hrtick_csd.info = rq; : 
2
strstr : if : 	rq->hrtick_csd.info = rq; : 
2
strstr : for : 	rq->hrtick_csd.info = rq; : 
2
strstr : while : 	rq->hrtick_csd.info = rq; : 
2
str : #endif[6]
strstr : INIT : #endif : 
2
strstr : if : #endif : 
2
strstr : for : #endif : 
2
strstr : while : #endif : 
2
str : 	hrtimer_init(&rq->hrtick_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);[68]
strstr : INIT : 	hrtimer_init(&rq->hrtick_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL); : 
2
strstr : if : 	hrtimer_init(&rq->hrtick_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL); : 
2
strstr : for : 	hrtimer_init(&rq->hrtick_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL); : 
2
strstr : while : 	hrtimer_init(&rq->hrtick_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL); : 
2
str : 	rq->hrtick_timer.function = hrtick;[36]
strstr : INIT : 	rq->hrtick_timer.function = hrtick; : 
2
strstr : if : 	rq->hrtick_timer.function = hrtick; : 
2
strstr : for : 	rq->hrtick_timer.function = hrtick; : 
2
strstr : while : 	rq->hrtick_timer.function = hrtick; : 
2
str : #else	/* CONFIG_SCHED_HRTICK */[31]
strstr : INIT : #else	/* CONFIG_SCHED_HRTICK */ : 
2
strstr : if : #else	/* CONFIG_SCHED_HRTICK */ : 
2
strstr : for : #else	/* CONFIG_SCHED_HRTICK */ : 
2
strstr : while : #else	/* CONFIG_SCHED_HRTICK */ : 
2
str : static inline void hrtick_clear(struct rq *rq)[46]
strstr : INIT : static inline void hrtick_clear(struct rq *rq) : 
2
strstr : if : static inline void hrtick_clear(struct rq *rq) : 
2
strstr : for : static inline void hrtick_clear(struct rq *rq) : 
2
strstr : while : static inline void hrtick_clear(struct rq *rq) : 
2
str : static inline void init_rq_hrtick(struct rq *rq)[48]
strstr : INIT : static inline void init_rq_hrtick(struct rq *rq) : 
2
strstr : if : static inline void init_rq_hrtick(struct rq *rq) : 
2
strstr : for : static inline void init_rq_hrtick(struct rq *rq) : 
2
strstr : while : static inline void init_rq_hrtick(struct rq *rq) : 
2
str : static inline void init_hrtick(void)[36]
strstr : INIT : static inline void init_hrtick(void) : 
2
strstr : if : static inline void init_hrtick(void) : 
2
strstr : for : static inline void init_hrtick(void) : 
2
strstr : while : static inline void init_hrtick(void) : 
2
str : #endif	/* CONFIG_SCHED_HRTICK */[32]
strstr : INIT : #endif	/* CONFIG_SCHED_HRTICK */ : 
2
strstr : if : #endif	/* CONFIG_SCHED_HRTICK */ : 
2
strstr : for : #endif	/* CONFIG_SCHED_HRTICK */ : 
2
strstr : while : #endif	/* CONFIG_SCHED_HRTICK */ : 
2
str :  * resched_task - mark a task 'to be rescheduled now'.[54]
strstr : INIT :  * resched_task - mark a task 'to be rescheduled now'. : 
2
strstr : if :  * resched_task - mark a task 'to be rescheduled now'. : 
2
strstr : for :  * resched_task - mark a task 'to be rescheduled now'. : 
2
strstr : while :  * resched_task - mark a task 'to be rescheduled now'. : 
2
str :  * On UP this means the setting of the need_resched flag, on SMP it[67]
strstr : INIT :  * On UP this means the setting of the need_resched flag, on SMP it : 
2
strstr : if :  * On UP this means the setting of the need_resched flag, on SMP it : 
2
strstr : for :  * On UP this means the setting of the need_resched flag, on SMP it : 
2
strstr : while :  * On UP this means the setting of the need_resched flag, on SMP it : 
2
str :  * might also involve a cross-CPU call to trigger the scheduler on[66]
strstr : INIT :  * might also involve a cross-CPU call to trigger the scheduler on : 
2
strstr : if :  * might also involve a cross-CPU call to trigger the scheduler on : 
2
strstr : for :  * might also involve a cross-CPU call to trigger the scheduler on : 
2
strstr : while :  * might also involve a cross-CPU call to trigger the scheduler on : 
2
str :  * the target CPU.[18]
strstr : INIT :  * the target CPU. : 
2
strstr : if :  * the target CPU. : 
2
strstr : for :  * the target CPU. : 
2
strstr : while :  * the target CPU. : 
2
str :  */[3]
strstr : INIT :  */ : 
2
strstr : if :  */ : 
2
strstr : for :  */ : 
2
strstr : while :  */ : 
2
str : void resched_task(struct task_struct *p)[40]
strstr : INIT : void resched_task(struct task_struct *p) : 
2
strstr : if : void resched_task(struct task_struct *p) : 
2
strstr : for : void resched_task(struct task_struct *p) : 
2
strstr : while : void resched_task(struct task_struct *p) : 
2
str : 	int cpu;[9]
strstr : INIT : 	int cpu; : 
2
strstr : if : 	int cpu; : 
2
strstr : for : 	int cpu; : 
2
strstr : while : 	int cpu; : 
2
str : 	lockdep_assert_held(&task_rq(p)->lock);[40]
strstr : INIT : 	lockdep_assert_held(&task_rq(p)->lock); : 
2
strstr : if : 	lockdep_assert_held(&task_rq(p)->lock); : 
2
strstr : for : 	lockdep_assert_held(&task_rq(p)->lock); : 
2
strstr : while : 	lockdep_assert_held(&task_rq(p)->lock); : 
2
str : 	if (test_tsk_need_resched(p))[30]
strstr : INIT : 	if (test_tsk_need_resched(p)) : 
2
strstr : if : 	if (test_tsk_need_resched(p)) : 
2
strstr : for : 	if (test_tsk_need_resched(p)) : 
2
strstr : while : 	if (test_tsk_need_resched(p)) : 
2
str : 		return;[9]
strstr : INIT : 		return; : 
2
strstr : if : 		return; : 
2
strstr : for : 		return; : 
2
strstr : while : 		return; : 
2
str : 	set_tsk_need_resched(p);[25]
strstr : INIT : 	set_tsk_need_resched(p); : 
2
strstr : if : 	set_tsk_need_resched(p); : 
2
strstr : for : 	set_tsk_need_resched(p); : 
2
strstr : while : 	set_tsk_need_resched(p); : 
2
str : 	cpu = task_cpu(p);[19]
strstr : INIT : 	cpu = task_cpu(p); : 
2
strstr : if : 	cpu = task_cpu(p); : 
2
strstr : for : 	cpu = task_cpu(p); : 
2
strstr : while : 	cpu = task_cpu(p); : 
2
str : 	if (cpu == smp_processor_id()) {[33]
strstr : INIT : 	if (cpu == smp_processor_id()) { : 
2
strstr : if : 	if (cpu == smp_processor_id()) { : 
2
strstr : for : 	if (cpu == smp_processor_id()) { : 
2
strstr : while : 	if (cpu == smp_processor_id()) { : 
2
str : 		set_preempt_need_resched();[29]
strstr : INIT : 		set_preempt_need_resched(); : 
2
strstr : if : 		set_preempt_need_resched(); : 
2
strstr : for : 		set_preempt_need_resched(); : 
2
strstr : while : 		set_preempt_need_resched(); : 
2
str : 		return;[9]
strstr : INIT : 		return; : 
2
strstr : if : 		return; : 
2
strstr : for : 		return; : 
2
strstr : while : 		return; : 
2
str : 	/* NEED_RESCHED must be visible before we test polling */[58]
strstr : INIT : 	/* NEED_RESCHED must be visible before we test polling */ : 
2
strstr : if : 	/* NEED_RESCHED must be visible before we test polling */ : 
2
strstr : for : 	/* NEED_RESCHED must be visible before we test polling */ : 
2
strstr : while : 	/* NEED_RESCHED must be visible before we test polling */ : 
2
str : 	smp_mb();[10]
strstr : INIT : 	smp_mb(); : 
2
strstr : if : 	smp_mb(); : 
2
strstr : for : 	smp_mb(); : 
2
strstr : while : 	smp_mb(); : 
2
str : 	if (!tsk_is_polling(p))[24]
strstr : INIT : 	if (!tsk_is_polling(p)) : 
2
strstr : if : 	if (!tsk_is_polling(p)) : 
2
strstr : for : 	if (!tsk_is_polling(p)) : 
2
strstr : while : 	if (!tsk_is_polling(p)) : 
2
str : 		smp_send_reschedule(cpu);[27]
strstr : INIT : 		smp_send_reschedule(cpu); : 
2
strstr : if : 		smp_send_reschedule(cpu); : 
2
strstr : for : 		smp_send_reschedule(cpu); : 
2
strstr : while : 		smp_send_reschedule(cpu); : 
2
str : void resched_cpu(int cpu)[25]
strstr : INIT : void resched_cpu(int cpu) : 
2
strstr : if : void resched_cpu(int cpu) : 
2
strstr : for : void resched_cpu(int cpu) : 
2
strstr : while : void resched_cpu(int cpu) : 
2
str : 	struct rq *rq = cpu_rq(cpu);[29]
strstr : INIT : 	struct rq *rq = cpu_rq(cpu); : 
2
strstr : if : 	struct rq *rq = cpu_rq(cpu); : 
2
strstr : for : 	struct rq *rq = cpu_rq(cpu); : 
2
strstr : while : 	struct rq *rq = cpu_rq(cpu); : 
2
str : 	unsigned long flags;[21]
strstr : INIT : 	unsigned long flags; : 
2
strstr : if : 	unsigned long flags; : 
2
strstr : for : 	unsigned long flags; : 
2
strstr : while : 	unsigned long flags; : 
2
str : 	if (!raw_spin_trylock_irqsave(&rq->lock, flags))[49]
strstr : INIT : 	if (!raw_spin_trylock_irqsave(&rq->lock, flags)) : 
2
strstr : if : 	if (!raw_spin_trylock_irqsave(&rq->lock, flags)) : 
2
strstr : for : 	if (!raw_spin_trylock_irqsave(&rq->lock, flags)) : 
2
strstr : while : 	if (!raw_spin_trylock_irqsave(&rq->lock, flags)) : 
2
str : 		return;[9]
strstr : INIT : 		return; : 
2
strstr : if : 		return; : 
2
strstr : for : 		return; : 
2
strstr : while : 		return; : 
2
str : 	resched_task(cpu_curr(cpu));[29]
strstr : INIT : 	resched_task(cpu_curr(cpu)); : 
2
strstr : if : 	resched_task(cpu_curr(cpu)); : 
2
strstr : for : 	resched_task(cpu_curr(cpu)); : 
2
strstr : while : 	resched_task(cpu_curr(cpu)); : 
2
str : 	raw_spin_unlock_irqrestore(&rq->lock, flags);[46]
strstr : INIT : 	raw_spin_unlock_irqrestore(&rq->lock, flags); : 
2
strstr : if : 	raw_spin_unlock_irqrestore(&rq->lock, flags); : 
2
strstr : for : 	raw_spin_unlock_irqrestore(&rq->lock, flags); : 
2
strstr : while : 	raw_spin_unlock_irqrestore(&rq->lock, flags); : 
2
str : #ifdef CONFIG_SMP[17]
strstr : INIT : #ifdef CONFIG_SMP : 
2
strstr : if : #ifdef CONFIG_SMP : 
2
strstr : for : #ifdef CONFIG_SMP : 
2
strstr : while : #ifdef CONFIG_SMP : 
2
str : #ifdef CONFIG_NO_HZ_COMMON[26]
strstr : INIT : #ifdef CONFIG_NO_HZ_COMMON : 
2
strstr : if : #ifdef CONFIG_NO_HZ_COMMON : 
2
strstr : for : #ifdef CONFIG_NO_HZ_COMMON : 
2
strstr : while : #ifdef CONFIG_NO_HZ_COMMON : 
2
str :  * In the semi idle case, use the nearest busy cpu for migrating timers[71]
strstr : INIT :  * In the semi idle case, use the nearest busy cpu for migrating timers : 
2
strstr : if :  * In the semi idle case, use the nearest busy cpu for migrating timers : 
2
strstr : for :  * In the semi idle case, use the nearest busy cpu for migrating timers : 
2
strstr : while :  * In the semi idle case, use the nearest busy cpu for migrating timers : 
2
str :  * from an idle cpu.  This is good for power-savings.[53]
strstr : INIT :  * from an idle cpu.  This is good for power-savings. : 
2
strstr : if :  * from an idle cpu.  This is good for power-savings. : 
2
strstr : for :  * from an idle cpu.  This is good for power-savings. : 
2
strstr : while :  * from an idle cpu.  This is good for power-savings. : 
2
str :  * We don't do similar optimization for completely idle system, as[66]
strstr : INIT :  * We don't do similar optimization for completely idle system, as : 
2
strstr : if :  * We don't do similar optimization for completely idle system, as : 
2
strstr : for :  * We don't do similar optimization for completely idle system, as : 
2
strstr : while :  * We don't do similar optimization for completely idle system, as : 
2
str :  * selecting an idle cpu will add more delays to the timers than intended[73]
strstr : INIT :  * selecting an idle cpu will add more delays to the timers than intended : 
2
strstr : if :  * selecting an idle cpu will add more delays to the timers than intended : 
2
strstr : for :  * selecting an idle cpu will add more delays to the timers than intended : 
2
strstr : while :  * selecting an idle cpu will add more delays to the timers than intended : 
2
str :  * (as that cpu's timer base may not be uptodate wrt jiffies etc).[66]
strstr : INIT :  * (as that cpu's timer base may not be uptodate wrt jiffies etc). : 
2
strstr : if :  * (as that cpu's timer base may not be uptodate wrt jiffies etc). : 
2
strstr : for :  * (as that cpu's timer base may not be uptodate wrt jiffies etc). : 
2
strstr : while :  * (as that cpu's timer base may not be uptodate wrt jiffies etc). : 
2
str :  */[3]
strstr : INIT :  */ : 
2
strstr : if :  */ : 
2
strstr : for :  */ : 
2
strstr : while :  */ : 
2
str : int get_nohz_timer_target(void)[31]
strstr : INIT : int get_nohz_timer_target(void) : 
2
strstr : if : int get_nohz_timer_target(void) : 
2
strstr : for : int get_nohz_timer_target(void) : 
2
strstr : while : int get_nohz_timer_target(void) : 
2
str : 	int cpu = smp_processor_id();[30]
strstr : INIT : 	int cpu = smp_processor_id(); : 
2
strstr : if : 	int cpu = smp_processor_id(); : 
2
strstr : for : 	int cpu = smp_processor_id(); : 
2
strstr : while : 	int cpu = smp_processor_id(); : 
2
str : 	int i;[7]
strstr : INIT : 	int i; : 
2
strstr : if : 	int i; : 
2
strstr : for : 	int i; : 
2
strstr : while : 	int i; : 
2
str : 	struct sched_domain *sd;[25]
strstr : INIT : 	struct sched_domain *sd; : 
2
strstr : if : 	struct sched_domain *sd; : 
2
strstr : for : 	struct sched_domain *sd; : 
2
strstr : while : 	struct sched_domain *sd; : 
2
str : 	rcu_read_lock();[17]
strstr : INIT : 	rcu_read_lock(); : 
2
strstr : if : 	rcu_read_lock(); : 
2
strstr : for : 	rcu_read_lock(); : 
2
strstr : while : 	rcu_read_lock(); : 
2
str : 	for_each_domain(cpu, sd) {[27]
strstr : INIT : 	for_each_domain(cpu, sd) { : 
2
strstr : if : 	for_each_domain(cpu, sd) { : 
2
strstr : for : 	for_each_domain(cpu, sd) { : 
2
strstr : while : 	for_each_domain(cpu, sd) { : 
2
str : 		for_each_cpu(i, sched_domain_span(sd)) {[42]
strstr : INIT : 		for_each_cpu(i, sched_domain_span(sd)) { : 
2
strstr : if : 		for_each_cpu(i, sched_domain_span(sd)) { : 
2
strstr : for : 		for_each_cpu(i, sched_domain_span(sd)) { : 
2
strstr : while : 		for_each_cpu(i, sched_domain_span(sd)) { : 
2
str : 			if (!idle_cpu(i)) {[22]
strstr : INIT : 			if (!idle_cpu(i)) { : 
2
strstr : if : 			if (!idle_cpu(i)) { : 
2
strstr : for : 			if (!idle_cpu(i)) { : 
2
strstr : while : 			if (!idle_cpu(i)) { : 
2
str : 				cpu = i;[12]
strstr : INIT : 				cpu = i; : 
2
strstr : if : 				cpu = i; : 
2
strstr : for : 				cpu = i; : 
2
strstr : while : 				cpu = i; : 
2
str : 				goto unlock;[16]
strstr : INIT : 				goto unlock; : 
2
strstr : if : 				goto unlock; : 
2
strstr : for : 				goto unlock; : 
2
strstr : while : 				goto unlock; : 
2
str : 			}[4]
strstr : INIT : 			} : 
2
strstr : if : 			} : 
2
strstr : for : 			} : 
2
strstr : while : 			} : 
2
str : 		}[3]
strstr : INIT : 		} : 
2
strstr : if : 		} : 
2
strstr : for : 		} : 
2
strstr : while : 		} : 
2
str : unlock:[7]
strstr : INIT : unlock: : 
2
strstr : if : unlock: : 
2
strstr : for : unlock: : 
2
strstr : while : unlock: : 
2
str : 	rcu_read_unlock();[19]
strstr : INIT : 	rcu_read_unlock(); : 
2
strstr : if : 	rcu_read_unlock(); : 
2
strstr : for : 	rcu_read_unlock(); : 
2
strstr : while : 	rcu_read_unlock(); : 
2
str : 	return cpu;[12]
strstr : INIT : 	return cpu; : 
2
strstr : if : 	return cpu; : 
2
strstr : for : 	return cpu; : 
2
strstr : while : 	return cpu; : 
2
str :  * When add_timer_on() enqueues a timer into the timer wheel of an[66]
strstr : INIT :  * When add_timer_on() enqueues a timer into the timer wheel of an : 
2
strstr : if :  * When add_timer_on() enqueues a timer into the timer wheel of an : 
2
strstr : for :  * When add_timer_on() enqueues a timer into the timer wheel of an : 
2
strstr : while :  * When add_timer_on() enqueues a timer into the timer wheel of an : 
2
str :  * idle CPU then this timer might expire before the next timer event[68]
strstr : INIT :  * idle CPU then this timer might expire before the next timer event : 
2
strstr : if :  * idle CPU then this timer might expire before the next timer event : 
2
strstr : for :  * idle CPU then this timer might expire before the next timer event : 
2
strstr : while :  * idle CPU then this timer might expire before the next timer event : 
2
str :  * which is scheduled to wake up that CPU. In case of a completely[66]
strstr : INIT :  * which is scheduled to wake up that CPU. In case of a completely : 
2
strstr : if :  * which is scheduled to wake up that CPU. In case of a completely : 
2
strstr : for :  * which is scheduled to wake up that CPU. In case of a completely : 
2
strstr : while :  * which is scheduled to wake up that CPU. In case of a completely : 
2
str :  * idle system the next event might even be infinite time into the[66]
strstr : INIT :  * idle system the next event might even be infinite time into the : 
2
strstr : if :  * idle system the next event might even be infinite time into the : 
2
strstr : for :  * idle system the next event might even be infinite time into the : 
2
strstr : while :  * idle system the next event might even be infinite time into the : 
2
str :  * future. wake_up_idle_cpu() ensures that the CPU is woken up and[66]
strstr : INIT :  * future. wake_up_idle_cpu() ensures that the CPU is woken up and : 
2
strstr : if :  * future. wake_up_idle_cpu() ensures that the CPU is woken up and : 
2
strstr : for :  * future. wake_up_idle_cpu() ensures that the CPU is woken up and : 
2
strstr : while :  * future. wake_up_idle_cpu() ensures that the CPU is woken up and : 
2
str :  * leaves the inner idle loop so the newly added timer is taken into[68]
strstr : INIT :  * leaves the inner idle loop so the newly added timer is taken into : 
2
strstr : if :  * leaves the inner idle loop so the newly added timer is taken into : 
2
strstr : for :  * leaves the inner idle loop so the newly added timer is taken into : 
2
strstr : while :  * leaves the inner idle loop so the newly added timer is taken into : 
2
str :  * account when the CPU goes back to idle and evaluates the timer[65]
strstr : INIT :  * account when the CPU goes back to idle and evaluates the timer : 
2
strstr : if :  * account when the CPU goes back to idle and evaluates the timer : 
2
strstr : for :  * account when the CPU goes back to idle and evaluates the timer : 
2
strstr : while :  * account when the CPU goes back to idle and evaluates the timer : 
2
str :  * wheel for the next timer event.[34]
strstr : INIT :  * wheel for the next timer event. : 
2
strstr : if :  * wheel for the next timer event. : 
2
strstr : for :  * wheel for the next timer event. : 
2
strstr : while :  * wheel for the next timer event. : 
2
str :  */[3]
strstr : INIT :  */ : 
2
strstr : if :  */ : 
2
strstr : for :  */ : 
2
strstr : while :  */ : 
2
str : static void wake_up_idle_cpu(int cpu)[37]
strstr : INIT : static void wake_up_idle_cpu(int cpu) : 
2
strstr : if : static void wake_up_idle_cpu(int cpu) : 
2
strstr : for : static void wake_up_idle_cpu(int cpu) : 
2
strstr : while : static void wake_up_idle_cpu(int cpu) : 
2
str : 	struct rq *rq = cpu_rq(cpu);[29]
strstr : INIT : 	struct rq *rq = cpu_rq(cpu); : 
2
strstr : if : 	struct rq *rq = cpu_rq(cpu); : 
2
strstr : for : 	struct rq *rq = cpu_rq(cpu); : 
2
strstr : while : 	struct rq *rq = cpu_rq(cpu); : 
2
str : 	if (cpu == smp_processor_id())[31]
strstr : INIT : 	if (cpu == smp_processor_id()) : 
2
strstr : if : 	if (cpu == smp_processor_id()) : 
2
strstr : for : 	if (cpu == smp_processor_id()) : 
2
strstr : while : 	if (cpu == smp_processor_id()) : 
2
str : 		return;[9]
strstr : INIT : 		return; : 
2
strstr : if : 		return; : 
2
strstr : for : 		return; : 
2
strstr : while : 		return; : 
2
str : 	/*[3]
strstr : INIT : 	/* : 
2
strstr : if : 	/* : 
2
strstr : for : 	/* : 
2
strstr : while : 	/* : 
2
str : 	 * This is safe, as this function is called with the timer[59]
strstr : INIT : 	 * This is safe, as this function is called with the timer : 
2
strstr : if : 	 * This is safe, as this function is called with the timer : 
2
strstr : for : 	 * This is safe, as this function is called with the timer : 
2
strstr : while : 	 * This is safe, as this function is called with the timer : 
2
str : 	 * wheel base lock of (cpu) held. When the CPU is on the way[61]
strstr : INIT : 	 * wheel base lock of (cpu) held. When the CPU is on the way : 
2
strstr : if : 	 * wheel base lock of (cpu) held. When the CPU is on the way : 
2
strstr : for : 	 * wheel base lock of (cpu) held. When the CPU is on the way : 
2
strstr : while : 	 * wheel base lock of (cpu) held. When the CPU is on the way : 
2
str : 	 * to idle and has not yet set rq->curr to idle then it will[61]
strstr : INIT : 	 * to idle and has not yet set rq->curr to idle then it will : 
2
strstr : if : 	 * to idle and has not yet set rq->curr to idle then it will : 
2
strstr : for : 	 * to idle and has not yet set rq->curr to idle then it will : 
2
strstr : while : 	 * to idle and has not yet set rq->curr to idle then it will : 
2
str : 	 * be serialized on the timer wheel base lock and take the new[63]
strstr : INIT : 	 * be serialized on the timer wheel base lock and take the new : 
2
strstr : if : 	 * be serialized on the timer wheel base lock and take the new : 
2
strstr : for : 	 * be serialized on the timer wheel base lock and take the new : 
2
strstr : while : 	 * be serialized on the timer wheel base lock and take the new : 
2
str : 	 * timer into account automatically.[37]
strstr : INIT : 	 * timer into account automatically. : 
2
strstr : if : 	 * timer into account automatically. : 
2
strstr : for : 	 * timer into account automatically. : 
2
strstr : while : 	 * timer into account automatically. : 
2
str : 	 */[4]
strstr : INIT : 	 */ : 
2
strstr : if : 	 */ : 
2
strstr : for : 	 */ : 
2
strstr : while : 	 */ : 
2
str : 	if (rq->curr != rq->idle)[26]
strstr : INIT : 	if (rq->curr != rq->idle) : 
2
strstr : if : 	if (rq->curr != rq->idle) : 
2
strstr : for : 	if (rq->curr != rq->idle) : 
2
strstr : while : 	if (rq->curr != rq->idle) : 
2
str : 		return;[9]
strstr : INIT : 		return; : 
2
strstr : if : 		return; : 
2
strstr : for : 		return; : 
2
strstr : while : 		return; : 
2
str : 	/*[3]
strstr : INIT : 	/* : 
2
strstr : if : 	/* : 
2
strstr : for : 	/* : 
2
strstr : while : 	/* : 
2
str : 	 * We can set TIF_RESCHED on the idle task of the other CPU[60]
strstr : INIT : 	 * We can set TIF_RESCHED on the idle task of the other CPU : 
2
strstr : if : 	 * We can set TIF_RESCHED on the idle task of the other CPU : 
2
strstr : for : 	 * We can set TIF_RESCHED on the idle task of the other CPU : 
2
strstr : while : 	 * We can set TIF_RESCHED on the idle task of the other CPU : 
2
str : 	 * lockless. The worst case is that the other CPU runs the[59]
strstr : INIT : 	 * lockless. The worst case is that the other CPU runs the : 
2
strstr : if : 	 * lockless. The worst case is that the other CPU runs the : 
2
strstr : for : 	 * lockless. The worst case is that the other CPU runs the : 
2
strstr : while : 	 * lockless. The worst case is that the other CPU runs the : 
2
str : 	 * idle task through an additional NOOP schedule()[51]
strstr : INIT : 	 * idle task through an additional NOOP schedule() : 
2
strstr : if : 	 * idle task through an additional NOOP schedule() : 
2
strstr : for : 	 * idle task through an additional NOOP schedule() : 
2
strstr : while : 	 * idle task through an additional NOOP schedule() : 
2
str : 	 */[4]
strstr : INIT : 	 */ : 
2
strstr : if : 	 */ : 
2
strstr : for : 	 */ : 
2
strstr : while : 	 */ : 
2
str : 	set_tsk_need_resched(rq->idle);[32]
strstr : INIT : 	set_tsk_need_resched(rq->idle); : 
2
strstr : if : 	set_tsk_need_resched(rq->idle); : 
2
strstr : for : 	set_tsk_need_resched(rq->idle); : 
2
strstr : while : 	set_tsk_need_resched(rq->idle); : 
2
str : 	/* NEED_RESCHED must be visible before we test polling */[58]
strstr : INIT : 	/* NEED_RESCHED must be visible before we test polling */ : 
2
strstr : if : 	/* NEED_RESCHED must be visible before we test polling */ : 
2
strstr : for : 	/* NEED_RESCHED must be visible before we test polling */ : 
2
strstr : while : 	/* NEED_RESCHED must be visible before we test polling */ : 
2
str : 	smp_mb();[10]
strstr : INIT : 	smp_mb(); : 
2
strstr : if : 	smp_mb(); : 
2
strstr : for : 	smp_mb(); : 
2
strstr : while : 	smp_mb(); : 
2
str : 	if (!tsk_is_polling(rq->idle))[31]
strstr : INIT : 	if (!tsk_is_polling(rq->idle)) : 
2
strstr : if : 	if (!tsk_is_polling(rq->idle)) : 
2
strstr : for : 	if (!tsk_is_polling(rq->idle)) : 
2
strstr : while : 	if (!tsk_is_polling(rq->idle)) : 
2
str : 		smp_send_reschedule(cpu);[27]
strstr : INIT : 		smp_send_reschedule(cpu); : 
2
strstr : if : 		smp_send_reschedule(cpu); : 
2
strstr : for : 		smp_send_reschedule(cpu); : 
2
strstr : while : 		smp_send_reschedule(cpu); : 
2
str : static bool wake_up_full_nohz_cpu(int cpu)[42]
strstr : INIT : static bool wake_up_full_nohz_cpu(int cpu) : 
2
strstr : if : static bool wake_up_full_nohz_cpu(int cpu) : 
2
strstr : for : static bool wake_up_full_nohz_cpu(int cpu) : 
2
strstr : while : static bool wake_up_full_nohz_cpu(int cpu) : 
2
str : 	if (tick_nohz_full_cpu(cpu)) {[31]
strstr : INIT : 	if (tick_nohz_full_cpu(cpu)) { : 
2
strstr : if : 	if (tick_nohz_full_cpu(cpu)) { : 
2
strstr : for : 	if (tick_nohz_full_cpu(cpu)) { : 
2
strstr : while : 	if (tick_nohz_full_cpu(cpu)) { : 
2
str : 		if (cpu != smp_processor_id() ||[34]
strstr : INIT : 		if (cpu != smp_processor_id() || : 
2
strstr : if : 		if (cpu != smp_processor_id() || : 
2
strstr : for : 		if (cpu != smp_processor_id() || : 
2
strstr : while : 		if (cpu != smp_processor_id() || : 
2
str : 		    tick_nohz_tick_stopped())[31]
strstr : INIT : 		    tick_nohz_tick_stopped()) : 
2
strstr : if : 		    tick_nohz_tick_stopped()) : 
2
strstr : for : 		    tick_nohz_tick_stopped()) : 
2
strstr : while : 		    tick_nohz_tick_stopped()) : 
2
str : 			smp_send_reschedule(cpu);[28]
strstr : INIT : 			smp_send_reschedule(cpu); : 
2
strstr : if : 			smp_send_reschedule(cpu); : 
2
strstr : for : 			smp_send_reschedule(cpu); : 
2
strstr : while : 			smp_send_reschedule(cpu); : 
2
str : 		return true;[14]
strstr : INIT : 		return true; : 
2
strstr : if : 		return true; : 
2
strstr : for : 		return true; : 
2
strstr : while : 		return true; : 
2
str : 	return false;[14]
strstr : INIT : 	return false; : 
2
strstr : if : 	return false; : 
2
strstr : for : 	return false; : 
2
strstr : while : 	return false; : 
2
str : void wake_up_nohz_cpu(int cpu)[30]
strstr : INIT : void wake_up_nohz_cpu(int cpu) : 
2
strstr : if : void wake_up_nohz_cpu(int cpu) : 
2
strstr : for : void wake_up_nohz_cpu(int cpu) : 
2
strstr : while : void wake_up_nohz_cpu(int cpu) : 
2
str : 	if (!wake_up_full_nohz_cpu(cpu))[33]
strstr : INIT : 	if (!wake_up_full_nohz_cpu(cpu)) : 
2
strstr : if : 	if (!wake_up_full_nohz_cpu(cpu)) : 
2
strstr : for : 	if (!wake_up_full_nohz_cpu(cpu)) : 
2
strstr : while : 	if (!wake_up_full_nohz_cpu(cpu)) : 
2
str : 		wake_up_idle_cpu(cpu);[24]
strstr : INIT : 		wake_up_idle_cpu(cpu); : 
2
strstr : if : 		wake_up_idle_cpu(cpu); : 
2
strstr : for : 		wake_up_idle_cpu(cpu); : 
2
strstr : while : 		wake_up_idle_cpu(cpu); : 
2
str : static inline bool got_nohz_idle_kick(void)[43]
strstr : INIT : static inline bool got_nohz_idle_kick(void) : 
2
strstr : if : static inline bool got_nohz_idle_kick(void) : 
2
strstr : for : static inline bool got_nohz_idle_kick(void) : 
2
strstr : while : static inline bool got_nohz_idle_kick(void) : 
2
str : 	int cpu = smp_processor_id();[30]
strstr : INIT : 	int cpu = smp_processor_id(); : 
2
strstr : if : 	int cpu = smp_processor_id(); : 
2
strstr : for : 	int cpu = smp_processor_id(); : 
2
strstr : while : 	int cpu = smp_processor_id(); : 
2
str : 	if (!test_bit(NOHZ_BALANCE_KICK, nohz_flags(cpu)))[51]
strstr : INIT : 	if (!test_bit(NOHZ_BALANCE_KICK, nohz_flags(cpu))) : 
2
strstr : if : 	if (!test_bit(NOHZ_BALANCE_KICK, nohz_flags(cpu))) : 
2
strstr : for : 	if (!test_bit(NOHZ_BALANCE_KICK, nohz_flags(cpu))) : 
2
strstr : while : 	if (!test_bit(NOHZ_BALANCE_KICK, nohz_flags(cpu))) : 
2
str : 		return false;[15]
strstr : INIT : 		return false; : 
2
strstr : if : 		return false; : 
2
strstr : for : 		return false; : 
2
strstr : while : 		return false; : 
2
str : 	if (idle_cpu(cpu) && !need_resched())[38]
strstr : INIT : 	if (idle_cpu(cpu) && !need_resched()) : 
2
strstr : if : 	if (idle_cpu(cpu) && !need_resched()) : 
2
strstr : for : 	if (idle_cpu(cpu) && !need_resched()) : 
2
strstr : while : 	if (idle_cpu(cpu) && !need_resched()) : 
2
str : 		return true;[14]
strstr : INIT : 		return true; : 
2
strstr : if : 		return true; : 
2
strstr : for : 		return true; : 
2
strstr : while : 		return true; : 
2
str : 	/*[3]
strstr : INIT : 	/* : 
2
strstr : if : 	/* : 
2
strstr : for : 	/* : 
2
strstr : while : 	/* : 
2
str : 	 * We can't run Idle Load Balance on this CPU for this time so we[66]
strstr : INIT : 	 * We can't run Idle Load Balance on this CPU for this time so we : 
2
strstr : if : 	 * We can't run Idle Load Balance on this CPU for this time so we : 
2
strstr : for : 	 * We can't run Idle Load Balance on this CPU for this time so we : 
2
strstr : while : 	 * We can't run Idle Load Balance on this CPU for this time so we : 
2
str : 	 * cancel it and clear NOHZ_BALANCE_KICK[41]
strstr : INIT : 	 * cancel it and clear NOHZ_BALANCE_KICK : 
2
strstr : if : 	 * cancel it and clear NOHZ_BALANCE_KICK : 
2
strstr : for : 	 * cancel it and clear NOHZ_BALANCE_KICK : 
2
strstr : while : 	 * cancel it and clear NOHZ_BALANCE_KICK : 
2
str : 	 */[4]
strstr : INIT : 	 */ : 
2
strstr : if : 	 */ : 
2
strstr : for : 	 */ : 
2
strstr : while : 	 */ : 
2
str : 	clear_bit(NOHZ_BALANCE_KICK, nohz_flags(cpu));[47]
strstr : INIT : 	clear_bit(NOHZ_BALANCE_KICK, nohz_flags(cpu)); : 
2
strstr : if : 	clear_bit(NOHZ_BALANCE_KICK, nohz_flags(cpu)); : 
2
strstr : for : 	clear_bit(NOHZ_BALANCE_KICK, nohz_flags(cpu)); : 
2
strstr : while : 	clear_bit(NOHZ_BALANCE_KICK, nohz_flags(cpu)); : 
2
str : 	return false;[14]
strstr : INIT : 	return false; : 
2
strstr : if : 	return false; : 
2
strstr : for : 	return false; : 
2
strstr : while : 	return false; : 
2
str : #else /* CONFIG_NO_HZ_COMMON */[31]
strstr : INIT : #else /* CONFIG_NO_HZ_COMMON */ : 
2
strstr : if : #else /* CONFIG_NO_HZ_COMMON */ : 
2
strstr : for : #else /* CONFIG_NO_HZ_COMMON */ : 
2
strstr : while : #else /* CONFIG_NO_HZ_COMMON */ : 
2
str : static inline bool got_nohz_idle_kick(void)[43]
strstr : INIT : static inline bool got_nohz_idle_kick(void) : 
2
strstr : if : static inline bool got_nohz_idle_kick(void) : 
2
strstr : for : static inline bool got_nohz_idle_kick(void) : 
2
strstr : while : static inline bool got_nohz_idle_kick(void) : 
2
str : 	return false;[14]
strstr : INIT : 	return false; : 
2
strstr : if : 	return false; : 
2
strstr : for : 	return false; : 
2
strstr : while : 	return false; : 
2
str : #endif /* CONFIG_NO_HZ_COMMON */[32]
strstr : INIT : #endif /* CONFIG_NO_HZ_COMMON */ : 
2
strstr : if : #endif /* CONFIG_NO_HZ_COMMON */ : 
2
strstr : for : #endif /* CONFIG_NO_HZ_COMMON */ : 
2
strstr : while : #endif /* CONFIG_NO_HZ_COMMON */ : 
2
str : #ifdef CONFIG_NO_HZ_FULL[24]
strstr : INIT : #ifdef CONFIG_NO_HZ_FULL : 
2
strstr : if : #ifdef CONFIG_NO_HZ_FULL : 
2
strstr : for : #ifdef CONFIG_NO_HZ_FULL : 
2
strstr : while : #ifdef CONFIG_NO_HZ_FULL : 
2
str : bool sched_can_stop_tick(void)[30]
strstr : INIT : bool sched_can_stop_tick(void) : 
2
strstr : if : bool sched_can_stop_tick(void) : 
2
strstr : for : bool sched_can_stop_tick(void) : 
2
strstr : while : bool sched_can_stop_tick(void) : 
2
str :        struct rq *rq;[21]
strstr : INIT :        struct rq *rq; : 
2
strstr : if :        struct rq *rq; : 
2
strstr : for :        struct rq *rq; : 
2
strstr : while :        struct rq *rq; : 
2
str :        rq = this_rq();[22]
strstr : INIT :        rq = this_rq(); : 
2
strstr : if :        rq = this_rq(); : 
2
strstr : for :        rq = this_rq(); : 
2
strstr : while :        rq = this_rq(); : 
2
str :        /* Make sure rq->nr_running update is visible after the IPI */[69]
strstr : INIT :        /* Make sure rq->nr_running update is visible after the IPI */ : 
2
strstr : if :        /* Make sure rq->nr_running update is visible after the IPI */ : 
2
strstr : for :        /* Make sure rq->nr_running update is visible after the IPI */ : 
2
strstr : while :        /* Make sure rq->nr_running update is visible after the IPI */ : 
2
str :        smp_rmb();[17]
strstr : INIT :        smp_rmb(); : 
2
strstr : if :        smp_rmb(); : 
2
strstr : for :        smp_rmb(); : 
2
strstr : while :        smp_rmb(); : 
2
str :        /* More than one running task need preemption */[55]
strstr : INIT :        /* More than one running task need preemption */ : 
2
strstr : if :        /* More than one running task need preemption */ : 
2
strstr : for :        /* More than one running task need preemption */ : 
2
strstr : while :        /* More than one running task need preemption */ : 
2
str :        if (rq->nr_running > 1)[30]
strstr : INIT :        if (rq->nr_running > 1) : 
2
strstr : if :        if (rq->nr_running > 1) : 
2
strstr : for :        if (rq->nr_running > 1) : 
2
strstr : while :        if (rq->nr_running > 1) : 
2
str :                return false;[28]
strstr : INIT :                return false; : 
2
strstr : if :                return false; : 
2
strstr : for :                return false; : 
2
strstr : while :                return false; : 
2
str :        return true;[19]
strstr : INIT :        return true; : 
2
strstr : if :        return true; : 
2
strstr : for :        return true; : 
2
strstr : while :        return true; : 
2
str : #endif /* CONFIG_NO_HZ_FULL */[30]
strstr : INIT : #endif /* CONFIG_NO_HZ_FULL */ : 
2
strstr : if : #endif /* CONFIG_NO_HZ_FULL */ : 
2
strstr : for : #endif /* CONFIG_NO_HZ_FULL */ : 
2
strstr : while : #endif /* CONFIG_NO_HZ_FULL */ : 
2
str : void sched_avg_update(struct rq *rq)[36]
strstr : INIT : void sched_avg_update(struct rq *rq) : 
2
strstr : if : void sched_avg_update(struct rq *rq) : 
2
strstr : for : void sched_avg_update(struct rq *rq) : 
2
strstr : while : void sched_avg_update(struct rq *rq) : 
2
str : 	s64 period = sched_avg_period();[33]
strstr : INIT : 	s64 period = sched_avg_period(); : 
2
strstr : if : 	s64 period = sched_avg_period(); : 
2
strstr : for : 	s64 period = sched_avg_period(); : 
2
strstr : while : 	s64 period = sched_avg_period(); : 
2
str : 	while ((s64)(rq_clock(rq) - rq->age_stamp) > period) {[55]
strstr : INIT : 	while ((s64)(rq_clock(rq) - rq->age_stamp) > period) { : 
2
strstr : if : 	while ((s64)(rq_clock(rq) - rq->age_stamp) > period) { : 
2
strstr : for : 	while ((s64)(rq_clock(rq) - rq->age_stamp) > period) { : 
2
strstr : while : 	while ((s64)(rq_clock(rq) - rq->age_stamp) > period) { : 
2
str : 		/*[4]
strstr : INIT : 		/* : 
2
strstr : if : 		/* : 
2
strstr : for : 		/* : 
2
strstr : while : 		/* : 
2
str : 		 * Inline assembly required to prevent the compiler[53]
strstr : INIT : 		 * Inline assembly required to prevent the compiler : 
2
strstr : if : 		 * Inline assembly required to prevent the compiler : 
2
strstr : for : 		 * Inline assembly required to prevent the compiler : 
2
strstr : while : 		 * Inline assembly required to prevent the compiler : 
2
str : 		 * optimising this loop into a divmod call.[45]
strstr : INIT : 		 * optimising this loop into a divmod call. : 
2
strstr : if : 		 * optimising this loop into a divmod call. : 
2
strstr : for : 		 * optimising this loop into a divmod call. : 
2
strstr : while : 		 * optimising this loop into a divmod call. : 
2
str : 		 * See __iter_div_u64_rem() for another example of this.[58]
strstr : INIT : 		 * See __iter_div_u64_rem() for another example of this. : 
2
strstr : if : 		 * See __iter_div_u64_rem() for another example of this. : 
2
strstr : for : 		 * See __iter_div_u64_rem() for another example of this. : 
2
strstr : while : 		 * See __iter_div_u64_rem() for another example of this. : 
2
str : 		 */[5]
strstr : INIT : 		 */ : 
2
strstr : if : 		 */ : 
2
strstr : for : 		 */ : 
2
strstr : while : 		 */ : 
2
str : 		asm("" : "+rm" (rq->age_stamp));[34]
strstr : INIT : 		asm("" : "+rm" (rq->age_stamp)); : 
2
strstr : if : 		asm("" : "+rm" (rq->age_stamp)); : 
2
strstr : for : 		asm("" : "+rm" (rq->age_stamp)); : 
2
strstr : while : 		asm("" : "+rm" (rq->age_stamp)); : 
2
str : 		rq->age_stamp += period;[26]
strstr : INIT : 		rq->age_stamp += period; : 
2
strstr : if : 		rq->age_stamp += period; : 
2
strstr : for : 		rq->age_stamp += period; : 
2
strstr : while : 		rq->age_stamp += period; : 
2
str : 		rq->rt_avg /= 2;[18]
strstr : INIT : 		rq->rt_avg /= 2; : 
2
strstr : if : 		rq->rt_avg /= 2; : 
2
strstr : for : 		rq->rt_avg /= 2; : 
2
strstr : while : 		rq->rt_avg /= 2; : 
2
str : #endif /* CONFIG_SMP */[23]
strstr : INIT : #endif /* CONFIG_SMP */ : 
2
strstr : if : #endif /* CONFIG_SMP */ : 
2
strstr : for : #endif /* CONFIG_SMP */ : 
2
strstr : while : #endif /* CONFIG_SMP */ : 
2
str : #if defined(CONFIG_RT_GROUP_SCHED) || (defined(CONFIG_FAIR_GROUP_SCHED) && \[76]
strstr : INIT : #if defined(CONFIG_RT_GROUP_SCHED) || (defined(CONFIG_FAIR_GROUP_SCHED) && \ : 
2
strstr : if : #if defined(CONFIG_RT_GROUP_SCHED) || (defined(CONFIG_FAIR_GROUP_SCHED) && \ : 
2
strstr : for : #if defined(CONFIG_RT_GROUP_SCHED) || (defined(CONFIG_FAIR_GROUP_SCHED) && \ : 
2
strstr : while : #if defined(CONFIG_RT_GROUP_SCHED) || (defined(CONFIG_FAIR_GROUP_SCHED) && \ : 
2
str : 			(defined(CONFIG_SMP) || defined(CONFIG_CFS_BANDWIDTH)))[58]
strstr : INIT : 			(defined(CONFIG_SMP) || defined(CONFIG_CFS_BANDWIDTH))) : 
2
strstr : if : 			(defined(CONFIG_SMP) || defined(CONFIG_CFS_BANDWIDTH))) : 
2
strstr : for : 			(defined(CONFIG_SMP) || defined(CONFIG_CFS_BANDWIDTH))) : 
2
strstr : while : 			(defined(CONFIG_SMP) || defined(CONFIG_CFS_BANDWIDTH))) : 
2
str :  * Iterate task_group tree rooted at *from, calling @down when first entering a[79]
strstr : INIT :  * Iterate task_group tree rooted at *from, calling @down when first entering a : 
2
strstr : if :  * Iterate task_group tree rooted at *from, calling @down when first entering a : 
2
strstr : for :  * Iterate task_group tree rooted at *from, calling @down when first entering a : 
2
strstr : while :  * Iterate task_group tree rooted at *from, calling @down when first entering a : 
2
str :  * node and @up when leaving it for the final time.[51]
strstr : INIT :  * node and @up when leaving it for the final time. : 
2
strstr : if :  * node and @up when leaving it for the final time. : 
2
strstr : for :  * node and @up when leaving it for the final time. : 
2
strstr : while :  * node and @up when leaving it for the final time. : 
2
str :  * Caller must hold rcu_lock or sufficient equivalent.[54]
strstr : INIT :  * Caller must hold rcu_lock or sufficient equivalent. : 
2
strstr : if :  * Caller must hold rcu_lock or sufficient equivalent. : 
2
strstr : for :  * Caller must hold rcu_lock or sufficient equivalent. : 
2
strstr : while :  * Caller must hold rcu_lock or sufficient equivalent. : 
2
str :  */[3]
strstr : INIT :  */ : 
2
strstr : if :  */ : 
2
strstr : for :  */ : 
2
strstr : while :  */ : 
2
str : int walk_tg_tree_from(struct task_group *from,[46]
strstr : INIT : int walk_tg_tree_from(struct task_group *from, : 
2
strstr : if : int walk_tg_tree_from(struct task_group *from, : 
2
strstr : for : int walk_tg_tree_from(struct task_group *from, : 
2
strstr : while : int walk_tg_tree_from(struct task_group *from, : 
2
str : 			     tg_visitor down, tg_visitor up, void *data)[51]
strstr : INIT : 			     tg_visitor down, tg_visitor up, void *data) : 
2
strstr : if : 			     tg_visitor down, tg_visitor up, void *data) : 
2
strstr : for : 			     tg_visitor down, tg_visitor up, void *data) : 
2
strstr : while : 			     tg_visitor down, tg_visitor up, void *data) : 
2
str : 	struct task_group *parent, *child;[35]
strstr : INIT : 	struct task_group *parent, *child; : 
2
strstr : if : 	struct task_group *parent, *child; : 
2
strstr : for : 	struct task_group *parent, *child; : 
2
strstr : while : 	struct task_group *parent, *child; : 
2
str : 	int ret;[9]
strstr : INIT : 	int ret; : 
2
strstr : if : 	int ret; : 
2
strstr : for : 	int ret; : 
2
strstr : while : 	int ret; : 
2
str : 	parent = from;[15]
strstr : INIT : 	parent = from; : 
2
strstr : if : 	parent = from; : 
2
strstr : for : 	parent = from; : 
2
strstr : while : 	parent = from; : 
2
str : down:[5]
strstr : INIT : down: : 
2
strstr : if : down: : 
2
strstr : for : down: : 
2
strstr : while : down: : 
2
str : 	ret = (*down)(parent, data);[29]
strstr : INIT : 	ret = (*down)(parent, data); : 
2
strstr : if : 	ret = (*down)(parent, data); : 
2
strstr : for : 	ret = (*down)(parent, data); : 
2
strstr : while : 	ret = (*down)(parent, data); : 
2
str : 	if (ret)[9]
strstr : INIT : 	if (ret) : 
2
strstr : if : 	if (ret) : 
2
strstr : for : 	if (ret) : 
2
strstr : while : 	if (ret) : 
2
str : 		goto out;[11]
strstr : INIT : 		goto out; : 
2
strstr : if : 		goto out; : 
2
strstr : for : 		goto out; : 
2
strstr : while : 		goto out; : 
2
str : 	list_for_each_entry_rcu(child, &parent->children, siblings) {[62]
strstr : INIT : 	list_for_each_entry_rcu(child, &parent->children, siblings) { : 
2
strstr : if : 	list_for_each_entry_rcu(child, &parent->children, siblings) { : 
2
strstr : for : 	list_for_each_entry_rcu(child, &parent->children, siblings) { : 
2
strstr : while : 	list_for_each_entry_rcu(child, &parent->children, siblings) { : 
2
str : 		parent = child;[17]
strstr : INIT : 		parent = child; : 
2
strstr : if : 		parent = child; : 
2
strstr : for : 		parent = child; : 
2
strstr : while : 		parent = child; : 
2
str : 		goto down;[12]
strstr : INIT : 		goto down; : 
2
strstr : if : 		goto down; : 
2
strstr : for : 		goto down; : 
2
strstr : while : 		goto down; : 
2
str : up:[3]
strstr : INIT : up: : 
2
strstr : if : up: : 
2
strstr : for : up: : 
2
strstr : while : up: : 
2
str : 		continue;[11]
strstr : INIT : 		continue; : 
2
strstr : if : 		continue; : 
2
strstr : for : 		continue; : 
2
strstr : while : 		continue; : 
2
str : 	ret = (*up)(parent, data);[27]
strstr : INIT : 	ret = (*up)(parent, data); : 
2
strstr : if : 	ret = (*up)(parent, data); : 
2
strstr : for : 	ret = (*up)(parent, data); : 
2
strstr : while : 	ret = (*up)(parent, data); : 
2
str : 	if (ret || parent == from)[27]
strstr : INIT : 	if (ret || parent == from) : 
2
strstr : if : 	if (ret || parent == from) : 
2
strstr : for : 	if (ret || parent == from) : 
2
strstr : while : 	if (ret || parent == from) : 
2
str : 		goto out;[11]
strstr : INIT : 		goto out; : 
2
strstr : if : 		goto out; : 
2
strstr : for : 		goto out; : 
2
strstr : while : 		goto out; : 
2
str : 	child = parent;[16]
strstr : INIT : 	child = parent; : 
2
strstr : if : 	child = parent; : 
2
strstr : for : 	child = parent; : 
2
strstr : while : 	child = parent; : 
2
str : 	parent = parent->parent;[25]
strstr : INIT : 	parent = parent->parent; : 
2
strstr : if : 	parent = parent->parent; : 
2
strstr : for : 	parent = parent->parent; : 
2
strstr : while : 	parent = parent->parent; : 
2
str : 	if (parent)[12]
strstr : INIT : 	if (parent) : 
2
strstr : if : 	if (parent) : 
2
strstr : for : 	if (parent) : 
2
strstr : while : 	if (parent) : 
2
str : 		goto up;[10]
strstr : INIT : 		goto up; : 
2
strstr : if : 		goto up; : 
2
strstr : for : 		goto up; : 
2
strstr : while : 		goto up; : 
2
str : out:[4]
strstr : INIT : out: : 
2
strstr : if : out: : 
2
strstr : for : out: : 
2
strstr : while : out: : 
2
str : 	return ret;[12]
strstr : INIT : 	return ret; : 
2
strstr : if : 	return ret; : 
2
strstr : for : 	return ret; : 
2
strstr : while : 	return ret; : 
2
str : int tg_nop(struct task_group *tg, void *data)[45]
strstr : INIT : int tg_nop(struct task_group *tg, void *data) : 
2
strstr : if : int tg_nop(struct task_group *tg, void *data) : 
2
strstr : for : int tg_nop(struct task_group *tg, void *data) : 
2
strstr : while : int tg_nop(struct task_group *tg, void *data) : 
2
str : 	return 0;[10]
strstr : INIT : 	return 0; : 
2
strstr : if : 	return 0; : 
2
strstr : for : 	return 0; : 
2
strstr : while : 	return 0; : 
2
str : #endif[6]
strstr : INIT : #endif : 
2
strstr : if : #endif : 
2
strstr : for : #endif : 
2
strstr : while : #endif : 
2
str : static void set_load_weight(struct task_struct *p)[50]
strstr : INIT : static void set_load_weight(struct task_struct *p) : 
2
strstr : if : static void set_load_weight(struct task_struct *p) : 
2
strstr : for : static void set_load_weight(struct task_struct *p) : 
2
strstr : while : static void set_load_weight(struct task_struct *p) : 
2
str : 	int prio = p->static_prio - MAX_RT_PRIO;[41]
strstr : INIT : 	int prio = p->static_prio - MAX_RT_PRIO; : 
2
strstr : if : 	int prio = p->static_prio - MAX_RT_PRIO; : 
2
strstr : for : 	int prio = p->static_prio - MAX_RT_PRIO; : 
2
strstr : while : 	int prio = p->static_prio - MAX_RT_PRIO; : 
2
str : 	struct load_weight *load = &p->se.load;[40]
strstr : INIT : 	struct load_weight *load = &p->se.load; : 
2
strstr : if : 	struct load_weight *load = &p->se.load; : 
2
strstr : for : 	struct load_weight *load = &p->se.load; : 
2
strstr : while : 	struct load_weight *load = &p->se.load; : 
2
str : 	/*[3]
strstr : INIT : 	/* : 
2
strstr : if : 	/* : 
2
strstr : for : 	/* : 
2
strstr : while : 	/* : 
2
str : 	 * SCHED_IDLE tasks get minimal weight:[40]
strstr : INIT : 	 * SCHED_IDLE tasks get minimal weight: : 
2
strstr : if : 	 * SCHED_IDLE tasks get minimal weight: : 
2
strstr : for : 	 * SCHED_IDLE tasks get minimal weight: : 
2
strstr : while : 	 * SCHED_IDLE tasks get minimal weight: : 
2
str : 	 */[4]
strstr : INIT : 	 */ : 
2
strstr : if : 	 */ : 
2
strstr : for : 	 */ : 
2
strstr : while : 	 */ : 
2
str : 	if (p->policy == SCHED_IDLE) {[31]
strstr : INIT : 	if (p->policy == SCHED_IDLE) { : 
2
strstr : if : 	if (p->policy == SCHED_IDLE) { : 
2
strstr : for : 	if (p->policy == SCHED_IDLE) { : 
2
strstr : while : 	if (p->policy == SCHED_IDLE) { : 
2
str : 		load->weight = scale_load(WEIGHT_IDLEPRIO);[45]
strstr : INIT : 		load->weight = scale_load(WEIGHT_IDLEPRIO); : 
2
strstr : if : 		load->weight = scale_load(WEIGHT_IDLEPRIO); : 
2
strstr : for : 		load->weight = scale_load(WEIGHT_IDLEPRIO); : 
2
strstr : while : 		load->weight = scale_load(WEIGHT_IDLEPRIO); : 
2
str : 		load->inv_weight = WMULT_IDLEPRIO;[36]
strstr : INIT : 		load->inv_weight = WMULT_IDLEPRIO; : 
2
strstr : if : 		load->inv_weight = WMULT_IDLEPRIO; : 
2
strstr : for : 		load->inv_weight = WMULT_IDLEPRIO; : 
2
strstr : while : 		load->inv_weight = WMULT_IDLEPRIO; : 
2
str : 		return;[9]
strstr : INIT : 		return; : 
2
strstr : if : 		return; : 
2
strstr : for : 		return; : 
2
strstr : while : 		return; : 
2
str : 	load->weight = scale_load(prio_to_weight[prio]);[49]
strstr : INIT : 	load->weight = scale_load(prio_to_weight[prio]); : 
2
strstr : if : 	load->weight = scale_load(prio_to_weight[prio]); : 
2
strstr : for : 	load->weight = scale_load(prio_to_weight[prio]); : 
2
strstr : while : 	load->weight = scale_load(prio_to_weight[prio]); : 
2
str : 	load->inv_weight = prio_to_wmult[prio];[40]
strstr : INIT : 	load->inv_weight = prio_to_wmult[prio]; : 
2
strstr : if : 	load->inv_weight = prio_to_wmult[prio]; : 
2
strstr : for : 	load->inv_weight = prio_to_wmult[prio]; : 
2
strstr : while : 	load->inv_weight = prio_to_wmult[prio]; : 
2
str : static void enqueue_task(struct rq *rq, struct task_struct *p, int flags)[73]
strstr : INIT : static void enqueue_task(struct rq *rq, struct task_struct *p, int flags) : 
2
strstr : if : static void enqueue_task(struct rq *rq, struct task_struct *p, int flags) : 
2
strstr : for : static void enqueue_task(struct rq *rq, struct task_struct *p, int flags) : 
2
strstr : while : static void enqueue_task(struct rq *rq, struct task_struct *p, int flags) : 
2
str : 	update_rq_clock(rq);[21]
strstr : INIT : 	update_rq_clock(rq); : 
2
strstr : if : 	update_rq_clock(rq); : 
2
strstr : for : 	update_rq_clock(rq); : 
2
strstr : while : 	update_rq_clock(rq); : 
2
str : 	sched_info_queued(rq, p);[26]
strstr : INIT : 	sched_info_queued(rq, p); : 
2
strstr : if : 	sched_info_queued(rq, p); : 
2
strstr : for : 	sched_info_queued(rq, p); : 
2
strstr : while : 	sched_info_queued(rq, p); : 
2
str : 	p->sched_class->enqueue_task(rq, p, flags);[44]
strstr : INIT : 	p->sched_class->enqueue_task(rq, p, flags); : 
2
strstr : if : 	p->sched_class->enqueue_task(rq, p, flags); : 
2
strstr : for : 	p->sched_class->enqueue_task(rq, p, flags); : 
2
strstr : while : 	p->sched_class->enqueue_task(rq, p, flags); : 
2
str : static void dequeue_task(struct rq *rq, struct task_struct *p, int flags)[73]
strstr : INIT : static void dequeue_task(struct rq *rq, struct task_struct *p, int flags) : 
2
strstr : if : static void dequeue_task(struct rq *rq, struct task_struct *p, int flags) : 
2
strstr : for : static void dequeue_task(struct rq *rq, struct task_struct *p, int flags) : 
2
strstr : while : static void dequeue_task(struct rq *rq, struct task_struct *p, int flags) : 
2
str : 	update_rq_clock(rq);[21]
strstr : INIT : 	update_rq_clock(rq); : 
2
strstr : if : 	update_rq_clock(rq); : 
2
strstr : for : 	update_rq_clock(rq); : 
2
strstr : while : 	update_rq_clock(rq); : 
2
str : 	sched_info_dequeued(rq, p);[28]
strstr : INIT : 	sched_info_dequeued(rq, p); : 
2
strstr : if : 	sched_info_dequeued(rq, p); : 
2
strstr : for : 	sched_info_dequeued(rq, p); : 
2
strstr : while : 	sched_info_dequeued(rq, p); : 
2
str : 	p->sched_class->dequeue_task(rq, p, flags);[44]
strstr : INIT : 	p->sched_class->dequeue_task(rq, p, flags); : 
2
strstr : if : 	p->sched_class->dequeue_task(rq, p, flags); : 
2
strstr : for : 	p->sched_class->dequeue_task(rq, p, flags); : 
2
strstr : while : 	p->sched_class->dequeue_task(rq, p, flags); : 
2
str : void activate_task(struct rq *rq, struct task_struct *p, int flags)[67]
strstr : INIT : void activate_task(struct rq *rq, struct task_struct *p, int flags) : 
2
strstr : if : void activate_task(struct rq *rq, struct task_struct *p, int flags) : 
2
strstr : for : void activate_task(struct rq *rq, struct task_struct *p, int flags) : 
2
strstr : while : void activate_task(struct rq *rq, struct task_struct *p, int flags) : 
2
str : 	if (task_contributes_to_load(p))[33]
strstr : INIT : 	if (task_contributes_to_load(p)) : 
2
strstr : if : 	if (task_contributes_to_load(p)) : 
2
strstr : for : 	if (task_contributes_to_load(p)) : 
2
strstr : while : 	if (task_contributes_to_load(p)) : 
2
str : 		rq->nr_uninterruptible--;[27]
strstr : INIT : 		rq->nr_uninterruptible--; : 
2
strstr : if : 		rq->nr_uninterruptible--; : 
2
strstr : for : 		rq->nr_uninterruptible--; : 
2
strstr : while : 		rq->nr_uninterruptible--; : 
2
str : 	enqueue_task(rq, p, flags);[28]
strstr : INIT : 	enqueue_task(rq, p, flags); : 
2
strstr : if : 	enqueue_task(rq, p, flags); : 
2
strstr : for : 	enqueue_task(rq, p, flags); : 
2
strstr : while : 	enqueue_task(rq, p, flags); : 
2
str : void deactivate_task(struct rq *rq, struct task_struct *p, int flags)[69]
strstr : INIT : void deactivate_task(struct rq *rq, struct task_struct *p, int flags) : 
2
strstr : if : void deactivate_task(struct rq *rq, struct task_struct *p, int flags) : 
2
strstr : for : void deactivate_task(struct rq *rq, struct task_struct *p, int flags) : 
2
strstr : while : void deactivate_task(struct rq *rq, struct task_struct *p, int flags) : 
2
str : 	if (task_contributes_to_load(p))[33]
strstr : INIT : 	if (task_contributes_to_load(p)) : 
2
strstr : if : 	if (task_contributes_to_load(p)) : 
2
strstr : for : 	if (task_contributes_to_load(p)) : 
2
strstr : while : 	if (task_contributes_to_load(p)) : 
2
str : 		rq->nr_uninterruptible++;[27]
strstr : INIT : 		rq->nr_uninterruptible++; : 
2
strstr : if : 		rq->nr_uninterruptible++; : 
2
strstr : for : 		rq->nr_uninterruptible++; : 
2
strstr : while : 		rq->nr_uninterruptible++; : 
2
str : 	dequeue_task(rq, p, flags);[28]
strstr : INIT : 	dequeue_task(rq, p, flags); : 
2
strstr : if : 	dequeue_task(rq, p, flags); : 
2
strstr : for : 	dequeue_task(rq, p, flags); : 
2
strstr : while : 	dequeue_task(rq, p, flags); : 
2
str : static void update_rq_clock_task(struct rq *rq, s64 delta)[58]
strstr : INIT : static void update_rq_clock_task(struct rq *rq, s64 delta) : 
2
strstr : if : static void update_rq_clock_task(struct rq *rq, s64 delta) : 
2
strstr : for : static void update_rq_clock_task(struct rq *rq, s64 delta) : 
2
strstr : while : static void update_rq_clock_task(struct rq *rq, s64 delta) : 
2
str :  * In theory, the compile should just see 0 here, and optimize out the call[75]
strstr : INIT :  * In theory, the compile should just see 0 here, and optimize out the call : 
2
strstr : if :  * In theory, the compile should just see 0 here, and optimize out the call : 
2
strstr : for :  * In theory, the compile should just see 0 here, and optimize out the call : 
2
strstr : while :  * In theory, the compile should just see 0 here, and optimize out the call : 
2
str :  * to sched_rt_avg_update. But I don't trust it...[50]
strstr : INIT :  * to sched_rt_avg_update. But I don't trust it... : 
2
strstr : if :  * to sched_rt_avg_update. But I don't trust it... : 
2
strstr : for :  * to sched_rt_avg_update. But I don't trust it... : 
2
strstr : while :  * to sched_rt_avg_update. But I don't trust it... : 
2
str :  */[3]
strstr : INIT :  */ : 
2
strstr : if :  */ : 
2
strstr : for :  */ : 
2
strstr : while :  */ : 
2
str : #if defined(CONFIG_IRQ_TIME_ACCOUNTING) || defined(CONFIG_PARAVIRT_TIME_ACCOUNTING)[83]
strstr : INIT : #if defined(CONFIG_IRQ_TIME_ACCOUNTING) || defined(CONFIG_PARAVIRT_TIME_ACCOUNTING) : 
2
strstr : if : #if defined(CONFIG_IRQ_TIME_ACCOUNTING) || defined(CONFIG_PARAVIRT_TIME_ACCOUNTING) : 
2
strstr : for : #if defined(CONFIG_IRQ_TIME_ACCOUNTING) || defined(CONFIG_PARAVIRT_TIME_ACCOUNTING) : 
2
strstr : while : #if defined(CONFIG_IRQ_TIME_ACCOUNTING) || defined(CONFIG_PARAVIRT_TIME_ACCOUNTING) : 
2
str : 	s64 steal = 0, irq_delta = 0;[30]
strstr : INIT : 	s64 steal = 0, irq_delta = 0; : 
2
strstr : if : 	s64 steal = 0, irq_delta = 0; : 
2
strstr : for : 	s64 steal = 0, irq_delta = 0; : 
2
strstr : while : 	s64 steal = 0, irq_delta = 0; : 
2
str : #endif[6]
strstr : INIT : #endif : 
2
strstr : if : #endif : 
2
strstr : for : #endif : 
2
strstr : while : #endif : 
2
str : #ifdef CONFIG_IRQ_TIME_ACCOUNTING[33]
strstr : INIT : #ifdef CONFIG_IRQ_TIME_ACCOUNTING : 
2
strstr : if : #ifdef CONFIG_IRQ_TIME_ACCOUNTING : 
2
strstr : for : #ifdef CONFIG_IRQ_TIME_ACCOUNTING : 
2
strstr : while : #ifdef CONFIG_IRQ_TIME_ACCOUNTING : 
2
str : 	irq_delta = irq_time_read(cpu_of(rq)) - rq->prev_irq_time;[59]
strstr : INIT : 	irq_delta = irq_time_read(cpu_of(rq)) - rq->prev_irq_time; : 
2
strstr : if : 	irq_delta = irq_time_read(cpu_of(rq)) - rq->prev_irq_time; : 
2
strstr : for : 	irq_delta = irq_time_read(cpu_of(rq)) - rq->prev_irq_time; : 
2
strstr : while : 	irq_delta = irq_time_read(cpu_of(rq)) - rq->prev_irq_time; : 
2
str : 	/*[3]
strstr : INIT : 	/* : 
2
strstr : if : 	/* : 
2
strstr : for : 	/* : 
2
strstr : while : 	/* : 
2
str : 	 * Since irq_time is only updated on {soft,}irq_exit, we might run into[72]
strstr : INIT : 	 * Since irq_time is only updated on {soft,}irq_exit, we might run into : 
2
strstr : if : 	 * Since irq_time is only updated on {soft,}irq_exit, we might run into : 
2
strstr : for : 	 * Since irq_time is only updated on {soft,}irq_exit, we might run into : 
2
strstr : while : 	 * Since irq_time is only updated on {soft,}irq_exit, we might run into : 
2
str : 	 * this case when a previous update_rq_clock() happened inside a[65]
strstr : INIT : 	 * this case when a previous update_rq_clock() happened inside a : 
2
strstr : if : 	 * this case when a previous update_rq_clock() happened inside a : 
2
strstr : for : 	 * this case when a previous update_rq_clock() happened inside a : 
2
strstr : while : 	 * this case when a previous update_rq_clock() happened inside a : 
2
str : 	 * {soft,}irq region.[22]
strstr : INIT : 	 * {soft,}irq region. : 
2
strstr : if : 	 * {soft,}irq region. : 
2
strstr : for : 	 * {soft,}irq region. : 
2
strstr : while : 	 * {soft,}irq region. : 
2
str : 	 *[3]
strstr : INIT : 	 * : 
2
strstr : if : 	 * : 
2
strstr : for : 	 * : 
2
strstr : while : 	 * : 
2
str : 	 * When this happens, we stop ->clock_task and only update the[63]
strstr : INIT : 	 * When this happens, we stop ->clock_task and only update the : 
2
strstr : if : 	 * When this happens, we stop ->clock_task and only update the : 
2
strstr : for : 	 * When this happens, we stop ->clock_task and only update the : 
2
strstr : while : 	 * When this happens, we stop ->clock_task and only update the : 
2
str : 	 * prev_irq_time stamp to account for the part that fit, so that a next[72]
strstr : INIT : 	 * prev_irq_time stamp to account for the part that fit, so that a next : 
2
strstr : if : 	 * prev_irq_time stamp to account for the part that fit, so that a next : 
2
strstr : for : 	 * prev_irq_time stamp to account for the part that fit, so that a next : 
2
strstr : while : 	 * prev_irq_time stamp to account for the part that fit, so that a next : 
2
str : 	 * update will consume the rest. This ensures ->clock_task is[62]
strstr : INIT : 	 * update will consume the rest. This ensures ->clock_task is : 
2
strstr : if : 	 * update will consume the rest. This ensures ->clock_task is : 
2
strstr : for : 	 * update will consume the rest. This ensures ->clock_task is : 
2
strstr : while : 	 * update will consume the rest. This ensures ->clock_task is : 
2
str : 	 * monotonic.[14]
strstr : INIT : 	 * monotonic. : 
2
strstr : if : 	 * monotonic. : 
2
strstr : for : 	 * monotonic. : 
2
strstr : while : 	 * monotonic. : 
2
str : 	 *[3]
strstr : INIT : 	 * : 
2
strstr : if : 	 * : 
2
strstr : for : 	 * : 
2
strstr : while : 	 * : 
2
str : 	 * It does however cause some slight miss-attribution of {soft,}irq[68]
strstr : INIT : 	 * It does however cause some slight miss-attribution of {soft,}irq : 
2
strstr : if : 	 * It does however cause some slight miss-attribution of {soft,}irq : 
2
strstr : for : 	 * It does however cause some slight miss-attribution of {soft,}irq : 
2
strstr : while : 	 * It does however cause some slight miss-attribution of {soft,}irq : 
2
str : 	 * time, a more accurate solution would be to update the irq_time using[72]
strstr : INIT : 	 * time, a more accurate solution would be to update the irq_time using : 
2
strstr : if : 	 * time, a more accurate solution would be to update the irq_time using : 
2
strstr : for : 	 * time, a more accurate solution would be to update the irq_time using : 
2
strstr : while : 	 * time, a more accurate solution would be to update the irq_time using : 
2
str : 	 * the current rq->clock timestamp, except that would require using[68]
strstr : INIT : 	 * the current rq->clock timestamp, except that would require using : 
2
strstr : if : 	 * the current rq->clock timestamp, except that would require using : 
2
strstr : for : 	 * the current rq->clock timestamp, except that would require using : 
2
strstr : while : 	 * the current rq->clock timestamp, except that would require using : 
2
str : 	 * atomic ops.[15]
strstr : INIT : 	 * atomic ops. : 
2
strstr : if : 	 * atomic ops. : 
2
strstr : for : 	 * atomic ops. : 
2
strstr : while : 	 * atomic ops. : 
2
str : 	 */[4]
strstr : INIT : 	 */ : 
2
strstr : if : 	 */ : 
2
strstr : for : 	 */ : 
2
strstr : while : 	 */ : 
2
str : 	if (irq_delta > delta)[23]
strstr : INIT : 	if (irq_delta > delta) : 
2
strstr : if : 	if (irq_delta > delta) : 
2
strstr : for : 	if (irq_delta > delta) : 
2
strstr : while : 	if (irq_delta > delta) : 
2
str : 		irq_delta = delta;[20]
strstr : INIT : 		irq_delta = delta; : 
2
strstr : if : 		irq_delta = delta; : 
2
strstr : for : 		irq_delta = delta; : 
2
strstr : while : 		irq_delta = delta; : 
2
str : 	rq->prev_irq_time += irq_delta;[32]
strstr : INIT : 	rq->prev_irq_time += irq_delta; : 
2
strstr : if : 	rq->prev_irq_time += irq_delta; : 
2
strstr : for : 	rq->prev_irq_time += irq_delta; : 
2
strstr : while : 	rq->prev_irq_time += irq_delta; : 
2
str : 	delta -= irq_delta;[20]
strstr : INIT : 	delta -= irq_delta; : 
2
strstr : if : 	delta -= irq_delta; : 
2
strstr : for : 	delta -= irq_delta; : 
2
strstr : while : 	delta -= irq_delta; : 
2
str : #endif[6]
strstr : INIT : #endif : 
2
strstr : if : #endif : 
2
strstr : for : #endif : 
2
strstr : while : #endif : 
2
str : #ifdef CONFIG_PARAVIRT_TIME_ACCOUNTING[38]
strstr : INIT : #ifdef CONFIG_PARAVIRT_TIME_ACCOUNTING : 
2
strstr : if : #ifdef CONFIG_PARAVIRT_TIME_ACCOUNTING : 
2
strstr : for : #ifdef CONFIG_PARAVIRT_TIME_ACCOUNTING : 
2
strstr : while : #ifdef CONFIG_PARAVIRT_TIME_ACCOUNTING : 
2
str : 	if (static_key_false((&paravirt_steal_rq_enabled))) {[54]
strstr : INIT : 	if (static_key_false((&paravirt_steal_rq_enabled))) { : 
2
strstr : if : 	if (static_key_false((&paravirt_steal_rq_enabled))) { : 
2
strstr : for : 	if (static_key_false((&paravirt_steal_rq_enabled))) { : 
2
strstr : while : 	if (static_key_false((&paravirt_steal_rq_enabled))) { : 
2
str : 		u64 st;[9]
strstr : INIT : 		u64 st; : 
2
strstr : if : 		u64 st; : 
2
strstr : for : 		u64 st; : 
2
strstr : while : 		u64 st; : 
2
str : 		steal = paravirt_steal_clock(cpu_of(rq));[43]
strstr : INIT : 		steal = paravirt_steal_clock(cpu_of(rq)); : 
2
strstr : if : 		steal = paravirt_steal_clock(cpu_of(rq)); : 
2
strstr : for : 		steal = paravirt_steal_clock(cpu_of(rq)); : 
2
strstr : while : 		steal = paravirt_steal_clock(cpu_of(rq)); : 
2
str : 		steal -= rq->prev_steal_time_rq;[34]
strstr : INIT : 		steal -= rq->prev_steal_time_rq; : 
2
strstr : if : 		steal -= rq->prev_steal_time_rq; : 
2
strstr : for : 		steal -= rq->prev_steal_time_rq; : 
2
strstr : while : 		steal -= rq->prev_steal_time_rq; : 
2
str : 		if (unlikely(steal > delta))[30]
strstr : INIT : 		if (unlikely(steal > delta)) : 
2
strstr : if : 		if (unlikely(steal > delta)) : 
2
strstr : for : 		if (unlikely(steal > delta)) : 
2
strstr : while : 		if (unlikely(steal > delta)) : 
2
str : 			steal = delta;[17]
strstr : INIT : 			steal = delta; : 
2
strstr : if : 			steal = delta; : 
2
strstr : for : 			steal = delta; : 
2
strstr : while : 			steal = delta; : 
2
str : 		st = steal_ticks(steal);[26]
strstr : INIT : 		st = steal_ticks(steal); : 
2
strstr : if : 		st = steal_ticks(steal); : 
2
strstr : for : 		st = steal_ticks(steal); : 
2
strstr : while : 		st = steal_ticks(steal); : 
2
str : 		steal = st * TICK_NSEC;[25]
strstr : INIT : 		steal = st * TICK_NSEC; : 
2
strstr : if : 		steal = st * TICK_NSEC; : 
2
strstr : for : 		steal = st * TICK_NSEC; : 
2
strstr : while : 		steal = st * TICK_NSEC; : 
2
str : 		rq->prev_steal_time_rq += steal;[34]
strstr : INIT : 		rq->prev_steal_time_rq += steal; : 
2
strstr : if : 		rq->prev_steal_time_rq += steal; : 
2
strstr : for : 		rq->prev_steal_time_rq += steal; : 
2
strstr : while : 		rq->prev_steal_time_rq += steal; : 
2
str : 		delta -= steal;[17]
strstr : INIT : 		delta -= steal; : 
2
strstr : if : 		delta -= steal; : 
2
strstr : for : 		delta -= steal; : 
2
strstr : while : 		delta -= steal; : 
2
str : #endif[6]
strstr : INIT : #endif : 
2
strstr : if : #endif : 
2
strstr : for : #endif : 
2
strstr : while : #endif : 
2
str : 	rq->clock_task += delta;[25]
strstr : INIT : 	rq->clock_task += delta; : 
2
strstr : if : 	rq->clock_task += delta; : 
2
strstr : for : 	rq->clock_task += delta; : 
2
strstr : while : 	rq->clock_task += delta; : 
2
str : #if defined(CONFIG_IRQ_TIME_ACCOUNTING) || defined(CONFIG_PARAVIRT_TIME_ACCOUNTING)[83]
strstr : INIT : #if defined(CONFIG_IRQ_TIME_ACCOUNTING) || defined(CONFIG_PARAVIRT_TIME_ACCOUNTING) : 
2
strstr : if : #if defined(CONFIG_IRQ_TIME_ACCOUNTING) || defined(CONFIG_PARAVIRT_TIME_ACCOUNTING) : 
2
strstr : for : #if defined(CONFIG_IRQ_TIME_ACCOUNTING) || defined(CONFIG_PARAVIRT_TIME_ACCOUNTING) : 
2
strstr : while : #if defined(CONFIG_IRQ_TIME_ACCOUNTING) || defined(CONFIG_PARAVIRT_TIME_ACCOUNTING) : 
2
str : 	if ((irq_delta + steal) && sched_feat(NONTASK_POWER))[54]
strstr : INIT : 	if ((irq_delta + steal) && sched_feat(NONTASK_POWER)) : 
2
strstr : if : 	if ((irq_delta + steal) && sched_feat(NONTASK_POWER)) : 
2
strstr : for : 	if ((irq_delta + steal) && sched_feat(NONTASK_POWER)) : 
2
strstr : while : 	if ((irq_delta + steal) && sched_feat(NONTASK_POWER)) : 
2
str : 		sched_rt_avg_update(rq, irq_delta + steal);[45]
strstr : INIT : 		sched_rt_avg_update(rq, irq_delta + steal); : 
2
strstr : if : 		sched_rt_avg_update(rq, irq_delta + steal); : 
2
strstr : for : 		sched_rt_avg_update(rq, irq_delta + steal); : 
2
strstr : while : 		sched_rt_avg_update(rq, irq_delta + steal); : 
2
str : #endif[6]
strstr : INIT : #endif : 
2
strstr : if : #endif : 
2
strstr : for : #endif : 
2
strstr : while : #endif : 
2
str : void sched_set_stop_task(int cpu, struct task_struct *stop)[59]
strstr : INIT : void sched_set_stop_task(int cpu, struct task_struct *stop) : 
2
strstr : if : void sched_set_stop_task(int cpu, struct task_struct *stop) : 
2
strstr : for : void sched_set_stop_task(int cpu, struct task_struct *stop) : 
2
strstr : while : void sched_set_stop_task(int cpu, struct task_struct *stop) : 
2
str : 	struct sched_param param = { .sched_priority = MAX_RT_PRIO - 1 };[66]
strstr : INIT : 	struct sched_param param = { .sched_priority = MAX_RT_PRIO - 1 }; : 
2
strstr : if : 	struct sched_param param = { .sched_priority = MAX_RT_PRIO - 1 }; : 
2
strstr : for : 	struct sched_param param = { .sched_priority = MAX_RT_PRIO - 1 }; : 
2
strstr : while : 	struct sched_param param = { .sched_priority = MAX_RT_PRIO - 1 }; : 
2
str : 	struct task_struct *old_stop = cpu_rq(cpu)->stop;[50]
strstr : INIT : 	struct task_struct *old_stop = cpu_rq(cpu)->stop; : 
2
strstr : if : 	struct task_struct *old_stop = cpu_rq(cpu)->stop; : 
2
strstr : for : 	struct task_struct *old_stop = cpu_rq(cpu)->stop; : 
2
strstr : while : 	struct task_struct *old_stop = cpu_rq(cpu)->stop; : 
2
str : 	if (stop) {[12]
strstr : INIT : 	if (stop) { : 
2
strstr : if : 	if (stop) { : 
2
strstr : for : 	if (stop) { : 
2
strstr : while : 	if (stop) { : 
2
str : 		/*[4]
strstr : INIT : 		/* : 
2
strstr : if : 		/* : 
2
strstr : for : 		/* : 
2
strstr : while : 		/* : 
2
str : 		 * Make it appear like a SCHED_FIFO task, its something[57]
strstr : INIT : 		 * Make it appear like a SCHED_FIFO task, its something : 
2
strstr : if : 		 * Make it appear like a SCHED_FIFO task, its something : 
2
strstr : for : 		 * Make it appear like a SCHED_FIFO task, its something : 
2
strstr : while : 		 * Make it appear like a SCHED_FIFO task, its something : 
2
str : 		 * userspace knows about and won't get confused about.[56]
strstr : INIT : 		 * userspace knows about and won't get confused about. : 
2
strstr : if : 		 * userspace knows about and won't get confused about. : 
2
strstr : for : 		 * userspace knows about and won't get confused about. : 
2
strstr : while : 		 * userspace knows about and won't get confused about. : 
2
str : 		 *[4]
strstr : INIT : 		 * : 
2
strstr : if : 		 * : 
2
strstr : for : 		 * : 
2
strstr : while : 		 * : 
2
str : 		 * Also, it will make PI more or less work without too[56]
strstr : INIT : 		 * Also, it will make PI more or less work without too : 
2
strstr : if : 		 * Also, it will make PI more or less work without too : 
2
strstr : for : 		 * Also, it will make PI more or less work without too : 
2
strstr : while : 		 * Also, it will make PI more or less work without too : 
2
str : 		 * much confusion -- but then, stop work should not[53]
strstr : INIT : 		 * much confusion -- but then, stop work should not : 
2
strstr : if : 		 * much confusion -- but then, stop work should not : 
2
strstr : for : 		 * much confusion -- but then, stop work should not : 
2
strstr : while : 		 * much confusion -- but then, stop work should not : 
2
str : 		 * rely on PI working anyway.[31]
strstr : INIT : 		 * rely on PI working anyway. : 
2
strstr : if : 		 * rely on PI working anyway. : 
2
strstr : for : 		 * rely on PI working anyway. : 
2
strstr : while : 		 * rely on PI working anyway. : 
2
str : 		 */[5]
strstr : INIT : 		 */ : 
2
strstr : if : 		 */ : 
2
strstr : for : 		 */ : 
2
strstr : while : 		 */ : 
2
str : 		sched_setscheduler_nocheck(stop, SCHED_FIFO, &param);[55]
strstr : INIT : 		sched_setscheduler_nocheck(stop, SCHED_FIFO, &param); : 
2
strstr : if : 		sched_setscheduler_nocheck(stop, SCHED_FIFO, &param); : 
2
strstr : for : 		sched_setscheduler_nocheck(stop, SCHED_FIFO, &param); : 
2
strstr : while : 		sched_setscheduler_nocheck(stop, SCHED_FIFO, &param); : 
2
str : 		stop->sched_class = &stop_sched_class;[40]
strstr : INIT : 		stop->sched_class = &stop_sched_class; : 
2
strstr : if : 		stop->sched_class = &stop_sched_class; : 
2
strstr : for : 		stop->sched_class = &stop_sched_class; : 
2
strstr : while : 		stop->sched_class = &stop_sched_class; : 
2
str : 	cpu_rq(cpu)->stop = stop;[26]
strstr : INIT : 	cpu_rq(cpu)->stop = stop; : 
2
strstr : if : 	cpu_rq(cpu)->stop = stop; : 
2
strstr : for : 	cpu_rq(cpu)->stop = stop; : 
2
strstr : while : 	cpu_rq(cpu)->stop = stop; : 
2
str : 	if (old_stop) {[16]
strstr : INIT : 	if (old_stop) { : 
2
strstr : if : 	if (old_stop) { : 
2
strstr : for : 	if (old_stop) { : 
2
strstr : while : 	if (old_stop) { : 
2
str : 		/*[4]
strstr : INIT : 		/* : 
2
strstr : if : 		/* : 
2
strstr : for : 		/* : 
2
strstr : while : 		/* : 
2
str : 		 * Reset it back to a normal scheduling class so that[55]
strstr : INIT : 		 * Reset it back to a normal scheduling class so that : 
2
strstr : if : 		 * Reset it back to a normal scheduling class so that : 
2
strstr : for : 		 * Reset it back to a normal scheduling class so that : 
2
strstr : while : 		 * Reset it back to a normal scheduling class so that : 
2
str : 		 * it can die in pieces.[26]
strstr : INIT : 		 * it can die in pieces. : 
2
strstr : if : 		 * it can die in pieces. : 
2
strstr : for : 		 * it can die in pieces. : 
2
strstr : while : 		 * it can die in pieces. : 
2
str : 		 */[5]
strstr : INIT : 		 */ : 
2
strstr : if : 		 */ : 
2
strstr : for : 		 */ : 
2
strstr : while : 		 */ : 
2
str : 		old_stop->sched_class = &rt_sched_class;[42]
strstr : INIT : 		old_stop->sched_class = &rt_sched_class; : 
2
strstr : if : 		old_stop->sched_class = &rt_sched_class; : 
2
strstr : for : 		old_stop->sched_class = &rt_sched_class; : 
2
strstr : while : 		old_stop->sched_class = &rt_sched_class; : 
2
str :  * __normal_prio - return the priority that is based on the static prio[71]
strstr : INIT :  * __normal_prio - return the priority that is based on the static prio : 
2
strstr : if :  * __normal_prio - return the priority that is based on the static prio : 
2
strstr : for :  * __normal_prio - return the priority that is based on the static prio : 
2
strstr : while :  * __normal_prio - return the priority that is based on the static prio : 
2
str :  */[3]
strstr : INIT :  */ : 
2
strstr : if :  */ : 
2
strstr : for :  */ : 
2
strstr : while :  */ : 
2
str : static inline int __normal_prio(struct task_struct *p)[54]
strstr : INIT : static inline int __normal_prio(struct task_struct *p) : 
2
strstr : if : static inline int __normal_prio(struct task_struct *p) : 
2
strstr : for : static inline int __normal_prio(struct task_struct *p) : 
2
strstr : while : static inline int __normal_prio(struct task_struct *p) : 
2
str : 	return p->static_prio;[23]
strstr : INIT : 	return p->static_prio; : 
2
strstr : if : 	return p->static_prio; : 
2
strstr : for : 	return p->static_prio; : 
2
strstr : while : 	return p->static_prio; : 
2
str :  * Calculate the expected normal priority: i.e. priority[56]
strstr : INIT :  * Calculate the expected normal priority: i.e. priority : 
2
strstr : if :  * Calculate the expected normal priority: i.e. priority : 
2
strstr : for :  * Calculate the expected normal priority: i.e. priority : 
2
strstr : while :  * Calculate the expected normal priority: i.e. priority : 
2
str :  * without taking RT-inheritance into account. Might be[55]
strstr : INIT :  * without taking RT-inheritance into account. Might be : 
2
strstr : if :  * without taking RT-inheritance into account. Might be : 
2
strstr : for :  * without taking RT-inheritance into account. Might be : 
2
strstr : while :  * without taking RT-inheritance into account. Might be : 
2
str :  * boosted by interactivity modifiers. Changes upon fork,[57]
strstr : INIT :  * boosted by interactivity modifiers. Changes upon fork, : 
2
strstr : if :  * boosted by interactivity modifiers. Changes upon fork, : 
2
strstr : for :  * boosted by interactivity modifiers. Changes upon fork, : 
2
strstr : while :  * boosted by interactivity modifiers. Changes upon fork, : 
2
str :  * setprio syscalls, and whenever the interactivity[51]
strstr : INIT :  * setprio syscalls, and whenever the interactivity : 
2
strstr : if :  * setprio syscalls, and whenever the interactivity : 
2
strstr : for :  * setprio syscalls, and whenever the interactivity : 
2
strstr : while :  * setprio syscalls, and whenever the interactivity : 
2
str :  * estimator recalculates.[26]
strstr : INIT :  * estimator recalculates. : 
2
strstr : if :  * estimator recalculates. : 
2
strstr : for :  * estimator recalculates. : 
2
strstr : while :  * estimator recalculates. : 
2
str :  */[3]
strstr : INIT :  */ : 
2
strstr : if :  */ : 
2
strstr : for :  */ : 
2
strstr : while :  */ : 
2
str : static inline int normal_prio(struct task_struct *p)[52]
strstr : INIT : static inline int normal_prio(struct task_struct *p) : 
2
strstr : if : static inline int normal_prio(struct task_struct *p) : 
2
strstr : for : static inline int normal_prio(struct task_struct *p) : 
2
strstr : while : static inline int normal_prio(struct task_struct *p) : 
2
str : 	int prio;[10]
strstr : INIT : 	int prio; : 
2
strstr : if : 	int prio; : 
2
strstr : for : 	int prio; : 
2
strstr : while : 	int prio; : 
2
str : 	if (task_has_dl_policy(p))[27]
strstr : INIT : 	if (task_has_dl_policy(p)) : 
2
strstr : if : 	if (task_has_dl_policy(p)) : 
2
strstr : for : 	if (task_has_dl_policy(p)) : 
2
strstr : while : 	if (task_has_dl_policy(p)) : 
2
str : 		prio = MAX_DL_PRIO-1;[23]
strstr : INIT : 		prio = MAX_DL_PRIO-1; : 
2
strstr : if : 		prio = MAX_DL_PRIO-1; : 
2
strstr : for : 		prio = MAX_DL_PRIO-1; : 
2
strstr : while : 		prio = MAX_DL_PRIO-1; : 
2
str : 	else if (task_has_rt_policy(p))[32]
strstr : INIT : 	else if (task_has_rt_policy(p)) : 
2
strstr : if : 	else if (task_has_rt_policy(p)) : 
2
strstr : for : 	else if (task_has_rt_policy(p)) : 
2
strstr : while : 	else if (task_has_rt_policy(p)) : 
2
str : 		prio = MAX_RT_PRIO-1 - p->rt_priority;[40]
strstr : INIT : 		prio = MAX_RT_PRIO-1 - p->rt_priority; : 
2
strstr : if : 		prio = MAX_RT_PRIO-1 - p->rt_priority; : 
2
strstr : for : 		prio = MAX_RT_PRIO-1 - p->rt_priority; : 
2
strstr : while : 		prio = MAX_RT_PRIO-1 - p->rt_priority; : 
2
str : 	else[5]
strstr : INIT : 	else : 
2
strstr : if : 	else : 
2
strstr : for : 	else : 
2
strstr : while : 	else : 
2
str : 		prio = __normal_prio(p);[26]
strstr : INIT : 		prio = __normal_prio(p); : 
2
strstr : if : 		prio = __normal_prio(p); : 
2
strstr : for : 		prio = __normal_prio(p); : 
2
strstr : while : 		prio = __normal_prio(p); : 
2
str : 	return prio;[13]
strstr : INIT : 	return prio; : 
2
strstr : if : 	return prio; : 
2
strstr : for : 	return prio; : 
2
strstr : while : 	return prio; : 
2
str :  * Calculate the current priority, i.e. the priority[52]
strstr : INIT :  * Calculate the current priority, i.e. the priority : 
2
strstr : if :  * Calculate the current priority, i.e. the priority : 
2
strstr : for :  * Calculate the current priority, i.e. the priority : 
2
strstr : while :  * Calculate the current priority, i.e. the priority : 
2
str :  * taken into account by the scheduler. This value might[56]
strstr : INIT :  * taken into account by the scheduler. This value might : 
2
strstr : if :  * taken into account by the scheduler. This value might : 
2
strstr : for :  * taken into account by the scheduler. This value might : 
2
strstr : while :  * taken into account by the scheduler. This value might : 
2
str :  * be boosted by RT tasks, or might be boosted by[49]
strstr : INIT :  * be boosted by RT tasks, or might be boosted by : 
2
strstr : if :  * be boosted by RT tasks, or might be boosted by : 
2
strstr : for :  * be boosted by RT tasks, or might be boosted by : 
2
strstr : while :  * be boosted by RT tasks, or might be boosted by : 
2
str :  * interactivity modifiers. Will be RT if the task got[54]
strstr : INIT :  * interactivity modifiers. Will be RT if the task got : 
2
strstr : if :  * interactivity modifiers. Will be RT if the task got : 
2
strstr : for :  * interactivity modifiers. Will be RT if the task got : 
2
strstr : while :  * interactivity modifiers. Will be RT if the task got : 
2
str :  * RT-boosted. If not then it returns p->normal_prio.[53]
strstr : INIT :  * RT-boosted. If not then it returns p->normal_prio. : 
2
strstr : if :  * RT-boosted. If not then it returns p->normal_prio. : 
2
strstr : for :  * RT-boosted. If not then it returns p->normal_prio. : 
2
strstr : while :  * RT-boosted. If not then it returns p->normal_prio. : 
2
str :  */[3]
strstr : INIT :  */ : 
2
strstr : if :  */ : 
2
strstr : for :  */ : 
2
strstr : while :  */ : 
2
str : static int effective_prio(struct task_struct *p)[48]
strstr : INIT : static int effective_prio(struct task_struct *p) : 
2
strstr : if : static int effective_prio(struct task_struct *p) : 
2
strstr : for : static int effective_prio(struct task_struct *p) : 
2
strstr : while : static int effective_prio(struct task_struct *p) : 
2
str : 	p->normal_prio = normal_prio(p);[33]
strstr : INIT : 	p->normal_prio = normal_prio(p); : 
2
strstr : if : 	p->normal_prio = normal_prio(p); : 
2
strstr : for : 	p->normal_prio = normal_prio(p); : 
2
strstr : while : 	p->normal_prio = normal_prio(p); : 
2
str : 	/*[3]
strstr : INIT : 	/* : 
2
strstr : if : 	/* : 
2
strstr : for : 	/* : 
2
strstr : while : 	/* : 
2
str : 	 * If we are RT tasks or we were boosted to RT priority,[57]
strstr : INIT : 	 * If we are RT tasks or we were boosted to RT priority, : 
2
strstr : if : 	 * If we are RT tasks or we were boosted to RT priority, : 
2
strstr : for : 	 * If we are RT tasks or we were boosted to RT priority, : 
2
strstr : while : 	 * If we are RT tasks or we were boosted to RT priority, : 
2
str : 	 * keep the priority unchanged. Otherwise, update priority[59]
strstr : INIT : 	 * keep the priority unchanged. Otherwise, update priority : 
2
strstr : if : 	 * keep the priority unchanged. Otherwise, update priority : 
2
strstr : for : 	 * keep the priority unchanged. Otherwise, update priority : 
2
strstr : while : 	 * keep the priority unchanged. Otherwise, update priority : 
2
str : 	 * to the normal priority:[27]
strstr : INIT : 	 * to the normal priority: : 
2
strstr : if : 	 * to the normal priority: : 
2
strstr : for : 	 * to the normal priority: : 
2
strstr : while : 	 * to the normal priority: : 
2
str : 	 */[4]
strstr : INIT : 	 */ : 
2
strstr : if : 	 */ : 
2
strstr : for : 	 */ : 
2
strstr : while : 	 */ : 
2
str : 	if (!rt_prio(p->prio))[23]
strstr : INIT : 	if (!rt_prio(p->prio)) : 
2
strstr : if : 	if (!rt_prio(p->prio)) : 
2
strstr : for : 	if (!rt_prio(p->prio)) : 
2
strstr : while : 	if (!rt_prio(p->prio)) : 
2
str : 		return p->normal_prio;[24]
strstr : INIT : 		return p->normal_prio; : 
2
strstr : if : 		return p->normal_prio; : 
2
strstr : for : 		return p->normal_prio; : 
2
strstr : while : 		return p->normal_prio; : 
2
str : 	return p->prio;[16]
strstr : INIT : 	return p->prio; : 
2
strstr : if : 	return p->prio; : 
2
strstr : for : 	return p->prio; : 
2
strstr : while : 	return p->prio; : 
2
str : /**[3]
strstr : INIT : /** : 
2
strstr : if : /** : 
2
strstr : for : /** : 
2
strstr : while : /** : 
2
str :  * task_curr - is this task currently executing on a CPU?[57]
strstr : INIT :  * task_curr - is this task currently executing on a CPU? : 
2
strstr : if :  * task_curr - is this task currently executing on a CPU? : 
2
strstr : for :  * task_curr - is this task currently executing on a CPU? : 
2
strstr : while :  * task_curr - is this task currently executing on a CPU? : 
2
str :  * @p: the task in question.[28]
strstr : INIT :  * @p: the task in question. : 
2
strstr : if :  * @p: the task in question. : 
2
strstr : for :  * @p: the task in question. : 
2
strstr : while :  * @p: the task in question. : 
2
str :  * Return: 1 if the task is currently executing. 0 otherwise.[61]
strstr : INIT :  * Return: 1 if the task is currently executing. 0 otherwise. : 
2
strstr : if :  * Return: 1 if the task is currently executing. 0 otherwise. : 
2
strstr : for :  * Return: 1 if the task is currently executing. 0 otherwise. : 
2
strstr : while :  * Return: 1 if the task is currently executing. 0 otherwise. : 
2
str :  */[3]
strstr : INIT :  */ : 
2
strstr : if :  */ : 
2
strstr : for :  */ : 
2
strstr : while :  */ : 
2
str : inline int task_curr(const struct task_struct *p)[49]
strstr : INIT : inline int task_curr(const struct task_struct *p) : 
2
strstr : if : inline int task_curr(const struct task_struct *p) : 
2
strstr : for : inline int task_curr(const struct task_struct *p) : 
2
strstr : while : inline int task_curr(const struct task_struct *p) : 
2
str : 	return cpu_curr(task_cpu(p)) == p;[35]
strstr : INIT : 	return cpu_curr(task_cpu(p)) == p; : 
2
strstr : if : 	return cpu_curr(task_cpu(p)) == p; : 
2
strstr : for : 	return cpu_curr(task_cpu(p)) == p; : 
2
strstr : while : 	return cpu_curr(task_cpu(p)) == p; : 
2
str : static inline void check_class_changed(struct rq *rq, struct task_struct *p,[76]
strstr : INIT : static inline void check_class_changed(struct rq *rq, struct task_struct *p, : 
2
strstr : if : static inline void check_class_changed(struct rq *rq, struct task_struct *p, : 
2
strstr : for : static inline void check_class_changed(struct rq *rq, struct task_struct *p, : 
2
strstr : while : static inline void check_class_changed(struct rq *rq, struct task_struct *p, : 
2
str : 				       const struct sched_class *prev_class,[48]
strstr : INIT : 				       const struct sched_class *prev_class, : 
2
strstr : if : 				       const struct sched_class *prev_class, : 
2
strstr : for : 				       const struct sched_class *prev_class, : 
2
strstr : while : 				       const struct sched_class *prev_class, : 
2
str : 				       int oldprio)[23]
strstr : INIT : 				       int oldprio) : 
2
strstr : if : 				       int oldprio) : 
2
strstr : for : 				       int oldprio) : 
2
strstr : while : 				       int oldprio) : 
2
str : 	if (prev_class != p->sched_class) {[36]
strstr : INIT : 	if (prev_class != p->sched_class) { : 
2
strstr : if : 	if (prev_class != p->sched_class) { : 
2
strstr : for : 	if (prev_class != p->sched_class) { : 
2
strstr : while : 	if (prev_class != p->sched_class) { : 
2
str : 		if (prev_class->switched_from)[32]
strstr : INIT : 		if (prev_class->switched_from) : 
2
strstr : if : 		if (prev_class->switched_from) : 
2
strstr : for : 		if (prev_class->switched_from) : 
2
strstr : while : 		if (prev_class->switched_from) : 
2
str : 			prev_class->switched_from(rq, p);[36]
strstr : INIT : 			prev_class->switched_from(rq, p); : 
2
strstr : if : 			prev_class->switched_from(rq, p); : 
2
strstr : for : 			prev_class->switched_from(rq, p); : 
2
strstr : while : 			prev_class->switched_from(rq, p); : 
2
str : 		p->sched_class->switched_to(rq, p);[37]
strstr : INIT : 		p->sched_class->switched_to(rq, p); : 
2
strstr : if : 		p->sched_class->switched_to(rq, p); : 
2
strstr : for : 		p->sched_class->switched_to(rq, p); : 
2
strstr : while : 		p->sched_class->switched_to(rq, p); : 
2
str : 	} else if (oldprio != p->prio || dl_task(p))[45]
strstr : INIT : 	} else if (oldprio != p->prio || dl_task(p)) : 
2
strstr : if : 	} else if (oldprio != p->prio || dl_task(p)) : 
2
strstr : for : 	} else if (oldprio != p->prio || dl_task(p)) : 
2
strstr : while : 	} else if (oldprio != p->prio || dl_task(p)) : 
2
str : 		p->sched_class->prio_changed(rq, p, oldprio);[47]
strstr : INIT : 		p->sched_class->prio_changed(rq, p, oldprio); : 
2
strstr : if : 		p->sched_class->prio_changed(rq, p, oldprio); : 
2
strstr : for : 		p->sched_class->prio_changed(rq, p, oldprio); : 
2
strstr : while : 		p->sched_class->prio_changed(rq, p, oldprio); : 
2
str : void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags)[72]
strstr : INIT : void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags) : 
2
strstr : if : void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags) : 
2
strstr : for : void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags) : 
2
strstr : while : void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags) : 
2
str : 	const struct sched_class *class;[33]
strstr : INIT : 	const struct sched_class *class; : 
2
strstr : if : 	const struct sched_class *class; : 
2
strstr : for : 	const struct sched_class *class; : 
2
strstr : while : 	const struct sched_class *class; : 
2
str : 	if (p->sched_class == rq->curr->sched_class) {[47]
strstr : INIT : 	if (p->sched_class == rq->curr->sched_class) { : 
2
strstr : if : 	if (p->sched_class == rq->curr->sched_class) { : 
2
strstr : for : 	if (p->sched_class == rq->curr->sched_class) { : 
2
strstr : while : 	if (p->sched_class == rq->curr->sched_class) { : 
2
str : 		rq->curr->sched_class->check_preempt_curr(rq, p, flags);[58]
strstr : INIT : 		rq->curr->sched_class->check_preempt_curr(rq, p, flags); : 
2
strstr : if : 		rq->curr->sched_class->check_preempt_curr(rq, p, flags); : 
2
strstr : for : 		rq->curr->sched_class->check_preempt_curr(rq, p, flags); : 
2
strstr : while : 		rq->curr->sched_class->check_preempt_curr(rq, p, flags); : 
2
str : 	} else {[9]
strstr : INIT : 	} else { : 
2
strstr : if : 	} else { : 
2
strstr : for : 	} else { : 
2
strstr : while : 	} else { : 
2
str : 		for_each_class(class) {[25]
strstr : INIT : 		for_each_class(class) { : 
2
strstr : if : 		for_each_class(class) { : 
2
strstr : for : 		for_each_class(class) { : 
2
strstr : while : 		for_each_class(class) { : 
2
str : 			if (class == rq->curr->sched_class)[38]
strstr : INIT : 			if (class == rq->curr->sched_class) : 
2
strstr : if : 			if (class == rq->curr->sched_class) : 
2
strstr : for : 			if (class == rq->curr->sched_class) : 
2
strstr : while : 			if (class == rq->curr->sched_class) : 
2
str : 				break;[10]
strstr : INIT : 				break; : 
2
strstr : if : 				break; : 
2
strstr : for : 				break; : 
2
strstr : while : 				break; : 
2
str : 			if (class == p->sched_class) {[33]
strstr : INIT : 			if (class == p->sched_class) { : 
2
strstr : if : 			if (class == p->sched_class) { : 
2
strstr : for : 			if (class == p->sched_class) { : 
2
strstr : while : 			if (class == p->sched_class) { : 
2
str : 				resched_task(rq->curr);[27]
strstr : INIT : 				resched_task(rq->curr); : 
2
strstr : if : 				resched_task(rq->curr); : 
2
strstr : for : 				resched_task(rq->curr); : 
2
strstr : while : 				resched_task(rq->curr); : 
2
str : 				break;[10]
strstr : INIT : 				break; : 
2
strstr : if : 				break; : 
2
strstr : for : 				break; : 
2
strstr : while : 				break; : 
2
str : 			}[4]
strstr : INIT : 			} : 
2
strstr : if : 			} : 
2
strstr : for : 			} : 
2
strstr : while : 			} : 
2
str : 		}[3]
strstr : INIT : 		} : 
2
strstr : if : 		} : 
2
strstr : for : 		} : 
2
strstr : while : 		} : 
2
str : 	/*[3]
strstr : INIT : 	/* : 
2
strstr : if : 	/* : 
2
strstr : for : 	/* : 
2
strstr : while : 	/* : 
2
str : 	 * A queue event has occurred, and we're going to schedule.  In[64]
strstr : INIT : 	 * A queue event has occurred, and we're going to schedule.  In : 
2
strstr : if : 	 * A queue event has occurred, and we're going to schedule.  In : 
2
strstr : for : 	 * A queue event has occurred, and we're going to schedule.  In : 
2
strstr : while : 	 * A queue event has occurred, and we're going to schedule.  In : 
2
str : 	 * this case, we can save a useless back to back clock update.[63]
strstr : INIT : 	 * this case, we can save a useless back to back clock update. : 
2
strstr : if : 	 * this case, we can save a useless back to back clock update. : 
2
strstr : for : 	 * this case, we can save a useless back to back clock update. : 
2
strstr : while : 	 * this case, we can save a useless back to back clock update. : 
2
str : 	 */[4]
strstr : INIT : 	 */ : 
2
strstr : if : 	 */ : 
2
strstr : for : 	 */ : 
2
strstr : while : 	 */ : 
2
str : 	if (rq->curr->on_rq && test_tsk_need_resched(rq->curr))[56]
strstr : INIT : 	if (rq->curr->on_rq && test_tsk_need_resched(rq->curr)) : 
2
strstr : if : 	if (rq->curr->on_rq && test_tsk_need_resched(rq->curr)) : 
2
strstr : for : 	if (rq->curr->on_rq && test_tsk_need_resched(rq->curr)) : 
2
strstr : while : 	if (rq->curr->on_rq && test_tsk_need_resched(rq->curr)) : 
2
str : 		rq->skip_clock_update = 1;[28]
strstr : INIT : 		rq->skip_clock_update = 1; : 
2
strstr : if : 		rq->skip_clock_update = 1; : 
2
strstr : for : 		rq->skip_clock_update = 1; : 
2
strstr : while : 		rq->skip_clock_update = 1; : 
2
str : #ifdef CONFIG_SMP[17]
strstr : INIT : #ifdef CONFIG_SMP : 
2
strstr : if : #ifdef CONFIG_SMP : 
2
strstr : for : #ifdef CONFIG_SMP : 
2
strstr : while : #ifdef CONFIG_SMP : 
2
str : void set_task_cpu(struct task_struct *p, unsigned int new_cpu)[62]
strstr : INIT : void set_task_cpu(struct task_struct *p, unsigned int new_cpu) : 
2
strstr : if : void set_task_cpu(struct task_struct *p, unsigned int new_cpu) : 
2
strstr : for : void set_task_cpu(struct task_struct *p, unsigned int new_cpu) : 
2
strstr : while : void set_task_cpu(struct task_struct *p, unsigned int new_cpu) : 
2
str : #ifdef CONFIG_SCHED_DEBUG[25]
strstr : INIT : #ifdef CONFIG_SCHED_DEBUG : 
2
strstr : if : #ifdef CONFIG_SCHED_DEBUG : 
2
strstr : for : #ifdef CONFIG_SCHED_DEBUG : 
2
strstr : while : #ifdef CONFIG_SCHED_DEBUG : 
2
str : 	/*[3]
strstr : INIT : 	/* : 
2
strstr : if : 	/* : 
2
strstr : for : 	/* : 
2
strstr : while : 	/* : 
2
str : 	 * We should never call set_task_cpu() on a blocked task,[58]
strstr : INIT : 	 * We should never call set_task_cpu() on a blocked task, : 
2
strstr : if : 	 * We should never call set_task_cpu() on a blocked task, : 
2
strstr : for : 	 * We should never call set_task_cpu() on a blocked task, : 
2
strstr : while : 	 * We should never call set_task_cpu() on a blocked task, : 
2
str : 	 * ttwu() will sort out the placement.[39]
strstr : INIT : 	 * ttwu() will sort out the placement. : 
2
strstr : if : 	 * ttwu() will sort out the placement. : 
2
strstr : for : 	 * ttwu() will sort out the placement. : 
2
strstr : while : 	 * ttwu() will sort out the placement. : 
2
str : 	 */[4]
strstr : INIT : 	 */ : 
2
strstr : if : 	 */ : 
2
strstr : for : 	 */ : 
2
strstr : while : 	 */ : 
2
str : 	WARN_ON_ONCE(p->state != TASK_RUNNING && p->state != TASK_WAKING &&[68]
strstr : INIT : 	WARN_ON_ONCE(p->state != TASK_RUNNING && p->state != TASK_WAKING && : 
2
strstr : if : 	WARN_ON_ONCE(p->state != TASK_RUNNING && p->state != TASK_WAKING && : 
2
strstr : for : 	WARN_ON_ONCE(p->state != TASK_RUNNING && p->state != TASK_WAKING && : 
2
strstr : while : 	WARN_ON_ONCE(p->state != TASK_RUNNING && p->state != TASK_WAKING && : 
2
str : 			!(task_preempt_count(p) & PREEMPT_ACTIVE));[46]
strstr : INIT : 			!(task_preempt_count(p) & PREEMPT_ACTIVE)); : 
2
strstr : if : 			!(task_preempt_count(p) & PREEMPT_ACTIVE)); : 
2
strstr : for : 			!(task_preempt_count(p) & PREEMPT_ACTIVE)); : 
2
strstr : while : 			!(task_preempt_count(p) & PREEMPT_ACTIVE)); : 
2
str : #ifdef CONFIG_LOCKDEP[21]
strstr : INIT : #ifdef CONFIG_LOCKDEP : 
2
strstr : if : #ifdef CONFIG_LOCKDEP : 
2
strstr : for : #ifdef CONFIG_LOCKDEP : 
2
strstr : while : #ifdef CONFIG_LOCKDEP : 
2
str : 	/*[3]
strstr : INIT : 	/* : 
2
strstr : if : 	/* : 
2
strstr : for : 	/* : 
2
strstr : while : 	/* : 
2
str : 	 * The caller should hold either p->pi_lock or rq->lock, when changing[71]
strstr : INIT : 	 * The caller should hold either p->pi_lock or rq->lock, when changing : 
2
strstr : if : 	 * The caller should hold either p->pi_lock or rq->lock, when changing : 
2
strstr : for : 	 * The caller should hold either p->pi_lock or rq->lock, when changing : 
2
strstr : while : 	 * The caller should hold either p->pi_lock or rq->lock, when changing : 
2
str : 	 * a task's CPU. ->pi_lock for waking tasks, rq->lock for runnable tasks.[74]
strstr : INIT : 	 * a task's CPU. ->pi_lock for waking tasks, rq->lock for runnable tasks. : 
2
strstr : if : 	 * a task's CPU. ->pi_lock for waking tasks, rq->lock for runnable tasks. : 
2
strstr : for : 	 * a task's CPU. ->pi_lock for waking tasks, rq->lock for runnable tasks. : 
2
strstr : while : 	 * a task's CPU. ->pi_lock for waking tasks, rq->lock for runnable tasks. : 
2
str : 	 *[3]
strstr : INIT : 	 * : 
2
strstr : if : 	 * : 
2
strstr : for : 	 * : 
2
strstr : while : 	 * : 
2
str : 	 * sched_move_task() holds both and thus holding either pins the cgroup,[73]
strstr : INIT : 	 * sched_move_task() holds both and thus holding either pins the cgroup, : 
2
strstr : if : 	 * sched_move_task() holds both and thus holding either pins the cgroup, : 
2
strstr : for : 	 * sched_move_task() holds both and thus holding either pins the cgroup, : 
2
strstr : while : 	 * sched_move_task() holds both and thus holding either pins the cgroup, : 
2
str : 	 * see task_group().[21]
strstr : INIT : 	 * see task_group(). : 
2
strstr : if : 	 * see task_group(). : 
2
strstr : for : 	 * see task_group(). : 
2
strstr : while : 	 * see task_group(). : 
2
str : 	 *[3]
strstr : INIT : 	 * : 
2
strstr : if : 	 * : 
2
strstr : for : 	 * : 
2
strstr : while : 	 * : 
2
str : 	 * Furthermore, all task_rq users should acquire both locks, see[65]
strstr : INIT : 	 * Furthermore, all task_rq users should acquire both locks, see : 
2
strstr : if : 	 * Furthermore, all task_rq users should acquire both locks, see : 
2
strstr : for : 	 * Furthermore, all task_rq users should acquire both locks, see : 
2
strstr : while : 	 * Furthermore, all task_rq users should acquire both locks, see : 
2
str : 	 * task_rq_lock().[19]
strstr : INIT : 	 * task_rq_lock(). : 
2
strstr : if : 	 * task_rq_lock(). : 
2
strstr : for : 	 * task_rq_lock(). : 
2
strstr : while : 	 * task_rq_lock(). : 
2
str : 	 */[4]
strstr : INIT : 	 */ : 
2
strstr : if : 	 */ : 
2
strstr : for : 	 */ : 
2
strstr : while : 	 */ : 
2
str : 	WARN_ON_ONCE(debug_locks && !(lockdep_is_held(&p->pi_lock) ||[62]
strstr : INIT : 	WARN_ON_ONCE(debug_locks && !(lockdep_is_held(&p->pi_lock) || : 
2
strstr : if : 	WARN_ON_ONCE(debug_locks && !(lockdep_is_held(&p->pi_lock) || : 
2
strstr : for : 	WARN_ON_ONCE(debug_locks && !(lockdep_is_held(&p->pi_lock) || : 
2
strstr : while : 	WARN_ON_ONCE(debug_locks && !(lockdep_is_held(&p->pi_lock) || : 
2
str : 				      lockdep_is_held(&task_rq(p)->lock)));[47]
strstr : INIT : 				      lockdep_is_held(&task_rq(p)->lock))); : 
2
strstr : if : 				      lockdep_is_held(&task_rq(p)->lock))); : 
2
strstr : for : 				      lockdep_is_held(&task_rq(p)->lock))); : 
2
strstr : while : 				      lockdep_is_held(&task_rq(p)->lock))); : 
2
str : #endif[6]
strstr : INIT : #endif : 
2
strstr : if : #endif : 
2
strstr : for : #endif : 
2
strstr : while : #endif : 
2
str : #endif[6]
strstr : INIT : #endif : 
2
strstr : if : #endif : 
2
strstr : for : #endif : 
2
strstr : while : #endif : 
2
str : 	trace_sched_migrate_task(p, new_cpu);[38]
strstr : INIT : 	trace_sched_migrate_task(p, new_cpu); : 
2
strstr : if : 	trace_sched_migrate_task(p, new_cpu); : 
2
strstr : for : 	trace_sched_migrate_task(p, new_cpu); : 
2
strstr : while : 	trace_sched_migrate_task(p, new_cpu); : 
2
str : 	if (task_cpu(p) != new_cpu) {[30]
strstr : INIT : 	if (task_cpu(p) != new_cpu) { : 
2
strstr : if : 	if (task_cpu(p) != new_cpu) { : 
2
strstr : for : 	if (task_cpu(p) != new_cpu) { : 
2
strstr : while : 	if (task_cpu(p) != new_cpu) { : 
2
str : 		if (p->sched_class->migrate_task_rq)[38]
strstr : INIT : 		if (p->sched_class->migrate_task_rq) : 
2
strstr : if : 		if (p->sched_class->migrate_task_rq) : 
2
strstr : for : 		if (p->sched_class->migrate_task_rq) : 
2
strstr : while : 		if (p->sched_class->migrate_task_rq) : 
2
str : 			p->sched_class->migrate_task_rq(p, new_cpu);[47]
strstr : INIT : 			p->sched_class->migrate_task_rq(p, new_cpu); : 
2
strstr : if : 			p->sched_class->migrate_task_rq(p, new_cpu); : 
2
strstr : for : 			p->sched_class->migrate_task_rq(p, new_cpu); : 
2
strstr : while : 			p->sched_class->migrate_task_rq(p, new_cpu); : 
2
str : 		p->se.nr_migrations++;[24]
strstr : INIT : 		p->se.nr_migrations++; : 
2
strstr : if : 		p->se.nr_migrations++; : 
2
strstr : for : 		p->se.nr_migrations++; : 
2
strstr : while : 		p->se.nr_migrations++; : 
2
str : 		perf_sw_event(PERF_COUNT_SW_CPU_MIGRATIONS, 1, NULL, 0);[58]
strstr : INIT : 		perf_sw_event(PERF_COUNT_SW_CPU_MIGRATIONS, 1, NULL, 0); : 
2
strstr : if : 		perf_sw_event(PERF_COUNT_SW_CPU_MIGRATIONS, 1, NULL, 0); : 
2
strstr : for : 		perf_sw_event(PERF_COUNT_SW_CPU_MIGRATIONS, 1, NULL, 0); : 
2
strstr : while : 		perf_sw_event(PERF_COUNT_SW_CPU_MIGRATIONS, 1, NULL, 0); : 
2
str : 	__set_task_cpu(p, new_cpu);[28]
strstr : INIT : 	__set_task_cpu(p, new_cpu); : 
2
strstr : if : 	__set_task_cpu(p, new_cpu); : 
2
strstr : for : 	__set_task_cpu(p, new_cpu); : 
2
strstr : while : 	__set_task_cpu(p, new_cpu); : 
2
str : static void __migrate_swap_task(struct task_struct *p, int cpu)[63]
strstr : INIT : static void __migrate_swap_task(struct task_struct *p, int cpu) : 
2
strstr : if : static void __migrate_swap_task(struct task_struct *p, int cpu) : 
2
strstr : for : static void __migrate_swap_task(struct task_struct *p, int cpu) : 
2
strstr : while : static void __migrate_swap_task(struct task_struct *p, int cpu) : 
2
str : 	if (p->on_rq) {[16]
strstr : INIT : 	if (p->on_rq) { : 
2
strstr : if : 	if (p->on_rq) { : 
2
strstr : for : 	if (p->on_rq) { : 
2
strstr : while : 	if (p->on_rq) { : 
2
str : 		struct rq *src_rq, *dst_rq;[29]
strstr : INIT : 		struct rq *src_rq, *dst_rq; : 
2
strstr : if : 		struct rq *src_rq, *dst_rq; : 
2
strstr : for : 		struct rq *src_rq, *dst_rq; : 
2
strstr : while : 		struct rq *src_rq, *dst_rq; : 
2
str : 		src_rq = task_rq(p);[22]
strstr : INIT : 		src_rq = task_rq(p); : 
2
strstr : if : 		src_rq = task_rq(p); : 
2
strstr : for : 		src_rq = task_rq(p); : 
2
strstr : while : 		src_rq = task_rq(p); : 
2
str : 		dst_rq = cpu_rq(cpu);[23]
strstr : INIT : 		dst_rq = cpu_rq(cpu); : 
2
strstr : if : 		dst_rq = cpu_rq(cpu); : 
2
strstr : for : 		dst_rq = cpu_rq(cpu); : 
2
strstr : while : 		dst_rq = cpu_rq(cpu); : 
2
str : 		deactivate_task(src_rq, p, 0);[32]
strstr : INIT : 		deactivate_task(src_rq, p, 0); : 
2
strstr : if : 		deactivate_task(src_rq, p, 0); : 
2
strstr : for : 		deactivate_task(src_rq, p, 0); : 
2
strstr : while : 		deactivate_task(src_rq, p, 0); : 
2
str : 		set_task_cpu(p, cpu);[23]
strstr : INIT : 		set_task_cpu(p, cpu); : 
2
strstr : if : 		set_task_cpu(p, cpu); : 
2
strstr : for : 		set_task_cpu(p, cpu); : 
2
strstr : while : 		set_task_cpu(p, cpu); : 
2
str : 		activate_task(dst_rq, p, 0);[30]
strstr : INIT : 		activate_task(dst_rq, p, 0); : 
2
strstr : if : 		activate_task(dst_rq, p, 0); : 
2
strstr : for : 		activate_task(dst_rq, p, 0); : 
2
strstr : while : 		activate_task(dst_rq, p, 0); : 
2
str : 		check_preempt_curr(dst_rq, p, 0);[35]
strstr : INIT : 		check_preempt_curr(dst_rq, p, 0); : 
2
strstr : if : 		check_preempt_curr(dst_rq, p, 0); : 
2
strstr : for : 		check_preempt_curr(dst_rq, p, 0); : 
2
strstr : while : 		check_preempt_curr(dst_rq, p, 0); : 
2
str : 	} else {[9]
strstr : INIT : 	} else { : 
2
strstr : if : 	} else { : 
2
strstr : for : 	} else { : 
2
strstr : while : 	} else { : 
2
str : 		/*[4]
strstr : INIT : 		/* : 
2
strstr : if : 		/* : 
2
strstr : for : 		/* : 
2
strstr : while : 		/* : 
2
str : 		 * Task isn't running anymore; make it appear like we migrated[64]
strstr : INIT : 		 * Task isn't running anymore; make it appear like we migrated : 
2
strstr : if : 		 * Task isn't running anymore; make it appear like we migrated : 
2
strstr : for : 		 * Task isn't running anymore; make it appear like we migrated : 
2
strstr : while : 		 * Task isn't running anymore; make it appear like we migrated : 
2
str : 		 * it before it went to sleep. This means on wakeup we make the[65]
strstr : INIT : 		 * it before it went to sleep. This means on wakeup we make the : 
2
strstr : if : 		 * it before it went to sleep. This means on wakeup we make the : 
2
strstr : for : 		 * it before it went to sleep. This means on wakeup we make the : 
2
strstr : while : 		 * it before it went to sleep. This means on wakeup we make the : 
2
str : 		 * previous cpu our targer instead of where it really is.[59]
strstr : INIT : 		 * previous cpu our targer instead of where it really is. : 
2
strstr : if : 		 * previous cpu our targer instead of where it really is. : 
2
strstr : for : 		 * previous cpu our targer instead of where it really is. : 
2
strstr : while : 		 * previous cpu our targer instead of where it really is. : 
2
str : 		 */[5]
strstr : INIT : 		 */ : 
2
strstr : if : 		 */ : 
2
strstr : for : 		 */ : 
2
strstr : while : 		 */ : 
2
str : 		p->wake_cpu = cpu;[20]
strstr : INIT : 		p->wake_cpu = cpu; : 
2
strstr : if : 		p->wake_cpu = cpu; : 
2
strstr : for : 		p->wake_cpu = cpu; : 
2
strstr : while : 		p->wake_cpu = cpu; : 
2
str : struct migration_swap_arg {[27]
strstr : INIT : struct migration_swap_arg { : 
2
strstr : if : struct migration_swap_arg { : 
2
strstr : for : struct migration_swap_arg { : 
2
strstr : while : struct migration_swap_arg { : 
2
str : 	struct task_struct *src_task, *dst_task;[41]
strstr : INIT : 	struct task_struct *src_task, *dst_task; : 
2
strstr : if : 	struct task_struct *src_task, *dst_task; : 
2
strstr : for : 	struct task_struct *src_task, *dst_task; : 
2
strstr : while : 	struct task_struct *src_task, *dst_task; : 
2
str : 	int src_cpu, dst_cpu;[22]
strstr : INIT : 	int src_cpu, dst_cpu; : 
2
strstr : if : 	int src_cpu, dst_cpu; : 
2
strstr : for : 	int src_cpu, dst_cpu; : 
2
strstr : while : 	int src_cpu, dst_cpu; : 
2
str : static int migrate_swap_stop(void *data)[40]
strstr : INIT : static int migrate_swap_stop(void *data) : 
2
strstr : if : static int migrate_swap_stop(void *data) : 
2
strstr : for : static int migrate_swap_stop(void *data) : 
2
strstr : while : static int migrate_swap_stop(void *data) : 
2
str : 	struct migration_swap_arg *arg = data;[39]
strstr : INIT : 	struct migration_swap_arg *arg = data; : 
2
strstr : if : 	struct migration_swap_arg *arg = data; : 
2
strstr : for : 	struct migration_swap_arg *arg = data; : 
2
strstr : while : 	struct migration_swap_arg *arg = data; : 
2
str : 	struct rq *src_rq, *dst_rq;[28]
strstr : INIT : 	struct rq *src_rq, *dst_rq; : 
2
strstr : if : 	struct rq *src_rq, *dst_rq; : 
2
strstr : for : 	struct rq *src_rq, *dst_rq; : 
2
strstr : while : 	struct rq *src_rq, *dst_rq; : 
2
str : 	int ret = -EAGAIN;[19]
strstr : INIT : 	int ret = -EAGAIN; : 
2
strstr : if : 	int ret = -EAGAIN; : 
2
strstr : for : 	int ret = -EAGAIN; : 
2
strstr : while : 	int ret = -EAGAIN; : 
2
str : 	src_rq = cpu_rq(arg->src_cpu);[31]
strstr : INIT : 	src_rq = cpu_rq(arg->src_cpu); : 
2
strstr : if : 	src_rq = cpu_rq(arg->src_cpu); : 
2
strstr : for : 	src_rq = cpu_rq(arg->src_cpu); : 
2
strstr : while : 	src_rq = cpu_rq(arg->src_cpu); : 
2
str : 	dst_rq = cpu_rq(arg->dst_cpu);[31]
strstr : INIT : 	dst_rq = cpu_rq(arg->dst_cpu); : 
2
strstr : if : 	dst_rq = cpu_rq(arg->dst_cpu); : 
2
strstr : for : 	dst_rq = cpu_rq(arg->dst_cpu); : 
2
strstr : while : 	dst_rq = cpu_rq(arg->dst_cpu); : 
2
str : 	double_raw_lock(&arg->src_task->pi_lock,[41]
strstr : INIT : 	double_raw_lock(&arg->src_task->pi_lock, : 
2
strstr : if : 	double_raw_lock(&arg->src_task->pi_lock, : 
2
strstr : for : 	double_raw_lock(&arg->src_task->pi_lock, : 
2
strstr : while : 	double_raw_lock(&arg->src_task->pi_lock, : 
2
str : 			&arg->dst_task->pi_lock);[28]
strstr : INIT : 			&arg->dst_task->pi_lock); : 
2
strstr : if : 			&arg->dst_task->pi_lock); : 
2
strstr : for : 			&arg->dst_task->pi_lock); : 
2
strstr : while : 			&arg->dst_task->pi_lock); : 
2
str : 	double_rq_lock(src_rq, dst_rq);[32]
strstr : INIT : 	double_rq_lock(src_rq, dst_rq); : 
2
strstr : if : 	double_rq_lock(src_rq, dst_rq); : 
2
strstr : for : 	double_rq_lock(src_rq, dst_rq); : 
2
strstr : while : 	double_rq_lock(src_rq, dst_rq); : 
2
str : 	if (task_cpu(arg->dst_task) != arg->dst_cpu)[45]
strstr : INIT : 	if (task_cpu(arg->dst_task) != arg->dst_cpu) : 
2
strstr : if : 	if (task_cpu(arg->dst_task) != arg->dst_cpu) : 
2
strstr : for : 	if (task_cpu(arg->dst_task) != arg->dst_cpu) : 
2
strstr : while : 	if (task_cpu(arg->dst_task) != arg->dst_cpu) : 
2
str : 		goto unlock;[14]
strstr : INIT : 		goto unlock; : 
2
strstr : if : 		goto unlock; : 
2
strstr : for : 		goto unlock; : 
2
strstr : while : 		goto unlock; : 
2
str : 	if (task_cpu(arg->src_task) != arg->src_cpu)[45]
strstr : INIT : 	if (task_cpu(arg->src_task) != arg->src_cpu) : 
2
strstr : if : 	if (task_cpu(arg->src_task) != arg->src_cpu) : 
2
strstr : for : 	if (task_cpu(arg->src_task) != arg->src_cpu) : 
2
strstr : while : 	if (task_cpu(arg->src_task) != arg->src_cpu) : 
2
str : 		goto unlock;[14]
strstr : INIT : 		goto unlock; : 
2
strstr : if : 		goto unlock; : 
2
strstr : for : 		goto unlock; : 
2
strstr : while : 		goto unlock; : 
2
str : 	if (!cpumask_test_cpu(arg->dst_cpu, tsk_cpus_allowed(arg->src_task)))[70]
strstr : INIT : 	if (!cpumask_test_cpu(arg->dst_cpu, tsk_cpus_allowed(arg->src_task))) : 
2
strstr : if : 	if (!cpumask_test_cpu(arg->dst_cpu, tsk_cpus_allowed(arg->src_task))) : 
2
strstr : for : 	if (!cpumask_test_cpu(arg->dst_cpu, tsk_cpus_allowed(arg->src_task))) : 
2
strstr : while : 	if (!cpumask_test_cpu(arg->dst_cpu, tsk_cpus_allowed(arg->src_task))) : 
2
str : 		goto unlock;[14]
strstr : INIT : 		goto unlock; : 
2
strstr : if : 		goto unlock; : 
2
strstr : for : 		goto unlock; : 
2
strstr : while : 		goto unlock; : 
2
str : 	if (!cpumask_test_cpu(arg->src_cpu, tsk_cpus_allowed(arg->dst_task)))[70]
strstr : INIT : 	if (!cpumask_test_cpu(arg->src_cpu, tsk_cpus_allowed(arg->dst_task))) : 
2
strstr : if : 	if (!cpumask_test_cpu(arg->src_cpu, tsk_cpus_allowed(arg->dst_task))) : 
2
strstr : for : 	if (!cpumask_test_cpu(arg->src_cpu, tsk_cpus_allowed(arg->dst_task))) : 
2
strstr : while : 	if (!cpumask_test_cpu(arg->src_cpu, tsk_cpus_allowed(arg->dst_task))) : 
2
str : 		goto unlock;[14]
strstr : INIT : 		goto unlock; : 
2
strstr : if : 		goto unlock; : 
2
strstr : for : 		goto unlock; : 
2
strstr : while : 		goto unlock; : 
2
str : 	__migrate_swap_task(arg->src_task, arg->dst_cpu);[50]
strstr : INIT : 	__migrate_swap_task(arg->src_task, arg->dst_cpu); : 
2
strstr : if : 	__migrate_swap_task(arg->src_task, arg->dst_cpu); : 
2
strstr : for : 	__migrate_swap_task(arg->src_task, arg->dst_cpu); : 
2
strstr : while : 	__migrate_swap_task(arg->src_task, arg->dst_cpu); : 
2
str : 	__migrate_swap_task(arg->dst_task, arg->src_cpu);[50]
strstr : INIT : 	__migrate_swap_task(arg->dst_task, arg->src_cpu); : 
2
strstr : if : 	__migrate_swap_task(arg->dst_task, arg->src_cpu); : 
2
strstr : for : 	__migrate_swap_task(arg->dst_task, arg->src_cpu); : 
2
strstr : while : 	__migrate_swap_task(arg->dst_task, arg->src_cpu); : 
2
str : 	ret = 0;[9]
strstr : INIT : 	ret = 0; : 
2
strstr : if : 	ret = 0; : 
2
strstr : for : 	ret = 0; : 
2
strstr : while : 	ret = 0; : 
2
str : unlock:[7]
strstr : INIT : unlock: : 
2
strstr : if : unlock: : 
2
strstr : for : unlock: : 
2
strstr : while : unlock: : 
2
str : 	double_rq_unlock(src_rq, dst_rq);[34]
strstr : INIT : 	double_rq_unlock(src_rq, dst_rq); : 
2
strstr : if : 	double_rq_unlock(src_rq, dst_rq); : 
2
strstr : for : 	double_rq_unlock(src_rq, dst_rq); : 
2
strstr : while : 	double_rq_unlock(src_rq, dst_rq); : 
2
str : 	raw_spin_unlock(&arg->dst_task->pi_lock);[42]
strstr : INIT : 	raw_spin_unlock(&arg->dst_task->pi_lock); : 
2
strstr : if : 	raw_spin_unlock(&arg->dst_task->pi_lock); : 
2
strstr : for : 	raw_spin_unlock(&arg->dst_task->pi_lock); : 
2
strstr : while : 	raw_spin_unlock(&arg->dst_task->pi_lock); : 
2
str : 	raw_spin_unlock(&arg->src_task->pi_lock);[42]
strstr : INIT : 	raw_spin_unlock(&arg->src_task->pi_lock); : 
2
strstr : if : 	raw_spin_unlock(&arg->src_task->pi_lock); : 
2
strstr : for : 	raw_spin_unlock(&arg->src_task->pi_lock); : 
2
strstr : while : 	raw_spin_unlock(&arg->src_task->pi_lock); : 
2
str : 	return ret;[12]
strstr : INIT : 	return ret; : 
2
strstr : if : 	return ret; : 
2
strstr : for : 	return ret; : 
2
strstr : while : 	return ret; : 
2
str :  * Cross migrate two tasks[26]
strstr : INIT :  * Cross migrate two tasks : 
2
strstr : if :  * Cross migrate two tasks : 
2
strstr : for :  * Cross migrate two tasks : 
2
strstr : while :  * Cross migrate two tasks : 
2
str :  */[3]
strstr : INIT :  */ : 
2
strstr : if :  */ : 
2
strstr : for :  */ : 
2
strstr : while :  */ : 
2
str : int migrate_swap(struct task_struct *cur, struct task_struct *p)[64]
strstr : INIT : int migrate_swap(struct task_struct *cur, struct task_struct *p) : 
2
strstr : if : int migrate_swap(struct task_struct *cur, struct task_struct *p) : 
2
strstr : for : int migrate_swap(struct task_struct *cur, struct task_struct *p) : 
2
strstr : while : int migrate_swap(struct task_struct *cur, struct task_struct *p) : 
2
str : 	struct migration_swap_arg arg;[31]
strstr : INIT : 	struct migration_swap_arg arg; : 
2
strstr : if : 	struct migration_swap_arg arg; : 
2
strstr : for : 	struct migration_swap_arg arg; : 
2
strstr : while : 	struct migration_swap_arg arg; : 
2
str : 	int ret = -EINVAL;[19]
strstr : INIT : 	int ret = -EINVAL; : 
2
strstr : if : 	int ret = -EINVAL; : 
2
strstr : for : 	int ret = -EINVAL; : 
2
strstr : while : 	int ret = -EINVAL; : 
2
str : 	arg = (struct migration_swap_arg){[35]
strstr : INIT : 	arg = (struct migration_swap_arg){ : 
2
strstr : if : 	arg = (struct migration_swap_arg){ : 
2
strstr : for : 	arg = (struct migration_swap_arg){ : 
2
strstr : while : 	arg = (struct migration_swap_arg){ : 
2
str : 		.src_task = cur,[18]
strstr : INIT : 		.src_task = cur, : 
2
strstr : if : 		.src_task = cur, : 
2
strstr : for : 		.src_task = cur, : 
2
strstr : while : 		.src_task = cur, : 
2
str : 		.src_cpu = task_cpu(cur),[27]
strstr : INIT : 		.src_cpu = task_cpu(cur), : 
2
strstr : if : 		.src_cpu = task_cpu(cur), : 
2
strstr : for : 		.src_cpu = task_cpu(cur), : 
2
strstr : while : 		.src_cpu = task_cpu(cur), : 
2
str : 		.dst_task = p,[16]
strstr : INIT : 		.dst_task = p, : 
2
strstr : if : 		.dst_task = p, : 
2
strstr : for : 		.dst_task = p, : 
2
strstr : while : 		.dst_task = p, : 
2
str : 		.dst_cpu = task_cpu(p),[25]
strstr : INIT : 		.dst_cpu = task_cpu(p), : 
2
strstr : if : 		.dst_cpu = task_cpu(p), : 
2
strstr : for : 		.dst_cpu = task_cpu(p), : 
2
strstr : while : 		.dst_cpu = task_cpu(p), : 
2
str : 	};[3]
strstr : INIT : 	}; : 
2
strstr : if : 	}; : 
2
strstr : for : 	}; : 
2
strstr : while : 	}; : 
2
str : 	if (arg.src_cpu == arg.dst_cpu)[32]
strstr : INIT : 	if (arg.src_cpu == arg.dst_cpu) : 
2
strstr : if : 	if (arg.src_cpu == arg.dst_cpu) : 
2
strstr : for : 	if (arg.src_cpu == arg.dst_cpu) : 
2
strstr : while : 	if (arg.src_cpu == arg.dst_cpu) : 
2
str : 		goto out;[11]
strstr : INIT : 		goto out; : 
2
strstr : if : 		goto out; : 
2
strstr : for : 		goto out; : 
2
strstr : while : 		goto out; : 
2
str : 	/*[3]
strstr : INIT : 	/* : 
2
strstr : if : 	/* : 
2
strstr : for : 	/* : 
2
strstr : while : 	/* : 
2
str : 	 * These three tests are all lockless; this is OK since all of them[68]
strstr : INIT : 	 * These three tests are all lockless; this is OK since all of them : 
2
strstr : if : 	 * These three tests are all lockless; this is OK since all of them : 
2
strstr : for : 	 * These three tests are all lockless; this is OK since all of them : 
2
strstr : while : 	 * These three tests are all lockless; this is OK since all of them : 
2
str : 	 * will be re-checked with proper locks held further down the line.[68]
strstr : INIT : 	 * will be re-checked with proper locks held further down the line. : 
2
strstr : if : 	 * will be re-checked with proper locks held further down the line. : 
2
strstr : for : 	 * will be re-checked with proper locks held further down the line. : 
2
strstr : while : 	 * will be re-checked with proper locks held further down the line. : 
2
str : 	 */[4]
strstr : INIT : 	 */ : 
2
strstr : if : 	 */ : 
2
strstr : for : 	 */ : 
2
strstr : while : 	 */ : 
2
str : 	if (!cpu_active(arg.src_cpu) || !cpu_active(arg.dst_cpu))[58]
strstr : INIT : 	if (!cpu_active(arg.src_cpu) || !cpu_active(arg.dst_cpu)) : 
2
strstr : if : 	if (!cpu_active(arg.src_cpu) || !cpu_active(arg.dst_cpu)) : 
2
strstr : for : 	if (!cpu_active(arg.src_cpu) || !cpu_active(arg.dst_cpu)) : 
2
strstr : while : 	if (!cpu_active(arg.src_cpu) || !cpu_active(arg.dst_cpu)) : 
2
str : 		goto out;[11]
strstr : INIT : 		goto out; : 
2
strstr : if : 		goto out; : 
2
strstr : for : 		goto out; : 
2
strstr : while : 		goto out; : 
2
str : 	if (!cpumask_test_cpu(arg.dst_cpu, tsk_cpus_allowed(arg.src_task)))[68]
strstr : INIT : 	if (!cpumask_test_cpu(arg.dst_cpu, tsk_cpus_allowed(arg.src_task))) : 
2
strstr : if : 	if (!cpumask_test_cpu(arg.dst_cpu, tsk_cpus_allowed(arg.src_task))) : 
2
strstr : for : 	if (!cpumask_test_cpu(arg.dst_cpu, tsk_cpus_allowed(arg.src_task))) : 
2
strstr : while : 	if (!cpumask_test_cpu(arg.dst_cpu, tsk_cpus_allowed(arg.src_task))) : 
2
str : 		goto out;[11]
strstr : INIT : 		goto out; : 
2
strstr : if : 		goto out; : 
2
strstr : for : 		goto out; : 
2
strstr : while : 		goto out; : 
2
str : 	if (!cpumask_test_cpu(arg.src_cpu, tsk_cpus_allowed(arg.dst_task)))[68]
strstr : INIT : 	if (!cpumask_test_cpu(arg.src_cpu, tsk_cpus_allowed(arg.dst_task))) : 
2
strstr : if : 	if (!cpumask_test_cpu(arg.src_cpu, tsk_cpus_allowed(arg.dst_task))) : 
2
strstr : for : 	if (!cpumask_test_cpu(arg.src_cpu, tsk_cpus_allowed(arg.dst_task))) : 
2
strstr : while : 	if (!cpumask_test_cpu(arg.src_cpu, tsk_cpus_allowed(arg.dst_task))) : 
2
str : 		goto out;[11]
strstr : INIT : 		goto out; : 
2
strstr : if : 		goto out; : 
2
strstr : for : 		goto out; : 
2
strstr : while : 		goto out; : 
2
str : 	trace_sched_swap_numa(cur, arg.src_cpu, p, arg.dst_cpu);[57]
strstr : INIT : 	trace_sched_swap_numa(cur, arg.src_cpu, p, arg.dst_cpu); : 
2
strstr : if : 	trace_sched_swap_numa(cur, arg.src_cpu, p, arg.dst_cpu); : 
2
strstr : for : 	trace_sched_swap_numa(cur, arg.src_cpu, p, arg.dst_cpu); : 
2
strstr : while : 	trace_sched_swap_numa(cur, arg.src_cpu, p, arg.dst_cpu); : 
2
str : 	ret = stop_two_cpus(arg.dst_cpu, arg.src_cpu, migrate_swap_stop, &arg);[72]
strstr : INIT : 	ret = stop_two_cpus(arg.dst_cpu, arg.src_cpu, migrate_swap_stop, &arg); : 
2
strstr : if : 	ret = stop_two_cpus(arg.dst_cpu, arg.src_cpu, migrate_swap_stop, &arg); : 
2
strstr : for : 	ret = stop_two_cpus(arg.dst_cpu, arg.src_cpu, migrate_swap_stop, &arg); : 
2
strstr : while : 	ret = stop_two_cpus(arg.dst_cpu, arg.src_cpu, migrate_swap_stop, &arg); : 
2
str : out:[4]
strstr : INIT : out: : 
2
strstr : if : out: : 
2
strstr : for : out: : 
2
strstr : while : out: : 
2
str : 	return ret;[12]
strstr : INIT : 	return ret; : 
2
strstr : if : 	return ret; : 
2
strstr : for : 	return ret; : 
2
strstr : while : 	return ret; : 
2
str : struct migration_arg {[22]
strstr : INIT : struct migration_arg { : 
2
strstr : if : struct migration_arg { : 
2
strstr : for : struct migration_arg { : 
2
strstr : while : struct migration_arg { : 
2
str : 	struct task_struct *task;[26]
strstr : INIT : 	struct task_struct *task; : 
2
strstr : if : 	struct task_struct *task; : 
2
strstr : for : 	struct task_struct *task; : 
2
strstr : while : 	struct task_struct *task; : 
2
str : 	int dest_cpu;[14]
strstr : INIT : 	int dest_cpu; : 
2
strstr : if : 	int dest_cpu; : 
2
strstr : for : 	int dest_cpu; : 
2
strstr : while : 	int dest_cpu; : 
2
str : static int migration_cpu_stop(void *data);[42]
strstr : INIT : static int migration_cpu_stop(void *data); : 
2
strstr : if : static int migration_cpu_stop(void *data); : 
2
strstr : for : static int migration_cpu_stop(void *data); : 
2
strstr : while : static int migration_cpu_stop(void *data); : 
2
str :  * wait_task_inactive - wait for a thread to unschedule.[56]
strstr : INIT :  * wait_task_inactive - wait for a thread to unschedule. : 
2
strstr : if :  * wait_task_inactive - wait for a thread to unschedule. : 
2
strstr : for :  * wait_task_inactive - wait for a thread to unschedule. : 
2
strstr : while :  * wait_task_inactive - wait for a thread to unschedule. : 
2
str :  * If @match_state is nonzero, it's the @p->state value just checked and[72]
strstr : INIT :  * If @match_state is nonzero, it's the @p->state value just checked and : 
2
strstr : if :  * If @match_state is nonzero, it's the @p->state value just checked and : 
2
strstr : for :  * If @match_state is nonzero, it's the @p->state value just checked and : 
2
strstr : while :  * If @match_state is nonzero, it's the @p->state value just checked and : 
2
str :  * not expected to change.  If it changes, i.e. @p might have woken up,[71]
strstr : INIT :  * not expected to change.  If it changes, i.e. @p might have woken up, : 
2
strstr : if :  * not expected to change.  If it changes, i.e. @p might have woken up, : 
2
strstr : for :  * not expected to change.  If it changes, i.e. @p might have woken up, : 
2
strstr : while :  * not expected to change.  If it changes, i.e. @p might have woken up, : 
2
str :  * then return zero.  When we succeed in waiting for @p to be off its CPU,[74]
strstr : INIT :  * then return zero.  When we succeed in waiting for @p to be off its CPU, : 
2
strstr : if :  * then return zero.  When we succeed in waiting for @p to be off its CPU, : 
2
strstr : for :  * then return zero.  When we succeed in waiting for @p to be off its CPU, : 
2
strstr : while :  * then return zero.  When we succeed in waiting for @p to be off its CPU, : 
2
str :  * we return a positive number (its total switch count).  If a second call[74]
strstr : INIT :  * we return a positive number (its total switch count).  If a second call : 
2
strstr : if :  * we return a positive number (its total switch count).  If a second call : 
2
strstr : for :  * we return a positive number (its total switch count).  If a second call : 
2
strstr : while :  * we return a positive number (its total switch count).  If a second call : 
2
str :  * a short while later returns the same number, the caller can be sure that[75]
strstr : INIT :  * a short while later returns the same number, the caller can be sure that : 
2
strstr : if :  * a short while later returns the same number, the caller can be sure that : 
2
strstr : for :  * a short while later returns the same number, the caller can be sure that : 
2
strstr : while :  * a short while later returns the same number, the caller can be sure that : 
2
str :  * @p has remained unscheduled the whole time.[46]
strstr : INIT :  * @p has remained unscheduled the whole time. : 
2
strstr : if :  * @p has remained unscheduled the whole time. : 
2
strstr : for :  * @p has remained unscheduled the whole time. : 
2
strstr : while :  * @p has remained unscheduled the whole time. : 
2
str :  * The caller must ensure that the task *will* unschedule sometime soon,[72]
strstr : INIT :  * The caller must ensure that the task *will* unschedule sometime soon, : 
2
strstr : if :  * The caller must ensure that the task *will* unschedule sometime soon, : 
2
strstr : for :  * The caller must ensure that the task *will* unschedule sometime soon, : 
2
strstr : while :  * The caller must ensure that the task *will* unschedule sometime soon, : 
2
str :  * else this function might spin for a *long* time. This function can't[71]
strstr : INIT :  * else this function might spin for a *long* time. This function can't : 
2
strstr : if :  * else this function might spin for a *long* time. This function can't : 
2
strstr : for :  * else this function might spin for a *long* time. This function can't : 
2
strstr : while :  * else this function might spin for a *long* time. This function can't : 
2
str :  * be called with interrupts off, or it may introduce deadlock with[67]
strstr : INIT :  * be called with interrupts off, or it may introduce deadlock with : 
2
strstr : if :  * be called with interrupts off, or it may introduce deadlock with : 
2
strstr : for :  * be called with interrupts off, or it may introduce deadlock with : 
2
strstr : while :  * be called with interrupts off, or it may introduce deadlock with : 
2
str :  * smp_call_function() if an IPI is sent by the same process we are[67]
strstr : INIT :  * smp_call_function() if an IPI is sent by the same process we are : 
2
strstr : if :  * smp_call_function() if an IPI is sent by the same process we are : 
2
strstr : for :  * smp_call_function() if an IPI is sent by the same process we are : 
2
strstr : while :  * smp_call_function() if an IPI is sent by the same process we are : 
2
str :  * waiting to become inactive.[30]
strstr : INIT :  * waiting to become inactive. : 
2
strstr : if :  * waiting to become inactive. : 
2
strstr : for :  * waiting to become inactive. : 
2
strstr : while :  * waiting to become inactive. : 
2
str :  */[3]
strstr : INIT :  */ : 
2
strstr : if :  */ : 
2
strstr : for :  */ : 
2
strstr : while :  */ : 
2
str : unsigned long wait_task_inactive(struct task_struct *p, long match_state)[73]
strstr : INIT : unsigned long wait_task_inactive(struct task_struct *p, long match_state) : 
2
strstr : if : unsigned long wait_task_inactive(struct task_struct *p, long match_state) : 
2
strstr : for : unsigned long wait_task_inactive(struct task_struct *p, long match_state) : 
2
strstr : while : unsigned long wait_task_inactive(struct task_struct *p, long match_state) : 
2
str : 	unsigned long flags;[21]
strstr : INIT : 	unsigned long flags; : 
2
strstr : if : 	unsigned long flags; : 
2
strstr : for : 	unsigned long flags; : 
2
strstr : while : 	unsigned long flags; : 
2
str : 	int running, on_rq;[20]
strstr : INIT : 	int running, on_rq; : 
2
strstr : if : 	int running, on_rq; : 
2
strstr : for : 	int running, on_rq; : 
2
strstr : while : 	int running, on_rq; : 
2
str : 	unsigned long ncsw;[20]
strstr : INIT : 	unsigned long ncsw; : 
2
strstr : if : 	unsigned long ncsw; : 
2
strstr : for : 	unsigned long ncsw; : 
2
strstr : while : 	unsigned long ncsw; : 
2
str : 	struct rq *rq;[15]
strstr : INIT : 	struct rq *rq; : 
2
strstr : if : 	struct rq *rq; : 
2
strstr : for : 	struct rq *rq; : 
2
strstr : while : 	struct rq *rq; : 
2
str : 	for (;;) {[11]
strstr : INIT : 	for (;;) { : 
2
strstr : if : 	for (;;) { : 
2
strstr : for : 	for (;;) { : 
2
strstr : while : 	for (;;) { : 
2
str : 		/*[4]
strstr : INIT : 		/* : 
2
strstr : if : 		/* : 
2
strstr : for : 		/* : 
2
strstr : while : 		/* : 
2
str : 		 * We do the initial early heuristics without holding[55]
strstr : INIT : 		 * We do the initial early heuristics without holding : 
2
strstr : if : 		 * We do the initial early heuristics without holding : 
2
strstr : for : 		 * We do the initial early heuristics without holding : 
2
strstr : while : 		 * We do the initial early heuristics without holding : 
2
str : 		 * any task-queue locks at all. We'll only try to get[55]
strstr : INIT : 		 * any task-queue locks at all. We'll only try to get : 
2
strstr : if : 		 * any task-queue locks at all. We'll only try to get : 
2
strstr : for : 		 * any task-queue locks at all. We'll only try to get : 
2
strstr : while : 		 * any task-queue locks at all. We'll only try to get : 
2
str : 		 * the runqueue lock when things look like they will[54]
strstr : INIT : 		 * the runqueue lock when things look like they will : 
2
strstr : if : 		 * the runqueue lock when things look like they will : 
2
strstr : for : 		 * the runqueue lock when things look like they will : 
2
strstr : while : 		 * the runqueue lock when things look like they will : 
2
str : 		 * work out![14]
strstr : INIT : 		 * work out! : 
2
strstr : if : 		 * work out! : 
2
strstr : for : 		 * work out! : 
2
strstr : while : 		 * work out! : 
2
str : 		 */[5]
strstr : INIT : 		 */ : 
2
strstr : if : 		 */ : 
2
strstr : for : 		 */ : 
2
strstr : while : 		 */ : 
2
str : 		rq = task_rq(p);[18]
strstr : INIT : 		rq = task_rq(p); : 
2
strstr : if : 		rq = task_rq(p); : 
2
strstr : for : 		rq = task_rq(p); : 
2
strstr : while : 		rq = task_rq(p); : 
2
str : 		/*[4]
strstr : INIT : 		/* : 
2
strstr : if : 		/* : 
2
strstr : for : 		/* : 
2
strstr : while : 		/* : 
2
str : 		 * If the task is actively running on another CPU[51]
strstr : INIT : 		 * If the task is actively running on another CPU : 
2
strstr : if : 		 * If the task is actively running on another CPU : 
2
strstr : for : 		 * If the task is actively running on another CPU : 
2
strstr : while : 		 * If the task is actively running on another CPU : 
2
str : 		 * still, just relax and busy-wait without holding[52]
strstr : INIT : 		 * still, just relax and busy-wait without holding : 
2
strstr : if : 		 * still, just relax and busy-wait without holding : 
2
strstr : for : 		 * still, just relax and busy-wait without holding : 
2
strstr : while : 		 * still, just relax and busy-wait without holding : 
2
str : 		 * any locks.[15]
strstr : INIT : 		 * any locks. : 
2
strstr : if : 		 * any locks. : 
2
strstr : for : 		 * any locks. : 
2
strstr : while : 		 * any locks. : 
2
str : 		 *[4]
strstr : INIT : 		 * : 
2
strstr : if : 		 * : 
2
strstr : for : 		 * : 
2
strstr : while : 		 * : 
2
str : 		 * NOTE! Since we don't hold any locks, it's not[50]
strstr : INIT : 		 * NOTE! Since we don't hold any locks, it's not : 
2
strstr : if : 		 * NOTE! Since we don't hold any locks, it's not : 
2
strstr : for : 		 * NOTE! Since we don't hold any locks, it's not : 
2
strstr : while : 		 * NOTE! Since we don't hold any locks, it's not : 
2
str : 		 * even sure that "rq" stays as the right runqueue![53]
strstr : INIT : 		 * even sure that "rq" stays as the right runqueue! : 
2
strstr : if : 		 * even sure that "rq" stays as the right runqueue! : 
2
strstr : for : 		 * even sure that "rq" stays as the right runqueue! : 
2
strstr : while : 		 * even sure that "rq" stays as the right runqueue! : 
2
str : 		 * But we don't care, since "task_running()" will[51]
strstr : INIT : 		 * But we don't care, since "task_running()" will : 
2
strstr : if : 		 * But we don't care, since "task_running()" will : 
2
strstr : for : 		 * But we don't care, since "task_running()" will : 
2
strstr : while : 		 * But we don't care, since "task_running()" will : 
2
str : 		 * return false if the runqueue has changed and p[51]
strstr : INIT : 		 * return false if the runqueue has changed and p : 
2
strstr : if : 		 * return false if the runqueue has changed and p : 
2
strstr : for : 		 * return false if the runqueue has changed and p : 
2
strstr : while : 		 * return false if the runqueue has changed and p : 
2
str : 		 * is actually now running somewhere else![44]
strstr : INIT : 		 * is actually now running somewhere else! : 
2
strstr : if : 		 * is actually now running somewhere else! : 
2
strstr : for : 		 * is actually now running somewhere else! : 
2
strstr : while : 		 * is actually now running somewhere else! : 
2
str : 		 */[5]
strstr : INIT : 		 */ : 
2
strstr : if : 		 */ : 
2
strstr : for : 		 */ : 
2
strstr : while : 		 */ : 
2
str : 		while (task_running(rq, p)) {[31]
strstr : INIT : 		while (task_running(rq, p)) { : 
2
strstr : if : 		while (task_running(rq, p)) { : 
2
strstr : for : 		while (task_running(rq, p)) { : 
2
strstr : while : 		while (task_running(rq, p)) { : 
2
str : 			if (match_state && unlikely(p->state != match_state))[56]
strstr : INIT : 			if (match_state && unlikely(p->state != match_state)) : 
2
strstr : if : 			if (match_state && unlikely(p->state != match_state)) : 
2
strstr : for : 			if (match_state && unlikely(p->state != match_state)) : 
2
strstr : while : 			if (match_state && unlikely(p->state != match_state)) : 
2
str : 				return 0;[13]
strstr : INIT : 				return 0; : 
2
strstr : if : 				return 0; : 
2
strstr : for : 				return 0; : 
2
strstr : while : 				return 0; : 
2
str : 			cpu_relax();[15]
strstr : INIT : 			cpu_relax(); : 
2
strstr : if : 			cpu_relax(); : 
2
strstr : for : 			cpu_relax(); : 
2
strstr : while : 			cpu_relax(); : 
2
str : 		}[3]
strstr : INIT : 		} : 
2
strstr : if : 		} : 
2
strstr : for : 		} : 
2
strstr : while : 		} : 
2
str : 		/*[4]
strstr : INIT : 		/* : 
2
strstr : if : 		/* : 
2
strstr : for : 		/* : 
2
strstr : while : 		/* : 
2
str : 		 * Ok, time to look more closely! We need the rq[50]
strstr : INIT : 		 * Ok, time to look more closely! We need the rq : 
2
strstr : if : 		 * Ok, time to look more closely! We need the rq : 
2
strstr : for : 		 * Ok, time to look more closely! We need the rq : 
2
strstr : while : 		 * Ok, time to look more closely! We need the rq : 
2
str : 		 * lock now, to be *sure*. If we're wrong, we'll[50]
strstr : INIT : 		 * lock now, to be *sure*. If we're wrong, we'll : 
2
strstr : if : 		 * lock now, to be *sure*. If we're wrong, we'll : 
2
strstr : for : 		 * lock now, to be *sure*. If we're wrong, we'll : 
2
strstr : while : 		 * lock now, to be *sure*. If we're wrong, we'll : 
2
str : 		 * just go back and repeat.[29]
strstr : INIT : 		 * just go back and repeat. : 
2
strstr : if : 		 * just go back and repeat. : 
2
strstr : for : 		 * just go back and repeat. : 
2
strstr : while : 		 * just go back and repeat. : 
2
str : 		 */[5]
strstr : INIT : 		 */ : 
2
strstr : if : 		 */ : 
2
strstr : for : 		 */ : 
2
strstr : while : 		 */ : 
2
str : 		rq = task_rq_lock(p, &flags);[31]
strstr : INIT : 		rq = task_rq_lock(p, &flags); : 
2
strstr : if : 		rq = task_rq_lock(p, &flags); : 
2
strstr : for : 		rq = task_rq_lock(p, &flags); : 
2
strstr : while : 		rq = task_rq_lock(p, &flags); : 
2
str : 		trace_sched_wait_task(p);[27]
strstr : INIT : 		trace_sched_wait_task(p); : 
2
strstr : if : 		trace_sched_wait_task(p); : 
2
strstr : for : 		trace_sched_wait_task(p); : 
2
strstr : while : 		trace_sched_wait_task(p); : 
2
str : 		running = task_running(rq, p);[32]
strstr : INIT : 		running = task_running(rq, p); : 
2
strstr : if : 		running = task_running(rq, p); : 
2
strstr : for : 		running = task_running(rq, p); : 
2
strstr : while : 		running = task_running(rq, p); : 
2
str : 		on_rq = p->on_rq;[19]
strstr : INIT : 		on_rq = p->on_rq; : 
2
strstr : if : 		on_rq = p->on_rq; : 
2
strstr : for : 		on_rq = p->on_rq; : 
2
strstr : while : 		on_rq = p->on_rq; : 
2
str : 		ncsw = 0;[11]
strstr : INIT : 		ncsw = 0; : 
2
strstr : if : 		ncsw = 0; : 
2
strstr : for : 		ncsw = 0; : 
2
strstr : while : 		ncsw = 0; : 
2
str : 		if (!match_state || p->state == match_state)[46]
strstr : INIT : 		if (!match_state || p->state == match_state) : 
2
strstr : if : 		if (!match_state || p->state == match_state) : 
2
strstr : for : 		if (!match_state || p->state == match_state) : 
2
strstr : while : 		if (!match_state || p->state == match_state) : 
2
str : 			ncsw = p->nvcsw | LONG_MIN; /* sets MSB */[45]
strstr : INIT : 			ncsw = p->nvcsw | LONG_MIN; /* sets MSB */ : 
2
strstr : if : 			ncsw = p->nvcsw | LONG_MIN; /* sets MSB */ : 
2
strstr : for : 			ncsw = p->nvcsw | LONG_MIN; /* sets MSB */ : 
2
strstr : while : 			ncsw = p->nvcsw | LONG_MIN; /* sets MSB */ : 
2
str : 		task_rq_unlock(rq, p, &flags);[32]
strstr : INIT : 		task_rq_unlock(rq, p, &flags); : 
2
strstr : if : 		task_rq_unlock(rq, p, &flags); : 
2
strstr : for : 		task_rq_unlock(rq, p, &flags); : 
2
strstr : while : 		task_rq_unlock(rq, p, &flags); : 
2
str : 		/*[4]
strstr : INIT : 		/* : 
2
strstr : if : 		/* : 
2
strstr : for : 		/* : 
2
strstr : while : 		/* : 
2
str : 		 * If it changed from the expected state, bail out now.[57]
strstr : INIT : 		 * If it changed from the expected state, bail out now. : 
2
strstr : if : 		 * If it changed from the expected state, bail out now. : 
2
strstr : for : 		 * If it changed from the expected state, bail out now. : 
2
strstr : while : 		 * If it changed from the expected state, bail out now. : 
2
str : 		 */[5]
strstr : INIT : 		 */ : 
2
strstr : if : 		 */ : 
2
strstr : for : 		 */ : 
2
strstr : while : 		 */ : 
2
str : 		if (unlikely(!ncsw))[22]
strstr : INIT : 		if (unlikely(!ncsw)) : 
2
strstr : if : 		if (unlikely(!ncsw)) : 
2
strstr : for : 		if (unlikely(!ncsw)) : 
2
strstr : while : 		if (unlikely(!ncsw)) : 
2
str : 			break;[9]
strstr : INIT : 			break; : 
2
strstr : if : 			break; : 
2
strstr : for : 			break; : 
2
strstr : while : 			break; : 
2
str : 		/*[4]
strstr : INIT : 		/* : 
2
strstr : if : 		/* : 
2
strstr : for : 		/* : 
2
strstr : while : 		/* : 
2
str : 		 * Was it really running after all now that we[48]
strstr : INIT : 		 * Was it really running after all now that we : 
2
strstr : if : 		 * Was it really running after all now that we : 
2
strstr : for : 		 * Was it really running after all now that we : 
2
strstr : while : 		 * Was it really running after all now that we : 
2
str : 		 * checked with the proper locks actually held?[49]
strstr : INIT : 		 * checked with the proper locks actually held? : 
2
strstr : if : 		 * checked with the proper locks actually held? : 
2
strstr : for : 		 * checked with the proper locks actually held? : 
2
strstr : while : 		 * checked with the proper locks actually held? : 
2
str : 		 *[4]
strstr : INIT : 		 * : 
2
strstr : if : 		 * : 
2
strstr : for : 		 * : 
2
strstr : while : 		 * : 
2
str : 		 * Oops. Go back and try again..[34]
strstr : INIT : 		 * Oops. Go back and try again.. : 
2
strstr : if : 		 * Oops. Go back and try again.. : 
2
strstr : for : 		 * Oops. Go back and try again.. : 
2
strstr : while : 		 * Oops. Go back and try again.. : 
2
str : 		 */[5]
strstr : INIT : 		 */ : 
2
strstr : if : 		 */ : 
2
strstr : for : 		 */ : 
2
strstr : while : 		 */ : 
2
str : 		if (unlikely(running)) {[26]
strstr : INIT : 		if (unlikely(running)) { : 
2
strstr : if : 		if (unlikely(running)) { : 
2
strstr : for : 		if (unlikely(running)) { : 
2
strstr : while : 		if (unlikely(running)) { : 
2
str : 			cpu_relax();[15]
strstr : INIT : 			cpu_relax(); : 
2
strstr : if : 			cpu_relax(); : 
2
strstr : for : 			cpu_relax(); : 
2
strstr : while : 			cpu_relax(); : 
2
str : 			continue;[12]
strstr : INIT : 			continue; : 
2
strstr : if : 			continue; : 
2
strstr : for : 			continue; : 
2
strstr : while : 			continue; : 
2
str : 		}[3]
strstr : INIT : 		} : 
2
strstr : if : 		} : 
2
strstr : for : 		} : 
2
strstr : while : 		} : 
2
str : 		/*[4]
strstr : INIT : 		/* : 
2
strstr : if : 		/* : 
2
strstr : for : 		/* : 
2
strstr : while : 		/* : 
2
str : 		 * It's not enough that it's not actively running,[52]
strstr : INIT : 		 * It's not enough that it's not actively running, : 
2
strstr : if : 		 * It's not enough that it's not actively running, : 
2
strstr : for : 		 * It's not enough that it's not actively running, : 
2
strstr : while : 		 * It's not enough that it's not actively running, : 
2
str : 		 * it must be off the runqueue _entirely_, and not[52]
strstr : INIT : 		 * it must be off the runqueue _entirely_, and not : 
2
strstr : if : 		 * it must be off the runqueue _entirely_, and not : 
2
strstr : for : 		 * it must be off the runqueue _entirely_, and not : 
2
strstr : while : 		 * it must be off the runqueue _entirely_, and not : 
2
str : 		 * preempted![15]
strstr : INIT : 		 * preempted! : 
2
strstr : if : 		 * preempted! : 
2
strstr : for : 		 * preempted! : 
2
strstr : while : 		 * preempted! : 
2
str : 		 *[4]
strstr : INIT : 		 * : 
2
strstr : if : 		 * : 
2
strstr : for : 		 * : 
2
strstr : while : 		 * : 
2
str : 		 * So if it was still runnable (but just not actively[55]
strstr : INIT : 		 * So if it was still runnable (but just not actively : 
2
strstr : if : 		 * So if it was still runnable (but just not actively : 
2
strstr : for : 		 * So if it was still runnable (but just not actively : 
2
strstr : while : 		 * So if it was still runnable (but just not actively : 
2
str : 		 * running right now), it's preempted, and we should[54]
strstr : INIT : 		 * running right now), it's preempted, and we should : 
2
strstr : if : 		 * running right now), it's preempted, and we should : 
2
strstr : for : 		 * running right now), it's preempted, and we should : 
2
strstr : while : 		 * running right now), it's preempted, and we should : 
2
str : 		 * yield - it could be a while.[33]
strstr : INIT : 		 * yield - it could be a while. : 
2
strstr : if : 		 * yield - it could be a while. : 
2
strstr : for : 		 * yield - it could be a while. : 
2
strstr : while : 		 * yield - it could be a while. : 
2
str : 		 */[5]
strstr : INIT : 		 */ : 
2
strstr : if : 		 */ : 
2
strstr : for : 		 */ : 
2
strstr : while : 		 */ : 
2
str : 		if (unlikely(on_rq)) {[24]
strstr : INIT : 		if (unlikely(on_rq)) { : 
2
strstr : if : 		if (unlikely(on_rq)) { : 
2
strstr : for : 		if (unlikely(on_rq)) { : 
2
strstr : while : 		if (unlikely(on_rq)) { : 
2
str : 			ktime_t to = ktime_set(0, NSEC_PER_SEC/HZ);[46]
strstr : INIT : 			ktime_t to = ktime_set(0, NSEC_PER_SEC/HZ); : 
2
strstr : if : 			ktime_t to = ktime_set(0, NSEC_PER_SEC/HZ); : 
2
strstr : for : 			ktime_t to = ktime_set(0, NSEC_PER_SEC/HZ); : 
2
strstr : while : 			ktime_t to = ktime_set(0, NSEC_PER_SEC/HZ); : 
2
str : 			set_current_state(TASK_UNINTERRUPTIBLE);[43]
strstr : INIT : 			set_current_state(TASK_UNINTERRUPTIBLE); : 
2
strstr : if : 			set_current_state(TASK_UNINTERRUPTIBLE); : 
2
strstr : for : 			set_current_state(TASK_UNINTERRUPTIBLE); : 
2
strstr : while : 			set_current_state(TASK_UNINTERRUPTIBLE); : 
2
str : 			schedule_hrtimeout(&to, HRTIMER_MODE_REL);[45]
strstr : INIT : 			schedule_hrtimeout(&to, HRTIMER_MODE_REL); : 
2
strstr : if : 			schedule_hrtimeout(&to, HRTIMER_MODE_REL); : 
2
strstr : for : 			schedule_hrtimeout(&to, HRTIMER_MODE_REL); : 
2
strstr : while : 			schedule_hrtimeout(&to, HRTIMER_MODE_REL); : 
2
str : 			continue;[12]
strstr : INIT : 			continue; : 
2
strstr : if : 			continue; : 
2
strstr : for : 			continue; : 
2
strstr : while : 			continue; : 
2
str : 		}[3]
strstr : INIT : 		} : 
2
strstr : if : 		} : 
2
strstr : for : 		} : 
2
strstr : while : 		} : 
2
str : 		/*[4]
strstr : INIT : 		/* : 
2
strstr : if : 		/* : 
2
strstr : for : 		/* : 
2
strstr : while : 		/* : 
2
str : 		 * Ahh, all good. It wasn't running, and it wasn't[52]
strstr : INIT : 		 * Ahh, all good. It wasn't running, and it wasn't : 
2
strstr : if : 		 * Ahh, all good. It wasn't running, and it wasn't : 
2
strstr : for : 		 * Ahh, all good. It wasn't running, and it wasn't : 
2
strstr : while : 		 * Ahh, all good. It wasn't running, and it wasn't : 
2
str : 		 * runnable, which means that it will never become[52]
strstr : INIT : 		 * runnable, which means that it will never become : 
2
strstr : if : 		 * runnable, which means that it will never become : 
2
strstr : for : 		 * runnable, which means that it will never become : 
2
strstr : while : 		 * runnable, which means that it will never become : 
2
str : 		 * running in the future either. We're all done![50]
strstr : INIT : 		 * running in the future either. We're all done! : 
2
strstr : if : 		 * running in the future either. We're all done! : 
2
strstr : for : 		 * running in the future either. We're all done! : 
2
strstr : while : 		 * running in the future either. We're all done! : 
2
str : 		 */[5]
strstr : INIT : 		 */ : 
2
strstr : if : 		 */ : 
2
strstr : for : 		 */ : 
2
strstr : while : 		 */ : 
2
str : 		break;[8]
strstr : INIT : 		break; : 
2
strstr : if : 		break; : 
2
strstr : for : 		break; : 
2
strstr : while : 		break; : 
2
str : 	return ncsw;[13]
strstr : INIT : 	return ncsw; : 
2
strstr : if : 	return ncsw; : 
2
strstr : for : 	return ncsw; : 
2
strstr : while : 	return ncsw; : 
2
str : /***[4]
strstr : INIT : /*** : 
2
strstr : if : /*** : 
2
strstr : for : /*** : 
2
strstr : while : /*** : 
2
str :  * kick_process - kick a running thread to enter/exit the kernel[64]
strstr : INIT :  * kick_process - kick a running thread to enter/exit the kernel : 
2
strstr : if :  * kick_process - kick a running thread to enter/exit the kernel : 
2
strstr : for :  * kick_process - kick a running thread to enter/exit the kernel : 
2
strstr : while :  * kick_process - kick a running thread to enter/exit the kernel : 
2
str :  * @p: the to-be-kicked thread[30]
strstr : INIT :  * @p: the to-be-kicked thread : 
2
strstr : if :  * @p: the to-be-kicked thread : 
2
strstr : for :  * @p: the to-be-kicked thread : 
2
strstr : while :  * @p: the to-be-kicked thread : 
2
str :  * Cause a process which is running on another CPU to enter[59]
strstr : INIT :  * Cause a process which is running on another CPU to enter : 
2
strstr : if :  * Cause a process which is running on another CPU to enter : 
2
strstr : for :  * Cause a process which is running on another CPU to enter : 
2
strstr : while :  * Cause a process which is running on another CPU to enter : 
2
str :  * kernel-mode, without any delay. (to get signals handled.)[60]
strstr : INIT :  * kernel-mode, without any delay. (to get signals handled.) : 
2
strstr : if :  * kernel-mode, without any delay. (to get signals handled.) : 
2
strstr : for :  * kernel-mode, without any delay. (to get signals handled.) : 
2
strstr : while :  * kernel-mode, without any delay. (to get signals handled.) : 
2
str :  * NOTE: this function doesn't have to take the runqueue lock,[62]
strstr : INIT :  * NOTE: this function doesn't have to take the runqueue lock, : 
2
strstr : if :  * NOTE: this function doesn't have to take the runqueue lock, : 
2
strstr : for :  * NOTE: this function doesn't have to take the runqueue lock, : 
2
strstr : while :  * NOTE: this function doesn't have to take the runqueue lock, : 
2
str :  * because all it wants to ensure is that the remote task enters[64]
strstr : INIT :  * because all it wants to ensure is that the remote task enters : 
2
strstr : if :  * because all it wants to ensure is that the remote task enters : 
2
strstr : for :  * because all it wants to ensure is that the remote task enters : 
2
strstr : while :  * because all it wants to ensure is that the remote task enters : 
2
str :  * the kernel. If the IPI races and the task has been migrated[62]
strstr : INIT :  * the kernel. If the IPI races and the task has been migrated : 
2
strstr : if :  * the kernel. If the IPI races and the task has been migrated : 
2
strstr : for :  * the kernel. If the IPI races and the task has been migrated : 
2
strstr : while :  * the kernel. If the IPI races and the task has been migrated : 
2
str :  * to another CPU then no harm is done and the purpose has been[63]
strstr : INIT :  * to another CPU then no harm is done and the purpose has been : 
2
strstr : if :  * to another CPU then no harm is done and the purpose has been : 
2
strstr : for :  * to another CPU then no harm is done and the purpose has been : 
2
strstr : while :  * to another CPU then no harm is done and the purpose has been : 
2
str :  * achieved as well.[20]
strstr : INIT :  * achieved as well. : 
2
strstr : if :  * achieved as well. : 
2
strstr : for :  * achieved as well. : 
2
strstr : while :  * achieved as well. : 
2
str :  */[3]
strstr : INIT :  */ : 
2
strstr : if :  */ : 
2
strstr : for :  */ : 
2
strstr : while :  */ : 
2
str : void kick_process(struct task_struct *p)[40]
strstr : INIT : void kick_process(struct task_struct *p) : 
2
strstr : if : void kick_process(struct task_struct *p) : 
2
strstr : for : void kick_process(struct task_struct *p) : 
2
strstr : while : void kick_process(struct task_struct *p) : 
2
str : 	int cpu;[9]
strstr : INIT : 	int cpu; : 
2
strstr : if : 	int cpu; : 
2
strstr : for : 	int cpu; : 
2
strstr : while : 	int cpu; : 
2
str : 	preempt_disable();[19]
strstr : INIT : 	preempt_disable(); : 
2
strstr : if : 	preempt_disable(); : 
2
strstr : for : 	preempt_disable(); : 
2
strstr : while : 	preempt_disable(); : 
2
str : 	cpu = task_cpu(p);[19]
strstr : INIT : 	cpu = task_cpu(p); : 
2
strstr : if : 	cpu = task_cpu(p); : 
2
strstr : for : 	cpu = task_cpu(p); : 
2
strstr : while : 	cpu = task_cpu(p); : 
2
str : 	if ((cpu != smp_processor_id()) && task_curr(p))[49]
strstr : INIT : 	if ((cpu != smp_processor_id()) && task_curr(p)) : 
2
strstr : if : 	if ((cpu != smp_processor_id()) && task_curr(p)) : 
2
strstr : for : 	if ((cpu != smp_processor_id()) && task_curr(p)) : 
2
strstr : while : 	if ((cpu != smp_processor_id()) && task_curr(p)) : 
2
str : 		smp_send_reschedule(cpu);[27]
strstr : INIT : 		smp_send_reschedule(cpu); : 
2
strstr : if : 		smp_send_reschedule(cpu); : 
2
strstr : for : 		smp_send_reschedule(cpu); : 
2
strstr : while : 		smp_send_reschedule(cpu); : 
2
str : 	preempt_enable();[18]
strstr : INIT : 	preempt_enable(); : 
2
strstr : if : 	preempt_enable(); : 
2
strstr : for : 	preempt_enable(); : 
2
strstr : while : 	preempt_enable(); : 
2
str : EXPORT_SYMBOL_GPL(kick_process);[32]
strstr : INIT : EXPORT_SYMBOL_GPL(kick_process); : 
2
strstr : if : EXPORT_SYMBOL_GPL(kick_process); : 
2
strstr : for : EXPORT_SYMBOL_GPL(kick_process); : 
2
strstr : while : EXPORT_SYMBOL_GPL(kick_process); : 
2
str : #endif /* CONFIG_SMP */[23]
strstr : INIT : #endif /* CONFIG_SMP */ : 
2
strstr : if : #endif /* CONFIG_SMP */ : 
2
strstr : for : #endif /* CONFIG_SMP */ : 
2
strstr : while : #endif /* CONFIG_SMP */ : 
2
str : #ifdef CONFIG_SMP[17]
strstr : INIT : #ifdef CONFIG_SMP : 
2
strstr : if : #ifdef CONFIG_SMP : 
2
strstr : for : #ifdef CONFIG_SMP : 
2
strstr : while : #ifdef CONFIG_SMP : 
2
str :  * ->cpus_allowed is protected by both rq->lock and p->pi_lock[62]
strstr : INIT :  * ->cpus_allowed is protected by both rq->lock and p->pi_lock : 
2
strstr : if :  * ->cpus_allowed is protected by both rq->lock and p->pi_lock : 
2
strstr : for :  * ->cpus_allowed is protected by both rq->lock and p->pi_lock : 
2
strstr : while :  * ->cpus_allowed is protected by both rq->lock and p->pi_lock : 
2
str :  */[3]
strstr : INIT :  */ : 
2
strstr : if :  */ : 
2
strstr : for :  */ : 
2
strstr : while :  */ : 
2
str : static int select_fallback_rq(int cpu, struct task_struct *p)[61]
strstr : INIT : static int select_fallback_rq(int cpu, struct task_struct *p) : 
2
strstr : if : static int select_fallback_rq(int cpu, struct task_struct *p) : 
2
strstr : for : static int select_fallback_rq(int cpu, struct task_struct *p) : 
2
strstr : while : static int select_fallback_rq(int cpu, struct task_struct *p) : 
2
str : 	int nid = cpu_to_node(cpu);[28]
strstr : INIT : 	int nid = cpu_to_node(cpu); : 
2
strstr : if : 	int nid = cpu_to_node(cpu); : 
2
strstr : for : 	int nid = cpu_to_node(cpu); : 
2
strstr : while : 	int nid = cpu_to_node(cpu); : 
2
str : 	const struct cpumask *nodemask = NULL;[39]
strstr : INIT : 	const struct cpumask *nodemask = NULL; : 
2
strstr : if : 	const struct cpumask *nodemask = NULL; : 
2
strstr : for : 	const struct cpumask *nodemask = NULL; : 
2
strstr : while : 	const struct cpumask *nodemask = NULL; : 
2
str : 	enum { cpuset, possible, fail } state = cpuset;[48]
strstr : INIT : 	enum { cpuset, possible, fail } state = cpuset; : 
2
strstr : if : 	enum { cpuset, possible, fail } state = cpuset; : 
2
strstr : for : 	enum { cpuset, possible, fail } state = cpuset; : 
2
strstr : while : 	enum { cpuset, possible, fail } state = cpuset; : 
2
str : 	int dest_cpu;[14]
strstr : INIT : 	int dest_cpu; : 
2
strstr : if : 	int dest_cpu; : 
2
strstr : for : 	int dest_cpu; : 
2
strstr : while : 	int dest_cpu; : 
2
str : 	/*[3]
strstr : INIT : 	/* : 
2
strstr : if : 	/* : 
2
strstr : for : 	/* : 
2
strstr : while : 	/* : 
2
str : 	 * If the node that the cpu is on has been offlined, cpu_to_node()[67]
strstr : INIT : 	 * If the node that the cpu is on has been offlined, cpu_to_node() : 
2
strstr : if : 	 * If the node that the cpu is on has been offlined, cpu_to_node() : 
2
strstr : for : 	 * If the node that the cpu is on has been offlined, cpu_to_node() : 
2
strstr : while : 	 * If the node that the cpu is on has been offlined, cpu_to_node() : 
2
str : 	 * will return -1. There is no cpu on the node, and we should[62]
strstr : INIT : 	 * will return -1. There is no cpu on the node, and we should : 
2
strstr : if : 	 * will return -1. There is no cpu on the node, and we should : 
2
strstr : for : 	 * will return -1. There is no cpu on the node, and we should : 
2
strstr : while : 	 * will return -1. There is no cpu on the node, and we should : 
2
str : 	 * select the cpu on the other node.[37]
strstr : INIT : 	 * select the cpu on the other node. : 
2
strstr : if : 	 * select the cpu on the other node. : 
2
strstr : for : 	 * select the cpu on the other node. : 
2
strstr : while : 	 * select the cpu on the other node. : 
2
str : 	 */[4]
strstr : INIT : 	 */ : 
2
strstr : if : 	 */ : 
2
strstr : for : 	 */ : 
2
strstr : while : 	 */ : 
2
str : 	if (nid != -1) {[17]
strstr : INIT : 	if (nid != -1) { : 
2
strstr : if : 	if (nid != -1) { : 
2
strstr : for : 	if (nid != -1) { : 
2
strstr : while : 	if (nid != -1) { : 
2
str : 		nodemask = cpumask_of_node(nid);[34]
strstr : INIT : 		nodemask = cpumask_of_node(nid); : 
2
strstr : if : 		nodemask = cpumask_of_node(nid); : 
2
strstr : for : 		nodemask = cpumask_of_node(nid); : 
2
strstr : while : 		nodemask = cpumask_of_node(nid); : 
2
str : 		/* Look for allowed, online CPU in same node. */[50]
strstr : INIT : 		/* Look for allowed, online CPU in same node. */ : 
2
strstr : if : 		/* Look for allowed, online CPU in same node. */ : 
2
strstr : for : 		/* Look for allowed, online CPU in same node. */ : 
2
strstr : while : 		/* Look for allowed, online CPU in same node. */ : 
2
str : 		for_each_cpu(dest_cpu, nodemask) {[36]
strstr : INIT : 		for_each_cpu(dest_cpu, nodemask) { : 
2
strstr : if : 		for_each_cpu(dest_cpu, nodemask) { : 
2
strstr : for : 		for_each_cpu(dest_cpu, nodemask) { : 
2
strstr : while : 		for_each_cpu(dest_cpu, nodemask) { : 
2
str : 			if (!cpu_online(dest_cpu))[29]
strstr : INIT : 			if (!cpu_online(dest_cpu)) : 
2
strstr : if : 			if (!cpu_online(dest_cpu)) : 
2
strstr : for : 			if (!cpu_online(dest_cpu)) : 
2
strstr : while : 			if (!cpu_online(dest_cpu)) : 
2
str : 				continue;[13]
strstr : INIT : 				continue; : 
2
strstr : if : 				continue; : 
2
strstr : for : 				continue; : 
2
strstr : while : 				continue; : 
2
str : 			if (!cpu_active(dest_cpu))[29]
strstr : INIT : 			if (!cpu_active(dest_cpu)) : 
2
strstr : if : 			if (!cpu_active(dest_cpu)) : 
2
strstr : for : 			if (!cpu_active(dest_cpu)) : 
2
strstr : while : 			if (!cpu_active(dest_cpu)) : 
2
str : 				continue;[13]
strstr : INIT : 				continue; : 
2
strstr : if : 				continue; : 
2
strstr : for : 				continue; : 
2
strstr : while : 				continue; : 
2
str : 			if (cpumask_test_cpu(dest_cpu, tsk_cpus_allowed(p)))[55]
strstr : INIT : 			if (cpumask_test_cpu(dest_cpu, tsk_cpus_allowed(p))) : 
2
strstr : if : 			if (cpumask_test_cpu(dest_cpu, tsk_cpus_allowed(p))) : 
2
strstr : for : 			if (cpumask_test_cpu(dest_cpu, tsk_cpus_allowed(p))) : 
2
strstr : while : 			if (cpumask_test_cpu(dest_cpu, tsk_cpus_allowed(p))) : 
2
str : 				return dest_cpu;[20]
strstr : INIT : 				return dest_cpu; : 
2
strstr : if : 				return dest_cpu; : 
2
strstr : for : 				return dest_cpu; : 
2
strstr : while : 				return dest_cpu; : 
2
str : 		}[3]
strstr : INIT : 		} : 
2
strstr : if : 		} : 
2
strstr : for : 		} : 
2
strstr : while : 		} : 
2
str : 	for (;;) {[11]
strstr : INIT : 	for (;;) { : 
2
strstr : if : 	for (;;) { : 
2
strstr : for : 	for (;;) { : 
2
strstr : while : 	for (;;) { : 
2
str : 		/* Any allowed, online CPU? */[32]
strstr : INIT : 		/* Any allowed, online CPU? */ : 
2
strstr : if : 		/* Any allowed, online CPU? */ : 
2
strstr : for : 		/* Any allowed, online CPU? */ : 
2
strstr : while : 		/* Any allowed, online CPU? */ : 
2
str : 		for_each_cpu(dest_cpu, tsk_cpus_allowed(p)) {[47]
strstr : INIT : 		for_each_cpu(dest_cpu, tsk_cpus_allowed(p)) { : 
2
strstr : if : 		for_each_cpu(dest_cpu, tsk_cpus_allowed(p)) { : 
2
strstr : for : 		for_each_cpu(dest_cpu, tsk_cpus_allowed(p)) { : 
2
strstr : while : 		for_each_cpu(dest_cpu, tsk_cpus_allowed(p)) { : 
2
str : 			if (!cpu_online(dest_cpu))[29]
strstr : INIT : 			if (!cpu_online(dest_cpu)) : 
2
strstr : if : 			if (!cpu_online(dest_cpu)) : 
2
strstr : for : 			if (!cpu_online(dest_cpu)) : 
2
strstr : while : 			if (!cpu_online(dest_cpu)) : 
2
str : 				continue;[13]
strstr : INIT : 				continue; : 
2
strstr : if : 				continue; : 
2
strstr : for : 				continue; : 
2
strstr : while : 				continue; : 
2
str : 			if (!cpu_active(dest_cpu))[29]
strstr : INIT : 			if (!cpu_active(dest_cpu)) : 
2
strstr : if : 			if (!cpu_active(dest_cpu)) : 
2
strstr : for : 			if (!cpu_active(dest_cpu)) : 
2
strstr : while : 			if (!cpu_active(dest_cpu)) : 
2
str : 				continue;[13]
strstr : INIT : 				continue; : 
2
strstr : if : 				continue; : 
2
strstr : for : 				continue; : 
2
strstr : while : 				continue; : 
2
str : 			goto out;[12]
strstr : INIT : 			goto out; : 
2
strstr : if : 			goto out; : 
2
strstr : for : 			goto out; : 
2
strstr : while : 			goto out; : 
2
str : 		}[3]
strstr : INIT : 		} : 
2
strstr : if : 		} : 
2
strstr : for : 		} : 
2
strstr : while : 		} : 
2
str : 		switch (state) {[18]
strstr : INIT : 		switch (state) { : 
2
strstr : if : 		switch (state) { : 
2
strstr : for : 		switch (state) { : 
2
strstr : while : 		switch (state) { : 
2
str : 		case cpuset:[14]
strstr : INIT : 		case cpuset: : 
2
strstr : if : 		case cpuset: : 
2
strstr : for : 		case cpuset: : 
2
strstr : while : 		case cpuset: : 
2
str : 			/* No more Mr. Nice Guy. */[30]
strstr : INIT : 			/* No more Mr. Nice Guy. */ : 
2
strstr : if : 			/* No more Mr. Nice Guy. */ : 
2
strstr : for : 			/* No more Mr. Nice Guy. */ : 
2
strstr : while : 			/* No more Mr. Nice Guy. */ : 
2
str : 			cpuset_cpus_allowed_fallback(p);[35]
strstr : INIT : 			cpuset_cpus_allowed_fallback(p); : 
2
strstr : if : 			cpuset_cpus_allowed_fallback(p); : 
2
strstr : for : 			cpuset_cpus_allowed_fallback(p); : 
2
strstr : while : 			cpuset_cpus_allowed_fallback(p); : 
2
str : 			state = possible;[20]
strstr : INIT : 			state = possible; : 
2
strstr : if : 			state = possible; : 
2
strstr : for : 			state = possible; : 
2
strstr : while : 			state = possible; : 
2
str : 			break;[9]
strstr : INIT : 			break; : 
2
strstr : if : 			break; : 
2
strstr : for : 			break; : 
2
strstr : while : 			break; : 
2
str : 		case possible:[16]
strstr : INIT : 		case possible: : 
2
strstr : if : 		case possible: : 
2
strstr : for : 		case possible: : 
2
strstr : while : 		case possible: : 
2
str : 			do_set_cpus_allowed(p, cpu_possible_mask);[45]
strstr : INIT : 			do_set_cpus_allowed(p, cpu_possible_mask); : 
2
strstr : if : 			do_set_cpus_allowed(p, cpu_possible_mask); : 
2
strstr : for : 			do_set_cpus_allowed(p, cpu_possible_mask); : 
2
strstr : while : 			do_set_cpus_allowed(p, cpu_possible_mask); : 
2
str : 			state = fail;[16]
strstr : INIT : 			state = fail; : 
2
strstr : if : 			state = fail; : 
2
strstr : for : 			state = fail; : 
2
strstr : while : 			state = fail; : 
2
str : 			break;[9]
strstr : INIT : 			break; : 
2
strstr : if : 			break; : 
2
strstr : for : 			break; : 
2
strstr : while : 			break; : 
2
str : 		case fail:[12]
strstr : INIT : 		case fail: : 
2
strstr : if : 		case fail: : 
2
strstr : for : 		case fail: : 
2
strstr : while : 		case fail: : 
2
str : 			BUG();[9]
strstr : INIT : 			BUG(); : 
2
strstr : if : 			BUG(); : 
2
strstr : for : 			BUG(); : 
2
strstr : while : 			BUG(); : 
2
str : 			break;[9]
strstr : INIT : 			break; : 
2
strstr : if : 			break; : 
2
strstr : for : 			break; : 
2
strstr : while : 			break; : 
2
str : 		}[3]
strstr : INIT : 		} : 
2
strstr : if : 		} : 
2
strstr : for : 		} : 
2
strstr : while : 		} : 
2
str : out:[4]
strstr : INIT : out: : 
2
strstr : if : out: : 
2
strstr : for : out: : 
2
strstr : while : out: : 
2
str : 	if (state != cpuset) {[23]
strstr : INIT : 	if (state != cpuset) { : 
2
strstr : if : 	if (state != cpuset) { : 
2
strstr : for : 	if (state != cpuset) { : 
2
strstr : while : 	if (state != cpuset) { : 
2
str : 		/*[4]
strstr : INIT : 		/* : 
2
strstr : if : 		/* : 
2
strstr : for : 		/* : 
2
strstr : while : 		/* : 
2
str : 		 * Don't tell them about moving exiting tasks or[50]
strstr : INIT : 		 * Don't tell them about moving exiting tasks or : 
2
strstr : if : 		 * Don't tell them about moving exiting tasks or : 
2
strstr : for : 		 * Don't tell them about moving exiting tasks or : 
2
strstr : while : 		 * Don't tell them about moving exiting tasks or : 
2
str : 		 * kernel threads (both mm NULL), since they never[52]
strstr : INIT : 		 * kernel threads (both mm NULL), since they never : 
2
strstr : if : 		 * kernel threads (both mm NULL), since they never : 
2
strstr : for : 		 * kernel threads (both mm NULL), since they never : 
2
strstr : while : 		 * kernel threads (both mm NULL), since they never : 
2
str : 		 * leave kernel.[18]
strstr : INIT : 		 * leave kernel. : 
2
strstr : if : 		 * leave kernel. : 
2
strstr : for : 		 * leave kernel. : 
2
strstr : while : 		 * leave kernel. : 
2
str : 		 */[5]
strstr : INIT : 		 */ : 
2
strstr : if : 		 */ : 
2
strstr : for : 		 */ : 
2
strstr : while : 		 */ : 
2
str : 		if (p->mm && printk_ratelimit()) {[36]
strstr : INIT : 		if (p->mm && printk_ratelimit()) { : 
2
strstr : if : 		if (p->mm && printk_ratelimit()) { : 
2
strstr : for : 		if (p->mm && printk_ratelimit()) { : 
2
strstr : while : 		if (p->mm && printk_ratelimit()) { : 
2
str : 			printk_sched("process %d (%s) no longer affine to cpu%d\n",[62]
strstr : INIT : 			printk_sched("process %d (%s) no longer affine to cpu%d\n", : 
2
strstr : if : 			printk_sched("process %d (%s) no longer affine to cpu%d\n", : 
2
strstr : for : 			printk_sched("process %d (%s) no longer affine to cpu%d\n", : 
2
strstr : while : 			printk_sched("process %d (%s) no longer affine to cpu%d\n", : 
2
str : 					task_pid_nr(p), p->comm, cpu);[35]
strstr : INIT : 					task_pid_nr(p), p->comm, cpu); : 
2
strstr : if : 					task_pid_nr(p), p->comm, cpu); : 
2
strstr : for : 					task_pid_nr(p), p->comm, cpu); : 
2
strstr : while : 					task_pid_nr(p), p->comm, cpu); : 
2
str : 		}[3]
strstr : INIT : 		} : 
2
strstr : if : 		} : 
2
strstr : for : 		} : 
2
strstr : while : 		} : 
2
str : 	return dest_cpu;[17]
strstr : INIT : 	return dest_cpu; : 
2
strstr : if : 	return dest_cpu; : 
2
strstr : for : 	return dest_cpu; : 
2
strstr : while : 	return dest_cpu; : 
2
str :  * The caller (fork, wakeup) owns p->pi_lock, ->cpus_allowed is stable.[71]
strstr : INIT :  * The caller (fork, wakeup) owns p->pi_lock, ->cpus_allowed is stable. : 
2
strstr : if :  * The caller (fork, wakeup) owns p->pi_lock, ->cpus_allowed is stable. : 
2
strstr : for :  * The caller (fork, wakeup) owns p->pi_lock, ->cpus_allowed is stable. : 
2
strstr : while :  * The caller (fork, wakeup) owns p->pi_lock, ->cpus_allowed is stable. : 
2
str :  */[3]
strstr : INIT :  */ : 
2
strstr : if :  */ : 
2
strstr : for :  */ : 
2
strstr : while :  */ : 
2
str : static inline[13]
strstr : INIT : static inline : 
2
strstr : if : static inline : 
2
strstr : for : static inline : 
2
strstr : while : static inline : 
2
str : int select_task_rq(struct task_struct *p, int cpu, int sd_flags, int wake_flags)[80]
strstr : INIT : int select_task_rq(struct task_struct *p, int cpu, int sd_flags, int wake_flags) : 
2
strstr : if : int select_task_rq(struct task_struct *p, int cpu, int sd_flags, int wake_flags) : 
2
strstr : for : int select_task_rq(struct task_struct *p, int cpu, int sd_flags, int wake_flags) : 
2
strstr : while : int select_task_rq(struct task_struct *p, int cpu, int sd_flags, int wake_flags) : 
2
str : 	cpu = p->sched_class->select_task_rq(p, cpu, sd_flags, wake_flags);[68]
strstr : INIT : 	cpu = p->sched_class->select_task_rq(p, cpu, sd_flags, wake_flags); : 
2
strstr : if : 	cpu = p->sched_class->select_task_rq(p, cpu, sd_flags, wake_flags); : 
2
strstr : for : 	cpu = p->sched_class->select_task_rq(p, cpu, sd_flags, wake_flags); : 
2
strstr : while : 	cpu = p->sched_class->select_task_rq(p, cpu, sd_flags, wake_flags); : 
2
str : 	/*[3]
strstr : INIT : 	/* : 
2
strstr : if : 	/* : 
2
strstr : for : 	/* : 
2
strstr : while : 	/* : 
2
str : 	 * In order not to call set_task_cpu() on a blocking task we need[66]
strstr : INIT : 	 * In order not to call set_task_cpu() on a blocking task we need : 
2
strstr : if : 	 * In order not to call set_task_cpu() on a blocking task we need : 
2
strstr : for : 	 * In order not to call set_task_cpu() on a blocking task we need : 
2
strstr : while : 	 * In order not to call set_task_cpu() on a blocking task we need : 
2
str : 	 * to rely on ttwu() to place the task on a valid ->cpus_allowed[65]
strstr : INIT : 	 * to rely on ttwu() to place the task on a valid ->cpus_allowed : 
2
strstr : if : 	 * to rely on ttwu() to place the task on a valid ->cpus_allowed : 
2
strstr : for : 	 * to rely on ttwu() to place the task on a valid ->cpus_allowed : 
2
strstr : while : 	 * to rely on ttwu() to place the task on a valid ->cpus_allowed : 
2
str : 	 * cpu.[8]
strstr : INIT : 	 * cpu. : 
2
strstr : if : 	 * cpu. : 
2
strstr : for : 	 * cpu. : 
2
strstr : while : 	 * cpu. : 
2
str : 	 *[3]
strstr : INIT : 	 * : 
2
strstr : if : 	 * : 
2
strstr : for : 	 * : 
2
strstr : while : 	 * : 
2
str : 	 * Since this is common to all placement strategies, this lives here.[70]
strstr : INIT : 	 * Since this is common to all placement strategies, this lives here. : 
2
strstr : if : 	 * Since this is common to all placement strategies, this lives here. : 
2
strstr : for : 	 * Since this is common to all placement strategies, this lives here. : 
2
strstr : while : 	 * Since this is common to all placement strategies, this lives here. : 
2
str : 	 *[3]
strstr : INIT : 	 * : 
2
strstr : if : 	 * : 
2
strstr : for : 	 * : 
2
strstr : while : 	 * : 
2
str : 	 * [ this allows ->select_task() to simply return task_cpu(p) and[66]
strstr : INIT : 	 * [ this allows ->select_task() to simply return task_cpu(p) and : 
2
strstr : if : 	 * [ this allows ->select_task() to simply return task_cpu(p) and : 
2
strstr : for : 	 * [ this allows ->select_task() to simply return task_cpu(p) and : 
2
strstr : while : 	 * [ this allows ->select_task() to simply return task_cpu(p) and : 
2
str : 	 *   not worry about this generic constraint ][47]
strstr : INIT : 	 *   not worry about this generic constraint ] : 
2
strstr : if : 	 *   not worry about this generic constraint ] : 
2
strstr : for : 	 *   not worry about this generic constraint ] : 
2
strstr : while : 	 *   not worry about this generic constraint ] : 
2
str : 	 */[4]
strstr : INIT : 	 */ : 
2
strstr : if : 	 */ : 
2
strstr : for : 	 */ : 
2
strstr : while : 	 */ : 
2
str : 	if (unlikely(!cpumask_test_cpu(cpu, tsk_cpus_allowed(p)) ||[60]
strstr : INIT : 	if (unlikely(!cpumask_test_cpu(cpu, tsk_cpus_allowed(p)) || : 
2
strstr : if : 	if (unlikely(!cpumask_test_cpu(cpu, tsk_cpus_allowed(p)) || : 
2
strstr : for : 	if (unlikely(!cpumask_test_cpu(cpu, tsk_cpus_allowed(p)) || : 
2
strstr : while : 	if (unlikely(!cpumask_test_cpu(cpu, tsk_cpus_allowed(p)) || : 
2
str : 		     !cpu_online(cpu)))[25]
strstr : INIT : 		     !cpu_online(cpu))) : 
2
strstr : if : 		     !cpu_online(cpu))) : 
2
strstr : for : 		     !cpu_online(cpu))) : 
2
strstr : while : 		     !cpu_online(cpu))) : 
2
str : 		cpu = select_fallback_rq(task_cpu(p), p);[43]
strstr : INIT : 		cpu = select_fallback_rq(task_cpu(p), p); : 
2
strstr : if : 		cpu = select_fallback_rq(task_cpu(p), p); : 
2
strstr : for : 		cpu = select_fallback_rq(task_cpu(p), p); : 
2
strstr : while : 		cpu = select_fallback_rq(task_cpu(p), p); : 
2
str : 	return cpu;[12]
strstr : INIT : 	return cpu; : 
2
strstr : if : 	return cpu; : 
2
strstr : for : 	return cpu; : 
2
strstr : while : 	return cpu; : 
2
str : static void update_avg(u64 *avg, u64 sample)[44]
strstr : INIT : static void update_avg(u64 *avg, u64 sample) : 
2
strstr : if : static void update_avg(u64 *avg, u64 sample) : 
2
strstr : for : static void update_avg(u64 *avg, u64 sample) : 
2
strstr : while : static void update_avg(u64 *avg, u64 sample) : 
2
str : 	s64 diff = sample - *avg;[26]
strstr : INIT : 	s64 diff = sample - *avg; : 
2
strstr : if : 	s64 diff = sample - *avg; : 
2
strstr : for : 	s64 diff = sample - *avg; : 
2
strstr : while : 	s64 diff = sample - *avg; : 
2
str : 	*avg += diff >> 3;[19]
strstr : INIT : 	*avg += diff >> 3; : 
2
strstr : if : 	*avg += diff >> 3; : 
2
strstr : for : 	*avg += diff >> 3; : 
2
strstr : while : 	*avg += diff >> 3; : 
2
str : #endif[6]
strstr : INIT : #endif : 
2
strstr : if : #endif : 
2
strstr : for : #endif : 
2
strstr : while : #endif : 
2
str : static void[11]
strstr : INIT : static void : 
2
strstr : if : static void : 
2
strstr : for : static void : 
2
strstr : while : static void : 
2
str : ttwu_stat(struct task_struct *p, int cpu, int wake_flags)[57]
strstr : INIT : ttwu_stat(struct task_struct *p, int cpu, int wake_flags) : 
2
strstr : if : ttwu_stat(struct task_struct *p, int cpu, int wake_flags) : 
2
strstr : for : ttwu_stat(struct task_struct *p, int cpu, int wake_flags) : 
2
strstr : while : ttwu_stat(struct task_struct *p, int cpu, int wake_flags) : 
2
str : #ifdef CONFIG_SCHEDSTATS[24]
strstr : INIT : #ifdef CONFIG_SCHEDSTATS : 
2
strstr : if : #ifdef CONFIG_SCHEDSTATS : 
2
strstr : for : #ifdef CONFIG_SCHEDSTATS : 
2
strstr : while : #ifdef CONFIG_SCHEDSTATS : 
2
str : 	struct rq *rq = this_rq();[27]
strstr : INIT : 	struct rq *rq = this_rq(); : 
2
strstr : if : 	struct rq *rq = this_rq(); : 
2
strstr : for : 	struct rq *rq = this_rq(); : 
2
strstr : while : 	struct rq *rq = this_rq(); : 
2
str : #ifdef CONFIG_SMP[17]
strstr : INIT : #ifdef CONFIG_SMP : 
2
strstr : if : #ifdef CONFIG_SMP : 
2
strstr : for : #ifdef CONFIG_SMP : 
2
strstr : while : #ifdef CONFIG_SMP : 
2
str : 	int this_cpu = smp_processor_id();[35]
strstr : INIT : 	int this_cpu = smp_processor_id(); : 
2
strstr : if : 	int this_cpu = smp_processor_id(); : 
2
strstr : for : 	int this_cpu = smp_processor_id(); : 
2
strstr : while : 	int this_cpu = smp_processor_id(); : 
2
str : 	if (cpu == this_cpu) {[23]
strstr : INIT : 	if (cpu == this_cpu) { : 
2
strstr : if : 	if (cpu == this_cpu) { : 
2
strstr : for : 	if (cpu == this_cpu) { : 
2
strstr : while : 	if (cpu == this_cpu) { : 
2
str : 		schedstat_inc(rq, ttwu_local);[32]
strstr : INIT : 		schedstat_inc(rq, ttwu_local); : 
2
strstr : if : 		schedstat_inc(rq, ttwu_local); : 
2
strstr : for : 		schedstat_inc(rq, ttwu_local); : 
2
strstr : while : 		schedstat_inc(rq, ttwu_local); : 
2
str : 		schedstat_inc(p, se.statistics.nr_wakeups_local);[51]
strstr : INIT : 		schedstat_inc(p, se.statistics.nr_wakeups_local); : 
2
strstr : if : 		schedstat_inc(p, se.statistics.nr_wakeups_local); : 
2
strstr : for : 		schedstat_inc(p, se.statistics.nr_wakeups_local); : 
2
strstr : while : 		schedstat_inc(p, se.statistics.nr_wakeups_local); : 
2
str : 	} else {[9]
strstr : INIT : 	} else { : 
2
strstr : if : 	} else { : 
2
strstr : for : 	} else { : 
2
strstr : while : 	} else { : 
2
str : 		struct sched_domain *sd;[26]
strstr : INIT : 		struct sched_domain *sd; : 
2
strstr : if : 		struct sched_domain *sd; : 
2
strstr : for : 		struct sched_domain *sd; : 
2
strstr : while : 		struct sched_domain *sd; : 
2
str : 		schedstat_inc(p, se.statistics.nr_wakeups_remote);[52]
strstr : INIT : 		schedstat_inc(p, se.statistics.nr_wakeups_remote); : 
2
strstr : if : 		schedstat_inc(p, se.statistics.nr_wakeups_remote); : 
2
strstr : for : 		schedstat_inc(p, se.statistics.nr_wakeups_remote); : 
2
strstr : while : 		schedstat_inc(p, se.statistics.nr_wakeups_remote); : 
2
str : 		rcu_read_lock();[18]
strstr : INIT : 		rcu_read_lock(); : 
2
strstr : if : 		rcu_read_lock(); : 
2
strstr : for : 		rcu_read_lock(); : 
2
strstr : while : 		rcu_read_lock(); : 
2
str : 		for_each_domain(this_cpu, sd) {[33]
strstr : INIT : 		for_each_domain(this_cpu, sd) { : 
2
strstr : if : 		for_each_domain(this_cpu, sd) { : 
2
strstr : for : 		for_each_domain(this_cpu, sd) { : 
2
strstr : while : 		for_each_domain(this_cpu, sd) { : 
2
str : 			if (cpumask_test_cpu(cpu, sched_domain_span(sd))) {[54]
strstr : INIT : 			if (cpumask_test_cpu(cpu, sched_domain_span(sd))) { : 
2
strstr : if : 			if (cpumask_test_cpu(cpu, sched_domain_span(sd))) { : 
2
strstr : for : 			if (cpumask_test_cpu(cpu, sched_domain_span(sd))) { : 
2
strstr : while : 			if (cpumask_test_cpu(cpu, sched_domain_span(sd))) { : 
2
str : 				schedstat_inc(sd, ttwu_wake_remote);[40]
strstr : INIT : 				schedstat_inc(sd, ttwu_wake_remote); : 
2
strstr : if : 				schedstat_inc(sd, ttwu_wake_remote); : 
2
strstr : for : 				schedstat_inc(sd, ttwu_wake_remote); : 
2
strstr : while : 				schedstat_inc(sd, ttwu_wake_remote); : 
2
str : 				break;[10]
strstr : INIT : 				break; : 
2
strstr : if : 				break; : 
2
strstr : for : 				break; : 
2
strstr : while : 				break; : 
2
str : 			}[4]
strstr : INIT : 			} : 
2
strstr : if : 			} : 
2
strstr : for : 			} : 
2
strstr : while : 			} : 
2
str : 		}[3]
strstr : INIT : 		} : 
2
strstr : if : 		} : 
2
strstr : for : 		} : 
2
strstr : while : 		} : 
2
str : 		rcu_read_unlock();[20]
strstr : INIT : 		rcu_read_unlock(); : 
2
strstr : if : 		rcu_read_unlock(); : 
2
strstr : for : 		rcu_read_unlock(); : 
2
strstr : while : 		rcu_read_unlock(); : 
2
str : 	if (wake_flags & WF_MIGRATED)[30]
strstr : INIT : 	if (wake_flags & WF_MIGRATED) : 
2
strstr : if : 	if (wake_flags & WF_MIGRATED) : 
2
strstr : for : 	if (wake_flags & WF_MIGRATED) : 
2
strstr : while : 	if (wake_flags & WF_MIGRATED) : 
2
str : 		schedstat_inc(p, se.statistics.nr_wakeups_migrate);[53]
strstr : INIT : 		schedstat_inc(p, se.statistics.nr_wakeups_migrate); : 
2
strstr : if : 		schedstat_inc(p, se.statistics.nr_wakeups_migrate); : 
2
strstr : for : 		schedstat_inc(p, se.statistics.nr_wakeups_migrate); : 
2
strstr : while : 		schedstat_inc(p, se.statistics.nr_wakeups_migrate); : 
2
str : #endif /* CONFIG_SMP */[23]
strstr : INIT : #endif /* CONFIG_SMP */ : 
2
strstr : if : #endif /* CONFIG_SMP */ : 
2
strstr : for : #endif /* CONFIG_SMP */ : 
2
strstr : while : #endif /* CONFIG_SMP */ : 
2
str : 	schedstat_inc(rq, ttwu_count);[31]
strstr : INIT : 	schedstat_inc(rq, ttwu_count); : 
2
strstr : if : 	schedstat_inc(rq, ttwu_count); : 
2
strstr : for : 	schedstat_inc(rq, ttwu_count); : 
2
strstr : while : 	schedstat_inc(rq, ttwu_count); : 
2
str : 	schedstat_inc(p, se.statistics.nr_wakeups);[44]
strstr : INIT : 	schedstat_inc(p, se.statistics.nr_wakeups); : 
2
strstr : if : 	schedstat_inc(p, se.statistics.nr_wakeups); : 
2
strstr : for : 	schedstat_inc(p, se.statistics.nr_wakeups); : 
2
strstr : while : 	schedstat_inc(p, se.statistics.nr_wakeups); : 
2
str : 	if (wake_flags & WF_SYNC)[26]
strstr : INIT : 	if (wake_flags & WF_SYNC) : 
2
strstr : if : 	if (wake_flags & WF_SYNC) : 
2
strstr : for : 	if (wake_flags & WF_SYNC) : 
2
strstr : while : 	if (wake_flags & WF_SYNC) : 
2
str : 		schedstat_inc(p, se.statistics.nr_wakeups_sync);[50]
strstr : INIT : 		schedstat_inc(p, se.statistics.nr_wakeups_sync); : 
2
strstr : if : 		schedstat_inc(p, se.statistics.nr_wakeups_sync); : 
2
strstr : for : 		schedstat_inc(p, se.statistics.nr_wakeups_sync); : 
2
strstr : while : 		schedstat_inc(p, se.statistics.nr_wakeups_sync); : 
2
str : #endif /* CONFIG_SCHEDSTATS */[30]
strstr : INIT : #endif /* CONFIG_SCHEDSTATS */ : 
2
strstr : if : #endif /* CONFIG_SCHEDSTATS */ : 
2
strstr : for : #endif /* CONFIG_SCHEDSTATS */ : 
2
strstr : while : #endif /* CONFIG_SCHEDSTATS */ : 
2
str : static void ttwu_activate(struct rq *rq, struct task_struct *p, int en_flags)[77]
strstr : INIT : static void ttwu_activate(struct rq *rq, struct task_struct *p, int en_flags) : 
2
strstr : if : static void ttwu_activate(struct rq *rq, struct task_struct *p, int en_flags) : 
2
strstr : for : static void ttwu_activate(struct rq *rq, struct task_struct *p, int en_flags) : 
2
strstr : while : static void ttwu_activate(struct rq *rq, struct task_struct *p, int en_flags) : 
2
str : 	activate_task(rq, p, en_flags);[32]
strstr : INIT : 	activate_task(rq, p, en_flags); : 
2
strstr : if : 	activate_task(rq, p, en_flags); : 
2
strstr : for : 	activate_task(rq, p, en_flags); : 
2
strstr : while : 	activate_task(rq, p, en_flags); : 
2
str : 	p->on_rq = 1;[14]
strstr : INIT : 	p->on_rq = 1; : 
2
strstr : if : 	p->on_rq = 1; : 
2
strstr : for : 	p->on_rq = 1; : 
2
strstr : while : 	p->on_rq = 1; : 
2
str : 	/* if a worker is waking up, notify workqueue */[49]
strstr : INIT : 	/* if a worker is waking up, notify workqueue */ : 
2
strstr : if : 	/* if a worker is waking up, notify workqueue */ : 
2
strstr : for : 	/* if a worker is waking up, notify workqueue */ : 
2
strstr : while : 	/* if a worker is waking up, notify workqueue */ : 
2
str : 	if (p->flags & PF_WQ_WORKER)[29]
strstr : INIT : 	if (p->flags & PF_WQ_WORKER) : 
2
strstr : if : 	if (p->flags & PF_WQ_WORKER) : 
2
strstr : for : 	if (p->flags & PF_WQ_WORKER) : 
2
strstr : while : 	if (p->flags & PF_WQ_WORKER) : 
2
str : 		wq_worker_waking_up(p, cpu_of(rq));[37]
strstr : INIT : 		wq_worker_waking_up(p, cpu_of(rq)); : 
2
strstr : if : 		wq_worker_waking_up(p, cpu_of(rq)); : 
2
strstr : for : 		wq_worker_waking_up(p, cpu_of(rq)); : 
2
strstr : while : 		wq_worker_waking_up(p, cpu_of(rq)); : 
2
str :  * Mark the task runnable and perform wakeup-preemption.[56]
strstr : INIT :  * Mark the task runnable and perform wakeup-preemption. : 
2
strstr : if :  * Mark the task runnable and perform wakeup-preemption. : 
2
strstr : for :  * Mark the task runnable and perform wakeup-preemption. : 
2
strstr : while :  * Mark the task runnable and perform wakeup-preemption. : 
2
str :  */[3]
strstr : INIT :  */ : 
2
strstr : if :  */ : 
2
strstr : for :  */ : 
2
strstr : while :  */ : 
2
str : static void[11]
strstr : INIT : static void : 
2
strstr : if : static void : 
2
strstr : for : static void : 
2
strstr : while : static void : 
2
str : ttwu_do_wakeup(struct rq *rq, struct task_struct *p, int wake_flags)[68]
strstr : INIT : ttwu_do_wakeup(struct rq *rq, struct task_struct *p, int wake_flags) : 
2
strstr : if : ttwu_do_wakeup(struct rq *rq, struct task_struct *p, int wake_flags) : 
2
strstr : for : ttwu_do_wakeup(struct rq *rq, struct task_struct *p, int wake_flags) : 
2
strstr : while : ttwu_do_wakeup(struct rq *rq, struct task_struct *p, int wake_flags) : 
2
str : 	check_preempt_curr(rq, p, wake_flags);[39]
strstr : INIT : 	check_preempt_curr(rq, p, wake_flags); : 
2
strstr : if : 	check_preempt_curr(rq, p, wake_flags); : 
2
strstr : for : 	check_preempt_curr(rq, p, wake_flags); : 
2
strstr : while : 	check_preempt_curr(rq, p, wake_flags); : 
2
str : 	trace_sched_wakeup(p, true);[29]
strstr : INIT : 	trace_sched_wakeup(p, true); : 
2
strstr : if : 	trace_sched_wakeup(p, true); : 
2
strstr : for : 	trace_sched_wakeup(p, true); : 
2
strstr : while : 	trace_sched_wakeup(p, true); : 
2
str : 	p->state = TASK_RUNNING;[25]
strstr : INIT : 	p->state = TASK_RUNNING; : 
2
strstr : if : 	p->state = TASK_RUNNING; : 
2
strstr : for : 	p->state = TASK_RUNNING; : 
2
strstr : while : 	p->state = TASK_RUNNING; : 
2
str : #ifdef CONFIG_SMP[17]
strstr : INIT : #ifdef CONFIG_SMP : 
2
strstr : if : #ifdef CONFIG_SMP : 
2
strstr : for : #ifdef CONFIG_SMP : 
2
strstr : while : #ifdef CONFIG_SMP : 
2
str : 	if (p->sched_class->task_woken)[32]
strstr : INIT : 	if (p->sched_class->task_woken) : 
2
strstr : if : 	if (p->sched_class->task_woken) : 
2
strstr : for : 	if (p->sched_class->task_woken) : 
2
strstr : while : 	if (p->sched_class->task_woken) : 
2
str : 		p->sched_class->task_woken(rq, p);[36]
strstr : INIT : 		p->sched_class->task_woken(rq, p); : 
2
strstr : if : 		p->sched_class->task_woken(rq, p); : 
2
strstr : for : 		p->sched_class->task_woken(rq, p); : 
2
strstr : while : 		p->sched_class->task_woken(rq, p); : 
2
str : 	if (rq->idle_stamp) {[22]
strstr : INIT : 	if (rq->idle_stamp) { : 
2
strstr : if : 	if (rq->idle_stamp) { : 
2
strstr : for : 	if (rq->idle_stamp) { : 
2
strstr : while : 	if (rq->idle_stamp) { : 
2
str : 		u64 delta = rq_clock(rq) - rq->idle_stamp;[44]
strstr : INIT : 		u64 delta = rq_clock(rq) - rq->idle_stamp; : 
2
strstr : if : 		u64 delta = rq_clock(rq) - rq->idle_stamp; : 
2
strstr : for : 		u64 delta = rq_clock(rq) - rq->idle_stamp; : 
2
strstr : while : 		u64 delta = rq_clock(rq) - rq->idle_stamp; : 
2
str : 		u64 max = 2*rq->max_idle_balance_cost;[40]
strstr : INIT : 		u64 max = 2*rq->max_idle_balance_cost; : 
2
strstr : if : 		u64 max = 2*rq->max_idle_balance_cost; : 
2
strstr : for : 		u64 max = 2*rq->max_idle_balance_cost; : 
2
strstr : while : 		u64 max = 2*rq->max_idle_balance_cost; : 
2
str : 		update_avg(&rq->avg_idle, delta);[35]
strstr : INIT : 		update_avg(&rq->avg_idle, delta); : 
2
strstr : if : 		update_avg(&rq->avg_idle, delta); : 
2
strstr : for : 		update_avg(&rq->avg_idle, delta); : 
2
strstr : while : 		update_avg(&rq->avg_idle, delta); : 
2
str : 		if (rq->avg_idle > max)[25]
strstr : INIT : 		if (rq->avg_idle > max) : 
2
strstr : if : 		if (rq->avg_idle > max) : 
2
strstr : for : 		if (rq->avg_idle > max) : 
2
strstr : while : 		if (rq->avg_idle > max) : 
2
str : 			rq->avg_idle = max;[22]
strstr : INIT : 			rq->avg_idle = max; : 
2
strstr : if : 			rq->avg_idle = max; : 
2
strstr : for : 			rq->avg_idle = max; : 
2
strstr : while : 			rq->avg_idle = max; : 
2
str : 		rq->idle_stamp = 0;[21]
strstr : INIT : 		rq->idle_stamp = 0; : 
2
strstr : if : 		rq->idle_stamp = 0; : 
2
strstr : for : 		rq->idle_stamp = 0; : 
2
strstr : while : 		rq->idle_stamp = 0; : 
2
str : #endif[6]
strstr : INIT : #endif : 
2
strstr : if : #endif : 
2
strstr : for : #endif : 
2
strstr : while : #endif : 
2
str : static void[11]
strstr : INIT : static void : 
2
strstr : if : static void : 
2
strstr : for : static void : 
2
strstr : while : static void : 
2
str : ttwu_do_activate(struct rq *rq, struct task_struct *p, int wake_flags)[70]
strstr : INIT : ttwu_do_activate(struct rq *rq, struct task_struct *p, int wake_flags) : 
2
strstr : if : ttwu_do_activate(struct rq *rq, struct task_struct *p, int wake_flags) : 
2
strstr : for : ttwu_do_activate(struct rq *rq, struct task_struct *p, int wake_flags) : 
2
strstr : while : ttwu_do_activate(struct rq *rq, struct task_struct *p, int wake_flags) : 
2
str : #ifdef CONFIG_SMP[17]
strstr : INIT : #ifdef CONFIG_SMP : 
2
strstr : if : #ifdef CONFIG_SMP : 
2
strstr : for : #ifdef CONFIG_SMP : 
2
strstr : while : #ifdef CONFIG_SMP : 
2
str : 	if (p->sched_contributes_to_load)[34]
strstr : INIT : 	if (p->sched_contributes_to_load) : 
2
strstr : if : 	if (p->sched_contributes_to_load) : 
2
strstr : for : 	if (p->sched_contributes_to_load) : 
2
strstr : while : 	if (p->sched_contributes_to_load) : 
2
str : 		rq->nr_uninterruptible--;[27]
strstr : INIT : 		rq->nr_uninterruptible--; : 
2
strstr : if : 		rq->nr_uninterruptible--; : 
2
strstr : for : 		rq->nr_uninterruptible--; : 
2
strstr : while : 		rq->nr_uninterruptible--; : 
2
str : #endif[6]
strstr : INIT : #endif : 
2
strstr : if : #endif : 
2
strstr : for : #endif : 
2
strstr : while : #endif : 
2
str : 	ttwu_activate(rq, p, ENQUEUE_WAKEUP | ENQUEUE_WAKING);[55]
strstr : INIT : 	ttwu_activate(rq, p, ENQUEUE_WAKEUP | ENQUEUE_WAKING); : 
2
strstr : if : 	ttwu_activate(rq, p, ENQUEUE_WAKEUP | ENQUEUE_WAKING); : 
2
strstr : for : 	ttwu_activate(rq, p, ENQUEUE_WAKEUP | ENQUEUE_WAKING); : 
2
strstr : while : 	ttwu_activate(rq, p, ENQUEUE_WAKEUP | ENQUEUE_WAKING); : 
2
str : 	ttwu_do_wakeup(rq, p, wake_flags);[35]
strstr : INIT : 	ttwu_do_wakeup(rq, p, wake_flags); : 
2
strstr : if : 	ttwu_do_wakeup(rq, p, wake_flags); : 
2
strstr : for : 	ttwu_do_wakeup(rq, p, wake_flags); : 
2
strstr : while : 	ttwu_do_wakeup(rq, p, wake_flags); : 
2
str :  * Called in case the task @p isn't fully descheduled from its runqueue,[72]
strstr : INIT :  * Called in case the task @p isn't fully descheduled from its runqueue, : 
2
strstr : if :  * Called in case the task @p isn't fully descheduled from its runqueue, : 
2
strstr : for :  * Called in case the task @p isn't fully descheduled from its runqueue, : 
2
strstr : while :  * Called in case the task @p isn't fully descheduled from its runqueue, : 
2
str :  * in this case we must do a remote wakeup. Its a 'light' wakeup though,[72]
strstr : INIT :  * in this case we must do a remote wakeup. Its a 'light' wakeup though, : 
2
strstr : if :  * in this case we must do a remote wakeup. Its a 'light' wakeup though, : 
2
strstr : for :  * in this case we must do a remote wakeup. Its a 'light' wakeup though, : 
2
strstr : while :  * in this case we must do a remote wakeup. Its a 'light' wakeup though, : 
2
str :  * since all we need to do is flip p->state to TASK_RUNNING, since[66]
strstr : INIT :  * since all we need to do is flip p->state to TASK_RUNNING, since : 
2
strstr : if :  * since all we need to do is flip p->state to TASK_RUNNING, since : 
2
strstr : for :  * since all we need to do is flip p->state to TASK_RUNNING, since : 
2
strstr : while :  * since all we need to do is flip p->state to TASK_RUNNING, since : 
2
str :  * the task is still ->on_rq.[29]
strstr : INIT :  * the task is still ->on_rq. : 
2
strstr : if :  * the task is still ->on_rq. : 
2
strstr : for :  * the task is still ->on_rq. : 
2
strstr : while :  * the task is still ->on_rq. : 
2
str :  */[3]
strstr : INIT :  */ : 
2
strstr : if :  */ : 
2
strstr : for :  */ : 
2
strstr : while :  */ : 
2
str : static int ttwu_remote(struct task_struct *p, int wake_flags)[61]
strstr : INIT : static int ttwu_remote(struct task_struct *p, int wake_flags) : 
2
strstr : if : static int ttwu_remote(struct task_struct *p, int wake_flags) : 
2
strstr : for : static int ttwu_remote(struct task_struct *p, int wake_flags) : 
2
strstr : while : static int ttwu_remote(struct task_struct *p, int wake_flags) : 
2
str : 	struct rq *rq;[15]
strstr : INIT : 	struct rq *rq; : 
2
strstr : if : 	struct rq *rq; : 
2
strstr : for : 	struct rq *rq; : 
2
strstr : while : 	struct rq *rq; : 
2
str : 	int ret = 0;[13]
strstr : INIT : 	int ret = 0; : 
2
strstr : if : 	int ret = 0; : 
2
strstr : for : 	int ret = 0; : 
2
strstr : while : 	int ret = 0; : 
2
str : 	rq = __task_rq_lock(p);[24]
strstr : INIT : 	rq = __task_rq_lock(p); : 
2
strstr : if : 	rq = __task_rq_lock(p); : 
2
strstr : for : 	rq = __task_rq_lock(p); : 
2
strstr : while : 	rq = __task_rq_lock(p); : 
2
str : 	if (p->on_rq) {[16]
strstr : INIT : 	if (p->on_rq) { : 
2
strstr : if : 	if (p->on_rq) { : 
2
strstr : for : 	if (p->on_rq) { : 
2
strstr : while : 	if (p->on_rq) { : 
2
str : 		/* check_preempt_curr() may use rq clock */[45]
strstr : INIT : 		/* check_preempt_curr() may use rq clock */ : 
2
strstr : if : 		/* check_preempt_curr() may use rq clock */ : 
2
strstr : for : 		/* check_preempt_curr() may use rq clock */ : 
2
strstr : while : 		/* check_preempt_curr() may use rq clock */ : 
2
str : 		update_rq_clock(rq);[22]
strstr : INIT : 		update_rq_clock(rq); : 
2
strstr : if : 		update_rq_clock(rq); : 
2
strstr : for : 		update_rq_clock(rq); : 
2
strstr : while : 		update_rq_clock(rq); : 
2
str : 		ttwu_do_wakeup(rq, p, wake_flags);[36]
strstr : INIT : 		ttwu_do_wakeup(rq, p, wake_flags); : 
2
strstr : if : 		ttwu_do_wakeup(rq, p, wake_flags); : 
2
strstr : for : 		ttwu_do_wakeup(rq, p, wake_flags); : 
2
strstr : while : 		ttwu_do_wakeup(rq, p, wake_flags); : 
2
str : 		ret = 1;[10]
strstr : INIT : 		ret = 1; : 
2
strstr : if : 		ret = 1; : 
2
strstr : for : 		ret = 1; : 
2
strstr : while : 		ret = 1; : 
2
str : 	__task_rq_unlock(rq);[22]
strstr : INIT : 	__task_rq_unlock(rq); : 
2
strstr : if : 	__task_rq_unlock(rq); : 
2
strstr : for : 	__task_rq_unlock(rq); : 
2
strstr : while : 	__task_rq_unlock(rq); : 
2
str : 	return ret;[12]
strstr : INIT : 	return ret; : 
2
strstr : if : 	return ret; : 
2
strstr : for : 	return ret; : 
2
strstr : while : 	return ret; : 
2
str : #ifdef CONFIG_SMP[17]
strstr : INIT : #ifdef CONFIG_SMP : 
2
strstr : if : #ifdef CONFIG_SMP : 
2
strstr : for : #ifdef CONFIG_SMP : 
2
strstr : while : #ifdef CONFIG_SMP : 
2
str : static void sched_ttwu_pending(void)[36]
strstr : INIT : static void sched_ttwu_pending(void) : 
2
strstr : if : static void sched_ttwu_pending(void) : 
2
strstr : for : static void sched_ttwu_pending(void) : 
2
strstr : while : static void sched_ttwu_pending(void) : 
2
str : 	struct rq *rq = this_rq();[27]
strstr : INIT : 	struct rq *rq = this_rq(); : 
2
strstr : if : 	struct rq *rq = this_rq(); : 
2
strstr : for : 	struct rq *rq = this_rq(); : 
2
strstr : while : 	struct rq *rq = this_rq(); : 
2
str : 	struct llist_node *llist = llist_del_all(&rq->wake_list);[58]
strstr : INIT : 	struct llist_node *llist = llist_del_all(&rq->wake_list); : 
2
strstr : if : 	struct llist_node *llist = llist_del_all(&rq->wake_list); : 
2
strstr : for : 	struct llist_node *llist = llist_del_all(&rq->wake_list); : 
2
strstr : while : 	struct llist_node *llist = llist_del_all(&rq->wake_list); : 
2
str : 	struct task_struct *p;[23]
strstr : INIT : 	struct task_struct *p; : 
2
strstr : if : 	struct task_struct *p; : 
2
strstr : for : 	struct task_struct *p; : 
2
strstr : while : 	struct task_struct *p; : 
2
str : 	raw_spin_lock(&rq->lock);[26]
strstr : INIT : 	raw_spin_lock(&rq->lock); : 
2
strstr : if : 	raw_spin_lock(&rq->lock); : 
2
strstr : for : 	raw_spin_lock(&rq->lock); : 
2
strstr : while : 	raw_spin_lock(&rq->lock); : 
2
str : 	while (llist) {[16]
strstr : INIT : 	while (llist) { : 
2
strstr : if : 	while (llist) { : 
2
strstr : for : 	while (llist) { : 
2
strstr : while : 	while (llist) { : 
2
str : 		p = llist_entry(llist, struct task_struct, wake_entry);[57]
strstr : INIT : 		p = llist_entry(llist, struct task_struct, wake_entry); : 
2
strstr : if : 		p = llist_entry(llist, struct task_struct, wake_entry); : 
2
strstr : for : 		p = llist_entry(llist, struct task_struct, wake_entry); : 
2
strstr : while : 		p = llist_entry(llist, struct task_struct, wake_entry); : 
2
str : 		llist = llist_next(llist);[28]
strstr : INIT : 		llist = llist_next(llist); : 
2
strstr : if : 		llist = llist_next(llist); : 
2
strstr : for : 		llist = llist_next(llist); : 
2
strstr : while : 		llist = llist_next(llist); : 
2
str : 		ttwu_do_activate(rq, p, 0);[29]
strstr : INIT : 		ttwu_do_activate(rq, p, 0); : 
2
strstr : if : 		ttwu_do_activate(rq, p, 0); : 
2
strstr : for : 		ttwu_do_activate(rq, p, 0); : 
2
strstr : while : 		ttwu_do_activate(rq, p, 0); : 
2
str : 	raw_spin_unlock(&rq->lock);[28]
strstr : INIT : 	raw_spin_unlock(&rq->lock); : 
2
strstr : if : 	raw_spin_unlock(&rq->lock); : 
2
strstr : for : 	raw_spin_unlock(&rq->lock); : 
2
strstr : while : 	raw_spin_unlock(&rq->lock); : 
2
str : void scheduler_ipi(void)[24]
strstr : INIT : void scheduler_ipi(void) : 
2
strstr : if : void scheduler_ipi(void) : 
2
strstr : for : void scheduler_ipi(void) : 
2
strstr : while : void scheduler_ipi(void) : 
2
str : 	/*[3]
strstr : INIT : 	/* : 
2
strstr : if : 	/* : 
2
strstr : for : 	/* : 
2
strstr : while : 	/* : 
2
str : 	 * Fold TIF_NEED_RESCHED into the preempt_count; anybody setting[65]
strstr : INIT : 	 * Fold TIF_NEED_RESCHED into the preempt_count; anybody setting : 
2
strstr : if : 	 * Fold TIF_NEED_RESCHED into the preempt_count; anybody setting : 
2
strstr : for : 	 * Fold TIF_NEED_RESCHED into the preempt_count; anybody setting : 
2
strstr : while : 	 * Fold TIF_NEED_RESCHED into the preempt_count; anybody setting : 
2
str : 	 * TIF_NEED_RESCHED remotely (for the first time) will also send[65]
strstr : INIT : 	 * TIF_NEED_RESCHED remotely (for the first time) will also send : 
2
strstr : if : 	 * TIF_NEED_RESCHED remotely (for the first time) will also send : 
2
strstr : for : 	 * TIF_NEED_RESCHED remotely (for the first time) will also send : 
2
strstr : while : 	 * TIF_NEED_RESCHED remotely (for the first time) will also send : 
2
str : 	 * this IPI.[13]
strstr : INIT : 	 * this IPI. : 
2
strstr : if : 	 * this IPI. : 
2
strstr : for : 	 * this IPI. : 
2
strstr : while : 	 * this IPI. : 
2
str : 	 */[4]
strstr : INIT : 	 */ : 
2
strstr : if : 	 */ : 
2
strstr : for : 	 */ : 
2
strstr : while : 	 */ : 
2
str : 	preempt_fold_need_resched();[29]
strstr : INIT : 	preempt_fold_need_resched(); : 
2
strstr : if : 	preempt_fold_need_resched(); : 
2
strstr : for : 	preempt_fold_need_resched(); : 
2
strstr : while : 	preempt_fold_need_resched(); : 
2
str : 	if (llist_empty(&this_rq()->wake_list)[39]
strstr : INIT : 	if (llist_empty(&this_rq()->wake_list) : 
2
strstr : if : 	if (llist_empty(&this_rq()->wake_list) : 
2
strstr : for : 	if (llist_empty(&this_rq()->wake_list) : 
2
strstr : while : 	if (llist_empty(&this_rq()->wake_list) : 
2
str : 			&& !tick_nohz_full_cpu(smp_processor_id())[45]
strstr : INIT : 			&& !tick_nohz_full_cpu(smp_processor_id()) : 
2
strstr : if : 			&& !tick_nohz_full_cpu(smp_processor_id()) : 
2
strstr : for : 			&& !tick_nohz_full_cpu(smp_processor_id()) : 
2
strstr : while : 			&& !tick_nohz_full_cpu(smp_processor_id()) : 
2
str : 			&& !got_nohz_idle_kick())[28]
strstr : INIT : 			&& !got_nohz_idle_kick()) : 
2
strstr : if : 			&& !got_nohz_idle_kick()) : 
2
strstr : for : 			&& !got_nohz_idle_kick()) : 
2
strstr : while : 			&& !got_nohz_idle_kick()) : 
2
str : 		return;[9]
strstr : INIT : 		return; : 
2
strstr : if : 		return; : 
2
strstr : for : 		return; : 
2
strstr : while : 		return; : 
2
str : 	/*[3]
strstr : INIT : 	/* : 
2
strstr : if : 	/* : 
2
strstr : for : 	/* : 
2
strstr : while : 	/* : 
2
str : 	 * Not all reschedule IPI handlers call irq_enter/irq_exit, since[66]
strstr : INIT : 	 * Not all reschedule IPI handlers call irq_enter/irq_exit, since : 
2
strstr : if : 	 * Not all reschedule IPI handlers call irq_enter/irq_exit, since : 
2
strstr : for : 	 * Not all reschedule IPI handlers call irq_enter/irq_exit, since : 
2
strstr : while : 	 * Not all reschedule IPI handlers call irq_enter/irq_exit, since : 
2
str : 	 * traditionally all their work was done from the interrupt return[67]
strstr : INIT : 	 * traditionally all their work was done from the interrupt return : 
2
strstr : if : 	 * traditionally all their work was done from the interrupt return : 
2
strstr : for : 	 * traditionally all their work was done from the interrupt return : 
2
strstr : while : 	 * traditionally all their work was done from the interrupt return : 
2
str : 	 * path. Now that we actually do some work, we need to make sure[65]
strstr : INIT : 	 * path. Now that we actually do some work, we need to make sure : 
2
strstr : if : 	 * path. Now that we actually do some work, we need to make sure : 
2
strstr : for : 	 * path. Now that we actually do some work, we need to make sure : 
2
strstr : while : 	 * path. Now that we actually do some work, we need to make sure : 
2
str : 	 * we do call them.[20]
strstr : INIT : 	 * we do call them. : 
2
strstr : if : 	 * we do call them. : 
2
strstr : for : 	 * we do call them. : 
2
strstr : while : 	 * we do call them. : 
2
str : 	 *[3]
strstr : INIT : 	 * : 
2
strstr : if : 	 * : 
2
strstr : for : 	 * : 
2
strstr : while : 	 * : 
2
str : 	 * Some archs already do call them, luckily irq_enter/exit nest[64]
strstr : INIT : 	 * Some archs already do call them, luckily irq_enter/exit nest : 
2
strstr : if : 	 * Some archs already do call them, luckily irq_enter/exit nest : 
2
strstr : for : 	 * Some archs already do call them, luckily irq_enter/exit nest : 
2
strstr : while : 	 * Some archs already do call them, luckily irq_enter/exit nest : 
2
str : 	 * properly.[13]
strstr : INIT : 	 * properly. : 
2
strstr : if : 	 * properly. : 
2
strstr : for : 	 * properly. : 
2
strstr : while : 	 * properly. : 
2
str : 	 *[3]
strstr : INIT : 	 * : 
2
strstr : if : 	 * : 
2
strstr : for : 	 * : 
2
strstr : while : 	 * : 
2
str : 	 * Arguably we should visit all archs and update all handlers,[63]
strstr : INIT : 	 * Arguably we should visit all archs and update all handlers, : 
2
strstr : if : 	 * Arguably we should visit all archs and update all handlers, : 
2
strstr : for : 	 * Arguably we should visit all archs and update all handlers, : 
2
strstr : while : 	 * Arguably we should visit all archs and update all handlers, : 
2
str : 	 * however a fair share of IPIs are still resched only so this would[69]
strstr : INIT : 	 * however a fair share of IPIs are still resched only so this would : 
2
strstr : if : 	 * however a fair share of IPIs are still resched only so this would : 
2
strstr : for : 	 * however a fair share of IPIs are still resched only so this would : 
2
strstr : while : 	 * however a fair share of IPIs are still resched only so this would : 
2
str : 	 * somewhat pessimize the simple resched case.[47]
strstr : INIT : 	 * somewhat pessimize the simple resched case. : 
2
strstr : if : 	 * somewhat pessimize the simple resched case. : 
2
strstr : for : 	 * somewhat pessimize the simple resched case. : 
2
strstr : while : 	 * somewhat pessimize the simple resched case. : 
2
str : 	 */[4]
strstr : INIT : 	 */ : 
2
strstr : if : 	 */ : 
2
strstr : for : 	 */ : 
2
strstr : while : 	 */ : 
2
str : 	irq_enter();[13]
strstr : INIT : 	irq_enter(); : 
2
strstr : if : 	irq_enter(); : 
2
strstr : for : 	irq_enter(); : 
2
strstr : while : 	irq_enter(); : 
2
str : 	tick_nohz_full_check();[24]
strstr : INIT : 	tick_nohz_full_check(); : 
2
strstr : if : 	tick_nohz_full_check(); : 
2
strstr : for : 	tick_nohz_full_check(); : 
2
strstr : while : 	tick_nohz_full_check(); : 
2
str : 	sched_ttwu_pending();[22]
strstr : INIT : 	sched_ttwu_pending(); : 
2
strstr : if : 	sched_ttwu_pending(); : 
2
strstr : for : 	sched_ttwu_pending(); : 
2
strstr : while : 	sched_ttwu_pending(); : 
2
str : 	/*[3]
strstr : INIT : 	/* : 
2
strstr : if : 	/* : 
2
strstr : for : 	/* : 
2
strstr : while : 	/* : 
2
str : 	 * Check if someone kicked us for doing the nohz idle load balance.[68]
strstr : INIT : 	 * Check if someone kicked us for doing the nohz idle load balance. : 
2
strstr : if : 	 * Check if someone kicked us for doing the nohz idle load balance. : 
2
strstr : for : 	 * Check if someone kicked us for doing the nohz idle load balance. : 
2
strstr : while : 	 * Check if someone kicked us for doing the nohz idle load balance. : 
2
str : 	 */[4]
strstr : INIT : 	 */ : 
2
strstr : if : 	 */ : 
2
strstr : for : 	 */ : 
2
strstr : while : 	 */ : 
2
str : 	if (unlikely(got_nohz_idle_kick())) {[38]
strstr : INIT : 	if (unlikely(got_nohz_idle_kick())) { : 
2
strstr : if : 	if (unlikely(got_nohz_idle_kick())) { : 
2
strstr : for : 	if (unlikely(got_nohz_idle_kick())) { : 
2
strstr : while : 	if (unlikely(got_nohz_idle_kick())) { : 
2
str : 		this_rq()->idle_balance = 1;[30]
strstr : INIT : 		this_rq()->idle_balance = 1; : 
2
strstr : if : 		this_rq()->idle_balance = 1; : 
2
strstr : for : 		this_rq()->idle_balance = 1; : 
2
strstr : while : 		this_rq()->idle_balance = 1; : 
2
str : 		raise_softirq_irqoff(SCHED_SOFTIRQ);[38]
strstr : INIT : 		raise_softirq_irqoff(SCHED_SOFTIRQ); : 
2
strstr : if : 		raise_softirq_irqoff(SCHED_SOFTIRQ); : 
2
strstr : for : 		raise_softirq_irqoff(SCHED_SOFTIRQ); : 
2
strstr : while : 		raise_softirq_irqoff(SCHED_SOFTIRQ); : 
2
str : 	irq_exit();[12]
strstr : INIT : 	irq_exit(); : 
2
strstr : if : 	irq_exit(); : 
2
strstr : for : 	irq_exit(); : 
2
strstr : while : 	irq_exit(); : 
2
str : static void ttwu_queue_remote(struct task_struct *p, int cpu)[61]
strstr : INIT : static void ttwu_queue_remote(struct task_struct *p, int cpu) : 
2
strstr : if : static void ttwu_queue_remote(struct task_struct *p, int cpu) : 
2
strstr : for : static void ttwu_queue_remote(struct task_struct *p, int cpu) : 
2
strstr : while : static void ttwu_queue_remote(struct task_struct *p, int cpu) : 
2
str : 	if (llist_add(&p->wake_entry, &cpu_rq(cpu)->wake_list))[56]
strstr : INIT : 	if (llist_add(&p->wake_entry, &cpu_rq(cpu)->wake_list)) : 
2
strstr : if : 	if (llist_add(&p->wake_entry, &cpu_rq(cpu)->wake_list)) : 
2
strstr : for : 	if (llist_add(&p->wake_entry, &cpu_rq(cpu)->wake_list)) : 
2
strstr : while : 	if (llist_add(&p->wake_entry, &cpu_rq(cpu)->wake_list)) : 
2
str : 		smp_send_reschedule(cpu);[27]
strstr : INIT : 		smp_send_reschedule(cpu); : 
2
strstr : if : 		smp_send_reschedule(cpu); : 
2
strstr : for : 		smp_send_reschedule(cpu); : 
2
strstr : while : 		smp_send_reschedule(cpu); : 
2
str : bool cpus_share_cache(int this_cpu, int that_cpu)[49]
strstr : INIT : bool cpus_share_cache(int this_cpu, int that_cpu) : 
2
strstr : if : bool cpus_share_cache(int this_cpu, int that_cpu) : 
2
strstr : for : bool cpus_share_cache(int this_cpu, int that_cpu) : 
2
strstr : while : bool cpus_share_cache(int this_cpu, int that_cpu) : 
2
str : 	return per_cpu(sd_llc_id, this_cpu) == per_cpu(sd_llc_id, that_cpu);[69]
strstr : INIT : 	return per_cpu(sd_llc_id, this_cpu) == per_cpu(sd_llc_id, that_cpu); : 
2
strstr : if : 	return per_cpu(sd_llc_id, this_cpu) == per_cpu(sd_llc_id, that_cpu); : 
2
strstr : for : 	return per_cpu(sd_llc_id, this_cpu) == per_cpu(sd_llc_id, that_cpu); : 
2
strstr : while : 	return per_cpu(sd_llc_id, this_cpu) == per_cpu(sd_llc_id, that_cpu); : 
2
str : #endif /* CONFIG_SMP */[23]
strstr : INIT : #endif /* CONFIG_SMP */ : 
2
strstr : if : #endif /* CONFIG_SMP */ : 
2
strstr : for : #endif /* CONFIG_SMP */ : 
2
strstr : while : #endif /* CONFIG_SMP */ : 
2
str : static void ttwu_queue(struct task_struct *p, int cpu)[54]
strstr : INIT : static void ttwu_queue(struct task_struct *p, int cpu) : 
2
strstr : if : static void ttwu_queue(struct task_struct *p, int cpu) : 
2
strstr : for : static void ttwu_queue(struct task_struct *p, int cpu) : 
2
strstr : while : static void ttwu_queue(struct task_struct *p, int cpu) : 
2
str : 	struct rq *rq = cpu_rq(cpu);[29]
strstr : INIT : 	struct rq *rq = cpu_rq(cpu); : 
2
strstr : if : 	struct rq *rq = cpu_rq(cpu); : 
2
strstr : for : 	struct rq *rq = cpu_rq(cpu); : 
2
strstr : while : 	struct rq *rq = cpu_rq(cpu); : 
2
str : #if defined(CONFIG_SMP)[23]
strstr : INIT : #if defined(CONFIG_SMP) : 
2
strstr : if : #if defined(CONFIG_SMP) : 
2
strstr : for : #if defined(CONFIG_SMP) : 
2
strstr : while : #if defined(CONFIG_SMP) : 
2
str : 	if (sched_feat(TTWU_QUEUE) && !cpus_share_cache(smp_processor_id(), cpu)) {[76]
strstr : INIT : 	if (sched_feat(TTWU_QUEUE) && !cpus_share_cache(smp_processor_id(), cpu)) { : 
2
strstr : if : 	if (sched_feat(TTWU_QUEUE) && !cpus_share_cache(smp_processor_id(), cpu)) { : 
2
strstr : for : 	if (sched_feat(TTWU_QUEUE) && !cpus_share_cache(smp_processor_id(), cpu)) { : 
2
strstr : while : 	if (sched_feat(TTWU_QUEUE) && !cpus_share_cache(smp_processor_id(), cpu)) { : 
2
str : 		sched_clock_cpu(cpu); /* sync clocks x-cpu */[47]
strstr : INIT : 		sched_clock_cpu(cpu); /* sync clocks x-cpu */ : 
2
strstr : if : 		sched_clock_cpu(cpu); /* sync clocks x-cpu */ : 
2
strstr : for : 		sched_clock_cpu(cpu); /* sync clocks x-cpu */ : 
2
strstr : while : 		sched_clock_cpu(cpu); /* sync clocks x-cpu */ : 
2
str : 		ttwu_queue_remote(p, cpu);[28]
strstr : INIT : 		ttwu_queue_remote(p, cpu); : 
2
strstr : if : 		ttwu_queue_remote(p, cpu); : 
2
strstr : for : 		ttwu_queue_remote(p, cpu); : 
2
strstr : while : 		ttwu_queue_remote(p, cpu); : 
2
str : 		return;[9]
strstr : INIT : 		return; : 
2
strstr : if : 		return; : 
2
strstr : for : 		return; : 
2
strstr : while : 		return; : 
2
str : #endif[6]
strstr : INIT : #endif : 
2
strstr : if : #endif : 
2
strstr : for : #endif : 
2
strstr : while : #endif : 
2
str : 	raw_spin_lock(&rq->lock);[26]
strstr : INIT : 	raw_spin_lock(&rq->lock); : 
2
strstr : if : 	raw_spin_lock(&rq->lock); : 
2
strstr : for : 	raw_spin_lock(&rq->lock); : 
2
strstr : while : 	raw_spin_lock(&rq->lock); : 
2
str : 	ttwu_do_activate(rq, p, 0);[28]
strstr : INIT : 	ttwu_do_activate(rq, p, 0); : 
2
strstr : if : 	ttwu_do_activate(rq, p, 0); : 
2
strstr : for : 	ttwu_do_activate(rq, p, 0); : 
2
strstr : while : 	ttwu_do_activate(rq, p, 0); : 
2
str : 	raw_spin_unlock(&rq->lock);[28]
strstr : INIT : 	raw_spin_unlock(&rq->lock); : 
2
strstr : if : 	raw_spin_unlock(&rq->lock); : 
2
strstr : for : 	raw_spin_unlock(&rq->lock); : 
2
strstr : while : 	raw_spin_unlock(&rq->lock); : 
2
str : /**[3]
strstr : INIT : /** : 
2
strstr : if : /** : 
2
strstr : for : /** : 
2
strstr : while : /** : 
2
str :  * try_to_wake_up - wake up a thread[36]
strstr : INIT :  * try_to_wake_up - wake up a thread : 
2
strstr : if :  * try_to_wake_up - wake up a thread : 
2
strstr : for :  * try_to_wake_up - wake up a thread : 
2
strstr : while :  * try_to_wake_up - wake up a thread : 
2
str :  * @p: the thread to be awakened[32]
strstr : INIT :  * @p: the thread to be awakened : 
2
strstr : if :  * @p: the thread to be awakened : 
2
strstr : for :  * @p: the thread to be awakened : 
2
strstr : while :  * @p: the thread to be awakened : 
2
str :  * @state: the mask of task states that can be woken[52]
strstr : INIT :  * @state: the mask of task states that can be woken : 
2
strstr : if :  * @state: the mask of task states that can be woken : 
2
strstr : for :  * @state: the mask of task states that can be woken : 
2
strstr : while :  * @state: the mask of task states that can be woken : 
2
str :  * @wake_flags: wake modifier flags (WF_*)[42]
strstr : INIT :  * @wake_flags: wake modifier flags (WF_*) : 
2
strstr : if :  * @wake_flags: wake modifier flags (WF_*) : 
2
strstr : for :  * @wake_flags: wake modifier flags (WF_*) : 
2
strstr : while :  * @wake_flags: wake modifier flags (WF_*) : 
2
str :  * Put it on the run-queue if it's not already there. The "current"[67]
strstr : INIT :  * Put it on the run-queue if it's not already there. The "current" : 
2
strstr : if :  * Put it on the run-queue if it's not already there. The "current" : 
2
strstr : for :  * Put it on the run-queue if it's not already there. The "current" : 
2
strstr : while :  * Put it on the run-queue if it's not already there. The "current" : 
2
str :  * thread is always on the run-queue (except when the actual[60]
strstr : INIT :  * thread is always on the run-queue (except when the actual : 
2
strstr : if :  * thread is always on the run-queue (except when the actual : 
2
strstr : for :  * thread is always on the run-queue (except when the actual : 
2
strstr : while :  * thread is always on the run-queue (except when the actual : 
2
str :  * re-schedule is in progress), and as such you're allowed to do[64]
strstr : INIT :  * re-schedule is in progress), and as such you're allowed to do : 
2
strstr : if :  * re-schedule is in progress), and as such you're allowed to do : 
2
strstr : for :  * re-schedule is in progress), and as such you're allowed to do : 
2
strstr : while :  * re-schedule is in progress), and as such you're allowed to do : 
2
str :  * the simpler "current->state = TASK_RUNNING" to mark yourself[63]
strstr : INIT :  * the simpler "current->state = TASK_RUNNING" to mark yourself : 
2
strstr : if :  * the simpler "current->state = TASK_RUNNING" to mark yourself : 
2
strstr : for :  * the simpler "current->state = TASK_RUNNING" to mark yourself : 
2
strstr : while :  * the simpler "current->state = TASK_RUNNING" to mark yourself : 
2
str :  * runnable without the overhead of this.[41]
strstr : INIT :  * runnable without the overhead of this. : 
2
strstr : if :  * runnable without the overhead of this. : 
2
strstr : for :  * runnable without the overhead of this. : 
2
strstr : while :  * runnable without the overhead of this. : 
2
str :  * Return: %true if @p was woken up, %false if it was already running.[70]
strstr : INIT :  * Return: %true if @p was woken up, %false if it was already running. : 
2
strstr : if :  * Return: %true if @p was woken up, %false if it was already running. : 
2
strstr : for :  * Return: %true if @p was woken up, %false if it was already running. : 
2
strstr : while :  * Return: %true if @p was woken up, %false if it was already running. : 
2
str :  * or @state didn't match @p's state.[37]
strstr : INIT :  * or @state didn't match @p's state. : 
2
strstr : if :  * or @state didn't match @p's state. : 
2
strstr : for :  * or @state didn't match @p's state. : 
2
strstr : while :  * or @state didn't match @p's state. : 
2
str :  */[3]
strstr : INIT :  */ : 
2
strstr : if :  */ : 
2
strstr : for :  */ : 
2
strstr : while :  */ : 
2
str : static int[10]
strstr : INIT : static int : 
2
strstr : if : static int : 
2
strstr : for : static int : 
2
strstr : while : static int : 
2
str : try_to_wake_up(struct task_struct *p, unsigned int state, int wake_flags)[73]
strstr : INIT : try_to_wake_up(struct task_struct *p, unsigned int state, int wake_flags) : 
2
strstr : if : try_to_wake_up(struct task_struct *p, unsigned int state, int wake_flags) : 
2
strstr : for : try_to_wake_up(struct task_struct *p, unsigned int state, int wake_flags) : 
2
strstr : while : try_to_wake_up(struct task_struct *p, unsigned int state, int wake_flags) : 
2
str : 	unsigned long flags;[21]
strstr : INIT : 	unsigned long flags; : 
2
strstr : if : 	unsigned long flags; : 
2
strstr : for : 	unsigned long flags; : 
2
strstr : while : 	unsigned long flags; : 
2
str : 	int cpu, success = 0;[22]
strstr : INIT : 	int cpu, success = 0; : 
2
strstr : if : 	int cpu, success = 0; : 
2
strstr : for : 	int cpu, success = 0; : 
2
strstr : while : 	int cpu, success = 0; : 
2
str : 	/*[3]
strstr : INIT : 	/* : 
2
strstr : if : 	/* : 
2
strstr : for : 	/* : 
2
strstr : while : 	/* : 
2
str : 	 * If we are going to wake up a thread waiting for CONDITION we[64]
strstr : INIT : 	 * If we are going to wake up a thread waiting for CONDITION we : 
2
strstr : if : 	 * If we are going to wake up a thread waiting for CONDITION we : 
2
strstr : for : 	 * If we are going to wake up a thread waiting for CONDITION we : 
2
strstr : while : 	 * If we are going to wake up a thread waiting for CONDITION we : 
2
str : 	 * need to ensure that CONDITION=1 done by the caller can not be[65]
strstr : INIT : 	 * need to ensure that CONDITION=1 done by the caller can not be : 
2
strstr : if : 	 * need to ensure that CONDITION=1 done by the caller can not be : 
2
strstr : for : 	 * need to ensure that CONDITION=1 done by the caller can not be : 
2
strstr : while : 	 * need to ensure that CONDITION=1 done by the caller can not be : 
2
str : 	 * reordered with p->state check below. This pairs with mb() in[64]
strstr : INIT : 	 * reordered with p->state check below. This pairs with mb() in : 
2
strstr : if : 	 * reordered with p->state check below. This pairs with mb() in : 
2
strstr : for : 	 * reordered with p->state check below. This pairs with mb() in : 
2
strstr : while : 	 * reordered with p->state check below. This pairs with mb() in : 
2
str : 	 * set_current_state() the waiting thread does.[48]
strstr : INIT : 	 * set_current_state() the waiting thread does. : 
2
strstr : if : 	 * set_current_state() the waiting thread does. : 
2
strstr : for : 	 * set_current_state() the waiting thread does. : 
2
strstr : while : 	 * set_current_state() the waiting thread does. : 
2
str : 	 */[4]
strstr : INIT : 	 */ : 
2
strstr : if : 	 */ : 
2
strstr : for : 	 */ : 
2
strstr : while : 	 */ : 
2
str : 	smp_mb__before_spinlock();[27]
strstr : INIT : 	smp_mb__before_spinlock(); : 
2
strstr : if : 	smp_mb__before_spinlock(); : 
2
strstr : for : 	smp_mb__before_spinlock(); : 
2
strstr : while : 	smp_mb__before_spinlock(); : 
2
str : 	raw_spin_lock_irqsave(&p->pi_lock, flags);[43]
strstr : INIT : 	raw_spin_lock_irqsave(&p->pi_lock, flags); : 
2
strstr : if : 	raw_spin_lock_irqsave(&p->pi_lock, flags); : 
2
strstr : for : 	raw_spin_lock_irqsave(&p->pi_lock, flags); : 
2
strstr : while : 	raw_spin_lock_irqsave(&p->pi_lock, flags); : 
2
str : 	if (!(p->state & state))[25]
strstr : INIT : 	if (!(p->state & state)) : 
2
strstr : if : 	if (!(p->state & state)) : 
2
strstr : for : 	if (!(p->state & state)) : 
2
strstr : while : 	if (!(p->state & state)) : 
2
str : 		goto out;[11]
strstr : INIT : 		goto out; : 
2
strstr : if : 		goto out; : 
2
strstr : for : 		goto out; : 
2
strstr : while : 		goto out; : 
2
str : 	success = 1; /* we're going to change ->state */[49]
strstr : INIT : 	success = 1; /* we're going to change ->state */ : 
2
strstr : if : 	success = 1; /* we're going to change ->state */ : 
2
strstr : for : 	success = 1; /* we're going to change ->state */ : 
2
strstr : while : 	success = 1; /* we're going to change ->state */ : 
2
str : 	cpu = task_cpu(p);[19]
strstr : INIT : 	cpu = task_cpu(p); : 
2
strstr : if : 	cpu = task_cpu(p); : 
2
strstr : for : 	cpu = task_cpu(p); : 
2
strstr : while : 	cpu = task_cpu(p); : 
2
str : 	if (p->on_rq && ttwu_remote(p, wake_flags))[44]
strstr : INIT : 	if (p->on_rq && ttwu_remote(p, wake_flags)) : 
2
strstr : if : 	if (p->on_rq && ttwu_remote(p, wake_flags)) : 
2
strstr : for : 	if (p->on_rq && ttwu_remote(p, wake_flags)) : 
2
strstr : while : 	if (p->on_rq && ttwu_remote(p, wake_flags)) : 
2
str : 		goto stat;[12]
strstr : INIT : 		goto stat; : 
2
strstr : if : 		goto stat; : 
2
strstr : for : 		goto stat; : 
2
strstr : while : 		goto stat; : 
2
str : #ifdef CONFIG_SMP[17]
strstr : INIT : #ifdef CONFIG_SMP : 
2
strstr : if : #ifdef CONFIG_SMP : 
2
strstr : for : #ifdef CONFIG_SMP : 
2
strstr : while : #ifdef CONFIG_SMP : 
2
str : 	/*[3]
strstr : INIT : 	/* : 
2
strstr : if : 	/* : 
2
strstr : for : 	/* : 
2
strstr : while : 	/* : 
2
str : 	 * If the owning (remote) cpu is still in the middle of schedule() with[72]
strstr : INIT : 	 * If the owning (remote) cpu is still in the middle of schedule() with : 
2
strstr : if : 	 * If the owning (remote) cpu is still in the middle of schedule() with : 
2
strstr : for : 	 * If the owning (remote) cpu is still in the middle of schedule() with : 
2
strstr : while : 	 * If the owning (remote) cpu is still in the middle of schedule() with : 
2
str : 	 * this task as prev, wait until its done referencing the task.[64]
strstr : INIT : 	 * this task as prev, wait until its done referencing the task. : 
2
strstr : if : 	 * this task as prev, wait until its done referencing the task. : 
2
strstr : for : 	 * this task as prev, wait until its done referencing the task. : 
2
strstr : while : 	 * this task as prev, wait until its done referencing the task. : 
2
str : 	 */[4]
strstr : INIT : 	 */ : 
2
strstr : if : 	 */ : 
2
strstr : for : 	 */ : 
2
strstr : while : 	 */ : 
2
str : 	while (p->on_cpu)[18]
strstr : INIT : 	while (p->on_cpu) : 
2
strstr : if : 	while (p->on_cpu) : 
2
strstr : for : 	while (p->on_cpu) : 
2
strstr : while : 	while (p->on_cpu) : 
2
str : 		cpu_relax();[14]
strstr : INIT : 		cpu_relax(); : 
2
strstr : if : 		cpu_relax(); : 
2
strstr : for : 		cpu_relax(); : 
2
strstr : while : 		cpu_relax(); : 
2
str : 	/*[3]
strstr : INIT : 	/* : 
2
strstr : if : 	/* : 
2
strstr : for : 	/* : 
2
strstr : while : 	/* : 
2
str : 	 * Pairs with the smp_wmb() in finish_lock_switch().[53]
strstr : INIT : 	 * Pairs with the smp_wmb() in finish_lock_switch(). : 
2
strstr : if : 	 * Pairs with the smp_wmb() in finish_lock_switch(). : 
2
strstr : for : 	 * Pairs with the smp_wmb() in finish_lock_switch(). : 
2
strstr : while : 	 * Pairs with the smp_wmb() in finish_lock_switch(). : 
2
str : 	 */[4]
strstr : INIT : 	 */ : 
2
strstr : if : 	 */ : 
2
strstr : for : 	 */ : 
2
strstr : while : 	 */ : 
2
str : 	smp_rmb();[11]
strstr : INIT : 	smp_rmb(); : 
2
strstr : if : 	smp_rmb(); : 
2
strstr : for : 	smp_rmb(); : 
2
strstr : while : 	smp_rmb(); : 
2
str : 	p->sched_contributes_to_load = !!task_contributes_to_load(p);[62]
strstr : INIT : 	p->sched_contributes_to_load = !!task_contributes_to_load(p); : 
2
strstr : if : 	p->sched_contributes_to_load = !!task_contributes_to_load(p); : 
2
strstr : for : 	p->sched_contributes_to_load = !!task_contributes_to_load(p); : 
2
strstr : while : 	p->sched_contributes_to_load = !!task_contributes_to_load(p); : 
2
str : 	p->state = TASK_WAKING;[24]
strstr : INIT : 	p->state = TASK_WAKING; : 
2
strstr : if : 	p->state = TASK_WAKING; : 
2
strstr : for : 	p->state = TASK_WAKING; : 
2
strstr : while : 	p->state = TASK_WAKING; : 
2
str : 	if (p->sched_class->task_waking)[33]
strstr : INIT : 	if (p->sched_class->task_waking) : 
2
strstr : if : 	if (p->sched_class->task_waking) : 
2
strstr : for : 	if (p->sched_class->task_waking) : 
2
strstr : while : 	if (p->sched_class->task_waking) : 
2
str : 		p->sched_class->task_waking(p);[33]
strstr : INIT : 		p->sched_class->task_waking(p); : 
2
strstr : if : 		p->sched_class->task_waking(p); : 
2
strstr : for : 		p->sched_class->task_waking(p); : 
2
strstr : while : 		p->sched_class->task_waking(p); : 
2
str : 	cpu = select_task_rq(p, p->wake_cpu, SD_BALANCE_WAKE, wake_flags);[67]
strstr : INIT : 	cpu = select_task_rq(p, p->wake_cpu, SD_BALANCE_WAKE, wake_flags); : 
2
strstr : if : 	cpu = select_task_rq(p, p->wake_cpu, SD_BALANCE_WAKE, wake_flags); : 
2
strstr : for : 	cpu = select_task_rq(p, p->wake_cpu, SD_BALANCE_WAKE, wake_flags); : 
2
strstr : while : 	cpu = select_task_rq(p, p->wake_cpu, SD_BALANCE_WAKE, wake_flags); : 
2
str : 	if (task_cpu(p) != cpu) {[26]
strstr : INIT : 	if (task_cpu(p) != cpu) { : 
2
strstr : if : 	if (task_cpu(p) != cpu) { : 
2
strstr : for : 	if (task_cpu(p) != cpu) { : 
2
strstr : while : 	if (task_cpu(p) != cpu) { : 
2
str : 		wake_flags |= WF_MIGRATED;[28]
strstr : INIT : 		wake_flags |= WF_MIGRATED; : 
2
strstr : if : 		wake_flags |= WF_MIGRATED; : 
2
strstr : for : 		wake_flags |= WF_MIGRATED; : 
2
strstr : while : 		wake_flags |= WF_MIGRATED; : 
2
str : 		set_task_cpu(p, cpu);[23]
strstr : INIT : 		set_task_cpu(p, cpu); : 
2
strstr : if : 		set_task_cpu(p, cpu); : 
2
strstr : for : 		set_task_cpu(p, cpu); : 
2
strstr : while : 		set_task_cpu(p, cpu); : 
2
str : #endif /* CONFIG_SMP */[23]
strstr : INIT : #endif /* CONFIG_SMP */ : 
2
strstr : if : #endif /* CONFIG_SMP */ : 
2
strstr : for : #endif /* CONFIG_SMP */ : 
2
strstr : while : #endif /* CONFIG_SMP */ : 
2
str : 	ttwu_queue(p, cpu);[20]
strstr : INIT : 	ttwu_queue(p, cpu); : 
2
strstr : if : 	ttwu_queue(p, cpu); : 
2
strstr : for : 	ttwu_queue(p, cpu); : 
2
strstr : while : 	ttwu_queue(p, cpu); : 
2
str : stat:[5]
strstr : INIT : stat: : 
2
strstr : if : stat: : 
2
strstr : for : stat: : 
2
strstr : while : stat: : 
2
str : 	ttwu_stat(p, cpu, wake_flags);[31]
strstr : INIT : 	ttwu_stat(p, cpu, wake_flags); : 
2
strstr : if : 	ttwu_stat(p, cpu, wake_flags); : 
2
strstr : for : 	ttwu_stat(p, cpu, wake_flags); : 
2
strstr : while : 	ttwu_stat(p, cpu, wake_flags); : 
2
str : out:[4]
strstr : INIT : out: : 
2
strstr : if : out: : 
2
strstr : for : out: : 
2
strstr : while : out: : 
2
str : 	raw_spin_unlock_irqrestore(&p->pi_lock, flags);[48]
strstr : INIT : 	raw_spin_unlock_irqrestore(&p->pi_lock, flags); : 
2
strstr : if : 	raw_spin_unlock_irqrestore(&p->pi_lock, flags); : 
2
strstr : for : 	raw_spin_unlock_irqrestore(&p->pi_lock, flags); : 
2
strstr : while : 	raw_spin_unlock_irqrestore(&p->pi_lock, flags); : 
2
str : 	return success;[16]
strstr : INIT : 	return success; : 
2
strstr : if : 	return success; : 
2
strstr : for : 	return success; : 
2
strstr : while : 	return success; : 
2
str : /**[3]
strstr : INIT : /** : 
2
strstr : if : /** : 
2
strstr : for : /** : 
2
strstr : while : /** : 
2
str :  * try_to_wake_up_local - try to wake up a local task with rq lock held[71]
strstr : INIT :  * try_to_wake_up_local - try to wake up a local task with rq lock held : 
2
strstr : if :  * try_to_wake_up_local - try to wake up a local task with rq lock held : 
2
strstr : for :  * try_to_wake_up_local - try to wake up a local task with rq lock held : 
2
strstr : while :  * try_to_wake_up_local - try to wake up a local task with rq lock held : 
2
str :  * @p: the thread to be awakened[32]
strstr : INIT :  * @p: the thread to be awakened : 
2
strstr : if :  * @p: the thread to be awakened : 
2
strstr : for :  * @p: the thread to be awakened : 
2
strstr : while :  * @p: the thread to be awakened : 
2
str :  * Put @p on the run-queue if it's not already there. The caller must[69]
strstr : INIT :  * Put @p on the run-queue if it's not already there. The caller must : 
2
strstr : if :  * Put @p on the run-queue if it's not already there. The caller must : 
2
strstr : for :  * Put @p on the run-queue if it's not already there. The caller must : 
2
strstr : while :  * Put @p on the run-queue if it's not already there. The caller must : 
2
str :  * ensure that this_rq() is locked, @p is bound to this_rq() and not[68]
strstr : INIT :  * ensure that this_rq() is locked, @p is bound to this_rq() and not : 
2
strstr : if :  * ensure that this_rq() is locked, @p is bound to this_rq() and not : 
2
strstr : for :  * ensure that this_rq() is locked, @p is bound to this_rq() and not : 
2
strstr : while :  * ensure that this_rq() is locked, @p is bound to this_rq() and not : 
2
str :  * the current task.[20]
strstr : INIT :  * the current task. : 
2
strstr : if :  * the current task. : 
2
strstr : for :  * the current task. : 
2
strstr : while :  * the current task. : 
2
str :  */[3]
strstr : INIT :  */ : 
2
strstr : if :  */ : 
2
strstr : for :  */ : 
2
strstr : while :  */ : 
2
str : static void try_to_wake_up_local(struct task_struct *p)[55]
strstr : INIT : static void try_to_wake_up_local(struct task_struct *p) : 
2
strstr : if : static void try_to_wake_up_local(struct task_struct *p) : 
2
strstr : for : static void try_to_wake_up_local(struct task_struct *p) : 
2
strstr : while : static void try_to_wake_up_local(struct task_struct *p) : 
2
str : 	struct rq *rq = task_rq(p);[28]
strstr : INIT : 	struct rq *rq = task_rq(p); : 
2
strstr : if : 	struct rq *rq = task_rq(p); : 
2
strstr : for : 	struct rq *rq = task_rq(p); : 
2
strstr : while : 	struct rq *rq = task_rq(p); : 
2
str : 	if (WARN_ON_ONCE(rq != this_rq()) ||[37]
strstr : INIT : 	if (WARN_ON_ONCE(rq != this_rq()) || : 
2
strstr : if : 	if (WARN_ON_ONCE(rq != this_rq()) || : 
2
strstr : for : 	if (WARN_ON_ONCE(rq != this_rq()) || : 
2
strstr : while : 	if (WARN_ON_ONCE(rq != this_rq()) || : 
2
str : 	    WARN_ON_ONCE(p == current))[32]
strstr : INIT : 	    WARN_ON_ONCE(p == current)) : 
2
strstr : if : 	    WARN_ON_ONCE(p == current)) : 
2
strstr : for : 	    WARN_ON_ONCE(p == current)) : 
2
strstr : while : 	    WARN_ON_ONCE(p == current)) : 
2
str : 		return;[9]
strstr : INIT : 		return; : 
2
strstr : if : 		return; : 
2
strstr : for : 		return; : 
2
strstr : while : 		return; : 
2
str : 	lockdep_assert_held(&rq->lock);[32]
strstr : INIT : 	lockdep_assert_held(&rq->lock); : 
2
strstr : if : 	lockdep_assert_held(&rq->lock); : 
2
strstr : for : 	lockdep_assert_held(&rq->lock); : 
2
strstr : while : 	lockdep_assert_held(&rq->lock); : 
2
str : 	if (!raw_spin_trylock(&p->pi_lock)) {[38]
strstr : INIT : 	if (!raw_spin_trylock(&p->pi_lock)) { : 
2
strstr : if : 	if (!raw_spin_trylock(&p->pi_lock)) { : 
2
strstr : for : 	if (!raw_spin_trylock(&p->pi_lock)) { : 
2
strstr : while : 	if (!raw_spin_trylock(&p->pi_lock)) { : 
2
str : 		raw_spin_unlock(&rq->lock);[29]
strstr : INIT : 		raw_spin_unlock(&rq->lock); : 
2
strstr : if : 		raw_spin_unlock(&rq->lock); : 
2
strstr : for : 		raw_spin_unlock(&rq->lock); : 
2
strstr : while : 		raw_spin_unlock(&rq->lock); : 
2
str : 		raw_spin_lock(&p->pi_lock);[29]
strstr : INIT : 		raw_spin_lock(&p->pi_lock); : 
2
strstr : if : 		raw_spin_lock(&p->pi_lock); : 
2
strstr : for : 		raw_spin_lock(&p->pi_lock); : 
2
strstr : while : 		raw_spin_lock(&p->pi_lock); : 
2
str : 		raw_spin_lock(&rq->lock);[27]
strstr : INIT : 		raw_spin_lock(&rq->lock); : 
2
strstr : if : 		raw_spin_lock(&rq->lock); : 
2
strstr : for : 		raw_spin_lock(&rq->lock); : 
2
strstr : while : 		raw_spin_lock(&rq->lock); : 
2
str : 	if (!(p->state & TASK_NORMAL))[31]
strstr : INIT : 	if (!(p->state & TASK_NORMAL)) : 
2
strstr : if : 	if (!(p->state & TASK_NORMAL)) : 
2
strstr : for : 	if (!(p->state & TASK_NORMAL)) : 
2
strstr : while : 	if (!(p->state & TASK_NORMAL)) : 
2
str : 		goto out;[11]
strstr : INIT : 		goto out; : 
2
strstr : if : 		goto out; : 
2
strstr : for : 		goto out; : 
2
strstr : while : 		goto out; : 
2
str : 	if (!p->on_rq)[15]
strstr : INIT : 	if (!p->on_rq) : 
2
strstr : if : 	if (!p->on_rq) : 
2
strstr : for : 	if (!p->on_rq) : 
2
strstr : while : 	if (!p->on_rq) : 
2
str : 		ttwu_activate(rq, p, ENQUEUE_WAKEUP);[39]
strstr : INIT : 		ttwu_activate(rq, p, ENQUEUE_WAKEUP); : 
2
strstr : if : 		ttwu_activate(rq, p, ENQUEUE_WAKEUP); : 
2
strstr : for : 		ttwu_activate(rq, p, ENQUEUE_WAKEUP); : 
2
strstr : while : 		ttwu_activate(rq, p, ENQUEUE_WAKEUP); : 
2
str : 	ttwu_do_wakeup(rq, p, 0);[26]
strstr : INIT : 	ttwu_do_wakeup(rq, p, 0); : 
2
strstr : if : 	ttwu_do_wakeup(rq, p, 0); : 
2
strstr : for : 	ttwu_do_wakeup(rq, p, 0); : 
2
strstr : while : 	ttwu_do_wakeup(rq, p, 0); : 
2
str : 	ttwu_stat(p, smp_processor_id(), 0);[37]
strstr : INIT : 	ttwu_stat(p, smp_processor_id(), 0); : 
2
strstr : if : 	ttwu_stat(p, smp_processor_id(), 0); : 
2
strstr : for : 	ttwu_stat(p, smp_processor_id(), 0); : 
2
strstr : while : 	ttwu_stat(p, smp_processor_id(), 0); : 
2
str : out:[4]
strstr : INIT : out: : 
2
strstr : if : out: : 
2
strstr : for : out: : 
2
strstr : while : out: : 
2
str : 	raw_spin_unlock(&p->pi_lock);[30]
strstr : INIT : 	raw_spin_unlock(&p->pi_lock); : 
2
strstr : if : 	raw_spin_unlock(&p->pi_lock); : 
2
strstr : for : 	raw_spin_unlock(&p->pi_lock); : 
2
strstr : while : 	raw_spin_unlock(&p->pi_lock); : 
2
str : /**[3]
strstr : INIT : /** : 
2
strstr : if : /** : 
2
strstr : for : /** : 
2
strstr : while : /** : 
2
str :  * wake_up_process - Wake up a specific process[47]
strstr : INIT :  * wake_up_process - Wake up a specific process : 
2
strstr : if :  * wake_up_process - Wake up a specific process : 
2
strstr : for :  * wake_up_process - Wake up a specific process : 
2
strstr : while :  * wake_up_process - Wake up a specific process : 
2
str :  * @p: The process to be woken up.[34]
strstr : INIT :  * @p: The process to be woken up. : 
2
strstr : if :  * @p: The process to be woken up. : 
2
strstr : for :  * @p: The process to be woken up. : 
2
strstr : while :  * @p: The process to be woken up. : 
2
str :  * Attempt to wake up the nominated process and move it to the set of runnable[78]
strstr : INIT :  * Attempt to wake up the nominated process and move it to the set of runnable : 
2
strstr : if :  * Attempt to wake up the nominated process and move it to the set of runnable : 
2
strstr : for :  * Attempt to wake up the nominated process and move it to the set of runnable : 
2
strstr : while :  * Attempt to wake up the nominated process and move it to the set of runnable : 
2
str :  * processes.[13]
strstr : INIT :  * processes. : 
2
strstr : if :  * processes. : 
2
strstr : for :  * processes. : 
2
strstr : while :  * processes. : 
2
str :  * Return: 1 if the process was woken up, 0 if it was already running.[70]
strstr : INIT :  * Return: 1 if the process was woken up, 0 if it was already running. : 
2
strstr : if :  * Return: 1 if the process was woken up, 0 if it was already running. : 
2
strstr : for :  * Return: 1 if the process was woken up, 0 if it was already running. : 
2
strstr : while :  * Return: 1 if the process was woken up, 0 if it was already running. : 
2
str :  * It may be assumed that this function implies a write memory barrier before[77]
strstr : INIT :  * It may be assumed that this function implies a write memory barrier before : 
2
strstr : if :  * It may be assumed that this function implies a write memory barrier before : 
2
strstr : for :  * It may be assumed that this function implies a write memory barrier before : 
2
strstr : while :  * It may be assumed that this function implies a write memory barrier before : 
2
str :  * changing the task state if and only if any tasks are woken up.[65]
strstr : INIT :  * changing the task state if and only if any tasks are woken up. : 
2
strstr : if :  * changing the task state if and only if any tasks are woken up. : 
2
strstr : for :  * changing the task state if and only if any tasks are woken up. : 
2
strstr : while :  * changing the task state if and only if any tasks are woken up. : 
2
str :  */[3]
strstr : INIT :  */ : 
2
strstr : if :  */ : 
2
strstr : for :  */ : 
2
strstr : while :  */ : 
2
str : int wake_up_process(struct task_struct *p)[42]
strstr : INIT : int wake_up_process(struct task_struct *p) : 
2
strstr : if : int wake_up_process(struct task_struct *p) : 
2
strstr : for : int wake_up_process(struct task_struct *p) : 
2
strstr : while : int wake_up_process(struct task_struct *p) : 
2
str : 	WARN_ON(task_is_stopped_or_traced(p));[39]
strstr : INIT : 	WARN_ON(task_is_stopped_or_traced(p)); : 
2
strstr : if : 	WARN_ON(task_is_stopped_or_traced(p)); : 
2
strstr : for : 	WARN_ON(task_is_stopped_or_traced(p)); : 
2
strstr : while : 	WARN_ON(task_is_stopped_or_traced(p)); : 
2
str : 	return try_to_wake_up(p, TASK_NORMAL, 0);[42]
strstr : INIT : 	return try_to_wake_up(p, TASK_NORMAL, 0); : 
2
strstr : if : 	return try_to_wake_up(p, TASK_NORMAL, 0); : 
2
strstr : for : 	return try_to_wake_up(p, TASK_NORMAL, 0); : 
2
strstr : while : 	return try_to_wake_up(p, TASK_NORMAL, 0); : 
2
str : EXPORT_SYMBOL(wake_up_process);[31]
strstr : INIT : EXPORT_SYMBOL(wake_up_process); : 
2
strstr : if : EXPORT_SYMBOL(wake_up_process); : 
2
strstr : for : EXPORT_SYMBOL(wake_up_process); : 
2
strstr : while : EXPORT_SYMBOL(wake_up_process); : 
2
str : int wake_up_state(struct task_struct *p, unsigned int state)[60]
strstr : INIT : int wake_up_state(struct task_struct *p, unsigned int state) : 
2
strstr : if : int wake_up_state(struct task_struct *p, unsigned int state) : 
2
strstr : for : int wake_up_state(struct task_struct *p, unsigned int state) : 
2
strstr : while : int wake_up_state(struct task_struct *p, unsigned int state) : 
2
str : 	return try_to_wake_up(p, state, 0);[36]
strstr : INIT : 	return try_to_wake_up(p, state, 0); : 
2
strstr : if : 	return try_to_wake_up(p, state, 0); : 
2
strstr : for : 	return try_to_wake_up(p, state, 0); : 
2
strstr : while : 	return try_to_wake_up(p, state, 0); : 
2
str :  * Perform scheduler related setup for a newly forked process p.[64]
strstr : INIT :  * Perform scheduler related setup for a newly forked process p. : 
2
strstr : if :  * Perform scheduler related setup for a newly forked process p. : 
2
strstr : for :  * Perform scheduler related setup for a newly forked process p. : 
2
strstr : while :  * Perform scheduler related setup for a newly forked process p. : 
2
str :  * p is forked by current.[26]
strstr : INIT :  * p is forked by current. : 
2
strstr : if :  * p is forked by current. : 
2
strstr : for :  * p is forked by current. : 
2
strstr : while :  * p is forked by current. : 
2
str :  * __sched_fork() is basic setup used by init_idle() too:[57]
strstr : INIT :  * __sched_fork() is basic setup used by init_idle() too: : 
2
strstr : if :  * __sched_fork() is basic setup used by init_idle() too: : 
2
strstr : for :  * __sched_fork() is basic setup used by init_idle() too: : 
2
strstr : while :  * __sched_fork() is basic setup used by init_idle() too: : 
2
str :  */[3]
strstr : INIT :  */ : 
2
strstr : if :  */ : 
2
strstr : for :  */ : 
2
strstr : while :  */ : 
2
str : static void __sched_fork(unsigned long clone_flags, struct task_struct *p)[74]
strstr : INIT : static void __sched_fork(unsigned long clone_flags, struct task_struct *p) : 
2
strstr : if : static void __sched_fork(unsigned long clone_flags, struct task_struct *p) : 
2
strstr : for : static void __sched_fork(unsigned long clone_flags, struct task_struct *p) : 
2
strstr : while : static void __sched_fork(unsigned long clone_flags, struct task_struct *p) : 
2
str : 	p->on_rq			= 0;[16]
strstr : INIT : 	p->on_rq			= 0; : 
2
strstr : if : 	p->on_rq			= 0; : 
2
strstr : for : 	p->on_rq			= 0; : 
2
strstr : while : 	p->on_rq			= 0; : 
2
str : 	p->se.on_rq			= 0;[19]
strstr : INIT : 	p->se.on_rq			= 0; : 
2
strstr : if : 	p->se.on_rq			= 0; : 
2
strstr : for : 	p->se.on_rq			= 0; : 
2
strstr : while : 	p->se.on_rq			= 0; : 
2
str : 	p->se.exec_start		= 0;[23]
strstr : INIT : 	p->se.exec_start		= 0; : 
2
strstr : if : 	p->se.exec_start		= 0; : 
2
strstr : for : 	p->se.exec_start		= 0; : 
2
strstr : while : 	p->se.exec_start		= 0; : 
2
str : 	p->se.sum_exec_runtime		= 0;[29]
strstr : INIT : 	p->se.sum_exec_runtime		= 0; : 
2
strstr : if : 	p->se.sum_exec_runtime		= 0; : 
2
strstr : for : 	p->se.sum_exec_runtime		= 0; : 
2
strstr : while : 	p->se.sum_exec_runtime		= 0; : 
2
str : 	p->se.prev_sum_exec_runtime	= 0;[33]
strstr : INIT : 	p->se.prev_sum_exec_runtime	= 0; : 
2
strstr : if : 	p->se.prev_sum_exec_runtime	= 0; : 
2
strstr : for : 	p->se.prev_sum_exec_runtime	= 0; : 
2
strstr : while : 	p->se.prev_sum_exec_runtime	= 0; : 
2
str : 	p->se.nr_migrations		= 0;[26]
strstr : INIT : 	p->se.nr_migrations		= 0; : 
2
strstr : if : 	p->se.nr_migrations		= 0; : 
2
strstr : for : 	p->se.nr_migrations		= 0; : 
2
strstr : while : 	p->se.nr_migrations		= 0; : 
2
str : 	p->se.vruntime			= 0;[22]
strstr : INIT : 	p->se.vruntime			= 0; : 
2
strstr : if : 	p->se.vruntime			= 0; : 
2
strstr : for : 	p->se.vruntime			= 0; : 
2
strstr : while : 	p->se.vruntime			= 0; : 
2
str : 	INIT_LIST_HEAD(&p->se.group_node);[35]
strstr : INIT : 	INIT_LIST_HEAD(&p->se.group_node); : 
2
strstr : if : 	INIT_LIST_HEAD(&p->se.group_node); : 
2
strstr : for : 	INIT_LIST_HEAD(&p->se.group_node); : 
2
strstr : while : 	INIT_LIST_HEAD(&p->se.group_node); : 
2
str : #ifdef CONFIG_SCHEDSTATS[24]
strstr : INIT : #ifdef CONFIG_SCHEDSTATS : 
2
strstr : if : #ifdef CONFIG_SCHEDSTATS : 
2
strstr : for : #ifdef CONFIG_SCHEDSTATS : 
2
strstr : while : #ifdef CONFIG_SCHEDSTATS : 
2
str : 	memset(&p->se.statistics, 0, sizeof(p->se.statistics));[56]
strstr : INIT : 	memset(&p->se.statistics, 0, sizeof(p->se.statistics)); : 
2
strstr : if : 	memset(&p->se.statistics, 0, sizeof(p->se.statistics)); : 
2
strstr : for : 	memset(&p->se.statistics, 0, sizeof(p->se.statistics)); : 
2
strstr : while : 	memset(&p->se.statistics, 0, sizeof(p->se.statistics)); : 
2
str : #endif[6]
strstr : INIT : #endif : 
2
strstr : if : #endif : 
2
strstr : for : #endif : 
2
strstr : while : #endif : 
2
str : 	RB_CLEAR_NODE(&p->dl.rb_node);[31]
strstr : INIT : 	RB_CLEAR_NODE(&p->dl.rb_node); : 
2
strstr : if : 	RB_CLEAR_NODE(&p->dl.rb_node); : 
2
strstr : for : 	RB_CLEAR_NODE(&p->dl.rb_node); : 
2
strstr : while : 	RB_CLEAR_NODE(&p->dl.rb_node); : 
2
str : 	hrtimer_init(&p->dl.dl_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);[66]
strstr : INIT : 	hrtimer_init(&p->dl.dl_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL); : 
2
strstr : if : 	hrtimer_init(&p->dl.dl_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL); : 
2
strstr : for : 	hrtimer_init(&p->dl.dl_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL); : 
2
strstr : while : 	hrtimer_init(&p->dl.dl_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL); : 
2
str : 	p->dl.dl_runtime = p->dl.runtime = 0;[38]
strstr : INIT : 	p->dl.dl_runtime = p->dl.runtime = 0; : 
2
strstr : if : 	p->dl.dl_runtime = p->dl.runtime = 0; : 
2
strstr : for : 	p->dl.dl_runtime = p->dl.runtime = 0; : 
2
strstr : while : 	p->dl.dl_runtime = p->dl.runtime = 0; : 
2
str : 	p->dl.dl_deadline = p->dl.deadline = 0;[40]
strstr : INIT : 	p->dl.dl_deadline = p->dl.deadline = 0; : 
2
strstr : if : 	p->dl.dl_deadline = p->dl.deadline = 0; : 
2
strstr : for : 	p->dl.dl_deadline = p->dl.deadline = 0; : 
2
strstr : while : 	p->dl.dl_deadline = p->dl.deadline = 0; : 
2
str : 	p->dl.dl_period = 0;[21]
strstr : INIT : 	p->dl.dl_period = 0; : 
2
strstr : if : 	p->dl.dl_period = 0; : 
2
strstr : for : 	p->dl.dl_period = 0; : 
2
strstr : while : 	p->dl.dl_period = 0; : 
2
str : 	p->dl.flags = 0;[17]
strstr : INIT : 	p->dl.flags = 0; : 
2
strstr : if : 	p->dl.flags = 0; : 
2
strstr : for : 	p->dl.flags = 0; : 
2
strstr : while : 	p->dl.flags = 0; : 
2
str : 	INIT_LIST_HEAD(&p->rt.run_list);[33]
strstr : INIT : 	INIT_LIST_HEAD(&p->rt.run_list); : 
2
strstr : if : 	INIT_LIST_HEAD(&p->rt.run_list); : 
2
strstr : for : 	INIT_LIST_HEAD(&p->rt.run_list); : 
2
strstr : while : 	INIT_LIST_HEAD(&p->rt.run_list); : 
2
str : #ifdef CONFIG_PREEMPT_NOTIFIERS[31]
strstr : INIT : #ifdef CONFIG_PREEMPT_NOTIFIERS : 
2
strstr : if : #ifdef CONFIG_PREEMPT_NOTIFIERS : 
2
strstr : for : #ifdef CONFIG_PREEMPT_NOTIFIERS : 
2
strstr : while : #ifdef CONFIG_PREEMPT_NOTIFIERS : 
2
str : 	INIT_HLIST_HEAD(&p->preempt_notifiers);[40]
strstr : INIT : 	INIT_HLIST_HEAD(&p->preempt_notifiers); : 
2
strstr : if : 	INIT_HLIST_HEAD(&p->preempt_notifiers); : 
2
strstr : for : 	INIT_HLIST_HEAD(&p->preempt_notifiers); : 
2
strstr : while : 	INIT_HLIST_HEAD(&p->preempt_notifiers); : 
2
str : #endif[6]
strstr : INIT : #endif : 
2
strstr : if : #endif : 
2
strstr : for : #endif : 
2
strstr : while : #endif : 
2
str : #ifdef CONFIG_NUMA_BALANCING[28]
strstr : INIT : #ifdef CONFIG_NUMA_BALANCING : 
2
strstr : if : #ifdef CONFIG_NUMA_BALANCING : 
2
strstr : for : #ifdef CONFIG_NUMA_BALANCING : 
2
strstr : while : #ifdef CONFIG_NUMA_BALANCING : 
2
str : 	if (p->mm && atomic_read(&p->mm->mm_users) == 1) {[51]
strstr : INIT : 	if (p->mm && atomic_read(&p->mm->mm_users) == 1) { : 
2
strstr : if : 	if (p->mm && atomic_read(&p->mm->mm_users) == 1) { : 
2
strstr : for : 	if (p->mm && atomic_read(&p->mm->mm_users) == 1) { : 
2
strstr : while : 	if (p->mm && atomic_read(&p->mm->mm_users) == 1) { : 
2
str : 		p->mm->numa_next_scan = jiffies + msecs_to_jiffies(sysctl_numa_balancing_scan_delay);[87]
strstr : INIT : 		p->mm->numa_next_scan = jiffies + msecs_to_jiffies(sysctl_numa_balancing_scan_delay); : 
2
strstr : if : 		p->mm->numa_next_scan = jiffies + msecs_to_jiffies(sysctl_numa_balancing_scan_delay); : 
2
strstr : for : 		p->mm->numa_next_scan = jiffies + msecs_to_jiffies(sysctl_numa_balancing_scan_delay); : 
2
strstr : while : 		p->mm->numa_next_scan = jiffies + msecs_to_jiffies(sysctl_numa_balancing_scan_delay); : 
2
str : 		p->mm->numa_scan_seq = 0;[27]
strstr : INIT : 		p->mm->numa_scan_seq = 0; : 
2
strstr : if : 		p->mm->numa_scan_seq = 0; : 
2
strstr : for : 		p->mm->numa_scan_seq = 0; : 
2
strstr : while : 		p->mm->numa_scan_seq = 0; : 
2
str : 	if (clone_flags & CLONE_VM)[28]
strstr : INIT : 	if (clone_flags & CLONE_VM) : 
2
strstr : if : 	if (clone_flags & CLONE_VM) : 
2
strstr : for : 	if (clone_flags & CLONE_VM) : 
2
strstr : while : 	if (clone_flags & CLONE_VM) : 
2
str : 		p->numa_preferred_nid = current->numa_preferred_nid;[54]
strstr : INIT : 		p->numa_preferred_nid = current->numa_preferred_nid; : 
2
strstr : if : 		p->numa_preferred_nid = current->numa_preferred_nid; : 
2
strstr : for : 		p->numa_preferred_nid = current->numa_preferred_nid; : 
2
strstr : while : 		p->numa_preferred_nid = current->numa_preferred_nid; : 
2
str : 	else[5]
strstr : INIT : 	else : 
2
strstr : if : 	else : 
2
strstr : for : 	else : 
2
strstr : while : 	else : 
2
str : 		p->numa_preferred_nid = -1;[29]
strstr : INIT : 		p->numa_preferred_nid = -1; : 
2
strstr : if : 		p->numa_preferred_nid = -1; : 
2
strstr : for : 		p->numa_preferred_nid = -1; : 
2
strstr : while : 		p->numa_preferred_nid = -1; : 
2
str : 	p->node_stamp = 0ULL;[22]
strstr : INIT : 	p->node_stamp = 0ULL; : 
2
strstr : if : 	p->node_stamp = 0ULL; : 
2
strstr : for : 	p->node_stamp = 0ULL; : 
2
strstr : while : 	p->node_stamp = 0ULL; : 
2
str : 	p->numa_scan_seq = p->mm ? p->mm->numa_scan_seq : 0;[53]
strstr : INIT : 	p->numa_scan_seq = p->mm ? p->mm->numa_scan_seq : 0; : 
2
strstr : if : 	p->numa_scan_seq = p->mm ? p->mm->numa_scan_seq : 0; : 
2
strstr : for : 	p->numa_scan_seq = p->mm ? p->mm->numa_scan_seq : 0; : 
2
strstr : while : 	p->numa_scan_seq = p->mm ? p->mm->numa_scan_seq : 0; : 
2
str : 	p->numa_scan_period = sysctl_numa_balancing_scan_delay;[56]
strstr : INIT : 	p->numa_scan_period = sysctl_numa_balancing_scan_delay; : 
2
strstr : if : 	p->numa_scan_period = sysctl_numa_balancing_scan_delay; : 
2
strstr : for : 	p->numa_scan_period = sysctl_numa_balancing_scan_delay; : 
2
strstr : while : 	p->numa_scan_period = sysctl_numa_balancing_scan_delay; : 
2
str : 	p->numa_work.next = &p->numa_work;[35]
strstr : INIT : 	p->numa_work.next = &p->numa_work; : 
2
strstr : if : 	p->numa_work.next = &p->numa_work; : 
2
strstr : for : 	p->numa_work.next = &p->numa_work; : 
2
strstr : while : 	p->numa_work.next = &p->numa_work; : 
2
str : 	p->numa_faults = NULL;[23]
strstr : INIT : 	p->numa_faults = NULL; : 
2
strstr : if : 	p->numa_faults = NULL; : 
2
strstr : for : 	p->numa_faults = NULL; : 
2
strstr : while : 	p->numa_faults = NULL; : 
2
str : 	p->numa_faults_buffer = NULL;[30]
strstr : INIT : 	p->numa_faults_buffer = NULL; : 
2
strstr : if : 	p->numa_faults_buffer = NULL; : 
2
strstr : for : 	p->numa_faults_buffer = NULL; : 
2
strstr : while : 	p->numa_faults_buffer = NULL; : 
2
str : 	INIT_LIST_HEAD(&p->numa_entry);[32]
strstr : INIT : 	INIT_LIST_HEAD(&p->numa_entry); : 
2
strstr : if : 	INIT_LIST_HEAD(&p->numa_entry); : 
2
strstr : for : 	INIT_LIST_HEAD(&p->numa_entry); : 
2
strstr : while : 	INIT_LIST_HEAD(&p->numa_entry); : 
2
str : 	p->numa_group = NULL;[22]
strstr : INIT : 	p->numa_group = NULL; : 
2
strstr : if : 	p->numa_group = NULL; : 
2
strstr : for : 	p->numa_group = NULL; : 
2
strstr : while : 	p->numa_group = NULL; : 
2
str : #endif /* CONFIG_NUMA_BALANCING */[34]
strstr : INIT : #endif /* CONFIG_NUMA_BALANCING */ : 
2
strstr : if : #endif /* CONFIG_NUMA_BALANCING */ : 
2
strstr : for : #endif /* CONFIG_NUMA_BALANCING */ : 
2
strstr : while : #endif /* CONFIG_NUMA_BALANCING */ : 
2
str : #ifdef CONFIG_NUMA_BALANCING[28]
strstr : INIT : #ifdef CONFIG_NUMA_BALANCING : 
2
strstr : if : #ifdef CONFIG_NUMA_BALANCING : 
2
strstr : for : #ifdef CONFIG_NUMA_BALANCING : 
2
strstr : while : #ifdef CONFIG_NUMA_BALANCING : 
2
str : #ifdef CONFIG_SCHED_DEBUG[25]
strstr : INIT : #ifdef CONFIG_SCHED_DEBUG : 
2
strstr : if : #ifdef CONFIG_SCHED_DEBUG : 
2
strstr : for : #ifdef CONFIG_SCHED_DEBUG : 
2
strstr : while : #ifdef CONFIG_SCHED_DEBUG : 
2
str : void set_numabalancing_state(bool enabled)[42]
strstr : INIT : void set_numabalancing_state(bool enabled) : 
2
strstr : if : void set_numabalancing_state(bool enabled) : 
2
strstr : for : void set_numabalancing_state(bool enabled) : 
2
strstr : while : void set_numabalancing_state(bool enabled) : 
2
str : 	if (enabled)[13]
strstr : INIT : 	if (enabled) : 
2
strstr : if : 	if (enabled) : 
2
strstr : for : 	if (enabled) : 
2
strstr : while : 	if (enabled) : 
2
str : 		sched_feat_set("NUMA");[25]
strstr : INIT : 		sched_feat_set("NUMA"); : 
2
strstr : if : 		sched_feat_set("NUMA"); : 
2
strstr : for : 		sched_feat_set("NUMA"); : 
2
strstr : while : 		sched_feat_set("NUMA"); : 
2
str : 	else[5]
strstr : INIT : 	else : 
2
strstr : if : 	else : 
2
strstr : for : 	else : 
2
strstr : while : 	else : 
2
str : 		sched_feat_set("NO_NUMA");[28]
strstr : INIT : 		sched_feat_set("NO_NUMA"); : 
2
strstr : if : 		sched_feat_set("NO_NUMA"); : 
2
strstr : for : 		sched_feat_set("NO_NUMA"); : 
2
strstr : while : 		sched_feat_set("NO_NUMA"); : 
2
str : #else[5]
strstr : INIT : #else : 
2
strstr : if : #else : 
2
strstr : for : #else : 
2
strstr : while : #else : 
2
str : __read_mostly bool numabalancing_enabled;[41]
strstr : INIT : __read_mostly bool numabalancing_enabled; : 
2
strstr : if : __read_mostly bool numabalancing_enabled; : 
2
strstr : for : __read_mostly bool numabalancing_enabled; : 
2
strstr : while : __read_mostly bool numabalancing_enabled; : 
2
str : void set_numabalancing_state(bool enabled)[42]
strstr : INIT : void set_numabalancing_state(bool enabled) : 
2
strstr : if : void set_numabalancing_state(bool enabled) : 
2
strstr : for : void set_numabalancing_state(bool enabled) : 
2
strstr : while : void set_numabalancing_state(bool enabled) : 
2
str : 	numabalancing_enabled = enabled;[33]
strstr : INIT : 	numabalancing_enabled = enabled; : 
2
strstr : if : 	numabalancing_enabled = enabled; : 
2
strstr : for : 	numabalancing_enabled = enabled; : 
2
strstr : while : 	numabalancing_enabled = enabled; : 
2
str : #endif /* CONFIG_SCHED_DEBUG */[31]
strstr : INIT : #endif /* CONFIG_SCHED_DEBUG */ : 
2
strstr : if : #endif /* CONFIG_SCHED_DEBUG */ : 
2
strstr : for : #endif /* CONFIG_SCHED_DEBUG */ : 
2
strstr : while : #endif /* CONFIG_SCHED_DEBUG */ : 
2
str : #ifdef CONFIG_PROC_SYSCTL[25]
strstr : INIT : #ifdef CONFIG_PROC_SYSCTL : 
2
strstr : if : #ifdef CONFIG_PROC_SYSCTL : 
2
strstr : for : #ifdef CONFIG_PROC_SYSCTL : 
2
strstr : while : #ifdef CONFIG_PROC_SYSCTL : 
2
str : int sysctl_numa_balancing(struct ctl_table *table, int write,[61]
strstr : INIT : int sysctl_numa_balancing(struct ctl_table *table, int write, : 
2
strstr : if : int sysctl_numa_balancing(struct ctl_table *table, int write, : 
2
strstr : for : int sysctl_numa_balancing(struct ctl_table *table, int write, : 
2
strstr : while : int sysctl_numa_balancing(struct ctl_table *table, int write, : 
2
str : 			 void __user *buffer, size_t *lenp, loff_t *ppos)[52]
strstr : INIT : 			 void __user *buffer, size_t *lenp, loff_t *ppos) : 
2
strstr : if : 			 void __user *buffer, size_t *lenp, loff_t *ppos) : 
2
strstr : for : 			 void __user *buffer, size_t *lenp, loff_t *ppos) : 
2
strstr : while : 			 void __user *buffer, size_t *lenp, loff_t *ppos) : 
2
str : 	struct ctl_table t;[20]
strstr : INIT : 	struct ctl_table t; : 
2
strstr : if : 	struct ctl_table t; : 
2
strstr : for : 	struct ctl_table t; : 
2
strstr : while : 	struct ctl_table t; : 
2
str : 	int err;[9]
strstr : INIT : 	int err; : 
2
strstr : if : 	int err; : 
2
strstr : for : 	int err; : 
2
strstr : while : 	int err; : 
2
str : 	int state = numabalancing_enabled;[35]
strstr : INIT : 	int state = numabalancing_enabled; : 
2
strstr : if : 	int state = numabalancing_enabled; : 
2
strstr : for : 	int state = numabalancing_enabled; : 
2
strstr : while : 	int state = numabalancing_enabled; : 
2
str : 	if (write && !capable(CAP_SYS_ADMIN))[38]
strstr : INIT : 	if (write && !capable(CAP_SYS_ADMIN)) : 
2
strstr : if : 	if (write && !capable(CAP_SYS_ADMIN)) : 
2
strstr : for : 	if (write && !capable(CAP_SYS_ADMIN)) : 
2
strstr : while : 	if (write && !capable(CAP_SYS_ADMIN)) : 
2
str : 		return -EPERM;[16]
strstr : INIT : 		return -EPERM; : 
2
strstr : if : 		return -EPERM; : 
2
strstr : for : 		return -EPERM; : 
2
strstr : while : 		return -EPERM; : 
2
str : 	t = *table;[12]
strstr : INIT : 	t = *table; : 
2
strstr : if : 	t = *table; : 
2
strstr : for : 	t = *table; : 
2
strstr : while : 	t = *table; : 
2
str : 	t.data = &state;[17]
strstr : INIT : 	t.data = &state; : 
2
strstr : if : 	t.data = &state; : 
2
strstr : for : 	t.data = &state; : 
2
strstr : while : 	t.data = &state; : 
2
str : 	err = proc_dointvec_minmax(&t, write, buffer, lenp, ppos);[59]
strstr : INIT : 	err = proc_dointvec_minmax(&t, write, buffer, lenp, ppos); : 
2
strstr : if : 	err = proc_dointvec_minmax(&t, write, buffer, lenp, ppos); : 
2
strstr : for : 	err = proc_dointvec_minmax(&t, write, buffer, lenp, ppos); : 
2
strstr : while : 	err = proc_dointvec_minmax(&t, write, buffer, lenp, ppos); : 
2
str : 	if (err < 0)[13]
strstr : INIT : 	if (err < 0) : 
2
strstr : if : 	if (err < 0) : 
2
strstr : for : 	if (err < 0) : 
2
strstr : while : 	if (err < 0) : 
2
str : 		return err;[13]
strstr : INIT : 		return err; : 
2
strstr : if : 		return err; : 
2
strstr : for : 		return err; : 
2
strstr : while : 		return err; : 
2
str : 	if (write)[11]
strstr : INIT : 	if (write) : 
2
strstr : if : 	if (write) : 
2
strstr : for : 	if (write) : 
2
strstr : while : 	if (write) : 
2
str : 		set_numabalancing_state(state);[33]
strstr : INIT : 		set_numabalancing_state(state); : 
2
strstr : if : 		set_numabalancing_state(state); : 
2
strstr : for : 		set_numabalancing_state(state); : 
2
strstr : while : 		set_numabalancing_state(state); : 
2
str : 	return err;[12]
strstr : INIT : 	return err; : 
2
strstr : if : 	return err; : 
2
strstr : for : 	return err; : 
2
strstr : while : 	return err; : 
2
str : #endif[6]
strstr : INIT : #endif : 
2
strstr : if : #endif : 
2
strstr : for : #endif : 
2
strstr : while : #endif : 
2
str : #endif[6]
strstr : INIT : #endif : 
2
strstr : if : #endif : 
2
strstr : for : #endif : 
2
strstr : while : #endif : 
2
str :  * fork()/clone()-time setup:[29]
strstr : INIT :  * fork()/clone()-time setup: : 
2
strstr : if :  * fork()/clone()-time setup: : 
2
strstr : for :  * fork()/clone()-time setup: : 
2
strstr : while :  * fork()/clone()-time setup: : 
2
str :  */[3]
strstr : INIT :  */ : 
2
strstr : if :  */ : 
2
strstr : for :  */ : 
2
strstr : while :  */ : 
2
str : int sched_fork(unsigned long clone_flags, struct task_struct *p)[64]
strstr : INIT : int sched_fork(unsigned long clone_flags, struct task_struct *p) : 
2
strstr : if : int sched_fork(unsigned long clone_flags, struct task_struct *p) : 
2
strstr : for : int sched_fork(unsigned long clone_flags, struct task_struct *p) : 
2
strstr : while : int sched_fork(unsigned long clone_flags, struct task_struct *p) : 
2
str : 	unsigned long flags;[21]
strstr : INIT : 	unsigned long flags; : 
2
strstr : if : 	unsigned long flags; : 
2
strstr : for : 	unsigned long flags; : 
2
strstr : while : 	unsigned long flags; : 
2
str : 	int cpu = get_cpu();[21]
strstr : INIT : 	int cpu = get_cpu(); : 
2
strstr : if : 	int cpu = get_cpu(); : 
2
strstr : for : 	int cpu = get_cpu(); : 
2
strstr : while : 	int cpu = get_cpu(); : 
2
str : 	__sched_fork(clone_flags, p);[30]
strstr : INIT : 	__sched_fork(clone_flags, p); : 
2
strstr : if : 	__sched_fork(clone_flags, p); : 
2
strstr : for : 	__sched_fork(clone_flags, p); : 
2
strstr : while : 	__sched_fork(clone_flags, p); : 
2
str : 	/*[3]
strstr : INIT : 	/* : 
2
strstr : if : 	/* : 
2
strstr : for : 	/* : 
2
strstr : while : 	/* : 
2
str : 	 * We mark the process as running here. This guarantees that[61]
strstr : INIT : 	 * We mark the process as running here. This guarantees that : 
2
strstr : if : 	 * We mark the process as running here. This guarantees that : 
2
strstr : for : 	 * We mark the process as running here. This guarantees that : 
2
strstr : while : 	 * We mark the process as running here. This guarantees that : 
2
str : 	 * nobody will actually run it, and a signal or other external[63]
strstr : INIT : 	 * nobody will actually run it, and a signal or other external : 
2
strstr : if : 	 * nobody will actually run it, and a signal or other external : 
2
strstr : for : 	 * nobody will actually run it, and a signal or other external : 
2
strstr : while : 	 * nobody will actually run it, and a signal or other external : 
2
str : 	 * event cannot wake it up and insert it on the runqueue either.[65]
strstr : INIT : 	 * event cannot wake it up and insert it on the runqueue either. : 
2
strstr : if : 	 * event cannot wake it up and insert it on the runqueue either. : 
2
strstr : for : 	 * event cannot wake it up and insert it on the runqueue either. : 
2
strstr : while : 	 * event cannot wake it up and insert it on the runqueue either. : 
2
str : 	 */[4]
strstr : INIT : 	 */ : 
2
strstr : if : 	 */ : 
2
strstr : for : 	 */ : 
2
strstr : while : 	 */ : 
2
str : 	p->state = TASK_RUNNING;[25]
strstr : INIT : 	p->state = TASK_RUNNING; : 
2
strstr : if : 	p->state = TASK_RUNNING; : 
2
strstr : for : 	p->state = TASK_RUNNING; : 
2
strstr : while : 	p->state = TASK_RUNNING; : 
2
str : 	/*[3]
strstr : INIT : 	/* : 
2
strstr : if : 	/* : 
2
strstr : for : 	/* : 
2
strstr : while : 	/* : 
2
str : 	 * Make sure we do not leak PI boosting priority to the child.[63]
strstr : INIT : 	 * Make sure we do not leak PI boosting priority to the child. : 
2
strstr : if : 	 * Make sure we do not leak PI boosting priority to the child. : 
2
strstr : for : 	 * Make sure we do not leak PI boosting priority to the child. : 
2
strstr : while : 	 * Make sure we do not leak PI boosting priority to the child. : 
2
str : 	 */[4]
strstr : INIT : 	 */ : 
2
strstr : if : 	 */ : 
2
strstr : for : 	 */ : 
2
strstr : while : 	 */ : 
2
str : 	p->prio = current->normal_prio;[32]
strstr : INIT : 	p->prio = current->normal_prio; : 
2
strstr : if : 	p->prio = current->normal_prio; : 
2
strstr : for : 	p->prio = current->normal_prio; : 
2
strstr : while : 	p->prio = current->normal_prio; : 
2
str : 	/*[3]
strstr : INIT : 	/* : 
2
strstr : if : 	/* : 
2
strstr : for : 	/* : 
2
strstr : while : 	/* : 
2
str : 	 * Revert to default priority/policy on fork if requested.[59]
strstr : INIT : 	 * Revert to default priority/policy on fork if requested. : 
2
strstr : if : 	 * Revert to default priority/policy on fork if requested. : 
2
strstr : for : 	 * Revert to default priority/policy on fork if requested. : 
2
strstr : while : 	 * Revert to default priority/policy on fork if requested. : 
2
str : 	 */[4]
strstr : INIT : 	 */ : 
2
strstr : if : 	 */ : 
2
strstr : for : 	 */ : 
2
strstr : while : 	 */ : 
2
str : 	if (unlikely(p->sched_reset_on_fork)) {[40]
strstr : INIT : 	if (unlikely(p->sched_reset_on_fork)) { : 
2
strstr : if : 	if (unlikely(p->sched_reset_on_fork)) { : 
2
strstr : for : 	if (unlikely(p->sched_reset_on_fork)) { : 
2
strstr : while : 	if (unlikely(p->sched_reset_on_fork)) { : 
2
str : 		if (task_has_dl_policy(p) || task_has_rt_policy(p)) {[55]
strstr : INIT : 		if (task_has_dl_policy(p) || task_has_rt_policy(p)) { : 
2
strstr : if : 		if (task_has_dl_policy(p) || task_has_rt_policy(p)) { : 
2
strstr : for : 		if (task_has_dl_policy(p) || task_has_rt_policy(p)) { : 
2
strstr : while : 		if (task_has_dl_policy(p) || task_has_rt_policy(p)) { : 
2
str : 			p->policy = SCHED_NORMAL;[28]
strstr : INIT : 			p->policy = SCHED_NORMAL; : 
2
strstr : if : 			p->policy = SCHED_NORMAL; : 
2
strstr : for : 			p->policy = SCHED_NORMAL; : 
2
strstr : while : 			p->policy = SCHED_NORMAL; : 
2
str : 			p->static_prio = NICE_TO_PRIO(0);[36]
strstr : INIT : 			p->static_prio = NICE_TO_PRIO(0); : 
2
strstr : if : 			p->static_prio = NICE_TO_PRIO(0); : 
2
strstr : for : 			p->static_prio = NICE_TO_PRIO(0); : 
2
strstr : while : 			p->static_prio = NICE_TO_PRIO(0); : 
2
str : 			p->rt_priority = 0;[22]
strstr : INIT : 			p->rt_priority = 0; : 
2
strstr : if : 			p->rt_priority = 0; : 
2
strstr : for : 			p->rt_priority = 0; : 
2
strstr : while : 			p->rt_priority = 0; : 
2
str : 		} else if (PRIO_TO_NICE(p->static_prio) < 0)[46]
strstr : INIT : 		} else if (PRIO_TO_NICE(p->static_prio) < 0) : 
2
strstr : if : 		} else if (PRIO_TO_NICE(p->static_prio) < 0) : 
2
strstr : for : 		} else if (PRIO_TO_NICE(p->static_prio) < 0) : 
2
strstr : while : 		} else if (PRIO_TO_NICE(p->static_prio) < 0) : 
2
str : 			p->static_prio = NICE_TO_PRIO(0);[36]
strstr : INIT : 			p->static_prio = NICE_TO_PRIO(0); : 
2
strstr : if : 			p->static_prio = NICE_TO_PRIO(0); : 
2
strstr : for : 			p->static_prio = NICE_TO_PRIO(0); : 
2
strstr : while : 			p->static_prio = NICE_TO_PRIO(0); : 
2
str : 		p->prio = p->normal_prio = __normal_prio(p);[46]
strstr : INIT : 		p->prio = p->normal_prio = __normal_prio(p); : 
2
strstr : if : 		p->prio = p->normal_prio = __normal_prio(p); : 
2
strstr : for : 		p->prio = p->normal_prio = __normal_prio(p); : 
2
strstr : while : 		p->prio = p->normal_prio = __normal_prio(p); : 
2
str : 		set_load_weight(p);[21]
strstr : INIT : 		set_load_weight(p); : 
2
strstr : if : 		set_load_weight(p); : 
2
strstr : for : 		set_load_weight(p); : 
2
strstr : while : 		set_load_weight(p); : 
2
str : 		/*[4]
strstr : INIT : 		/* : 
2
strstr : if : 		/* : 
2
strstr : for : 		/* : 
2
strstr : while : 		/* : 
2
str : 		 * We don't need the reset flag anymore after the fork. It has[64]
strstr : INIT : 		 * We don't need the reset flag anymore after the fork. It has : 
2
strstr : if : 		 * We don't need the reset flag anymore after the fork. It has : 
2
strstr : for : 		 * We don't need the reset flag anymore after the fork. It has : 
2
strstr : while : 		 * We don't need the reset flag anymore after the fork. It has : 
2
str : 		 * fulfilled its duty:[24]
strstr : INIT : 		 * fulfilled its duty: : 
2
strstr : if : 		 * fulfilled its duty: : 
2
strstr : for : 		 * fulfilled its duty: : 
2
strstr : while : 		 * fulfilled its duty: : 
2
str : 		 */[5]
strstr : INIT : 		 */ : 
2
strstr : if : 		 */ : 
2
strstr : for : 		 */ : 
2
strstr : while : 		 */ : 
2
str : 		p->sched_reset_on_fork = 0;[29]
strstr : INIT : 		p->sched_reset_on_fork = 0; : 
2
strstr : if : 		p->sched_reset_on_fork = 0; : 
2
strstr : for : 		p->sched_reset_on_fork = 0; : 
2
strstr : while : 		p->sched_reset_on_fork = 0; : 
2
str : 	if (dl_prio(p->prio)) {[24]
strstr : INIT : 	if (dl_prio(p->prio)) { : 
2
strstr : if : 	if (dl_prio(p->prio)) { : 
2
strstr : for : 	if (dl_prio(p->prio)) { : 
2
strstr : while : 	if (dl_prio(p->prio)) { : 
2
str : 		put_cpu();[12]
strstr : INIT : 		put_cpu(); : 
2
strstr : if : 		put_cpu(); : 
2
strstr : for : 		put_cpu(); : 
2
strstr : while : 		put_cpu(); : 
2
str : 		return -EAGAIN;[17]
strstr : INIT : 		return -EAGAIN; : 
2
strstr : if : 		return -EAGAIN; : 
2
strstr : for : 		return -EAGAIN; : 
2
strstr : while : 		return -EAGAIN; : 
2
str : 	} else if (rt_prio(p->prio)) {[31]
strstr : INIT : 	} else if (rt_prio(p->prio)) { : 
2
strstr : if : 	} else if (rt_prio(p->prio)) { : 
2
strstr : for : 	} else if (rt_prio(p->prio)) { : 
2
strstr : while : 	} else if (rt_prio(p->prio)) { : 
2
str : 		p->sched_class = &rt_sched_class;[35]
strstr : INIT : 		p->sched_class = &rt_sched_class; : 
2
strstr : if : 		p->sched_class = &rt_sched_class; : 
2
strstr : for : 		p->sched_class = &rt_sched_class; : 
2
strstr : while : 		p->sched_class = &rt_sched_class; : 
2
str : 	} else {[9]
strstr : INIT : 	} else { : 
2
strstr : if : 	} else { : 
2
strstr : for : 	} else { : 
2
strstr : while : 	} else { : 
2
str : 		p->sched_class = &fair_sched_class;[37]
strstr : INIT : 		p->sched_class = &fair_sched_class; : 
2
strstr : if : 		p->sched_class = &fair_sched_class; : 
2
strstr : for : 		p->sched_class = &fair_sched_class; : 
2
strstr : while : 		p->sched_class = &fair_sched_class; : 
2
str : 	if (p->sched_class->task_fork)[31]
strstr : INIT : 	if (p->sched_class->task_fork) : 
2
strstr : if : 	if (p->sched_class->task_fork) : 
2
strstr : for : 	if (p->sched_class->task_fork) : 
2
strstr : while : 	if (p->sched_class->task_fork) : 
2
str : 		p->sched_class->task_fork(p);[31]
strstr : INIT : 		p->sched_class->task_fork(p); : 
2
strstr : if : 		p->sched_class->task_fork(p); : 
2
strstr : for : 		p->sched_class->task_fork(p); : 
2
strstr : while : 		p->sched_class->task_fork(p); : 
2
str : 	/*[3]
strstr : INIT : 	/* : 
2
strstr : if : 	/* : 
2
strstr : for : 	/* : 
2
strstr : while : 	/* : 
2
str : 	 * The child is not yet in the pid-hash so no cgroup attach races,[67]
strstr : INIT : 	 * The child is not yet in the pid-hash so no cgroup attach races, : 
2
strstr : if : 	 * The child is not yet in the pid-hash so no cgroup attach races, : 
2
strstr : for : 	 * The child is not yet in the pid-hash so no cgroup attach races, : 
2
strstr : while : 	 * The child is not yet in the pid-hash so no cgroup attach races, : 
2
str : 	 * and the cgroup is pinned to this child due to cgroup_fork()[63]
strstr : INIT : 	 * and the cgroup is pinned to this child due to cgroup_fork() : 
2
strstr : if : 	 * and the cgroup is pinned to this child due to cgroup_fork() : 
2
strstr : for : 	 * and the cgroup is pinned to this child due to cgroup_fork() : 
2
strstr : while : 	 * and the cgroup is pinned to this child due to cgroup_fork() : 
2
str : 	 * is ran before sched_fork().[31]
strstr : INIT : 	 * is ran before sched_fork(). : 
2
strstr : if : 	 * is ran before sched_fork(). : 
2
strstr : for : 	 * is ran before sched_fork(). : 
2
strstr : while : 	 * is ran before sched_fork(). : 
2
str : 	 *[3]
strstr : INIT : 	 * : 
2
strstr : if : 	 * : 
2
strstr : for : 	 * : 
2
strstr : while : 	 * : 
2
str : 	 * Silence PROVE_RCU.[22]
strstr : INIT : 	 * Silence PROVE_RCU. : 
2
strstr : if : 	 * Silence PROVE_RCU. : 
2
strstr : for : 	 * Silence PROVE_RCU. : 
2
strstr : while : 	 * Silence PROVE_RCU. : 
2
str : 	 */[4]
strstr : INIT : 	 */ : 
2
strstr : if : 	 */ : 
2
strstr : for : 	 */ : 
2
strstr : while : 	 */ : 
2
str : 	raw_spin_lock_irqsave(&p->pi_lock, flags);[43]
strstr : INIT : 	raw_spin_lock_irqsave(&p->pi_lock, flags); : 
2
strstr : if : 	raw_spin_lock_irqsave(&p->pi_lock, flags); : 
2
strstr : for : 	raw_spin_lock_irqsave(&p->pi_lock, flags); : 
2
strstr : while : 	raw_spin_lock_irqsave(&p->pi_lock, flags); : 
2
str : 	set_task_cpu(p, cpu);[22]
strstr : INIT : 	set_task_cpu(p, cpu); : 
2
strstr : if : 	set_task_cpu(p, cpu); : 
2
strstr : for : 	set_task_cpu(p, cpu); : 
2
strstr : while : 	set_task_cpu(p, cpu); : 
2
str : 	raw_spin_unlock_irqrestore(&p->pi_lock, flags);[48]
strstr : INIT : 	raw_spin_unlock_irqrestore(&p->pi_lock, flags); : 
2
strstr : if : 	raw_spin_unlock_irqrestore(&p->pi_lock, flags); : 
2
strstr : for : 	raw_spin_unlock_irqrestore(&p->pi_lock, flags); : 
2
strstr : while : 	raw_spin_unlock_irqrestore(&p->pi_lock, flags); : 
2
str : #if defined(CONFIG_SCHEDSTATS) || defined(CONFIG_TASK_DELAY_ACCT)[65]
strstr : INIT : #if defined(CONFIG_SCHEDSTATS) || defined(CONFIG_TASK_DELAY_ACCT) : 
2
strstr : if : #if defined(CONFIG_SCHEDSTATS) || defined(CONFIG_TASK_DELAY_ACCT) : 
2
strstr : for : #if defined(CONFIG_SCHEDSTATS) || defined(CONFIG_TASK_DELAY_ACCT) : 
2
strstr : while : #if defined(CONFIG_SCHEDSTATS) || defined(CONFIG_TASK_DELAY_ACCT) : 
2
str : 	if (likely(sched_info_on()))[29]
strstr : INIT : 	if (likely(sched_info_on())) : 
2
strstr : if : 	if (likely(sched_info_on())) : 
2
strstr : for : 	if (likely(sched_info_on())) : 
2
strstr : while : 	if (likely(sched_info_on())) : 
2
str : 		memset(&p->sched_info, 0, sizeof(p->sched_info));[51]
strstr : INIT : 		memset(&p->sched_info, 0, sizeof(p->sched_info)); : 
2
strstr : if : 		memset(&p->sched_info, 0, sizeof(p->sched_info)); : 
2
strstr : for : 		memset(&p->sched_info, 0, sizeof(p->sched_info)); : 
2
strstr : while : 		memset(&p->sched_info, 0, sizeof(p->sched_info)); : 
2
str : #endif[6]
strstr : INIT : #endif : 
2
strstr : if : #endif : 
2
strstr : for : #endif : 
2
strstr : while : #endif : 
2
str : #if defined(CONFIG_SMP)[23]
strstr : INIT : #if defined(CONFIG_SMP) : 
2
strstr : if : #if defined(CONFIG_SMP) : 
2
strstr : for : #if defined(CONFIG_SMP) : 
2
strstr : while : #if defined(CONFIG_SMP) : 
2
str : 	p->on_cpu = 0;[15]
strstr : INIT : 	p->on_cpu = 0; : 
2
strstr : if : 	p->on_cpu = 0; : 
2
strstr : for : 	p->on_cpu = 0; : 
2
strstr : while : 	p->on_cpu = 0; : 
2
str : #endif[6]
strstr : INIT : #endif : 
2
strstr : if : #endif : 
2
strstr : for : #endif : 
2
strstr : while : #endif : 
2
str : 	init_task_preempt_count(p);[28]
strstr : INIT : 	init_task_preempt_count(p); : 
2
strstr : if : 	init_task_preempt_count(p); : 
2
strstr : for : 	init_task_preempt_count(p); : 
2
strstr : while : 	init_task_preempt_count(p); : 
2
str : #ifdef CONFIG_SMP[17]
strstr : INIT : #ifdef CONFIG_SMP : 
2
strstr : if : #ifdef CONFIG_SMP : 
2
strstr : for : #ifdef CONFIG_SMP : 
2
strstr : while : #ifdef CONFIG_SMP : 
2
str : 	plist_node_init(&p->pushable_tasks, MAX_PRIO);[47]
strstr : INIT : 	plist_node_init(&p->pushable_tasks, MAX_PRIO); : 
2
strstr : if : 	plist_node_init(&p->pushable_tasks, MAX_PRIO); : 
2
strstr : for : 	plist_node_init(&p->pushable_tasks, MAX_PRIO); : 
2
strstr : while : 	plist_node_init(&p->pushable_tasks, MAX_PRIO); : 
2
str : 	RB_CLEAR_NODE(&p->pushable_dl_tasks);[38]
strstr : INIT : 	RB_CLEAR_NODE(&p->pushable_dl_tasks); : 
2
strstr : if : 	RB_CLEAR_NODE(&p->pushable_dl_tasks); : 
2
strstr : for : 	RB_CLEAR_NODE(&p->pushable_dl_tasks); : 
2
strstr : while : 	RB_CLEAR_NODE(&p->pushable_dl_tasks); : 
2
str : #endif[6]
strstr : INIT : #endif : 
2
strstr : if : #endif : 
2
strstr : for : #endif : 
2
strstr : while : #endif : 
2
str : 	put_cpu();[11]
strstr : INIT : 	put_cpu(); : 
2
strstr : if : 	put_cpu(); : 
2
strstr : for : 	put_cpu(); : 
2
strstr : while : 	put_cpu(); : 
2
str : 	return 0;[10]
strstr : INIT : 	return 0; : 
2
strstr : if : 	return 0; : 
2
strstr : for : 	return 0; : 
2
strstr : while : 	return 0; : 
2
str : unsigned long to_ratio(u64 period, u64 runtime)[47]
strstr : INIT : unsigned long to_ratio(u64 period, u64 runtime) : 
2
strstr : if : unsigned long to_ratio(u64 period, u64 runtime) : 
2
strstr : for : unsigned long to_ratio(u64 period, u64 runtime) : 
2
strstr : while : unsigned long to_ratio(u64 period, u64 runtime) : 
2
str : 	if (runtime == RUNTIME_INF)[28]
strstr : INIT : 	if (runtime == RUNTIME_INF) : 
2
strstr : if : 	if (runtime == RUNTIME_INF) : 
2
strstr : for : 	if (runtime == RUNTIME_INF) : 
2
strstr : while : 	if (runtime == RUNTIME_INF) : 
2
str : 		return 1ULL << 20;[20]
strstr : INIT : 		return 1ULL << 20; : 
2
strstr : if : 		return 1ULL << 20; : 
2
strstr : for : 		return 1ULL << 20; : 
2
strstr : while : 		return 1ULL << 20; : 
2
str : 	/*[3]
strstr : INIT : 	/* : 
2
strstr : if : 	/* : 
2
strstr : for : 	/* : 
2
strstr : while : 	/* : 
2
str : 	 * Doing this here saves a lot of checks in all[48]
strstr : INIT : 	 * Doing this here saves a lot of checks in all : 
2
strstr : if : 	 * Doing this here saves a lot of checks in all : 
2
strstr : for : 	 * Doing this here saves a lot of checks in all : 
2
strstr : while : 	 * Doing this here saves a lot of checks in all : 
2
str : 	 * the calling paths, and returning zero seems[47]
strstr : INIT : 	 * the calling paths, and returning zero seems : 
2
strstr : if : 	 * the calling paths, and returning zero seems : 
2
strstr : for : 	 * the calling paths, and returning zero seems : 
2
strstr : while : 	 * the calling paths, and returning zero seems : 
2
str : 	 * safe for them anyway.[25]
strstr : INIT : 	 * safe for them anyway. : 
2
strstr : if : 	 * safe for them anyway. : 
2
strstr : for : 	 * safe for them anyway. : 
2
strstr : while : 	 * safe for them anyway. : 
2
str : 	 */[4]
strstr : INIT : 	 */ : 
2
strstr : if : 	 */ : 
2
strstr : for : 	 */ : 
2
strstr : while : 	 */ : 
2
str : 	if (period == 0)[17]
strstr : INIT : 	if (period == 0) : 
2
strstr : if : 	if (period == 0) : 
2
strstr : for : 	if (period == 0) : 
2
strstr : while : 	if (period == 0) : 
2
str : 		return 0;[11]
strstr : INIT : 		return 0; : 
2
strstr : if : 		return 0; : 
2
strstr : for : 		return 0; : 
2
strstr : while : 		return 0; : 
2
str : 	return div64_u64(runtime << 20, period);[41]
strstr : INIT : 	return div64_u64(runtime << 20, period); : 
2
strstr : if : 	return div64_u64(runtime << 20, period); : 
2
strstr : for : 	return div64_u64(runtime << 20, period); : 
2
strstr : while : 	return div64_u64(runtime << 20, period); : 
2
str : #ifdef CONFIG_SMP[17]
strstr : INIT : #ifdef CONFIG_SMP : 
2
strstr : if : #ifdef CONFIG_SMP : 
2
strstr : for : #ifdef CONFIG_SMP : 
2
strstr : while : #ifdef CONFIG_SMP : 
2
str : inline struct dl_bw *dl_bw_of(int i)[36]
strstr : INIT : inline struct dl_bw *dl_bw_of(int i) : 
2
strstr : if : inline struct dl_bw *dl_bw_of(int i) : 
2
strstr : for : inline struct dl_bw *dl_bw_of(int i) : 
2
strstr : while : inline struct dl_bw *dl_bw_of(int i) : 
2
str : 	return &cpu_rq(i)->rd->dl_bw;[30]
strstr : INIT : 	return &cpu_rq(i)->rd->dl_bw; : 
2
strstr : if : 	return &cpu_rq(i)->rd->dl_bw; : 
2
strstr : for : 	return &cpu_rq(i)->rd->dl_bw; : 
2
strstr : while : 	return &cpu_rq(i)->rd->dl_bw; : 
2
str : static inline int dl_bw_cpus(int i)[35]
strstr : INIT : static inline int dl_bw_cpus(int i) : 
2
strstr : if : static inline int dl_bw_cpus(int i) : 
2
strstr : for : static inline int dl_bw_cpus(int i) : 
2
strstr : while : static inline int dl_bw_cpus(int i) : 
2
str : 	struct root_domain *rd = cpu_rq(i)->rd;[40]
strstr : INIT : 	struct root_domain *rd = cpu_rq(i)->rd; : 
2
strstr : if : 	struct root_domain *rd = cpu_rq(i)->rd; : 
2
strstr : for : 	struct root_domain *rd = cpu_rq(i)->rd; : 
2
strstr : while : 	struct root_domain *rd = cpu_rq(i)->rd; : 
2
str : 	int cpus = 0;[14]
strstr : INIT : 	int cpus = 0; : 
2
strstr : if : 	int cpus = 0; : 
2
strstr : for : 	int cpus = 0; : 
2
strstr : while : 	int cpus = 0; : 
2
str : 	for_each_cpu_and(i, rd->span, cpu_active_mask)[47]
strstr : INIT : 	for_each_cpu_and(i, rd->span, cpu_active_mask) : 
2
strstr : if : 	for_each_cpu_and(i, rd->span, cpu_active_mask) : 
2
strstr : for : 	for_each_cpu_and(i, rd->span, cpu_active_mask) : 
2
strstr : while : 	for_each_cpu_and(i, rd->span, cpu_active_mask) : 
2
str : 		cpus++;[9]
strstr : INIT : 		cpus++; : 
2
strstr : if : 		cpus++; : 
2
strstr : for : 		cpus++; : 
2
strstr : while : 		cpus++; : 
2
str : 	return cpus;[13]
strstr : INIT : 	return cpus; : 
2
strstr : if : 	return cpus; : 
2
strstr : for : 	return cpus; : 
2
strstr : while : 	return cpus; : 
2
str : #else[5]
strstr : INIT : #else : 
2
strstr : if : #else : 
2
strstr : for : #else : 
2
strstr : while : #else : 
2
str : inline struct dl_bw *dl_bw_of(int i)[36]
strstr : INIT : inline struct dl_bw *dl_bw_of(int i) : 
2
strstr : if : inline struct dl_bw *dl_bw_of(int i) : 
2
strstr : for : inline struct dl_bw *dl_bw_of(int i) : 
2
strstr : while : inline struct dl_bw *dl_bw_of(int i) : 
2
str : 	return &cpu_rq(i)->dl.dl_bw;[29]
strstr : INIT : 	return &cpu_rq(i)->dl.dl_bw; : 
2
strstr : if : 	return &cpu_rq(i)->dl.dl_bw; : 
2
strstr : for : 	return &cpu_rq(i)->dl.dl_bw; : 
2
strstr : while : 	return &cpu_rq(i)->dl.dl_bw; : 
2
str : static inline int dl_bw_cpus(int i)[35]
strstr : INIT : static inline int dl_bw_cpus(int i) : 
2
strstr : if : static inline int dl_bw_cpus(int i) : 
2
strstr : for : static inline int dl_bw_cpus(int i) : 
2
strstr : while : static inline int dl_bw_cpus(int i) : 
2
str : 	return 1;[10]
strstr : INIT : 	return 1; : 
2
strstr : if : 	return 1; : 
2
strstr : for : 	return 1; : 
2
strstr : while : 	return 1; : 
2
str : #endif[6]
strstr : INIT : #endif : 
2
strstr : if : #endif : 
2
strstr : for : #endif : 
2
strstr : while : #endif : 
2
str : static inline[13]
strstr : INIT : static inline : 
2
strstr : if : static inline : 
2
strstr : for : static inline : 
2
strstr : while : static inline : 
2
str : void __dl_clear(struct dl_bw *dl_b, u64 tsk_bw)[47]
strstr : INIT : void __dl_clear(struct dl_bw *dl_b, u64 tsk_bw) : 
2
strstr : if : void __dl_clear(struct dl_bw *dl_b, u64 tsk_bw) : 
2
strstr : for : void __dl_clear(struct dl_bw *dl_b, u64 tsk_bw) : 
2
strstr : while : void __dl_clear(struct dl_bw *dl_b, u64 tsk_bw) : 
2
str : 	dl_b->total_bw -= tsk_bw;[26]
strstr : INIT : 	dl_b->total_bw -= tsk_bw; : 
2
strstr : if : 	dl_b->total_bw -= tsk_bw; : 
2
strstr : for : 	dl_b->total_bw -= tsk_bw; : 
2
strstr : while : 	dl_b->total_bw -= tsk_bw; : 
2
str : static inline[13]
strstr : INIT : static inline : 
2
strstr : if : static inline : 
2
strstr : for : static inline : 
2
strstr : while : static inline : 
2
str : void __dl_add(struct dl_bw *dl_b, u64 tsk_bw)[45]
strstr : INIT : void __dl_add(struct dl_bw *dl_b, u64 tsk_bw) : 
2
strstr : if : void __dl_add(struct dl_bw *dl_b, u64 tsk_bw) : 
2
strstr : for : void __dl_add(struct dl_bw *dl_b, u64 tsk_bw) : 
2
strstr : while : void __dl_add(struct dl_bw *dl_b, u64 tsk_bw) : 
2
str : 	dl_b->total_bw += tsk_bw;[26]
strstr : INIT : 	dl_b->total_bw += tsk_bw; : 
2
strstr : if : 	dl_b->total_bw += tsk_bw; : 
2
strstr : for : 	dl_b->total_bw += tsk_bw; : 
2
strstr : while : 	dl_b->total_bw += tsk_bw; : 
2
str : static inline[13]
strstr : INIT : static inline : 
2
strstr : if : static inline : 
2
strstr : for : static inline : 
2
strstr : while : static inline : 
2
str : bool __dl_overflow(struct dl_bw *dl_b, int cpus, u64 old_bw, u64 new_bw)[72]
strstr : INIT : bool __dl_overflow(struct dl_bw *dl_b, int cpus, u64 old_bw, u64 new_bw) : 
2
strstr : if : bool __dl_overflow(struct dl_bw *dl_b, int cpus, u64 old_bw, u64 new_bw) : 
2
strstr : for : bool __dl_overflow(struct dl_bw *dl_b, int cpus, u64 old_bw, u64 new_bw) : 
2
strstr : while : bool __dl_overflow(struct dl_bw *dl_b, int cpus, u64 old_bw, u64 new_bw) : 
2
str : 	return dl_b->bw != -1 &&[25]
strstr : INIT : 	return dl_b->bw != -1 && : 
2
strstr : if : 	return dl_b->bw != -1 && : 
2
strstr : for : 	return dl_b->bw != -1 && : 
2
strstr : while : 	return dl_b->bw != -1 && : 
2
str : 	       dl_b->bw * cpus < dl_b->total_bw - old_bw + new_bw;[59]
strstr : INIT : 	       dl_b->bw * cpus < dl_b->total_bw - old_bw + new_bw; : 
2
strstr : if : 	       dl_b->bw * cpus < dl_b->total_bw - old_bw + new_bw; : 
2
strstr : for : 	       dl_b->bw * cpus < dl_b->total_bw - old_bw + new_bw; : 
2
strstr : while : 	       dl_b->bw * cpus < dl_b->total_bw - old_bw + new_bw; : 
2
str :  * We must be sure that accepting a new task (or allowing changing the[70]
strstr : INIT :  * We must be sure that accepting a new task (or allowing changing the : 
2
strstr : if :  * We must be sure that accepting a new task (or allowing changing the : 
2
strstr : for :  * We must be sure that accepting a new task (or allowing changing the : 
2
strstr : while :  * We must be sure that accepting a new task (or allowing changing the : 
2
str :  * parameters of an existing one) is consistent with the bandwidth[66]
strstr : INIT :  * parameters of an existing one) is consistent with the bandwidth : 
2
strstr : if :  * parameters of an existing one) is consistent with the bandwidth : 
2
strstr : for :  * parameters of an existing one) is consistent with the bandwidth : 
2
strstr : while :  * parameters of an existing one) is consistent with the bandwidth : 
2
str :  * constraints. If yes, this function also accordingly updates the currently[76]
strstr : INIT :  * constraints. If yes, this function also accordingly updates the currently : 
2
strstr : if :  * constraints. If yes, this function also accordingly updates the currently : 
2
strstr : for :  * constraints. If yes, this function also accordingly updates the currently : 
2
strstr : while :  * constraints. If yes, this function also accordingly updates the currently : 
2
str :  * allocated bandwidth to reflect the new situation.[52]
strstr : INIT :  * allocated bandwidth to reflect the new situation. : 
2
strstr : if :  * allocated bandwidth to reflect the new situation. : 
2
strstr : for :  * allocated bandwidth to reflect the new situation. : 
2
strstr : while :  * allocated bandwidth to reflect the new situation. : 
2
str :  * This function is called while holding p's rq->lock.[54]
strstr : INIT :  * This function is called while holding p's rq->lock. : 
2
strstr : if :  * This function is called while holding p's rq->lock. : 
2
strstr : for :  * This function is called while holding p's rq->lock. : 
2
strstr : while :  * This function is called while holding p's rq->lock. : 
2
str :  */[3]
strstr : INIT :  */ : 
2
strstr : if :  */ : 
2
strstr : for :  */ : 
2
strstr : while :  */ : 
2
str : static int dl_overflow(struct task_struct *p, int policy,[57]
strstr : INIT : static int dl_overflow(struct task_struct *p, int policy, : 
2
strstr : if : static int dl_overflow(struct task_struct *p, int policy, : 
2
strstr : for : static int dl_overflow(struct task_struct *p, int policy, : 
2
strstr : while : static int dl_overflow(struct task_struct *p, int policy, : 
2
str : 		       const struct sched_attr *attr)[39]
strstr : INIT : 		       const struct sched_attr *attr) : 
2
strstr : if : 		       const struct sched_attr *attr) : 
2
strstr : for : 		       const struct sched_attr *attr) : 
2
strstr : while : 		       const struct sched_attr *attr) : 
2
str : 	struct dl_bw *dl_b = dl_bw_of(task_cpu(p));[44]
strstr : INIT : 	struct dl_bw *dl_b = dl_bw_of(task_cpu(p)); : 
2
strstr : if : 	struct dl_bw *dl_b = dl_bw_of(task_cpu(p)); : 
2
strstr : for : 	struct dl_bw *dl_b = dl_bw_of(task_cpu(p)); : 
2
strstr : while : 	struct dl_bw *dl_b = dl_bw_of(task_cpu(p)); : 
2
str : 	u64 period = attr->sched_period ?: attr->sched_deadline;[57]
strstr : INIT : 	u64 period = attr->sched_period ?: attr->sched_deadline; : 
2
strstr : if : 	u64 period = attr->sched_period ?: attr->sched_deadline; : 
2
strstr : for : 	u64 period = attr->sched_period ?: attr->sched_deadline; : 
2
strstr : while : 	u64 period = attr->sched_period ?: attr->sched_deadline; : 
2
str : 	u64 runtime = attr->sched_runtime;[35]
strstr : INIT : 	u64 runtime = attr->sched_runtime; : 
2
strstr : if : 	u64 runtime = attr->sched_runtime; : 
2
strstr : for : 	u64 runtime = attr->sched_runtime; : 
2
strstr : while : 	u64 runtime = attr->sched_runtime; : 
2
str : 	u64 new_bw = dl_policy(policy) ? to_ratio(period, runtime) : 0;[64]
strstr : INIT : 	u64 new_bw = dl_policy(policy) ? to_ratio(period, runtime) : 0; : 
2
strstr : if : 	u64 new_bw = dl_policy(policy) ? to_ratio(period, runtime) : 0; : 
2
strstr : for : 	u64 new_bw = dl_policy(policy) ? to_ratio(period, runtime) : 0; : 
2
strstr : while : 	u64 new_bw = dl_policy(policy) ? to_ratio(period, runtime) : 0; : 
2
str : 	int cpus, err = -1;[20]
strstr : INIT : 	int cpus, err = -1; : 
2
strstr : if : 	int cpus, err = -1; : 
2
strstr : for : 	int cpus, err = -1; : 
2
strstr : while : 	int cpus, err = -1; : 
2
str : 	if (new_bw == p->dl.dl_bw)[27]
strstr : INIT : 	if (new_bw == p->dl.dl_bw) : 
2
strstr : if : 	if (new_bw == p->dl.dl_bw) : 
2
strstr : for : 	if (new_bw == p->dl.dl_bw) : 
2
strstr : while : 	if (new_bw == p->dl.dl_bw) : 
2
str : 		return 0;[11]
strstr : INIT : 		return 0; : 
2
strstr : if : 		return 0; : 
2
strstr : for : 		return 0; : 
2
strstr : while : 		return 0; : 
2
str : 	/*[3]
strstr : INIT : 	/* : 
2
strstr : if : 	/* : 
2
strstr : for : 	/* : 
2
strstr : while : 	/* : 
2
str : 	 * Either if a task, enters, leave, or stays -deadline but changes[67]
strstr : INIT : 	 * Either if a task, enters, leave, or stays -deadline but changes : 
2
strstr : if : 	 * Either if a task, enters, leave, or stays -deadline but changes : 
2
strstr : for : 	 * Either if a task, enters, leave, or stays -deadline but changes : 
2
strstr : while : 	 * Either if a task, enters, leave, or stays -deadline but changes : 
2
str : 	 * its parameters, we may need to update accordingly the total[63]
strstr : INIT : 	 * its parameters, we may need to update accordingly the total : 
2
strstr : if : 	 * its parameters, we may need to update accordingly the total : 
2
strstr : for : 	 * its parameters, we may need to update accordingly the total : 
2
strstr : while : 	 * its parameters, we may need to update accordingly the total : 
2
str : 	 * allocated bandwidth of the container.[41]
strstr : INIT : 	 * allocated bandwidth of the container. : 
2
strstr : if : 	 * allocated bandwidth of the container. : 
2
strstr : for : 	 * allocated bandwidth of the container. : 
2
strstr : while : 	 * allocated bandwidth of the container. : 
2
str : 	 */[4]
strstr : INIT : 	 */ : 
2
strstr : if : 	 */ : 
2
strstr : for : 	 */ : 
2
strstr : while : 	 */ : 
2
str : 	raw_spin_lock(&dl_b->lock);[28]
strstr : INIT : 	raw_spin_lock(&dl_b->lock); : 
2
strstr : if : 	raw_spin_lock(&dl_b->lock); : 
2
strstr : for : 	raw_spin_lock(&dl_b->lock); : 
2
strstr : while : 	raw_spin_lock(&dl_b->lock); : 
2
str : 	cpus = dl_bw_cpus(task_cpu(p));[32]
strstr : INIT : 	cpus = dl_bw_cpus(task_cpu(p)); : 
2
strstr : if : 	cpus = dl_bw_cpus(task_cpu(p)); : 
2
strstr : for : 	cpus = dl_bw_cpus(task_cpu(p)); : 
2
strstr : while : 	cpus = dl_bw_cpus(task_cpu(p)); : 
2
str : 	if (dl_policy(policy) && !task_has_dl_policy(p) &&[51]
strstr : INIT : 	if (dl_policy(policy) && !task_has_dl_policy(p) && : 
2
strstr : if : 	if (dl_policy(policy) && !task_has_dl_policy(p) && : 
2
strstr : for : 	if (dl_policy(policy) && !task_has_dl_policy(p) && : 
2
strstr : while : 	if (dl_policy(policy) && !task_has_dl_policy(p) && : 
2
str : 	    !__dl_overflow(dl_b, cpus, 0, new_bw)) {[45]
strstr : INIT : 	    !__dl_overflow(dl_b, cpus, 0, new_bw)) { : 
2
strstr : if : 	    !__dl_overflow(dl_b, cpus, 0, new_bw)) { : 
2
strstr : for : 	    !__dl_overflow(dl_b, cpus, 0, new_bw)) { : 
2
strstr : while : 	    !__dl_overflow(dl_b, cpus, 0, new_bw)) { : 
2
str : 		__dl_add(dl_b, new_bw);[25]
strstr : INIT : 		__dl_add(dl_b, new_bw); : 
2
strstr : if : 		__dl_add(dl_b, new_bw); : 
2
strstr : for : 		__dl_add(dl_b, new_bw); : 
2
strstr : while : 		__dl_add(dl_b, new_bw); : 
2
str : 		err = 0;[10]
strstr : INIT : 		err = 0; : 
2
strstr : if : 		err = 0; : 
2
strstr : for : 		err = 0; : 
2
strstr : while : 		err = 0; : 
2
str : 	} else if (dl_policy(policy) && task_has_dl_policy(p) &&[57]
strstr : INIT : 	} else if (dl_policy(policy) && task_has_dl_policy(p) && : 
2
strstr : if : 	} else if (dl_policy(policy) && task_has_dl_policy(p) && : 
2
strstr : for : 	} else if (dl_policy(policy) && task_has_dl_policy(p) && : 
2
strstr : while : 	} else if (dl_policy(policy) && task_has_dl_policy(p) && : 
2
str : 		   !__dl_overflow(dl_b, cpus, p->dl.dl_bw, new_bw)) {[55]
strstr : INIT : 		   !__dl_overflow(dl_b, cpus, p->dl.dl_bw, new_bw)) { : 
2
strstr : if : 		   !__dl_overflow(dl_b, cpus, p->dl.dl_bw, new_bw)) { : 
2
strstr : for : 		   !__dl_overflow(dl_b, cpus, p->dl.dl_bw, new_bw)) { : 
2
strstr : while : 		   !__dl_overflow(dl_b, cpus, p->dl.dl_bw, new_bw)) { : 
2
str : 		__dl_clear(dl_b, p->dl.dl_bw);[32]
strstr : INIT : 		__dl_clear(dl_b, p->dl.dl_bw); : 
2
strstr : if : 		__dl_clear(dl_b, p->dl.dl_bw); : 
2
strstr : for : 		__dl_clear(dl_b, p->dl.dl_bw); : 
2
strstr : while : 		__dl_clear(dl_b, p->dl.dl_bw); : 
2
str : 		__dl_add(dl_b, new_bw);[25]
strstr : INIT : 		__dl_add(dl_b, new_bw); : 
2
strstr : if : 		__dl_add(dl_b, new_bw); : 
2
strstr : for : 		__dl_add(dl_b, new_bw); : 
2
strstr : while : 		__dl_add(dl_b, new_bw); : 
2
str : 		err = 0;[10]
strstr : INIT : 		err = 0; : 
2
strstr : if : 		err = 0; : 
2
strstr : for : 		err = 0; : 
2
strstr : while : 		err = 0; : 
2
str : 	} else if (!dl_policy(policy) && task_has_dl_policy(p)) {[58]
strstr : INIT : 	} else if (!dl_policy(policy) && task_has_dl_policy(p)) { : 
2
strstr : if : 	} else if (!dl_policy(policy) && task_has_dl_policy(p)) { : 
2
strstr : for : 	} else if (!dl_policy(policy) && task_has_dl_policy(p)) { : 
2
strstr : while : 	} else if (!dl_policy(policy) && task_has_dl_policy(p)) { : 
2
str : 		__dl_clear(dl_b, p->dl.dl_bw);[32]
strstr : INIT : 		__dl_clear(dl_b, p->dl.dl_bw); : 
2
strstr : if : 		__dl_clear(dl_b, p->dl.dl_bw); : 
2
strstr : for : 		__dl_clear(dl_b, p->dl.dl_bw); : 
2
strstr : while : 		__dl_clear(dl_b, p->dl.dl_bw); : 
2
str : 		err = 0;[10]
strstr : INIT : 		err = 0; : 
2
strstr : if : 		err = 0; : 
2
strstr : for : 		err = 0; : 
2
strstr : while : 		err = 0; : 
2
str : 	raw_spin_unlock(&dl_b->lock);[30]
strstr : INIT : 	raw_spin_unlock(&dl_b->lock); : 
2
strstr : if : 	raw_spin_unlock(&dl_b->lock); : 
2
strstr : for : 	raw_spin_unlock(&dl_b->lock); : 
2
strstr : while : 	raw_spin_unlock(&dl_b->lock); : 
2
str : 	return err;[12]
strstr : INIT : 	return err; : 
2
strstr : if : 	return err; : 
2
strstr : for : 	return err; : 
2
strstr : while : 	return err; : 
2
str : extern void init_dl_bw(struct dl_bw *dl_b);[43]
strstr : INIT : extern void init_dl_bw(struct dl_bw *dl_b); : 
2
strstr : if : extern void init_dl_bw(struct dl_bw *dl_b); : 
2
strstr : for : extern void init_dl_bw(struct dl_bw *dl_b); : 
2
strstr : while : extern void init_dl_bw(struct dl_bw *dl_b); : 
2
str :  * wake_up_new_task - wake up a newly created task for the first time.[70]
strstr : INIT :  * wake_up_new_task - wake up a newly created task for the first time. : 
2
strstr : if :  * wake_up_new_task - wake up a newly created task for the first time. : 
2
strstr : for :  * wake_up_new_task - wake up a newly created task for the first time. : 
2
strstr : while :  * wake_up_new_task - wake up a newly created task for the first time. : 
2
str :  * This function will do some initial scheduler statistics housekeeping[71]
strstr : INIT :  * This function will do some initial scheduler statistics housekeeping : 
2
strstr : if :  * This function will do some initial scheduler statistics housekeeping : 
2
strstr : for :  * This function will do some initial scheduler statistics housekeeping : 
2
strstr : while :  * This function will do some initial scheduler statistics housekeeping : 
2
str :  * that must be done for every newly created context, then puts the task[72]
strstr : INIT :  * that must be done for every newly created context, then puts the task : 
2
strstr : if :  * that must be done for every newly created context, then puts the task : 
2
strstr : for :  * that must be done for every newly created context, then puts the task : 
2
strstr : while :  * that must be done for every newly created context, then puts the task : 
2
str :  * on the runqueue and wakes it.[32]
strstr : INIT :  * on the runqueue and wakes it. : 
2
strstr : if :  * on the runqueue and wakes it. : 
2
strstr : for :  * on the runqueue and wakes it. : 
2
strstr : while :  * on the runqueue and wakes it. : 
2
str :  */[3]
strstr : INIT :  */ : 
2
strstr : if :  */ : 
2
strstr : for :  */ : 
2
strstr : while :  */ : 
2
str : void wake_up_new_task(struct task_struct *p)[44]
strstr : INIT : void wake_up_new_task(struct task_struct *p) : 
2
strstr : if : void wake_up_new_task(struct task_struct *p) : 
2
strstr : for : void wake_up_new_task(struct task_struct *p) : 
2
strstr : while : void wake_up_new_task(struct task_struct *p) : 
2
str : 	unsigned long flags;[21]
strstr : INIT : 	unsigned long flags; : 
2
strstr : if : 	unsigned long flags; : 
2
strstr : for : 	unsigned long flags; : 
2
strstr : while : 	unsigned long flags; : 
2
str : 	struct rq *rq;[15]
strstr : INIT : 	struct rq *rq; : 
2
strstr : if : 	struct rq *rq; : 
2
strstr : for : 	struct rq *rq; : 
2
strstr : while : 	struct rq *rq; : 
2
str : 	raw_spin_lock_irqsave(&p->pi_lock, flags);[43]
strstr : INIT : 	raw_spin_lock_irqsave(&p->pi_lock, flags); : 
2
strstr : if : 	raw_spin_lock_irqsave(&p->pi_lock, flags); : 
2
strstr : for : 	raw_spin_lock_irqsave(&p->pi_lock, flags); : 
2
strstr : while : 	raw_spin_lock_irqsave(&p->pi_lock, flags); : 
2
str : #ifdef CONFIG_SMP[17]
strstr : INIT : #ifdef CONFIG_SMP : 
2
strstr : if : #ifdef CONFIG_SMP : 
2
strstr : for : #ifdef CONFIG_SMP : 
2
strstr : while : #ifdef CONFIG_SMP : 
2
str : 	/*[3]
strstr : INIT : 	/* : 
2
strstr : if : 	/* : 
2
strstr : for : 	/* : 
2
strstr : while : 	/* : 
2
str : 	 * Fork balancing, do it here and not earlier because:[55]
strstr : INIT : 	 * Fork balancing, do it here and not earlier because: : 
2
strstr : if : 	 * Fork balancing, do it here and not earlier because: : 
2
strstr : for : 	 * Fork balancing, do it here and not earlier because: : 
2
strstr : while : 	 * Fork balancing, do it here and not earlier because: : 
2
str : 	 *  - cpus_allowed can change in the fork path[47]
strstr : INIT : 	 *  - cpus_allowed can change in the fork path : 
2
strstr : if : 	 *  - cpus_allowed can change in the fork path : 
2
strstr : for : 	 *  - cpus_allowed can change in the fork path : 
2
strstr : while : 	 *  - cpus_allowed can change in the fork path : 
2
str : 	 *  - any previously selected cpu might disappear through hotplug[66]
strstr : INIT : 	 *  - any previously selected cpu might disappear through hotplug : 
2
strstr : if : 	 *  - any previously selected cpu might disappear through hotplug : 
2
strstr : for : 	 *  - any previously selected cpu might disappear through hotplug : 
2
strstr : while : 	 *  - any previously selected cpu might disappear through hotplug : 
2
str : 	 */[4]
strstr : INIT : 	 */ : 
2
strstr : if : 	 */ : 
2
strstr : for : 	 */ : 
2
strstr : while : 	 */ : 
2
str : 	set_task_cpu(p, select_task_rq(p, task_cpu(p), SD_BALANCE_FORK, 0));[69]
strstr : INIT : 	set_task_cpu(p, select_task_rq(p, task_cpu(p), SD_BALANCE_FORK, 0)); : 
2
strstr : if : 	set_task_cpu(p, select_task_rq(p, task_cpu(p), SD_BALANCE_FORK, 0)); : 
2
strstr : for : 	set_task_cpu(p, select_task_rq(p, task_cpu(p), SD_BALANCE_FORK, 0)); : 
2
strstr : while : 	set_task_cpu(p, select_task_rq(p, task_cpu(p), SD_BALANCE_FORK, 0)); : 
2
str : #endif[6]
strstr : INIT : #endif : 
2
strstr : if : #endif : 
2
strstr : for : #endif : 
2
strstr : while : #endif : 
2
str : 	/* Initialize new task's runnable average */[45]
strstr : INIT : 	/* Initialize new task's runnable average */ : 
2
strstr : if : 	/* Initialize new task's runnable average */ : 
2
strstr : for : 	/* Initialize new task's runnable average */ : 
2
strstr : while : 	/* Initialize new task's runnable average */ : 
2
str : 	init_task_runnable_average(p);[31]
strstr : INIT : 	init_task_runnable_average(p); : 
2
strstr : if : 	init_task_runnable_average(p); : 
2
strstr : for : 	init_task_runnable_average(p); : 
2
strstr : while : 	init_task_runnable_average(p); : 
2
str : 	rq = __task_rq_lock(p);[24]
strstr : INIT : 	rq = __task_rq_lock(p); : 
2
strstr : if : 	rq = __task_rq_lock(p); : 
2
strstr : for : 	rq = __task_rq_lock(p); : 
2
strstr : while : 	rq = __task_rq_lock(p); : 
2
str : 	activate_task(rq, p, 0);[25]
strstr : INIT : 	activate_task(rq, p, 0); : 
2
strstr : if : 	activate_task(rq, p, 0); : 
2
strstr : for : 	activate_task(rq, p, 0); : 
2
strstr : while : 	activate_task(rq, p, 0); : 
2
str : 	p->on_rq = 1;[14]
strstr : INIT : 	p->on_rq = 1; : 
2
strstr : if : 	p->on_rq = 1; : 
2
strstr : for : 	p->on_rq = 1; : 
2
strstr : while : 	p->on_rq = 1; : 
2
str : 	trace_sched_wakeup_new(p, true);[33]
strstr : INIT : 	trace_sched_wakeup_new(p, true); : 
2
strstr : if : 	trace_sched_wakeup_new(p, true); : 
2
strstr : for : 	trace_sched_wakeup_new(p, true); : 
2
strstr : while : 	trace_sched_wakeup_new(p, true); : 
2
str : 	check_preempt_curr(rq, p, WF_FORK);[36]
strstr : INIT : 	check_preempt_curr(rq, p, WF_FORK); : 
2
strstr : if : 	check_preempt_curr(rq, p, WF_FORK); : 
2
strstr : for : 	check_preempt_curr(rq, p, WF_FORK); : 
2
strstr : while : 	check_preempt_curr(rq, p, WF_FORK); : 
2
str : #ifdef CONFIG_SMP[17]
strstr : INIT : #ifdef CONFIG_SMP : 
2
strstr : if : #ifdef CONFIG_SMP : 
2
strstr : for : #ifdef CONFIG_SMP : 
2
strstr : while : #ifdef CONFIG_SMP : 
2
str : 	if (p->sched_class->task_woken)[32]
strstr : INIT : 	if (p->sched_class->task_woken) : 
2
strstr : if : 	if (p->sched_class->task_woken) : 
2
strstr : for : 	if (p->sched_class->task_woken) : 
2
strstr : while : 	if (p->sched_class->task_woken) : 
2
str : 		p->sched_class->task_woken(rq, p);[36]
strstr : INIT : 		p->sched_class->task_woken(rq, p); : 
2
strstr : if : 		p->sched_class->task_woken(rq, p); : 
2
strstr : for : 		p->sched_class->task_woken(rq, p); : 
2
strstr : while : 		p->sched_class->task_woken(rq, p); : 
2
str : #endif[6]
strstr : INIT : #endif : 
2
strstr : if : #endif : 
2
strstr : for : #endif : 
2
strstr : while : #endif : 
2
str : 	task_rq_unlock(rq, p, &flags);[31]
strstr : INIT : 	task_rq_unlock(rq, p, &flags); : 
2
strstr : if : 	task_rq_unlock(rq, p, &flags); : 
2
strstr : for : 	task_rq_unlock(rq, p, &flags); : 
2
strstr : while : 	task_rq_unlock(rq, p, &flags); : 
2
str : #ifdef CONFIG_PREEMPT_NOTIFIERS[31]
strstr : INIT : #ifdef CONFIG_PREEMPT_NOTIFIERS : 
2
strstr : if : #ifdef CONFIG_PREEMPT_NOTIFIERS : 
2
strstr : for : #ifdef CONFIG_PREEMPT_NOTIFIERS : 
2
strstr : while : #ifdef CONFIG_PREEMPT_NOTIFIERS : 
2
str : /**[3]
strstr : INIT : /** : 
2
strstr : if : /** : 
2
strstr : for : /** : 
2
strstr : while : /** : 
2
str :  * preempt_notifier_register - tell me when current is being preempted & rescheduled[84]
strstr : INIT :  * preempt_notifier_register - tell me when current is being preempted & rescheduled : 
2
strstr : if :  * preempt_notifier_register - tell me when current is being preempted & rescheduled : 
2
strstr : for :  * preempt_notifier_register - tell me when current is being preempted & rescheduled : 
2
strstr : while :  * preempt_notifier_register - tell me when current is being preempted & rescheduled : 
2
str :  * @notifier: notifier struct to register[41]
strstr : INIT :  * @notifier: notifier struct to register : 
2
strstr : if :  * @notifier: notifier struct to register : 
2
strstr : for :  * @notifier: notifier struct to register : 
2
strstr : while :  * @notifier: notifier struct to register : 
2
str :  */[3]
strstr : INIT :  */ : 
2
strstr : if :  */ : 
2
strstr : for :  */ : 
2
strstr : while :  */ : 
2
str : void preempt_notifier_register(struct preempt_notifier *notifier)[65]
strstr : INIT : void preempt_notifier_register(struct preempt_notifier *notifier) : 
2
strstr : if : void preempt_notifier_register(struct preempt_notifier *notifier) : 
2
strstr : for : void preempt_notifier_register(struct preempt_notifier *notifier) : 
2
strstr : while : void preempt_notifier_register(struct preempt_notifier *notifier) : 
2
str : 	hlist_add_head(&notifier->link, &current->preempt_notifiers);[62]
strstr : INIT : 	hlist_add_head(&notifier->link, &current->preempt_notifiers); : 
2
strstr : if : 	hlist_add_head(&notifier->link, &current->preempt_notifiers); : 
2
strstr : for : 	hlist_add_head(&notifier->link, &current->preempt_notifiers); : 
2
strstr : while : 	hlist_add_head(&notifier->link, &current->preempt_notifiers); : 
2
str : EXPORT_SYMBOL_GPL(preempt_notifier_register);[45]
strstr : INIT : EXPORT_SYMBOL_GPL(preempt_notifier_register); : 
2
strstr : if : EXPORT_SYMBOL_GPL(preempt_notifier_register); : 
2
strstr : for : EXPORT_SYMBOL_GPL(preempt_notifier_register); : 
2
strstr : while : EXPORT_SYMBOL_GPL(preempt_notifier_register); : 
2
str : /**[3]
strstr : INIT : /** : 
2
strstr : if : /** : 
2
strstr : for : /** : 
2
strstr : while : /** : 
2
str :  * preempt_notifier_unregister - no longer interested in preemption notifications[81]
strstr : INIT :  * preempt_notifier_unregister - no longer interested in preemption notifications : 
2
strstr : if :  * preempt_notifier_unregister - no longer interested in preemption notifications : 
2
strstr : for :  * preempt_notifier_unregister - no longer interested in preemption notifications : 
2
strstr : while :  * preempt_notifier_unregister - no longer interested in preemption notifications : 
2
str :  * @notifier: notifier struct to unregister[43]
strstr : INIT :  * @notifier: notifier struct to unregister : 
2
strstr : if :  * @notifier: notifier struct to unregister : 
2
strstr : for :  * @notifier: notifier struct to unregister : 
2
strstr : while :  * @notifier: notifier struct to unregister : 
2
str :  * This is safe to call from within a preemption notifier.[58]
strstr : INIT :  * This is safe to call from within a preemption notifier. : 
2
strstr : if :  * This is safe to call from within a preemption notifier. : 
2
strstr : for :  * This is safe to call from within a preemption notifier. : 
2
strstr : while :  * This is safe to call from within a preemption notifier. : 
2
str :  */[3]
strstr : INIT :  */ : 
2
strstr : if :  */ : 
2
strstr : for :  */ : 
2
strstr : while :  */ : 
2
str : void preempt_notifier_unregister(struct preempt_notifier *notifier)[67]
strstr : INIT : void preempt_notifier_unregister(struct preempt_notifier *notifier) : 
2
strstr : if : void preempt_notifier_unregister(struct preempt_notifier *notifier) : 
2
strstr : for : void preempt_notifier_unregister(struct preempt_notifier *notifier) : 
2
strstr : while : void preempt_notifier_unregister(struct preempt_notifier *notifier) : 
2
str : 	hlist_del(&notifier->link);[28]
strstr : INIT : 	hlist_del(&notifier->link); : 
2
strstr : if : 	hlist_del(&notifier->link); : 
2
strstr : for : 	hlist_del(&notifier->link); : 
2
strstr : while : 	hlist_del(&notifier->link); : 
2
str : EXPORT_SYMBOL_GPL(preempt_notifier_unregister);[47]
strstr : INIT : EXPORT_SYMBOL_GPL(preempt_notifier_unregister); : 
2
strstr : if : EXPORT_SYMBOL_GPL(preempt_notifier_unregister); : 
2
strstr : for : EXPORT_SYMBOL_GPL(preempt_notifier_unregister); : 
2
strstr : while : EXPORT_SYMBOL_GPL(preempt_notifier_unregister); : 
2
str : static void fire_sched_in_preempt_notifiers(struct task_struct *curr)[69]
strstr : INIT : static void fire_sched_in_preempt_notifiers(struct task_struct *curr) : 
2
strstr : if : static void fire_sched_in_preempt_notifiers(struct task_struct *curr) : 
2
strstr : for : static void fire_sched_in_preempt_notifiers(struct task_struct *curr) : 
2
strstr : while : static void fire_sched_in_preempt_notifiers(struct task_struct *curr) : 
2
str : 	struct preempt_notifier *notifier;[35]
strstr : INIT : 	struct preempt_notifier *notifier; : 
2
strstr : if : 	struct preempt_notifier *notifier; : 
2
strstr : for : 	struct preempt_notifier *notifier; : 
2
strstr : while : 	struct preempt_notifier *notifier; : 
2
str : 	hlist_for_each_entry(notifier, &curr->preempt_notifiers, link)[63]
strstr : INIT : 	hlist_for_each_entry(notifier, &curr->preempt_notifiers, link) : 
2
strstr : if : 	hlist_for_each_entry(notifier, &curr->preempt_notifiers, link) : 
2
strstr : for : 	hlist_for_each_entry(notifier, &curr->preempt_notifiers, link) : 
2
strstr : while : 	hlist_for_each_entry(notifier, &curr->preempt_notifiers, link) : 
2
str : 		notifier->ops->sched_in(notifier, raw_smp_processor_id());[60]
strstr : INIT : 		notifier->ops->sched_in(notifier, raw_smp_processor_id()); : 
2
strstr : if : 		notifier->ops->sched_in(notifier, raw_smp_processor_id()); : 
2
strstr : for : 		notifier->ops->sched_in(notifier, raw_smp_processor_id()); : 
2
strstr : while : 		notifier->ops->sched_in(notifier, raw_smp_processor_id()); : 
2
str : static void[11]
strstr : INIT : static void : 
2
strstr : if : static void : 
2
strstr : for : static void : 
2
strstr : while : static void : 
2
str : fire_sched_out_preempt_notifiers(struct task_struct *curr,[58]
strstr : INIT : fire_sched_out_preempt_notifiers(struct task_struct *curr, : 
2
strstr : if : fire_sched_out_preempt_notifiers(struct task_struct *curr, : 
2
strstr : for : fire_sched_out_preempt_notifiers(struct task_struct *curr, : 
2
strstr : while : fire_sched_out_preempt_notifiers(struct task_struct *curr, : 
2
str : 				 struct task_struct *next)[30]
strstr : INIT : 				 struct task_struct *next) : 
2
strstr : if : 				 struct task_struct *next) : 
2
strstr : for : 				 struct task_struct *next) : 
2
strstr : while : 				 struct task_struct *next) : 
2
str : 	struct preempt_notifier *notifier;[35]
strstr : INIT : 	struct preempt_notifier *notifier; : 
2
strstr : if : 	struct preempt_notifier *notifier; : 
2
strstr : for : 	struct preempt_notifier *notifier; : 
2
strstr : while : 	struct preempt_notifier *notifier; : 
2
str : 	hlist_for_each_entry(notifier, &curr->preempt_notifiers, link)[63]
strstr : INIT : 	hlist_for_each_entry(notifier, &curr->preempt_notifiers, link) : 
2
strstr : if : 	hlist_for_each_entry(notifier, &curr->preempt_notifiers, link) : 
2
strstr : for : 	hlist_for_each_entry(notifier, &curr->preempt_notifiers, link) : 
2
strstr : while : 	hlist_for_each_entry(notifier, &curr->preempt_notifiers, link) : 
2
str : 		notifier->ops->sched_out(notifier, next);[43]
strstr : INIT : 		notifier->ops->sched_out(notifier, next); : 
2
strstr : if : 		notifier->ops->sched_out(notifier, next); : 
2
strstr : for : 		notifier->ops->sched_out(notifier, next); : 
2
strstr : while : 		notifier->ops->sched_out(notifier, next); : 
2
str : #else /* !CONFIG_PREEMPT_NOTIFIERS */[37]
strstr : INIT : #else /* !CONFIG_PREEMPT_NOTIFIERS */ : 
2
strstr : if : #else /* !CONFIG_PREEMPT_NOTIFIERS */ : 
2
strstr : for : #else /* !CONFIG_PREEMPT_NOTIFIERS */ : 
2
strstr : while : #else /* !CONFIG_PREEMPT_NOTIFIERS */ : 
2
str : static void fire_sched_in_preempt_notifiers(struct task_struct *curr)[69]
strstr : INIT : static void fire_sched_in_preempt_notifiers(struct task_struct *curr) : 
2
strstr : if : static void fire_sched_in_preempt_notifiers(struct task_struct *curr) : 
2
strstr : for : static void fire_sched_in_preempt_notifiers(struct task_struct *curr) : 
2
strstr : while : static void fire_sched_in_preempt_notifiers(struct task_struct *curr) : 
2
str : static void[11]
strstr : INIT : static void : 
2
strstr : if : static void : 
2
strstr : for : static void : 
2
strstr : while : static void : 
2
str : fire_sched_out_preempt_notifiers(struct task_struct *curr,[58]
strstr : INIT : fire_sched_out_preempt_notifiers(struct task_struct *curr, : 
2
strstr : if : fire_sched_out_preempt_notifiers(struct task_struct *curr, : 
2
strstr : for : fire_sched_out_preempt_notifiers(struct task_struct *curr, : 
2
strstr : while : fire_sched_out_preempt_notifiers(struct task_struct *curr, : 
2
str : 				 struct task_struct *next)[30]
strstr : INIT : 				 struct task_struct *next) : 
2
strstr : if : 				 struct task_struct *next) : 
2
strstr : for : 				 struct task_struct *next) : 
2
strstr : while : 				 struct task_struct *next) : 
2
str : #endif /* CONFIG_PREEMPT_NOTIFIERS */[37]
strstr : INIT : #endif /* CONFIG_PREEMPT_NOTIFIERS */ : 
2
strstr : if : #endif /* CONFIG_PREEMPT_NOTIFIERS */ : 
2
strstr : for : #endif /* CONFIG_PREEMPT_NOTIFIERS */ : 
2
strstr : while : #endif /* CONFIG_PREEMPT_NOTIFIERS */ : 
2
str : /**[3]
strstr : INIT : /** : 
2
strstr : if : /** : 
2
strstr : for : /** : 
2
strstr : while : /** : 
2
str :  * prepare_task_switch - prepare to switch tasks[48]
strstr : INIT :  * prepare_task_switch - prepare to switch tasks : 
2
strstr : if :  * prepare_task_switch - prepare to switch tasks : 
2
strstr : for :  * prepare_task_switch - prepare to switch tasks : 
2
strstr : while :  * prepare_task_switch - prepare to switch tasks : 
2
str :  * @rq: the runqueue preparing to switch[40]
strstr : INIT :  * @rq: the runqueue preparing to switch : 
2
strstr : if :  * @rq: the runqueue preparing to switch : 
2
strstr : for :  * @rq: the runqueue preparing to switch : 
2
strstr : while :  * @rq: the runqueue preparing to switch : 
2
str :  * @prev: the current task that is being switched out[53]
strstr : INIT :  * @prev: the current task that is being switched out : 
2
strstr : if :  * @prev: the current task that is being switched out : 
2
strstr : for :  * @prev: the current task that is being switched out : 
2
strstr : while :  * @prev: the current task that is being switched out : 
2
str :  * @next: the task we are going to switch to.[45]
strstr : INIT :  * @next: the task we are going to switch to. : 
2
strstr : if :  * @next: the task we are going to switch to. : 
2
strstr : for :  * @next: the task we are going to switch to. : 
2
strstr : while :  * @next: the task we are going to switch to. : 
2
str :  * This is called with the rq lock held and interrupts off. It must[67]
strstr : INIT :  * This is called with the rq lock held and interrupts off. It must : 
2
strstr : if :  * This is called with the rq lock held and interrupts off. It must : 
2
strstr : for :  * This is called with the rq lock held and interrupts off. It must : 
2
strstr : while :  * This is called with the rq lock held and interrupts off. It must : 
2
str :  * be paired with a subsequent finish_task_switch after the context[67]
strstr : INIT :  * be paired with a subsequent finish_task_switch after the context : 
2
strstr : if :  * be paired with a subsequent finish_task_switch after the context : 
2
strstr : for :  * be paired with a subsequent finish_task_switch after the context : 
2
strstr : while :  * be paired with a subsequent finish_task_switch after the context : 
2
str :  * switch.[10]
strstr : INIT :  * switch. : 
2
strstr : if :  * switch. : 
2
strstr : for :  * switch. : 
2
strstr : while :  * switch. : 
2
str :  * prepare_task_switch sets up locking and calls architecture specific[70]
strstr : INIT :  * prepare_task_switch sets up locking and calls architecture specific : 
2
strstr : if :  * prepare_task_switch sets up locking and calls architecture specific : 
2
strstr : for :  * prepare_task_switch sets up locking and calls architecture specific : 
2
strstr : while :  * prepare_task_switch sets up locking and calls architecture specific : 
2
str :  * hooks.[9]
strstr : INIT :  * hooks. : 
2
strstr : if :  * hooks. : 
2
strstr : for :  * hooks. : 
2
strstr : while :  * hooks. : 
2
str :  */[3]
strstr : INIT :  */ : 
2
strstr : if :  */ : 
2
strstr : for :  */ : 
2
strstr : while :  */ : 
2
str : static inline void[18]
strstr : INIT : static inline void : 
2
strstr : if : static inline void : 
2
strstr : for : static inline void : 
2
strstr : while : static inline void : 
2
str : prepare_task_switch(struct rq *rq, struct task_struct *prev,[60]
strstr : INIT : prepare_task_switch(struct rq *rq, struct task_struct *prev, : 
2
strstr : if : prepare_task_switch(struct rq *rq, struct task_struct *prev, : 
2
strstr : for : prepare_task_switch(struct rq *rq, struct task_struct *prev, : 
2
strstr : while : prepare_task_switch(struct rq *rq, struct task_struct *prev, : 
2
str : 		    struct task_struct *next)[31]
strstr : INIT : 		    struct task_struct *next) : 
2
strstr : if : 		    struct task_struct *next) : 
2
strstr : for : 		    struct task_struct *next) : 
2
strstr : while : 		    struct task_struct *next) : 
2
str : 	trace_sched_switch(prev, next);[32]
strstr : INIT : 	trace_sched_switch(prev, next); : 
2
strstr : if : 	trace_sched_switch(prev, next); : 
2
strstr : for : 	trace_sched_switch(prev, next); : 
2
strstr : while : 	trace_sched_switch(prev, next); : 
2
str : 	sched_info_switch(rq, prev, next);[35]
strstr : INIT : 	sched_info_switch(rq, prev, next); : 
2
strstr : if : 	sched_info_switch(rq, prev, next); : 
2
strstr : for : 	sched_info_switch(rq, prev, next); : 
2
strstr : while : 	sched_info_switch(rq, prev, next); : 
2
str : 	perf_event_task_sched_out(prev, next);[39]
strstr : INIT : 	perf_event_task_sched_out(prev, next); : 
2
strstr : if : 	perf_event_task_sched_out(prev, next); : 
2
strstr : for : 	perf_event_task_sched_out(prev, next); : 
2
strstr : while : 	perf_event_task_sched_out(prev, next); : 
2
str : 	fire_sched_out_preempt_notifiers(prev, next);[46]
strstr : INIT : 	fire_sched_out_preempt_notifiers(prev, next); : 
2
strstr : if : 	fire_sched_out_preempt_notifiers(prev, next); : 
2
strstr : for : 	fire_sched_out_preempt_notifiers(prev, next); : 
2
strstr : while : 	fire_sched_out_preempt_notifiers(prev, next); : 
2
str : 	prepare_lock_switch(rq, next);[31]
strstr : INIT : 	prepare_lock_switch(rq, next); : 
2
strstr : if : 	prepare_lock_switch(rq, next); : 
2
strstr : for : 	prepare_lock_switch(rq, next); : 
2
strstr : while : 	prepare_lock_switch(rq, next); : 
2
str : 	prepare_arch_switch(next);[27]
strstr : INIT : 	prepare_arch_switch(next); : 
2
strstr : if : 	prepare_arch_switch(next); : 
2
strstr : for : 	prepare_arch_switch(next); : 
2
strstr : while : 	prepare_arch_switch(next); : 
2
str : /**[3]
strstr : INIT : /** : 
2
strstr : if : /** : 
2
strstr : for : /** : 
2
strstr : while : /** : 
2
str :  * finish_task_switch - clean up after a task-switch[52]
strstr : INIT :  * finish_task_switch - clean up after a task-switch : 
2
strstr : if :  * finish_task_switch - clean up after a task-switch : 
2
strstr : for :  * finish_task_switch - clean up after a task-switch : 
2
strstr : while :  * finish_task_switch - clean up after a task-switch : 
2
str :  * @rq: runqueue associated with task-switch[44]
strstr : INIT :  * @rq: runqueue associated with task-switch : 
2
strstr : if :  * @rq: runqueue associated with task-switch : 
2
strstr : for :  * @rq: runqueue associated with task-switch : 
2
strstr : while :  * @rq: runqueue associated with task-switch : 
2
str :  * @prev: the thread we just switched away from.[48]
strstr : INIT :  * @prev: the thread we just switched away from. : 
2
strstr : if :  * @prev: the thread we just switched away from. : 
2
strstr : for :  * @prev: the thread we just switched away from. : 
2
strstr : while :  * @prev: the thread we just switched away from. : 
2
str :  * finish_task_switch must be called after the context switch, paired[69]
strstr : INIT :  * finish_task_switch must be called after the context switch, paired : 
2
strstr : if :  * finish_task_switch must be called after the context switch, paired : 
2
strstr : for :  * finish_task_switch must be called after the context switch, paired : 
2
strstr : while :  * finish_task_switch must be called after the context switch, paired : 
2
str :  * with a prepare_task_switch call before the context switch.[61]
strstr : INIT :  * with a prepare_task_switch call before the context switch. : 
2
strstr : if :  * with a prepare_task_switch call before the context switch. : 
2
strstr : for :  * with a prepare_task_switch call before the context switch. : 
2
strstr : while :  * with a prepare_task_switch call before the context switch. : 
2
str :  * finish_task_switch will reconcile locking set up by prepare_task_switch,[75]
strstr : INIT :  * finish_task_switch will reconcile locking set up by prepare_task_switch, : 
2
strstr : if :  * finish_task_switch will reconcile locking set up by prepare_task_switch, : 
2
strstr : for :  * finish_task_switch will reconcile locking set up by prepare_task_switch, : 
2
strstr : while :  * finish_task_switch will reconcile locking set up by prepare_task_switch, : 
2
str :  * and do any other architecture-specific cleanup actions.[58]
strstr : INIT :  * and do any other architecture-specific cleanup actions. : 
2
strstr : if :  * and do any other architecture-specific cleanup actions. : 
2
strstr : for :  * and do any other architecture-specific cleanup actions. : 
2
strstr : while :  * and do any other architecture-specific cleanup actions. : 
2
str :  * Note that we may have delayed dropping an mm in context_switch(). If[71]
strstr : INIT :  * Note that we may have delayed dropping an mm in context_switch(). If : 
2
strstr : if :  * Note that we may have delayed dropping an mm in context_switch(). If : 
2
strstr : for :  * Note that we may have delayed dropping an mm in context_switch(). If : 
2
strstr : while :  * Note that we may have delayed dropping an mm in context_switch(). If : 
2
str :  * so, we finish that here outside of the runqueue lock. (Doing it[66]
strstr : INIT :  * so, we finish that here outside of the runqueue lock. (Doing it : 
2
strstr : if :  * so, we finish that here outside of the runqueue lock. (Doing it : 
2
strstr : for :  * so, we finish that here outside of the runqueue lock. (Doing it : 
2
strstr : while :  * so, we finish that here outside of the runqueue lock. (Doing it : 
2
str :  * with the lock held can cause deadlocks; see schedule() for[61]
strstr : INIT :  * with the lock held can cause deadlocks; see schedule() for : 
2
strstr : if :  * with the lock held can cause deadlocks; see schedule() for : 
2
strstr : for :  * with the lock held can cause deadlocks; see schedule() for : 
2
strstr : while :  * with the lock held can cause deadlocks; see schedule() for : 
2
str :  * details.)[12]
strstr : INIT :  * details.) : 
2
strstr : if :  * details.) : 
2
strstr : for :  * details.) : 
2
strstr : while :  * details.) : 
2
str :  */[3]
strstr : INIT :  */ : 
2
strstr : if :  */ : 
2
strstr : for :  */ : 
2
strstr : while :  */ : 
2
str : static void finish_task_switch(struct rq *rq, struct task_struct *prev)[71]
strstr : INIT : static void finish_task_switch(struct rq *rq, struct task_struct *prev) : 
2
strstr : if : static void finish_task_switch(struct rq *rq, struct task_struct *prev) : 
2
strstr : for : static void finish_task_switch(struct rq *rq, struct task_struct *prev) : 
2
strstr : while : static void finish_task_switch(struct rq *rq, struct task_struct *prev) : 
2
str : 	__releases(rq->lock)[21]
strstr : INIT : 	__releases(rq->lock) : 
2
strstr : if : 	__releases(rq->lock) : 
2
strstr : for : 	__releases(rq->lock) : 
2
strstr : while : 	__releases(rq->lock) : 
2
str : 	struct mm_struct *mm = rq->prev_mm;[36]
strstr : INIT : 	struct mm_struct *mm = rq->prev_mm; : 
2
strstr : if : 	struct mm_struct *mm = rq->prev_mm; : 
2
strstr : for : 	struct mm_struct *mm = rq->prev_mm; : 
2
strstr : while : 	struct mm_struct *mm = rq->prev_mm; : 
2
str : 	long prev_state;[17]
strstr : INIT : 	long prev_state; : 
2
strstr : if : 	long prev_state; : 
2
strstr : for : 	long prev_state; : 
2
strstr : while : 	long prev_state; : 
2
str : 	rq->prev_mm = NULL;[20]
strstr : INIT : 	rq->prev_mm = NULL; : 
2
strstr : if : 	rq->prev_mm = NULL; : 
2
strstr : for : 	rq->prev_mm = NULL; : 
2
strstr : while : 	rq->prev_mm = NULL; : 
2
str : 	/*[3]
strstr : INIT : 	/* : 
2
strstr : if : 	/* : 
2
strstr : for : 	/* : 
2
strstr : while : 	/* : 
2
str : 	 * A task struct has one reference for the use as "current".[61]
strstr : INIT : 	 * A task struct has one reference for the use as "current". : 
2
strstr : if : 	 * A task struct has one reference for the use as "current". : 
2
strstr : for : 	 * A task struct has one reference for the use as "current". : 
2
strstr : while : 	 * A task struct has one reference for the use as "current". : 
2
str : 	 * If a task dies, then it sets TASK_DEAD in tsk->state and calls[66]
strstr : INIT : 	 * If a task dies, then it sets TASK_DEAD in tsk->state and calls : 
2
strstr : if : 	 * If a task dies, then it sets TASK_DEAD in tsk->state and calls : 
2
strstr : for : 	 * If a task dies, then it sets TASK_DEAD in tsk->state and calls : 
2
strstr : while : 	 * If a task dies, then it sets TASK_DEAD in tsk->state and calls : 
2
str : 	 * schedule one last time. The schedule call will never return, and[68]
strstr : INIT : 	 * schedule one last time. The schedule call will never return, and : 
2
strstr : if : 	 * schedule one last time. The schedule call will never return, and : 
2
strstr : for : 	 * schedule one last time. The schedule call will never return, and : 
2
strstr : while : 	 * schedule one last time. The schedule call will never return, and : 
2
str : 	 * the scheduled task must drop that reference.[48]
strstr : INIT : 	 * the scheduled task must drop that reference. : 
2
strstr : if : 	 * the scheduled task must drop that reference. : 
2
strstr : for : 	 * the scheduled task must drop that reference. : 
2
strstr : while : 	 * the scheduled task must drop that reference. : 
2
str : 	 * The test for TASK_DEAD must occur while the runqueue locks are[66]
strstr : INIT : 	 * The test for TASK_DEAD must occur while the runqueue locks are : 
2
strstr : if : 	 * The test for TASK_DEAD must occur while the runqueue locks are : 
2
strstr : for : 	 * The test for TASK_DEAD must occur while the runqueue locks are : 
2
strstr : while : 	 * The test for TASK_DEAD must occur while the runqueue locks are : 
2
str : 	 * still held, otherwise prev could be scheduled on another cpu, die[69]
strstr : INIT : 	 * still held, otherwise prev could be scheduled on another cpu, die : 
2
strstr : if : 	 * still held, otherwise prev could be scheduled on another cpu, die : 
2
strstr : for : 	 * still held, otherwise prev could be scheduled on another cpu, die : 
2
strstr : while : 	 * still held, otherwise prev could be scheduled on another cpu, die : 
2
str : 	 * there before we look at prev->state, and then the reference would[69]
strstr : INIT : 	 * there before we look at prev->state, and then the reference would : 
2
strstr : if : 	 * there before we look at prev->state, and then the reference would : 
2
strstr : for : 	 * there before we look at prev->state, and then the reference would : 
2
strstr : while : 	 * there before we look at prev->state, and then the reference would : 
2
str : 	 * be dropped twice.[21]
strstr : INIT : 	 * be dropped twice. : 
2
strstr : if : 	 * be dropped twice. : 
2
strstr : for : 	 * be dropped twice. : 
2
strstr : while : 	 * be dropped twice. : 
2
str : 	 *		Manfred Spraul <manfred@colorfullife.com>[46]
strstr : INIT : 	 *		Manfred Spraul <manfred@colorfullife.com> : 
2
strstr : if : 	 *		Manfred Spraul <manfred@colorfullife.com> : 
2
strstr : for : 	 *		Manfred Spraul <manfred@colorfullife.com> : 
2
strstr : while : 	 *		Manfred Spraul <manfred@colorfullife.com> : 
2
str : 	 */[4]
strstr : INIT : 	 */ : 
2
strstr : if : 	 */ : 
2
strstr : for : 	 */ : 
2
strstr : while : 	 */ : 
2
str : 	prev_state = prev->state;[26]
strstr : INIT : 	prev_state = prev->state; : 
2
strstr : if : 	prev_state = prev->state; : 
2
strstr : for : 	prev_state = prev->state; : 
2
strstr : while : 	prev_state = prev->state; : 
2
str : 	vtime_task_switch(prev);[25]
strstr : INIT : 	vtime_task_switch(prev); : 
2
strstr : if : 	vtime_task_switch(prev); : 
2
strstr : for : 	vtime_task_switch(prev); : 
2
strstr : while : 	vtime_task_switch(prev); : 
2
str : 	finish_arch_switch(prev);[26]
strstr : INIT : 	finish_arch_switch(prev); : 
2
strstr : if : 	finish_arch_switch(prev); : 
2
strstr : for : 	finish_arch_switch(prev); : 
2
strstr : while : 	finish_arch_switch(prev); : 
2
str : 	perf_event_task_sched_in(prev, current);[41]
strstr : INIT : 	perf_event_task_sched_in(prev, current); : 
2
strstr : if : 	perf_event_task_sched_in(prev, current); : 
2
strstr : for : 	perf_event_task_sched_in(prev, current); : 
2
strstr : while : 	perf_event_task_sched_in(prev, current); : 
2
str : 	finish_lock_switch(rq, prev);[30]
strstr : INIT : 	finish_lock_switch(rq, prev); : 
2
strstr : if : 	finish_lock_switch(rq, prev); : 
2
strstr : for : 	finish_lock_switch(rq, prev); : 
2
strstr : while : 	finish_lock_switch(rq, prev); : 
2
str : 	finish_arch_post_lock_switch();[32]
strstr : INIT : 	finish_arch_post_lock_switch(); : 
2
strstr : if : 	finish_arch_post_lock_switch(); : 
2
strstr : for : 	finish_arch_post_lock_switch(); : 
2
strstr : while : 	finish_arch_post_lock_switch(); : 
2
str : 	fire_sched_in_preempt_notifiers(current);[42]
strstr : INIT : 	fire_sched_in_preempt_notifiers(current); : 
2
strstr : if : 	fire_sched_in_preempt_notifiers(current); : 
2
strstr : for : 	fire_sched_in_preempt_notifiers(current); : 
2
strstr : while : 	fire_sched_in_preempt_notifiers(current); : 
2
str : 	if (mm)[8]
strstr : INIT : 	if (mm) : 
2
strstr : if : 	if (mm) : 
2
strstr : for : 	if (mm) : 
2
strstr : while : 	if (mm) : 
2
str : 		mmdrop(mm);[13]
strstr : INIT : 		mmdrop(mm); : 
2
strstr : if : 		mmdrop(mm); : 
2
strstr : for : 		mmdrop(mm); : 
2
strstr : while : 		mmdrop(mm); : 
2
str : 	if (unlikely(prev_state == TASK_DEAD)) {[41]
strstr : INIT : 	if (unlikely(prev_state == TASK_DEAD)) { : 
2
strstr : if : 	if (unlikely(prev_state == TASK_DEAD)) { : 
2
strstr : for : 	if (unlikely(prev_state == TASK_DEAD)) { : 
2
strstr : while : 	if (unlikely(prev_state == TASK_DEAD)) { : 
2
str : 		task_numa_free(prev);[23]
strstr : INIT : 		task_numa_free(prev); : 
2
strstr : if : 		task_numa_free(prev); : 
2
strstr : for : 		task_numa_free(prev); : 
2
strstr : while : 		task_numa_free(prev); : 
2
str : 		if (prev->sched_class->task_dead)[35]
strstr : INIT : 		if (prev->sched_class->task_dead) : 
2
strstr : if : 		if (prev->sched_class->task_dead) : 
2
strstr : for : 		if (prev->sched_class->task_dead) : 
2
strstr : while : 		if (prev->sched_class->task_dead) : 
2
str : 			prev->sched_class->task_dead(prev);[38]
strstr : INIT : 			prev->sched_class->task_dead(prev); : 
2
strstr : if : 			prev->sched_class->task_dead(prev); : 
2
strstr : for : 			prev->sched_class->task_dead(prev); : 
2
strstr : while : 			prev->sched_class->task_dead(prev); : 
2
str : 		/*[4]
strstr : INIT : 		/* : 
2
strstr : if : 		/* : 
2
strstr : for : 		/* : 
2
strstr : while : 		/* : 
2
str : 		 * Remove function-return probe instances associated with this[64]
strstr : INIT : 		 * Remove function-return probe instances associated with this : 
2
strstr : if : 		 * Remove function-return probe instances associated with this : 
2
strstr : for : 		 * Remove function-return probe instances associated with this : 
2
strstr : while : 		 * Remove function-return probe instances associated with this : 
2
str : 		 * task and put them back on the free list.[45]
strstr : INIT : 		 * task and put them back on the free list. : 
2
strstr : if : 		 * task and put them back on the free list. : 
2
strstr : for : 		 * task and put them back on the free list. : 
2
strstr : while : 		 * task and put them back on the free list. : 
2
str : 		 */[5]
strstr : INIT : 		 */ : 
2
strstr : if : 		 */ : 
2
strstr : for : 		 */ : 
2
strstr : while : 		 */ : 
2
str : 		kprobe_flush_task(prev);[26]
strstr : INIT : 		kprobe_flush_task(prev); : 
2
strstr : if : 		kprobe_flush_task(prev); : 
2
strstr : for : 		kprobe_flush_task(prev); : 
2
strstr : while : 		kprobe_flush_task(prev); : 
2
str : 		put_task_struct(prev);[24]
strstr : INIT : 		put_task_struct(prev); : 
2
strstr : if : 		put_task_struct(prev); : 
2
strstr : for : 		put_task_struct(prev); : 
2
strstr : while : 		put_task_struct(prev); : 
2
str : 	tick_nohz_task_switch(current);[32]
strstr : INIT : 	tick_nohz_task_switch(current); : 
2
strstr : if : 	tick_nohz_task_switch(current); : 
2
strstr : for : 	tick_nohz_task_switch(current); : 
2
strstr : while : 	tick_nohz_task_switch(current); : 
2
str : #ifdef CONFIG_SMP[17]
strstr : INIT : #ifdef CONFIG_SMP : 
2
strstr : if : #ifdef CONFIG_SMP : 
2
strstr : for : #ifdef CONFIG_SMP : 
2
strstr : while : #ifdef CONFIG_SMP : 
2
str : /* assumes rq->lock is held */[30]
strstr : INIT : /* assumes rq->lock is held */ : 
2
strstr : if : /* assumes rq->lock is held */ : 
2
strstr : for : /* assumes rq->lock is held */ : 
2
strstr : while : /* assumes rq->lock is held */ : 
2
str : static inline void pre_schedule(struct rq *rq, struct task_struct *prev)[72]
strstr : INIT : static inline void pre_schedule(struct rq *rq, struct task_struct *prev) : 
2
strstr : if : static inline void pre_schedule(struct rq *rq, struct task_struct *prev) : 
2
strstr : for : static inline void pre_schedule(struct rq *rq, struct task_struct *prev) : 
2
strstr : while : static inline void pre_schedule(struct rq *rq, struct task_struct *prev) : 
2
str : 	if (prev->sched_class->pre_schedule)[37]
strstr : INIT : 	if (prev->sched_class->pre_schedule) : 
2
strstr : if : 	if (prev->sched_class->pre_schedule) : 
2
strstr : for : 	if (prev->sched_class->pre_schedule) : 
2
strstr : while : 	if (prev->sched_class->pre_schedule) : 
2
str : 		prev->sched_class->pre_schedule(rq, prev);[44]
strstr : INIT : 		prev->sched_class->pre_schedule(rq, prev); : 
2
strstr : if : 		prev->sched_class->pre_schedule(rq, prev); : 
2
strstr : for : 		prev->sched_class->pre_schedule(rq, prev); : 
2
strstr : while : 		prev->sched_class->pre_schedule(rq, prev); : 
2
str : /* rq->lock is NOT held, but preemption is disabled */[54]
strstr : INIT : /* rq->lock is NOT held, but preemption is disabled */ : 
2
strstr : if : /* rq->lock is NOT held, but preemption is disabled */ : 
2
strstr : for : /* rq->lock is NOT held, but preemption is disabled */ : 
2
strstr : while : /* rq->lock is NOT held, but preemption is disabled */ : 
2
str : static inline void post_schedule(struct rq *rq)[47]
strstr : INIT : static inline void post_schedule(struct rq *rq) : 
2
strstr : if : static inline void post_schedule(struct rq *rq) : 
2
strstr : for : static inline void post_schedule(struct rq *rq) : 
2
strstr : while : static inline void post_schedule(struct rq *rq) : 
2
str : 	if (rq->post_schedule) {[25]
strstr : INIT : 	if (rq->post_schedule) { : 
2
strstr : if : 	if (rq->post_schedule) { : 
2
strstr : for : 	if (rq->post_schedule) { : 
2
strstr : while : 	if (rq->post_schedule) { : 
2
str : 		unsigned long flags;[22]
strstr : INIT : 		unsigned long flags; : 
2
strstr : if : 		unsigned long flags; : 
2
strstr : for : 		unsigned long flags; : 
2
strstr : while : 		unsigned long flags; : 
2
str : 		raw_spin_lock_irqsave(&rq->lock, flags);[42]
strstr : INIT : 		raw_spin_lock_irqsave(&rq->lock, flags); : 
2
strstr : if : 		raw_spin_lock_irqsave(&rq->lock, flags); : 
2
strstr : for : 		raw_spin_lock_irqsave(&rq->lock, flags); : 
2
strstr : while : 		raw_spin_lock_irqsave(&rq->lock, flags); : 
2
str : 		if (rq->curr->sched_class->post_schedule)[43]
strstr : INIT : 		if (rq->curr->sched_class->post_schedule) : 
2
strstr : if : 		if (rq->curr->sched_class->post_schedule) : 
2
strstr : for : 		if (rq->curr->sched_class->post_schedule) : 
2
strstr : while : 		if (rq->curr->sched_class->post_schedule) : 
2
str : 			rq->curr->sched_class->post_schedule(rq);[44]
strstr : INIT : 			rq->curr->sched_class->post_schedule(rq); : 
2
strstr : if : 			rq->curr->sched_class->post_schedule(rq); : 
2
strstr : for : 			rq->curr->sched_class->post_schedule(rq); : 
2
strstr : while : 			rq->curr->sched_class->post_schedule(rq); : 
2
str : 		raw_spin_unlock_irqrestore(&rq->lock, flags);[47]
strstr : INIT : 		raw_spin_unlock_irqrestore(&rq->lock, flags); : 
2
strstr : if : 		raw_spin_unlock_irqrestore(&rq->lock, flags); : 
2
strstr : for : 		raw_spin_unlock_irqrestore(&rq->lock, flags); : 
2
strstr : while : 		raw_spin_unlock_irqrestore(&rq->lock, flags); : 
2
str : 		rq->post_schedule = 0;[24]
strstr : INIT : 		rq->post_schedule = 0; : 
2
strstr : if : 		rq->post_schedule = 0; : 
2
strstr : for : 		rq->post_schedule = 0; : 
2
strstr : while : 		rq->post_schedule = 0; : 
2
str : #else[5]
strstr : INIT : #else : 
2
strstr : if : #else : 
2
strstr : for : #else : 
2
strstr : while : #else : 
2
str : static inline void pre_schedule(struct rq *rq, struct task_struct *p)[69]
strstr : INIT : static inline void pre_schedule(struct rq *rq, struct task_struct *p) : 
2
strstr : if : static inline void pre_schedule(struct rq *rq, struct task_struct *p) : 
2
strstr : for : static inline void pre_schedule(struct rq *rq, struct task_struct *p) : 
2
strstr : while : static inline void pre_schedule(struct rq *rq, struct task_struct *p) : 
2
str : static inline void post_schedule(struct rq *rq)[47]
strstr : INIT : static inline void post_schedule(struct rq *rq) : 
2
strstr : if : static inline void post_schedule(struct rq *rq) : 
2
strstr : for : static inline void post_schedule(struct rq *rq) : 
2
strstr : while : static inline void post_schedule(struct rq *rq) : 
2
str : #endif[6]
strstr : INIT : #endif : 
2
strstr : if : #endif : 
2
strstr : for : #endif : 
2
strstr : while : #endif : 
2
str : /**[3]
strstr : INIT : /** : 
2
strstr : if : /** : 
2
strstr : for : /** : 
2
strstr : while : /** : 
2
str :  * schedule_tail - first thing a freshly forked thread must call.[65]
strstr : INIT :  * schedule_tail - first thing a freshly forked thread must call. : 
2
strstr : if :  * schedule_tail - first thing a freshly forked thread must call. : 
2
strstr : for :  * schedule_tail - first thing a freshly forked thread must call. : 
2
strstr : while :  * schedule_tail - first thing a freshly forked thread must call. : 
2
str :  * @prev: the thread we just switched away from.[48]
strstr : INIT :  * @prev: the thread we just switched away from. : 
2
strstr : if :  * @prev: the thread we just switched away from. : 
2
strstr : for :  * @prev: the thread we just switched away from. : 
2
strstr : while :  * @prev: the thread we just switched away from. : 
2
str :  */[3]
strstr : INIT :  */ : 
2
strstr : if :  */ : 
2
strstr : for :  */ : 
2
strstr : while :  */ : 
2
str : asmlinkage void schedule_tail(struct task_struct *prev)[55]
strstr : INIT : asmlinkage void schedule_tail(struct task_struct *prev) : 
2
strstr : if : asmlinkage void schedule_tail(struct task_struct *prev) : 
2
strstr : for : asmlinkage void schedule_tail(struct task_struct *prev) : 
2
strstr : while : asmlinkage void schedule_tail(struct task_struct *prev) : 
2
str : 	__releases(rq->lock)[21]
strstr : INIT : 	__releases(rq->lock) : 
2
strstr : if : 	__releases(rq->lock) : 
2
strstr : for : 	__releases(rq->lock) : 
2
strstr : while : 	__releases(rq->lock) : 
2
str : 	struct rq *rq = this_rq();[27]
strstr : INIT : 	struct rq *rq = this_rq(); : 
2
strstr : if : 	struct rq *rq = this_rq(); : 
2
strstr : for : 	struct rq *rq = this_rq(); : 
2
strstr : while : 	struct rq *rq = this_rq(); : 
2
str : 	finish_task_switch(rq, prev);[30]
strstr : INIT : 	finish_task_switch(rq, prev); : 
2
strstr : if : 	finish_task_switch(rq, prev); : 
2
strstr : for : 	finish_task_switch(rq, prev); : 
2
strstr : while : 	finish_task_switch(rq, prev); : 
2
str : 	/*[3]
strstr : INIT : 	/* : 
2
strstr : if : 	/* : 
2
strstr : for : 	/* : 
2
strstr : while : 	/* : 
2
str : 	 * FIXME: do we need to worry about rq being invalidated by the[64]
strstr : INIT : 	 * FIXME: do we need to worry about rq being invalidated by the : 
2
strstr : if : 	 * FIXME: do we need to worry about rq being invalidated by the : 
2
strstr : for : 	 * FIXME: do we need to worry about rq being invalidated by the : 
2
strstr : while : 	 * FIXME: do we need to worry about rq being invalidated by the : 
2
str : 	 * task_switch?[16]
strstr : INIT : 	 * task_switch? : 
2
strstr : if : 	 * task_switch? : 
2
strstr : for : 	 * task_switch? : 
2
strstr : while : 	 * task_switch? : 
2
str : 	 */[4]
strstr : INIT : 	 */ : 
2
strstr : if : 	 */ : 
2
strstr : for : 	 */ : 
2
strstr : while : 	 */ : 
2
str : 	post_schedule(rq);[19]
strstr : INIT : 	post_schedule(rq); : 
2
strstr : if : 	post_schedule(rq); : 
2
strstr : for : 	post_schedule(rq); : 
2
strstr : while : 	post_schedule(rq); : 
2
str : #ifdef __ARCH_WANT_UNLOCKED_CTXSW[33]
strstr : INIT : #ifdef __ARCH_WANT_UNLOCKED_CTXSW : 
2
strstr : if : #ifdef __ARCH_WANT_UNLOCKED_CTXSW : 
2
strstr : for : #ifdef __ARCH_WANT_UNLOCKED_CTXSW : 
2
strstr : while : #ifdef __ARCH_WANT_UNLOCKED_CTXSW : 
2
str : 	/* In this case, finish_task_switch does not reenable preemption */[68]
strstr : INIT : 	/* In this case, finish_task_switch does not reenable preemption */ : 
2
strstr : if : 	/* In this case, finish_task_switch does not reenable preemption */ : 
2
strstr : for : 	/* In this case, finish_task_switch does not reenable preemption */ : 
2
strstr : while : 	/* In this case, finish_task_switch does not reenable preemption */ : 
2
str : 	preempt_enable();[18]
strstr : INIT : 	preempt_enable(); : 
2
strstr : if : 	preempt_enable(); : 
2
strstr : for : 	preempt_enable(); : 
2
strstr : while : 	preempt_enable(); : 
2
str : #endif[6]
strstr : INIT : #endif : 
2
strstr : if : #endif : 
2
strstr : for : #endif : 
2
strstr : while : #endif : 
2
str : 	if (current->set_child_tid)[28]
strstr : INIT : 	if (current->set_child_tid) : 
2
strstr : if : 	if (current->set_child_tid) : 
2
strstr : for : 	if (current->set_child_tid) : 
2
strstr : while : 	if (current->set_child_tid) : 
2
str : 		put_user(task_pid_vnr(current), current->set_child_tid);[58]
strstr : INIT : 		put_user(task_pid_vnr(current), current->set_child_tid); : 
2
strstr : if : 		put_user(task_pid_vnr(current), current->set_child_tid); : 
2
strstr : for : 		put_user(task_pid_vnr(current), current->set_child_tid); : 
2
strstr : while : 		put_user(task_pid_vnr(current), current->set_child_tid); : 
2
str :  * context_switch - switch to the new MM and the new[52]
strstr : INIT :  * context_switch - switch to the new MM and the new : 
2
strstr : if :  * context_switch - switch to the new MM and the new : 
2
strstr : for :  * context_switch - switch to the new MM and the new : 
2
strstr : while :  * context_switch - switch to the new MM and the new : 
2
str :  * thread's register state.[27]
strstr : INIT :  * thread's register state. : 
2
strstr : if :  * thread's register state. : 
2
strstr : for :  * thread's register state. : 
2
strstr : while :  * thread's register state. : 
2
str :  */[3]
strstr : INIT :  */ : 
2
strstr : if :  */ : 
2
strstr : for :  */ : 
2
strstr : while :  */ : 
2
str : static inline void[18]
strstr : INIT : static inline void : 
2
strstr : if : static inline void : 
2
strstr : for : static inline void : 
2
strstr : while : static inline void : 
2
str : context_switch(struct rq *rq, struct task_struct *prev,[55]
strstr : INIT : context_switch(struct rq *rq, struct task_struct *prev, : 
2
strstr : if : context_switch(struct rq *rq, struct task_struct *prev, : 
2
strstr : for : context_switch(struct rq *rq, struct task_struct *prev, : 
2
strstr : while : context_switch(struct rq *rq, struct task_struct *prev, : 
2
str : 	       struct task_struct *next)[33]
strstr : INIT : 	       struct task_struct *next) : 
2
strstr : if : 	       struct task_struct *next) : 
2
strstr : for : 	       struct task_struct *next) : 
2
strstr : while : 	       struct task_struct *next) : 
2
str : 	struct mm_struct *mm, *oldmm;[30]
strstr : INIT : 	struct mm_struct *mm, *oldmm; : 
2
strstr : if : 	struct mm_struct *mm, *oldmm; : 
2
strstr : for : 	struct mm_struct *mm, *oldmm; : 
2
strstr : while : 	struct mm_struct *mm, *oldmm; : 
2
str : 	prepare_task_switch(rq, prev, next);[37]
strstr : INIT : 	prepare_task_switch(rq, prev, next); : 
2
strstr : if : 	prepare_task_switch(rq, prev, next); : 
2
strstr : for : 	prepare_task_switch(rq, prev, next); : 
2
strstr : while : 	prepare_task_switch(rq, prev, next); : 
2
str : 	mm = next->mm;[15]
strstr : INIT : 	mm = next->mm; : 
2
strstr : if : 	mm = next->mm; : 
2
strstr : for : 	mm = next->mm; : 
2
strstr : while : 	mm = next->mm; : 
2
str : 	oldmm = prev->active_mm;[25]
strstr : INIT : 	oldmm = prev->active_mm; : 
2
strstr : if : 	oldmm = prev->active_mm; : 
2
strstr : for : 	oldmm = prev->active_mm; : 
2
strstr : while : 	oldmm = prev->active_mm; : 
2
str : 	/*[3]
strstr : INIT : 	/* : 
2
strstr : if : 	/* : 
2
strstr : for : 	/* : 
2
strstr : while : 	/* : 
2
str : 	 * For paravirt, this is coupled with an exit in switch_to to[62]
strstr : INIT : 	 * For paravirt, this is coupled with an exit in switch_to to : 
2
strstr : if : 	 * For paravirt, this is coupled with an exit in switch_to to : 
2
strstr : for : 	 * For paravirt, this is coupled with an exit in switch_to to : 
2
strstr : while : 	 * For paravirt, this is coupled with an exit in switch_to to : 
2
str : 	 * combine the page table reload and the switch backend into[61]
strstr : INIT : 	 * combine the page table reload and the switch backend into : 
2
strstr : if : 	 * combine the page table reload and the switch backend into : 
2
strstr : for : 	 * combine the page table reload and the switch backend into : 
2
strstr : while : 	 * combine the page table reload and the switch backend into : 
2
str : 	 * one hypercall.[18]
strstr : INIT : 	 * one hypercall. : 
2
strstr : if : 	 * one hypercall. : 
2
strstr : for : 	 * one hypercall. : 
2
strstr : while : 	 * one hypercall. : 
2
str : 	 */[4]
strstr : INIT : 	 */ : 
2
strstr : if : 	 */ : 
2
strstr : for : 	 */ : 
2
strstr : while : 	 */ : 
2
str : 	arch_start_context_switch(prev);[33]
strstr : INIT : 	arch_start_context_switch(prev); : 
2
strstr : if : 	arch_start_context_switch(prev); : 
2
strstr : for : 	arch_start_context_switch(prev); : 
2
strstr : while : 	arch_start_context_switch(prev); : 
2
str : 	if (!mm) {[11]
strstr : INIT : 	if (!mm) { : 
2
strstr : if : 	if (!mm) { : 
2
strstr : for : 	if (!mm) { : 
2
strstr : while : 	if (!mm) { : 
2
str : 		next->active_mm = oldmm;[26]
strstr : INIT : 		next->active_mm = oldmm; : 
2
strstr : if : 		next->active_mm = oldmm; : 
2
strstr : for : 		next->active_mm = oldmm; : 
2
strstr : while : 		next->active_mm = oldmm; : 
2
str : 		atomic_inc(&oldmm->mm_count);[31]
strstr : INIT : 		atomic_inc(&oldmm->mm_count); : 
2
strstr : if : 		atomic_inc(&oldmm->mm_count); : 
2
strstr : for : 		atomic_inc(&oldmm->mm_count); : 
2
strstr : while : 		atomic_inc(&oldmm->mm_count); : 
2
str : 		enter_lazy_tlb(oldmm, next);[30]
strstr : INIT : 		enter_lazy_tlb(oldmm, next); : 
2
strstr : if : 		enter_lazy_tlb(oldmm, next); : 
2
strstr : for : 		enter_lazy_tlb(oldmm, next); : 
2
strstr : while : 		enter_lazy_tlb(oldmm, next); : 
2
str : 	} else[7]
strstr : INIT : 	} else : 
2
strstr : if : 	} else : 
2
strstr : for : 	} else : 
2
strstr : while : 	} else : 
2
str : 		switch_mm(oldmm, mm, next);[29]
strstr : INIT : 		switch_mm(oldmm, mm, next); : 
2
strstr : if : 		switch_mm(oldmm, mm, next); : 
2
strstr : for : 		switch_mm(oldmm, mm, next); : 
2
strstr : while : 		switch_mm(oldmm, mm, next); : 
2
str : 	if (!prev->mm) {[17]
strstr : INIT : 	if (!prev->mm) { : 
2
strstr : if : 	if (!prev->mm) { : 
2
strstr : for : 	if (!prev->mm) { : 
2
strstr : while : 	if (!prev->mm) { : 
2
str : 		prev->active_mm = NULL;[25]
strstr : INIT : 		prev->active_mm = NULL; : 
2
strstr : if : 		prev->active_mm = NULL; : 
2
strstr : for : 		prev->active_mm = NULL; : 
2
strstr : while : 		prev->active_mm = NULL; : 
2
str : 		rq->prev_mm = oldmm;[22]
strstr : INIT : 		rq->prev_mm = oldmm; : 
2
strstr : if : 		rq->prev_mm = oldmm; : 
2
strstr : for : 		rq->prev_mm = oldmm; : 
2
strstr : while : 		rq->prev_mm = oldmm; : 
2
str : 	/*[3]
strstr : INIT : 	/* : 
2
strstr : if : 	/* : 
2
strstr : for : 	/* : 
2
strstr : while : 	/* : 
2
str : 	 * Since the runqueue lock will be released by the next[56]
strstr : INIT : 	 * Since the runqueue lock will be released by the next : 
2
strstr : if : 	 * Since the runqueue lock will be released by the next : 
2
strstr : for : 	 * Since the runqueue lock will be released by the next : 
2
strstr : while : 	 * Since the runqueue lock will be released by the next : 
2
str : 	 * task (which is an invalid locking op but in the case[56]
strstr : INIT : 	 * task (which is an invalid locking op but in the case : 
2
strstr : if : 	 * task (which is an invalid locking op but in the case : 
2
strstr : for : 	 * task (which is an invalid locking op but in the case : 
2
strstr : while : 	 * task (which is an invalid locking op but in the case : 
2
str : 	 * of the scheduler it's an obvious special-case), so we[57]
strstr : INIT : 	 * of the scheduler it's an obvious special-case), so we : 
2
strstr : if : 	 * of the scheduler it's an obvious special-case), so we : 
2
strstr : for : 	 * of the scheduler it's an obvious special-case), so we : 
2
strstr : while : 	 * of the scheduler it's an obvious special-case), so we : 
2
str : 	 * do an early lockdep release here:[37]
strstr : INIT : 	 * do an early lockdep release here: : 
2
strstr : if : 	 * do an early lockdep release here: : 
2
strstr : for : 	 * do an early lockdep release here: : 
2
strstr : while : 	 * do an early lockdep release here: : 
2
str : 	 */[4]
strstr : INIT : 	 */ : 
2
strstr : if : 	 */ : 
2
strstr : for : 	 */ : 
2
strstr : while : 	 */ : 
2
str : #ifndef __ARCH_WANT_UNLOCKED_CTXSW[34]
strstr : INIT : #ifndef __ARCH_WANT_UNLOCKED_CTXSW : 
2
strstr : if : #ifndef __ARCH_WANT_UNLOCKED_CTXSW : 
2
strstr : for : #ifndef __ARCH_WANT_UNLOCKED_CTXSW : 
2
strstr : while : #ifndef __ARCH_WANT_UNLOCKED_CTXSW : 
2
str : 	spin_release(&rq->lock.dep_map, 1, _THIS_IP_);[47]
strstr : INIT : 	spin_release(&rq->lock.dep_map, 1, _THIS_IP_); : 
2
strstr : if : 	spin_release(&rq->lock.dep_map, 1, _THIS_IP_); : 
2
strstr : for : 	spin_release(&rq->lock.dep_map, 1, _THIS_IP_); : 
2
strstr : while : 	spin_release(&rq->lock.dep_map, 1, _THIS_IP_); : 
2
str : #endif[6]
strstr : INIT : #endif : 
2
strstr : if : #endif : 
2
strstr : for : #endif : 
2
strstr : while : #endif : 
2
str : 	context_tracking_task_switch(prev, next);[42]
strstr : INIT : 	context_tracking_task_switch(prev, next); : 
2
strstr : if : 	context_tracking_task_switch(prev, next); : 
2
strstr : for : 	context_tracking_task_switch(prev, next); : 
2
strstr : while : 	context_tracking_task_switch(prev, next); : 
2
str : 	/* Here we just switch the register state and the stack. */[60]
strstr : INIT : 	/* Here we just switch the register state and the stack. */ : 
2
strstr : if : 	/* Here we just switch the register state and the stack. */ : 
2
strstr : for : 	/* Here we just switch the register state and the stack. */ : 
2
strstr : while : 	/* Here we just switch the register state and the stack. */ : 
2
str : 	switch_to(prev, next, prev);[29]
strstr : INIT : 	switch_to(prev, next, prev); : 
2
strstr : if : 	switch_to(prev, next, prev); : 
2
strstr : for : 	switch_to(prev, next, prev); : 
2
strstr : while : 	switch_to(prev, next, prev); : 
2
str : 	barrier();[11]
strstr : INIT : 	barrier(); : 
2
strstr : if : 	barrier(); : 
2
strstr : for : 	barrier(); : 
2
strstr : while : 	barrier(); : 
2
str : 	/*[3]
strstr : INIT : 	/* : 
2
strstr : if : 	/* : 
2
strstr : for : 	/* : 
2
strstr : while : 	/* : 
2
str : 	 * this_rq must be evaluated again because prev may have moved[63]
strstr : INIT : 	 * this_rq must be evaluated again because prev may have moved : 
2
strstr : if : 	 * this_rq must be evaluated again because prev may have moved : 
2
strstr : for : 	 * this_rq must be evaluated again because prev may have moved : 
2
strstr : while : 	 * this_rq must be evaluated again because prev may have moved : 
2
str : 	 * CPUs since it called schedule(), thus the 'rq' on its stack[63]
strstr : INIT : 	 * CPUs since it called schedule(), thus the 'rq' on its stack : 
2
strstr : if : 	 * CPUs since it called schedule(), thus the 'rq' on its stack : 
2
strstr : for : 	 * CPUs since it called schedule(), thus the 'rq' on its stack : 
2
strstr : while : 	 * CPUs since it called schedule(), thus the 'rq' on its stack : 
2
str : 	 * frame will be invalid.[26]
strstr : INIT : 	 * frame will be invalid. : 
2
strstr : if : 	 * frame will be invalid. : 
2
strstr : for : 	 * frame will be invalid. : 
2
strstr : while : 	 * frame will be invalid. : 
2
str : 	 */[4]
strstr : INIT : 	 */ : 
2
strstr : if : 	 */ : 
2
strstr : for : 	 */ : 
2
strstr : while : 	 */ : 
2
str : 	finish_task_switch(this_rq(), prev);[37]
strstr : INIT : 	finish_task_switch(this_rq(), prev); : 
2
strstr : if : 	finish_task_switch(this_rq(), prev); : 
2
strstr : for : 	finish_task_switch(this_rq(), prev); : 
2
strstr : while : 	finish_task_switch(this_rq(), prev); : 
2
str :  * nr_running and nr_context_switches:[38]
strstr : INIT :  * nr_running and nr_context_switches: : 
2
strstr : if :  * nr_running and nr_context_switches: : 
2
strstr : for :  * nr_running and nr_context_switches: : 
2
strstr : while :  * nr_running and nr_context_switches: : 
2
str :  * externally visible scheduler statistics: current number of runnable[70]
strstr : INIT :  * externally visible scheduler statistics: current number of runnable : 
2
strstr : if :  * externally visible scheduler statistics: current number of runnable : 
2
strstr : for :  * externally visible scheduler statistics: current number of runnable : 
2
strstr : while :  * externally visible scheduler statistics: current number of runnable : 
2
str :  * threads, total number of context switches performed since bootup.[68]
strstr : INIT :  * threads, total number of context switches performed since bootup. : 
2
strstr : if :  * threads, total number of context switches performed since bootup. : 
2
strstr : for :  * threads, total number of context switches performed since bootup. : 
2
strstr : while :  * threads, total number of context switches performed since bootup. : 
2
str :  */[3]
strstr : INIT :  */ : 
2
strstr : if :  */ : 
2
strstr : for :  */ : 
2
strstr : while :  */ : 
2
str : unsigned long nr_running(void)[30]
strstr : INIT : unsigned long nr_running(void) : 
2
strstr : if : unsigned long nr_running(void) : 
2
strstr : for : unsigned long nr_running(void) : 
2
strstr : while : unsigned long nr_running(void) : 
2
str : 	unsigned long i, sum = 0;[26]
strstr : INIT : 	unsigned long i, sum = 0; : 
2
strstr : if : 	unsigned long i, sum = 0; : 
2
strstr : for : 	unsigned long i, sum = 0; : 
2
strstr : while : 	unsigned long i, sum = 0; : 
2
str : 	for_each_online_cpu(i)[23]
strstr : INIT : 	for_each_online_cpu(i) : 
2
strstr : if : 	for_each_online_cpu(i) : 
2
strstr : for : 	for_each_online_cpu(i) : 
2
strstr : while : 	for_each_online_cpu(i) : 
2
str : 		sum += cpu_rq(i)->nr_running;[31]
strstr : INIT : 		sum += cpu_rq(i)->nr_running; : 
2
strstr : if : 		sum += cpu_rq(i)->nr_running; : 
2
strstr : for : 		sum += cpu_rq(i)->nr_running; : 
2
strstr : while : 		sum += cpu_rq(i)->nr_running; : 
2
str : 	return sum;[12]
strstr : INIT : 	return sum; : 
2
strstr : if : 	return sum; : 
2
strstr : for : 	return sum; : 
2
strstr : while : 	return sum; : 
2
str : unsigned long long nr_context_switches(void)[44]
strstr : INIT : unsigned long long nr_context_switches(void) : 
2
strstr : if : unsigned long long nr_context_switches(void) : 
2
strstr : for : unsigned long long nr_context_switches(void) : 
2
strstr : while : unsigned long long nr_context_switches(void) : 
2
str : 	int i;[7]
strstr : INIT : 	int i; : 
2
strstr : if : 	int i; : 
2
strstr : for : 	int i; : 
2
strstr : while : 	int i; : 
2
str : 	unsigned long long sum = 0;[28]
strstr : INIT : 	unsigned long long sum = 0; : 
2
strstr : if : 	unsigned long long sum = 0; : 
2
strstr : for : 	unsigned long long sum = 0; : 
2
strstr : while : 	unsigned long long sum = 0; : 
2
str : 	for_each_possible_cpu(i)[25]
strstr : INIT : 	for_each_possible_cpu(i) : 
2
strstr : if : 	for_each_possible_cpu(i) : 
2
strstr : for : 	for_each_possible_cpu(i) : 
2
strstr : while : 	for_each_possible_cpu(i) : 
2
str : 		sum += cpu_rq(i)->nr_switches;[32]
strstr : INIT : 		sum += cpu_rq(i)->nr_switches; : 
2
strstr : if : 		sum += cpu_rq(i)->nr_switches; : 
2
strstr : for : 		sum += cpu_rq(i)->nr_switches; : 
2
strstr : while : 		sum += cpu_rq(i)->nr_switches; : 
2
str : 	return sum;[12]
strstr : INIT : 	return sum; : 
2
strstr : if : 	return sum; : 
2
strstr : for : 	return sum; : 
2
strstr : while : 	return sum; : 
2
str : unsigned long nr_iowait(void)[29]
strstr : INIT : unsigned long nr_iowait(void) : 
2
strstr : if : unsigned long nr_iowait(void) : 
2
strstr : for : unsigned long nr_iowait(void) : 
2
strstr : while : unsigned long nr_iowait(void) : 
2
str : 	unsigned long i, sum = 0;[26]
strstr : INIT : 	unsigned long i, sum = 0; : 
2
strstr : if : 	unsigned long i, sum = 0; : 
2
strstr : for : 	unsigned long i, sum = 0; : 
2
strstr : while : 	unsigned long i, sum = 0; : 
2
str : 	for_each_possible_cpu(i)[25]
strstr : INIT : 	for_each_possible_cpu(i) : 
2
strstr : if : 	for_each_possible_cpu(i) : 
2
strstr : for : 	for_each_possible_cpu(i) : 
2
strstr : while : 	for_each_possible_cpu(i) : 
2
str : 		sum += atomic_read(&cpu_rq(i)->nr_iowait);[44]
strstr : INIT : 		sum += atomic_read(&cpu_rq(i)->nr_iowait); : 
2
strstr : if : 		sum += atomic_read(&cpu_rq(i)->nr_iowait); : 
2
strstr : for : 		sum += atomic_read(&cpu_rq(i)->nr_iowait); : 
2
strstr : while : 		sum += atomic_read(&cpu_rq(i)->nr_iowait); : 
2
str : 	return sum;[12]
strstr : INIT : 	return sum; : 
2
strstr : if : 	return sum; : 
2
strstr : for : 	return sum; : 
2
strstr : while : 	return sum; : 
2
str : unsigned long nr_iowait_cpu(int cpu)[36]
strstr : INIT : unsigned long nr_iowait_cpu(int cpu) : 
2
strstr : if : unsigned long nr_iowait_cpu(int cpu) : 
2
strstr : for : unsigned long nr_iowait_cpu(int cpu) : 
2
strstr : while : unsigned long nr_iowait_cpu(int cpu) : 
2
str : 	struct rq *this = cpu_rq(cpu);[31]
strstr : INIT : 	struct rq *this = cpu_rq(cpu); : 
2
strstr : if : 	struct rq *this = cpu_rq(cpu); : 
2
strstr : for : 	struct rq *this = cpu_rq(cpu); : 
2
strstr : while : 	struct rq *this = cpu_rq(cpu); : 
2
str : 	return atomic_read(&this->nr_iowait);[38]
strstr : INIT : 	return atomic_read(&this->nr_iowait); : 
2
strstr : if : 	return atomic_read(&this->nr_iowait); : 
2
strstr : for : 	return atomic_read(&this->nr_iowait); : 
2
strstr : while : 	return atomic_read(&this->nr_iowait); : 
2
str : #ifdef CONFIG_SMP[17]
strstr : INIT : #ifdef CONFIG_SMP : 
2
strstr : if : #ifdef CONFIG_SMP : 
2
strstr : for : #ifdef CONFIG_SMP : 
2
strstr : while : #ifdef CONFIG_SMP : 
2
str :  * sched_exec - execve() is a valuable balancing opportunity, because at[72]
strstr : INIT :  * sched_exec - execve() is a valuable balancing opportunity, because at : 
2
strstr : if :  * sched_exec - execve() is a valuable balancing opportunity, because at : 
2
strstr : for :  * sched_exec - execve() is a valuable balancing opportunity, because at : 
2
strstr : while :  * sched_exec - execve() is a valuable balancing opportunity, because at : 
2
str :  * this point the task has the smallest effective memory and cache footprint.[77]
strstr : INIT :  * this point the task has the smallest effective memory and cache footprint. : 
2
strstr : if :  * this point the task has the smallest effective memory and cache footprint. : 
2
strstr : for :  * this point the task has the smallest effective memory and cache footprint. : 
2
strstr : while :  * this point the task has the smallest effective memory and cache footprint. : 
2
str :  */[3]
strstr : INIT :  */ : 
2
strstr : if :  */ : 
2
strstr : for :  */ : 
2
strstr : while :  */ : 
2
str : void sched_exec(void)[21]
strstr : INIT : void sched_exec(void) : 
2
strstr : if : void sched_exec(void) : 
2
strstr : for : void sched_exec(void) : 
2
strstr : while : void sched_exec(void) : 
2
str : 	struct task_struct *p = current;[33]
strstr : INIT : 	struct task_struct *p = current; : 
2
strstr : if : 	struct task_struct *p = current; : 
2
strstr : for : 	struct task_struct *p = current; : 
2
strstr : while : 	struct task_struct *p = current; : 
2
str : 	unsigned long flags;[21]
strstr : INIT : 	unsigned long flags; : 
2
strstr : if : 	unsigned long flags; : 
2
strstr : for : 	unsigned long flags; : 
2
strstr : while : 	unsigned long flags; : 
2
str : 	int dest_cpu;[14]
strstr : INIT : 	int dest_cpu; : 
2
strstr : if : 	int dest_cpu; : 
2
strstr : for : 	int dest_cpu; : 
2
strstr : while : 	int dest_cpu; : 
2
str : 	raw_spin_lock_irqsave(&p->pi_lock, flags);[43]
strstr : INIT : 	raw_spin_lock_irqsave(&p->pi_lock, flags); : 
2
strstr : if : 	raw_spin_lock_irqsave(&p->pi_lock, flags); : 
2
strstr : for : 	raw_spin_lock_irqsave(&p->pi_lock, flags); : 
2
strstr : while : 	raw_spin_lock_irqsave(&p->pi_lock, flags); : 
2
str : 	dest_cpu = p->sched_class->select_task_rq(p, task_cpu(p), SD_BALANCE_EXEC, 0);[79]
strstr : INIT : 	dest_cpu = p->sched_class->select_task_rq(p, task_cpu(p), SD_BALANCE_EXEC, 0); : 
2
strstr : if : 	dest_cpu = p->sched_class->select_task_rq(p, task_cpu(p), SD_BALANCE_EXEC, 0); : 
2
strstr : for : 	dest_cpu = p->sched_class->select_task_rq(p, task_cpu(p), SD_BALANCE_EXEC, 0); : 
2
strstr : while : 	dest_cpu = p->sched_class->select_task_rq(p, task_cpu(p), SD_BALANCE_EXEC, 0); : 
2
str : 	if (dest_cpu == smp_processor_id())[36]
strstr : INIT : 	if (dest_cpu == smp_processor_id()) : 
2
strstr : if : 	if (dest_cpu == smp_processor_id()) : 
2
strstr : for : 	if (dest_cpu == smp_processor_id()) : 
2
strstr : while : 	if (dest_cpu == smp_processor_id()) : 
2
str : 		goto unlock;[14]
strstr : INIT : 		goto unlock; : 
2
strstr : if : 		goto unlock; : 
2
strstr : for : 		goto unlock; : 
2
strstr : while : 		goto unlock; : 
2
str : 	if (likely(cpu_active(dest_cpu))) {[36]
strstr : INIT : 	if (likely(cpu_active(dest_cpu))) { : 
2
strstr : if : 	if (likely(cpu_active(dest_cpu))) { : 
2
strstr : for : 	if (likely(cpu_active(dest_cpu))) { : 
2
strstr : while : 	if (likely(cpu_active(dest_cpu))) { : 
2
str : 		struct migration_arg arg = { p, dest_cpu };[45]
strstr : INIT : 		struct migration_arg arg = { p, dest_cpu }; : 
2
strstr : if : 		struct migration_arg arg = { p, dest_cpu }; : 
2
strstr : for : 		struct migration_arg arg = { p, dest_cpu }; : 
2
strstr : while : 		struct migration_arg arg = { p, dest_cpu }; : 
2
str : 		raw_spin_unlock_irqrestore(&p->pi_lock, flags);[49]
strstr : INIT : 		raw_spin_unlock_irqrestore(&p->pi_lock, flags); : 
2
strstr : if : 		raw_spin_unlock_irqrestore(&p->pi_lock, flags); : 
2
strstr : for : 		raw_spin_unlock_irqrestore(&p->pi_lock, flags); : 
2
strstr : while : 		raw_spin_unlock_irqrestore(&p->pi_lock, flags); : 
2
str : 		stop_one_cpu(task_cpu(p), migration_cpu_stop, &arg);[54]
strstr : INIT : 		stop_one_cpu(task_cpu(p), migration_cpu_stop, &arg); : 
2
strstr : if : 		stop_one_cpu(task_cpu(p), migration_cpu_stop, &arg); : 
2
strstr : for : 		stop_one_cpu(task_cpu(p), migration_cpu_stop, &arg); : 
2
strstr : while : 		stop_one_cpu(task_cpu(p), migration_cpu_stop, &arg); : 
2
str : 		return;[9]
strstr : INIT : 		return; : 
2
strstr : if : 		return; : 
2
strstr : for : 		return; : 
2
strstr : while : 		return; : 
2
str : unlock:[7]
strstr : INIT : unlock: : 
2
strstr : if : unlock: : 
2
strstr : for : unlock: : 
2
strstr : while : unlock: : 
2
str : 	raw_spin_unlock_irqrestore(&p->pi_lock, flags);[48]
strstr : INIT : 	raw_spin_unlock_irqrestore(&p->pi_lock, flags); : 
2
strstr : if : 	raw_spin_unlock_irqrestore(&p->pi_lock, flags); : 
2
strstr : for : 	raw_spin_unlock_irqrestore(&p->pi_lock, flags); : 
2
strstr : while : 	raw_spin_unlock_irqrestore(&p->pi_lock, flags); : 
2
str : #endif[6]
strstr : INIT : #endif : 
2
strstr : if : #endif : 
2
strstr : for : #endif : 
2
strstr : while : #endif : 
2
str : DEFINE_PER_CPU(struct kernel_stat, kstat);[42]
strstr : INIT : DEFINE_PER_CPU(struct kernel_stat, kstat); : 
2
strstr : if : DEFINE_PER_CPU(struct kernel_stat, kstat); : 
2
strstr : for : DEFINE_PER_CPU(struct kernel_stat, kstat); : 
2
strstr : while : DEFINE_PER_CPU(struct kernel_stat, kstat); : 
2
str : DEFINE_PER_CPU(struct kernel_cpustat, kernel_cpustat);[54]
strstr : INIT : DEFINE_PER_CPU(struct kernel_cpustat, kernel_cpustat); : 
2
strstr : if : DEFINE_PER_CPU(struct kernel_cpustat, kernel_cpustat); : 
2
strstr : for : DEFINE_PER_CPU(struct kernel_cpustat, kernel_cpustat); : 
2
strstr : while : DEFINE_PER_CPU(struct kernel_cpustat, kernel_cpustat); : 
2
str : EXPORT_PER_CPU_SYMBOL(kstat);[29]
strstr : INIT : EXPORT_PER_CPU_SYMBOL(kstat); : 
2
strstr : if : EXPORT_PER_CPU_SYMBOL(kstat); : 
2
strstr : for : EXPORT_PER_CPU_SYMBOL(kstat); : 
2
strstr : while : EXPORT_PER_CPU_SYMBOL(kstat); : 
2
str : EXPORT_PER_CPU_SYMBOL(kernel_cpustat);[38]
strstr : INIT : EXPORT_PER_CPU_SYMBOL(kernel_cpustat); : 
2
strstr : if : EXPORT_PER_CPU_SYMBOL(kernel_cpustat); : 
2
strstr : for : EXPORT_PER_CPU_SYMBOL(kernel_cpustat); : 
2
strstr : while : EXPORT_PER_CPU_SYMBOL(kernel_cpustat); : 
2
str :  * Return any ns on the sched_clock that have not yet been accounted in[71]
strstr : INIT :  * Return any ns on the sched_clock that have not yet been accounted in : 
2
strstr : if :  * Return any ns on the sched_clock that have not yet been accounted in : 
2
strstr : for :  * Return any ns on the sched_clock that have not yet been accounted in : 
2
strstr : while :  * Return any ns on the sched_clock that have not yet been accounted in : 
2
str :  * @p in case that task is currently running.[45]
strstr : INIT :  * @p in case that task is currently running. : 
2
strstr : if :  * @p in case that task is currently running. : 
2
strstr : for :  * @p in case that task is currently running. : 
2
strstr : while :  * @p in case that task is currently running. : 
2
str :  * Called with task_rq_lock() held on @rq.[42]
strstr : INIT :  * Called with task_rq_lock() held on @rq. : 
2
strstr : if :  * Called with task_rq_lock() held on @rq. : 
2
strstr : for :  * Called with task_rq_lock() held on @rq. : 
2
strstr : while :  * Called with task_rq_lock() held on @rq. : 
2
str :  */[3]
strstr : INIT :  */ : 
2
strstr : if :  */ : 
2
strstr : for :  */ : 
2
strstr : while :  */ : 
2
str : static u64 do_task_delta_exec(struct task_struct *p, struct rq *rq)[67]
strstr : INIT : static u64 do_task_delta_exec(struct task_struct *p, struct rq *rq) : 
2
strstr : if : static u64 do_task_delta_exec(struct task_struct *p, struct rq *rq) : 
2
strstr : for : static u64 do_task_delta_exec(struct task_struct *p, struct rq *rq) : 
2
strstr : while : static u64 do_task_delta_exec(struct task_struct *p, struct rq *rq) : 
2
str : 	u64 ns = 0;[12]
strstr : INIT : 	u64 ns = 0; : 
2
strstr : if : 	u64 ns = 0; : 
2
strstr : for : 	u64 ns = 0; : 
2
strstr : while : 	u64 ns = 0; : 
2
str : 	if (task_current(rq, p)) {[27]
strstr : INIT : 	if (task_current(rq, p)) { : 
2
strstr : if : 	if (task_current(rq, p)) { : 
2
strstr : for : 	if (task_current(rq, p)) { : 
2
strstr : while : 	if (task_current(rq, p)) { : 
2
str : 		update_rq_clock(rq);[22]
strstr : INIT : 		update_rq_clock(rq); : 
2
strstr : if : 		update_rq_clock(rq); : 
2
strstr : for : 		update_rq_clock(rq); : 
2
strstr : while : 		update_rq_clock(rq); : 
2
str : 		ns = rq_clock_task(rq) - p->se.exec_start;[44]
strstr : INIT : 		ns = rq_clock_task(rq) - p->se.exec_start; : 
2
strstr : if : 		ns = rq_clock_task(rq) - p->se.exec_start; : 
2
strstr : for : 		ns = rq_clock_task(rq) - p->se.exec_start; : 
2
strstr : while : 		ns = rq_clock_task(rq) - p->se.exec_start; : 
2
str : 		if ((s64)ns < 0)[18]
strstr : INIT : 		if ((s64)ns < 0) : 
2
strstr : if : 		if ((s64)ns < 0) : 
2
strstr : for : 		if ((s64)ns < 0) : 
2
strstr : while : 		if ((s64)ns < 0) : 
2
str : 			ns = 0;[10]
strstr : INIT : 			ns = 0; : 
2
strstr : if : 			ns = 0; : 
2
strstr : for : 			ns = 0; : 
2
strstr : while : 			ns = 0; : 
2
str : 	return ns;[11]
strstr : INIT : 	return ns; : 
2
strstr : if : 	return ns; : 
2
strstr : for : 	return ns; : 
2
strstr : while : 	return ns; : 
2
str : unsigned long long task_delta_exec(struct task_struct *p)[57]
strstr : INIT : unsigned long long task_delta_exec(struct task_struct *p) : 
2
strstr : if : unsigned long long task_delta_exec(struct task_struct *p) : 
2
strstr : for : unsigned long long task_delta_exec(struct task_struct *p) : 
2
strstr : while : unsigned long long task_delta_exec(struct task_struct *p) : 
2
str : 	unsigned long flags;[21]
strstr : INIT : 	unsigned long flags; : 
2
strstr : if : 	unsigned long flags; : 
2
strstr : for : 	unsigned long flags; : 
2
strstr : while : 	unsigned long flags; : 
2
str : 	struct rq *rq;[15]
strstr : INIT : 	struct rq *rq; : 
2
strstr : if : 	struct rq *rq; : 
2
strstr : for : 	struct rq *rq; : 
2
strstr : while : 	struct rq *rq; : 
2
str : 	u64 ns = 0;[12]
strstr : INIT : 	u64 ns = 0; : 
2
strstr : if : 	u64 ns = 0; : 
2
strstr : for : 	u64 ns = 0; : 
2
strstr : while : 	u64 ns = 0; : 
2
str : 	rq = task_rq_lock(p, &flags);[30]
strstr : INIT : 	rq = task_rq_lock(p, &flags); : 
2
strstr : if : 	rq = task_rq_lock(p, &flags); : 
2
strstr : for : 	rq = task_rq_lock(p, &flags); : 
2
strstr : while : 	rq = task_rq_lock(p, &flags); : 
2
str : 	ns = do_task_delta_exec(p, rq);[32]
strstr : INIT : 	ns = do_task_delta_exec(p, rq); : 
2
strstr : if : 	ns = do_task_delta_exec(p, rq); : 
2
strstr : for : 	ns = do_task_delta_exec(p, rq); : 
2
strstr : while : 	ns = do_task_delta_exec(p, rq); : 
2
str : 	task_rq_unlock(rq, p, &flags);[31]
strstr : INIT : 	task_rq_unlock(rq, p, &flags); : 
2
strstr : if : 	task_rq_unlock(rq, p, &flags); : 
2
strstr : for : 	task_rq_unlock(rq, p, &flags); : 
2
strstr : while : 	task_rq_unlock(rq, p, &flags); : 
2
str : 	return ns;[11]
strstr : INIT : 	return ns; : 
2
strstr : if : 	return ns; : 
2
strstr : for : 	return ns; : 
2
strstr : while : 	return ns; : 
2
str :  * Return accounted runtime for the task.[41]
strstr : INIT :  * Return accounted runtime for the task. : 
2
strstr : if :  * Return accounted runtime for the task. : 
2
strstr : for :  * Return accounted runtime for the task. : 
2
strstr : while :  * Return accounted runtime for the task. : 
2
str :  * In case the task is currently running, return the runtime plus current's[75]
strstr : INIT :  * In case the task is currently running, return the runtime plus current's : 
2
strstr : if :  * In case the task is currently running, return the runtime plus current's : 
2
strstr : for :  * In case the task is currently running, return the runtime plus current's : 
2
strstr : while :  * In case the task is currently running, return the runtime plus current's : 
2
str :  * pending runtime that have not been accounted yet.[52]
strstr : INIT :  * pending runtime that have not been accounted yet. : 
2
strstr : if :  * pending runtime that have not been accounted yet. : 
2
strstr : for :  * pending runtime that have not been accounted yet. : 
2
strstr : while :  * pending runtime that have not been accounted yet. : 
2
str :  */[3]
strstr : INIT :  */ : 
2
strstr : if :  */ : 
2
strstr : for :  */ : 
2
strstr : while :  */ : 
2
str : unsigned long long task_sched_runtime(struct task_struct *p)[60]
strstr : INIT : unsigned long long task_sched_runtime(struct task_struct *p) : 
2
strstr : if : unsigned long long task_sched_runtime(struct task_struct *p) : 
2
strstr : for : unsigned long long task_sched_runtime(struct task_struct *p) : 
2
strstr : while : unsigned long long task_sched_runtime(struct task_struct *p) : 
2
str : 	unsigned long flags;[21]
strstr : INIT : 	unsigned long flags; : 
2
strstr : if : 	unsigned long flags; : 
2
strstr : for : 	unsigned long flags; : 
2
strstr : while : 	unsigned long flags; : 
2
str : 	struct rq *rq;[15]
strstr : INIT : 	struct rq *rq; : 
2
strstr : if : 	struct rq *rq; : 
2
strstr : for : 	struct rq *rq; : 
2
strstr : while : 	struct rq *rq; : 
2
str : 	u64 ns = 0;[12]
strstr : INIT : 	u64 ns = 0; : 
2
strstr : if : 	u64 ns = 0; : 
2
strstr : for : 	u64 ns = 0; : 
2
strstr : while : 	u64 ns = 0; : 
2
str : #if defined(CONFIG_64BIT) && defined(CONFIG_SMP)[48]
strstr : INIT : #if defined(CONFIG_64BIT) && defined(CONFIG_SMP) : 
2
strstr : if : #if defined(CONFIG_64BIT) && defined(CONFIG_SMP) : 
2
strstr : for : #if defined(CONFIG_64BIT) && defined(CONFIG_SMP) : 
2
strstr : while : #if defined(CONFIG_64BIT) && defined(CONFIG_SMP) : 
2
str : 	/*[3]
strstr : INIT : 	/* : 
2
strstr : if : 	/* : 
2
strstr : for : 	/* : 
2
strstr : while : 	/* : 
2
str : 	 * 64-bit doesn't need locks to atomically read a 64bit value.[63]
strstr : INIT : 	 * 64-bit doesn't need locks to atomically read a 64bit value. : 
2
strstr : if : 	 * 64-bit doesn't need locks to atomically read a 64bit value. : 
2
strstr : for : 	 * 64-bit doesn't need locks to atomically read a 64bit value. : 
2
strstr : while : 	 * 64-bit doesn't need locks to atomically read a 64bit value. : 
2
str : 	 * So we have a optimization chance when the task's delta_exec is 0.[69]
strstr : INIT : 	 * So we have a optimization chance when the task's delta_exec is 0. : 
2
strstr : if : 	 * So we have a optimization chance when the task's delta_exec is 0. : 
2
strstr : for : 	 * So we have a optimization chance when the task's delta_exec is 0. : 
2
strstr : while : 	 * So we have a optimization chance when the task's delta_exec is 0. : 
2
str : 	 * Reading ->on_cpu is racy, but this is ok.[45]
strstr : INIT : 	 * Reading ->on_cpu is racy, but this is ok. : 
2
strstr : if : 	 * Reading ->on_cpu is racy, but this is ok. : 
2
strstr : for : 	 * Reading ->on_cpu is racy, but this is ok. : 
2
strstr : while : 	 * Reading ->on_cpu is racy, but this is ok. : 
2
str : 	 *[3]
strstr : INIT : 	 * : 
2
strstr : if : 	 * : 
2
strstr : for : 	 * : 
2
strstr : while : 	 * : 
2
str : 	 * If we race with it leaving cpu, we'll take a lock. So we're correct.[72]
strstr : INIT : 	 * If we race with it leaving cpu, we'll take a lock. So we're correct. : 
2
strstr : if : 	 * If we race with it leaving cpu, we'll take a lock. So we're correct. : 
2
strstr : for : 	 * If we race with it leaving cpu, we'll take a lock. So we're correct. : 
2
strstr : while : 	 * If we race with it leaving cpu, we'll take a lock. So we're correct. : 
2
str : 	 * If we race with it entering cpu, unaccounted time is 0. This is[67]
strstr : INIT : 	 * If we race with it entering cpu, unaccounted time is 0. This is : 
2
strstr : if : 	 * If we race with it entering cpu, unaccounted time is 0. This is : 
2
strstr : for : 	 * If we race with it entering cpu, unaccounted time is 0. This is : 
2
strstr : while : 	 * If we race with it entering cpu, unaccounted time is 0. This is : 
2
str : 	 * indistinguishable from the read occurring a few cycles earlier.[67]
strstr : INIT : 	 * indistinguishable from the read occurring a few cycles earlier. : 
2
strstr : if : 	 * indistinguishable from the read occurring a few cycles earlier. : 
2
strstr : for : 	 * indistinguishable from the read occurring a few cycles earlier. : 
2
strstr : while : 	 * indistinguishable from the read occurring a few cycles earlier. : 
2
str : 	 */[4]
strstr : INIT : 	 */ : 
2
strstr : if : 	 */ : 
2
strstr : for : 	 */ : 
2
strstr : while : 	 */ : 
2
str : 	if (!p->on_cpu)[16]
strstr : INIT : 	if (!p->on_cpu) : 
2
strstr : if : 	if (!p->on_cpu) : 
2
strstr : for : 	if (!p->on_cpu) : 
2
strstr : while : 	if (!p->on_cpu) : 
2
str : 		return p->se.sum_exec_runtime;[32]
strstr : INIT : 		return p->se.sum_exec_runtime; : 
2
strstr : if : 		return p->se.sum_exec_runtime; : 
2
strstr : for : 		return p->se.sum_exec_runtime; : 
2
strstr : while : 		return p->se.sum_exec_runtime; : 
2
str : #endif[6]
strstr : INIT : #endif : 
2
strstr : if : #endif : 
2
strstr : for : #endif : 
2
strstr : while : #endif : 
2
str : 	rq = task_rq_lock(p, &flags);[30]
strstr : INIT : 	rq = task_rq_lock(p, &flags); : 
2
strstr : if : 	rq = task_rq_lock(p, &flags); : 
2
strstr : for : 	rq = task_rq_lock(p, &flags); : 
2
strstr : while : 	rq = task_rq_lock(p, &flags); : 
2
str : 	ns = p->se.sum_exec_runtime + do_task_delta_exec(p, rq);[57]
strstr : INIT : 	ns = p->se.sum_exec_runtime + do_task_delta_exec(p, rq); : 
2
strstr : if : 	ns = p->se.sum_exec_runtime + do_task_delta_exec(p, rq); : 
2
strstr : for : 	ns = p->se.sum_exec_runtime + do_task_delta_exec(p, rq); : 
2
strstr : while : 	ns = p->se.sum_exec_runtime + do_task_delta_exec(p, rq); : 
2
str : 	task_rq_unlock(rq, p, &flags);[31]
strstr : INIT : 	task_rq_unlock(rq, p, &flags); : 
2
strstr : if : 	task_rq_unlock(rq, p, &flags); : 
2
strstr : for : 	task_rq_unlock(rq, p, &flags); : 
2
strstr : while : 	task_rq_unlock(rq, p, &flags); : 
2
str : 	return ns;[11]
strstr : INIT : 	return ns; : 
2
strstr : if : 	return ns; : 
2
strstr : for : 	return ns; : 
2
strstr : while : 	return ns; : 
2
str :  * This function gets called by the timer code, with HZ frequency.[66]
strstr : INIT :  * This function gets called by the timer code, with HZ frequency. : 
2
strstr : if :  * This function gets called by the timer code, with HZ frequency. : 
2
strstr : for :  * This function gets called by the timer code, with HZ frequency. : 
2
strstr : while :  * This function gets called by the timer code, with HZ frequency. : 
2
str :  * We call it with interrupts disabled.[39]
strstr : INIT :  * We call it with interrupts disabled. : 
2
strstr : if :  * We call it with interrupts disabled. : 
2
strstr : for :  * We call it with interrupts disabled. : 
2
strstr : while :  * We call it with interrupts disabled. : 
2
str :  */[3]
strstr : INIT :  */ : 
2
strstr : if :  */ : 
2
strstr : for :  */ : 
2
strstr : while :  */ : 
2
str : void scheduler_tick(void)[25]
strstr : INIT : void scheduler_tick(void) : 
2
strstr : if : void scheduler_tick(void) : 
2
strstr : for : void scheduler_tick(void) : 
2
strstr : while : void scheduler_tick(void) : 
2
str : 	int cpu = smp_processor_id();[30]
strstr : INIT : 	int cpu = smp_processor_id(); : 
2
strstr : if : 	int cpu = smp_processor_id(); : 
2
strstr : for : 	int cpu = smp_processor_id(); : 
2
strstr : while : 	int cpu = smp_processor_id(); : 
2
str : 	struct rq *rq = cpu_rq(cpu);[29]
strstr : INIT : 	struct rq *rq = cpu_rq(cpu); : 
2
strstr : if : 	struct rq *rq = cpu_rq(cpu); : 
2
strstr : for : 	struct rq *rq = cpu_rq(cpu); : 
2
strstr : while : 	struct rq *rq = cpu_rq(cpu); : 
2
str : 	struct task_struct *curr = rq->curr;[37]
strstr : INIT : 	struct task_struct *curr = rq->curr; : 
2
strstr : if : 	struct task_struct *curr = rq->curr; : 
2
strstr : for : 	struct task_struct *curr = rq->curr; : 
2
strstr : while : 	struct task_struct *curr = rq->curr; : 
2
str : 	sched_clock_tick();[20]
strstr : INIT : 	sched_clock_tick(); : 
2
strstr : if : 	sched_clock_tick(); : 
2
strstr : for : 	sched_clock_tick(); : 
2
strstr : while : 	sched_clock_tick(); : 
2
str : 	raw_spin_lock(&rq->lock);[26]
strstr : INIT : 	raw_spin_lock(&rq->lock); : 
2
strstr : if : 	raw_spin_lock(&rq->lock); : 
2
strstr : for : 	raw_spin_lock(&rq->lock); : 
2
strstr : while : 	raw_spin_lock(&rq->lock); : 
2
str : 	update_rq_clock(rq);[21]
strstr : INIT : 	update_rq_clock(rq); : 
2
strstr : if : 	update_rq_clock(rq); : 
2
strstr : for : 	update_rq_clock(rq); : 
2
strstr : while : 	update_rq_clock(rq); : 
2
str : 	curr->sched_class->task_tick(rq, curr, 0);[43]
strstr : INIT : 	curr->sched_class->task_tick(rq, curr, 0); : 
2
strstr : if : 	curr->sched_class->task_tick(rq, curr, 0); : 
2
strstr : for : 	curr->sched_class->task_tick(rq, curr, 0); : 
2
strstr : while : 	curr->sched_class->task_tick(rq, curr, 0); : 
2
str : 	update_cpu_load_active(rq);[28]
strstr : INIT : 	update_cpu_load_active(rq); : 
2
strstr : if : 	update_cpu_load_active(rq); : 
2
strstr : for : 	update_cpu_load_active(rq); : 
2
strstr : while : 	update_cpu_load_active(rq); : 
2
str : 	raw_spin_unlock(&rq->lock);[28]
strstr : INIT : 	raw_spin_unlock(&rq->lock); : 
2
strstr : if : 	raw_spin_unlock(&rq->lock); : 
2
strstr : for : 	raw_spin_unlock(&rq->lock); : 
2
strstr : while : 	raw_spin_unlock(&rq->lock); : 
2
str : 	perf_event_task_tick();[24]
strstr : INIT : 	perf_event_task_tick(); : 
2
strstr : if : 	perf_event_task_tick(); : 
2
strstr : for : 	perf_event_task_tick(); : 
2
strstr : while : 	perf_event_task_tick(); : 
2
str : #ifdef CONFIG_SMP[17]
strstr : INIT : #ifdef CONFIG_SMP : 
2
strstr : if : #ifdef CONFIG_SMP : 
2
strstr : for : #ifdef CONFIG_SMP : 
2
strstr : while : #ifdef CONFIG_SMP : 
2
str : 	rq->idle_balance = idle_cpu(cpu);[34]
strstr : INIT : 	rq->idle_balance = idle_cpu(cpu); : 
2
strstr : if : 	rq->idle_balance = idle_cpu(cpu); : 
2
strstr : for : 	rq->idle_balance = idle_cpu(cpu); : 
2
strstr : while : 	rq->idle_balance = idle_cpu(cpu); : 
2
str : 	trigger_load_balance(rq);[26]
strstr : INIT : 	trigger_load_balance(rq); : 
2
strstr : if : 	trigger_load_balance(rq); : 
2
strstr : for : 	trigger_load_balance(rq); : 
2
strstr : while : 	trigger_load_balance(rq); : 
2
str : #endif[6]
strstr : INIT : #endif : 
2
strstr : if : #endif : 
2
strstr : for : #endif : 
2
strstr : while : #endif : 
2
str : 	rq_last_tick_reset(rq);[24]
strstr : INIT : 	rq_last_tick_reset(rq); : 
2
strstr : if : 	rq_last_tick_reset(rq); : 
2
strstr : for : 	rq_last_tick_reset(rq); : 
2
strstr : while : 	rq_last_tick_reset(rq); : 
2
str : #ifdef CONFIG_NO_HZ_FULL[24]
strstr : INIT : #ifdef CONFIG_NO_HZ_FULL : 
2
strstr : if : #ifdef CONFIG_NO_HZ_FULL : 
2
strstr : for : #ifdef CONFIG_NO_HZ_FULL : 
2
strstr : while : #ifdef CONFIG_NO_HZ_FULL : 
2
str : /**[3]
strstr : INIT : /** : 
2
strstr : if : /** : 
2
strstr : for : /** : 
2
strstr : while : /** : 
2
str :  * scheduler_tick_max_deferment[31]
strstr : INIT :  * scheduler_tick_max_deferment : 
2
strstr : if :  * scheduler_tick_max_deferment : 
2
strstr : for :  * scheduler_tick_max_deferment : 
2
strstr : while :  * scheduler_tick_max_deferment : 
2
str :  * Keep at least one tick per second when a single[50]
strstr : INIT :  * Keep at least one tick per second when a single : 
2
strstr : if :  * Keep at least one tick per second when a single : 
2
strstr : for :  * Keep at least one tick per second when a single : 
2
strstr : while :  * Keep at least one tick per second when a single : 
2
str :  * active task is running because the scheduler doesn't[55]
strstr : INIT :  * active task is running because the scheduler doesn't : 
2
strstr : if :  * active task is running because the scheduler doesn't : 
2
strstr : for :  * active task is running because the scheduler doesn't : 
2
strstr : while :  * active task is running because the scheduler doesn't : 
2
str :  * yet completely support full dynticks environment.[52]
strstr : INIT :  * yet completely support full dynticks environment. : 
2
strstr : if :  * yet completely support full dynticks environment. : 
2
strstr : for :  * yet completely support full dynticks environment. : 
2
strstr : while :  * yet completely support full dynticks environment. : 
2
str :  * This makes sure that uptime, CFS vruntime, load[50]
strstr : INIT :  * This makes sure that uptime, CFS vruntime, load : 
2
strstr : if :  * This makes sure that uptime, CFS vruntime, load : 
2
strstr : for :  * This makes sure that uptime, CFS vruntime, load : 
2
strstr : while :  * This makes sure that uptime, CFS vruntime, load : 
2
str :  * balancing, etc... continue to move forward, even[51]
strstr : INIT :  * balancing, etc... continue to move forward, even : 
2
strstr : if :  * balancing, etc... continue to move forward, even : 
2
strstr : for :  * balancing, etc... continue to move forward, even : 
2
strstr : while :  * balancing, etc... continue to move forward, even : 
2
str :  * with a very low granularity.[31]
strstr : INIT :  * with a very low granularity. : 
2
strstr : if :  * with a very low granularity. : 
2
strstr : for :  * with a very low granularity. : 
2
strstr : while :  * with a very low granularity. : 
2
str :  * Return: Maximum deferment in nanoseconds.[44]
strstr : INIT :  * Return: Maximum deferment in nanoseconds. : 
2
strstr : if :  * Return: Maximum deferment in nanoseconds. : 
2
strstr : for :  * Return: Maximum deferment in nanoseconds. : 
2
strstr : while :  * Return: Maximum deferment in nanoseconds. : 
2
str :  */[3]
strstr : INIT :  */ : 
2
strstr : if :  */ : 
2
strstr : for :  */ : 
2
strstr : while :  */ : 
2
str : u64 scheduler_tick_max_deferment(void)[38]
strstr : INIT : u64 scheduler_tick_max_deferment(void) : 
2
strstr : if : u64 scheduler_tick_max_deferment(void) : 
2
strstr : for : u64 scheduler_tick_max_deferment(void) : 
2
strstr : while : u64 scheduler_tick_max_deferment(void) : 
2
str : 	struct rq *rq = this_rq();[27]
strstr : INIT : 	struct rq *rq = this_rq(); : 
2
strstr : if : 	struct rq *rq = this_rq(); : 
2
strstr : for : 	struct rq *rq = this_rq(); : 
2
strstr : while : 	struct rq *rq = this_rq(); : 
2
str : 	unsigned long next, now = ACCESS_ONCE(jiffies);[48]
strstr : INIT : 	unsigned long next, now = ACCESS_ONCE(jiffies); : 
2
strstr : if : 	unsigned long next, now = ACCESS_ONCE(jiffies); : 
2
strstr : for : 	unsigned long next, now = ACCESS_ONCE(jiffies); : 
2
strstr : while : 	unsigned long next, now = ACCESS_ONCE(jiffies); : 
2
str : 	next = rq->last_sched_tick + HZ;[33]
strstr : INIT : 	next = rq->last_sched_tick + HZ; : 
2
strstr : if : 	next = rq->last_sched_tick + HZ; : 
2
strstr : for : 	next = rq->last_sched_tick + HZ; : 
2
strstr : while : 	next = rq->last_sched_tick + HZ; : 
2
str : 	if (time_before_eq(next, now))[31]
strstr : INIT : 	if (time_before_eq(next, now)) : 
2
strstr : if : 	if (time_before_eq(next, now)) : 
2
strstr : for : 	if (time_before_eq(next, now)) : 
2
strstr : while : 	if (time_before_eq(next, now)) : 
2
str : 		return 0;[11]
strstr : INIT : 		return 0; : 
2
strstr : if : 		return 0; : 
2
strstr : for : 		return 0; : 
2
strstr : while : 		return 0; : 
2
str : 	return jiffies_to_nsecs(next - now);[37]
strstr : INIT : 	return jiffies_to_nsecs(next - now); : 
2
strstr : if : 	return jiffies_to_nsecs(next - now); : 
2
strstr : for : 	return jiffies_to_nsecs(next - now); : 
2
strstr : while : 	return jiffies_to_nsecs(next - now); : 
2
str : #endif[6]
strstr : INIT : #endif : 
2
strstr : if : #endif : 
2
strstr : for : #endif : 
2
strstr : while : #endif : 
2
str : notrace unsigned long get_parent_ip(unsigned long addr)[55]
strstr : INIT : notrace unsigned long get_parent_ip(unsigned long addr) : 
2
strstr : if : notrace unsigned long get_parent_ip(unsigned long addr) : 
2
strstr : for : notrace unsigned long get_parent_ip(unsigned long addr) : 
2
strstr : while : notrace unsigned long get_parent_ip(unsigned long addr) : 
2
str : 	if (in_lock_functions(addr)) {[31]
strstr : INIT : 	if (in_lock_functions(addr)) { : 
2
strstr : if : 	if (in_lock_functions(addr)) { : 
2
strstr : for : 	if (in_lock_functions(addr)) { : 
2
strstr : while : 	if (in_lock_functions(addr)) { : 
2
str : 		addr = CALLER_ADDR2;[22]
strstr : INIT : 		addr = CALLER_ADDR2; : 
2
strstr : if : 		addr = CALLER_ADDR2; : 
2
strstr : for : 		addr = CALLER_ADDR2; : 
2
strstr : while : 		addr = CALLER_ADDR2; : 
2
str : 		if (in_lock_functions(addr))[30]
strstr : INIT : 		if (in_lock_functions(addr)) : 
2
strstr : if : 		if (in_lock_functions(addr)) : 
2
strstr : for : 		if (in_lock_functions(addr)) : 
2
strstr : while : 		if (in_lock_functions(addr)) : 
2
str : 			addr = CALLER_ADDR3;[23]
strstr : INIT : 			addr = CALLER_ADDR3; : 
2
strstr : if : 			addr = CALLER_ADDR3; : 
2
strstr : for : 			addr = CALLER_ADDR3; : 
2
strstr : while : 			addr = CALLER_ADDR3; : 
2
str : 	return addr;[13]
strstr : INIT : 	return addr; : 
2
strstr : if : 	return addr; : 
2
strstr : for : 	return addr; : 
2
strstr : while : 	return addr; : 
2
str : #if defined(CONFIG_PREEMPT) && (defined(CONFIG_DEBUG_PREEMPT) || \[66]
strstr : INIT : #if defined(CONFIG_PREEMPT) && (defined(CONFIG_DEBUG_PREEMPT) || \ : 
2
strstr : if : #if defined(CONFIG_PREEMPT) && (defined(CONFIG_DEBUG_PREEMPT) || \ : 
2
strstr : for : #if defined(CONFIG_PREEMPT) && (defined(CONFIG_DEBUG_PREEMPT) || \ : 
2
strstr : while : #if defined(CONFIG_PREEMPT) && (defined(CONFIG_DEBUG_PREEMPT) || \ : 
2
str : 				defined(CONFIG_PREEMPT_TRACER))[35]
strstr : INIT : 				defined(CONFIG_PREEMPT_TRACER)) : 
2
strstr : if : 				defined(CONFIG_PREEMPT_TRACER)) : 
2
strstr : for : 				defined(CONFIG_PREEMPT_TRACER)) : 
2
strstr : while : 				defined(CONFIG_PREEMPT_TRACER)) : 
2
str : void __kprobes preempt_count_add(int val)[41]
strstr : INIT : void __kprobes preempt_count_add(int val) : 
2
strstr : if : void __kprobes preempt_count_add(int val) : 
2
strstr : for : void __kprobes preempt_count_add(int val) : 
2
strstr : while : void __kprobes preempt_count_add(int val) : 
2
str : #ifdef CONFIG_DEBUG_PREEMPT[27]
strstr : INIT : #ifdef CONFIG_DEBUG_PREEMPT : 
2
strstr : if : #ifdef CONFIG_DEBUG_PREEMPT : 
2
strstr : for : #ifdef CONFIG_DEBUG_PREEMPT : 
2
strstr : while : #ifdef CONFIG_DEBUG_PREEMPT : 
2
str : 	/*[3]
strstr : INIT : 	/* : 
2
strstr : if : 	/* : 
2
strstr : for : 	/* : 
2
strstr : while : 	/* : 
2
str : 	 * Underflow?[14]
strstr : INIT : 	 * Underflow? : 
2
strstr : if : 	 * Underflow? : 
2
strstr : for : 	 * Underflow? : 
2
strstr : while : 	 * Underflow? : 
2
str : 	 */[4]
strstr : INIT : 	 */ : 
2
strstr : if : 	 */ : 
2
strstr : for : 	 */ : 
2
strstr : while : 	 */ : 
2
str : 	if (DEBUG_LOCKS_WARN_ON((preempt_count() < 0)))[48]
strstr : INIT : 	if (DEBUG_LOCKS_WARN_ON((preempt_count() < 0))) : 
2
strstr : if : 	if (DEBUG_LOCKS_WARN_ON((preempt_count() < 0))) : 
2
strstr : for : 	if (DEBUG_LOCKS_WARN_ON((preempt_count() < 0))) : 
2
strstr : while : 	if (DEBUG_LOCKS_WARN_ON((preempt_count() < 0))) : 
2
str : 		return;[9]
strstr : INIT : 		return; : 
2
strstr : if : 		return; : 
2
strstr : for : 		return; : 
2
strstr : while : 		return; : 
2
str : #endif[6]
strstr : INIT : #endif : 
2
strstr : if : #endif : 
2
strstr : for : #endif : 
2
strstr : while : #endif : 
2
str : 	__preempt_count_add(val);[26]
strstr : INIT : 	__preempt_count_add(val); : 
2
strstr : if : 	__preempt_count_add(val); : 
2
strstr : for : 	__preempt_count_add(val); : 
2
strstr : while : 	__preempt_count_add(val); : 
2
str : #ifdef CONFIG_DEBUG_PREEMPT[27]
strstr : INIT : #ifdef CONFIG_DEBUG_PREEMPT : 
2
strstr : if : #ifdef CONFIG_DEBUG_PREEMPT : 
2
strstr : for : #ifdef CONFIG_DEBUG_PREEMPT : 
2
strstr : while : #ifdef CONFIG_DEBUG_PREEMPT : 
2
str : 	/*[3]
strstr : INIT : 	/* : 
2
strstr : if : 	/* : 
2
strstr : for : 	/* : 
2
strstr : while : 	/* : 
2
str : 	 * Spinlock count overflowing soon?[36]
strstr : INIT : 	 * Spinlock count overflowing soon? : 
2
strstr : if : 	 * Spinlock count overflowing soon? : 
2
strstr : for : 	 * Spinlock count overflowing soon? : 
2
strstr : while : 	 * Spinlock count overflowing soon? : 
2
str : 	 */[4]
strstr : INIT : 	 */ : 
2
strstr : if : 	 */ : 
2
strstr : for : 	 */ : 
2
strstr : while : 	 */ : 
2
str : 	DEBUG_LOCKS_WARN_ON((preempt_count() & PREEMPT_MASK) >=[56]
strstr : INIT : 	DEBUG_LOCKS_WARN_ON((preempt_count() & PREEMPT_MASK) >= : 
2
strstr : if : 	DEBUG_LOCKS_WARN_ON((preempt_count() & PREEMPT_MASK) >= : 
2
strstr : for : 	DEBUG_LOCKS_WARN_ON((preempt_count() & PREEMPT_MASK) >= : 
2
strstr : while : 	DEBUG_LOCKS_WARN_ON((preempt_count() & PREEMPT_MASK) >= : 
2
str : 				PREEMPT_MASK - 10);[23]
strstr : INIT : 				PREEMPT_MASK - 10); : 
2
strstr : if : 				PREEMPT_MASK - 10); : 
2
strstr : for : 				PREEMPT_MASK - 10); : 
2
strstr : while : 				PREEMPT_MASK - 10); : 
2
str : #endif[6]
strstr : INIT : #endif : 
2
strstr : if : #endif : 
2
strstr : for : #endif : 
2
strstr : while : #endif : 
2
str : 	if (preempt_count() == val)[28]
strstr : INIT : 	if (preempt_count() == val) : 
2
strstr : if : 	if (preempt_count() == val) : 
2
strstr : for : 	if (preempt_count() == val) : 
2
strstr : while : 	if (preempt_count() == val) : 
2
str : 		trace_preempt_off(CALLER_ADDR0, get_parent_ip(CALLER_ADDR1));[63]
strstr : INIT : 		trace_preempt_off(CALLER_ADDR0, get_parent_ip(CALLER_ADDR1)); : 
2
strstr : if : 		trace_preempt_off(CALLER_ADDR0, get_parent_ip(CALLER_ADDR1)); : 
2
strstr : for : 		trace_preempt_off(CALLER_ADDR0, get_parent_ip(CALLER_ADDR1)); : 
2
strstr : while : 		trace_preempt_off(CALLER_ADDR0, get_parent_ip(CALLER_ADDR1)); : 
2
str : EXPORT_SYMBOL(preempt_count_add);[33]
strstr : INIT : EXPORT_SYMBOL(preempt_count_add); : 
2
strstr : if : EXPORT_SYMBOL(preempt_count_add); : 
2
strstr : for : EXPORT_SYMBOL(preempt_count_add); : 
2
strstr : while : EXPORT_SYMBOL(preempt_count_add); : 
2
str : void __kprobes preempt_count_sub(int val)[41]
strstr : INIT : void __kprobes preempt_count_sub(int val) : 
2
strstr : if : void __kprobes preempt_count_sub(int val) : 
2
strstr : for : void __kprobes preempt_count_sub(int val) : 
2
strstr : while : void __kprobes preempt_count_sub(int val) : 
2
str : #ifdef CONFIG_DEBUG_PREEMPT[27]
strstr : INIT : #ifdef CONFIG_DEBUG_PREEMPT : 
2
strstr : if : #ifdef CONFIG_DEBUG_PREEMPT : 
2
strstr : for : #ifdef CONFIG_DEBUG_PREEMPT : 
2
strstr : while : #ifdef CONFIG_DEBUG_PREEMPT : 
2
str : 	/*[3]
strstr : INIT : 	/* : 
2
strstr : if : 	/* : 
2
strstr : for : 	/* : 
2
strstr : while : 	/* : 
2
str : 	 * Underflow?[14]
strstr : INIT : 	 * Underflow? : 
2
strstr : if : 	 * Underflow? : 
2
strstr : for : 	 * Underflow? : 
2
strstr : while : 	 * Underflow? : 
2
str : 	 */[4]
strstr : INIT : 	 */ : 
2
strstr : if : 	 */ : 
2
strstr : for : 	 */ : 
2
strstr : while : 	 */ : 
2
str : 	if (DEBUG_LOCKS_WARN_ON(val > preempt_count()))[48]
strstr : INIT : 	if (DEBUG_LOCKS_WARN_ON(val > preempt_count())) : 
2
strstr : if : 	if (DEBUG_LOCKS_WARN_ON(val > preempt_count())) : 
2
strstr : for : 	if (DEBUG_LOCKS_WARN_ON(val > preempt_count())) : 
2
strstr : while : 	if (DEBUG_LOCKS_WARN_ON(val > preempt_count())) : 
2
str : 		return;[9]
strstr : INIT : 		return; : 
2
strstr : if : 		return; : 
2
strstr : for : 		return; : 
2
strstr : while : 		return; : 
2
str : 	/*[3]
strstr : INIT : 	/* : 
2
strstr : if : 	/* : 
2
strstr : for : 	/* : 
2
strstr : while : 	/* : 
2
str : 	 * Is the spinlock portion underflowing?[41]
strstr : INIT : 	 * Is the spinlock portion underflowing? : 
2
strstr : if : 	 * Is the spinlock portion underflowing? : 
2
strstr : for : 	 * Is the spinlock portion underflowing? : 
2
strstr : while : 	 * Is the spinlock portion underflowing? : 
2
str : 	 */[4]
strstr : INIT : 	 */ : 
2
strstr : if : 	 */ : 
2
strstr : for : 	 */ : 
2
strstr : while : 	 */ : 
2
str : 	if (DEBUG_LOCKS_WARN_ON((val < PREEMPT_MASK) &&[48]
strstr : INIT : 	if (DEBUG_LOCKS_WARN_ON((val < PREEMPT_MASK) && : 
2
strstr : if : 	if (DEBUG_LOCKS_WARN_ON((val < PREEMPT_MASK) && : 
2
strstr : for : 	if (DEBUG_LOCKS_WARN_ON((val < PREEMPT_MASK) && : 
2
strstr : while : 	if (DEBUG_LOCKS_WARN_ON((val < PREEMPT_MASK) && : 
2
str : 			!(preempt_count() & PREEMPT_MASK)))[38]
strstr : INIT : 			!(preempt_count() & PREEMPT_MASK))) : 
2
strstr : if : 			!(preempt_count() & PREEMPT_MASK))) : 
2
strstr : for : 			!(preempt_count() & PREEMPT_MASK))) : 
2
strstr : while : 			!(preempt_count() & PREEMPT_MASK))) : 
2
str : 		return;[9]
strstr : INIT : 		return; : 
2
strstr : if : 		return; : 
2
strstr : for : 		return; : 
2
strstr : while : 		return; : 
2
str : #endif[6]
strstr : INIT : #endif : 
2
strstr : if : #endif : 
2
strstr : for : #endif : 
2
strstr : while : #endif : 
2
str : 	if (preempt_count() == val)[28]
strstr : INIT : 	if (preempt_count() == val) : 
2
strstr : if : 	if (preempt_count() == val) : 
2
strstr : for : 	if (preempt_count() == val) : 
2
strstr : while : 	if (preempt_count() == val) : 
2
str : 		trace_preempt_on(CALLER_ADDR0, get_parent_ip(CALLER_ADDR1));[62]
strstr : INIT : 		trace_preempt_on(CALLER_ADDR0, get_parent_ip(CALLER_ADDR1)); : 
2
strstr : if : 		trace_preempt_on(CALLER_ADDR0, get_parent_ip(CALLER_ADDR1)); : 
2
strstr : for : 		trace_preempt_on(CALLER_ADDR0, get_parent_ip(CALLER_ADDR1)); : 
2
strstr : while : 		trace_preempt_on(CALLER_ADDR0, get_parent_ip(CALLER_ADDR1)); : 
2
str : 	__preempt_count_sub(val);[26]
strstr : INIT : 	__preempt_count_sub(val); : 
2
strstr : if : 	__preempt_count_sub(val); : 
2
strstr : for : 	__preempt_count_sub(val); : 
2
strstr : while : 	__preempt_count_sub(val); : 
2
str : EXPORT_SYMBOL(preempt_count_sub);[33]
strstr : INIT : EXPORT_SYMBOL(preempt_count_sub); : 
2
strstr : if : EXPORT_SYMBOL(preempt_count_sub); : 
2
strstr : for : EXPORT_SYMBOL(preempt_count_sub); : 
2
strstr : while : EXPORT_SYMBOL(preempt_count_sub); : 
2
str : #endif[6]
strstr : INIT : #endif : 
2
strstr : if : #endif : 
2
strstr : for : #endif : 
2
strstr : while : #endif : 
2
str :  * Print scheduling while atomic bug:[37]
strstr : INIT :  * Print scheduling while atomic bug: : 
2
strstr : if :  * Print scheduling while atomic bug: : 
2
strstr : for :  * Print scheduling while atomic bug: : 
2
strstr : while :  * Print scheduling while atomic bug: : 
2
str :  */[3]
strstr : INIT :  */ : 
2
strstr : if :  */ : 
2
strstr : for :  */ : 
2
strstr : while :  */ : 
2
str : static noinline void __schedule_bug(struct task_struct *prev)[61]
strstr : INIT : static noinline void __schedule_bug(struct task_struct *prev) : 
2
strstr : if : static noinline void __schedule_bug(struct task_struct *prev) : 
2
strstr : for : static noinline void __schedule_bug(struct task_struct *prev) : 
2
strstr : while : static noinline void __schedule_bug(struct task_struct *prev) : 
2
str : 	if (oops_in_progress)[22]
strstr : INIT : 	if (oops_in_progress) : 
2
strstr : if : 	if (oops_in_progress) : 
2
strstr : for : 	if (oops_in_progress) : 
2
strstr : while : 	if (oops_in_progress) : 
2
str : 		return;[9]
strstr : INIT : 		return; : 
2
strstr : if : 		return; : 
2
strstr : for : 		return; : 
2
strstr : while : 		return; : 
2
str : 	printk(KERN_ERR "BUG: scheduling while atomic: %s/%d/0x%08x\n",[64]
strstr : INIT : 	printk(KERN_ERR "BUG: scheduling while atomic: %s/%d/0x%08x\n", : 
2
strstr : if : 	printk(KERN_ERR "BUG: scheduling while atomic: %s/%d/0x%08x\n", : 
2
strstr : for : 	printk(KERN_ERR "BUG: scheduling while atomic: %s/%d/0x%08x\n", : 
2
strstr : while : 	printk(KERN_ERR "BUG: scheduling while atomic: %s/%d/0x%08x\n", : 
2
str : 		prev->comm, prev->pid, preempt_count());[42]
strstr : INIT : 		prev->comm, prev->pid, preempt_count()); : 
2
strstr : if : 		prev->comm, prev->pid, preempt_count()); : 
2
strstr : for : 		prev->comm, prev->pid, preempt_count()); : 
2
strstr : while : 		prev->comm, prev->pid, preempt_count()); : 
2
str : 	debug_show_held_locks(prev);[29]
strstr : INIT : 	debug_show_held_locks(prev); : 
2
strstr : if : 	debug_show_held_locks(prev); : 
2
strstr : for : 	debug_show_held_locks(prev); : 
2
strstr : while : 	debug_show_held_locks(prev); : 
2
str : 	print_modules();[17]
strstr : INIT : 	print_modules(); : 
2
strstr : if : 	print_modules(); : 
2
strstr : for : 	print_modules(); : 
2
strstr : while : 	print_modules(); : 
2
str : 	if (irqs_disabled())[21]
strstr : INIT : 	if (irqs_disabled()) : 
2
strstr : if : 	if (irqs_disabled()) : 
2
strstr : for : 	if (irqs_disabled()) : 
2
strstr : while : 	if (irqs_disabled()) : 
2
str : 		print_irqtrace_events(prev);[30]
strstr : INIT : 		print_irqtrace_events(prev); : 
2
strstr : if : 		print_irqtrace_events(prev); : 
2
strstr : for : 		print_irqtrace_events(prev); : 
2
strstr : while : 		print_irqtrace_events(prev); : 
2
str : 	dump_stack();[14]
strstr : INIT : 	dump_stack(); : 
2
strstr : if : 	dump_stack(); : 
2
strstr : for : 	dump_stack(); : 
2
strstr : while : 	dump_stack(); : 
2
str : 	add_taint(TAINT_WARN, LOCKDEP_STILL_OK);[41]
strstr : INIT : 	add_taint(TAINT_WARN, LOCKDEP_STILL_OK); : 
2
strstr : if : 	add_taint(TAINT_WARN, LOCKDEP_STILL_OK); : 
2
strstr : for : 	add_taint(TAINT_WARN, LOCKDEP_STILL_OK); : 
2
strstr : while : 	add_taint(TAINT_WARN, LOCKDEP_STILL_OK); : 
2
str :  * Various schedule()-time debugging checks and statistics:[59]
strstr : INIT :  * Various schedule()-time debugging checks and statistics: : 
2
strstr : if :  * Various schedule()-time debugging checks and statistics: : 
2
strstr : for :  * Various schedule()-time debugging checks and statistics: : 
2
strstr : while :  * Various schedule()-time debugging checks and statistics: : 
2
str :  */[3]
strstr : INIT :  */ : 
2
strstr : if :  */ : 
2
strstr : for :  */ : 
2
strstr : while :  */ : 
2
str : static inline void schedule_debug(struct task_struct *prev)[59]
strstr : INIT : static inline void schedule_debug(struct task_struct *prev) : 
2
strstr : if : static inline void schedule_debug(struct task_struct *prev) : 
2
strstr : for : static inline void schedule_debug(struct task_struct *prev) : 
2
strstr : while : static inline void schedule_debug(struct task_struct *prev) : 
2
str : 	/*[3]
strstr : INIT : 	/* : 
2
strstr : if : 	/* : 
2
strstr : for : 	/* : 
2
strstr : while : 	/* : 
2
str : 	 * Test if we are atomic. Since do_exit() needs to call into[61]
strstr : INIT : 	 * Test if we are atomic. Since do_exit() needs to call into : 
2
strstr : if : 	 * Test if we are atomic. Since do_exit() needs to call into : 
2
strstr : for : 	 * Test if we are atomic. Since do_exit() needs to call into : 
2
strstr : while : 	 * Test if we are atomic. Since do_exit() needs to call into : 
2
str : 	 * schedule() atomically, we ignore that path. Otherwise whine[63]
strstr : INIT : 	 * schedule() atomically, we ignore that path. Otherwise whine : 
2
strstr : if : 	 * schedule() atomically, we ignore that path. Otherwise whine : 
2
strstr : for : 	 * schedule() atomically, we ignore that path. Otherwise whine : 
2
strstr : while : 	 * schedule() atomically, we ignore that path. Otherwise whine : 
2
str : 	 * if we are scheduling when we should not.[44]
strstr : INIT : 	 * if we are scheduling when we should not. : 
2
strstr : if : 	 * if we are scheduling when we should not. : 
2
strstr : for : 	 * if we are scheduling when we should not. : 
2
strstr : while : 	 * if we are scheduling when we should not. : 
2
str : 	 */[4]
strstr : INIT : 	 */ : 
2
strstr : if : 	 */ : 
2
strstr : for : 	 */ : 
2
strstr : while : 	 */ : 
2
str : 	if (unlikely(in_atomic_preempt_off() && prev->state != TASK_DEAD))[67]
strstr : INIT : 	if (unlikely(in_atomic_preempt_off() && prev->state != TASK_DEAD)) : 
2
strstr : if : 	if (unlikely(in_atomic_preempt_off() && prev->state != TASK_DEAD)) : 
2
strstr : for : 	if (unlikely(in_atomic_preempt_off() && prev->state != TASK_DEAD)) : 
2
strstr : while : 	if (unlikely(in_atomic_preempt_off() && prev->state != TASK_DEAD)) : 
2
str : 		__schedule_bug(prev);[23]
strstr : INIT : 		__schedule_bug(prev); : 
2
strstr : if : 		__schedule_bug(prev); : 
2
strstr : for : 		__schedule_bug(prev); : 
2
strstr : while : 		__schedule_bug(prev); : 
2
str : 	rcu_sleep_check();[19]
strstr : INIT : 	rcu_sleep_check(); : 
2
strstr : if : 	rcu_sleep_check(); : 
2
strstr : for : 	rcu_sleep_check(); : 
2
strstr : while : 	rcu_sleep_check(); : 
2
str : 	profile_hit(SCHED_PROFILING, __builtin_return_address(0));[59]
strstr : INIT : 	profile_hit(SCHED_PROFILING, __builtin_return_address(0)); : 
2
strstr : if : 	profile_hit(SCHED_PROFILING, __builtin_return_address(0)); : 
2
strstr : for : 	profile_hit(SCHED_PROFILING, __builtin_return_address(0)); : 
2
strstr : while : 	profile_hit(SCHED_PROFILING, __builtin_return_address(0)); : 
2
str : 	schedstat_inc(this_rq(), sched_count);[39]
strstr : INIT : 	schedstat_inc(this_rq(), sched_count); : 
2
strstr : if : 	schedstat_inc(this_rq(), sched_count); : 
2
strstr : for : 	schedstat_inc(this_rq(), sched_count); : 
2
strstr : while : 	schedstat_inc(this_rq(), sched_count); : 
2
str : static void put_prev_task(struct rq *rq, struct task_struct *prev)[66]
strstr : INIT : static void put_prev_task(struct rq *rq, struct task_struct *prev) : 
2
strstr : if : static void put_prev_task(struct rq *rq, struct task_struct *prev) : 
2
strstr : for : static void put_prev_task(struct rq *rq, struct task_struct *prev) : 
2
strstr : while : static void put_prev_task(struct rq *rq, struct task_struct *prev) : 
2
str : 	if (prev->on_rq || rq->skip_clock_update < 0)[46]
strstr : INIT : 	if (prev->on_rq || rq->skip_clock_update < 0) : 
2
strstr : if : 	if (prev->on_rq || rq->skip_clock_update < 0) : 
2
strstr : for : 	if (prev->on_rq || rq->skip_clock_update < 0) : 
2
strstr : while : 	if (prev->on_rq || rq->skip_clock_update < 0) : 
2
str : 		update_rq_clock(rq);[22]
strstr : INIT : 		update_rq_clock(rq); : 
2
strstr : if : 		update_rq_clock(rq); : 
2
strstr : for : 		update_rq_clock(rq); : 
2
strstr : while : 		update_rq_clock(rq); : 
2
str : 	prev->sched_class->put_prev_task(rq, prev);[44]
strstr : INIT : 	prev->sched_class->put_prev_task(rq, prev); : 
2
strstr : if : 	prev->sched_class->put_prev_task(rq, prev); : 
2
strstr : for : 	prev->sched_class->put_prev_task(rq, prev); : 
2
strstr : while : 	prev->sched_class->put_prev_task(rq, prev); : 
2
str :  * Pick up the highest-prio task:[33]
strstr : INIT :  * Pick up the highest-prio task: : 
2
strstr : if :  * Pick up the highest-prio task: : 
2
strstr : for :  * Pick up the highest-prio task: : 
2
strstr : while :  * Pick up the highest-prio task: : 
2
str :  */[3]
strstr : INIT :  */ : 
2
strstr : if :  */ : 
2
strstr : for :  */ : 
2
strstr : while :  */ : 
2
str : static inline struct task_struct *[34]
strstr : INIT : static inline struct task_struct * : 
2
strstr : if : static inline struct task_struct * : 
2
strstr : for : static inline struct task_struct * : 
2
strstr : while : static inline struct task_struct * : 
2
str : pick_next_task(struct rq *rq)[29]
strstr : INIT : pick_next_task(struct rq *rq) : 
2
strstr : if : pick_next_task(struct rq *rq) : 
2
strstr : for : pick_next_task(struct rq *rq) : 
2
strstr : while : pick_next_task(struct rq *rq) : 
2
str : 	const struct sched_class *class;[33]
strstr : INIT : 	const struct sched_class *class; : 
2
strstr : if : 	const struct sched_class *class; : 
2
strstr : for : 	const struct sched_class *class; : 
2
strstr : while : 	const struct sched_class *class; : 
2
str : 	struct task_struct *p;[23]
strstr : INIT : 	struct task_struct *p; : 
2
strstr : if : 	struct task_struct *p; : 
2
strstr : for : 	struct task_struct *p; : 
2
strstr : while : 	struct task_struct *p; : 
2
str : 	/*[3]
strstr : INIT : 	/* : 
2
strstr : if : 	/* : 
2
strstr : for : 	/* : 
2
strstr : while : 	/* : 
2
str : 	 * Optimization: we know that if all tasks are in[50]
strstr : INIT : 	 * Optimization: we know that if all tasks are in : 
2
strstr : if : 	 * Optimization: we know that if all tasks are in : 
2
strstr : for : 	 * Optimization: we know that if all tasks are in : 
2
strstr : while : 	 * Optimization: we know that if all tasks are in : 
2
str : 	 * the fair class we can call that function directly:[54]
strstr : INIT : 	 * the fair class we can call that function directly: : 
2
strstr : if : 	 * the fair class we can call that function directly: : 
2
strstr : for : 	 * the fair class we can call that function directly: : 
2
strstr : while : 	 * the fair class we can call that function directly: : 
2
str : 	 */[4]
strstr : INIT : 	 */ : 
2
strstr : if : 	 */ : 
2
strstr : for : 	 */ : 
2
strstr : while : 	 */ : 
2
str : 	if (likely(rq->nr_running == rq->cfs.h_nr_running)) {[54]
strstr : INIT : 	if (likely(rq->nr_running == rq->cfs.h_nr_running)) { : 
2
strstr : if : 	if (likely(rq->nr_running == rq->cfs.h_nr_running)) { : 
2
strstr : for : 	if (likely(rq->nr_running == rq->cfs.h_nr_running)) { : 
2
strstr : while : 	if (likely(rq->nr_running == rq->cfs.h_nr_running)) { : 
2
str : 		p = fair_sched_class.pick_next_task(rq);[42]
strstr : INIT : 		p = fair_sched_class.pick_next_task(rq); : 
2
strstr : if : 		p = fair_sched_class.pick_next_task(rq); : 
2
strstr : for : 		p = fair_sched_class.pick_next_task(rq); : 
2
strstr : while : 		p = fair_sched_class.pick_next_task(rq); : 
2
str : 		if (likely(p))[16]
strstr : INIT : 		if (likely(p)) : 
2
strstr : if : 		if (likely(p)) : 
2
strstr : for : 		if (likely(p)) : 
2
strstr : while : 		if (likely(p)) : 
2
str : 			return p;[12]
strstr : INIT : 			return p; : 
2
strstr : if : 			return p; : 
2
strstr : for : 			return p; : 
2
strstr : while : 			return p; : 
2
str : 	for_each_class(class) {[24]
strstr : INIT : 	for_each_class(class) { : 
2
strstr : if : 	for_each_class(class) { : 
2
strstr : for : 	for_each_class(class) { : 
2
strstr : while : 	for_each_class(class) { : 
2
str : 		p = class->pick_next_task(rq);[32]
strstr : INIT : 		p = class->pick_next_task(rq); : 
2
strstr : if : 		p = class->pick_next_task(rq); : 
2
strstr : for : 		p = class->pick_next_task(rq); : 
2
strstr : while : 		p = class->pick_next_task(rq); : 
2
str : 		if (p)[8]
strstr : INIT : 		if (p) : 
2
strstr : if : 		if (p) : 
2
strstr : for : 		if (p) : 
2
strstr : while : 		if (p) : 
2
str : 			return p;[12]
strstr : INIT : 			return p; : 
2
strstr : if : 			return p; : 
2
strstr : for : 			return p; : 
2
strstr : while : 			return p; : 
2
str : 	BUG(); /* the idle class will always have a runnable task */[61]
strstr : INIT : 	BUG(); /* the idle class will always have a runnable task */ : 
2
strstr : if : 	BUG(); /* the idle class will always have a runnable task */ : 
2
strstr : for : 	BUG(); /* the idle class will always have a runnable task */ : 
2
strstr : while : 	BUG(); /* the idle class will always have a runnable task */ : 
2
str :  * __schedule() is the main scheduler function.[47]
strstr : INIT :  * __schedule() is the main scheduler function. : 
2
strstr : if :  * __schedule() is the main scheduler function. : 
2
strstr : for :  * __schedule() is the main scheduler function. : 
2
strstr : while :  * __schedule() is the main scheduler function. : 
2
str :  * The main means of driving the scheduler and thus entering this function are:[79]
strstr : INIT :  * The main means of driving the scheduler and thus entering this function are: : 
2
strstr : if :  * The main means of driving the scheduler and thus entering this function are: : 
2
strstr : for :  * The main means of driving the scheduler and thus entering this function are: : 
2
strstr : while :  * The main means of driving the scheduler and thus entering this function are: : 
2
str :  *   1. Explicit blocking: mutex, semaphore, waitqueue, etc.[60]
strstr : INIT :  *   1. Explicit blocking: mutex, semaphore, waitqueue, etc. : 
2
strstr : if :  *   1. Explicit blocking: mutex, semaphore, waitqueue, etc. : 
2
strstr : for :  *   1. Explicit blocking: mutex, semaphore, waitqueue, etc. : 
2
strstr : while :  *   1. Explicit blocking: mutex, semaphore, waitqueue, etc. : 
2
str :  *   2. TIF_NEED_RESCHED flag is checked on interrupt and userspace return[74]
strstr : INIT :  *   2. TIF_NEED_RESCHED flag is checked on interrupt and userspace return : 
2
strstr : if :  *   2. TIF_NEED_RESCHED flag is checked on interrupt and userspace return : 
2
strstr : for :  *   2. TIF_NEED_RESCHED flag is checked on interrupt and userspace return : 
2
strstr : while :  *   2. TIF_NEED_RESCHED flag is checked on interrupt and userspace return : 
2
str :  *      paths. For example, see arch/x86/entry_64.S.[52]
strstr : INIT :  *      paths. For example, see arch/x86/entry_64.S. : 
2
strstr : if :  *      paths. For example, see arch/x86/entry_64.S. : 
2
strstr : for :  *      paths. For example, see arch/x86/entry_64.S. : 
2
strstr : while :  *      paths. For example, see arch/x86/entry_64.S. : 
2
str :  *      To drive preemption between tasks, the scheduler sets the flag in timer[79]
strstr : INIT :  *      To drive preemption between tasks, the scheduler sets the flag in timer : 
2
strstr : if :  *      To drive preemption between tasks, the scheduler sets the flag in timer : 
2
strstr : for :  *      To drive preemption between tasks, the scheduler sets the flag in timer : 
2
strstr : while :  *      To drive preemption between tasks, the scheduler sets the flag in timer : 
2
str :  *      interrupt handler scheduler_tick().[43]
strstr : INIT :  *      interrupt handler scheduler_tick(). : 
2
strstr : if :  *      interrupt handler scheduler_tick(). : 
2
strstr : for :  *      interrupt handler scheduler_tick(). : 
2
strstr : while :  *      interrupt handler scheduler_tick(). : 
2
str :  *   3. Wakeups don't really cause entry into schedule(). They add a[68]
strstr : INIT :  *   3. Wakeups don't really cause entry into schedule(). They add a : 
2
strstr : if :  *   3. Wakeups don't really cause entry into schedule(). They add a : 
2
strstr : for :  *   3. Wakeups don't really cause entry into schedule(). They add a : 
2
strstr : while :  *   3. Wakeups don't really cause entry into schedule(). They add a : 
2
str :  *      task to the run-queue and that's it.[44]
strstr : INIT :  *      task to the run-queue and that's it. : 
2
strstr : if :  *      task to the run-queue and that's it. : 
2
strstr : for :  *      task to the run-queue and that's it. : 
2
strstr : while :  *      task to the run-queue and that's it. : 
2
str :  *      Now, if the new task added to the run-queue preempts the current[72]
strstr : INIT :  *      Now, if the new task added to the run-queue preempts the current : 
2
strstr : if :  *      Now, if the new task added to the run-queue preempts the current : 
2
strstr : for :  *      Now, if the new task added to the run-queue preempts the current : 
2
strstr : while :  *      Now, if the new task added to the run-queue preempts the current : 
2
str :  *      task, then the wakeup sets TIF_NEED_RESCHED and schedule() gets[71]
strstr : INIT :  *      task, then the wakeup sets TIF_NEED_RESCHED and schedule() gets : 
2
strstr : if :  *      task, then the wakeup sets TIF_NEED_RESCHED and schedule() gets : 
2
strstr : for :  *      task, then the wakeup sets TIF_NEED_RESCHED and schedule() gets : 
2
strstr : while :  *      task, then the wakeup sets TIF_NEED_RESCHED and schedule() gets : 
2
str :  *      called on the nearest possible occasion:[48]
strstr : INIT :  *      called on the nearest possible occasion: : 
2
strstr : if :  *      called on the nearest possible occasion: : 
2
strstr : for :  *      called on the nearest possible occasion: : 
2
strstr : while :  *      called on the nearest possible occasion: : 
2
str :  *       - If the kernel is preemptible (CONFIG_PREEMPT=y):[59]
strstr : INIT :  *       - If the kernel is preemptible (CONFIG_PREEMPT=y): : 
2
strstr : if :  *       - If the kernel is preemptible (CONFIG_PREEMPT=y): : 
2
strstr : for :  *       - If the kernel is preemptible (CONFIG_PREEMPT=y): : 
2
strstr : while :  *       - If the kernel is preemptible (CONFIG_PREEMPT=y): : 
2
str :  *         - in syscall or exception context, at the next outmost[65]
strstr : INIT :  *         - in syscall or exception context, at the next outmost : 
2
strstr : if :  *         - in syscall or exception context, at the next outmost : 
2
strstr : for :  *         - in syscall or exception context, at the next outmost : 
2
strstr : while :  *         - in syscall or exception context, at the next outmost : 
2
str :  *           preempt_enable(). (this might be as soon as the wake_up()'s[72]
strstr : INIT :  *           preempt_enable(). (this might be as soon as the wake_up()'s : 
2
strstr : if :  *           preempt_enable(). (this might be as soon as the wake_up()'s : 
2
strstr : for :  *           preempt_enable(). (this might be as soon as the wake_up()'s : 
2
strstr : while :  *           preempt_enable(). (this might be as soon as the wake_up()'s : 
2
str :  *           spin_unlock()!)[28]
strstr : INIT :  *           spin_unlock()!) : 
2
strstr : if :  *           spin_unlock()!) : 
2
strstr : for :  *           spin_unlock()!) : 
2
strstr : while :  *           spin_unlock()!) : 
2
str :  *         - in IRQ context, return from interrupt-handler to[61]
strstr : INIT :  *         - in IRQ context, return from interrupt-handler to : 
2
strstr : if :  *         - in IRQ context, return from interrupt-handler to : 
2
strstr : for :  *         - in IRQ context, return from interrupt-handler to : 
2
strstr : while :  *         - in IRQ context, return from interrupt-handler to : 
2
str :  *           preemptible context[32]
strstr : INIT :  *           preemptible context : 
2
strstr : if :  *           preemptible context : 
2
strstr : for :  *           preemptible context : 
2
strstr : while :  *           preemptible context : 
2
str :  *       - If the kernel is not preemptible (CONFIG_PREEMPT is not set)[71]
strstr : INIT :  *       - If the kernel is not preemptible (CONFIG_PREEMPT is not set) : 
2
strstr : if :  *       - If the kernel is not preemptible (CONFIG_PREEMPT is not set) : 
2
strstr : for :  *       - If the kernel is not preemptible (CONFIG_PREEMPT is not set) : 
2
strstr : while :  *       - If the kernel is not preemptible (CONFIG_PREEMPT is not set) : 
2
str :  *         then at the next:[28]
strstr : INIT :  *         then at the next: : 
2
strstr : if :  *         then at the next: : 
2
strstr : for :  *         then at the next: : 
2
strstr : while :  *         then at the next: : 
2
str :  *          - cond_resched() call[33]
strstr : INIT :  *          - cond_resched() call : 
2
strstr : if :  *          - cond_resched() call : 
2
strstr : for :  *          - cond_resched() call : 
2
strstr : while :  *          - cond_resched() call : 
2
str :  *          - explicit schedule() call[38]
strstr : INIT :  *          - explicit schedule() call : 
2
strstr : if :  *          - explicit schedule() call : 
2
strstr : for :  *          - explicit schedule() call : 
2
strstr : while :  *          - explicit schedule() call : 
2
str :  *          - return from syscall or exception to user-space[60]
strstr : INIT :  *          - return from syscall or exception to user-space : 
2
strstr : if :  *          - return from syscall or exception to user-space : 
2
strstr : for :  *          - return from syscall or exception to user-space : 
2
strstr : while :  *          - return from syscall or exception to user-space : 
2
str :  *          - return from interrupt-handler to user-space[57]
strstr : INIT :  *          - return from interrupt-handler to user-space : 
2
strstr : if :  *          - return from interrupt-handler to user-space : 
2
strstr : for :  *          - return from interrupt-handler to user-space : 
2
strstr : while :  *          - return from interrupt-handler to user-space : 
2
str :  */[3]
strstr : INIT :  */ : 
2
strstr : if :  */ : 
2
strstr : for :  */ : 
2
strstr : while :  */ : 
2
str : static void __sched __schedule(void)[36]
strstr : INIT : static void __sched __schedule(void) : 
2
strstr : if : static void __sched __schedule(void) : 
2
strstr : for : static void __sched __schedule(void) : 
2
strstr : while : static void __sched __schedule(void) : 
2
str : 	struct task_struct *prev, *next;[33]
strstr : INIT : 	struct task_struct *prev, *next; : 
2
strstr : if : 	struct task_struct *prev, *next; : 
2
strstr : for : 	struct task_struct *prev, *next; : 
2
strstr : while : 	struct task_struct *prev, *next; : 
2
str : 	unsigned long *switch_count;[29]
strstr : INIT : 	unsigned long *switch_count; : 
2
strstr : if : 	unsigned long *switch_count; : 
2
strstr : for : 	unsigned long *switch_count; : 
2
strstr : while : 	unsigned long *switch_count; : 
2
str : 	struct rq *rq;[15]
strstr : INIT : 	struct rq *rq; : 
2
strstr : if : 	struct rq *rq; : 
2
strstr : for : 	struct rq *rq; : 
2
strstr : while : 	struct rq *rq; : 
2
str : 	int cpu;[9]
strstr : INIT : 	int cpu; : 
2
strstr : if : 	int cpu; : 
2
strstr : for : 	int cpu; : 
2
strstr : while : 	int cpu; : 
2
str : need_resched:[13]
strstr : INIT : need_resched: : 
2
strstr : if : need_resched: : 
2
strstr : for : need_resched: : 
2
strstr : while : need_resched: : 
2
str : 	preempt_disable();[19]
strstr : INIT : 	preempt_disable(); : 
2
strstr : if : 	preempt_disable(); : 
2
strstr : for : 	preempt_disable(); : 
2
strstr : while : 	preempt_disable(); : 
2
str : 	cpu = smp_processor_id();[26]
strstr : INIT : 	cpu = smp_processor_id(); : 
2
strstr : if : 	cpu = smp_processor_id(); : 
2
strstr : for : 	cpu = smp_processor_id(); : 
2
strstr : while : 	cpu = smp_processor_id(); : 
2
str : 	rq = cpu_rq(cpu);[18]
strstr : INIT : 	rq = cpu_rq(cpu); : 
2
strstr : if : 	rq = cpu_rq(cpu); : 
2
strstr : for : 	rq = cpu_rq(cpu); : 
2
strstr : while : 	rq = cpu_rq(cpu); : 
2
str : 	rcu_note_context_switch(cpu);[30]
strstr : INIT : 	rcu_note_context_switch(cpu); : 
2
strstr : if : 	rcu_note_context_switch(cpu); : 
2
strstr : for : 	rcu_note_context_switch(cpu); : 
2
strstr : while : 	rcu_note_context_switch(cpu); : 
2
str : 	prev = rq->curr;[17]
strstr : INIT : 	prev = rq->curr; : 
2
strstr : if : 	prev = rq->curr; : 
2
strstr : for : 	prev = rq->curr; : 
2
strstr : while : 	prev = rq->curr; : 
2
str : 	schedule_debug(prev);[22]
strstr : INIT : 	schedule_debug(prev); : 
2
strstr : if : 	schedule_debug(prev); : 
2
strstr : for : 	schedule_debug(prev); : 
2
strstr : while : 	schedule_debug(prev); : 
2
str : 	if (sched_feat(HRTICK))[24]
strstr : INIT : 	if (sched_feat(HRTICK)) : 
2
strstr : if : 	if (sched_feat(HRTICK)) : 
2
strstr : for : 	if (sched_feat(HRTICK)) : 
2
strstr : while : 	if (sched_feat(HRTICK)) : 
2
str : 		hrtick_clear(rq);[19]
strstr : INIT : 		hrtick_clear(rq); : 
2
strstr : if : 		hrtick_clear(rq); : 
2
strstr : for : 		hrtick_clear(rq); : 
2
strstr : while : 		hrtick_clear(rq); : 
2
str : 	/*[3]
strstr : INIT : 	/* : 
2
strstr : if : 	/* : 
2
strstr : for : 	/* : 
2
strstr : while : 	/* : 
2
str : 	 * Make sure that signal_pending_state()->signal_pending() below[65]
strstr : INIT : 	 * Make sure that signal_pending_state()->signal_pending() below : 
2
strstr : if : 	 * Make sure that signal_pending_state()->signal_pending() below : 
2
strstr : for : 	 * Make sure that signal_pending_state()->signal_pending() below : 
2
strstr : while : 	 * Make sure that signal_pending_state()->signal_pending() below : 
2
str : 	 * can't be reordered with __set_current_state(TASK_INTERRUPTIBLE)[67]
strstr : INIT : 	 * can't be reordered with __set_current_state(TASK_INTERRUPTIBLE) : 
2
strstr : if : 	 * can't be reordered with __set_current_state(TASK_INTERRUPTIBLE) : 
2
strstr : for : 	 * can't be reordered with __set_current_state(TASK_INTERRUPTIBLE) : 
2
strstr : while : 	 * can't be reordered with __set_current_state(TASK_INTERRUPTIBLE) : 
2
str : 	 * done by the caller to avoid the race with signal_wake_up().[63]
strstr : INIT : 	 * done by the caller to avoid the race with signal_wake_up(). : 
2
strstr : if : 	 * done by the caller to avoid the race with signal_wake_up(). : 
2
strstr : for : 	 * done by the caller to avoid the race with signal_wake_up(). : 
2
strstr : while : 	 * done by the caller to avoid the race with signal_wake_up(). : 
2
str : 	 */[4]
strstr : INIT : 	 */ : 
2
strstr : if : 	 */ : 
2
strstr : for : 	 */ : 
2
strstr : while : 	 */ : 
2
str : 	smp_mb__before_spinlock();[27]
strstr : INIT : 	smp_mb__before_spinlock(); : 
2
strstr : if : 	smp_mb__before_spinlock(); : 
2
strstr : for : 	smp_mb__before_spinlock(); : 
2
strstr : while : 	smp_mb__before_spinlock(); : 
2
str : 	raw_spin_lock_irq(&rq->lock);[30]
strstr : INIT : 	raw_spin_lock_irq(&rq->lock); : 
2
strstr : if : 	raw_spin_lock_irq(&rq->lock); : 
2
strstr : for : 	raw_spin_lock_irq(&rq->lock); : 
2
strstr : while : 	raw_spin_lock_irq(&rq->lock); : 
2
str : 	switch_count = &prev->nivcsw;[30]
strstr : INIT : 	switch_count = &prev->nivcsw; : 
2
strstr : if : 	switch_count = &prev->nivcsw; : 
2
strstr : for : 	switch_count = &prev->nivcsw; : 
2
strstr : while : 	switch_count = &prev->nivcsw; : 
2
str : 	if (prev->state && !(preempt_count() & PREEMPT_ACTIVE)) {[58]
strstr : INIT : 	if (prev->state && !(preempt_count() & PREEMPT_ACTIVE)) { : 
2
strstr : if : 	if (prev->state && !(preempt_count() & PREEMPT_ACTIVE)) { : 
2
strstr : for : 	if (prev->state && !(preempt_count() & PREEMPT_ACTIVE)) { : 
2
strstr : while : 	if (prev->state && !(preempt_count() & PREEMPT_ACTIVE)) { : 
2
str : 		if (unlikely(signal_pending_state(prev->state, prev))) {[58]
strstr : INIT : 		if (unlikely(signal_pending_state(prev->state, prev))) { : 
2
strstr : if : 		if (unlikely(signal_pending_state(prev->state, prev))) { : 
2
strstr : for : 		if (unlikely(signal_pending_state(prev->state, prev))) { : 
2
strstr : while : 		if (unlikely(signal_pending_state(prev->state, prev))) { : 
2
str : 			prev->state = TASK_RUNNING;[30]
strstr : INIT : 			prev->state = TASK_RUNNING; : 
2
strstr : if : 			prev->state = TASK_RUNNING; : 
2
strstr : for : 			prev->state = TASK_RUNNING; : 
2
strstr : while : 			prev->state = TASK_RUNNING; : 
2
str : 		} else {[10]
strstr : INIT : 		} else { : 
2
strstr : if : 		} else { : 
2
strstr : for : 		} else { : 
2
strstr : while : 		} else { : 
2
str : 			deactivate_task(rq, prev, DEQUEUE_SLEEP);[44]
strstr : INIT : 			deactivate_task(rq, prev, DEQUEUE_SLEEP); : 
2
strstr : if : 			deactivate_task(rq, prev, DEQUEUE_SLEEP); : 
2
strstr : for : 			deactivate_task(rq, prev, DEQUEUE_SLEEP); : 
2
strstr : while : 			deactivate_task(rq, prev, DEQUEUE_SLEEP); : 
2
str : 			prev->on_rq = 0;[19]
strstr : INIT : 			prev->on_rq = 0; : 
2
strstr : if : 			prev->on_rq = 0; : 
2
strstr : for : 			prev->on_rq = 0; : 
2
strstr : while : 			prev->on_rq = 0; : 
2
str : 			/*[5]
strstr : INIT : 			/* : 
2
strstr : if : 			/* : 
2
strstr : for : 			/* : 
2
strstr : while : 			/* : 
2
str : 			 * If a worker went to sleep, notify and ask workqueue[57]
strstr : INIT : 			 * If a worker went to sleep, notify and ask workqueue : 
2
strstr : if : 			 * If a worker went to sleep, notify and ask workqueue : 
2
strstr : for : 			 * If a worker went to sleep, notify and ask workqueue : 
2
strstr : while : 			 * If a worker went to sleep, notify and ask workqueue : 
2
str : 			 * whether it wants to wake up a task to maintain[52]
strstr : INIT : 			 * whether it wants to wake up a task to maintain : 
2
strstr : if : 			 * whether it wants to wake up a task to maintain : 
2
strstr : for : 			 * whether it wants to wake up a task to maintain : 
2
strstr : while : 			 * whether it wants to wake up a task to maintain : 
2
str : 			 * concurrency.[18]
strstr : INIT : 			 * concurrency. : 
2
strstr : if : 			 * concurrency. : 
2
strstr : for : 			 * concurrency. : 
2
strstr : while : 			 * concurrency. : 
2
str : 			 */[6]
strstr : INIT : 			 */ : 
2
strstr : if : 			 */ : 
2
strstr : for : 			 */ : 
2
strstr : while : 			 */ : 
2
str : 			if (prev->flags & PF_WQ_WORKER) {[36]
strstr : INIT : 			if (prev->flags & PF_WQ_WORKER) { : 
2
strstr : if : 			if (prev->flags & PF_WQ_WORKER) { : 
2
strstr : for : 			if (prev->flags & PF_WQ_WORKER) { : 
2
strstr : while : 			if (prev->flags & PF_WQ_WORKER) { : 
2
str : 				struct task_struct *to_wakeup;[34]
strstr : INIT : 				struct task_struct *to_wakeup; : 
2
strstr : if : 				struct task_struct *to_wakeup; : 
2
strstr : for : 				struct task_struct *to_wakeup; : 
2
strstr : while : 				struct task_struct *to_wakeup; : 
2
str : 				to_wakeup = wq_worker_sleeping(prev, cpu);[46]
strstr : INIT : 				to_wakeup = wq_worker_sleeping(prev, cpu); : 
2
strstr : if : 				to_wakeup = wq_worker_sleeping(prev, cpu); : 
2
strstr : for : 				to_wakeup = wq_worker_sleeping(prev, cpu); : 
2
strstr : while : 				to_wakeup = wq_worker_sleeping(prev, cpu); : 
2
str : 				if (to_wakeup)[18]
strstr : INIT : 				if (to_wakeup) : 
2
strstr : if : 				if (to_wakeup) : 
2
strstr : for : 				if (to_wakeup) : 
2
strstr : while : 				if (to_wakeup) : 
2
str : 					try_to_wake_up_local(to_wakeup);[37]
strstr : INIT : 					try_to_wake_up_local(to_wakeup); : 
2
strstr : if : 					try_to_wake_up_local(to_wakeup); : 
2
strstr : for : 					try_to_wake_up_local(to_wakeup); : 
2
strstr : while : 					try_to_wake_up_local(to_wakeup); : 
2
str : 			}[4]
strstr : INIT : 			} : 
2
strstr : if : 			} : 
2
strstr : for : 			} : 
2
strstr : while : 			} : 
2
str : 		}[3]
strstr : INIT : 		} : 
2
strstr : if : 		} : 
2
strstr : for : 		} : 
2
strstr : while : 		} : 
2
str : 		switch_count = &prev->nvcsw;[30]
strstr : INIT : 		switch_count = &prev->nvcsw; : 
2
strstr : if : 		switch_count = &prev->nvcsw; : 
2
strstr : for : 		switch_count = &prev->nvcsw; : 
2
strstr : while : 		switch_count = &prev->nvcsw; : 
2
str : 	pre_schedule(rq, prev);[24]
strstr : INIT : 	pre_schedule(rq, prev); : 
2
strstr : if : 	pre_schedule(rq, prev); : 
2
strstr : for : 	pre_schedule(rq, prev); : 
2
strstr : while : 	pre_schedule(rq, prev); : 
2
str : 	if (unlikely(!rq->nr_running))[31]
strstr : INIT : 	if (unlikely(!rq->nr_running)) : 
2
strstr : if : 	if (unlikely(!rq->nr_running)) : 
2
strstr : for : 	if (unlikely(!rq->nr_running)) : 
2
strstr : while : 	if (unlikely(!rq->nr_running)) : 
2
str : 		idle_balance(cpu, rq);[24]
strstr : INIT : 		idle_balance(cpu, rq); : 
2
strstr : if : 		idle_balance(cpu, rq); : 
2
strstr : for : 		idle_balance(cpu, rq); : 
2
strstr : while : 		idle_balance(cpu, rq); : 
2
str : 	put_prev_task(rq, prev);[25]
strstr : INIT : 	put_prev_task(rq, prev); : 
2
strstr : if : 	put_prev_task(rq, prev); : 
2
strstr : for : 	put_prev_task(rq, prev); : 
2
strstr : while : 	put_prev_task(rq, prev); : 
2
str : 	next = pick_next_task(rq);[27]
strstr : INIT : 	next = pick_next_task(rq); : 
2
strstr : if : 	next = pick_next_task(rq); : 
2
strstr : for : 	next = pick_next_task(rq); : 
2
strstr : while : 	next = pick_next_task(rq); : 
2
str : 	clear_tsk_need_resched(prev);[30]
strstr : INIT : 	clear_tsk_need_resched(prev); : 
2
strstr : if : 	clear_tsk_need_resched(prev); : 
2
strstr : for : 	clear_tsk_need_resched(prev); : 
2
strstr : while : 	clear_tsk_need_resched(prev); : 
2
str : 	clear_preempt_need_resched();[30]
strstr : INIT : 	clear_preempt_need_resched(); : 
2
strstr : if : 	clear_preempt_need_resched(); : 
2
strstr : for : 	clear_preempt_need_resched(); : 
2
strstr : while : 	clear_preempt_need_resched(); : 
2
str : 	rq->skip_clock_update = 0;[27]
strstr : INIT : 	rq->skip_clock_update = 0; : 
2
strstr : if : 	rq->skip_clock_update = 0; : 
2
strstr : for : 	rq->skip_clock_update = 0; : 
2
strstr : while : 	rq->skip_clock_update = 0; : 
2
str : 	if (likely(prev != next)) {[28]
strstr : INIT : 	if (likely(prev != next)) { : 
2
strstr : if : 	if (likely(prev != next)) { : 
2
strstr : for : 	if (likely(prev != next)) { : 
2
strstr : while : 	if (likely(prev != next)) { : 
2
str : 		rq->nr_switches++;[20]
strstr : INIT : 		rq->nr_switches++; : 
2
strstr : if : 		rq->nr_switches++; : 
2
strstr : for : 		rq->nr_switches++; : 
2
strstr : while : 		rq->nr_switches++; : 
2
str : 		rq->curr = next;[18]
strstr : INIT : 		rq->curr = next; : 
2
strstr : if : 		rq->curr = next; : 
2
strstr : for : 		rq->curr = next; : 
2
strstr : while : 		rq->curr = next; : 
2
str : 		++*switch_count;[18]
strstr : INIT : 		++*switch_count; : 
2
strstr : if : 		++*switch_count; : 
2
strstr : for : 		++*switch_count; : 
2
strstr : while : 		++*switch_count; : 
2
str : 		context_switch(rq, prev, next); /* unlocks the rq */[54]
strstr : INIT : 		context_switch(rq, prev, next); /* unlocks the rq */ : 
2
strstr : if : 		context_switch(rq, prev, next); /* unlocks the rq */ : 
2
strstr : for : 		context_switch(rq, prev, next); /* unlocks the rq */ : 
2
strstr : while : 		context_switch(rq, prev, next); /* unlocks the rq */ : 
2
str : 		/*[4]
strstr : INIT : 		/* : 
2
strstr : if : 		/* : 
2
strstr : for : 		/* : 
2
strstr : while : 		/* : 
2
str : 		 * The context switch have flipped the stack from under us[60]
strstr : INIT : 		 * The context switch have flipped the stack from under us : 
2
strstr : if : 		 * The context switch have flipped the stack from under us : 
2
strstr : for : 		 * The context switch have flipped the stack from under us : 
2
strstr : while : 		 * The context switch have flipped the stack from under us : 
2
str : 		 * and restored the local variables which were saved when[59]
strstr : INIT : 		 * and restored the local variables which were saved when : 
2
strstr : if : 		 * and restored the local variables which were saved when : 
2
strstr : for : 		 * and restored the local variables which were saved when : 
2
strstr : while : 		 * and restored the local variables which were saved when : 
2
str : 		 * this task called schedule() in the past. prev == current[61]
strstr : INIT : 		 * this task called schedule() in the past. prev == current : 
2
strstr : if : 		 * this task called schedule() in the past. prev == current : 
2
strstr : for : 		 * this task called schedule() in the past. prev == current : 
2
strstr : while : 		 * this task called schedule() in the past. prev == current : 
2
str : 		 * is still correct, but it can be moved to another cpu/rq.[61]
strstr : INIT : 		 * is still correct, but it can be moved to another cpu/rq. : 
2
strstr : if : 		 * is still correct, but it can be moved to another cpu/rq. : 
2
strstr : for : 		 * is still correct, but it can be moved to another cpu/rq. : 
2
strstr : while : 		 * is still correct, but it can be moved to another cpu/rq. : 
2
str : 		 */[5]
strstr : INIT : 		 */ : 
2
strstr : if : 		 */ : 
2
strstr : for : 		 */ : 
2
strstr : while : 		 */ : 
2
str : 		cpu = smp_processor_id();[27]
strstr : INIT : 		cpu = smp_processor_id(); : 
2
strstr : if : 		cpu = smp_processor_id(); : 
2
strstr : for : 		cpu = smp_processor_id(); : 
2
strstr : while : 		cpu = smp_processor_id(); : 
2
str : 		rq = cpu_rq(cpu);[19]
strstr : INIT : 		rq = cpu_rq(cpu); : 
2
strstr : if : 		rq = cpu_rq(cpu); : 
2
strstr : for : 		rq = cpu_rq(cpu); : 
2
strstr : while : 		rq = cpu_rq(cpu); : 
2
str : 	} else[7]
strstr : INIT : 	} else : 
2
strstr : if : 	} else : 
2
strstr : for : 	} else : 
2
strstr : while : 	} else : 
2
str : 		raw_spin_unlock_irq(&rq->lock);[33]
strstr : INIT : 		raw_spin_unlock_irq(&rq->lock); : 
2
strstr : if : 		raw_spin_unlock_irq(&rq->lock); : 
2
strstr : for : 		raw_spin_unlock_irq(&rq->lock); : 
2
strstr : while : 		raw_spin_unlock_irq(&rq->lock); : 
2
str : 	post_schedule(rq);[19]
strstr : INIT : 	post_schedule(rq); : 
2
strstr : if : 	post_schedule(rq); : 
2
strstr : for : 	post_schedule(rq); : 
2
strstr : while : 	post_schedule(rq); : 
2
str : 	sched_preempt_enable_no_resched();[35]
strstr : INIT : 	sched_preempt_enable_no_resched(); : 
2
strstr : if : 	sched_preempt_enable_no_resched(); : 
2
strstr : for : 	sched_preempt_enable_no_resched(); : 
2
strstr : while : 	sched_preempt_enable_no_resched(); : 
2
str : 	if (need_resched())[20]
strstr : INIT : 	if (need_resched()) : 
2
strstr : if : 	if (need_resched()) : 
2
strstr : for : 	if (need_resched()) : 
2
strstr : while : 	if (need_resched()) : 
2
str : 		goto need_resched;[20]
strstr : INIT : 		goto need_resched; : 
2
strstr : if : 		goto need_resched; : 
2
strstr : for : 		goto need_resched; : 
2
strstr : while : 		goto need_resched; : 
2
str : static inline void sched_submit_work(struct task_struct *tsk)[61]
strstr : INIT : static inline void sched_submit_work(struct task_struct *tsk) : 
2
strstr : if : static inline void sched_submit_work(struct task_struct *tsk) : 
2
strstr : for : static inline void sched_submit_work(struct task_struct *tsk) : 
2
strstr : while : static inline void sched_submit_work(struct task_struct *tsk) : 
2
str : 	if (!tsk->state || tsk_is_pi_blocked(tsk))[43]
strstr : INIT : 	if (!tsk->state || tsk_is_pi_blocked(tsk)) : 
2
strstr : if : 	if (!tsk->state || tsk_is_pi_blocked(tsk)) : 
2
strstr : for : 	if (!tsk->state || tsk_is_pi_blocked(tsk)) : 
2
strstr : while : 	if (!tsk->state || tsk_is_pi_blocked(tsk)) : 
2
str : 		return;[9]
strstr : INIT : 		return; : 
2
strstr : if : 		return; : 
2
strstr : for : 		return; : 
2
strstr : while : 		return; : 
2
str : 	/*[3]
strstr : INIT : 	/* : 
2
strstr : if : 	/* : 
2
strstr : for : 	/* : 
2
strstr : while : 	/* : 
2
str : 	 * If we are going to sleep and we have plugged IO queued,[59]
strstr : INIT : 	 * If we are going to sleep and we have plugged IO queued, : 
2
strstr : if : 	 * If we are going to sleep and we have plugged IO queued, : 
2
strstr : for : 	 * If we are going to sleep and we have plugged IO queued, : 
2
strstr : while : 	 * If we are going to sleep and we have plugged IO queued, : 
2
str : 	 * make sure to submit it to avoid deadlocks.[46]
strstr : INIT : 	 * make sure to submit it to avoid deadlocks. : 
2
strstr : if : 	 * make sure to submit it to avoid deadlocks. : 
2
strstr : for : 	 * make sure to submit it to avoid deadlocks. : 
2
strstr : while : 	 * make sure to submit it to avoid deadlocks. : 
2
str : 	 */[4]
strstr : INIT : 	 */ : 
2
strstr : if : 	 */ : 
2
strstr : for : 	 */ : 
2
strstr : while : 	 */ : 
2
str : 	if (blk_needs_flush_plug(tsk))[31]
strstr : INIT : 	if (blk_needs_flush_plug(tsk)) : 
2
strstr : if : 	if (blk_needs_flush_plug(tsk)) : 
2
strstr : for : 	if (blk_needs_flush_plug(tsk)) : 
2
strstr : while : 	if (blk_needs_flush_plug(tsk)) : 
2
str : 		blk_schedule_flush_plug(tsk);[31]
strstr : INIT : 		blk_schedule_flush_plug(tsk); : 
2
strstr : if : 		blk_schedule_flush_plug(tsk); : 
2
strstr : for : 		blk_schedule_flush_plug(tsk); : 
2
strstr : while : 		blk_schedule_flush_plug(tsk); : 
2
str : asmlinkage void __sched schedule(void)[38]
strstr : INIT : asmlinkage void __sched schedule(void) : 
2
strstr : if : asmlinkage void __sched schedule(void) : 
2
strstr : for : asmlinkage void __sched schedule(void) : 
2
strstr : while : asmlinkage void __sched schedule(void) : 
2
str : 	struct task_struct *tsk = current;[35]
strstr : INIT : 	struct task_struct *tsk = current; : 
2
strstr : if : 	struct task_struct *tsk = current; : 
2
strstr : for : 	struct task_struct *tsk = current; : 
2
strstr : while : 	struct task_struct *tsk = current; : 
2
str : 	sched_submit_work(tsk);[24]
strstr : INIT : 	sched_submit_work(tsk); : 
2
strstr : if : 	sched_submit_work(tsk); : 
2
strstr : for : 	sched_submit_work(tsk); : 
2
strstr : while : 	sched_submit_work(tsk); : 
2
str : 	__schedule();[14]
strstr : INIT : 	__schedule(); : 
2
strstr : if : 	__schedule(); : 
2
strstr : for : 	__schedule(); : 
2
strstr : while : 	__schedule(); : 
2
str : EXPORT_SYMBOL(schedule);[24]
strstr : INIT : EXPORT_SYMBOL(schedule); : 
2
strstr : if : EXPORT_SYMBOL(schedule); : 
2
strstr : for : EXPORT_SYMBOL(schedule); : 
2
strstr : while : EXPORT_SYMBOL(schedule); : 
2
str : #ifdef CONFIG_CONTEXT_TRACKING[30]
strstr : INIT : #ifdef CONFIG_CONTEXT_TRACKING : 
2
strstr : if : #ifdef CONFIG_CONTEXT_TRACKING : 
2
strstr : for : #ifdef CONFIG_CONTEXT_TRACKING : 
2
strstr : while : #ifdef CONFIG_CONTEXT_TRACKING : 
2
str : asmlinkage void __sched schedule_user(void)[43]
strstr : INIT : asmlinkage void __sched schedule_user(void) : 
2
strstr : if : asmlinkage void __sched schedule_user(void) : 
2
strstr : for : asmlinkage void __sched schedule_user(void) : 
2
strstr : while : asmlinkage void __sched schedule_user(void) : 
2
str : 	/*[3]
strstr : INIT : 	/* : 
2
strstr : if : 	/* : 
2
strstr : for : 	/* : 
2
strstr : while : 	/* : 
2
str : 	 * If we come here after a random call to set_need_resched(),[62]
strstr : INIT : 	 * If we come here after a random call to set_need_resched(), : 
2
strstr : if : 	 * If we come here after a random call to set_need_resched(), : 
2
strstr : for : 	 * If we come here after a random call to set_need_resched(), : 
2
strstr : while : 	 * If we come here after a random call to set_need_resched(), : 
2
str : 	 * or we have been woken up remotely but the IPI has not yet arrived,[70]
strstr : INIT : 	 * or we have been woken up remotely but the IPI has not yet arrived, : 
2
strstr : if : 	 * or we have been woken up remotely but the IPI has not yet arrived, : 
2
strstr : for : 	 * or we have been woken up remotely but the IPI has not yet arrived, : 
2
strstr : while : 	 * or we have been woken up remotely but the IPI has not yet arrived, : 
2
str : 	 * we haven't yet exited the RCU idle mode. Do it here manually until[70]
strstr : INIT : 	 * we haven't yet exited the RCU idle mode. Do it here manually until : 
2
strstr : if : 	 * we haven't yet exited the RCU idle mode. Do it here manually until : 
2
strstr : for : 	 * we haven't yet exited the RCU idle mode. Do it here manually until : 
2
strstr : while : 	 * we haven't yet exited the RCU idle mode. Do it here manually until : 
2
str : 	 * we find a better solution.[30]
strstr : INIT : 	 * we find a better solution. : 
2
strstr : if : 	 * we find a better solution. : 
2
strstr : for : 	 * we find a better solution. : 
2
strstr : while : 	 * we find a better solution. : 
2
str : 	 */[4]
strstr : INIT : 	 */ : 
2
strstr : if : 	 */ : 
2
strstr : for : 	 */ : 
2
strstr : while : 	 */ : 
2
str : 	user_exit();[13]
strstr : INIT : 	user_exit(); : 
2
strstr : if : 	user_exit(); : 
2
strstr : for : 	user_exit(); : 
2
strstr : while : 	user_exit(); : 
2
str : 	schedule();[12]
strstr : INIT : 	schedule(); : 
2
strstr : if : 	schedule(); : 
2
strstr : for : 	schedule(); : 
2
strstr : while : 	schedule(); : 
2
str : 	user_enter();[14]
strstr : INIT : 	user_enter(); : 
2
strstr : if : 	user_enter(); : 
2
strstr : for : 	user_enter(); : 
2
strstr : while : 	user_enter(); : 
2
str : #endif[6]
strstr : INIT : #endif : 
2
strstr : if : #endif : 
2
strstr : for : #endif : 
2
strstr : while : #endif : 
2
str : /**[3]
strstr : INIT : /** : 
2
strstr : if : /** : 
2
strstr : for : /** : 
2
strstr : while : /** : 
2
str :  * schedule_preempt_disabled - called with preemption disabled[62]
strstr : INIT :  * schedule_preempt_disabled - called with preemption disabled : 
2
strstr : if :  * schedule_preempt_disabled - called with preemption disabled : 
2
strstr : for :  * schedule_preempt_disabled - called with preemption disabled : 
2
strstr : while :  * schedule_preempt_disabled - called with preemption disabled : 
2
str :  * Returns with preemption disabled. Note: preempt_count must be 1[66]
strstr : INIT :  * Returns with preemption disabled. Note: preempt_count must be 1 : 
2
strstr : if :  * Returns with preemption disabled. Note: preempt_count must be 1 : 
2
strstr : for :  * Returns with preemption disabled. Note: preempt_count must be 1 : 
2
strstr : while :  * Returns with preemption disabled. Note: preempt_count must be 1 : 
2
str :  */[3]
strstr : INIT :  */ : 
2
strstr : if :  */ : 
2
strstr : for :  */ : 
2
strstr : while :  */ : 
2
str : void __sched schedule_preempt_disabled(void)[44]
strstr : INIT : void __sched schedule_preempt_disabled(void) : 
2
strstr : if : void __sched schedule_preempt_disabled(void) : 
2
strstr : for : void __sched schedule_preempt_disabled(void) : 
2
strstr : while : void __sched schedule_preempt_disabled(void) : 
2
str : 	sched_preempt_enable_no_resched();[35]
strstr : INIT : 	sched_preempt_enable_no_resched(); : 
2
strstr : if : 	sched_preempt_enable_no_resched(); : 
2
strstr : for : 	sched_preempt_enable_no_resched(); : 
2
strstr : while : 	sched_preempt_enable_no_resched(); : 
2
str : 	schedule();[12]
strstr : INIT : 	schedule(); : 
2
strstr : if : 	schedule(); : 
2
strstr : for : 	schedule(); : 
2
strstr : while : 	schedule(); : 
2
str : 	preempt_disable();[19]
strstr : INIT : 	preempt_disable(); : 
2
strstr : if : 	preempt_disable(); : 
2
strstr : for : 	preempt_disable(); : 
2
strstr : while : 	preempt_disable(); : 
2
str : #ifdef CONFIG_PREEMPT[21]
strstr : INIT : #ifdef CONFIG_PREEMPT : 
2
strstr : if : #ifdef CONFIG_PREEMPT : 
2
strstr : for : #ifdef CONFIG_PREEMPT : 
2
strstr : while : #ifdef CONFIG_PREEMPT : 
2
str :  * this is the entry point to schedule() from in-kernel preemption[66]
strstr : INIT :  * this is the entry point to schedule() from in-kernel preemption : 
2
strstr : if :  * this is the entry point to schedule() from in-kernel preemption : 
2
strstr : for :  * this is the entry point to schedule() from in-kernel preemption : 
2
strstr : while :  * this is the entry point to schedule() from in-kernel preemption : 
2
str :  * off of preempt_enable. Kernel preemptions off return from interrupt[70]
strstr : INIT :  * off of preempt_enable. Kernel preemptions off return from interrupt : 
2
strstr : if :  * off of preempt_enable. Kernel preemptions off return from interrupt : 
2
strstr : for :  * off of preempt_enable. Kernel preemptions off return from interrupt : 
2
strstr : while :  * off of preempt_enable. Kernel preemptions off return from interrupt : 
2
str :  * occur there and call schedule directly.[42]
strstr : INIT :  * occur there and call schedule directly. : 
2
strstr : if :  * occur there and call schedule directly. : 
2
strstr : for :  * occur there and call schedule directly. : 
2
strstr : while :  * occur there and call schedule directly. : 
2
str :  */[3]
strstr : INIT :  */ : 
2
strstr : if :  */ : 
2
strstr : for :  */ : 
2
strstr : while :  */ : 
2
str : asmlinkage void __sched notrace preempt_schedule(void)[54]
strstr : INIT : asmlinkage void __sched notrace preempt_schedule(void) : 
2
strstr : if : asmlinkage void __sched notrace preempt_schedule(void) : 
2
strstr : for : asmlinkage void __sched notrace preempt_schedule(void) : 
2
strstr : while : asmlinkage void __sched notrace preempt_schedule(void) : 
2
str : 	/*[3]
strstr : INIT : 	/* : 
2
strstr : if : 	/* : 
2
strstr : for : 	/* : 
2
strstr : while : 	/* : 
2
str : 	 * If there is a non-zero preempt_count or interrupts are disabled,[68]
strstr : INIT : 	 * If there is a non-zero preempt_count or interrupts are disabled, : 
2
strstr : if : 	 * If there is a non-zero preempt_count or interrupts are disabled, : 
2
strstr : for : 	 * If there is a non-zero preempt_count or interrupts are disabled, : 
2
strstr : while : 	 * If there is a non-zero preempt_count or interrupts are disabled, : 
2
str : 	 * we do not want to preempt the current task. Just return..[61]
strstr : INIT : 	 * we do not want to preempt the current task. Just return.. : 
2
strstr : if : 	 * we do not want to preempt the current task. Just return.. : 
2
strstr : for : 	 * we do not want to preempt the current task. Just return.. : 
2
strstr : while : 	 * we do not want to preempt the current task. Just return.. : 
2
str : 	 */[4]
strstr : INIT : 	 */ : 
2
strstr : if : 	 */ : 
2
strstr : for : 	 */ : 
2
strstr : while : 	 */ : 
2
str : 	if (likely(!preemptible()))[28]
strstr : INIT : 	if (likely(!preemptible())) : 
2
strstr : if : 	if (likely(!preemptible())) : 
2
strstr : for : 	if (likely(!preemptible())) : 
2
strstr : while : 	if (likely(!preemptible())) : 
2
str : 		return;[9]
strstr : INIT : 		return; : 
2
strstr : if : 		return; : 
2
strstr : for : 		return; : 
2
strstr : while : 		return; : 
2
str : 	do {[5]
strstr : INIT : 	do { : 
2
strstr : if : 	do { : 
2
strstr : for : 	do { : 
2
strstr : while : 	do { : 
2
str : 		__preempt_count_add(PREEMPT_ACTIVE);[38]
strstr : INIT : 		__preempt_count_add(PREEMPT_ACTIVE); : 
2
strstr : if : 		__preempt_count_add(PREEMPT_ACTIVE); : 
2
strstr : for : 		__preempt_count_add(PREEMPT_ACTIVE); : 
2
strstr : while : 		__preempt_count_add(PREEMPT_ACTIVE); : 
2
str : 		__schedule();[15]
strstr : INIT : 		__schedule(); : 
2
strstr : if : 		__schedule(); : 
2
strstr : for : 		__schedule(); : 
2
strstr : while : 		__schedule(); : 
2
str : 		__preempt_count_sub(PREEMPT_ACTIVE);[38]
strstr : INIT : 		__preempt_count_sub(PREEMPT_ACTIVE); : 
2
strstr : if : 		__preempt_count_sub(PREEMPT_ACTIVE); : 
2
strstr : for : 		__preempt_count_sub(PREEMPT_ACTIVE); : 
2
strstr : while : 		__preempt_count_sub(PREEMPT_ACTIVE); : 
2
str : 		/*[4]
strstr : INIT : 		/* : 
2
strstr : if : 		/* : 
2
strstr : for : 		/* : 
2
strstr : while : 		/* : 
2
str : 		 * Check again in case we missed a preemption opportunity[59]
strstr : INIT : 		 * Check again in case we missed a preemption opportunity : 
2
strstr : if : 		 * Check again in case we missed a preemption opportunity : 
2
strstr : for : 		 * Check again in case we missed a preemption opportunity : 
2
strstr : while : 		 * Check again in case we missed a preemption opportunity : 
2
str : 		 * between schedule and now.[30]
strstr : INIT : 		 * between schedule and now. : 
2
strstr : if : 		 * between schedule and now. : 
2
strstr : for : 		 * between schedule and now. : 
2
strstr : while : 		 * between schedule and now. : 
2
str : 		 */[5]
strstr : INIT : 		 */ : 
2
strstr : if : 		 */ : 
2
strstr : for : 		 */ : 
2
strstr : while : 		 */ : 
2
str : 		barrier();[12]
strstr : INIT : 		barrier(); : 
2
strstr : if : 		barrier(); : 
2
strstr : for : 		barrier(); : 
2
strstr : while : 		barrier(); : 
2
str : 	} while (need_resched());[26]
strstr : INIT : 	} while (need_resched()); : 
2
strstr : if : 	} while (need_resched()); : 
2
strstr : for : 	} while (need_resched()); : 
2
strstr : while : 	} while (need_resched()); : 
2
str : EXPORT_SYMBOL(preempt_schedule);[32]
strstr : INIT : EXPORT_SYMBOL(preempt_schedule); : 
2
strstr : if : EXPORT_SYMBOL(preempt_schedule); : 
2
strstr : for : EXPORT_SYMBOL(preempt_schedule); : 
2
strstr : while : EXPORT_SYMBOL(preempt_schedule); : 
2
str : #endif /* CONFIG_PREEMPT */[27]
strstr : INIT : #endif /* CONFIG_PREEMPT */ : 
2
strstr : if : #endif /* CONFIG_PREEMPT */ : 
2
strstr : for : #endif /* CONFIG_PREEMPT */ : 
2
strstr : while : #endif /* CONFIG_PREEMPT */ : 
2
str :  * this is the entry point to schedule() from kernel preemption[63]
strstr : INIT :  * this is the entry point to schedule() from kernel preemption : 
2
strstr : if :  * this is the entry point to schedule() from kernel preemption : 
2
strstr : for :  * this is the entry point to schedule() from kernel preemption : 
2
strstr : while :  * this is the entry point to schedule() from kernel preemption : 
2
str :  * off of irq context.[22]
strstr : INIT :  * off of irq context. : 
2
strstr : if :  * off of irq context. : 
2
strstr : for :  * off of irq context. : 
2
strstr : while :  * off of irq context. : 
2
str :  * Note, that this is called and return with irqs disabled. This will[69]
strstr : INIT :  * Note, that this is called and return with irqs disabled. This will : 
2
strstr : if :  * Note, that this is called and return with irqs disabled. This will : 
2
strstr : for :  * Note, that this is called and return with irqs disabled. This will : 
2
strstr : while :  * Note, that this is called and return with irqs disabled. This will : 
2
str :  * protect us against recursive calling from irq.[49]
strstr : INIT :  * protect us against recursive calling from irq. : 
2
strstr : if :  * protect us against recursive calling from irq. : 
2
strstr : for :  * protect us against recursive calling from irq. : 
2
strstr : while :  * protect us against recursive calling from irq. : 
2
str :  */[3]
strstr : INIT :  */ : 
2
strstr : if :  */ : 
2
strstr : for :  */ : 
2
strstr : while :  */ : 
2
str : asmlinkage void __sched preempt_schedule_irq(void)[50]
strstr : INIT : asmlinkage void __sched preempt_schedule_irq(void) : 
2
strstr : if : asmlinkage void __sched preempt_schedule_irq(void) : 
2
strstr : for : asmlinkage void __sched preempt_schedule_irq(void) : 
2
strstr : while : asmlinkage void __sched preempt_schedule_irq(void) : 
2
str : 	enum ctx_state prev_state;[27]
strstr : INIT : 	enum ctx_state prev_state; : 
2
strstr : if : 	enum ctx_state prev_state; : 
2
strstr : for : 	enum ctx_state prev_state; : 
2
strstr : while : 	enum ctx_state prev_state; : 
2
str : 	/* Catch callers which need to be fixed */[43]
strstr : INIT : 	/* Catch callers which need to be fixed */ : 
2
strstr : if : 	/* Catch callers which need to be fixed */ : 
2
strstr : for : 	/* Catch callers which need to be fixed */ : 
2
strstr : while : 	/* Catch callers which need to be fixed */ : 
2
str : 	BUG_ON(preempt_count() || !irqs_disabled());[45]
strstr : INIT : 	BUG_ON(preempt_count() || !irqs_disabled()); : 
2
strstr : if : 	BUG_ON(preempt_count() || !irqs_disabled()); : 
2
strstr : for : 	BUG_ON(preempt_count() || !irqs_disabled()); : 
2
strstr : while : 	BUG_ON(preempt_count() || !irqs_disabled()); : 
2
str : 	prev_state = exception_enter();[32]
strstr : INIT : 	prev_state = exception_enter(); : 
2
strstr : if : 	prev_state = exception_enter(); : 
2
strstr : for : 	prev_state = exception_enter(); : 
2
strstr : while : 	prev_state = exception_enter(); : 
2
str : 	do {[5]
strstr : INIT : 	do { : 
2
strstr : if : 	do { : 
2
strstr : for : 	do { : 
2
strstr : while : 	do { : 
2
str : 		__preempt_count_add(PREEMPT_ACTIVE);[38]
strstr : INIT : 		__preempt_count_add(PREEMPT_ACTIVE); : 
2
strstr : if : 		__preempt_count_add(PREEMPT_ACTIVE); : 
2
strstr : for : 		__preempt_count_add(PREEMPT_ACTIVE); : 
2
strstr : while : 		__preempt_count_add(PREEMPT_ACTIVE); : 
2
str : 		local_irq_enable();[21]
strstr : INIT : 		local_irq_enable(); : 
2
strstr : if : 		local_irq_enable(); : 
2
strstr : for : 		local_irq_enable(); : 
2
strstr : while : 		local_irq_enable(); : 
2
str : 		__schedule();[15]
strstr : INIT : 		__schedule(); : 
2
strstr : if : 		__schedule(); : 
2
strstr : for : 		__schedule(); : 
2
strstr : while : 		__schedule(); : 
2
str : 		local_irq_disable();[22]
strstr : INIT : 		local_irq_disable(); : 
2
strstr : if : 		local_irq_disable(); : 
2
strstr : for : 		local_irq_disable(); : 
2
strstr : while : 		local_irq_disable(); : 
2
str : 		__preempt_count_sub(PREEMPT_ACTIVE);[38]
strstr : INIT : 		__preempt_count_sub(PREEMPT_ACTIVE); : 
2
strstr : if : 		__preempt_count_sub(PREEMPT_ACTIVE); : 
2
strstr : for : 		__preempt_count_sub(PREEMPT_ACTIVE); : 
2
strstr : while : 		__preempt_count_sub(PREEMPT_ACTIVE); : 
2
str : 		/*[4]
strstr : INIT : 		/* : 
2
strstr : if : 		/* : 
2
strstr : for : 		/* : 
2
strstr : while : 		/* : 
2
str : 		 * Check again in case we missed a preemption opportunity[59]
strstr : INIT : 		 * Check again in case we missed a preemption opportunity : 
2
strstr : if : 		 * Check again in case we missed a preemption opportunity : 
2
strstr : for : 		 * Check again in case we missed a preemption opportunity : 
2
strstr : while : 		 * Check again in case we missed a preemption opportunity : 
2
str : 		 * between schedule and now.[30]
strstr : INIT : 		 * between schedule and now. : 
2
strstr : if : 		 * between schedule and now. : 
2
strstr : for : 		 * between schedule and now. : 
2
strstr : while : 		 * between schedule and now. : 
2
str : 		 */[5]
strstr : INIT : 		 */ : 
2
strstr : if : 		 */ : 
2
strstr : for : 		 */ : 
2
strstr : while : 		 */ : 
2
str : 		barrier();[12]
strstr : INIT : 		barrier(); : 
2
strstr : if : 		barrier(); : 
2
strstr : for : 		barrier(); : 
2
strstr : while : 		barrier(); : 
2
str : 	} while (need_resched());[26]
strstr : INIT : 	} while (need_resched()); : 
2
strstr : if : 	} while (need_resched()); : 
2
strstr : for : 	} while (need_resched()); : 
2
strstr : while : 	} while (need_resched()); : 
2
str : 	exception_exit(prev_state);[28]
strstr : INIT : 	exception_exit(prev_state); : 
2
strstr : if : 	exception_exit(prev_state); : 
2
strstr : for : 	exception_exit(prev_state); : 
2
strstr : while : 	exception_exit(prev_state); : 
2
str : int default_wake_function(wait_queue_t *curr, unsigned mode, int wake_flags,[76]
strstr : INIT : int default_wake_function(wait_queue_t *curr, unsigned mode, int wake_flags, : 
2
strstr : if : int default_wake_function(wait_queue_t *curr, unsigned mode, int wake_flags, : 
2
strstr : for : int default_wake_function(wait_queue_t *curr, unsigned mode, int wake_flags, : 
2
strstr : while : int default_wake_function(wait_queue_t *curr, unsigned mode, int wake_flags, : 
2
str : 			  void *key)[15]
strstr : INIT : 			  void *key) : 
2
strstr : if : 			  void *key) : 
2
strstr : for : 			  void *key) : 
2
strstr : while : 			  void *key) : 
2
str : 	return try_to_wake_up(curr->private, mode, wake_flags);[56]
strstr : INIT : 	return try_to_wake_up(curr->private, mode, wake_flags); : 
2
strstr : if : 	return try_to_wake_up(curr->private, mode, wake_flags); : 
2
strstr : for : 	return try_to_wake_up(curr->private, mode, wake_flags); : 
2
strstr : while : 	return try_to_wake_up(curr->private, mode, wake_flags); : 
2
str : EXPORT_SYMBOL(default_wake_function);[37]
strstr : INIT : EXPORT_SYMBOL(default_wake_function); : 
2
strstr : if : EXPORT_SYMBOL(default_wake_function); : 
2
strstr : for : EXPORT_SYMBOL(default_wake_function); : 
2
strstr : while : EXPORT_SYMBOL(default_wake_function); : 
2
str : static long __sched[19]
strstr : INIT : static long __sched : 
2
strstr : if : static long __sched : 
2
strstr : for : static long __sched : 
2
strstr : while : static long __sched : 
2
str : sleep_on_common(wait_queue_head_t *q, int state, long timeout)[62]
strstr : INIT : sleep_on_common(wait_queue_head_t *q, int state, long timeout) : 
2
strstr : if : sleep_on_common(wait_queue_head_t *q, int state, long timeout) : 
2
strstr : for : sleep_on_common(wait_queue_head_t *q, int state, long timeout) : 
2
strstr : while : sleep_on_common(wait_queue_head_t *q, int state, long timeout) : 
2
str : 	unsigned long flags;[21]
strstr : INIT : 	unsigned long flags; : 
2
strstr : if : 	unsigned long flags; : 
2
strstr : for : 	unsigned long flags; : 
2
strstr : while : 	unsigned long flags; : 
2
str : 	wait_queue_t wait;[19]
strstr : INIT : 	wait_queue_t wait; : 
2
strstr : if : 	wait_queue_t wait; : 
2
strstr : for : 	wait_queue_t wait; : 
2
strstr : while : 	wait_queue_t wait; : 
2
str : 	init_waitqueue_entry(&wait, current);[38]
strstr : INIT : 	init_waitqueue_entry(&wait, current); : 
2
strstr : if : 	init_waitqueue_entry(&wait, current); : 
2
strstr : for : 	init_waitqueue_entry(&wait, current); : 
2
strstr : while : 	init_waitqueue_entry(&wait, current); : 
2
str : 	__set_current_state(state);[28]
strstr : INIT : 	__set_current_state(state); : 
2
strstr : if : 	__set_current_state(state); : 
2
strstr : for : 	__set_current_state(state); : 
2
strstr : while : 	__set_current_state(state); : 
2
str : 	spin_lock_irqsave(&q->lock, flags);[36]
strstr : INIT : 	spin_lock_irqsave(&q->lock, flags); : 
2
strstr : if : 	spin_lock_irqsave(&q->lock, flags); : 
2
strstr : for : 	spin_lock_irqsave(&q->lock, flags); : 
2
strstr : while : 	spin_lock_irqsave(&q->lock, flags); : 
2
str : 	__add_wait_queue(q, &wait);[28]
strstr : INIT : 	__add_wait_queue(q, &wait); : 
2
strstr : if : 	__add_wait_queue(q, &wait); : 
2
strstr : for : 	__add_wait_queue(q, &wait); : 
2
strstr : while : 	__add_wait_queue(q, &wait); : 
2
str : 	spin_unlock(&q->lock);[23]
strstr : INIT : 	spin_unlock(&q->lock); : 
2
strstr : if : 	spin_unlock(&q->lock); : 
2
strstr : for : 	spin_unlock(&q->lock); : 
2
strstr : while : 	spin_unlock(&q->lock); : 
2
str : 	timeout = schedule_timeout(timeout);[37]
strstr : INIT : 	timeout = schedule_timeout(timeout); : 
2
strstr : if : 	timeout = schedule_timeout(timeout); : 
2
strstr : for : 	timeout = schedule_timeout(timeout); : 
2
strstr : while : 	timeout = schedule_timeout(timeout); : 
2
str : 	spin_lock_irq(&q->lock);[25]
strstr : INIT : 	spin_lock_irq(&q->lock); : 
2
strstr : if : 	spin_lock_irq(&q->lock); : 
2
strstr : for : 	spin_lock_irq(&q->lock); : 
2
strstr : while : 	spin_lock_irq(&q->lock); : 
2
str : 	__remove_wait_queue(q, &wait);[31]
strstr : INIT : 	__remove_wait_queue(q, &wait); : 
2
strstr : if : 	__remove_wait_queue(q, &wait); : 
2
strstr : for : 	__remove_wait_queue(q, &wait); : 
2
strstr : while : 	__remove_wait_queue(q, &wait); : 
2
str : 	spin_unlock_irqrestore(&q->lock, flags);[41]
strstr : INIT : 	spin_unlock_irqrestore(&q->lock, flags); : 
2
strstr : if : 	spin_unlock_irqrestore(&q->lock, flags); : 
2
strstr : for : 	spin_unlock_irqrestore(&q->lock, flags); : 
2
strstr : while : 	spin_unlock_irqrestore(&q->lock, flags); : 
2
str : 	return timeout;[16]
strstr : INIT : 	return timeout; : 
2
strstr : if : 	return timeout; : 
2
strstr : for : 	return timeout; : 
2
strstr : while : 	return timeout; : 
2
str : void __sched interruptible_sleep_on(wait_queue_head_t *q)[57]
strstr : INIT : void __sched interruptible_sleep_on(wait_queue_head_t *q) : 
2
strstr : if : void __sched interruptible_sleep_on(wait_queue_head_t *q) : 
2
strstr : for : void __sched interruptible_sleep_on(wait_queue_head_t *q) : 
2
strstr : while : void __sched interruptible_sleep_on(wait_queue_head_t *q) : 
2
str : 	sleep_on_common(q, TASK_INTERRUPTIBLE, MAX_SCHEDULE_TIMEOUT);[62]
strstr : INIT : 	sleep_on_common(q, TASK_INTERRUPTIBLE, MAX_SCHEDULE_TIMEOUT); : 
2
strstr : if : 	sleep_on_common(q, TASK_INTERRUPTIBLE, MAX_SCHEDULE_TIMEOUT); : 
2
strstr : for : 	sleep_on_common(q, TASK_INTERRUPTIBLE, MAX_SCHEDULE_TIMEOUT); : 
2
strstr : while : 	sleep_on_common(q, TASK_INTERRUPTIBLE, MAX_SCHEDULE_TIMEOUT); : 
2
str : EXPORT_SYMBOL(interruptible_sleep_on);[38]
strstr : INIT : EXPORT_SYMBOL(interruptible_sleep_on); : 
2
strstr : if : EXPORT_SYMBOL(interruptible_sleep_on); : 
2
strstr : for : EXPORT_SYMBOL(interruptible_sleep_on); : 
2
strstr : while : EXPORT_SYMBOL(interruptible_sleep_on); : 
2
str : long __sched[12]
strstr : INIT : long __sched : 
2
strstr : if : long __sched : 
2
strstr : for : long __sched : 
2
strstr : while : long __sched : 
2
str : interruptible_sleep_on_timeout(wait_queue_head_t *q, long timeout)[66]
strstr : INIT : interruptible_sleep_on_timeout(wait_queue_head_t *q, long timeout) : 
2
strstr : if : interruptible_sleep_on_timeout(wait_queue_head_t *q, long timeout) : 
2
strstr : for : interruptible_sleep_on_timeout(wait_queue_head_t *q, long timeout) : 
2
strstr : while : interruptible_sleep_on_timeout(wait_queue_head_t *q, long timeout) : 
2
str : 	return sleep_on_common(q, TASK_INTERRUPTIBLE, timeout);[56]
strstr : INIT : 	return sleep_on_common(q, TASK_INTERRUPTIBLE, timeout); : 
2
strstr : if : 	return sleep_on_common(q, TASK_INTERRUPTIBLE, timeout); : 
2
strstr : for : 	return sleep_on_common(q, TASK_INTERRUPTIBLE, timeout); : 
2
strstr : while : 	return sleep_on_common(q, TASK_INTERRUPTIBLE, timeout); : 
2
str : EXPORT_SYMBOL(interruptible_sleep_on_timeout);[46]
strstr : INIT : EXPORT_SYMBOL(interruptible_sleep_on_timeout); : 
2
strstr : if : EXPORT_SYMBOL(interruptible_sleep_on_timeout); : 
2
strstr : for : EXPORT_SYMBOL(interruptible_sleep_on_timeout); : 
2
strstr : while : EXPORT_SYMBOL(interruptible_sleep_on_timeout); : 
2
str : void __sched sleep_on(wait_queue_head_t *q)[43]
strstr : INIT : void __sched sleep_on(wait_queue_head_t *q) : 
2
strstr : if : void __sched sleep_on(wait_queue_head_t *q) : 
2
strstr : for : void __sched sleep_on(wait_queue_head_t *q) : 
2
strstr : while : void __sched sleep_on(wait_queue_head_t *q) : 
2
str : 	sleep_on_common(q, TASK_UNINTERRUPTIBLE, MAX_SCHEDULE_TIMEOUT);[64]
strstr : INIT : 	sleep_on_common(q, TASK_UNINTERRUPTIBLE, MAX_SCHEDULE_TIMEOUT); : 
2
strstr : if : 	sleep_on_common(q, TASK_UNINTERRUPTIBLE, MAX_SCHEDULE_TIMEOUT); : 
2
strstr : for : 	sleep_on_common(q, TASK_UNINTERRUPTIBLE, MAX_SCHEDULE_TIMEOUT); : 
2
strstr : while : 	sleep_on_common(q, TASK_UNINTERRUPTIBLE, MAX_SCHEDULE_TIMEOUT); : 
2
str : EXPORT_SYMBOL(sleep_on);[24]
strstr : INIT : EXPORT_SYMBOL(sleep_on); : 
2
strstr : if : EXPORT_SYMBOL(sleep_on); : 
2
strstr : for : EXPORT_SYMBOL(sleep_on); : 
2
strstr : while : EXPORT_SYMBOL(sleep_on); : 
2
str : long __sched sleep_on_timeout(wait_queue_head_t *q, long timeout)[65]
strstr : INIT : long __sched sleep_on_timeout(wait_queue_head_t *q, long timeout) : 
2
strstr : if : long __sched sleep_on_timeout(wait_queue_head_t *q, long timeout) : 
2
strstr : for : long __sched sleep_on_timeout(wait_queue_head_t *q, long timeout) : 
2
strstr : while : long __sched sleep_on_timeout(wait_queue_head_t *q, long timeout) : 
2
str : 	return sleep_on_common(q, TASK_UNINTERRUPTIBLE, timeout);[58]
strstr : INIT : 	return sleep_on_common(q, TASK_UNINTERRUPTIBLE, timeout); : 
2
strstr : if : 	return sleep_on_common(q, TASK_UNINTERRUPTIBLE, timeout); : 
2
strstr : for : 	return sleep_on_common(q, TASK_UNINTERRUPTIBLE, timeout); : 
2
strstr : while : 	return sleep_on_common(q, TASK_UNINTERRUPTIBLE, timeout); : 
2
str : EXPORT_SYMBOL(sleep_on_timeout);[32]
strstr : INIT : EXPORT_SYMBOL(sleep_on_timeout); : 
2
strstr : if : EXPORT_SYMBOL(sleep_on_timeout); : 
2
strstr : for : EXPORT_SYMBOL(sleep_on_timeout); : 
2
strstr : while : EXPORT_SYMBOL(sleep_on_timeout); : 
2
str : #ifdef CONFIG_RT_MUTEXES[24]
strstr : INIT : #ifdef CONFIG_RT_MUTEXES : 
2
strstr : if : #ifdef CONFIG_RT_MUTEXES : 
2
strstr : for : #ifdef CONFIG_RT_MUTEXES : 
2
strstr : while : #ifdef CONFIG_RT_MUTEXES : 
2
str :  * rt_mutex_setprio - set the current priority of a task[56]
strstr : INIT :  * rt_mutex_setprio - set the current priority of a task : 
2
strstr : if :  * rt_mutex_setprio - set the current priority of a task : 
2
strstr : for :  * rt_mutex_setprio - set the current priority of a task : 
2
strstr : while :  * rt_mutex_setprio - set the current priority of a task : 
2
str :  * @p: task[11]
strstr : INIT :  * @p: task : 
2
strstr : if :  * @p: task : 
2
strstr : for :  * @p: task : 
2
strstr : while :  * @p: task : 
2
str :  * @prio: prio value (kernel-internal form)[43]
strstr : INIT :  * @prio: prio value (kernel-internal form) : 
2
strstr : if :  * @prio: prio value (kernel-internal form) : 
2
strstr : for :  * @prio: prio value (kernel-internal form) : 
2
strstr : while :  * @prio: prio value (kernel-internal form) : 
2
str :  * This function changes the 'effective' priority of a task. It does[68]
strstr : INIT :  * This function changes the 'effective' priority of a task. It does : 
2
strstr : if :  * This function changes the 'effective' priority of a task. It does : 
2
strstr : for :  * This function changes the 'effective' priority of a task. It does : 
2
strstr : while :  * This function changes the 'effective' priority of a task. It does : 
2
str :  * not touch ->normal_prio like __setscheduler().[49]
strstr : INIT :  * not touch ->normal_prio like __setscheduler(). : 
2
strstr : if :  * not touch ->normal_prio like __setscheduler(). : 
2
strstr : for :  * not touch ->normal_prio like __setscheduler(). : 
2
strstr : while :  * not touch ->normal_prio like __setscheduler(). : 
2
str :  * Used by the rt_mutex code to implement priority inheritance logic.[69]
strstr : INIT :  * Used by the rt_mutex code to implement priority inheritance logic. : 
2
strstr : if :  * Used by the rt_mutex code to implement priority inheritance logic. : 
2
strstr : for :  * Used by the rt_mutex code to implement priority inheritance logic. : 
2
strstr : while :  * Used by the rt_mutex code to implement priority inheritance logic. : 
2
str :  */[3]
strstr : INIT :  */ : 
2
strstr : if :  */ : 
2
strstr : for :  */ : 
2
strstr : while :  */ : 
2
str : void rt_mutex_setprio(struct task_struct *p, int prio)[54]
strstr : INIT : void rt_mutex_setprio(struct task_struct *p, int prio) : 
2
strstr : if : void rt_mutex_setprio(struct task_struct *p, int prio) : 
2
strstr : for : void rt_mutex_setprio(struct task_struct *p, int prio) : 
2
strstr : while : void rt_mutex_setprio(struct task_struct *p, int prio) : 
2
str : 	int oldprio, on_rq, running, enqueue_flag = 0;[47]
strstr : INIT : 	int oldprio, on_rq, running, enqueue_flag = 0; : 
2
strstr : if : 	int oldprio, on_rq, running, enqueue_flag = 0; : 
2
strstr : for : 	int oldprio, on_rq, running, enqueue_flag = 0; : 
2
strstr : while : 	int oldprio, on_rq, running, enqueue_flag = 0; : 
2
str : 	struct rq *rq;[15]
strstr : INIT : 	struct rq *rq; : 
2
strstr : if : 	struct rq *rq; : 
2
strstr : for : 	struct rq *rq; : 
2
strstr : while : 	struct rq *rq; : 
2
str : 	const struct sched_class *prev_class;[38]
strstr : INIT : 	const struct sched_class *prev_class; : 
2
strstr : if : 	const struct sched_class *prev_class; : 
2
strstr : for : 	const struct sched_class *prev_class; : 
2
strstr : while : 	const struct sched_class *prev_class; : 
2
str : 	BUG_ON(prio > MAX_PRIO);[25]
strstr : INIT : 	BUG_ON(prio > MAX_PRIO); : 
2
strstr : if : 	BUG_ON(prio > MAX_PRIO); : 
2
strstr : for : 	BUG_ON(prio > MAX_PRIO); : 
2
strstr : while : 	BUG_ON(prio > MAX_PRIO); : 
2
str : 	rq = __task_rq_lock(p);[24]
strstr : INIT : 	rq = __task_rq_lock(p); : 
2
strstr : if : 	rq = __task_rq_lock(p); : 
2
strstr : for : 	rq = __task_rq_lock(p); : 
2
strstr : while : 	rq = __task_rq_lock(p); : 
2
str : 	/*[3]
strstr : INIT : 	/* : 
2
strstr : if : 	/* : 
2
strstr : for : 	/* : 
2
strstr : while : 	/* : 
2
str : 	 * Idle task boosting is a nono in general. There is one[57]
strstr : INIT : 	 * Idle task boosting is a nono in general. There is one : 
2
strstr : if : 	 * Idle task boosting is a nono in general. There is one : 
2
strstr : for : 	 * Idle task boosting is a nono in general. There is one : 
2
strstr : while : 	 * Idle task boosting is a nono in general. There is one : 
2
str : 	 * exception, when PREEMPT_RT and NOHZ is active:[50]
strstr : INIT : 	 * exception, when PREEMPT_RT and NOHZ is active: : 
2
strstr : if : 	 * exception, when PREEMPT_RT and NOHZ is active: : 
2
strstr : for : 	 * exception, when PREEMPT_RT and NOHZ is active: : 
2
strstr : while : 	 * exception, when PREEMPT_RT and NOHZ is active: : 
2
str : 	 *[3]
strstr : INIT : 	 * : 
2
strstr : if : 	 * : 
2
strstr : for : 	 * : 
2
strstr : while : 	 * : 
2
str : 	 * The idle task calls get_next_timer_interrupt() and holds[60]
strstr : INIT : 	 * The idle task calls get_next_timer_interrupt() and holds : 
2
strstr : if : 	 * The idle task calls get_next_timer_interrupt() and holds : 
2
strstr : for : 	 * The idle task calls get_next_timer_interrupt() and holds : 
2
strstr : while : 	 * The idle task calls get_next_timer_interrupt() and holds : 
2
str : 	 * the timer wheel base->lock on the CPU and another CPU wants[63]
strstr : INIT : 	 * the timer wheel base->lock on the CPU and another CPU wants : 
2
strstr : if : 	 * the timer wheel base->lock on the CPU and another CPU wants : 
2
strstr : for : 	 * the timer wheel base->lock on the CPU and another CPU wants : 
2
strstr : while : 	 * the timer wheel base->lock on the CPU and another CPU wants : 
2
str : 	 * to access the timer (probably to cancel it). We can safely[62]
strstr : INIT : 	 * to access the timer (probably to cancel it). We can safely : 
2
strstr : if : 	 * to access the timer (probably to cancel it). We can safely : 
2
strstr : for : 	 * to access the timer (probably to cancel it). We can safely : 
2
strstr : while : 	 * to access the timer (probably to cancel it). We can safely : 
2
str : 	 * ignore the boosting request, as the idle CPU runs this code[63]
strstr : INIT : 	 * ignore the boosting request, as the idle CPU runs this code : 
2
strstr : if : 	 * ignore the boosting request, as the idle CPU runs this code : 
2
strstr : for : 	 * ignore the boosting request, as the idle CPU runs this code : 
2
strstr : while : 	 * ignore the boosting request, as the idle CPU runs this code : 
2
str : 	 * with interrupts disabled and will complete the lock[55]
strstr : INIT : 	 * with interrupts disabled and will complete the lock : 
2
strstr : if : 	 * with interrupts disabled and will complete the lock : 
2
strstr : for : 	 * with interrupts disabled and will complete the lock : 
2
strstr : while : 	 * with interrupts disabled and will complete the lock : 
2
str : 	 * protected section without being interrupted. So there is no[63]
strstr : INIT : 	 * protected section without being interrupted. So there is no : 
2
strstr : if : 	 * protected section without being interrupted. So there is no : 
2
strstr : for : 	 * protected section without being interrupted. So there is no : 
2
strstr : while : 	 * protected section without being interrupted. So there is no : 
2
str : 	 * real need to boost.[23]
strstr : INIT : 	 * real need to boost. : 
2
strstr : if : 	 * real need to boost. : 
2
strstr : for : 	 * real need to boost. : 
2
strstr : while : 	 * real need to boost. : 
2
str : 	 */[4]
strstr : INIT : 	 */ : 
2
strstr : if : 	 */ : 
2
strstr : for : 	 */ : 
2
strstr : while : 	 */ : 
2
str : 	if (unlikely(p == rq->idle)) {[31]
strstr : INIT : 	if (unlikely(p == rq->idle)) { : 
2
strstr : if : 	if (unlikely(p == rq->idle)) { : 
2
strstr : for : 	if (unlikely(p == rq->idle)) { : 
2
strstr : while : 	if (unlikely(p == rq->idle)) { : 
2
str : 		WARN_ON(p != rq->curr);[25]
strstr : INIT : 		WARN_ON(p != rq->curr); : 
2
strstr : if : 		WARN_ON(p != rq->curr); : 
2
strstr : for : 		WARN_ON(p != rq->curr); : 
2
strstr : while : 		WARN_ON(p != rq->curr); : 
2
str : 		WARN_ON(p->pi_blocked_on);[28]
strstr : INIT : 		WARN_ON(p->pi_blocked_on); : 
2
strstr : if : 		WARN_ON(p->pi_blocked_on); : 
2
strstr : for : 		WARN_ON(p->pi_blocked_on); : 
2
strstr : while : 		WARN_ON(p->pi_blocked_on); : 
2
str : 		goto out_unlock;[18]
strstr : INIT : 		goto out_unlock; : 
2
strstr : if : 		goto out_unlock; : 
2
strstr : for : 		goto out_unlock; : 
2
strstr : while : 		goto out_unlock; : 
2
str : 	trace_sched_pi_setprio(p, prio);[33]
strstr : INIT : 	trace_sched_pi_setprio(p, prio); : 
2
strstr : if : 	trace_sched_pi_setprio(p, prio); : 
2
strstr : for : 	trace_sched_pi_setprio(p, prio); : 
2
strstr : while : 	trace_sched_pi_setprio(p, prio); : 
2
str : 	p->pi_top_task = rt_mutex_get_top_task(p);[43]
strstr : INIT : 	p->pi_top_task = rt_mutex_get_top_task(p); : 
2
strstr : if : 	p->pi_top_task = rt_mutex_get_top_task(p); : 
2
strstr : for : 	p->pi_top_task = rt_mutex_get_top_task(p); : 
2
strstr : while : 	p->pi_top_task = rt_mutex_get_top_task(p); : 
2
str : 	oldprio = p->prio;[19]
strstr : INIT : 	oldprio = p->prio; : 
2
strstr : if : 	oldprio = p->prio; : 
2
strstr : for : 	oldprio = p->prio; : 
2
strstr : while : 	oldprio = p->prio; : 
2
str : 	prev_class = p->sched_class;[29]
strstr : INIT : 	prev_class = p->sched_class; : 
2
strstr : if : 	prev_class = p->sched_class; : 
2
strstr : for : 	prev_class = p->sched_class; : 
2
strstr : while : 	prev_class = p->sched_class; : 
2
str : 	on_rq = p->on_rq;[18]
strstr : INIT : 	on_rq = p->on_rq; : 
2
strstr : if : 	on_rq = p->on_rq; : 
2
strstr : for : 	on_rq = p->on_rq; : 
2
strstr : while : 	on_rq = p->on_rq; : 
2
str : 	running = task_current(rq, p);[31]
strstr : INIT : 	running = task_current(rq, p); : 
2
strstr : if : 	running = task_current(rq, p); : 
2
strstr : for : 	running = task_current(rq, p); : 
2
strstr : while : 	running = task_current(rq, p); : 
2
str : 	if (on_rq)[11]
strstr : INIT : 	if (on_rq) : 
2
strstr : if : 	if (on_rq) : 
2
strstr : for : 	if (on_rq) : 
2
strstr : while : 	if (on_rq) : 
2
str : 		dequeue_task(rq, p, 0);[25]
strstr : INIT : 		dequeue_task(rq, p, 0); : 
2
strstr : if : 		dequeue_task(rq, p, 0); : 
2
strstr : for : 		dequeue_task(rq, p, 0); : 
2
strstr : while : 		dequeue_task(rq, p, 0); : 
2
str : 	if (running)[13]
strstr : INIT : 	if (running) : 
2
strstr : if : 	if (running) : 
2
strstr : for : 	if (running) : 
2
strstr : while : 	if (running) : 
2
str : 		p->sched_class->put_prev_task(rq, p);[39]
strstr : INIT : 		p->sched_class->put_prev_task(rq, p); : 
2
strstr : if : 		p->sched_class->put_prev_task(rq, p); : 
2
strstr : for : 		p->sched_class->put_prev_task(rq, p); : 
2
strstr : while : 		p->sched_class->put_prev_task(rq, p); : 
2
str : 	/*[3]
strstr : INIT : 	/* : 
2
strstr : if : 	/* : 
2
strstr : for : 	/* : 
2
strstr : while : 	/* : 
2
str : 	 * Boosting condition are:[27]
strstr : INIT : 	 * Boosting condition are: : 
2
strstr : if : 	 * Boosting condition are: : 
2
strstr : for : 	 * Boosting condition are: : 
2
strstr : while : 	 * Boosting condition are: : 
2
str : 	 * 1. -rt task is running and holds mutex A[44]
strstr : INIT : 	 * 1. -rt task is running and holds mutex A : 
2
strstr : if : 	 * 1. -rt task is running and holds mutex A : 
2
strstr : for : 	 * 1. -rt task is running and holds mutex A : 
2
strstr : while : 	 * 1. -rt task is running and holds mutex A : 
2
str : 	 *      --> -dl task blocks on mutex A[39]
strstr : INIT : 	 *      --> -dl task blocks on mutex A : 
2
strstr : if : 	 *      --> -dl task blocks on mutex A : 
2
strstr : for : 	 *      --> -dl task blocks on mutex A : 
2
strstr : while : 	 *      --> -dl task blocks on mutex A : 
2
str : 	 *[3]
strstr : INIT : 	 * : 
2
strstr : if : 	 * : 
2
strstr : for : 	 * : 
2
strstr : while : 	 * : 
2
str : 	 * 2. -dl task is running and holds mutex A[44]
strstr : INIT : 	 * 2. -dl task is running and holds mutex A : 
2
strstr : if : 	 * 2. -dl task is running and holds mutex A : 
2
strstr : for : 	 * 2. -dl task is running and holds mutex A : 
2
strstr : while : 	 * 2. -dl task is running and holds mutex A : 
2
str : 	 *      --> -dl task blocks on mutex A and could preempt the[61]
strstr : INIT : 	 *      --> -dl task blocks on mutex A and could preempt the : 
2
strstr : if : 	 *      --> -dl task blocks on mutex A and could preempt the : 
2
strstr : for : 	 *      --> -dl task blocks on mutex A and could preempt the : 
2
strstr : while : 	 *      --> -dl task blocks on mutex A and could preempt the : 
2
str : 	 *          running task[25]
strstr : INIT : 	 *          running task : 
2
strstr : if : 	 *          running task : 
2
strstr : for : 	 *          running task : 
2
strstr : while : 	 *          running task : 
2
str : 	 */[4]
strstr : INIT : 	 */ : 
2
strstr : if : 	 */ : 
2
strstr : for : 	 */ : 
2
strstr : while : 	 */ : 
2
str : 	if (dl_prio(prio)) {[21]
strstr : INIT : 	if (dl_prio(prio)) { : 
2
strstr : if : 	if (dl_prio(prio)) { : 
2
strstr : for : 	if (dl_prio(prio)) { : 
2
strstr : while : 	if (dl_prio(prio)) { : 
2
str : 		if (!dl_prio(p->normal_prio) || (p->pi_top_task &&[52]
strstr : INIT : 		if (!dl_prio(p->normal_prio) || (p->pi_top_task && : 
2
strstr : if : 		if (!dl_prio(p->normal_prio) || (p->pi_top_task && : 
2
strstr : for : 		if (!dl_prio(p->normal_prio) || (p->pi_top_task && : 
2
strstr : while : 		if (!dl_prio(p->normal_prio) || (p->pi_top_task && : 
2
str : 			dl_entity_preempt(&p->pi_top_task->dl, &p->dl))) {[53]
strstr : INIT : 			dl_entity_preempt(&p->pi_top_task->dl, &p->dl))) { : 
2
strstr : if : 			dl_entity_preempt(&p->pi_top_task->dl, &p->dl))) { : 
2
strstr : for : 			dl_entity_preempt(&p->pi_top_task->dl, &p->dl))) { : 
2
strstr : while : 			dl_entity_preempt(&p->pi_top_task->dl, &p->dl))) { : 
2
str : 			p->dl.dl_boosted = 1;[24]
strstr : INIT : 			p->dl.dl_boosted = 1; : 
2
strstr : if : 			p->dl.dl_boosted = 1; : 
2
strstr : for : 			p->dl.dl_boosted = 1; : 
2
strstr : while : 			p->dl.dl_boosted = 1; : 
2
str : 			p->dl.dl_throttled = 0;[26]
strstr : INIT : 			p->dl.dl_throttled = 0; : 
2
strstr : if : 			p->dl.dl_throttled = 0; : 
2
strstr : for : 			p->dl.dl_throttled = 0; : 
2
strstr : while : 			p->dl.dl_throttled = 0; : 
2
str : 			enqueue_flag = ENQUEUE_REPLENISH;[36]
strstr : INIT : 			enqueue_flag = ENQUEUE_REPLENISH; : 
2
strstr : if : 			enqueue_flag = ENQUEUE_REPLENISH; : 
2
strstr : for : 			enqueue_flag = ENQUEUE_REPLENISH; : 
2
strstr : while : 			enqueue_flag = ENQUEUE_REPLENISH; : 
2
str : 		} else[8]
strstr : INIT : 		} else : 
2
strstr : if : 		} else : 
2
strstr : for : 		} else : 
2
strstr : while : 		} else : 
2
str : 			p->dl.dl_boosted = 0;[24]
strstr : INIT : 			p->dl.dl_boosted = 0; : 
2
strstr : if : 			p->dl.dl_boosted = 0; : 
2
strstr : for : 			p->dl.dl_boosted = 0; : 
2
strstr : while : 			p->dl.dl_boosted = 0; : 
2
str : 		p->sched_class = &dl_sched_class;[35]
strstr : INIT : 		p->sched_class = &dl_sched_class; : 
2
strstr : if : 		p->sched_class = &dl_sched_class; : 
2
strstr : for : 		p->sched_class = &dl_sched_class; : 
2
strstr : while : 		p->sched_class = &dl_sched_class; : 
2
str : 	} else if (rt_prio(prio)) {[28]
strstr : INIT : 	} else if (rt_prio(prio)) { : 
2
strstr : if : 	} else if (rt_prio(prio)) { : 
2
strstr : for : 	} else if (rt_prio(prio)) { : 
2
strstr : while : 	} else if (rt_prio(prio)) { : 
2
str : 		if (dl_prio(oldprio))[23]
strstr : INIT : 		if (dl_prio(oldprio)) : 
2
strstr : if : 		if (dl_prio(oldprio)) : 
2
strstr : for : 		if (dl_prio(oldprio)) : 
2
strstr : while : 		if (dl_prio(oldprio)) : 
2
str : 			p->dl.dl_boosted = 0;[24]
strstr : INIT : 			p->dl.dl_boosted = 0; : 
2
strstr : if : 			p->dl.dl_boosted = 0; : 
2
strstr : for : 			p->dl.dl_boosted = 0; : 
2
strstr : while : 			p->dl.dl_boosted = 0; : 
2
str : 		if (oldprio < prio)[21]
strstr : INIT : 		if (oldprio < prio) : 
2
strstr : if : 		if (oldprio < prio) : 
2
strstr : for : 		if (oldprio < prio) : 
2
strstr : while : 		if (oldprio < prio) : 
2
str : 			enqueue_flag = ENQUEUE_HEAD;[31]
strstr : INIT : 			enqueue_flag = ENQUEUE_HEAD; : 
2
strstr : if : 			enqueue_flag = ENQUEUE_HEAD; : 
2
strstr : for : 			enqueue_flag = ENQUEUE_HEAD; : 
2
strstr : while : 			enqueue_flag = ENQUEUE_HEAD; : 
2
str : 		p->sched_class = &rt_sched_class;[35]
strstr : INIT : 		p->sched_class = &rt_sched_class; : 
2
strstr : if : 		p->sched_class = &rt_sched_class; : 
2
strstr : for : 		p->sched_class = &rt_sched_class; : 
2
strstr : while : 		p->sched_class = &rt_sched_class; : 
2
str : 	} else {[9]
strstr : INIT : 	} else { : 
2
strstr : if : 	} else { : 
2
strstr : for : 	} else { : 
2
strstr : while : 	} else { : 
2
str : 		if (dl_prio(oldprio))[23]
strstr : INIT : 		if (dl_prio(oldprio)) : 
2
strstr : if : 		if (dl_prio(oldprio)) : 
2
strstr : for : 		if (dl_prio(oldprio)) : 
2
strstr : while : 		if (dl_prio(oldprio)) : 
2
str : 			p->dl.dl_boosted = 0;[24]
strstr : INIT : 			p->dl.dl_boosted = 0; : 
2
strstr : if : 			p->dl.dl_boosted = 0; : 
2
strstr : for : 			p->dl.dl_boosted = 0; : 
2
strstr : while : 			p->dl.dl_boosted = 0; : 
2
str : 		p->sched_class = &fair_sched_class;[37]
strstr : INIT : 		p->sched_class = &fair_sched_class; : 
2
strstr : if : 		p->sched_class = &fair_sched_class; : 
2
strstr : for : 		p->sched_class = &fair_sched_class; : 
2
strstr : while : 		p->sched_class = &fair_sched_class; : 
2
str : 	p->prio = prio;[16]
strstr : INIT : 	p->prio = prio; : 
2
strstr : if : 	p->prio = prio; : 
2
strstr : for : 	p->prio = prio; : 
2
strstr : while : 	p->prio = prio; : 
2
str : 	if (running)[13]
strstr : INIT : 	if (running) : 
2
strstr : if : 	if (running) : 
2
strstr : for : 	if (running) : 
2
strstr : while : 	if (running) : 
2
str : 		p->sched_class->set_curr_task(rq);[36]
strstr : INIT : 		p->sched_class->set_curr_task(rq); : 
2
strstr : if : 		p->sched_class->set_curr_task(rq); : 
2
strstr : for : 		p->sched_class->set_curr_task(rq); : 
2
strstr : while : 		p->sched_class->set_curr_task(rq); : 
2
str : 	if (on_rq)[11]
strstr : INIT : 	if (on_rq) : 
2
strstr : if : 	if (on_rq) : 
2
strstr : for : 	if (on_rq) : 
2
strstr : while : 	if (on_rq) : 
2
str : 		enqueue_task(rq, p, enqueue_flag);[36]
strstr : INIT : 		enqueue_task(rq, p, enqueue_flag); : 
2
strstr : if : 		enqueue_task(rq, p, enqueue_flag); : 
2
strstr : for : 		enqueue_task(rq, p, enqueue_flag); : 
2
strstr : while : 		enqueue_task(rq, p, enqueue_flag); : 
2
str : 	check_class_changed(rq, p, prev_class, oldprio);[49]
strstr : INIT : 	check_class_changed(rq, p, prev_class, oldprio); : 
2
strstr : if : 	check_class_changed(rq, p, prev_class, oldprio); : 
2
strstr : for : 	check_class_changed(rq, p, prev_class, oldprio); : 
2
strstr : while : 	check_class_changed(rq, p, prev_class, oldprio); : 
2
str : out_unlock:[11]
strstr : INIT : out_unlock: : 
2
strstr : if : out_unlock: : 
2
strstr : for : out_unlock: : 
2
strstr : while : out_unlock: : 
2
str : 	__task_rq_unlock(rq);[22]
strstr : INIT : 	__task_rq_unlock(rq); : 
2
strstr : if : 	__task_rq_unlock(rq); : 
2
strstr : for : 	__task_rq_unlock(rq); : 
2
strstr : while : 	__task_rq_unlock(rq); : 
2
str : #endif[6]
strstr : INIT : #endif : 
2
strstr : if : #endif : 
2
strstr : for : #endif : 
2
strstr : while : #endif : 
2
str : void set_user_nice(struct task_struct *p, long nice)[52]
strstr : INIT : void set_user_nice(struct task_struct *p, long nice) : 
2
strstr : if : void set_user_nice(struct task_struct *p, long nice) : 
2
strstr : for : void set_user_nice(struct task_struct *p, long nice) : 
2
strstr : while : void set_user_nice(struct task_struct *p, long nice) : 
2
str : 	int old_prio, delta, on_rq;[28]
strstr : INIT : 	int old_prio, delta, on_rq; : 
2
strstr : if : 	int old_prio, delta, on_rq; : 
2
strstr : for : 	int old_prio, delta, on_rq; : 
2
strstr : while : 	int old_prio, delta, on_rq; : 
2
str : 	unsigned long flags;[21]
strstr : INIT : 	unsigned long flags; : 
2
strstr : if : 	unsigned long flags; : 
2
strstr : for : 	unsigned long flags; : 
2
strstr : while : 	unsigned long flags; : 
2
str : 	struct rq *rq;[15]
strstr : INIT : 	struct rq *rq; : 
2
strstr : if : 	struct rq *rq; : 
2
strstr : for : 	struct rq *rq; : 
2
strstr : while : 	struct rq *rq; : 
2
str : 	if (TASK_NICE(p) == nice || nice < -20 || nice > 19)[53]
strstr : INIT : 	if (TASK_NICE(p) == nice || nice < -20 || nice > 19) : 
2
strstr : if : 	if (TASK_NICE(p) == nice || nice < -20 || nice > 19) : 
2
strstr : for : 	if (TASK_NICE(p) == nice || nice < -20 || nice > 19) : 
2
strstr : while : 	if (TASK_NICE(p) == nice || nice < -20 || nice > 19) : 
2
str : 		return;[9]
strstr : INIT : 		return; : 
2
strstr : if : 		return; : 
2
strstr : for : 		return; : 
2
strstr : while : 		return; : 
2
str : 	/*[3]
strstr : INIT : 	/* : 
2
strstr : if : 	/* : 
2
strstr : for : 	/* : 
2
strstr : while : 	/* : 
2
str : 	 * We have to be careful, if called from sys_setpriority(),[60]
strstr : INIT : 	 * We have to be careful, if called from sys_setpriority(), : 
2
strstr : if : 	 * We have to be careful, if called from sys_setpriority(), : 
2
strstr : for : 	 * We have to be careful, if called from sys_setpriority(), : 
2
strstr : while : 	 * We have to be careful, if called from sys_setpriority(), : 
2
str : 	 * the task might be in the middle of scheduling on another CPU.[65]
strstr : INIT : 	 * the task might be in the middle of scheduling on another CPU. : 
2
strstr : if : 	 * the task might be in the middle of scheduling on another CPU. : 
2
strstr : for : 	 * the task might be in the middle of scheduling on another CPU. : 
2
strstr : while : 	 * the task might be in the middle of scheduling on another CPU. : 
2
str : 	 */[4]
strstr : INIT : 	 */ : 
2
strstr : if : 	 */ : 
2
strstr : for : 	 */ : 
2
strstr : while : 	 */ : 
2
str : 	rq = task_rq_lock(p, &flags);[30]
strstr : INIT : 	rq = task_rq_lock(p, &flags); : 
2
strstr : if : 	rq = task_rq_lock(p, &flags); : 
2
strstr : for : 	rq = task_rq_lock(p, &flags); : 
2
strstr : while : 	rq = task_rq_lock(p, &flags); : 
2
str : 	/*[3]
strstr : INIT : 	/* : 
2
strstr : if : 	/* : 
2
strstr : for : 	/* : 
2
strstr : while : 	/* : 
2
str : 	 * The RT priorities are set via sched_setscheduler(), but we still[68]
strstr : INIT : 	 * The RT priorities are set via sched_setscheduler(), but we still : 
2
strstr : if : 	 * The RT priorities are set via sched_setscheduler(), but we still : 
2
strstr : for : 	 * The RT priorities are set via sched_setscheduler(), but we still : 
2
strstr : while : 	 * The RT priorities are set via sched_setscheduler(), but we still : 
2
str : 	 * allow the 'normal' nice value to be set - but as expected[61]
strstr : INIT : 	 * allow the 'normal' nice value to be set - but as expected : 
2
strstr : if : 	 * allow the 'normal' nice value to be set - but as expected : 
2
strstr : for : 	 * allow the 'normal' nice value to be set - but as expected : 
2
strstr : while : 	 * allow the 'normal' nice value to be set - but as expected : 
2
str : 	 * it wont have any effect on scheduling until the task is[59]
strstr : INIT : 	 * it wont have any effect on scheduling until the task is : 
2
strstr : if : 	 * it wont have any effect on scheduling until the task is : 
2
strstr : for : 	 * it wont have any effect on scheduling until the task is : 
2
strstr : while : 	 * it wont have any effect on scheduling until the task is : 
2
str : 	 * SCHED_DEADLINE, SCHED_FIFO or SCHED_RR:[43]
strstr : INIT : 	 * SCHED_DEADLINE, SCHED_FIFO or SCHED_RR: : 
2
strstr : if : 	 * SCHED_DEADLINE, SCHED_FIFO or SCHED_RR: : 
2
strstr : for : 	 * SCHED_DEADLINE, SCHED_FIFO or SCHED_RR: : 
2
strstr : while : 	 * SCHED_DEADLINE, SCHED_FIFO or SCHED_RR: : 
2
str : 	 */[4]
strstr : INIT : 	 */ : 
2
strstr : if : 	 */ : 
2
strstr : for : 	 */ : 
2
strstr : while : 	 */ : 
2
str : 	if (task_has_dl_policy(p) || task_has_rt_policy(p)) {[54]
strstr : INIT : 	if (task_has_dl_policy(p) || task_has_rt_policy(p)) { : 
2
strstr : if : 	if (task_has_dl_policy(p) || task_has_rt_policy(p)) { : 
2
strstr : for : 	if (task_has_dl_policy(p) || task_has_rt_policy(p)) { : 
2
strstr : while : 	if (task_has_dl_policy(p) || task_has_rt_policy(p)) { : 
2
str : 		p->static_prio = NICE_TO_PRIO(nice);[38]
strstr : INIT : 		p->static_prio = NICE_TO_PRIO(nice); : 
2
strstr : if : 		p->static_prio = NICE_TO_PRIO(nice); : 
2
strstr : for : 		p->static_prio = NICE_TO_PRIO(nice); : 
2
strstr : while : 		p->static_prio = NICE_TO_PRIO(nice); : 
2
str : 		goto out_unlock;[18]
strstr : INIT : 		goto out_unlock; : 
2
strstr : if : 		goto out_unlock; : 
2
strstr : for : 		goto out_unlock; : 
2
strstr : while : 		goto out_unlock; : 
2
str : 	on_rq = p->on_rq;[18]
strstr : INIT : 	on_rq = p->on_rq; : 
2
strstr : if : 	on_rq = p->on_rq; : 
2
strstr : for : 	on_rq = p->on_rq; : 
2
strstr : while : 	on_rq = p->on_rq; : 
2
str : 	if (on_rq)[11]
strstr : INIT : 	if (on_rq) : 
2
strstr : if : 	if (on_rq) : 
2
strstr : for : 	if (on_rq) : 
2
strstr : while : 	if (on_rq) : 
2
str : 		dequeue_task(rq, p, 0);[25]
strstr : INIT : 		dequeue_task(rq, p, 0); : 
2
strstr : if : 		dequeue_task(rq, p, 0); : 
2
strstr : for : 		dequeue_task(rq, p, 0); : 
2
strstr : while : 		dequeue_task(rq, p, 0); : 
2
str : 	p->static_prio = NICE_TO_PRIO(nice);[37]
strstr : INIT : 	p->static_prio = NICE_TO_PRIO(nice); : 
2
strstr : if : 	p->static_prio = NICE_TO_PRIO(nice); : 
2
strstr : for : 	p->static_prio = NICE_TO_PRIO(nice); : 
2
strstr : while : 	p->static_prio = NICE_TO_PRIO(nice); : 
2
str : 	set_load_weight(p);[20]
strstr : INIT : 	set_load_weight(p); : 
2
strstr : if : 	set_load_weight(p); : 
2
strstr : for : 	set_load_weight(p); : 
2
strstr : while : 	set_load_weight(p); : 
2
str : 	old_prio = p->prio;[20]
strstr : INIT : 	old_prio = p->prio; : 
2
strstr : if : 	old_prio = p->prio; : 
2
strstr : for : 	old_prio = p->prio; : 
2
strstr : while : 	old_prio = p->prio; : 
2
str : 	p->prio = effective_prio(p);[29]
strstr : INIT : 	p->prio = effective_prio(p); : 
2
strstr : if : 	p->prio = effective_prio(p); : 
2
strstr : for : 	p->prio = effective_prio(p); : 
2
strstr : while : 	p->prio = effective_prio(p); : 
2
str : 	delta = p->prio - old_prio;[28]
strstr : INIT : 	delta = p->prio - old_prio; : 
2
strstr : if : 	delta = p->prio - old_prio; : 
2
strstr : for : 	delta = p->prio - old_prio; : 
2
strstr : while : 	delta = p->prio - old_prio; : 
2
str : 	if (on_rq) {[13]
strstr : INIT : 	if (on_rq) { : 
2
strstr : if : 	if (on_rq) { : 
2
strstr : for : 	if (on_rq) { : 
2
strstr : while : 	if (on_rq) { : 
2
str : 		enqueue_task(rq, p, 0);[25]
strstr : INIT : 		enqueue_task(rq, p, 0); : 
2
strstr : if : 		enqueue_task(rq, p, 0); : 
2
strstr : for : 		enqueue_task(rq, p, 0); : 
2
strstr : while : 		enqueue_task(rq, p, 0); : 
2
str : 		/*[4]
strstr : INIT : 		/* : 
2
strstr : if : 		/* : 
2
strstr : for : 		/* : 
2
strstr : while : 		/* : 
2
str : 		 * If the task increased its priority or is running and[57]
strstr : INIT : 		 * If the task increased its priority or is running and : 
2
strstr : if : 		 * If the task increased its priority or is running and : 
2
strstr : for : 		 * If the task increased its priority or is running and : 
2
strstr : while : 		 * If the task increased its priority or is running and : 
2
str : 		 * lowered its priority, then reschedule its CPU:[51]
strstr : INIT : 		 * lowered its priority, then reschedule its CPU: : 
2
strstr : if : 		 * lowered its priority, then reschedule its CPU: : 
2
strstr : for : 		 * lowered its priority, then reschedule its CPU: : 
2
strstr : while : 		 * lowered its priority, then reschedule its CPU: : 
2
str : 		 */[5]
strstr : INIT : 		 */ : 
2
strstr : if : 		 */ : 
2
strstr : for : 		 */ : 
2
strstr : while : 		 */ : 
2
str : 		if (delta < 0 || (delta > 0 && task_running(rq, p)))[54]
strstr : INIT : 		if (delta < 0 || (delta > 0 && task_running(rq, p))) : 
2
strstr : if : 		if (delta < 0 || (delta > 0 && task_running(rq, p))) : 
2
strstr : for : 		if (delta < 0 || (delta > 0 && task_running(rq, p))) : 
2
strstr : while : 		if (delta < 0 || (delta > 0 && task_running(rq, p))) : 
2
str : 			resched_task(rq->curr);[26]
strstr : INIT : 			resched_task(rq->curr); : 
2
strstr : if : 			resched_task(rq->curr); : 
2
strstr : for : 			resched_task(rq->curr); : 
2
strstr : while : 			resched_task(rq->curr); : 
2
str : out_unlock:[11]
strstr : INIT : out_unlock: : 
2
strstr : if : out_unlock: : 
2
strstr : for : out_unlock: : 
2
strstr : while : out_unlock: : 
2
str : 	task_rq_unlock(rq, p, &flags);[31]
strstr : INIT : 	task_rq_unlock(rq, p, &flags); : 
2
strstr : if : 	task_rq_unlock(rq, p, &flags); : 
2
strstr : for : 	task_rq_unlock(rq, p, &flags); : 
2
strstr : while : 	task_rq_unlock(rq, p, &flags); : 
2
str : EXPORT_SYMBOL(set_user_nice);[29]
strstr : INIT : EXPORT_SYMBOL(set_user_nice); : 
2
strstr : if : EXPORT_SYMBOL(set_user_nice); : 
2
strstr : for : EXPORT_SYMBOL(set_user_nice); : 
2
strstr : while : EXPORT_SYMBOL(set_user_nice); : 
2
str :  * can_nice - check if a task can reduce its nice value[55]
strstr : INIT :  * can_nice - check if a task can reduce its nice value : 
2
strstr : if :  * can_nice - check if a task can reduce its nice value : 
2
strstr : for :  * can_nice - check if a task can reduce its nice value : 
2
strstr : while :  * can_nice - check if a task can reduce its nice value : 
2
str :  * @p: task[11]
strstr : INIT :  * @p: task : 
2
strstr : if :  * @p: task : 
2
strstr : for :  * @p: task : 
2
strstr : while :  * @p: task : 
2
str :  * @nice: nice value[20]
strstr : INIT :  * @nice: nice value : 
2
strstr : if :  * @nice: nice value : 
2
strstr : for :  * @nice: nice value : 
2
strstr : while :  * @nice: nice value : 
2
str :  */[3]
strstr : INIT :  */ : 
2
strstr : if :  */ : 
2
strstr : for :  */ : 
2
strstr : while :  */ : 
2
str : int can_nice(const struct task_struct *p, const int nice)[57]
strstr : INIT : int can_nice(const struct task_struct *p, const int nice) : 
2
strstr : if : int can_nice(const struct task_struct *p, const int nice) : 
2
strstr : for : int can_nice(const struct task_struct *p, const int nice) : 
2
strstr : while : int can_nice(const struct task_struct *p, const int nice) : 
2
str : 	/* convert nice value [19,-20] to rlimit style value [1,40] */[63]
strstr : INIT : 	/* convert nice value [19,-20] to rlimit style value [1,40] */ : 
2
strstr : if : 	/* convert nice value [19,-20] to rlimit style value [1,40] */ : 
2
strstr : for : 	/* convert nice value [19,-20] to rlimit style value [1,40] */ : 
2
strstr : while : 	/* convert nice value [19,-20] to rlimit style value [1,40] */ : 
2
str : 	int nice_rlim = 20 - nice;[27]
strstr : INIT : 	int nice_rlim = 20 - nice; : 
2
strstr : if : 	int nice_rlim = 20 - nice; : 
2
strstr : for : 	int nice_rlim = 20 - nice; : 
2
strstr : while : 	int nice_rlim = 20 - nice; : 
2
str : 	return (nice_rlim <= task_rlimit(p, RLIMIT_NICE) ||[52]
strstr : INIT : 	return (nice_rlim <= task_rlimit(p, RLIMIT_NICE) || : 
2
strstr : if : 	return (nice_rlim <= task_rlimit(p, RLIMIT_NICE) || : 
2
strstr : for : 	return (nice_rlim <= task_rlimit(p, RLIMIT_NICE) || : 
2
strstr : while : 	return (nice_rlim <= task_rlimit(p, RLIMIT_NICE) || : 
2
str : 		capable(CAP_SYS_NICE));[25]
strstr : INIT : 		capable(CAP_SYS_NICE)); : 
2
strstr : if : 		capable(CAP_SYS_NICE)); : 
2
strstr : for : 		capable(CAP_SYS_NICE)); : 
2
strstr : while : 		capable(CAP_SYS_NICE)); : 
2
str : #ifdef __ARCH_WANT_SYS_NICE[27]
strstr : INIT : #ifdef __ARCH_WANT_SYS_NICE : 
2
strstr : if : #ifdef __ARCH_WANT_SYS_NICE : 
2
strstr : for : #ifdef __ARCH_WANT_SYS_NICE : 
2
strstr : while : #ifdef __ARCH_WANT_SYS_NICE : 
2
str :  * sys_nice - change the priority of the current process.[57]
strstr : INIT :  * sys_nice - change the priority of the current process. : 
2
strstr : if :  * sys_nice - change the priority of the current process. : 
2
strstr : for :  * sys_nice - change the priority of the current process. : 
2
strstr : while :  * sys_nice - change the priority of the current process. : 
2
str :  * @increment: priority increment[33]
strstr : INIT :  * @increment: priority increment : 
2
strstr : if :  * @increment: priority increment : 
2
strstr : for :  * @increment: priority increment : 
2
strstr : while :  * @increment: priority increment : 
2
str :  * sys_setpriority is a more generic, but much slower function that[67]
strstr : INIT :  * sys_setpriority is a more generic, but much slower function that : 
2
strstr : if :  * sys_setpriority is a more generic, but much slower function that : 
2
strstr : for :  * sys_setpriority is a more generic, but much slower function that : 
2
strstr : while :  * sys_setpriority is a more generic, but much slower function that : 
2
str :  * does similar things.[23]
strstr : INIT :  * does similar things. : 
2
strstr : if :  * does similar things. : 
2
strstr : for :  * does similar things. : 
2
strstr : while :  * does similar things. : 
2
str :  */[3]
strstr : INIT :  */ : 
2
strstr : if :  */ : 
2
strstr : for :  */ : 
2
strstr : while :  */ : 
2
str : SYSCALL_DEFINE1(nice, int, increment)[37]
strstr : INIT : SYSCALL_DEFINE1(nice, int, increment) : 
2
strstr : if : SYSCALL_DEFINE1(nice, int, increment) : 
2
strstr : for : SYSCALL_DEFINE1(nice, int, increment) : 
2
strstr : while : SYSCALL_DEFINE1(nice, int, increment) : 
2
str : 	long nice, retval;[19]
strstr : INIT : 	long nice, retval; : 
2
strstr : if : 	long nice, retval; : 
2
strstr : for : 	long nice, retval; : 
2
strstr : while : 	long nice, retval; : 
2
str : 	/*[3]
strstr : INIT : 	/* : 
2
strstr : if : 	/* : 
2
strstr : for : 	/* : 
2
strstr : while : 	/* : 
2
str : 	 * Setpriority might change our priority at the same moment.[61]
strstr : INIT : 	 * Setpriority might change our priority at the same moment. : 
2
strstr : if : 	 * Setpriority might change our priority at the same moment. : 
2
strstr : for : 	 * Setpriority might change our priority at the same moment. : 
2
strstr : while : 	 * Setpriority might change our priority at the same moment. : 
2
str : 	 * We don't have to worry. Conceptually one call occurs first[62]
strstr : INIT : 	 * We don't have to worry. Conceptually one call occurs first : 
2
strstr : if : 	 * We don't have to worry. Conceptually one call occurs first : 
2
strstr : for : 	 * We don't have to worry. Conceptually one call occurs first : 
2
strstr : while : 	 * We don't have to worry. Conceptually one call occurs first : 
2
str : 	 * and we have a single winner.[32]
strstr : INIT : 	 * and we have a single winner. : 
2
strstr : if : 	 * and we have a single winner. : 
2
strstr : for : 	 * and we have a single winner. : 
2
strstr : while : 	 * and we have a single winner. : 
2
str : 	 */[4]
strstr : INIT : 	 */ : 
2
strstr : if : 	 */ : 
2
strstr : for : 	 */ : 
2
strstr : while : 	 */ : 
2
str : 	if (increment < -40)[21]
strstr : INIT : 	if (increment < -40) : 
2
strstr : if : 	if (increment < -40) : 
2
strstr : for : 	if (increment < -40) : 
2
strstr : while : 	if (increment < -40) : 
2
str : 		increment = -40;[18]
strstr : INIT : 		increment = -40; : 
2
strstr : if : 		increment = -40; : 
2
strstr : for : 		increment = -40; : 
2
strstr : while : 		increment = -40; : 
2
str : 	if (increment > 40)[20]
strstr : INIT : 	if (increment > 40) : 
2
strstr : if : 	if (increment > 40) : 
2
strstr : for : 	if (increment > 40) : 
2
strstr : while : 	if (increment > 40) : 
2
str : 		increment = 40;[17]
strstr : INIT : 		increment = 40; : 
2
strstr : if : 		increment = 40; : 
2
strstr : for : 		increment = 40; : 
2
strstr : while : 		increment = 40; : 
2
str : 	nice = TASK_NICE(current) + increment;[39]
strstr : INIT : 	nice = TASK_NICE(current) + increment; : 
2
strstr : if : 	nice = TASK_NICE(current) + increment; : 
2
strstr : for : 	nice = TASK_NICE(current) + increment; : 
2
strstr : while : 	nice = TASK_NICE(current) + increment; : 
2
str : 	if (nice < -20)[16]
strstr : INIT : 	if (nice < -20) : 
2
strstr : if : 	if (nice < -20) : 
2
strstr : for : 	if (nice < -20) : 
2
strstr : while : 	if (nice < -20) : 
2
str : 		nice = -20;[13]
strstr : INIT : 		nice = -20; : 
2
strstr : if : 		nice = -20; : 
2
strstr : for : 		nice = -20; : 
2
strstr : while : 		nice = -20; : 
2
str : 	if (nice > 19)[15]
strstr : INIT : 	if (nice > 19) : 
2
strstr : if : 	if (nice > 19) : 
2
strstr : for : 	if (nice > 19) : 
2
strstr : while : 	if (nice > 19) : 
2
str : 		nice = 19;[12]
strstr : INIT : 		nice = 19; : 
2
strstr : if : 		nice = 19; : 
2
strstr : for : 		nice = 19; : 
2
strstr : while : 		nice = 19; : 
2
str : 	if (increment < 0 && !can_nice(current, nice))[47]
strstr : INIT : 	if (increment < 0 && !can_nice(current, nice)) : 
2
strstr : if : 	if (increment < 0 && !can_nice(current, nice)) : 
2
strstr : for : 	if (increment < 0 && !can_nice(current, nice)) : 
2
strstr : while : 	if (increment < 0 && !can_nice(current, nice)) : 
2
str : 		return -EPERM;[16]
strstr : INIT : 		return -EPERM; : 
2
strstr : if : 		return -EPERM; : 
2
strstr : for : 		return -EPERM; : 
2
strstr : while : 		return -EPERM; : 
2
str : 	retval = security_task_setnice(current, nice);[47]
strstr : INIT : 	retval = security_task_setnice(current, nice); : 
2
strstr : if : 	retval = security_task_setnice(current, nice); : 
2
strstr : for : 	retval = security_task_setnice(current, nice); : 
2
strstr : while : 	retval = security_task_setnice(current, nice); : 
2
str : 	if (retval)[12]
strstr : INIT : 	if (retval) : 
2
strstr : if : 	if (retval) : 
2
strstr : for : 	if (retval) : 
2
strstr : while : 	if (retval) : 
2
str : 		return retval;[16]
strstr : INIT : 		return retval; : 
2
strstr : if : 		return retval; : 
2
strstr : for : 		return retval; : 
2
strstr : while : 		return retval; : 
2
str : 	set_user_nice(current, nice);[30]
strstr : INIT : 	set_user_nice(current, nice); : 
2
strstr : if : 	set_user_nice(current, nice); : 
2
strstr : for : 	set_user_nice(current, nice); : 
2
strstr : while : 	set_user_nice(current, nice); : 
2
str : 	return 0;[10]
strstr : INIT : 	return 0; : 
2
strstr : if : 	return 0; : 
2
strstr : for : 	return 0; : 
2
strstr : while : 	return 0; : 
2
str : #endif[6]
strstr : INIT : #endif : 
2
strstr : if : #endif : 
2
strstr : for : #endif : 
2
strstr : while : #endif : 
2
str : /**[3]
strstr : INIT : /** : 
2
strstr : if : /** : 
2
strstr : for : /** : 
2
strstr : while : /** : 
2
str :  * task_prio - return the priority value of a given task.[57]
strstr : INIT :  * task_prio - return the priority value of a given task. : 
2
strstr : if :  * task_prio - return the priority value of a given task. : 
2
strstr : for :  * task_prio - return the priority value of a given task. : 
2
strstr : while :  * task_prio - return the priority value of a given task. : 
2
str :  * @p: the task in question.[28]
strstr : INIT :  * @p: the task in question. : 
2
strstr : if :  * @p: the task in question. : 
2
strstr : for :  * @p: the task in question. : 
2
strstr : while :  * @p: the task in question. : 
2
str :  * Return: The priority value as seen by users in /proc.[56]
strstr : INIT :  * Return: The priority value as seen by users in /proc. : 
2
strstr : if :  * Return: The priority value as seen by users in /proc. : 
2
strstr : for :  * Return: The priority value as seen by users in /proc. : 
2
strstr : while :  * Return: The priority value as seen by users in /proc. : 
2
str :  * RT tasks are offset by -200. Normal tasks are centered[57]
strstr : INIT :  * RT tasks are offset by -200. Normal tasks are centered : 
2
strstr : if :  * RT tasks are offset by -200. Normal tasks are centered : 
2
strstr : for :  * RT tasks are offset by -200. Normal tasks are centered : 
2
strstr : while :  * RT tasks are offset by -200. Normal tasks are centered : 
2
str :  * around 0, value goes from -16 to +15.[40]
strstr : INIT :  * around 0, value goes from -16 to +15. : 
2
strstr : if :  * around 0, value goes from -16 to +15. : 
2
strstr : for :  * around 0, value goes from -16 to +15. : 
2
strstr : while :  * around 0, value goes from -16 to +15. : 
2
str :  */[3]
strstr : INIT :  */ : 
2
strstr : if :  */ : 
2
strstr : for :  */ : 
2
strstr : while :  */ : 
2
str : int task_prio(const struct task_struct *p)[42]
strstr : INIT : int task_prio(const struct task_struct *p) : 
2
strstr : if : int task_prio(const struct task_struct *p) : 
2
strstr : for : int task_prio(const struct task_struct *p) : 
2
strstr : while : int task_prio(const struct task_struct *p) : 
2
str : 	return p->prio - MAX_RT_PRIO;[30]
strstr : INIT : 	return p->prio - MAX_RT_PRIO; : 
2
strstr : if : 	return p->prio - MAX_RT_PRIO; : 
2
strstr : for : 	return p->prio - MAX_RT_PRIO; : 
2
strstr : while : 	return p->prio - MAX_RT_PRIO; : 
2
str : /**[3]
strstr : INIT : /** : 
2
strstr : if : /** : 
2
strstr : for : /** : 
2
strstr : while : /** : 
2
str :  * task_nice - return the nice value of a given task.[53]
strstr : INIT :  * task_nice - return the nice value of a given task. : 
2
strstr : if :  * task_nice - return the nice value of a given task. : 
2
strstr : for :  * task_nice - return the nice value of a given task. : 
2
strstr : while :  * task_nice - return the nice value of a given task. : 
2
str :  * @p: the task in question.[28]
strstr : INIT :  * @p: the task in question. : 
2
strstr : if :  * @p: the task in question. : 
2
strstr : for :  * @p: the task in question. : 
2
strstr : while :  * @p: the task in question. : 
2
str :  * Return: The nice value [ -20 ... 0 ... 19 ].[47]
strstr : INIT :  * Return: The nice value [ -20 ... 0 ... 19 ]. : 
2
strstr : if :  * Return: The nice value [ -20 ... 0 ... 19 ]. : 
2
strstr : for :  * Return: The nice value [ -20 ... 0 ... 19 ]. : 
2
strstr : while :  * Return: The nice value [ -20 ... 0 ... 19 ]. : 
2
str :  */[3]
strstr : INIT :  */ : 
2
strstr : if :  */ : 
2
strstr : for :  */ : 
2
strstr : while :  */ : 
2
str : int task_nice(const struct task_struct *p)[42]
strstr : INIT : int task_nice(const struct task_struct *p) : 
2
strstr : if : int task_nice(const struct task_struct *p) : 
2
strstr : for : int task_nice(const struct task_struct *p) : 
2
strstr : while : int task_nice(const struct task_struct *p) : 
2
str : 	return TASK_NICE(p);[21]
strstr : INIT : 	return TASK_NICE(p); : 
2
strstr : if : 	return TASK_NICE(p); : 
2
strstr : for : 	return TASK_NICE(p); : 
2
strstr : while : 	return TASK_NICE(p); : 
2
str : EXPORT_SYMBOL(task_nice);[25]
strstr : INIT : EXPORT_SYMBOL(task_nice); : 
2
strstr : if : EXPORT_SYMBOL(task_nice); : 
2
strstr : for : EXPORT_SYMBOL(task_nice); : 
2
strstr : while : EXPORT_SYMBOL(task_nice); : 
2
str : /**[3]
strstr : INIT : /** : 
2
strstr : if : /** : 
2
strstr : for : /** : 
2
strstr : while : /** : 
2
str :  * idle_cpu - is a given cpu idle currently?[44]
strstr : INIT :  * idle_cpu - is a given cpu idle currently? : 
2
strstr : if :  * idle_cpu - is a given cpu idle currently? : 
2
strstr : for :  * idle_cpu - is a given cpu idle currently? : 
2
strstr : while :  * idle_cpu - is a given cpu idle currently? : 
2
str :  * @cpu: the processor in question.[35]
strstr : INIT :  * @cpu: the processor in question. : 
2
strstr : if :  * @cpu: the processor in question. : 
2
strstr : for :  * @cpu: the processor in question. : 
2
strstr : while :  * @cpu: the processor in question. : 
2
str :  * Return: 1 if the CPU is currently idle. 0 otherwise.[55]
strstr : INIT :  * Return: 1 if the CPU is currently idle. 0 otherwise. : 
2
strstr : if :  * Return: 1 if the CPU is currently idle. 0 otherwise. : 
2
strstr : for :  * Return: 1 if the CPU is currently idle. 0 otherwise. : 
2
strstr : while :  * Return: 1 if the CPU is currently idle. 0 otherwise. : 
2
str :  */[3]
strstr : INIT :  */ : 
2
strstr : if :  */ : 
2
strstr : for :  */ : 
2
strstr : while :  */ : 
2
str : int idle_cpu(int cpu)[21]
strstr : INIT : int idle_cpu(int cpu) : 
2
strstr : if : int idle_cpu(int cpu) : 
2
strstr : for : int idle_cpu(int cpu) : 
2
strstr : while : int idle_cpu(int cpu) : 
2
str : 	struct rq *rq = cpu_rq(cpu);[29]
strstr : INIT : 	struct rq *rq = cpu_rq(cpu); : 
2
strstr : if : 	struct rq *rq = cpu_rq(cpu); : 
2
strstr : for : 	struct rq *rq = cpu_rq(cpu); : 
2
strstr : while : 	struct rq *rq = cpu_rq(cpu); : 
2
str : 	if (rq->curr != rq->idle)[26]
strstr : INIT : 	if (rq->curr != rq->idle) : 
2
strstr : if : 	if (rq->curr != rq->idle) : 
2
strstr : for : 	if (rq->curr != rq->idle) : 
2
strstr : while : 	if (rq->curr != rq->idle) : 
2
str : 		return 0;[11]
strstr : INIT : 		return 0; : 
2
strstr : if : 		return 0; : 
2
strstr : for : 		return 0; : 
2
strstr : while : 		return 0; : 
2
str : 	if (rq->nr_running)[20]
strstr : INIT : 	if (rq->nr_running) : 
2
strstr : if : 	if (rq->nr_running) : 
2
strstr : for : 	if (rq->nr_running) : 
2
strstr : while : 	if (rq->nr_running) : 
2
str : 		return 0;[11]
strstr : INIT : 		return 0; : 
2
strstr : if : 		return 0; : 
2
strstr : for : 		return 0; : 
2
strstr : while : 		return 0; : 
2
str : #ifdef CONFIG_SMP[17]
strstr : INIT : #ifdef CONFIG_SMP : 
2
strstr : if : #ifdef CONFIG_SMP : 
2
strstr : for : #ifdef CONFIG_SMP : 
2
strstr : while : #ifdef CONFIG_SMP : 
2
str : 	if (!llist_empty(&rq->wake_list))[34]
strstr : INIT : 	if (!llist_empty(&rq->wake_list)) : 
2
strstr : if : 	if (!llist_empty(&rq->wake_list)) : 
2
strstr : for : 	if (!llist_empty(&rq->wake_list)) : 
2
strstr : while : 	if (!llist_empty(&rq->wake_list)) : 
2
str : 		return 0;[11]
strstr : INIT : 		return 0; : 
2
strstr : if : 		return 0; : 
2
strstr : for : 		return 0; : 
2
strstr : while : 		return 0; : 
2
str : #endif[6]
strstr : INIT : #endif : 
2
strstr : if : #endif : 
2
strstr : for : #endif : 
2
strstr : while : #endif : 
2
str : 	return 1;[10]
strstr : INIT : 	return 1; : 
2
strstr : if : 	return 1; : 
2
strstr : for : 	return 1; : 
2
strstr : while : 	return 1; : 
2
str : /**[3]
strstr : INIT : /** : 
2
strstr : if : /** : 
2
strstr : for : /** : 
2
strstr : while : /** : 
2
str :  * idle_task - return the idle task for a given cpu.[52]
strstr : INIT :  * idle_task - return the idle task for a given cpu. : 
2
strstr : if :  * idle_task - return the idle task for a given cpu. : 
2
strstr : for :  * idle_task - return the idle task for a given cpu. : 
2
strstr : while :  * idle_task - return the idle task for a given cpu. : 
2
str :  * @cpu: the processor in question.[35]
strstr : INIT :  * @cpu: the processor in question. : 
2
strstr : if :  * @cpu: the processor in question. : 
2
strstr : for :  * @cpu: the processor in question. : 
2
strstr : while :  * @cpu: the processor in question. : 
2
str :  * Return: The idle task for the cpu @cpu.[42]
strstr : INIT :  * Return: The idle task for the cpu @cpu. : 
2
strstr : if :  * Return: The idle task for the cpu @cpu. : 
2
strstr : for :  * Return: The idle task for the cpu @cpu. : 
2
strstr : while :  * Return: The idle task for the cpu @cpu. : 
2
str :  */[3]
strstr : INIT :  */ : 
2
strstr : if :  */ : 
2
strstr : for :  */ : 
2
strstr : while :  */ : 
2
str : struct task_struct *idle_task(int cpu)[38]
strstr : INIT : struct task_struct *idle_task(int cpu) : 
2
strstr : if : struct task_struct *idle_task(int cpu) : 
2
strstr : for : struct task_struct *idle_task(int cpu) : 
2
strstr : while : struct task_struct *idle_task(int cpu) : 
2
str : 	return cpu_rq(cpu)->idle;[26]
strstr : INIT : 	return cpu_rq(cpu)->idle; : 
2
strstr : if : 	return cpu_rq(cpu)->idle; : 
2
strstr : for : 	return cpu_rq(cpu)->idle; : 
2
strstr : while : 	return cpu_rq(cpu)->idle; : 
2
str : /**[3]
strstr : INIT : /** : 
2
strstr : if : /** : 
2
strstr : for : /** : 
2
strstr : while : /** : 
2
str :  * find_process_by_pid - find a process with a matching PID value.[66]
strstr : INIT :  * find_process_by_pid - find a process with a matching PID value. : 
2
strstr : if :  * find_process_by_pid - find a process with a matching PID value. : 
2
strstr : for :  * find_process_by_pid - find a process with a matching PID value. : 
2
strstr : while :  * find_process_by_pid - find a process with a matching PID value. : 
2
str :  * @pid: the pid in question.[29]
strstr : INIT :  * @pid: the pid in question. : 
2
strstr : if :  * @pid: the pid in question. : 
2
strstr : for :  * @pid: the pid in question. : 
2
strstr : while :  * @pid: the pid in question. : 
2
str :  * The task of @pid, if found. %NULL otherwise.[47]
strstr : INIT :  * The task of @pid, if found. %NULL otherwise. : 
2
strstr : if :  * The task of @pid, if found. %NULL otherwise. : 
2
strstr : for :  * The task of @pid, if found. %NULL otherwise. : 
2
strstr : while :  * The task of @pid, if found. %NULL otherwise. : 
2
str :  */[3]
strstr : INIT :  */ : 
2
strstr : if :  */ : 
2
strstr : for :  */ : 
2
strstr : while :  */ : 
2
str : static struct task_struct *find_process_by_pid(pid_t pid)[57]
strstr : INIT : static struct task_struct *find_process_by_pid(pid_t pid) : 
2
strstr : if : static struct task_struct *find_process_by_pid(pid_t pid) : 
2
strstr : for : static struct task_struct *find_process_by_pid(pid_t pid) : 
2
strstr : while : static struct task_struct *find_process_by_pid(pid_t pid) : 
2
str : 	return pid ? find_task_by_vpid(pid) : current;[47]
strstr : INIT : 	return pid ? find_task_by_vpid(pid) : current; : 
2
strstr : if : 	return pid ? find_task_by_vpid(pid) : current; : 
2
strstr : for : 	return pid ? find_task_by_vpid(pid) : current; : 
2
strstr : while : 	return pid ? find_task_by_vpid(pid) : current; : 
2
str :  * This function initializes the sched_dl_entity of a newly becoming[68]
strstr : INIT :  * This function initializes the sched_dl_entity of a newly becoming : 
2
strstr : if :  * This function initializes the sched_dl_entity of a newly becoming : 
2
strstr : for :  * This function initializes the sched_dl_entity of a newly becoming : 
2
strstr : while :  * This function initializes the sched_dl_entity of a newly becoming : 
2
str :  * SCHED_DEADLINE task.[23]
strstr : INIT :  * SCHED_DEADLINE task. : 
2
strstr : if :  * SCHED_DEADLINE task. : 
2
strstr : for :  * SCHED_DEADLINE task. : 
2
strstr : while :  * SCHED_DEADLINE task. : 
2
str :  * Only the static values are considered here, the actual runtime and the[73]
strstr : INIT :  * Only the static values are considered here, the actual runtime and the : 
2
strstr : if :  * Only the static values are considered here, the actual runtime and the : 
2
strstr : for :  * Only the static values are considered here, the actual runtime and the : 
2
strstr : while :  * Only the static values are considered here, the actual runtime and the : 
2
str :  * absolute deadline will be properly calculated when the task is enqueued[74]
strstr : INIT :  * absolute deadline will be properly calculated when the task is enqueued : 
2
strstr : if :  * absolute deadline will be properly calculated when the task is enqueued : 
2
strstr : for :  * absolute deadline will be properly calculated when the task is enqueued : 
2
strstr : while :  * absolute deadline will be properly calculated when the task is enqueued : 
2
str :  * for the first time with its new policy.[42]
strstr : INIT :  * for the first time with its new policy. : 
2
strstr : if :  * for the first time with its new policy. : 
2
strstr : for :  * for the first time with its new policy. : 
2
strstr : while :  * for the first time with its new policy. : 
2
str :  */[3]
strstr : INIT :  */ : 
2
strstr : if :  */ : 
2
strstr : for :  */ : 
2
strstr : while :  */ : 
2
str : static void[11]
strstr : INIT : static void : 
2
strstr : if : static void : 
2
strstr : for : static void : 
2
strstr : while : static void : 
2
str : __setparam_dl(struct task_struct *p, const struct sched_attr *attr)[67]
strstr : INIT : __setparam_dl(struct task_struct *p, const struct sched_attr *attr) : 
2
strstr : if : __setparam_dl(struct task_struct *p, const struct sched_attr *attr) : 
2
strstr : for : __setparam_dl(struct task_struct *p, const struct sched_attr *attr) : 
2
strstr : while : __setparam_dl(struct task_struct *p, const struct sched_attr *attr) : 
2
str : 	struct sched_dl_entity *dl_se = &p->dl;[40]
strstr : INIT : 	struct sched_dl_entity *dl_se = &p->dl; : 
2
strstr : if : 	struct sched_dl_entity *dl_se = &p->dl; : 
2
strstr : for : 	struct sched_dl_entity *dl_se = &p->dl; : 
2
strstr : while : 	struct sched_dl_entity *dl_se = &p->dl; : 
2
str : 	init_dl_task_timer(dl_se);[27]
strstr : INIT : 	init_dl_task_timer(dl_se); : 
2
strstr : if : 	init_dl_task_timer(dl_se); : 
2
strstr : for : 	init_dl_task_timer(dl_se); : 
2
strstr : while : 	init_dl_task_timer(dl_se); : 
2
str : 	dl_se->dl_runtime = attr->sched_runtime;[41]
strstr : INIT : 	dl_se->dl_runtime = attr->sched_runtime; : 
2
strstr : if : 	dl_se->dl_runtime = attr->sched_runtime; : 
2
strstr : for : 	dl_se->dl_runtime = attr->sched_runtime; : 
2
strstr : while : 	dl_se->dl_runtime = attr->sched_runtime; : 
2
str : 	dl_se->dl_deadline = attr->sched_deadline;[43]
strstr : INIT : 	dl_se->dl_deadline = attr->sched_deadline; : 
2
strstr : if : 	dl_se->dl_deadline = attr->sched_deadline; : 
2
strstr : for : 	dl_se->dl_deadline = attr->sched_deadline; : 
2
strstr : while : 	dl_se->dl_deadline = attr->sched_deadline; : 
2
str : 	dl_se->dl_period = attr->sched_period ?: dl_se->dl_deadline;[61]
strstr : INIT : 	dl_se->dl_period = attr->sched_period ?: dl_se->dl_deadline; : 
2
strstr : if : 	dl_se->dl_period = attr->sched_period ?: dl_se->dl_deadline; : 
2
strstr : for : 	dl_se->dl_period = attr->sched_period ?: dl_se->dl_deadline; : 
2
strstr : while : 	dl_se->dl_period = attr->sched_period ?: dl_se->dl_deadline; : 
2
str : 	dl_se->flags = attr->sched_flags;[34]
strstr : INIT : 	dl_se->flags = attr->sched_flags; : 
2
strstr : if : 	dl_se->flags = attr->sched_flags; : 
2
strstr : for : 	dl_se->flags = attr->sched_flags; : 
2
strstr : while : 	dl_se->flags = attr->sched_flags; : 
2
str : 	dl_se->dl_bw = to_ratio(dl_se->dl_period, dl_se->dl_runtime);[62]
strstr : INIT : 	dl_se->dl_bw = to_ratio(dl_se->dl_period, dl_se->dl_runtime); : 
2
strstr : if : 	dl_se->dl_bw = to_ratio(dl_se->dl_period, dl_se->dl_runtime); : 
2
strstr : for : 	dl_se->dl_bw = to_ratio(dl_se->dl_period, dl_se->dl_runtime); : 
2
strstr : while : 	dl_se->dl_bw = to_ratio(dl_se->dl_period, dl_se->dl_runtime); : 
2
str : 	dl_se->dl_throttled = 0;[25]
strstr : INIT : 	dl_se->dl_throttled = 0; : 
2
strstr : if : 	dl_se->dl_throttled = 0; : 
2
strstr : for : 	dl_se->dl_throttled = 0; : 
2
strstr : while : 	dl_se->dl_throttled = 0; : 
2
str : 	dl_se->dl_new = 1;[19]
strstr : INIT : 	dl_se->dl_new = 1; : 
2
strstr : if : 	dl_se->dl_new = 1; : 
2
strstr : for : 	dl_se->dl_new = 1; : 
2
strstr : while : 	dl_se->dl_new = 1; : 
2
str : /* Actually do priority change: must hold pi & rq lock. */[58]
strstr : INIT : /* Actually do priority change: must hold pi & rq lock. */ : 
2
strstr : if : /* Actually do priority change: must hold pi & rq lock. */ : 
2
strstr : for : /* Actually do priority change: must hold pi & rq lock. */ : 
2
strstr : while : /* Actually do priority change: must hold pi & rq lock. */ : 
2
str : static void __setscheduler(struct rq *rq, struct task_struct *p,[64]
strstr : INIT : static void __setscheduler(struct rq *rq, struct task_struct *p, : 
2
strstr : if : static void __setscheduler(struct rq *rq, struct task_struct *p, : 
2
strstr : for : static void __setscheduler(struct rq *rq, struct task_struct *p, : 
2
strstr : while : static void __setscheduler(struct rq *rq, struct task_struct *p, : 
2
str : 			   const struct sched_attr *attr)[36]
strstr : INIT : 			   const struct sched_attr *attr) : 
2
strstr : if : 			   const struct sched_attr *attr) : 
2
strstr : for : 			   const struct sched_attr *attr) : 
2
strstr : while : 			   const struct sched_attr *attr) : 
2
str : 	int policy = attr->sched_policy;[33]
strstr : INIT : 	int policy = attr->sched_policy; : 
2
strstr : if : 	int policy = attr->sched_policy; : 
2
strstr : for : 	int policy = attr->sched_policy; : 
2
strstr : while : 	int policy = attr->sched_policy; : 
2
str : 	if (policy == -1) /* setparam */[33]
strstr : INIT : 	if (policy == -1) /* setparam */ : 
2
strstr : if : 	if (policy == -1) /* setparam */ : 
2
strstr : for : 	if (policy == -1) /* setparam */ : 
2
strstr : while : 	if (policy == -1) /* setparam */ : 
2
str : 		policy = p->policy;[21]
strstr : INIT : 		policy = p->policy; : 
2
strstr : if : 		policy = p->policy; : 
2
strstr : for : 		policy = p->policy; : 
2
strstr : while : 		policy = p->policy; : 
2
str : 	p->policy = policy;[20]
strstr : INIT : 	p->policy = policy; : 
2
strstr : if : 	p->policy = policy; : 
2
strstr : for : 	p->policy = policy; : 
2
strstr : while : 	p->policy = policy; : 
2
str : 	if (dl_policy(policy))[23]
strstr : INIT : 	if (dl_policy(policy)) : 
2
strstr : if : 	if (dl_policy(policy)) : 
2
strstr : for : 	if (dl_policy(policy)) : 
2
strstr : while : 	if (dl_policy(policy)) : 
2
str : 		__setparam_dl(p, attr);[25]
strstr : INIT : 		__setparam_dl(p, attr); : 
2
strstr : if : 		__setparam_dl(p, attr); : 
2
strstr : for : 		__setparam_dl(p, attr); : 
2
strstr : while : 		__setparam_dl(p, attr); : 
2
str : 	else if (fair_policy(policy))[30]
strstr : INIT : 	else if (fair_policy(policy)) : 
2
strstr : if : 	else if (fair_policy(policy)) : 
2
strstr : for : 	else if (fair_policy(policy)) : 
2
strstr : while : 	else if (fair_policy(policy)) : 
2
str : 		p->static_prio = NICE_TO_PRIO(attr->sched_nice);[50]
strstr : INIT : 		p->static_prio = NICE_TO_PRIO(attr->sched_nice); : 
2
strstr : if : 		p->static_prio = NICE_TO_PRIO(attr->sched_nice); : 
2
strstr : for : 		p->static_prio = NICE_TO_PRIO(attr->sched_nice); : 
2
strstr : while : 		p->static_prio = NICE_TO_PRIO(attr->sched_nice); : 
2
str : 	/*[3]
strstr : INIT : 	/* : 
2
strstr : if : 	/* : 
2
strstr : for : 	/* : 
2
strstr : while : 	/* : 
2
str : 	 * __sched_setscheduler() ensures attr->sched_priority == 0 when[65]
strstr : INIT : 	 * __sched_setscheduler() ensures attr->sched_priority == 0 when : 
2
strstr : if : 	 * __sched_setscheduler() ensures attr->sched_priority == 0 when : 
2
strstr : for : 	 * __sched_setscheduler() ensures attr->sched_priority == 0 when : 
2
strstr : while : 	 * __sched_setscheduler() ensures attr->sched_priority == 0 when : 
2
str : 	 * !rt_policy. Always setting this ensures that things like[60]
strstr : INIT : 	 * !rt_policy. Always setting this ensures that things like : 
2
strstr : if : 	 * !rt_policy. Always setting this ensures that things like : 
2
strstr : for : 	 * !rt_policy. Always setting this ensures that things like : 
2
strstr : while : 	 * !rt_policy. Always setting this ensures that things like : 
2
str : 	 * getparam()/getattr() don't report silly values for !rt tasks.[65]
strstr : INIT : 	 * getparam()/getattr() don't report silly values for !rt tasks. : 
2
strstr : if : 	 * getparam()/getattr() don't report silly values for !rt tasks. : 
2
strstr : for : 	 * getparam()/getattr() don't report silly values for !rt tasks. : 
2
strstr : while : 	 * getparam()/getattr() don't report silly values for !rt tasks. : 
2
str : 	 */[4]
strstr : INIT : 	 */ : 
2
strstr : if : 	 */ : 
2
strstr : for : 	 */ : 
2
strstr : while : 	 */ : 
2
str : 	p->rt_priority = attr->sched_priority;[39]
strstr : INIT : 	p->rt_priority = attr->sched_priority; : 
2
strstr : if : 	p->rt_priority = attr->sched_priority; : 
2
strstr : for : 	p->rt_priority = attr->sched_priority; : 
2
strstr : while : 	p->rt_priority = attr->sched_priority; : 
2
str : 	p->normal_prio = normal_prio(p);[33]
strstr : INIT : 	p->normal_prio = normal_prio(p); : 
2
strstr : if : 	p->normal_prio = normal_prio(p); : 
2
strstr : for : 	p->normal_prio = normal_prio(p); : 
2
strstr : while : 	p->normal_prio = normal_prio(p); : 
2
str : 	p->prio = rt_mutex_getprio(p);[31]
strstr : INIT : 	p->prio = rt_mutex_getprio(p); : 
2
strstr : if : 	p->prio = rt_mutex_getprio(p); : 
2
strstr : for : 	p->prio = rt_mutex_getprio(p); : 
2
strstr : while : 	p->prio = rt_mutex_getprio(p); : 
2
str : 	if (dl_prio(p->prio))[22]
strstr : INIT : 	if (dl_prio(p->prio)) : 
2
strstr : if : 	if (dl_prio(p->prio)) : 
2
strstr : for : 	if (dl_prio(p->prio)) : 
2
strstr : while : 	if (dl_prio(p->prio)) : 
2
str : 		p->sched_class = &dl_sched_class;[35]
strstr : INIT : 		p->sched_class = &dl_sched_class; : 
2
strstr : if : 		p->sched_class = &dl_sched_class; : 
2
strstr : for : 		p->sched_class = &dl_sched_class; : 
2
strstr : while : 		p->sched_class = &dl_sched_class; : 
2
str : 	else if (rt_prio(p->prio))[27]
strstr : INIT : 	else if (rt_prio(p->prio)) : 
2
strstr : if : 	else if (rt_prio(p->prio)) : 
2
strstr : for : 	else if (rt_prio(p->prio)) : 
2
strstr : while : 	else if (rt_prio(p->prio)) : 
2
str : 		p->sched_class = &rt_sched_class;[35]
strstr : INIT : 		p->sched_class = &rt_sched_class; : 
2
strstr : if : 		p->sched_class = &rt_sched_class; : 
2
strstr : for : 		p->sched_class = &rt_sched_class; : 
2
strstr : while : 		p->sched_class = &rt_sched_class; : 
2
str : 	else[5]
strstr : INIT : 	else : 
2
strstr : if : 	else : 
2
strstr : for : 	else : 
2
strstr : while : 	else : 
2
str : 		p->sched_class = &fair_sched_class;[37]
strstr : INIT : 		p->sched_class = &fair_sched_class; : 
2
strstr : if : 		p->sched_class = &fair_sched_class; : 
2
strstr : for : 		p->sched_class = &fair_sched_class; : 
2
strstr : while : 		p->sched_class = &fair_sched_class; : 
2
str : 	set_load_weight(p);[20]
strstr : INIT : 	set_load_weight(p); : 
2
strstr : if : 	set_load_weight(p); : 
2
strstr : for : 	set_load_weight(p); : 
2
strstr : while : 	set_load_weight(p); : 
2
str : static void[11]
strstr : INIT : static void : 
2
strstr : if : static void : 
2
strstr : for : static void : 
2
strstr : while : static void : 
2
str : __getparam_dl(struct task_struct *p, struct sched_attr *attr)[61]
strstr : INIT : __getparam_dl(struct task_struct *p, struct sched_attr *attr) : 
2
strstr : if : __getparam_dl(struct task_struct *p, struct sched_attr *attr) : 
2
strstr : for : __getparam_dl(struct task_struct *p, struct sched_attr *attr) : 
2
strstr : while : __getparam_dl(struct task_struct *p, struct sched_attr *attr) : 
2
str : 	struct sched_dl_entity *dl_se = &p->dl;[40]
strstr : INIT : 	struct sched_dl_entity *dl_se = &p->dl; : 
2
strstr : if : 	struct sched_dl_entity *dl_se = &p->dl; : 
2
strstr : for : 	struct sched_dl_entity *dl_se = &p->dl; : 
2
strstr : while : 	struct sched_dl_entity *dl_se = &p->dl; : 
2
str : 	attr->sched_priority = p->rt_priority;[39]
strstr : INIT : 	attr->sched_priority = p->rt_priority; : 
2
strstr : if : 	attr->sched_priority = p->rt_priority; : 
2
strstr : for : 	attr->sched_priority = p->rt_priority; : 
2
strstr : while : 	attr->sched_priority = p->rt_priority; : 
2
str : 	attr->sched_runtime = dl_se->dl_runtime;[41]
strstr : INIT : 	attr->sched_runtime = dl_se->dl_runtime; : 
2
strstr : if : 	attr->sched_runtime = dl_se->dl_runtime; : 
2
strstr : for : 	attr->sched_runtime = dl_se->dl_runtime; : 
2
strstr : while : 	attr->sched_runtime = dl_se->dl_runtime; : 
2
str : 	attr->sched_deadline = dl_se->dl_deadline;[43]
strstr : INIT : 	attr->sched_deadline = dl_se->dl_deadline; : 
2
strstr : if : 	attr->sched_deadline = dl_se->dl_deadline; : 
2
strstr : for : 	attr->sched_deadline = dl_se->dl_deadline; : 
2
strstr : while : 	attr->sched_deadline = dl_se->dl_deadline; : 
2
str : 	attr->sched_period = dl_se->dl_period;[39]
strstr : INIT : 	attr->sched_period = dl_se->dl_period; : 
2
strstr : if : 	attr->sched_period = dl_se->dl_period; : 
2
strstr : for : 	attr->sched_period = dl_se->dl_period; : 
2
strstr : while : 	attr->sched_period = dl_se->dl_period; : 
2
str : 	attr->sched_flags = dl_se->flags;[34]
strstr : INIT : 	attr->sched_flags = dl_se->flags; : 
2
strstr : if : 	attr->sched_flags = dl_se->flags; : 
2
strstr : for : 	attr->sched_flags = dl_se->flags; : 
2
strstr : while : 	attr->sched_flags = dl_se->flags; : 
2
str :  * This function validates the new parameters of a -deadline task.[66]
strstr : INIT :  * This function validates the new parameters of a -deadline task. : 
2
strstr : if :  * This function validates the new parameters of a -deadline task. : 
2
strstr : for :  * This function validates the new parameters of a -deadline task. : 
2
strstr : while :  * This function validates the new parameters of a -deadline task. : 
2
str :  * We ask for the deadline not being zero, and greater or equal[63]
strstr : INIT :  * We ask for the deadline not being zero, and greater or equal : 
2
strstr : if :  * We ask for the deadline not being zero, and greater or equal : 
2
strstr : for :  * We ask for the deadline not being zero, and greater or equal : 
2
strstr : while :  * We ask for the deadline not being zero, and greater or equal : 
2
str :  * than the runtime, as well as the period of being zero or[59]
strstr : INIT :  * than the runtime, as well as the period of being zero or : 
2
strstr : if :  * than the runtime, as well as the period of being zero or : 
2
strstr : for :  * than the runtime, as well as the period of being zero or : 
2
strstr : while :  * than the runtime, as well as the period of being zero or : 
2
str :  * greater than deadline. Furthermore, we have to be sure that[62]
strstr : INIT :  * greater than deadline. Furthermore, we have to be sure that : 
2
strstr : if :  * greater than deadline. Furthermore, we have to be sure that : 
2
strstr : for :  * greater than deadline. Furthermore, we have to be sure that : 
2
strstr : while :  * greater than deadline. Furthermore, we have to be sure that : 
2
str :  * user parameters are above the internal resolution of 1us (we[63]
strstr : INIT :  * user parameters are above the internal resolution of 1us (we : 
2
strstr : if :  * user parameters are above the internal resolution of 1us (we : 
2
strstr : for :  * user parameters are above the internal resolution of 1us (we : 
2
strstr : while :  * user parameters are above the internal resolution of 1us (we : 
2
str :  * check sched_runtime only since it is always the smaller one) and[67]
strstr : INIT :  * check sched_runtime only since it is always the smaller one) and : 
2
strstr : if :  * check sched_runtime only since it is always the smaller one) and : 
2
strstr : for :  * check sched_runtime only since it is always the smaller one) and : 
2
strstr : while :  * check sched_runtime only since it is always the smaller one) and : 
2
str :  * below 2^63 ns (we have to check both sched_deadline and[58]
strstr : INIT :  * below 2^63 ns (we have to check both sched_deadline and : 
2
strstr : if :  * below 2^63 ns (we have to check both sched_deadline and : 
2
strstr : for :  * below 2^63 ns (we have to check both sched_deadline and : 
2
strstr : while :  * below 2^63 ns (we have to check both sched_deadline and : 
2
str :  * sched_period, as the latter can be zero).[44]
strstr : INIT :  * sched_period, as the latter can be zero). : 
2
strstr : if :  * sched_period, as the latter can be zero). : 
2
strstr : for :  * sched_period, as the latter can be zero). : 
2
strstr : while :  * sched_period, as the latter can be zero). : 
2
str :  */[3]
strstr : INIT :  */ : 
2
strstr : if :  */ : 
2
strstr : for :  */ : 
2
strstr : while :  */ : 
2
str : static bool[11]
strstr : INIT : static bool : 
2
strstr : if : static bool : 
2
strstr : for : static bool : 
2
strstr : while : static bool : 
2
str : __checkparam_dl(const struct sched_attr *attr)[46]
strstr : INIT : __checkparam_dl(const struct sched_attr *attr) : 
2
strstr : if : __checkparam_dl(const struct sched_attr *attr) : 
2
strstr : for : __checkparam_dl(const struct sched_attr *attr) : 
2
strstr : while : __checkparam_dl(const struct sched_attr *attr) : 
2
str : 	/* deadline != 0 */[20]
strstr : INIT : 	/* deadline != 0 */ : 
2
strstr : if : 	/* deadline != 0 */ : 
2
strstr : for : 	/* deadline != 0 */ : 
2
strstr : while : 	/* deadline != 0 */ : 
2
str : 	if (attr->sched_deadline == 0)[31]
strstr : INIT : 	if (attr->sched_deadline == 0) : 
2
strstr : if : 	if (attr->sched_deadline == 0) : 
2
strstr : for : 	if (attr->sched_deadline == 0) : 
2
strstr : while : 	if (attr->sched_deadline == 0) : 
2
str : 		return false;[15]
strstr : INIT : 		return false; : 
2
strstr : if : 		return false; : 
2
strstr : for : 		return false; : 
2
strstr : while : 		return false; : 
2
str : 	/*[3]
strstr : INIT : 	/* : 
2
strstr : if : 	/* : 
2
strstr : for : 	/* : 
2
strstr : while : 	/* : 
2
str : 	 * Since we truncate DL_SCALE bits, make sure we're at least[61]
strstr : INIT : 	 * Since we truncate DL_SCALE bits, make sure we're at least : 
2
strstr : if : 	 * Since we truncate DL_SCALE bits, make sure we're at least : 
2
strstr : for : 	 * Since we truncate DL_SCALE bits, make sure we're at least : 
2
strstr : while : 	 * Since we truncate DL_SCALE bits, make sure we're at least : 
2
str : 	 * that big.[13]
strstr : INIT : 	 * that big. : 
2
strstr : if : 	 * that big. : 
2
strstr : for : 	 * that big. : 
2
strstr : while : 	 * that big. : 
2
str : 	 */[4]
strstr : INIT : 	 */ : 
2
strstr : if : 	 */ : 
2
strstr : for : 	 */ : 
2
strstr : while : 	 */ : 
2
str : 	if (attr->sched_runtime < (1ULL << DL_SCALE))[46]
strstr : INIT : 	if (attr->sched_runtime < (1ULL << DL_SCALE)) : 
2
strstr : if : 	if (attr->sched_runtime < (1ULL << DL_SCALE)) : 
2
strstr : for : 	if (attr->sched_runtime < (1ULL << DL_SCALE)) : 
2
strstr : while : 	if (attr->sched_runtime < (1ULL << DL_SCALE)) : 
2
str : 		return false;[15]
strstr : INIT : 		return false; : 
2
strstr : if : 		return false; : 
2
strstr : for : 		return false; : 
2
strstr : while : 		return false; : 
2
str : 	/*[3]
strstr : INIT : 	/* : 
2
strstr : if : 	/* : 
2
strstr : for : 	/* : 
2
strstr : while : 	/* : 
2
str : 	 * Since we use the MSB for wrap-around and sign issues, make[62]
strstr : INIT : 	 * Since we use the MSB for wrap-around and sign issues, make : 
2
strstr : if : 	 * Since we use the MSB for wrap-around and sign issues, make : 
2
strstr : for : 	 * Since we use the MSB for wrap-around and sign issues, make : 
2
strstr : while : 	 * Since we use the MSB for wrap-around and sign issues, make : 
2
str : 	 * sure it's not set (mind that period can be equal to zero).[62]
strstr : INIT : 	 * sure it's not set (mind that period can be equal to zero). : 
2
strstr : if : 	 * sure it's not set (mind that period can be equal to zero). : 
2
strstr : for : 	 * sure it's not set (mind that period can be equal to zero). : 
2
strstr : while : 	 * sure it's not set (mind that period can be equal to zero). : 
2
str : 	 */[4]
strstr : INIT : 	 */ : 
2
strstr : if : 	 */ : 
2
strstr : for : 	 */ : 
2
strstr : while : 	 */ : 
2
str : 	if (attr->sched_deadline & (1ULL << 63) ||[43]
strstr : INIT : 	if (attr->sched_deadline & (1ULL << 63) || : 
2
strstr : if : 	if (attr->sched_deadline & (1ULL << 63) || : 
2
strstr : for : 	if (attr->sched_deadline & (1ULL << 63) || : 
2
strstr : while : 	if (attr->sched_deadline & (1ULL << 63) || : 
2
str : 	    attr->sched_period & (1ULL << 63))[39]
strstr : INIT : 	    attr->sched_period & (1ULL << 63)) : 
2
strstr : if : 	    attr->sched_period & (1ULL << 63)) : 
2
strstr : for : 	    attr->sched_period & (1ULL << 63)) : 
2
strstr : while : 	    attr->sched_period & (1ULL << 63)) : 
2
str : 		return false;[15]
strstr : INIT : 		return false; : 
2
strstr : if : 		return false; : 
2
strstr : for : 		return false; : 
2
strstr : while : 		return false; : 
2
str : 	/* runtime <= deadline <= period (if period != 0) */[53]
strstr : INIT : 	/* runtime <= deadline <= period (if period != 0) */ : 
2
strstr : if : 	/* runtime <= deadline <= period (if period != 0) */ : 
2
strstr : for : 	/* runtime <= deadline <= period (if period != 0) */ : 
2
strstr : while : 	/* runtime <= deadline <= period (if period != 0) */ : 
2
str : 	if ((attr->sched_period != 0 &&[32]
strstr : INIT : 	if ((attr->sched_period != 0 && : 
2
strstr : if : 	if ((attr->sched_period != 0 && : 
2
strstr : for : 	if ((attr->sched_period != 0 && : 
2
strstr : while : 	if ((attr->sched_period != 0 && : 
2
str : 	     attr->sched_period < attr->sched_deadline) ||[51]
strstr : INIT : 	     attr->sched_period < attr->sched_deadline) || : 
2
strstr : if : 	     attr->sched_period < attr->sched_deadline) || : 
2
strstr : for : 	     attr->sched_period < attr->sched_deadline) || : 
2
strstr : while : 	     attr->sched_period < attr->sched_deadline) || : 
2
str : 	    attr->sched_deadline < attr->sched_runtime)[48]
strstr : INIT : 	    attr->sched_deadline < attr->sched_runtime) : 
2
strstr : if : 	    attr->sched_deadline < attr->sched_runtime) : 
2
strstr : for : 	    attr->sched_deadline < attr->sched_runtime) : 
2
strstr : while : 	    attr->sched_deadline < attr->sched_runtime) : 
2
str : 		return false;[15]
strstr : INIT : 		return false; : 
2
strstr : if : 		return false; : 
2
strstr : for : 		return false; : 
2
strstr : while : 		return false; : 
2
str : 	return true;[13]
strstr : INIT : 	return true; : 
2
strstr : if : 	return true; : 
2
strstr : for : 	return true; : 
2
strstr : while : 	return true; : 
2
str :  * check the target process has a UID that matches the current process's[72]
strstr : INIT :  * check the target process has a UID that matches the current process's : 
2
strstr : if :  * check the target process has a UID that matches the current process's : 
2
strstr : for :  * check the target process has a UID that matches the current process's : 
2
strstr : while :  * check the target process has a UID that matches the current process's : 
2
str :  */[3]
strstr : INIT :  */ : 
2
strstr : if :  */ : 
2
strstr : for :  */ : 
2
strstr : while :  */ : 
2
str : static bool check_same_owner(struct task_struct *p)[51]
strstr : INIT : static bool check_same_owner(struct task_struct *p) : 
2
strstr : if : static bool check_same_owner(struct task_struct *p) : 
2
strstr : for : static bool check_same_owner(struct task_struct *p) : 
2
strstr : while : static bool check_same_owner(struct task_struct *p) : 
2
str : 	const struct cred *cred = current_cred(), *pcred;[50]
strstr : INIT : 	const struct cred *cred = current_cred(), *pcred; : 
2
strstr : if : 	const struct cred *cred = current_cred(), *pcred; : 
2
strstr : for : 	const struct cred *cred = current_cred(), *pcred; : 
2
strstr : while : 	const struct cred *cred = current_cred(), *pcred; : 
2
str : 	bool match;[12]
strstr : INIT : 	bool match; : 
2
strstr : if : 	bool match; : 
2
strstr : for : 	bool match; : 
2
strstr : while : 	bool match; : 
2
str : 	rcu_read_lock();[17]
strstr : INIT : 	rcu_read_lock(); : 
2
strstr : if : 	rcu_read_lock(); : 
2
strstr : for : 	rcu_read_lock(); : 
2
strstr : while : 	rcu_read_lock(); : 
2
str : 	pcred = __task_cred(p);[24]
strstr : INIT : 	pcred = __task_cred(p); : 
2
strstr : if : 	pcred = __task_cred(p); : 
2
strstr : for : 	pcred = __task_cred(p); : 
2
strstr : while : 	pcred = __task_cred(p); : 
2
str : 	match = (uid_eq(cred->euid, pcred->euid) ||[44]
strstr : INIT : 	match = (uid_eq(cred->euid, pcred->euid) || : 
2
strstr : if : 	match = (uid_eq(cred->euid, pcred->euid) || : 
2
strstr : for : 	match = (uid_eq(cred->euid, pcred->euid) || : 
2
strstr : while : 	match = (uid_eq(cred->euid, pcred->euid) || : 
2
str : 		 uid_eq(cred->euid, pcred->uid));[35]
strstr : INIT : 		 uid_eq(cred->euid, pcred->uid)); : 
2
strstr : if : 		 uid_eq(cred->euid, pcred->uid)); : 
2
strstr : for : 		 uid_eq(cred->euid, pcred->uid)); : 
2
strstr : while : 		 uid_eq(cred->euid, pcred->uid)); : 
2
str : 	rcu_read_unlock();[19]
strstr : INIT : 	rcu_read_unlock(); : 
2
strstr : if : 	rcu_read_unlock(); : 
2
strstr : for : 	rcu_read_unlock(); : 
2
strstr : while : 	rcu_read_unlock(); : 
2
str : 	return match;[14]
strstr : INIT : 	return match; : 
2
strstr : if : 	return match; : 
2
strstr : for : 	return match; : 
2
strstr : while : 	return match; : 
2
str : static int __sched_setscheduler(struct task_struct *p,[54]
strstr : INIT : static int __sched_setscheduler(struct task_struct *p, : 
2
strstr : if : static int __sched_setscheduler(struct task_struct *p, : 
2
strstr : for : static int __sched_setscheduler(struct task_struct *p, : 
2
strstr : while : static int __sched_setscheduler(struct task_struct *p, : 
2
str : 				const struct sched_attr *attr,[34]
strstr : INIT : 				const struct sched_attr *attr, : 
2
strstr : if : 				const struct sched_attr *attr, : 
2
strstr : for : 				const struct sched_attr *attr, : 
2
strstr : while : 				const struct sched_attr *attr, : 
2
str : 				bool user)[14]
strstr : INIT : 				bool user) : 
2
strstr : if : 				bool user) : 
2
strstr : for : 				bool user) : 
2
strstr : while : 				bool user) : 
2
str : 	int retval, oldprio, oldpolicy = -1, on_rq, running;[53]
strstr : INIT : 	int retval, oldprio, oldpolicy = -1, on_rq, running; : 
2
strstr : if : 	int retval, oldprio, oldpolicy = -1, on_rq, running; : 
2
strstr : for : 	int retval, oldprio, oldpolicy = -1, on_rq, running; : 
2
strstr : while : 	int retval, oldprio, oldpolicy = -1, on_rq, running; : 
2
str : 	int policy = attr->sched_policy;[33]
strstr : INIT : 	int policy = attr->sched_policy; : 
2
strstr : if : 	int policy = attr->sched_policy; : 
2
strstr : for : 	int policy = attr->sched_policy; : 
2
strstr : while : 	int policy = attr->sched_policy; : 
2
str : 	unsigned long flags;[21]
strstr : INIT : 	unsigned long flags; : 
2
strstr : if : 	unsigned long flags; : 
2
strstr : for : 	unsigned long flags; : 
2
strstr : while : 	unsigned long flags; : 
2
str : 	const struct sched_class *prev_class;[38]
strstr : INIT : 	const struct sched_class *prev_class; : 
2
strstr : if : 	const struct sched_class *prev_class; : 
2
strstr : for : 	const struct sched_class *prev_class; : 
2
strstr : while : 	const struct sched_class *prev_class; : 
2
str : 	struct rq *rq;[15]
strstr : INIT : 	struct rq *rq; : 
2
strstr : if : 	struct rq *rq; : 
2
strstr : for : 	struct rq *rq; : 
2
strstr : while : 	struct rq *rq; : 
2
str : 	int reset_on_fork;[19]
strstr : INIT : 	int reset_on_fork; : 
2
strstr : if : 	int reset_on_fork; : 
2
strstr : for : 	int reset_on_fork; : 
2
strstr : while : 	int reset_on_fork; : 
2
str : 	/* may grab non-irq protected spin_locks */[44]
strstr : INIT : 	/* may grab non-irq protected spin_locks */ : 
2
strstr : if : 	/* may grab non-irq protected spin_locks */ : 
2
strstr : for : 	/* may grab non-irq protected spin_locks */ : 
2
strstr : while : 	/* may grab non-irq protected spin_locks */ : 
2
str : 	BUG_ON(in_interrupt());[24]
strstr : INIT : 	BUG_ON(in_interrupt()); : 
2
strstr : if : 	BUG_ON(in_interrupt()); : 
2
strstr : for : 	BUG_ON(in_interrupt()); : 
2
strstr : while : 	BUG_ON(in_interrupt()); : 
2
str : recheck:[8]
strstr : INIT : recheck: : 
2
strstr : if : recheck: : 
2
strstr : for : recheck: : 
2
strstr : while : recheck: : 
2
str : 	/* double check policy once rq lock held */[44]
strstr : INIT : 	/* double check policy once rq lock held */ : 
2
strstr : if : 	/* double check policy once rq lock held */ : 
2
strstr : for : 	/* double check policy once rq lock held */ : 
2
strstr : while : 	/* double check policy once rq lock held */ : 
2
str : 	if (policy < 0) {[18]
strstr : INIT : 	if (policy < 0) { : 
2
strstr : if : 	if (policy < 0) { : 
2
strstr : for : 	if (policy < 0) { : 
2
strstr : while : 	if (policy < 0) { : 
2
str : 		reset_on_fork = p->sched_reset_on_fork;[41]
strstr : INIT : 		reset_on_fork = p->sched_reset_on_fork; : 
2
strstr : if : 		reset_on_fork = p->sched_reset_on_fork; : 
2
strstr : for : 		reset_on_fork = p->sched_reset_on_fork; : 
2
strstr : while : 		reset_on_fork = p->sched_reset_on_fork; : 
2
str : 		policy = oldpolicy = p->policy;[33]
strstr : INIT : 		policy = oldpolicy = p->policy; : 
2
strstr : if : 		policy = oldpolicy = p->policy; : 
2
strstr : for : 		policy = oldpolicy = p->policy; : 
2
strstr : while : 		policy = oldpolicy = p->policy; : 
2
str : 	} else {[9]
strstr : INIT : 	} else { : 
2
strstr : if : 	} else { : 
2
strstr : for : 	} else { : 
2
strstr : while : 	} else { : 
2
str : 		reset_on_fork = !!(attr->sched_flags & SCHED_FLAG_RESET_ON_FORK);[67]
strstr : INIT : 		reset_on_fork = !!(attr->sched_flags & SCHED_FLAG_RESET_ON_FORK); : 
2
strstr : if : 		reset_on_fork = !!(attr->sched_flags & SCHED_FLAG_RESET_ON_FORK); : 
2
strstr : for : 		reset_on_fork = !!(attr->sched_flags & SCHED_FLAG_RESET_ON_FORK); : 
2
strstr : while : 		reset_on_fork = !!(attr->sched_flags & SCHED_FLAG_RESET_ON_FORK); : 
2
str : 		if (policy != SCHED_DEADLINE &&[33]
strstr : INIT : 		if (policy != SCHED_DEADLINE && : 
2
strstr : if : 		if (policy != SCHED_DEADLINE && : 
2
strstr : for : 		if (policy != SCHED_DEADLINE && : 
2
strstr : while : 		if (policy != SCHED_DEADLINE && : 
2
str : 				policy != SCHED_FIFO && policy != SCHED_RR &&[49]
strstr : INIT : 				policy != SCHED_FIFO && policy != SCHED_RR && : 
2
strstr : if : 				policy != SCHED_FIFO && policy != SCHED_RR && : 
2
strstr : for : 				policy != SCHED_FIFO && policy != SCHED_RR && : 
2
strstr : while : 				policy != SCHED_FIFO && policy != SCHED_RR && : 
2
str : 				policy != SCHED_NORMAL && policy != SCHED_BATCH &&[54]
strstr : INIT : 				policy != SCHED_NORMAL && policy != SCHED_BATCH && : 
2
strstr : if : 				policy != SCHED_NORMAL && policy != SCHED_BATCH && : 
2
strstr : for : 				policy != SCHED_NORMAL && policy != SCHED_BATCH && : 
2
strstr : while : 				policy != SCHED_NORMAL && policy != SCHED_BATCH && : 
2
str : 				policy != SCHED_IDLE)[25]
strstr : INIT : 				policy != SCHED_IDLE) : 
2
strstr : if : 				policy != SCHED_IDLE) : 
2
strstr : for : 				policy != SCHED_IDLE) : 
2
strstr : while : 				policy != SCHED_IDLE) : 
2
str : 			return -EINVAL;[18]
strstr : INIT : 			return -EINVAL; : 
2
strstr : if : 			return -EINVAL; : 
2
strstr : for : 			return -EINVAL; : 
2
strstr : while : 			return -EINVAL; : 
2
str : 	if (attr->sched_flags & ~(SCHED_FLAG_RESET_ON_FORK))[53]
strstr : INIT : 	if (attr->sched_flags & ~(SCHED_FLAG_RESET_ON_FORK)) : 
2
strstr : if : 	if (attr->sched_flags & ~(SCHED_FLAG_RESET_ON_FORK)) : 
2
strstr : for : 	if (attr->sched_flags & ~(SCHED_FLAG_RESET_ON_FORK)) : 
2
strstr : while : 	if (attr->sched_flags & ~(SCHED_FLAG_RESET_ON_FORK)) : 
2
str : 		return -EINVAL;[17]
strstr : INIT : 		return -EINVAL; : 
2
strstr : if : 		return -EINVAL; : 
2
strstr : for : 		return -EINVAL; : 
2
strstr : while : 		return -EINVAL; : 
2
str : 	/*[3]
strstr : INIT : 	/* : 
2
strstr : if : 	/* : 
2
strstr : for : 	/* : 
2
strstr : while : 	/* : 
2
str : 	 * Valid priorities for SCHED_FIFO and SCHED_RR are[52]
strstr : INIT : 	 * Valid priorities for SCHED_FIFO and SCHED_RR are : 
2
strstr : if : 	 * Valid priorities for SCHED_FIFO and SCHED_RR are : 
2
strstr : for : 	 * Valid priorities for SCHED_FIFO and SCHED_RR are : 
2
strstr : while : 	 * Valid priorities for SCHED_FIFO and SCHED_RR are : 
2
str : 	 * 1..MAX_USER_RT_PRIO-1, valid priority for SCHED_NORMAL,[59]
strstr : INIT : 	 * 1..MAX_USER_RT_PRIO-1, valid priority for SCHED_NORMAL, : 
2
strstr : if : 	 * 1..MAX_USER_RT_PRIO-1, valid priority for SCHED_NORMAL, : 
2
strstr : for : 	 * 1..MAX_USER_RT_PRIO-1, valid priority for SCHED_NORMAL, : 
2
strstr : while : 	 * 1..MAX_USER_RT_PRIO-1, valid priority for SCHED_NORMAL, : 
2
str : 	 * SCHED_BATCH and SCHED_IDLE is 0.[36]
strstr : INIT : 	 * SCHED_BATCH and SCHED_IDLE is 0. : 
2
strstr : if : 	 * SCHED_BATCH and SCHED_IDLE is 0. : 
2
strstr : for : 	 * SCHED_BATCH and SCHED_IDLE is 0. : 
2
strstr : while : 	 * SCHED_BATCH and SCHED_IDLE is 0. : 
2
str : 	 */[4]
strstr : INIT : 	 */ : 
2
strstr : if : 	 */ : 
2
strstr : for : 	 */ : 
2
strstr : while : 	 */ : 
2
str : 	if ((p->mm && attr->sched_priority > MAX_USER_RT_PRIO-1) ||[60]
strstr : INIT : 	if ((p->mm && attr->sched_priority > MAX_USER_RT_PRIO-1) || : 
2
strstr : if : 	if ((p->mm && attr->sched_priority > MAX_USER_RT_PRIO-1) || : 
2
strstr : for : 	if ((p->mm && attr->sched_priority > MAX_USER_RT_PRIO-1) || : 
2
strstr : while : 	if ((p->mm && attr->sched_priority > MAX_USER_RT_PRIO-1) || : 
2
str : 	    (!p->mm && attr->sched_priority > MAX_RT_PRIO-1))[54]
strstr : INIT : 	    (!p->mm && attr->sched_priority > MAX_RT_PRIO-1)) : 
2
strstr : if : 	    (!p->mm && attr->sched_priority > MAX_RT_PRIO-1)) : 
2
strstr : for : 	    (!p->mm && attr->sched_priority > MAX_RT_PRIO-1)) : 
2
strstr : while : 	    (!p->mm && attr->sched_priority > MAX_RT_PRIO-1)) : 
2
str : 		return -EINVAL;[17]
strstr : INIT : 		return -EINVAL; : 
2
strstr : if : 		return -EINVAL; : 
2
strstr : for : 		return -EINVAL; : 
2
strstr : while : 		return -EINVAL; : 
2
str : 	if ((dl_policy(policy) && !__checkparam_dl(attr)) ||[53]
strstr : INIT : 	if ((dl_policy(policy) && !__checkparam_dl(attr)) || : 
2
strstr : if : 	if ((dl_policy(policy) && !__checkparam_dl(attr)) || : 
2
strstr : for : 	if ((dl_policy(policy) && !__checkparam_dl(attr)) || : 
2
strstr : while : 	if ((dl_policy(policy) && !__checkparam_dl(attr)) || : 
2
str : 	    (rt_policy(policy) != (attr->sched_priority != 0)))[56]
strstr : INIT : 	    (rt_policy(policy) != (attr->sched_priority != 0))) : 
2
strstr : if : 	    (rt_policy(policy) != (attr->sched_priority != 0))) : 
2
strstr : for : 	    (rt_policy(policy) != (attr->sched_priority != 0))) : 
2
strstr : while : 	    (rt_policy(policy) != (attr->sched_priority != 0))) : 
2
str : 		return -EINVAL;[17]
strstr : INIT : 		return -EINVAL; : 
2
strstr : if : 		return -EINVAL; : 
2
strstr : for : 		return -EINVAL; : 
2
strstr : while : 		return -EINVAL; : 
2
str : 	/*[3]
strstr : INIT : 	/* : 
2
strstr : if : 	/* : 
2
strstr : for : 	/* : 
2
strstr : while : 	/* : 
2
str : 	 * Allow unprivileged RT tasks to decrease priority:[53]
strstr : INIT : 	 * Allow unprivileged RT tasks to decrease priority: : 
2
strstr : if : 	 * Allow unprivileged RT tasks to decrease priority: : 
2
strstr : for : 	 * Allow unprivileged RT tasks to decrease priority: : 
2
strstr : while : 	 * Allow unprivileged RT tasks to decrease priority: : 
2
str : 	 */[4]
strstr : INIT : 	 */ : 
2
strstr : if : 	 */ : 
2
strstr : for : 	 */ : 
2
strstr : while : 	 */ : 
2
str : 	if (user && !capable(CAP_SYS_NICE)) {[38]
strstr : INIT : 	if (user && !capable(CAP_SYS_NICE)) { : 
2
strstr : if : 	if (user && !capable(CAP_SYS_NICE)) { : 
2
strstr : for : 	if (user && !capable(CAP_SYS_NICE)) { : 
2
strstr : while : 	if (user && !capable(CAP_SYS_NICE)) { : 
2
str : 		if (fair_policy(policy)) {[28]
strstr : INIT : 		if (fair_policy(policy)) { : 
2
strstr : if : 		if (fair_policy(policy)) { : 
2
strstr : for : 		if (fair_policy(policy)) { : 
2
strstr : while : 		if (fair_policy(policy)) { : 
2
str : 			if (attr->sched_nice < TASK_NICE(p) &&[41]
strstr : INIT : 			if (attr->sched_nice < TASK_NICE(p) && : 
2
strstr : if : 			if (attr->sched_nice < TASK_NICE(p) && : 
2
strstr : for : 			if (attr->sched_nice < TASK_NICE(p) && : 
2
strstr : while : 			if (attr->sched_nice < TASK_NICE(p) && : 
2
str : 			    !can_nice(p, attr->sched_nice))[38]
strstr : INIT : 			    !can_nice(p, attr->sched_nice)) : 
2
strstr : if : 			    !can_nice(p, attr->sched_nice)) : 
2
strstr : for : 			    !can_nice(p, attr->sched_nice)) : 
2
strstr : while : 			    !can_nice(p, attr->sched_nice)) : 
2
str : 				return -EPERM;[18]
strstr : INIT : 				return -EPERM; : 
2
strstr : if : 				return -EPERM; : 
2
strstr : for : 				return -EPERM; : 
2
strstr : while : 				return -EPERM; : 
2
str : 		}[3]
strstr : INIT : 		} : 
2
strstr : if : 		} : 
2
strstr : for : 		} : 
2
strstr : while : 		} : 
2
str : 		if (rt_policy(policy)) {[26]
strstr : INIT : 		if (rt_policy(policy)) { : 
2
strstr : if : 		if (rt_policy(policy)) { : 
2
strstr : for : 		if (rt_policy(policy)) { : 
2
strstr : while : 		if (rt_policy(policy)) { : 
2
str : 			unsigned long rlim_rtprio =[30]
strstr : INIT : 			unsigned long rlim_rtprio = : 
2
strstr : if : 			unsigned long rlim_rtprio = : 
2
strstr : for : 			unsigned long rlim_rtprio = : 
2
strstr : while : 			unsigned long rlim_rtprio = : 
2
str : 					task_rlimit(p, RLIMIT_RTPRIO);[35]
strstr : INIT : 					task_rlimit(p, RLIMIT_RTPRIO); : 
2
strstr : if : 					task_rlimit(p, RLIMIT_RTPRIO); : 
2
strstr : for : 					task_rlimit(p, RLIMIT_RTPRIO); : 
2
strstr : while : 					task_rlimit(p, RLIMIT_RTPRIO); : 
2
str : 			/* can't set/change the rt policy */[39]
strstr : INIT : 			/* can't set/change the rt policy */ : 
2
strstr : if : 			/* can't set/change the rt policy */ : 
2
strstr : for : 			/* can't set/change the rt policy */ : 
2
strstr : while : 			/* can't set/change the rt policy */ : 
2
str : 			if (policy != p->policy && !rlim_rtprio)[43]
strstr : INIT : 			if (policy != p->policy && !rlim_rtprio) : 
2
strstr : if : 			if (policy != p->policy && !rlim_rtprio) : 
2
strstr : for : 			if (policy != p->policy && !rlim_rtprio) : 
2
strstr : while : 			if (policy != p->policy && !rlim_rtprio) : 
2
str : 				return -EPERM;[18]
strstr : INIT : 				return -EPERM; : 
2
strstr : if : 				return -EPERM; : 
2
strstr : for : 				return -EPERM; : 
2
strstr : while : 				return -EPERM; : 
2
str : 			/* can't increase priority */[32]
strstr : INIT : 			/* can't increase priority */ : 
2
strstr : if : 			/* can't increase priority */ : 
2
strstr : for : 			/* can't increase priority */ : 
2
strstr : while : 			/* can't increase priority */ : 
2
str : 			if (attr->sched_priority > p->rt_priority &&[47]
strstr : INIT : 			if (attr->sched_priority > p->rt_priority && : 
2
strstr : if : 			if (attr->sched_priority > p->rt_priority && : 
2
strstr : for : 			if (attr->sched_priority > p->rt_priority && : 
2
strstr : while : 			if (attr->sched_priority > p->rt_priority && : 
2
str : 			    attr->sched_priority > rlim_rtprio)[42]
strstr : INIT : 			    attr->sched_priority > rlim_rtprio) : 
2
strstr : if : 			    attr->sched_priority > rlim_rtprio) : 
2
strstr : for : 			    attr->sched_priority > rlim_rtprio) : 
2
strstr : while : 			    attr->sched_priority > rlim_rtprio) : 
2
str : 				return -EPERM;[18]
strstr : INIT : 				return -EPERM; : 
2
strstr : if : 				return -EPERM; : 
2
strstr : for : 				return -EPERM; : 
2
strstr : while : 				return -EPERM; : 
2
str : 		}[3]
strstr : INIT : 		} : 
2
strstr : if : 		} : 
2
strstr : for : 		} : 
2
strstr : while : 		} : 
2
str : 		 /*[5]
strstr : INIT : 		 /* : 
2
strstr : if : 		 /* : 
2
strstr : for : 		 /* : 
2
strstr : while : 		 /* : 
2
str : 		  * Can't set/change SCHED_DEADLINE policy at all for now[59]
strstr : INIT : 		  * Can't set/change SCHED_DEADLINE policy at all for now : 
2
strstr : if : 		  * Can't set/change SCHED_DEADLINE policy at all for now : 
2
strstr : for : 		  * Can't set/change SCHED_DEADLINE policy at all for now : 
2
strstr : while : 		  * Can't set/change SCHED_DEADLINE policy at all for now : 
2
str : 		  * (safest behavior); in the future we would like to allow[61]
strstr : INIT : 		  * (safest behavior); in the future we would like to allow : 
2
strstr : if : 		  * (safest behavior); in the future we would like to allow : 
2
strstr : for : 		  * (safest behavior); in the future we would like to allow : 
2
strstr : while : 		  * (safest behavior); in the future we would like to allow : 
2
str : 		  * unprivileged DL tasks to increase their relative deadline[63]
strstr : INIT : 		  * unprivileged DL tasks to increase their relative deadline : 
2
strstr : if : 		  * unprivileged DL tasks to increase their relative deadline : 
2
strstr : for : 		  * unprivileged DL tasks to increase their relative deadline : 
2
strstr : while : 		  * unprivileged DL tasks to increase their relative deadline : 
2
str : 		  * or reduce their runtime (both ways reducing utilization)[62]
strstr : INIT : 		  * or reduce their runtime (both ways reducing utilization) : 
2
strstr : if : 		  * or reduce their runtime (both ways reducing utilization) : 
2
strstr : for : 		  * or reduce their runtime (both ways reducing utilization) : 
2
strstr : while : 		  * or reduce their runtime (both ways reducing utilization) : 
2
str : 		  */[6]
strstr : INIT : 		  */ : 
2
strstr : if : 		  */ : 
2
strstr : for : 		  */ : 
2
strstr : while : 		  */ : 
2
str : 		if (dl_policy(policy))[24]
strstr : INIT : 		if (dl_policy(policy)) : 
2
strstr : if : 		if (dl_policy(policy)) : 
2
strstr : for : 		if (dl_policy(policy)) : 
2
strstr : while : 		if (dl_policy(policy)) : 
2
str : 			return -EPERM;[17]
strstr : INIT : 			return -EPERM; : 
2
strstr : if : 			return -EPERM; : 
2
strstr : for : 			return -EPERM; : 
2
strstr : while : 			return -EPERM; : 
2
str : 		/*[4]
strstr : INIT : 		/* : 
2
strstr : if : 		/* : 
2
strstr : for : 		/* : 
2
strstr : while : 		/* : 
2
str : 		 * Treat SCHED_IDLE as nice 20. Only allow a switch to[56]
strstr : INIT : 		 * Treat SCHED_IDLE as nice 20. Only allow a switch to : 
2
strstr : if : 		 * Treat SCHED_IDLE as nice 20. Only allow a switch to : 
2
strstr : for : 		 * Treat SCHED_IDLE as nice 20. Only allow a switch to : 
2
strstr : while : 		 * Treat SCHED_IDLE as nice 20. Only allow a switch to : 
2
str : 		 * SCHED_NORMAL if the RLIMIT_NICE would normally permit it.[62]
strstr : INIT : 		 * SCHED_NORMAL if the RLIMIT_NICE would normally permit it. : 
2
strstr : if : 		 * SCHED_NORMAL if the RLIMIT_NICE would normally permit it. : 
2
strstr : for : 		 * SCHED_NORMAL if the RLIMIT_NICE would normally permit it. : 
2
strstr : while : 		 * SCHED_NORMAL if the RLIMIT_NICE would normally permit it. : 
2
str : 		 */[5]
strstr : INIT : 		 */ : 
2
strstr : if : 		 */ : 
2
strstr : for : 		 */ : 
2
strstr : while : 		 */ : 
2
str : 		if (p->policy == SCHED_IDLE && policy != SCHED_IDLE) {[56]
strstr : INIT : 		if (p->policy == SCHED_IDLE && policy != SCHED_IDLE) { : 
2
strstr : if : 		if (p->policy == SCHED_IDLE && policy != SCHED_IDLE) { : 
2
strstr : for : 		if (p->policy == SCHED_IDLE && policy != SCHED_IDLE) { : 
2
strstr : while : 		if (p->policy == SCHED_IDLE && policy != SCHED_IDLE) { : 
2
str : 			if (!can_nice(p, TASK_NICE(p)))[34]
strstr : INIT : 			if (!can_nice(p, TASK_NICE(p))) : 
2
strstr : if : 			if (!can_nice(p, TASK_NICE(p))) : 
2
strstr : for : 			if (!can_nice(p, TASK_NICE(p))) : 
2
strstr : while : 			if (!can_nice(p, TASK_NICE(p))) : 
2
str : 				return -EPERM;[18]
strstr : INIT : 				return -EPERM; : 
2
strstr : if : 				return -EPERM; : 
2
strstr : for : 				return -EPERM; : 
2
strstr : while : 				return -EPERM; : 
2
str : 		}[3]
strstr : INIT : 		} : 
2
strstr : if : 		} : 
2
strstr : for : 		} : 
2
strstr : while : 		} : 
2
str : 		/* can't change other user's priorities */[44]
strstr : INIT : 		/* can't change other user's priorities */ : 
2
strstr : if : 		/* can't change other user's priorities */ : 
2
strstr : for : 		/* can't change other user's priorities */ : 
2
strstr : while : 		/* can't change other user's priorities */ : 
2
str : 		if (!check_same_owner(p))[27]
strstr : INIT : 		if (!check_same_owner(p)) : 
2
strstr : if : 		if (!check_same_owner(p)) : 
2
strstr : for : 		if (!check_same_owner(p)) : 
2
strstr : while : 		if (!check_same_owner(p)) : 
2
str : 			return -EPERM;[17]
strstr : INIT : 			return -EPERM; : 
2
strstr : if : 			return -EPERM; : 
2
strstr : for : 			return -EPERM; : 
2
strstr : while : 			return -EPERM; : 
2
str : 		/* Normal users shall not reset the sched_reset_on_fork flag */[65]
strstr : INIT : 		/* Normal users shall not reset the sched_reset_on_fork flag */ : 
2
strstr : if : 		/* Normal users shall not reset the sched_reset_on_fork flag */ : 
2
strstr : for : 		/* Normal users shall not reset the sched_reset_on_fork flag */ : 
2
strstr : while : 		/* Normal users shall not reset the sched_reset_on_fork flag */ : 
2
str : 		if (p->sched_reset_on_fork && !reset_on_fork)[47]
strstr : INIT : 		if (p->sched_reset_on_fork && !reset_on_fork) : 
2
strstr : if : 		if (p->sched_reset_on_fork && !reset_on_fork) : 
2
strstr : for : 		if (p->sched_reset_on_fork && !reset_on_fork) : 
2
strstr : while : 		if (p->sched_reset_on_fork && !reset_on_fork) : 
2
str : 			return -EPERM;[17]
strstr : INIT : 			return -EPERM; : 
2
strstr : if : 			return -EPERM; : 
2
strstr : for : 			return -EPERM; : 
2
strstr : while : 			return -EPERM; : 
2
str : 	if (user) {[12]
strstr : INIT : 	if (user) { : 
2
strstr : if : 	if (user) { : 
2
strstr : for : 	if (user) { : 
2
strstr : while : 	if (user) { : 
2
str : 		retval = security_task_setscheduler(p);[41]
strstr : INIT : 		retval = security_task_setscheduler(p); : 
2
strstr : if : 		retval = security_task_setscheduler(p); : 
2
strstr : for : 		retval = security_task_setscheduler(p); : 
2
strstr : while : 		retval = security_task_setscheduler(p); : 
2
str : 		if (retval)[13]
strstr : INIT : 		if (retval) : 
2
strstr : if : 		if (retval) : 
2
strstr : for : 		if (retval) : 
2
strstr : while : 		if (retval) : 
2
str : 			return retval;[17]
strstr : INIT : 			return retval; : 
2
strstr : if : 			return retval; : 
2
strstr : for : 			return retval; : 
2
strstr : while : 			return retval; : 
2
str : 	/*[3]
strstr : INIT : 	/* : 
2
strstr : if : 	/* : 
2
strstr : for : 	/* : 
2
strstr : while : 	/* : 
2
str : 	 * make sure no PI-waiters arrive (or leave) while we are[58]
strstr : INIT : 	 * make sure no PI-waiters arrive (or leave) while we are : 
2
strstr : if : 	 * make sure no PI-waiters arrive (or leave) while we are : 
2
strstr : for : 	 * make sure no PI-waiters arrive (or leave) while we are : 
2
strstr : while : 	 * make sure no PI-waiters arrive (or leave) while we are : 
2
str : 	 * changing the priority of the task:[38]
strstr : INIT : 	 * changing the priority of the task: : 
2
strstr : if : 	 * changing the priority of the task: : 
2
strstr : for : 	 * changing the priority of the task: : 
2
strstr : while : 	 * changing the priority of the task: : 
2
str : 	 *[3]
strstr : INIT : 	 * : 
2
strstr : if : 	 * : 
2
strstr : for : 	 * : 
2
strstr : while : 	 * : 
2
str : 	 * To be able to change p->policy safely, the appropriate[58]
strstr : INIT : 	 * To be able to change p->policy safely, the appropriate : 
2
strstr : if : 	 * To be able to change p->policy safely, the appropriate : 
2
strstr : for : 	 * To be able to change p->policy safely, the appropriate : 
2
strstr : while : 	 * To be able to change p->policy safely, the appropriate : 
2
str : 	 * runqueue lock must be held.[31]
strstr : INIT : 	 * runqueue lock must be held. : 
2
strstr : if : 	 * runqueue lock must be held. : 
2
strstr : for : 	 * runqueue lock must be held. : 
2
strstr : while : 	 * runqueue lock must be held. : 
2
str : 	 */[4]
strstr : INIT : 	 */ : 
2
strstr : if : 	 */ : 
2
strstr : for : 	 */ : 
2
strstr : while : 	 */ : 
2
str : 	rq = task_rq_lock(p, &flags);[30]
strstr : INIT : 	rq = task_rq_lock(p, &flags); : 
2
strstr : if : 	rq = task_rq_lock(p, &flags); : 
2
strstr : for : 	rq = task_rq_lock(p, &flags); : 
2
strstr : while : 	rq = task_rq_lock(p, &flags); : 
2
str : 	/*[3]
strstr : INIT : 	/* : 
2
strstr : if : 	/* : 
2
strstr : for : 	/* : 
2
strstr : while : 	/* : 
2
str : 	 * Changing the policy of the stop threads its a very bad idea[63]
strstr : INIT : 	 * Changing the policy of the stop threads its a very bad idea : 
2
strstr : if : 	 * Changing the policy of the stop threads its a very bad idea : 
2
strstr : for : 	 * Changing the policy of the stop threads its a very bad idea : 
2
strstr : while : 	 * Changing the policy of the stop threads its a very bad idea : 
2
str : 	 */[4]
strstr : INIT : 	 */ : 
2
strstr : if : 	 */ : 
2
strstr : for : 	 */ : 
2
strstr : while : 	 */ : 
2
str : 	if (p == rq->stop) {[21]
strstr : INIT : 	if (p == rq->stop) { : 
2
strstr : if : 	if (p == rq->stop) { : 
2
strstr : for : 	if (p == rq->stop) { : 
2
strstr : while : 	if (p == rq->stop) { : 
2
str : 		task_rq_unlock(rq, p, &flags);[32]
strstr : INIT : 		task_rq_unlock(rq, p, &flags); : 
2
strstr : if : 		task_rq_unlock(rq, p, &flags); : 
2
strstr : for : 		task_rq_unlock(rq, p, &flags); : 
2
strstr : while : 		task_rq_unlock(rq, p, &flags); : 
2
str : 		return -EINVAL;[17]
strstr : INIT : 		return -EINVAL; : 
2
strstr : if : 		return -EINVAL; : 
2
strstr : for : 		return -EINVAL; : 
2
strstr : while : 		return -EINVAL; : 
2
str : 	/*[3]
strstr : INIT : 	/* : 
2
strstr : if : 	/* : 
2
strstr : for : 	/* : 
2
strstr : while : 	/* : 
2
str : 	 * If not changing anything there's no need to proceed further:[64]
strstr : INIT : 	 * If not changing anything there's no need to proceed further: : 
2
strstr : if : 	 * If not changing anything there's no need to proceed further: : 
2
strstr : for : 	 * If not changing anything there's no need to proceed further: : 
2
strstr : while : 	 * If not changing anything there's no need to proceed further: : 
2
str : 	 */[4]
strstr : INIT : 	 */ : 
2
strstr : if : 	 */ : 
2
strstr : for : 	 */ : 
2
strstr : while : 	 */ : 
2
str : 	if (unlikely(policy == p->policy)) {[37]
strstr : INIT : 	if (unlikely(policy == p->policy)) { : 
2
strstr : if : 	if (unlikely(policy == p->policy)) { : 
2
strstr : for : 	if (unlikely(policy == p->policy)) { : 
2
strstr : while : 	if (unlikely(policy == p->policy)) { : 
2
str : 		if (fair_policy(policy) && attr->sched_nice != TASK_NICE(p))[62]
strstr : INIT : 		if (fair_policy(policy) && attr->sched_nice != TASK_NICE(p)) : 
2
strstr : if : 		if (fair_policy(policy) && attr->sched_nice != TASK_NICE(p)) : 
2
strstr : for : 		if (fair_policy(policy) && attr->sched_nice != TASK_NICE(p)) : 
2
strstr : while : 		if (fair_policy(policy) && attr->sched_nice != TASK_NICE(p)) : 
2
str : 			goto change;[15]
strstr : INIT : 			goto change; : 
2
strstr : if : 			goto change; : 
2
strstr : for : 			goto change; : 
2
strstr : while : 			goto change; : 
2
str : 		if (rt_policy(policy) && attr->sched_priority != p->rt_priority)[66]
strstr : INIT : 		if (rt_policy(policy) && attr->sched_priority != p->rt_priority) : 
2
strstr : if : 		if (rt_policy(policy) && attr->sched_priority != p->rt_priority) : 
2
strstr : for : 		if (rt_policy(policy) && attr->sched_priority != p->rt_priority) : 
2
strstr : while : 		if (rt_policy(policy) && attr->sched_priority != p->rt_priority) : 
2
str : 			goto change;[15]
strstr : INIT : 			goto change; : 
2
strstr : if : 			goto change; : 
2
strstr : for : 			goto change; : 
2
strstr : while : 			goto change; : 
2
str : 		if (dl_policy(policy))[24]
strstr : INIT : 		if (dl_policy(policy)) : 
2
strstr : if : 		if (dl_policy(policy)) : 
2
strstr : for : 		if (dl_policy(policy)) : 
2
strstr : while : 		if (dl_policy(policy)) : 
2
str : 			goto change;[15]
strstr : INIT : 			goto change; : 
2
strstr : if : 			goto change; : 
2
strstr : for : 			goto change; : 
2
strstr : while : 			goto change; : 
2
str : 		task_rq_unlock(rq, p, &flags);[32]
strstr : INIT : 		task_rq_unlock(rq, p, &flags); : 
2
strstr : if : 		task_rq_unlock(rq, p, &flags); : 
2
strstr : for : 		task_rq_unlock(rq, p, &flags); : 
2
strstr : while : 		task_rq_unlock(rq, p, &flags); : 
2
str : 		return 0;[11]
strstr : INIT : 		return 0; : 
2
strstr : if : 		return 0; : 
2
strstr : for : 		return 0; : 
2
strstr : while : 		return 0; : 
2
str : change:[7]
strstr : INIT : change: : 
2
strstr : if : change: : 
2
strstr : for : change: : 
2
strstr : while : change: : 
2
str : 	if (user) {[12]
strstr : INIT : 	if (user) { : 
2
strstr : if : 	if (user) { : 
2
strstr : for : 	if (user) { : 
2
strstr : while : 	if (user) { : 
2
str : #ifdef CONFIG_RT_GROUP_SCHED[28]
strstr : INIT : #ifdef CONFIG_RT_GROUP_SCHED : 
2
strstr : if : #ifdef CONFIG_RT_GROUP_SCHED : 
2
strstr : for : #ifdef CONFIG_RT_GROUP_SCHED : 
2
strstr : while : #ifdef CONFIG_RT_GROUP_SCHED : 
2
str : 		/*[4]
strstr : INIT : 		/* : 
2
strstr : if : 		/* : 
2
strstr : for : 		/* : 
2
strstr : while : 		/* : 
2
str : 		 * Do not allow realtime tasks into groups that have no runtime[65]
strstr : INIT : 		 * Do not allow realtime tasks into groups that have no runtime : 
2
strstr : if : 		 * Do not allow realtime tasks into groups that have no runtime : 
2
strstr : for : 		 * Do not allow realtime tasks into groups that have no runtime : 
2
strstr : while : 		 * Do not allow realtime tasks into groups that have no runtime : 
2
str : 		 * assigned.[14]
strstr : INIT : 		 * assigned. : 
2
strstr : if : 		 * assigned. : 
2
strstr : for : 		 * assigned. : 
2
strstr : while : 		 * assigned. : 
2
str : 		 */[5]
strstr : INIT : 		 */ : 
2
strstr : if : 		 */ : 
2
strstr : for : 		 */ : 
2
strstr : while : 		 */ : 
2
str : 		if (rt_bandwidth_enabled() && rt_policy(policy) &&[52]
strstr : INIT : 		if (rt_bandwidth_enabled() && rt_policy(policy) && : 
2
strstr : if : 		if (rt_bandwidth_enabled() && rt_policy(policy) && : 
2
strstr : for : 		if (rt_bandwidth_enabled() && rt_policy(policy) && : 
2
strstr : while : 		if (rt_bandwidth_enabled() && rt_policy(policy) && : 
2
str : 				task_group(p)->rt_bandwidth.rt_runtime == 0 &&[50]
strstr : INIT : 				task_group(p)->rt_bandwidth.rt_runtime == 0 && : 
2
strstr : if : 				task_group(p)->rt_bandwidth.rt_runtime == 0 && : 
2
strstr : for : 				task_group(p)->rt_bandwidth.rt_runtime == 0 && : 
2
strstr : while : 				task_group(p)->rt_bandwidth.rt_runtime == 0 && : 
2
str : 				!task_group_is_autogroup(task_group(p))) {[46]
strstr : INIT : 				!task_group_is_autogroup(task_group(p))) { : 
2
strstr : if : 				!task_group_is_autogroup(task_group(p))) { : 
2
strstr : for : 				!task_group_is_autogroup(task_group(p))) { : 
2
strstr : while : 				!task_group_is_autogroup(task_group(p))) { : 
2
str : 			task_rq_unlock(rq, p, &flags);[33]
strstr : INIT : 			task_rq_unlock(rq, p, &flags); : 
2
strstr : if : 			task_rq_unlock(rq, p, &flags); : 
2
strstr : for : 			task_rq_unlock(rq, p, &flags); : 
2
strstr : while : 			task_rq_unlock(rq, p, &flags); : 
2
str : 			return -EPERM;[17]
strstr : INIT : 			return -EPERM; : 
2
strstr : if : 			return -EPERM; : 
2
strstr : for : 			return -EPERM; : 
2
strstr : while : 			return -EPERM; : 
2
str : 		}[3]
strstr : INIT : 		} : 
2
strstr : if : 		} : 
2
strstr : for : 		} : 
2
strstr : while : 		} : 
2
str : #endif[6]
strstr : INIT : #endif : 
2
strstr : if : #endif : 
2
strstr : for : #endif : 
2
strstr : while : #endif : 
2
str : #ifdef CONFIG_SMP[17]
strstr : INIT : #ifdef CONFIG_SMP : 
2
strstr : if : #ifdef CONFIG_SMP : 
2
strstr : for : #ifdef CONFIG_SMP : 
2
strstr : while : #ifdef CONFIG_SMP : 
2
str : 		if (dl_bandwidth_enabled() && dl_policy(policy)) {[52]
strstr : INIT : 		if (dl_bandwidth_enabled() && dl_policy(policy)) { : 
2
strstr : if : 		if (dl_bandwidth_enabled() && dl_policy(policy)) { : 
2
strstr : for : 		if (dl_bandwidth_enabled() && dl_policy(policy)) { : 
2
strstr : while : 		if (dl_bandwidth_enabled() && dl_policy(policy)) { : 
2
str : 			cpumask_t *span = rq->rd->span;[34]
strstr : INIT : 			cpumask_t *span = rq->rd->span; : 
2
strstr : if : 			cpumask_t *span = rq->rd->span; : 
2
strstr : for : 			cpumask_t *span = rq->rd->span; : 
2
strstr : while : 			cpumask_t *span = rq->rd->span; : 
2
str : 			/*[5]
strstr : INIT : 			/* : 
2
strstr : if : 			/* : 
2
strstr : for : 			/* : 
2
strstr : while : 			/* : 
2
str : 			 * Don't allow tasks with an affinity mask smaller than[58]
strstr : INIT : 			 * Don't allow tasks with an affinity mask smaller than : 
2
strstr : if : 			 * Don't allow tasks with an affinity mask smaller than : 
2
strstr : for : 			 * Don't allow tasks with an affinity mask smaller than : 
2
strstr : while : 			 * Don't allow tasks with an affinity mask smaller than : 
2
str : 			 * the entire root_domain to become SCHED_DEADLINE. We[57]
strstr : INIT : 			 * the entire root_domain to become SCHED_DEADLINE. We : 
2
strstr : if : 			 * the entire root_domain to become SCHED_DEADLINE. We : 
2
strstr : for : 			 * the entire root_domain to become SCHED_DEADLINE. We : 
2
strstr : while : 			 * the entire root_domain to become SCHED_DEADLINE. We : 
2
str : 			 * will also fail if there's no bandwidth available.[55]
strstr : INIT : 			 * will also fail if there's no bandwidth available. : 
2
strstr : if : 			 * will also fail if there's no bandwidth available. : 
2
strstr : for : 			 * will also fail if there's no bandwidth available. : 
2
strstr : while : 			 * will also fail if there's no bandwidth available. : 
2
str : 			 */[6]
strstr : INIT : 			 */ : 
2
strstr : if : 			 */ : 
2
strstr : for : 			 */ : 
2
strstr : while : 			 */ : 
2
str : 			if (!cpumask_subset(span, &p->cpus_allowed) ||[49]
strstr : INIT : 			if (!cpumask_subset(span, &p->cpus_allowed) || : 
2
strstr : if : 			if (!cpumask_subset(span, &p->cpus_allowed) || : 
2
strstr : for : 			if (!cpumask_subset(span, &p->cpus_allowed) || : 
2
strstr : while : 			if (!cpumask_subset(span, &p->cpus_allowed) || : 
2
str : 			    rq->rd->dl_bw.bw == 0) {[31]
strstr : INIT : 			    rq->rd->dl_bw.bw == 0) { : 
2
strstr : if : 			    rq->rd->dl_bw.bw == 0) { : 
2
strstr : for : 			    rq->rd->dl_bw.bw == 0) { : 
2
strstr : while : 			    rq->rd->dl_bw.bw == 0) { : 
2
str : 				task_rq_unlock(rq, p, &flags);[34]
strstr : INIT : 				task_rq_unlock(rq, p, &flags); : 
2
strstr : if : 				task_rq_unlock(rq, p, &flags); : 
2
strstr : for : 				task_rq_unlock(rq, p, &flags); : 
2
strstr : while : 				task_rq_unlock(rq, p, &flags); : 
2
str : 				return -EPERM;[18]
strstr : INIT : 				return -EPERM; : 
2
strstr : if : 				return -EPERM; : 
2
strstr : for : 				return -EPERM; : 
2
strstr : while : 				return -EPERM; : 
2
str : 			}[4]
strstr : INIT : 			} : 
2
strstr : if : 			} : 
2
strstr : for : 			} : 
2
strstr : while : 			} : 
2
str : 		}[3]
strstr : INIT : 		} : 
2
strstr : if : 		} : 
2
strstr : for : 		} : 
2
strstr : while : 		} : 
2
str : #endif[6]
strstr : INIT : #endif : 
2
strstr : if : #endif : 
2
strstr : for : #endif : 
2
strstr : while : #endif : 
2
str : 	/* recheck policy now with rq lock held */[43]
strstr : INIT : 	/* recheck policy now with rq lock held */ : 
2
strstr : if : 	/* recheck policy now with rq lock held */ : 
2
strstr : for : 	/* recheck policy now with rq lock held */ : 
2
strstr : while : 	/* recheck policy now with rq lock held */ : 
2
str : 	if (unlikely(oldpolicy != -1 && oldpolicy != p->policy)) {[59]
strstr : INIT : 	if (unlikely(oldpolicy != -1 && oldpolicy != p->policy)) { : 
2
strstr : if : 	if (unlikely(oldpolicy != -1 && oldpolicy != p->policy)) { : 
2
strstr : for : 	if (unlikely(oldpolicy != -1 && oldpolicy != p->policy)) { : 
2
strstr : while : 	if (unlikely(oldpolicy != -1 && oldpolicy != p->policy)) { : 
2
str : 		policy = oldpolicy = -1;[26]
strstr : INIT : 		policy = oldpolicy = -1; : 
2
strstr : if : 		policy = oldpolicy = -1; : 
2
strstr : for : 		policy = oldpolicy = -1; : 
2
strstr : while : 		policy = oldpolicy = -1; : 
2
str : 		task_rq_unlock(rq, p, &flags);[32]
strstr : INIT : 		task_rq_unlock(rq, p, &flags); : 
2
strstr : if : 		task_rq_unlock(rq, p, &flags); : 
2
strstr : for : 		task_rq_unlock(rq, p, &flags); : 
2
strstr : while : 		task_rq_unlock(rq, p, &flags); : 
2
str : 		goto recheck;[15]
strstr : INIT : 		goto recheck; : 
2
strstr : if : 		goto recheck; : 
2
strstr : for : 		goto recheck; : 
2
strstr : while : 		goto recheck; : 
2
str : 	/*[3]
strstr : INIT : 	/* : 
2
strstr : if : 	/* : 
2
strstr : for : 	/* : 
2
strstr : while : 	/* : 
2
str : 	 * If setscheduling to SCHED_DEADLINE (or changing the parameters[66]
strstr : INIT : 	 * If setscheduling to SCHED_DEADLINE (or changing the parameters : 
2
strstr : if : 	 * If setscheduling to SCHED_DEADLINE (or changing the parameters : 
2
strstr : for : 	 * If setscheduling to SCHED_DEADLINE (or changing the parameters : 
2
strstr : while : 	 * If setscheduling to SCHED_DEADLINE (or changing the parameters : 
2
str : 	 * of a SCHED_DEADLINE task) we need to check if enough bandwidth[66]
strstr : INIT : 	 * of a SCHED_DEADLINE task) we need to check if enough bandwidth : 
2
strstr : if : 	 * of a SCHED_DEADLINE task) we need to check if enough bandwidth : 
2
strstr : for : 	 * of a SCHED_DEADLINE task) we need to check if enough bandwidth : 
2
strstr : while : 	 * of a SCHED_DEADLINE task) we need to check if enough bandwidth : 
2
str : 	 * is available.[17]
strstr : INIT : 	 * is available. : 
2
strstr : if : 	 * is available. : 
2
strstr : for : 	 * is available. : 
2
strstr : while : 	 * is available. : 
2
str : 	 */[4]
strstr : INIT : 	 */ : 
2
strstr : if : 	 */ : 
2
strstr : for : 	 */ : 
2
strstr : while : 	 */ : 
2
str : 	if ((dl_policy(policy) || dl_task(p)) && dl_overflow(p, policy, attr)) {[73]
strstr : INIT : 	if ((dl_policy(policy) || dl_task(p)) && dl_overflow(p, policy, attr)) { : 
2
strstr : if : 	if ((dl_policy(policy) || dl_task(p)) && dl_overflow(p, policy, attr)) { : 
2
strstr : for : 	if ((dl_policy(policy) || dl_task(p)) && dl_overflow(p, policy, attr)) { : 
2
strstr : while : 	if ((dl_policy(policy) || dl_task(p)) && dl_overflow(p, policy, attr)) { : 
2
str : 		task_rq_unlock(rq, p, &flags);[32]
strstr : INIT : 		task_rq_unlock(rq, p, &flags); : 
2
strstr : if : 		task_rq_unlock(rq, p, &flags); : 
2
strstr : for : 		task_rq_unlock(rq, p, &flags); : 
2
strstr : while : 		task_rq_unlock(rq, p, &flags); : 
2
str : 		return -EBUSY;[16]
strstr : INIT : 		return -EBUSY; : 
2
strstr : if : 		return -EBUSY; : 
2
strstr : for : 		return -EBUSY; : 
2
strstr : while : 		return -EBUSY; : 
2
str : 	on_rq = p->on_rq;[18]
strstr : INIT : 	on_rq = p->on_rq; : 
2
strstr : if : 	on_rq = p->on_rq; : 
2
strstr : for : 	on_rq = p->on_rq; : 
2
strstr : while : 	on_rq = p->on_rq; : 
2
str : 	running = task_current(rq, p);[31]
strstr : INIT : 	running = task_current(rq, p); : 
2
strstr : if : 	running = task_current(rq, p); : 
2
strstr : for : 	running = task_current(rq, p); : 
2
strstr : while : 	running = task_current(rq, p); : 
2
str : 	if (on_rq)[11]
strstr : INIT : 	if (on_rq) : 
2
strstr : if : 	if (on_rq) : 
2
strstr : for : 	if (on_rq) : 
2
strstr : while : 	if (on_rq) : 
2
str : 		dequeue_task(rq, p, 0);[25]
strstr : INIT : 		dequeue_task(rq, p, 0); : 
2
strstr : if : 		dequeue_task(rq, p, 0); : 
2
strstr : for : 		dequeue_task(rq, p, 0); : 
2
strstr : while : 		dequeue_task(rq, p, 0); : 
2
str : 	if (running)[13]
strstr : INIT : 	if (running) : 
2
strstr : if : 	if (running) : 
2
strstr : for : 	if (running) : 
2
strstr : while : 	if (running) : 
2
str : 		p->sched_class->put_prev_task(rq, p);[39]
strstr : INIT : 		p->sched_class->put_prev_task(rq, p); : 
2
strstr : if : 		p->sched_class->put_prev_task(rq, p); : 
2
strstr : for : 		p->sched_class->put_prev_task(rq, p); : 
2
strstr : while : 		p->sched_class->put_prev_task(rq, p); : 
2
str : 	p->sched_reset_on_fork = reset_on_fork;[40]
strstr : INIT : 	p->sched_reset_on_fork = reset_on_fork; : 
2
strstr : if : 	p->sched_reset_on_fork = reset_on_fork; : 
2
strstr : for : 	p->sched_reset_on_fork = reset_on_fork; : 
2
strstr : while : 	p->sched_reset_on_fork = reset_on_fork; : 
2
str : 	oldprio = p->prio;[19]
strstr : INIT : 	oldprio = p->prio; : 
2
strstr : if : 	oldprio = p->prio; : 
2
strstr : for : 	oldprio = p->prio; : 
2
strstr : while : 	oldprio = p->prio; : 
2
str : 	prev_class = p->sched_class;[29]
strstr : INIT : 	prev_class = p->sched_class; : 
2
strstr : if : 	prev_class = p->sched_class; : 
2
strstr : for : 	prev_class = p->sched_class; : 
2
strstr : while : 	prev_class = p->sched_class; : 
2
str : 	__setscheduler(rq, p, attr);[29]
strstr : INIT : 	__setscheduler(rq, p, attr); : 
2
strstr : if : 	__setscheduler(rq, p, attr); : 
2
strstr : for : 	__setscheduler(rq, p, attr); : 
2
strstr : while : 	__setscheduler(rq, p, attr); : 
2
str : 	if (running)[13]
strstr : INIT : 	if (running) : 
2
strstr : if : 	if (running) : 
2
strstr : for : 	if (running) : 
2
strstr : while : 	if (running) : 
2
str : 		p->sched_class->set_curr_task(rq);[36]
strstr : INIT : 		p->sched_class->set_curr_task(rq); : 
2
strstr : if : 		p->sched_class->set_curr_task(rq); : 
2
strstr : for : 		p->sched_class->set_curr_task(rq); : 
2
strstr : while : 		p->sched_class->set_curr_task(rq); : 
2
str : 	if (on_rq)[11]
strstr : INIT : 	if (on_rq) : 
2
strstr : if : 	if (on_rq) : 
2
strstr : for : 	if (on_rq) : 
2
strstr : while : 	if (on_rq) : 
2
str : 		enqueue_task(rq, p, 0);[25]
strstr : INIT : 		enqueue_task(rq, p, 0); : 
2
strstr : if : 		enqueue_task(rq, p, 0); : 
2
strstr : for : 		enqueue_task(rq, p, 0); : 
2
strstr : while : 		enqueue_task(rq, p, 0); : 
2
str : 	check_class_changed(rq, p, prev_class, oldprio);[49]
strstr : INIT : 	check_class_changed(rq, p, prev_class, oldprio); : 
2
strstr : if : 	check_class_changed(rq, p, prev_class, oldprio); : 
2
strstr : for : 	check_class_changed(rq, p, prev_class, oldprio); : 
2
strstr : while : 	check_class_changed(rq, p, prev_class, oldprio); : 
2
str : 	task_rq_unlock(rq, p, &flags);[31]
strstr : INIT : 	task_rq_unlock(rq, p, &flags); : 
2
strstr : if : 	task_rq_unlock(rq, p, &flags); : 
2
strstr : for : 	task_rq_unlock(rq, p, &flags); : 
2
strstr : while : 	task_rq_unlock(rq, p, &flags); : 
2
str : 	rt_mutex_adjust_pi(p);[23]
strstr : INIT : 	rt_mutex_adjust_pi(p); : 
2
strstr : if : 	rt_mutex_adjust_pi(p); : 
2
strstr : for : 	rt_mutex_adjust_pi(p); : 
2
strstr : while : 	rt_mutex_adjust_pi(p); : 
2
str : 	return 0;[10]
strstr : INIT : 	return 0; : 
2
strstr : if : 	return 0; : 
2
strstr : for : 	return 0; : 
2
strstr : while : 	return 0; : 
2
str : static int _sched_setscheduler(struct task_struct *p, int policy,[65]
strstr : INIT : static int _sched_setscheduler(struct task_struct *p, int policy, : 
2
strstr : if : static int _sched_setscheduler(struct task_struct *p, int policy, : 
2
strstr : for : static int _sched_setscheduler(struct task_struct *p, int policy, : 
2
strstr : while : static int _sched_setscheduler(struct task_struct *p, int policy, : 
2
str : 			       const struct sched_param *param, bool check)[54]
strstr : INIT : 			       const struct sched_param *param, bool check) : 
2
strstr : if : 			       const struct sched_param *param, bool check) : 
2
strstr : for : 			       const struct sched_param *param, bool check) : 
2
strstr : while : 			       const struct sched_param *param, bool check) : 
2
str : 	struct sched_attr attr = {[27]
strstr : INIT : 	struct sched_attr attr = { : 
2
strstr : if : 	struct sched_attr attr = { : 
2
strstr : for : 	struct sched_attr attr = { : 
2
strstr : while : 	struct sched_attr attr = { : 
2
str : 		.sched_policy   = policy,[27]
strstr : INIT : 		.sched_policy   = policy, : 
2
strstr : if : 		.sched_policy   = policy, : 
2
strstr : for : 		.sched_policy   = policy, : 
2
strstr : while : 		.sched_policy   = policy, : 
2
str : 		.sched_priority = param->sched_priority,[42]
strstr : INIT : 		.sched_priority = param->sched_priority, : 
2
strstr : if : 		.sched_priority = param->sched_priority, : 
2
strstr : for : 		.sched_priority = param->sched_priority, : 
2
strstr : while : 		.sched_priority = param->sched_priority, : 
2
str : 		.sched_nice	= PRIO_TO_NICE(p->static_prio),[45]
strstr : INIT : 		.sched_nice	= PRIO_TO_NICE(p->static_prio), : 
2
strstr : if : 		.sched_nice	= PRIO_TO_NICE(p->static_prio), : 
2
strstr : for : 		.sched_nice	= PRIO_TO_NICE(p->static_prio), : 
2
strstr : while : 		.sched_nice	= PRIO_TO_NICE(p->static_prio), : 
2
str : 	};[3]
strstr : INIT : 	}; : 
2
strstr : if : 	}; : 
2
strstr : for : 	}; : 
2
strstr : while : 	}; : 
2
str : 	/*[3]
strstr : INIT : 	/* : 
2
strstr : if : 	/* : 
2
strstr : for : 	/* : 
2
strstr : while : 	/* : 
2
str : 	 * Fixup the legacy SCHED_RESET_ON_FORK hack[45]
strstr : INIT : 	 * Fixup the legacy SCHED_RESET_ON_FORK hack : 
2
strstr : if : 	 * Fixup the legacy SCHED_RESET_ON_FORK hack : 
2
strstr : for : 	 * Fixup the legacy SCHED_RESET_ON_FORK hack : 
2
strstr : while : 	 * Fixup the legacy SCHED_RESET_ON_FORK hack : 
2
str : 	 */[4]
strstr : INIT : 	 */ : 
2
strstr : if : 	 */ : 
2
strstr : for : 	 */ : 
2
strstr : while : 	 */ : 
2
str : 	if (policy & SCHED_RESET_ON_FORK) {[36]
strstr : INIT : 	if (policy & SCHED_RESET_ON_FORK) { : 
2
strstr : if : 	if (policy & SCHED_RESET_ON_FORK) { : 
2
strstr : for : 	if (policy & SCHED_RESET_ON_FORK) { : 
2
strstr : while : 	if (policy & SCHED_RESET_ON_FORK) { : 
2
str : 		attr.sched_flags |= SCHED_FLAG_RESET_ON_FORK;[47]
strstr : INIT : 		attr.sched_flags |= SCHED_FLAG_RESET_ON_FORK; : 
2
strstr : if : 		attr.sched_flags |= SCHED_FLAG_RESET_ON_FORK; : 
2
strstr : for : 		attr.sched_flags |= SCHED_FLAG_RESET_ON_FORK; : 
2
strstr : while : 		attr.sched_flags |= SCHED_FLAG_RESET_ON_FORK; : 
2
str : 		policy &= ~SCHED_RESET_ON_FORK;[33]
strstr : INIT : 		policy &= ~SCHED_RESET_ON_FORK; : 
2
strstr : if : 		policy &= ~SCHED_RESET_ON_FORK; : 
2
strstr : for : 		policy &= ~SCHED_RESET_ON_FORK; : 
2
strstr : while : 		policy &= ~SCHED_RESET_ON_FORK; : 
2
str : 		attr.sched_policy = policy;[29]
strstr : INIT : 		attr.sched_policy = policy; : 
2
strstr : if : 		attr.sched_policy = policy; : 
2
strstr : for : 		attr.sched_policy = policy; : 
2
strstr : while : 		attr.sched_policy = policy; : 
2
str : 	return __sched_setscheduler(p, &attr, check);[46]
strstr : INIT : 	return __sched_setscheduler(p, &attr, check); : 
2
strstr : if : 	return __sched_setscheduler(p, &attr, check); : 
2
strstr : for : 	return __sched_setscheduler(p, &attr, check); : 
2
strstr : while : 	return __sched_setscheduler(p, &attr, check); : 
2
str : /**[3]
strstr : INIT : /** : 
2
strstr : if : /** : 
2
strstr : for : /** : 
2
strstr : while : /** : 
2
str :  * sched_setscheduler - change the scheduling policy and/or RT priority of a thread.[84]
strstr : INIT :  * sched_setscheduler - change the scheduling policy and/or RT priority of a thread. : 
2
strstr : if :  * sched_setscheduler - change the scheduling policy and/or RT priority of a thread. : 
2
strstr : for :  * sched_setscheduler - change the scheduling policy and/or RT priority of a thread. : 
2
strstr : while :  * sched_setscheduler - change the scheduling policy and/or RT priority of a thread. : 
2
str :  * @p: the task in question.[28]
strstr : INIT :  * @p: the task in question. : 
2
strstr : if :  * @p: the task in question. : 
2
strstr : for :  * @p: the task in question. : 
2
strstr : while :  * @p: the task in question. : 
2
str :  * @policy: new policy.[23]
strstr : INIT :  * @policy: new policy. : 
2
strstr : if :  * @policy: new policy. : 
2
strstr : for :  * @policy: new policy. : 
2
strstr : while :  * @policy: new policy. : 
2
str :  * @param: structure containing the new RT priority.[52]
strstr : INIT :  * @param: structure containing the new RT priority. : 
2
strstr : if :  * @param: structure containing the new RT priority. : 
2
strstr : for :  * @param: structure containing the new RT priority. : 
2
strstr : while :  * @param: structure containing the new RT priority. : 
2
str :  * Return: 0 on success. An error code otherwise.[49]
strstr : INIT :  * Return: 0 on success. An error code otherwise. : 
2
strstr : if :  * Return: 0 on success. An error code otherwise. : 
2
strstr : for :  * Return: 0 on success. An error code otherwise. : 
2
strstr : while :  * Return: 0 on success. An error code otherwise. : 
2
str :  * NOTE that the task may be already dead.[42]
strstr : INIT :  * NOTE that the task may be already dead. : 
2
strstr : if :  * NOTE that the task may be already dead. : 
2
strstr : for :  * NOTE that the task may be already dead. : 
2
strstr : while :  * NOTE that the task may be already dead. : 
2
str :  */[3]
strstr : INIT :  */ : 
2
strstr : if :  */ : 
2
strstr : for :  */ : 
2
strstr : while :  */ : 
2
str : int sched_setscheduler(struct task_struct *p, int policy,[57]
strstr : INIT : int sched_setscheduler(struct task_struct *p, int policy, : 
2
strstr : if : int sched_setscheduler(struct task_struct *p, int policy, : 
2
strstr : for : int sched_setscheduler(struct task_struct *p, int policy, : 
2
strstr : while : int sched_setscheduler(struct task_struct *p, int policy, : 
2
str : 		       const struct sched_param *param)[41]
strstr : INIT : 		       const struct sched_param *param) : 
2
strstr : if : 		       const struct sched_param *param) : 
2
strstr : for : 		       const struct sched_param *param) : 
2
strstr : while : 		       const struct sched_param *param) : 
2
str : 	return _sched_setscheduler(p, policy, param, true);[52]
strstr : INIT : 	return _sched_setscheduler(p, policy, param, true); : 
2
strstr : if : 	return _sched_setscheduler(p, policy, param, true); : 
2
strstr : for : 	return _sched_setscheduler(p, policy, param, true); : 
2
strstr : while : 	return _sched_setscheduler(p, policy, param, true); : 
2
str : EXPORT_SYMBOL_GPL(sched_setscheduler);[38]
strstr : INIT : EXPORT_SYMBOL_GPL(sched_setscheduler); : 
2
strstr : if : EXPORT_SYMBOL_GPL(sched_setscheduler); : 
2
strstr : for : EXPORT_SYMBOL_GPL(sched_setscheduler); : 
2
strstr : while : EXPORT_SYMBOL_GPL(sched_setscheduler); : 
2
str : int sched_setattr(struct task_struct *p, const struct sched_attr *attr)[71]
strstr : INIT : int sched_setattr(struct task_struct *p, const struct sched_attr *attr) : 
2
strstr : if : int sched_setattr(struct task_struct *p, const struct sched_attr *attr) : 
2
strstr : for : int sched_setattr(struct task_struct *p, const struct sched_attr *attr) : 
2
strstr : while : int sched_setattr(struct task_struct *p, const struct sched_attr *attr) : 
2
str : 	return __sched_setscheduler(p, attr, true);[44]
strstr : INIT : 	return __sched_setscheduler(p, attr, true); : 
2
strstr : if : 	return __sched_setscheduler(p, attr, true); : 
2
strstr : for : 	return __sched_setscheduler(p, attr, true); : 
2
strstr : while : 	return __sched_setscheduler(p, attr, true); : 
2
str : EXPORT_SYMBOL_GPL(sched_setattr);[33]
strstr : INIT : EXPORT_SYMBOL_GPL(sched_setattr); : 
2
strstr : if : EXPORT_SYMBOL_GPL(sched_setattr); : 
2
strstr : for : EXPORT_SYMBOL_GPL(sched_setattr); : 
2
strstr : while : EXPORT_SYMBOL_GPL(sched_setattr); : 
2
str : /**[3]
strstr : INIT : /** : 
2
strstr : if : /** : 
2
strstr : for : /** : 
2
strstr : while : /** : 
2
str :  * sched_setscheduler_nocheck - change the scheduling policy and/or RT priority of a thread from kernelspace.[109]
strstr : INIT :  * sched_setscheduler_nocheck - change the scheduling policy and/or RT priority of a thread from kernelspace. : 
2
strstr : if :  * sched_setscheduler_nocheck - change the scheduling policy and/or RT priority of a thread from kernelspace. : 
2
strstr : for :  * sched_setscheduler_nocheck - change the scheduling policy and/or RT priority of a thread from kernelspace. : 
2
strstr : while :  * sched_setscheduler_nocheck - change the scheduling policy and/or RT priority of a thread from kernelspace. : 
2
str :  * @p: the task in question.[28]
strstr : INIT :  * @p: the task in question. : 
2
strstr : if :  * @p: the task in question. : 
2
strstr : for :  * @p: the task in question. : 
2
strstr : while :  * @p: the task in question. : 
2
str :  * @policy: new policy.[23]
strstr : INIT :  * @policy: new policy. : 
2
strstr : if :  * @policy: new policy. : 
2
strstr : for :  * @policy: new policy. : 
2
strstr : while :  * @policy: new policy. : 
2
str :  * @param: structure containing the new RT priority.[52]
strstr : INIT :  * @param: structure containing the new RT priority. : 
2
strstr : if :  * @param: structure containing the new RT priority. : 
2
strstr : for :  * @param: structure containing the new RT priority. : 
2
strstr : while :  * @param: structure containing the new RT priority. : 
2
str :  * Just like sched_setscheduler, only don't bother checking if the[66]
strstr : INIT :  * Just like sched_setscheduler, only don't bother checking if the : 
2
strstr : if :  * Just like sched_setscheduler, only don't bother checking if the : 
2
strstr : for :  * Just like sched_setscheduler, only don't bother checking if the : 
2
strstr : while :  * Just like sched_setscheduler, only don't bother checking if the : 
2
str :  * current context has permission.  For example, this is needed in[66]
strstr : INIT :  * current context has permission.  For example, this is needed in : 
2
strstr : if :  * current context has permission.  For example, this is needed in : 
2
strstr : for :  * current context has permission.  For example, this is needed in : 
2
strstr : while :  * current context has permission.  For example, this is needed in : 
2
str :  * stop_machine(): we create temporary high priority worker threads,[68]
strstr : INIT :  * stop_machine(): we create temporary high priority worker threads, : 
2
strstr : if :  * stop_machine(): we create temporary high priority worker threads, : 
2
strstr : for :  * stop_machine(): we create temporary high priority worker threads, : 
2
strstr : while :  * stop_machine(): we create temporary high priority worker threads, : 
2
str :  * but our caller might not have that capability.[49]
strstr : INIT :  * but our caller might not have that capability. : 
2
strstr : if :  * but our caller might not have that capability. : 
2
strstr : for :  * but our caller might not have that capability. : 
2
strstr : while :  * but our caller might not have that capability. : 
2
str :  * Return: 0 on success. An error code otherwise.[49]
strstr : INIT :  * Return: 0 on success. An error code otherwise. : 
2
strstr : if :  * Return: 0 on success. An error code otherwise. : 
2
strstr : for :  * Return: 0 on success. An error code otherwise. : 
2
strstr : while :  * Return: 0 on success. An error code otherwise. : 
2
str :  */[3]
strstr : INIT :  */ : 
2
strstr : if :  */ : 
2
strstr : for :  */ : 
2
strstr : while :  */ : 
2
str : int sched_setscheduler_nocheck(struct task_struct *p, int policy,[65]
strstr : INIT : int sched_setscheduler_nocheck(struct task_struct *p, int policy, : 
2
strstr : if : int sched_setscheduler_nocheck(struct task_struct *p, int policy, : 
2
strstr : for : int sched_setscheduler_nocheck(struct task_struct *p, int policy, : 
2
strstr : while : int sched_setscheduler_nocheck(struct task_struct *p, int policy, : 
2
str : 			       const struct sched_param *param)[42]
strstr : INIT : 			       const struct sched_param *param) : 
2
strstr : if : 			       const struct sched_param *param) : 
2
strstr : for : 			       const struct sched_param *param) : 
2
strstr : while : 			       const struct sched_param *param) : 
2
str : 	return _sched_setscheduler(p, policy, param, false);[53]
strstr : INIT : 	return _sched_setscheduler(p, policy, param, false); : 
2
strstr : if : 	return _sched_setscheduler(p, policy, param, false); : 
2
strstr : for : 	return _sched_setscheduler(p, policy, param, false); : 
2
strstr : while : 	return _sched_setscheduler(p, policy, param, false); : 
2
str : static int[10]
strstr : INIT : static int : 
2
strstr : if : static int : 
2
strstr : for : static int : 
2
strstr : while : static int : 
2
str : do_sched_setscheduler(pid_t pid, int policy, struct sched_param __user *param)[78]
strstr : INIT : do_sched_setscheduler(pid_t pid, int policy, struct sched_param __user *param) : 
2
strstr : if : do_sched_setscheduler(pid_t pid, int policy, struct sched_param __user *param) : 
2
strstr : for : do_sched_setscheduler(pid_t pid, int policy, struct sched_param __user *param) : 
2
strstr : while : do_sched_setscheduler(pid_t pid, int policy, struct sched_param __user *param) : 
2
str : 	struct sched_param lparam;[27]
strstr : INIT : 	struct sched_param lparam; : 
2
strstr : if : 	struct sched_param lparam; : 
2
strstr : for : 	struct sched_param lparam; : 
2
strstr : while : 	struct sched_param lparam; : 
2
str : 	struct task_struct *p;[23]
strstr : INIT : 	struct task_struct *p; : 
2
strstr : if : 	struct task_struct *p; : 
2
strstr : for : 	struct task_struct *p; : 
2
strstr : while : 	struct task_struct *p; : 
2
str : 	int retval;[12]
strstr : INIT : 	int retval; : 
2
strstr : if : 	int retval; : 
2
strstr : for : 	int retval; : 
2
strstr : while : 	int retval; : 
2
str : 	if (!param || pid < 0)[23]
strstr : INIT : 	if (!param || pid < 0) : 
2
strstr : if : 	if (!param || pid < 0) : 
2
strstr : for : 	if (!param || pid < 0) : 
2
strstr : while : 	if (!param || pid < 0) : 
2
str : 		return -EINVAL;[17]
strstr : INIT : 		return -EINVAL; : 
2
strstr : if : 		return -EINVAL; : 
2
strstr : for : 		return -EINVAL; : 
2
strstr : while : 		return -EINVAL; : 
2
str : 	if (copy_from_user(&lparam, param, sizeof(struct sched_param)))[64]
strstr : INIT : 	if (copy_from_user(&lparam, param, sizeof(struct sched_param))) : 
2
strstr : if : 	if (copy_from_user(&lparam, param, sizeof(struct sched_param))) : 
2
strstr : for : 	if (copy_from_user(&lparam, param, sizeof(struct sched_param))) : 
2
strstr : while : 	if (copy_from_user(&lparam, param, sizeof(struct sched_param))) : 
2
str : 		return -EFAULT;[17]
strstr : INIT : 		return -EFAULT; : 
2
strstr : if : 		return -EFAULT; : 
2
strstr : for : 		return -EFAULT; : 
2
strstr : while : 		return -EFAULT; : 
2
str : 	rcu_read_lock();[17]
strstr : INIT : 	rcu_read_lock(); : 
2
strstr : if : 	rcu_read_lock(); : 
2
strstr : for : 	rcu_read_lock(); : 
2
strstr : while : 	rcu_read_lock(); : 
2
str : 	retval = -ESRCH;[17]
strstr : INIT : 	retval = -ESRCH; : 
2
strstr : if : 	retval = -ESRCH; : 
2
strstr : for : 	retval = -ESRCH; : 
2
strstr : while : 	retval = -ESRCH; : 
2
str : 	p = find_process_by_pid(pid);[30]
strstr : INIT : 	p = find_process_by_pid(pid); : 
2
strstr : if : 	p = find_process_by_pid(pid); : 
2
strstr : for : 	p = find_process_by_pid(pid); : 
2
strstr : while : 	p = find_process_by_pid(pid); : 
2
str : 	if (p != NULL)[15]
strstr : INIT : 	if (p != NULL) : 
2
strstr : if : 	if (p != NULL) : 
2
strstr : for : 	if (p != NULL) : 
2
strstr : while : 	if (p != NULL) : 
2
str : 		retval = sched_setscheduler(p, policy, &lparam);[50]
strstr : INIT : 		retval = sched_setscheduler(p, policy, &lparam); : 
2
strstr : if : 		retval = sched_setscheduler(p, policy, &lparam); : 
2
strstr : for : 		retval = sched_setscheduler(p, policy, &lparam); : 
2
strstr : while : 		retval = sched_setscheduler(p, policy, &lparam); : 
2
str : 	rcu_read_unlock();[19]
strstr : INIT : 	rcu_read_unlock(); : 
2
strstr : if : 	rcu_read_unlock(); : 
2
strstr : for : 	rcu_read_unlock(); : 
2
strstr : while : 	rcu_read_unlock(); : 
2
str : 	return retval;[15]
strstr : INIT : 	return retval; : 
2
strstr : if : 	return retval; : 
2
strstr : for : 	return retval; : 
2
strstr : while : 	return retval; : 
2
str :  * Mimics kernel/events/core.c perf_copy_attr().[48]
strstr : INIT :  * Mimics kernel/events/core.c perf_copy_attr(). : 
2
strstr : if :  * Mimics kernel/events/core.c perf_copy_attr(). : 
2
strstr : for :  * Mimics kernel/events/core.c perf_copy_attr(). : 
2
strstr : while :  * Mimics kernel/events/core.c perf_copy_attr(). : 
2
str :  */[3]
strstr : INIT :  */ : 
2
strstr : if :  */ : 
2
strstr : for :  */ : 
2
strstr : while :  */ : 
2
str : static int sched_copy_attr(struct sched_attr __user *uattr,[59]
strstr : INIT : static int sched_copy_attr(struct sched_attr __user *uattr, : 
2
strstr : if : static int sched_copy_attr(struct sched_attr __user *uattr, : 
2
strstr : for : static int sched_copy_attr(struct sched_attr __user *uattr, : 
2
strstr : while : static int sched_copy_attr(struct sched_attr __user *uattr, : 
2
str : 			   struct sched_attr *attr)[30]
strstr : INIT : 			   struct sched_attr *attr) : 
2
strstr : if : 			   struct sched_attr *attr) : 
2
strstr : for : 			   struct sched_attr *attr) : 
2
strstr : while : 			   struct sched_attr *attr) : 
2
str : 	u32 size;[10]
strstr : INIT : 	u32 size; : 
2
strstr : if : 	u32 size; : 
2
strstr : for : 	u32 size; : 
2
strstr : while : 	u32 size; : 
2
str : 	int ret;[9]
strstr : INIT : 	int ret; : 
2
strstr : if : 	int ret; : 
2
strstr : for : 	int ret; : 
2
strstr : while : 	int ret; : 
2
str : 	if (!access_ok(VERIFY_WRITE, uattr, SCHED_ATTR_SIZE_VER0))[59]
strstr : INIT : 	if (!access_ok(VERIFY_WRITE, uattr, SCHED_ATTR_SIZE_VER0)) : 
2
strstr : if : 	if (!access_ok(VERIFY_WRITE, uattr, SCHED_ATTR_SIZE_VER0)) : 
2
strstr : for : 	if (!access_ok(VERIFY_WRITE, uattr, SCHED_ATTR_SIZE_VER0)) : 
2
strstr : while : 	if (!access_ok(VERIFY_WRITE, uattr, SCHED_ATTR_SIZE_VER0)) : 
2
str : 		return -EFAULT;[17]
strstr : INIT : 		return -EFAULT; : 
2
strstr : if : 		return -EFAULT; : 
2
strstr : for : 		return -EFAULT; : 
2
strstr : while : 		return -EFAULT; : 
2
str : 	/*[3]
strstr : INIT : 	/* : 
2
strstr : if : 	/* : 
2
strstr : for : 	/* : 
2
strstr : while : 	/* : 
2
str : 	 * zero the full structure, so that a short copy will be nice.[63]
strstr : INIT : 	 * zero the full structure, so that a short copy will be nice. : 
2
strstr : if : 	 * zero the full structure, so that a short copy will be nice. : 
2
strstr : for : 	 * zero the full structure, so that a short copy will be nice. : 
2
strstr : while : 	 * zero the full structure, so that a short copy will be nice. : 
2
str : 	 */[4]
strstr : INIT : 	 */ : 
2
strstr : if : 	 */ : 
2
strstr : for : 	 */ : 
2
strstr : while : 	 */ : 
2
str : 	memset(attr, 0, sizeof(*attr));[32]
strstr : INIT : 	memset(attr, 0, sizeof(*attr)); : 
2
strstr : if : 	memset(attr, 0, sizeof(*attr)); : 
2
strstr : for : 	memset(attr, 0, sizeof(*attr)); : 
2
strstr : while : 	memset(attr, 0, sizeof(*attr)); : 
2
str : 	ret = get_user(size, &uattr->size);[36]
strstr : INIT : 	ret = get_user(size, &uattr->size); : 
2
strstr : if : 	ret = get_user(size, &uattr->size); : 
2
strstr : for : 	ret = get_user(size, &uattr->size); : 
2
strstr : while : 	ret = get_user(size, &uattr->size); : 
2
str : 	if (ret)[9]
strstr : INIT : 	if (ret) : 
2
strstr : if : 	if (ret) : 
2
strstr : for : 	if (ret) : 
2
strstr : while : 	if (ret) : 
2
str : 		return ret;[13]
strstr : INIT : 		return ret; : 
2
strstr : if : 		return ret; : 
2
strstr : for : 		return ret; : 
2
strstr : while : 		return ret; : 
2
str : 	if (size > PAGE_SIZE)	/* silly large */[40]
strstr : INIT : 	if (size > PAGE_SIZE)	/* silly large */ : 
2
strstr : if : 	if (size > PAGE_SIZE)	/* silly large */ : 
2
strstr : for : 	if (size > PAGE_SIZE)	/* silly large */ : 
2
strstr : while : 	if (size > PAGE_SIZE)	/* silly large */ : 
2
str : 		goto err_size;[16]
strstr : INIT : 		goto err_size; : 
2
strstr : if : 		goto err_size; : 
2
strstr : for : 		goto err_size; : 
2
strstr : while : 		goto err_size; : 
2
str : 	if (!size)		/* abi compat */[29]
strstr : INIT : 	if (!size)		/* abi compat */ : 
2
strstr : if : 	if (!size)		/* abi compat */ : 
2
strstr : for : 	if (!size)		/* abi compat */ : 
2
strstr : while : 	if (!size)		/* abi compat */ : 
2
str : 		size = SCHED_ATTR_SIZE_VER0;[30]
strstr : INIT : 		size = SCHED_ATTR_SIZE_VER0; : 
2
strstr : if : 		size = SCHED_ATTR_SIZE_VER0; : 
2
strstr : for : 		size = SCHED_ATTR_SIZE_VER0; : 
2
strstr : while : 		size = SCHED_ATTR_SIZE_VER0; : 
2
str : 	if (size < SCHED_ATTR_SIZE_VER0)[33]
strstr : INIT : 	if (size < SCHED_ATTR_SIZE_VER0) : 
2
strstr : if : 	if (size < SCHED_ATTR_SIZE_VER0) : 
2
strstr : for : 	if (size < SCHED_ATTR_SIZE_VER0) : 
2
strstr : while : 	if (size < SCHED_ATTR_SIZE_VER0) : 
2
str : 		goto err_size;[16]
strstr : INIT : 		goto err_size; : 
2
strstr : if : 		goto err_size; : 
2
strstr : for : 		goto err_size; : 
2
strstr : while : 		goto err_size; : 
2
str : 	/*[3]
strstr : INIT : 	/* : 
2
strstr : if : 	/* : 
2
strstr : for : 	/* : 
2
strstr : while : 	/* : 
2
str : 	 * If we're handed a bigger struct than we know of,[52]
strstr : INIT : 	 * If we're handed a bigger struct than we know of, : 
2
strstr : if : 	 * If we're handed a bigger struct than we know of, : 
2
strstr : for : 	 * If we're handed a bigger struct than we know of, : 
2
strstr : while : 	 * If we're handed a bigger struct than we know of, : 
2
str : 	 * ensure all the unknown bits are 0 - i.e. new[48]
strstr : INIT : 	 * ensure all the unknown bits are 0 - i.e. new : 
2
strstr : if : 	 * ensure all the unknown bits are 0 - i.e. new : 
2
strstr : for : 	 * ensure all the unknown bits are 0 - i.e. new : 
2
strstr : while : 	 * ensure all the unknown bits are 0 - i.e. new : 
2
str : 	 * user-space does not rely on any kernel feature[50]
strstr : INIT : 	 * user-space does not rely on any kernel feature : 
2
strstr : if : 	 * user-space does not rely on any kernel feature : 
2
strstr : for : 	 * user-space does not rely on any kernel feature : 
2
strstr : while : 	 * user-space does not rely on any kernel feature : 
2
str : 	 * extensions we dont know about yet.[38]
strstr : INIT : 	 * extensions we dont know about yet. : 
2
strstr : if : 	 * extensions we dont know about yet. : 
2
strstr : for : 	 * extensions we dont know about yet. : 
2
strstr : while : 	 * extensions we dont know about yet. : 
2
str : 	 */[4]
strstr : INIT : 	 */ : 
2
strstr : if : 	 */ : 
2
strstr : for : 	 */ : 
2
strstr : while : 	 */ : 
2
str : 	if (size > sizeof(*attr)) {[28]
strstr : INIT : 	if (size > sizeof(*attr)) { : 
2
strstr : if : 	if (size > sizeof(*attr)) { : 
2
strstr : for : 	if (size > sizeof(*attr)) { : 
2
strstr : while : 	if (size > sizeof(*attr)) { : 
2
str : 		unsigned char __user *addr;[29]
strstr : INIT : 		unsigned char __user *addr; : 
2
strstr : if : 		unsigned char __user *addr; : 
2
strstr : for : 		unsigned char __user *addr; : 
2
strstr : while : 		unsigned char __user *addr; : 
2
str : 		unsigned char __user *end;[28]
strstr : INIT : 		unsigned char __user *end; : 
2
strstr : if : 		unsigned char __user *end; : 
2
strstr : for : 		unsigned char __user *end; : 
2
strstr : while : 		unsigned char __user *end; : 
2
str : 		unsigned char val;[20]
strstr : INIT : 		unsigned char val; : 
2
strstr : if : 		unsigned char val; : 
2
strstr : for : 		unsigned char val; : 
2
strstr : while : 		unsigned char val; : 
2
str : 		addr = (void __user *)uattr + sizeof(*attr);[46]
strstr : INIT : 		addr = (void __user *)uattr + sizeof(*attr); : 
2
strstr : if : 		addr = (void __user *)uattr + sizeof(*attr); : 
2
strstr : for : 		addr = (void __user *)uattr + sizeof(*attr); : 
2
strstr : while : 		addr = (void __user *)uattr + sizeof(*attr); : 
2
str : 		end  = (void __user *)uattr + size;[37]
strstr : INIT : 		end  = (void __user *)uattr + size; : 
2
strstr : if : 		end  = (void __user *)uattr + size; : 
2
strstr : for : 		end  = (void __user *)uattr + size; : 
2
strstr : while : 		end  = (void __user *)uattr + size; : 
2
str : 		for (; addr < end; addr++) {[30]
strstr : INIT : 		for (; addr < end; addr++) { : 
2
strstr : if : 		for (; addr < end; addr++) { : 
2
strstr : for : 		for (; addr < end; addr++) { : 
2
strstr : while : 		for (; addr < end; addr++) { : 
2
str : 			ret = get_user(val, addr);[29]
strstr : INIT : 			ret = get_user(val, addr); : 
2
strstr : if : 			ret = get_user(val, addr); : 
2
strstr : for : 			ret = get_user(val, addr); : 
2
strstr : while : 			ret = get_user(val, addr); : 
2
str : 			if (ret)[11]
strstr : INIT : 			if (ret) : 
2
strstr : if : 			if (ret) : 
2
strstr : for : 			if (ret) : 
2
strstr : while : 			if (ret) : 
2
str : 				return ret;[15]
strstr : INIT : 				return ret; : 
2
strstr : if : 				return ret; : 
2
strstr : for : 				return ret; : 
2
strstr : while : 				return ret; : 
2
str : 			if (val)[11]
strstr : INIT : 			if (val) : 
2
strstr : if : 			if (val) : 
2
strstr : for : 			if (val) : 
2
strstr : while : 			if (val) : 
2
str : 				goto err_size;[18]
strstr : INIT : 				goto err_size; : 
2
strstr : if : 				goto err_size; : 
2
strstr : for : 				goto err_size; : 
2
strstr : while : 				goto err_size; : 
2
str : 		}[3]
strstr : INIT : 		} : 
2
strstr : if : 		} : 
2
strstr : for : 		} : 
2
strstr : while : 		} : 
2
str : 		size = sizeof(*attr);[23]
strstr : INIT : 		size = sizeof(*attr); : 
2
strstr : if : 		size = sizeof(*attr); : 
2
strstr : for : 		size = sizeof(*attr); : 
2
strstr : while : 		size = sizeof(*attr); : 
2
str : 	ret = copy_from_user(attr, uattr, size);[41]
strstr : INIT : 	ret = copy_from_user(attr, uattr, size); : 
2
strstr : if : 	ret = copy_from_user(attr, uattr, size); : 
2
strstr : for : 	ret = copy_from_user(attr, uattr, size); : 
2
strstr : while : 	ret = copy_from_user(attr, uattr, size); : 
2
str : 	if (ret)[9]
strstr : INIT : 	if (ret) : 
2
strstr : if : 	if (ret) : 
2
strstr : for : 	if (ret) : 
2
strstr : while : 	if (ret) : 
2
str : 		return -EFAULT;[17]
strstr : INIT : 		return -EFAULT; : 
2
strstr : if : 		return -EFAULT; : 
2
strstr : for : 		return -EFAULT; : 
2
strstr : while : 		return -EFAULT; : 
2
str : 	/*[3]
strstr : INIT : 	/* : 
2
strstr : if : 	/* : 
2
strstr : for : 	/* : 
2
strstr : while : 	/* : 
2
str : 	 * XXX: do we want to be lenient like existing syscalls; or do we want[71]
strstr : INIT : 	 * XXX: do we want to be lenient like existing syscalls; or do we want : 
2
strstr : if : 	 * XXX: do we want to be lenient like existing syscalls; or do we want : 
2
strstr : for : 	 * XXX: do we want to be lenient like existing syscalls; or do we want : 
2
strstr : while : 	 * XXX: do we want to be lenient like existing syscalls; or do we want : 
2
str : 	 * to be strict and return an error on out-of-bounds values?[61]
strstr : INIT : 	 * to be strict and return an error on out-of-bounds values? : 
2
strstr : if : 	 * to be strict and return an error on out-of-bounds values? : 
2
strstr : for : 	 * to be strict and return an error on out-of-bounds values? : 
2
strstr : while : 	 * to be strict and return an error on out-of-bounds values? : 
2
str : 	 */[4]
strstr : INIT : 	 */ : 
2
strstr : if : 	 */ : 
2
strstr : for : 	 */ : 
2
strstr : while : 	 */ : 
2
str : 	attr->sched_nice = clamp(attr->sched_nice, -20, 19);[53]
strstr : INIT : 	attr->sched_nice = clamp(attr->sched_nice, -20, 19); : 
2
strstr : if : 	attr->sched_nice = clamp(attr->sched_nice, -20, 19); : 
2
strstr : for : 	attr->sched_nice = clamp(attr->sched_nice, -20, 19); : 
2
strstr : while : 	attr->sched_nice = clamp(attr->sched_nice, -20, 19); : 
2
str : out:[4]
strstr : INIT : out: : 
2
strstr : if : out: : 
2
strstr : for : out: : 
2
strstr : while : out: : 
2
str : 	return ret;[12]
strstr : INIT : 	return ret; : 
2
strstr : if : 	return ret; : 
2
strstr : for : 	return ret; : 
2
strstr : while : 	return ret; : 
2
str : err_size:[9]
strstr : INIT : err_size: : 
2
strstr : if : err_size: : 
2
strstr : for : err_size: : 
2
strstr : while : err_size: : 
2
str : 	put_user(sizeof(*attr), &uattr->size);[39]
strstr : INIT : 	put_user(sizeof(*attr), &uattr->size); : 
2
strstr : if : 	put_user(sizeof(*attr), &uattr->size); : 
2
strstr : for : 	put_user(sizeof(*attr), &uattr->size); : 
2
strstr : while : 	put_user(sizeof(*attr), &uattr->size); : 
2
str : 	ret = -E2BIG;[14]
strstr : INIT : 	ret = -E2BIG; : 
2
strstr : if : 	ret = -E2BIG; : 
2
strstr : for : 	ret = -E2BIG; : 
2
strstr : while : 	ret = -E2BIG; : 
2
str : 	goto out;[10]
strstr : INIT : 	goto out; : 
2
strstr : if : 	goto out; : 
2
strstr : for : 	goto out; : 
2
strstr : while : 	goto out; : 
2
str : /**[3]
strstr : INIT : /** : 
2
strstr : if : /** : 
2
strstr : for : /** : 
2
strstr : while : /** : 
2
str :  * sys_sched_setscheduler - set/change the scheduler policy and RT priority[75]
strstr : INIT :  * sys_sched_setscheduler - set/change the scheduler policy and RT priority : 
2
strstr : if :  * sys_sched_setscheduler - set/change the scheduler policy and RT priority : 
2
strstr : for :  * sys_sched_setscheduler - set/change the scheduler policy and RT priority : 
2
strstr : while :  * sys_sched_setscheduler - set/change the scheduler policy and RT priority : 
2
str :  * @pid: the pid in question.[29]
strstr : INIT :  * @pid: the pid in question. : 
2
strstr : if :  * @pid: the pid in question. : 
2
strstr : for :  * @pid: the pid in question. : 
2
strstr : while :  * @pid: the pid in question. : 
2
str :  * @policy: new policy.[23]
strstr : INIT :  * @policy: new policy. : 
2
strstr : if :  * @policy: new policy. : 
2
strstr : for :  * @policy: new policy. : 
2
strstr : while :  * @policy: new policy. : 
2
str :  * @param: structure containing the new RT priority.[52]
strstr : INIT :  * @param: structure containing the new RT priority. : 
2
strstr : if :  * @param: structure containing the new RT priority. : 
2
strstr : for :  * @param: structure containing the new RT priority. : 
2
strstr : while :  * @param: structure containing the new RT priority. : 
2
str :  * Return: 0 on success. An error code otherwise.[49]
strstr : INIT :  * Return: 0 on success. An error code otherwise. : 
2
strstr : if :  * Return: 0 on success. An error code otherwise. : 
2
strstr : for :  * Return: 0 on success. An error code otherwise. : 
2
strstr : while :  * Return: 0 on success. An error code otherwise. : 
2
str :  */[3]
strstr : INIT :  */ : 
2
strstr : if :  */ : 
2
strstr : for :  */ : 
2
strstr : while :  */ : 
2
str : SYSCALL_DEFINE3(sched_setscheduler, pid_t, pid, int, policy,[60]
strstr : INIT : SYSCALL_DEFINE3(sched_setscheduler, pid_t, pid, int, policy, : 
2
strstr : if : SYSCALL_DEFINE3(sched_setscheduler, pid_t, pid, int, policy, : 
2
strstr : for : SYSCALL_DEFINE3(sched_setscheduler, pid_t, pid, int, policy, : 
2
strstr : while : SYSCALL_DEFINE3(sched_setscheduler, pid_t, pid, int, policy, : 
2
str : 		struct sched_param __user *, param)[37]
strstr : INIT : 		struct sched_param __user *, param) : 
2
strstr : if : 		struct sched_param __user *, param) : 
2
strstr : for : 		struct sched_param __user *, param) : 
2
strstr : while : 		struct sched_param __user *, param) : 
2
str : 	/* negative values for policy are not valid */[47]
strstr : INIT : 	/* negative values for policy are not valid */ : 
2
strstr : if : 	/* negative values for policy are not valid */ : 
2
strstr : for : 	/* negative values for policy are not valid */ : 
2
strstr : while : 	/* negative values for policy are not valid */ : 
2
str : 	if (policy < 0)[16]
strstr : INIT : 	if (policy < 0) : 
2
strstr : if : 	if (policy < 0) : 
2
strstr : for : 	if (policy < 0) : 
2
strstr : while : 	if (policy < 0) : 
2
str : 		return -EINVAL;[17]
strstr : INIT : 		return -EINVAL; : 
2
strstr : if : 		return -EINVAL; : 
2
strstr : for : 		return -EINVAL; : 
2
strstr : while : 		return -EINVAL; : 
2
str : 	return do_sched_setscheduler(pid, policy, param);[50]
strstr : INIT : 	return do_sched_setscheduler(pid, policy, param); : 
2
strstr : if : 	return do_sched_setscheduler(pid, policy, param); : 
2
strstr : for : 	return do_sched_setscheduler(pid, policy, param); : 
2
strstr : while : 	return do_sched_setscheduler(pid, policy, param); : 
2
str : /**[3]
strstr : INIT : /** : 
2
strstr : if : /** : 
2
strstr : for : /** : 
2
strstr : while : /** : 
2
str :  * sys_sched_setparam - set/change the RT priority of a thread[62]
strstr : INIT :  * sys_sched_setparam - set/change the RT priority of a thread : 
2
strstr : if :  * sys_sched_setparam - set/change the RT priority of a thread : 
2
strstr : for :  * sys_sched_setparam - set/change the RT priority of a thread : 
2
strstr : while :  * sys_sched_setparam - set/change the RT priority of a thread : 
2
str :  * @pid: the pid in question.[29]
strstr : INIT :  * @pid: the pid in question. : 
2
strstr : if :  * @pid: the pid in question. : 
2
strstr : for :  * @pid: the pid in question. : 
2
strstr : while :  * @pid: the pid in question. : 
2
str :  * @param: structure containing the new RT priority.[52]
strstr : INIT :  * @param: structure containing the new RT priority. : 
2
strstr : if :  * @param: structure containing the new RT priority. : 
2
strstr : for :  * @param: structure containing the new RT priority. : 
2
strstr : while :  * @param: structure containing the new RT priority. : 
2
str :  * Return: 0 on success. An error code otherwise.[49]
strstr : INIT :  * Return: 0 on success. An error code otherwise. : 
2
strstr : if :  * Return: 0 on success. An error code otherwise. : 
2
strstr : for :  * Return: 0 on success. An error code otherwise. : 
2
strstr : while :  * Return: 0 on success. An error code otherwise. : 
2
str :  */[3]
strstr : INIT :  */ : 
2
strstr : if :  */ : 
2
strstr : for :  */ : 
2
strstr : while :  */ : 
2
str : SYSCALL_DEFINE2(sched_setparam, pid_t, pid, struct sched_param __user *, param)[79]
strstr : INIT : SYSCALL_DEFINE2(sched_setparam, pid_t, pid, struct sched_param __user *, param) : 
2
strstr : if : SYSCALL_DEFINE2(sched_setparam, pid_t, pid, struct sched_param __user *, param) : 
2
strstr : for : SYSCALL_DEFINE2(sched_setparam, pid_t, pid, struct sched_param __user *, param) : 
2
strstr : while : SYSCALL_DEFINE2(sched_setparam, pid_t, pid, struct sched_param __user *, param) : 
2
str : 	return do_sched_setscheduler(pid, -1, param);[46]
strstr : INIT : 	return do_sched_setscheduler(pid, -1, param); : 
2
strstr : if : 	return do_sched_setscheduler(pid, -1, param); : 
2
strstr : for : 	return do_sched_setscheduler(pid, -1, param); : 
2
strstr : while : 	return do_sched_setscheduler(pid, -1, param); : 
2
str : /**[3]
strstr : INIT : /** : 
2
strstr : if : /** : 
2
strstr : for : /** : 
2
strstr : while : /** : 
2
str :  * sys_sched_setattr - same as above, but with extended sched_attr[66]
strstr : INIT :  * sys_sched_setattr - same as above, but with extended sched_attr : 
2
strstr : if :  * sys_sched_setattr - same as above, but with extended sched_attr : 
2
strstr : for :  * sys_sched_setattr - same as above, but with extended sched_attr : 
2
strstr : while :  * sys_sched_setattr - same as above, but with extended sched_attr : 
2
str :  * @pid: the pid in question.[29]
strstr : INIT :  * @pid: the pid in question. : 
2
strstr : if :  * @pid: the pid in question. : 
2
strstr : for :  * @pid: the pid in question. : 
2
strstr : while :  * @pid: the pid in question. : 
2
str :  * @uattr: structure containing the extended parameters.[56]
strstr : INIT :  * @uattr: structure containing the extended parameters. : 
2
strstr : if :  * @uattr: structure containing the extended parameters. : 
2
strstr : for :  * @uattr: structure containing the extended parameters. : 
2
strstr : while :  * @uattr: structure containing the extended parameters. : 
2
str :  */[3]
strstr : INIT :  */ : 
2
strstr : if :  */ : 
2
strstr : for :  */ : 
2
strstr : while :  */ : 
2
str : SYSCALL_DEFINE3(sched_setattr, pid_t, pid, struct sched_attr __user *, uattr,[77]
strstr : INIT : SYSCALL_DEFINE3(sched_setattr, pid_t, pid, struct sched_attr __user *, uattr, : 
2
strstr : if : SYSCALL_DEFINE3(sched_setattr, pid_t, pid, struct sched_attr __user *, uattr, : 
2
strstr : for : SYSCALL_DEFINE3(sched_setattr, pid_t, pid, struct sched_attr __user *, uattr, : 
2
strstr : while : SYSCALL_DEFINE3(sched_setattr, pid_t, pid, struct sched_attr __user *, uattr, : 
2
str : 			       unsigned int, flags)[30]
strstr : INIT : 			       unsigned int, flags) : 
2
strstr : if : 			       unsigned int, flags) : 
2
strstr : for : 			       unsigned int, flags) : 
2
strstr : while : 			       unsigned int, flags) : 
2
str : 	struct sched_attr attr;[24]
strstr : INIT : 	struct sched_attr attr; : 
2
strstr : if : 	struct sched_attr attr; : 
2
strstr : for : 	struct sched_attr attr; : 
2
strstr : while : 	struct sched_attr attr; : 
2
str : 	struct task_struct *p;[23]
strstr : INIT : 	struct task_struct *p; : 
2
strstr : if : 	struct task_struct *p; : 
2
strstr : for : 	struct task_struct *p; : 
2
strstr : while : 	struct task_struct *p; : 
2
str : 	int retval;[12]
strstr : INIT : 	int retval; : 
2
strstr : if : 	int retval; : 
2
strstr : for : 	int retval; : 
2
strstr : while : 	int retval; : 
2
str : 	if (!uattr || pid < 0 || flags)[32]
strstr : INIT : 	if (!uattr || pid < 0 || flags) : 
2
strstr : if : 	if (!uattr || pid < 0 || flags) : 
2
strstr : for : 	if (!uattr || pid < 0 || flags) : 
2
strstr : while : 	if (!uattr || pid < 0 || flags) : 
2
str : 		return -EINVAL;[17]
strstr : INIT : 		return -EINVAL; : 
2
strstr : if : 		return -EINVAL; : 
2
strstr : for : 		return -EINVAL; : 
2
strstr : while : 		return -EINVAL; : 
2
str : 	retval = sched_copy_attr(uattr, &attr);[40]
strstr : INIT : 	retval = sched_copy_attr(uattr, &attr); : 
2
strstr : if : 	retval = sched_copy_attr(uattr, &attr); : 
2
strstr : for : 	retval = sched_copy_attr(uattr, &attr); : 
2
strstr : while : 	retval = sched_copy_attr(uattr, &attr); : 
2
str : 	if (retval)[12]
strstr : INIT : 	if (retval) : 
2
strstr : if : 	if (retval) : 
2
strstr : for : 	if (retval) : 
2
strstr : while : 	if (retval) : 
2
str : 		return retval;[16]
strstr : INIT : 		return retval; : 
2
strstr : if : 		return retval; : 
2
strstr : for : 		return retval; : 
2
strstr : while : 		return retval; : 
2
str : 	if ((int)attr.sched_policy < 0)[32]
strstr : INIT : 	if ((int)attr.sched_policy < 0) : 
2
strstr : if : 	if ((int)attr.sched_policy < 0) : 
2
strstr : for : 	if ((int)attr.sched_policy < 0) : 
2
strstr : while : 	if ((int)attr.sched_policy < 0) : 
2
str : 		return -EINVAL;[17]
strstr : INIT : 		return -EINVAL; : 
2
strstr : if : 		return -EINVAL; : 
2
strstr : for : 		return -EINVAL; : 
2
strstr : while : 		return -EINVAL; : 
2
str : 	rcu_read_lock();[17]
strstr : INIT : 	rcu_read_lock(); : 
2
strstr : if : 	rcu_read_lock(); : 
2
strstr : for : 	rcu_read_lock(); : 
2
strstr : while : 	rcu_read_lock(); : 
2
str : 	retval = -ESRCH;[17]
strstr : INIT : 	retval = -ESRCH; : 
2
strstr : if : 	retval = -ESRCH; : 
2
strstr : for : 	retval = -ESRCH; : 
2
strstr : while : 	retval = -ESRCH; : 
2
str : 	p = find_process_by_pid(pid);[30]
strstr : INIT : 	p = find_process_by_pid(pid); : 
2
strstr : if : 	p = find_process_by_pid(pid); : 
2
strstr : for : 	p = find_process_by_pid(pid); : 
2
strstr : while : 	p = find_process_by_pid(pid); : 
2
str : 	if (p != NULL)[15]
strstr : INIT : 	if (p != NULL) : 
2
strstr : if : 	if (p != NULL) : 
2
strstr : for : 	if (p != NULL) : 
2
strstr : while : 	if (p != NULL) : 
2
str : 		retval = sched_setattr(p, &attr);[35]
strstr : INIT : 		retval = sched_setattr(p, &attr); : 
2
strstr : if : 		retval = sched_setattr(p, &attr); : 
2
strstr : for : 		retval = sched_setattr(p, &attr); : 
2
strstr : while : 		retval = sched_setattr(p, &attr); : 
2
str : 	rcu_read_unlock();[19]
strstr : INIT : 	rcu_read_unlock(); : 
2
strstr : if : 	rcu_read_unlock(); : 
2
strstr : for : 	rcu_read_unlock(); : 
2
strstr : while : 	rcu_read_unlock(); : 
2
str : 	return retval;[15]
strstr : INIT : 	return retval; : 
2
strstr : if : 	return retval; : 
2
strstr : for : 	return retval; : 
2
strstr : while : 	return retval; : 
2
str : /**[3]
strstr : INIT : /** : 
2
strstr : if : /** : 
2
strstr : for : /** : 
2
strstr : while : /** : 
2
str :  * sys_sched_getscheduler - get the policy (scheduling class) of a thread[73]
strstr : INIT :  * sys_sched_getscheduler - get the policy (scheduling class) of a thread : 
2
strstr : if :  * sys_sched_getscheduler - get the policy (scheduling class) of a thread : 
2
strstr : for :  * sys_sched_getscheduler - get the policy (scheduling class) of a thread : 
2
strstr : while :  * sys_sched_getscheduler - get the policy (scheduling class) of a thread : 
2
str :  * @pid: the pid in question.[29]
strstr : INIT :  * @pid: the pid in question. : 
2
strstr : if :  * @pid: the pid in question. : 
2
strstr : for :  * @pid: the pid in question. : 
2
strstr : while :  * @pid: the pid in question. : 
2
str :  * Return: On success, the policy of the thread. Otherwise, a negative error[76]
strstr : INIT :  * Return: On success, the policy of the thread. Otherwise, a negative error : 
2
strstr : if :  * Return: On success, the policy of the thread. Otherwise, a negative error : 
2
strstr : for :  * Return: On success, the policy of the thread. Otherwise, a negative error : 
2
strstr : while :  * Return: On success, the policy of the thread. Otherwise, a negative error : 
2
str :  * code.[8]
strstr : INIT :  * code. : 
2
strstr : if :  * code. : 
2
strstr : for :  * code. : 
2
strstr : while :  * code. : 
2
str :  */[3]
strstr : INIT :  */ : 
2
strstr : if :  */ : 
2
strstr : for :  */ : 
2
strstr : while :  */ : 
2
str : SYSCALL_DEFINE1(sched_getscheduler, pid_t, pid)[47]
strstr : INIT : SYSCALL_DEFINE1(sched_getscheduler, pid_t, pid) : 
2
strstr : if : SYSCALL_DEFINE1(sched_getscheduler, pid_t, pid) : 
2
strstr : for : SYSCALL_DEFINE1(sched_getscheduler, pid_t, pid) : 
2
strstr : while : SYSCALL_DEFINE1(sched_getscheduler, pid_t, pid) : 
2
str : 	struct task_struct *p;[23]
strstr : INIT : 	struct task_struct *p; : 
2
strstr : if : 	struct task_struct *p; : 
2
strstr : for : 	struct task_struct *p; : 
2
strstr : while : 	struct task_struct *p; : 
2
str : 	int retval;[12]
strstr : INIT : 	int retval; : 
2
strstr : if : 	int retval; : 
2
strstr : for : 	int retval; : 
2
strstr : while : 	int retval; : 
2
str : 	if (pid < 0)[13]
strstr : INIT : 	if (pid < 0) : 
2
strstr : if : 	if (pid < 0) : 
2
strstr : for : 	if (pid < 0) : 
2
strstr : while : 	if (pid < 0) : 
2
str : 		return -EINVAL;[17]
strstr : INIT : 		return -EINVAL; : 
2
strstr : if : 		return -EINVAL; : 
2
strstr : for : 		return -EINVAL; : 
2
strstr : while : 		return -EINVAL; : 
2
str : 	retval = -ESRCH;[17]
strstr : INIT : 	retval = -ESRCH; : 
2
strstr : if : 	retval = -ESRCH; : 
2
strstr : for : 	retval = -ESRCH; : 
2
strstr : while : 	retval = -ESRCH; : 
2
str : 	rcu_read_lock();[17]
strstr : INIT : 	rcu_read_lock(); : 
2
strstr : if : 	rcu_read_lock(); : 
2
strstr : for : 	rcu_read_lock(); : 
2
strstr : while : 	rcu_read_lock(); : 
2
str : 	p = find_process_by_pid(pid);[30]
strstr : INIT : 	p = find_process_by_pid(pid); : 
2
strstr : if : 	p = find_process_by_pid(pid); : 
2
strstr : for : 	p = find_process_by_pid(pid); : 
2
strstr : while : 	p = find_process_by_pid(pid); : 
2
str : 	if (p) {[9]
strstr : INIT : 	if (p) { : 
2
strstr : if : 	if (p) { : 
2
strstr : for : 	if (p) { : 
2
strstr : while : 	if (p) { : 
2
str : 		retval = security_task_getscheduler(p);[41]
strstr : INIT : 		retval = security_task_getscheduler(p); : 
2
strstr : if : 		retval = security_task_getscheduler(p); : 
2
strstr : for : 		retval = security_task_getscheduler(p); : 
2
strstr : while : 		retval = security_task_getscheduler(p); : 
2
str : 		if (!retval)[14]
strstr : INIT : 		if (!retval) : 
2
strstr : if : 		if (!retval) : 
2
strstr : for : 		if (!retval) : 
2
strstr : while : 		if (!retval) : 
2
str : 			retval = p->policy[21]
strstr : INIT : 			retval = p->policy : 
2
strstr : if : 			retval = p->policy : 
2
strstr : for : 			retval = p->policy : 
2
strstr : while : 			retval = p->policy : 
2
str : 				| (p->sched_reset_on_fork ? SCHED_RESET_ON_FORK : 0);[57]
strstr : INIT : 				| (p->sched_reset_on_fork ? SCHED_RESET_ON_FORK : 0); : 
2
strstr : if : 				| (p->sched_reset_on_fork ? SCHED_RESET_ON_FORK : 0); : 
2
strstr : for : 				| (p->sched_reset_on_fork ? SCHED_RESET_ON_FORK : 0); : 
2
strstr : while : 				| (p->sched_reset_on_fork ? SCHED_RESET_ON_FORK : 0); : 
2
str : 	rcu_read_unlock();[19]
strstr : INIT : 	rcu_read_unlock(); : 
2
strstr : if : 	rcu_read_unlock(); : 
2
strstr : for : 	rcu_read_unlock(); : 
2
strstr : while : 	rcu_read_unlock(); : 
2
str : 	return retval;[15]
strstr : INIT : 	return retval; : 
2
strstr : if : 	return retval; : 
2
strstr : for : 	return retval; : 
2
strstr : while : 	return retval; : 
2
str : /**[3]
strstr : INIT : /** : 
2
strstr : if : /** : 
2
strstr : for : /** : 
2
strstr : while : /** : 
2
str :  * sys_sched_getparam - get the RT priority of a thread[55]
strstr : INIT :  * sys_sched_getparam - get the RT priority of a thread : 
2
strstr : if :  * sys_sched_getparam - get the RT priority of a thread : 
2
strstr : for :  * sys_sched_getparam - get the RT priority of a thread : 
2
strstr : while :  * sys_sched_getparam - get the RT priority of a thread : 
2
str :  * @pid: the pid in question.[29]
strstr : INIT :  * @pid: the pid in question. : 
2
strstr : if :  * @pid: the pid in question. : 
2
strstr : for :  * @pid: the pid in question. : 
2
strstr : while :  * @pid: the pid in question. : 
2
str :  * @param: structure containing the RT priority.[48]
strstr : INIT :  * @param: structure containing the RT priority. : 
2
strstr : if :  * @param: structure containing the RT priority. : 
2
strstr : for :  * @param: structure containing the RT priority. : 
2
strstr : while :  * @param: structure containing the RT priority. : 
2
str :  * Return: On success, 0 and the RT priority is in @param. Otherwise, an error[78]
strstr : INIT :  * Return: On success, 0 and the RT priority is in @param. Otherwise, an error : 
2
strstr : if :  * Return: On success, 0 and the RT priority is in @param. Otherwise, an error : 
2
strstr : for :  * Return: On success, 0 and the RT priority is in @param. Otherwise, an error : 
2
strstr : while :  * Return: On success, 0 and the RT priority is in @param. Otherwise, an error : 
2
str :  * code.[8]
strstr : INIT :  * code. : 
2
strstr : if :  * code. : 
2
strstr : for :  * code. : 
2
strstr : while :  * code. : 
2
str :  */[3]
strstr : INIT :  */ : 
2
strstr : if :  */ : 
2
strstr : for :  */ : 
2
strstr : while :  */ : 
2
str : SYSCALL_DEFINE2(sched_getparam, pid_t, pid, struct sched_param __user *, param)[79]
strstr : INIT : SYSCALL_DEFINE2(sched_getparam, pid_t, pid, struct sched_param __user *, param) : 
2
strstr : if : SYSCALL_DEFINE2(sched_getparam, pid_t, pid, struct sched_param __user *, param) : 
2
strstr : for : SYSCALL_DEFINE2(sched_getparam, pid_t, pid, struct sched_param __user *, param) : 
2
strstr : while : SYSCALL_DEFINE2(sched_getparam, pid_t, pid, struct sched_param __user *, param) : 
2
str : 	struct sched_param lp = { .sched_priority = 0 };[49]
strstr : INIT : 	struct sched_param lp = { .sched_priority = 0 }; : 
2
strstr : if : 	struct sched_param lp = { .sched_priority = 0 }; : 
2
strstr : for : 	struct sched_param lp = { .sched_priority = 0 }; : 
2
strstr : while : 	struct sched_param lp = { .sched_priority = 0 }; : 
2
str : 	struct task_struct *p;[23]
strstr : INIT : 	struct task_struct *p; : 
2
strstr : if : 	struct task_struct *p; : 
2
strstr : for : 	struct task_struct *p; : 
2
strstr : while : 	struct task_struct *p; : 
2
str : 	int retval;[12]
strstr : INIT : 	int retval; : 
2
strstr : if : 	int retval; : 
2
strstr : for : 	int retval; : 
2
strstr : while : 	int retval; : 
2
str : 	if (!param || pid < 0)[23]
strstr : INIT : 	if (!param || pid < 0) : 
2
strstr : if : 	if (!param || pid < 0) : 
2
strstr : for : 	if (!param || pid < 0) : 
2
strstr : while : 	if (!param || pid < 0) : 
2
str : 		return -EINVAL;[17]
strstr : INIT : 		return -EINVAL; : 
2
strstr : if : 		return -EINVAL; : 
2
strstr : for : 		return -EINVAL; : 
2
strstr : while : 		return -EINVAL; : 
2
str : 	rcu_read_lock();[17]
strstr : INIT : 	rcu_read_lock(); : 
2
strstr : if : 	rcu_read_lock(); : 
2
strstr : for : 	rcu_read_lock(); : 
2
strstr : while : 	rcu_read_lock(); : 
2
str : 	p = find_process_by_pid(pid);[30]
strstr : INIT : 	p = find_process_by_pid(pid); : 
2
strstr : if : 	p = find_process_by_pid(pid); : 
2
strstr : for : 	p = find_process_by_pid(pid); : 
2
strstr : while : 	p = find_process_by_pid(pid); : 
2
str : 	retval = -ESRCH;[17]
strstr : INIT : 	retval = -ESRCH; : 
2
strstr : if : 	retval = -ESRCH; : 
2
strstr : for : 	retval = -ESRCH; : 
2
strstr : while : 	retval = -ESRCH; : 
2
str : 	if (!p)[8]
strstr : INIT : 	if (!p) : 
2
strstr : if : 	if (!p) : 
2
strstr : for : 	if (!p) : 
2
strstr : while : 	if (!p) : 
2
str : 		goto out_unlock;[18]
strstr : INIT : 		goto out_unlock; : 
2
strstr : if : 		goto out_unlock; : 
2
strstr : for : 		goto out_unlock; : 
2
strstr : while : 		goto out_unlock; : 
2
str : 	retval = security_task_getscheduler(p);[40]
strstr : INIT : 	retval = security_task_getscheduler(p); : 
2
strstr : if : 	retval = security_task_getscheduler(p); : 
2
strstr : for : 	retval = security_task_getscheduler(p); : 
2
strstr : while : 	retval = security_task_getscheduler(p); : 
2
str : 	if (retval)[12]
strstr : INIT : 	if (retval) : 
2
strstr : if : 	if (retval) : 
2
strstr : for : 	if (retval) : 
2
strstr : while : 	if (retval) : 
2
str : 		goto out_unlock;[18]
strstr : INIT : 		goto out_unlock; : 
2
strstr : if : 		goto out_unlock; : 
2
strstr : for : 		goto out_unlock; : 
2
strstr : while : 		goto out_unlock; : 
2
str : 	if (task_has_rt_policy(p))[27]
strstr : INIT : 	if (task_has_rt_policy(p)) : 
2
strstr : if : 	if (task_has_rt_policy(p)) : 
2
strstr : for : 	if (task_has_rt_policy(p)) : 
2
strstr : while : 	if (task_has_rt_policy(p)) : 
2
str : 		lp.sched_priority = p->rt_priority;[37]
strstr : INIT : 		lp.sched_priority = p->rt_priority; : 
2
strstr : if : 		lp.sched_priority = p->rt_priority; : 
2
strstr : for : 		lp.sched_priority = p->rt_priority; : 
2
strstr : while : 		lp.sched_priority = p->rt_priority; : 
2
str : 	rcu_read_unlock();[19]
strstr : INIT : 	rcu_read_unlock(); : 
2
strstr : if : 	rcu_read_unlock(); : 
2
strstr : for : 	rcu_read_unlock(); : 
2
strstr : while : 	rcu_read_unlock(); : 
2
str : 	/*[3]
strstr : INIT : 	/* : 
2
strstr : if : 	/* : 
2
strstr : for : 	/* : 
2
strstr : while : 	/* : 
2
str : 	 * This one might sleep, we cannot do it with a spinlock held ...[66]
strstr : INIT : 	 * This one might sleep, we cannot do it with a spinlock held ... : 
2
strstr : if : 	 * This one might sleep, we cannot do it with a spinlock held ... : 
2
strstr : for : 	 * This one might sleep, we cannot do it with a spinlock held ... : 
2
strstr : while : 	 * This one might sleep, we cannot do it with a spinlock held ... : 
2
str : 	 */[4]
strstr : INIT : 	 */ : 
2
strstr : if : 	 */ : 
2
strstr : for : 	 */ : 
2
strstr : while : 	 */ : 
2
str : 	retval = copy_to_user(param, &lp, sizeof(*param)) ? -EFAULT : 0;[65]
strstr : INIT : 	retval = copy_to_user(param, &lp, sizeof(*param)) ? -EFAULT : 0; : 
2
strstr : if : 	retval = copy_to_user(param, &lp, sizeof(*param)) ? -EFAULT : 0; : 
2
strstr : for : 	retval = copy_to_user(param, &lp, sizeof(*param)) ? -EFAULT : 0; : 
2
strstr : while : 	retval = copy_to_user(param, &lp, sizeof(*param)) ? -EFAULT : 0; : 
2
str : 	return retval;[15]
strstr : INIT : 	return retval; : 
2
strstr : if : 	return retval; : 
2
strstr : for : 	return retval; : 
2
strstr : while : 	return retval; : 
2
str : out_unlock:[11]
strstr : INIT : out_unlock: : 
2
strstr : if : out_unlock: : 
2
strstr : for : out_unlock: : 
2
strstr : while : out_unlock: : 
2
str : 	rcu_read_unlock();[19]
strstr : INIT : 	rcu_read_unlock(); : 
2
strstr : if : 	rcu_read_unlock(); : 
2
strstr : for : 	rcu_read_unlock(); : 
2
strstr : while : 	rcu_read_unlock(); : 
2
str : 	return retval;[15]
strstr : INIT : 	return retval; : 
2
strstr : if : 	return retval; : 
2
strstr : for : 	return retval; : 
2
strstr : while : 	return retval; : 
2
str : static int sched_read_attr(struct sched_attr __user *uattr,[59]
strstr : INIT : static int sched_read_attr(struct sched_attr __user *uattr, : 
2
strstr : if : static int sched_read_attr(struct sched_attr __user *uattr, : 
2
strstr : for : static int sched_read_attr(struct sched_attr __user *uattr, : 
2
strstr : while : static int sched_read_attr(struct sched_attr __user *uattr, : 
2
str : 			   struct sched_attr *attr,[30]
strstr : INIT : 			   struct sched_attr *attr, : 
2
strstr : if : 			   struct sched_attr *attr, : 
2
strstr : for : 			   struct sched_attr *attr, : 
2
strstr : while : 			   struct sched_attr *attr, : 
2
str : 			   unsigned int usize)[25]
strstr : INIT : 			   unsigned int usize) : 
2
strstr : if : 			   unsigned int usize) : 
2
strstr : for : 			   unsigned int usize) : 
2
strstr : while : 			   unsigned int usize) : 
2
str : 	int ret;[9]
strstr : INIT : 	int ret; : 
2
strstr : if : 	int ret; : 
2
strstr : for : 	int ret; : 
2
strstr : while : 	int ret; : 
2
str : 	if (!access_ok(VERIFY_WRITE, uattr, usize))[44]
strstr : INIT : 	if (!access_ok(VERIFY_WRITE, uattr, usize)) : 
2
strstr : if : 	if (!access_ok(VERIFY_WRITE, uattr, usize)) : 
2
strstr : for : 	if (!access_ok(VERIFY_WRITE, uattr, usize)) : 
2
strstr : while : 	if (!access_ok(VERIFY_WRITE, uattr, usize)) : 
2
str : 		return -EFAULT;[17]
strstr : INIT : 		return -EFAULT; : 
2
strstr : if : 		return -EFAULT; : 
2
strstr : for : 		return -EFAULT; : 
2
strstr : while : 		return -EFAULT; : 
2
str : 	/*[3]
strstr : INIT : 	/* : 
2
strstr : if : 	/* : 
2
strstr : for : 	/* : 
2
strstr : while : 	/* : 
2
str : 	 * If we're handed a smaller struct than we know of,[53]
strstr : INIT : 	 * If we're handed a smaller struct than we know of, : 
2
strstr : if : 	 * If we're handed a smaller struct than we know of, : 
2
strstr : for : 	 * If we're handed a smaller struct than we know of, : 
2
strstr : while : 	 * If we're handed a smaller struct than we know of, : 
2
str : 	 * ensure all the unknown bits are 0 - i.e. old[48]
strstr : INIT : 	 * ensure all the unknown bits are 0 - i.e. old : 
2
strstr : if : 	 * ensure all the unknown bits are 0 - i.e. old : 
2
strstr : for : 	 * ensure all the unknown bits are 0 - i.e. old : 
2
strstr : while : 	 * ensure all the unknown bits are 0 - i.e. old : 
2
str : 	 * user-space does not get uncomplete information.[51]
strstr : INIT : 	 * user-space does not get uncomplete information. : 
2
strstr : if : 	 * user-space does not get uncomplete information. : 
2
strstr : for : 	 * user-space does not get uncomplete information. : 
2
strstr : while : 	 * user-space does not get uncomplete information. : 
2
str : 	 */[4]
strstr : INIT : 	 */ : 
2
strstr : if : 	 */ : 
2
strstr : for : 	 */ : 
2
strstr : while : 	 */ : 
2
str : 	if (usize < sizeof(*attr)) {[29]
strstr : INIT : 	if (usize < sizeof(*attr)) { : 
2
strstr : if : 	if (usize < sizeof(*attr)) { : 
2
strstr : for : 	if (usize < sizeof(*attr)) { : 
2
strstr : while : 	if (usize < sizeof(*attr)) { : 
2
str : 		unsigned char *addr;[22]
strstr : INIT : 		unsigned char *addr; : 
2
strstr : if : 		unsigned char *addr; : 
2
strstr : for : 		unsigned char *addr; : 
2
strstr : while : 		unsigned char *addr; : 
2
str : 		unsigned char *end;[21]
strstr : INIT : 		unsigned char *end; : 
2
strstr : if : 		unsigned char *end; : 
2
strstr : for : 		unsigned char *end; : 
2
strstr : while : 		unsigned char *end; : 
2
str : 		addr = (void *)attr + usize;[30]
strstr : INIT : 		addr = (void *)attr + usize; : 
2
strstr : if : 		addr = (void *)attr + usize; : 
2
strstr : for : 		addr = (void *)attr + usize; : 
2
strstr : while : 		addr = (void *)attr + usize; : 
2
str : 		end  = (void *)attr + sizeof(*attr);[38]
strstr : INIT : 		end  = (void *)attr + sizeof(*attr); : 
2
strstr : if : 		end  = (void *)attr + sizeof(*attr); : 
2
strstr : for : 		end  = (void *)attr + sizeof(*attr); : 
2
strstr : while : 		end  = (void *)attr + sizeof(*attr); : 
2
str : 		for (; addr < end; addr++) {[30]
strstr : INIT : 		for (; addr < end; addr++) { : 
2
strstr : if : 		for (; addr < end; addr++) { : 
2
strstr : for : 		for (; addr < end; addr++) { : 
2
strstr : while : 		for (; addr < end; addr++) { : 
2
str : 			if (*addr)[13]
strstr : INIT : 			if (*addr) : 
2
strstr : if : 			if (*addr) : 
2
strstr : for : 			if (*addr) : 
2
strstr : while : 			if (*addr) : 
2
str : 				goto err_size;[18]
strstr : INIT : 				goto err_size; : 
2
strstr : if : 				goto err_size; : 
2
strstr : for : 				goto err_size; : 
2
strstr : while : 				goto err_size; : 
2
str : 		}[3]
strstr : INIT : 		} : 
2
strstr : if : 		} : 
2
strstr : for : 		} : 
2
strstr : while : 		} : 
2
str : 		attr->size = usize;[21]
strstr : INIT : 		attr->size = usize; : 
2
strstr : if : 		attr->size = usize; : 
2
strstr : for : 		attr->size = usize; : 
2
strstr : while : 		attr->size = usize; : 
2
str : 	ret = copy_to_user(uattr, attr, attr->size);[45]
strstr : INIT : 	ret = copy_to_user(uattr, attr, attr->size); : 
2
strstr : if : 	ret = copy_to_user(uattr, attr, attr->size); : 
2
strstr : for : 	ret = copy_to_user(uattr, attr, attr->size); : 
2
strstr : while : 	ret = copy_to_user(uattr, attr, attr->size); : 
2
str : 	if (ret)[9]
strstr : INIT : 	if (ret) : 
2
strstr : if : 	if (ret) : 
2
strstr : for : 	if (ret) : 
2
strstr : while : 	if (ret) : 
2
str : 		return -EFAULT;[17]
strstr : INIT : 		return -EFAULT; : 
2
strstr : if : 		return -EFAULT; : 
2
strstr : for : 		return -EFAULT; : 
2
strstr : while : 		return -EFAULT; : 
2
str : out:[4]
strstr : INIT : out: : 
2
strstr : if : out: : 
2
strstr : for : out: : 
2
strstr : while : out: : 
2
str : 	return ret;[12]
strstr : INIT : 	return ret; : 
2
strstr : if : 	return ret; : 
2
strstr : for : 	return ret; : 
2
strstr : while : 	return ret; : 
2
str : err_size:[9]
strstr : INIT : err_size: : 
2
strstr : if : err_size: : 
2
strstr : for : err_size: : 
2
strstr : while : err_size: : 
2
str : 	ret = -E2BIG;[14]
strstr : INIT : 	ret = -E2BIG; : 
2
strstr : if : 	ret = -E2BIG; : 
2
strstr : for : 	ret = -E2BIG; : 
2
strstr : while : 	ret = -E2BIG; : 
2
str : 	goto out;[10]
strstr : INIT : 	goto out; : 
2
strstr : if : 	goto out; : 
2
strstr : for : 	goto out; : 
2
strstr : while : 	goto out; : 
2
str : /**[3]
strstr : INIT : /** : 
2
strstr : if : /** : 
2
strstr : for : /** : 
2
strstr : while : /** : 
2
str :  * sys_sched_getattr - similar to sched_getparam, but with sched_attr[69]
strstr : INIT :  * sys_sched_getattr - similar to sched_getparam, but with sched_attr : 
2
strstr : if :  * sys_sched_getattr - similar to sched_getparam, but with sched_attr : 
2
strstr : for :  * sys_sched_getattr - similar to sched_getparam, but with sched_attr : 
2
strstr : while :  * sys_sched_getattr - similar to sched_getparam, but with sched_attr : 
2
str :  * @pid: the pid in question.[29]
strstr : INIT :  * @pid: the pid in question. : 
2
strstr : if :  * @pid: the pid in question. : 
2
strstr : for :  * @pid: the pid in question. : 
2
strstr : while :  * @pid: the pid in question. : 
2
str :  * @uattr: structure containing the extended parameters.[56]
strstr : INIT :  * @uattr: structure containing the extended parameters. : 
2
strstr : if :  * @uattr: structure containing the extended parameters. : 
2
strstr : for :  * @uattr: structure containing the extended parameters. : 
2
strstr : while :  * @uattr: structure containing the extended parameters. : 
2
str :  * @size: sizeof(attr) for fwd/bwd comp.[40]
strstr : INIT :  * @size: sizeof(attr) for fwd/bwd comp. : 
2
strstr : if :  * @size: sizeof(attr) for fwd/bwd comp. : 
2
strstr : for :  * @size: sizeof(attr) for fwd/bwd comp. : 
2
strstr : while :  * @size: sizeof(attr) for fwd/bwd comp. : 
2
str :  */[3]
strstr : INIT :  */ : 
2
strstr : if :  */ : 
2
strstr : for :  */ : 
2
strstr : while :  */ : 
2
str : SYSCALL_DEFINE4(sched_getattr, pid_t, pid, struct sched_attr __user *, uattr,[77]
strstr : INIT : SYSCALL_DEFINE4(sched_getattr, pid_t, pid, struct sched_attr __user *, uattr, : 
2
strstr : if : SYSCALL_DEFINE4(sched_getattr, pid_t, pid, struct sched_attr __user *, uattr, : 
2
strstr : for : SYSCALL_DEFINE4(sched_getattr, pid_t, pid, struct sched_attr __user *, uattr, : 
2
strstr : while : SYSCALL_DEFINE4(sched_getattr, pid_t, pid, struct sched_attr __user *, uattr, : 
2
str : 		unsigned int, size, unsigned int, flags)[42]
strstr : INIT : 		unsigned int, size, unsigned int, flags) : 
2
strstr : if : 		unsigned int, size, unsigned int, flags) : 
2
strstr : for : 		unsigned int, size, unsigned int, flags) : 
2
strstr : while : 		unsigned int, size, unsigned int, flags) : 
2
str : 	struct sched_attr attr = {[27]
strstr : INIT : 	struct sched_attr attr = { : 
2
strstr : if : 	struct sched_attr attr = { : 
2
strstr : for : 	struct sched_attr attr = { : 
2
strstr : while : 	struct sched_attr attr = { : 
2
str : 		.size = sizeof(struct sched_attr),[36]
strstr : INIT : 		.size = sizeof(struct sched_attr), : 
2
strstr : if : 		.size = sizeof(struct sched_attr), : 
2
strstr : for : 		.size = sizeof(struct sched_attr), : 
2
strstr : while : 		.size = sizeof(struct sched_attr), : 
2
str : 	};[3]
strstr : INIT : 	}; : 
2
strstr : if : 	}; : 
2
strstr : for : 	}; : 
2
strstr : while : 	}; : 
2
str : 	struct task_struct *p;[23]
strstr : INIT : 	struct task_struct *p; : 
2
strstr : if : 	struct task_struct *p; : 
2
strstr : for : 	struct task_struct *p; : 
2
strstr : while : 	struct task_struct *p; : 
2
str : 	int retval;[12]
strstr : INIT : 	int retval; : 
2
strstr : if : 	int retval; : 
2
strstr : for : 	int retval; : 
2
strstr : while : 	int retval; : 
2
str : 	if (!uattr || pid < 0 || size > PAGE_SIZE ||[45]
strstr : INIT : 	if (!uattr || pid < 0 || size > PAGE_SIZE || : 
2
strstr : if : 	if (!uattr || pid < 0 || size > PAGE_SIZE || : 
2
strstr : for : 	if (!uattr || pid < 0 || size > PAGE_SIZE || : 
2
strstr : while : 	if (!uattr || pid < 0 || size > PAGE_SIZE || : 
2
str : 	    size < SCHED_ATTR_SIZE_VER0 || flags)[42]
strstr : INIT : 	    size < SCHED_ATTR_SIZE_VER0 || flags) : 
2
strstr : if : 	    size < SCHED_ATTR_SIZE_VER0 || flags) : 
2
strstr : for : 	    size < SCHED_ATTR_SIZE_VER0 || flags) : 
2
strstr : while : 	    size < SCHED_ATTR_SIZE_VER0 || flags) : 
2
str : 		return -EINVAL;[17]
strstr : INIT : 		return -EINVAL; : 
2
strstr : if : 		return -EINVAL; : 
2
strstr : for : 		return -EINVAL; : 
2
strstr : while : 		return -EINVAL; : 
2
str : 	rcu_read_lock();[17]
strstr : INIT : 	rcu_read_lock(); : 
2
strstr : if : 	rcu_read_lock(); : 
2
strstr : for : 	rcu_read_lock(); : 
2
strstr : while : 	rcu_read_lock(); : 
2
str : 	p = find_process_by_pid(pid);[30]
strstr : INIT : 	p = find_process_by_pid(pid); : 
2
strstr : if : 	p = find_process_by_pid(pid); : 
2
strstr : for : 	p = find_process_by_pid(pid); : 
2
strstr : while : 	p = find_process_by_pid(pid); : 
2
str : 	retval = -ESRCH;[17]
strstr : INIT : 	retval = -ESRCH; : 
2
strstr : if : 	retval = -ESRCH; : 
2
strstr : for : 	retval = -ESRCH; : 
2
strstr : while : 	retval = -ESRCH; : 
2
str : 	if (!p)[8]
strstr : INIT : 	if (!p) : 
2
strstr : if : 	if (!p) : 
2
strstr : for : 	if (!p) : 
2
strstr : while : 	if (!p) : 
2
str : 		goto out_unlock;[18]
strstr : INIT : 		goto out_unlock; : 
2
strstr : if : 		goto out_unlock; : 
2
strstr : for : 		goto out_unlock; : 
2
strstr : while : 		goto out_unlock; : 
2
str : 	retval = security_task_getscheduler(p);[40]
strstr : INIT : 	retval = security_task_getscheduler(p); : 
2
strstr : if : 	retval = security_task_getscheduler(p); : 
2
strstr : for : 	retval = security_task_getscheduler(p); : 
2
strstr : while : 	retval = security_task_getscheduler(p); : 
2
str : 	if (retval)[12]
strstr : INIT : 	if (retval) : 
2
strstr : if : 	if (retval) : 
2
strstr : for : 	if (retval) : 
2
strstr : while : 	if (retval) : 
2
str : 		goto out_unlock;[18]
strstr : INIT : 		goto out_unlock; : 
2
strstr : if : 		goto out_unlock; : 
2
strstr : for : 		goto out_unlock; : 
2
strstr : while : 		goto out_unlock; : 
2
str : 	attr.sched_policy = p->policy;[31]
strstr : INIT : 	attr.sched_policy = p->policy; : 
2
strstr : if : 	attr.sched_policy = p->policy; : 
2
strstr : for : 	attr.sched_policy = p->policy; : 
2
strstr : while : 	attr.sched_policy = p->policy; : 
2
str : 	if (p->sched_reset_on_fork)[28]
strstr : INIT : 	if (p->sched_reset_on_fork) : 
2
strstr : if : 	if (p->sched_reset_on_fork) : 
2
strstr : for : 	if (p->sched_reset_on_fork) : 
2
strstr : while : 	if (p->sched_reset_on_fork) : 
2
str : 		attr.sched_flags |= SCHED_FLAG_RESET_ON_FORK;[47]
strstr : INIT : 		attr.sched_flags |= SCHED_FLAG_RESET_ON_FORK; : 
2
strstr : if : 		attr.sched_flags |= SCHED_FLAG_RESET_ON_FORK; : 
2
strstr : for : 		attr.sched_flags |= SCHED_FLAG_RESET_ON_FORK; : 
2
strstr : while : 		attr.sched_flags |= SCHED_FLAG_RESET_ON_FORK; : 
2
str : 	if (task_has_dl_policy(p))[27]
strstr : INIT : 	if (task_has_dl_policy(p)) : 
2
strstr : if : 	if (task_has_dl_policy(p)) : 
2
strstr : for : 	if (task_has_dl_policy(p)) : 
2
strstr : while : 	if (task_has_dl_policy(p)) : 
2
str : 		__getparam_dl(p, &attr);[26]
strstr : INIT : 		__getparam_dl(p, &attr); : 
2
strstr : if : 		__getparam_dl(p, &attr); : 
2
strstr : for : 		__getparam_dl(p, &attr); : 
2
strstr : while : 		__getparam_dl(p, &attr); : 
2
str : 	else if (task_has_rt_policy(p))[32]
strstr : INIT : 	else if (task_has_rt_policy(p)) : 
2
strstr : if : 	else if (task_has_rt_policy(p)) : 
2
strstr : for : 	else if (task_has_rt_policy(p)) : 
2
strstr : while : 	else if (task_has_rt_policy(p)) : 
2
str : 		attr.sched_priority = p->rt_priority;[39]
strstr : INIT : 		attr.sched_priority = p->rt_priority; : 
2
strstr : if : 		attr.sched_priority = p->rt_priority; : 
2
strstr : for : 		attr.sched_priority = p->rt_priority; : 
2
strstr : while : 		attr.sched_priority = p->rt_priority; : 
2
str : 	else[5]
strstr : INIT : 	else : 
2
strstr : if : 	else : 
2
strstr : for : 	else : 
2
strstr : while : 	else : 
2
str : 		attr.sched_nice = TASK_NICE(p);[33]
strstr : INIT : 		attr.sched_nice = TASK_NICE(p); : 
2
strstr : if : 		attr.sched_nice = TASK_NICE(p); : 
2
strstr : for : 		attr.sched_nice = TASK_NICE(p); : 
2
strstr : while : 		attr.sched_nice = TASK_NICE(p); : 
2
str : 	rcu_read_unlock();[19]
strstr : INIT : 	rcu_read_unlock(); : 
2
strstr : if : 	rcu_read_unlock(); : 
2
strstr : for : 	rcu_read_unlock(); : 
2
strstr : while : 	rcu_read_unlock(); : 
2
str : 	retval = sched_read_attr(uattr, &attr, size);[46]
strstr : INIT : 	retval = sched_read_attr(uattr, &attr, size); : 
2
strstr : if : 	retval = sched_read_attr(uattr, &attr, size); : 
2
strstr : for : 	retval = sched_read_attr(uattr, &attr, size); : 
2
strstr : while : 	retval = sched_read_attr(uattr, &attr, size); : 
2
str : 	return retval;[15]
strstr : INIT : 	return retval; : 
2
strstr : if : 	return retval; : 
2
strstr : for : 	return retval; : 
2
strstr : while : 	return retval; : 
2
str : out_unlock:[11]
strstr : INIT : out_unlock: : 
2
strstr : if : out_unlock: : 
2
strstr : for : out_unlock: : 
2
strstr : while : out_unlock: : 
2
str : 	rcu_read_unlock();[19]
strstr : INIT : 	rcu_read_unlock(); : 
2
strstr : if : 	rcu_read_unlock(); : 
2
strstr : for : 	rcu_read_unlock(); : 
2
strstr : while : 	rcu_read_unlock(); : 
2
str : 	return retval;[15]
strstr : INIT : 	return retval; : 
2
strstr : if : 	return retval; : 
2
strstr : for : 	return retval; : 
2
strstr : while : 	return retval; : 
2
str : long sched_setaffinity(pid_t pid, const struct cpumask *in_mask)[64]
strstr : INIT : long sched_setaffinity(pid_t pid, const struct cpumask *in_mask) : 
2
strstr : if : long sched_setaffinity(pid_t pid, const struct cpumask *in_mask) : 
2
strstr : for : long sched_setaffinity(pid_t pid, const struct cpumask *in_mask) : 
2
strstr : while : long sched_setaffinity(pid_t pid, const struct cpumask *in_mask) : 
2
str : 	cpumask_var_t cpus_allowed, new_mask;[38]
strstr : INIT : 	cpumask_var_t cpus_allowed, new_mask; : 
2
strstr : if : 	cpumask_var_t cpus_allowed, new_mask; : 
2
strstr : for : 	cpumask_var_t cpus_allowed, new_mask; : 
2
strstr : while : 	cpumask_var_t cpus_allowed, new_mask; : 
2
str : 	struct task_struct *p;[23]
strstr : INIT : 	struct task_struct *p; : 
2
strstr : if : 	struct task_struct *p; : 
2
strstr : for : 	struct task_struct *p; : 
2
strstr : while : 	struct task_struct *p; : 
2
str : 	int retval;[12]
strstr : INIT : 	int retval; : 
2
strstr : if : 	int retval; : 
2
strstr : for : 	int retval; : 
2
strstr : while : 	int retval; : 
2
str : 	rcu_read_lock();[17]
strstr : INIT : 	rcu_read_lock(); : 
2
strstr : if : 	rcu_read_lock(); : 
2
strstr : for : 	rcu_read_lock(); : 
2
strstr : while : 	rcu_read_lock(); : 
2
str : 	p = find_process_by_pid(pid);[30]
strstr : INIT : 	p = find_process_by_pid(pid); : 
2
strstr : if : 	p = find_process_by_pid(pid); : 
2
strstr : for : 	p = find_process_by_pid(pid); : 
2
strstr : while : 	p = find_process_by_pid(pid); : 
2
str : 	if (!p) {[10]
strstr : INIT : 	if (!p) { : 
2
strstr : if : 	if (!p) { : 
2
strstr : for : 	if (!p) { : 
2
strstr : while : 	if (!p) { : 
2
str : 		rcu_read_unlock();[20]
strstr : INIT : 		rcu_read_unlock(); : 
2
strstr : if : 		rcu_read_unlock(); : 
2
strstr : for : 		rcu_read_unlock(); : 
2
strstr : while : 		rcu_read_unlock(); : 
2
str : 		return -ESRCH;[16]
strstr : INIT : 		return -ESRCH; : 
2
strstr : if : 		return -ESRCH; : 
2
strstr : for : 		return -ESRCH; : 
2
strstr : while : 		return -ESRCH; : 
2
str : 	/* Prevent p going away */[27]
strstr : INIT : 	/* Prevent p going away */ : 
2
strstr : if : 	/* Prevent p going away */ : 
2
strstr : for : 	/* Prevent p going away */ : 
2
strstr : while : 	/* Prevent p going away */ : 
2
str : 	get_task_struct(p);[20]
strstr : INIT : 	get_task_struct(p); : 
2
strstr : if : 	get_task_struct(p); : 
2
strstr : for : 	get_task_struct(p); : 
2
strstr : while : 	get_task_struct(p); : 
2
str : 	rcu_read_unlock();[19]
strstr : INIT : 	rcu_read_unlock(); : 
2
strstr : if : 	rcu_read_unlock(); : 
2
strstr : for : 	rcu_read_unlock(); : 
2
strstr : while : 	rcu_read_unlock(); : 
2
str : 	if (p->flags & PF_NO_SETAFFINITY) {[36]
strstr : INIT : 	if (p->flags & PF_NO_SETAFFINITY) { : 
2
strstr : if : 	if (p->flags & PF_NO_SETAFFINITY) { : 
2
strstr : for : 	if (p->flags & PF_NO_SETAFFINITY) { : 
2
strstr : while : 	if (p->flags & PF_NO_SETAFFINITY) { : 
2
str : 		retval = -EINVAL;[19]
strstr : INIT : 		retval = -EINVAL; : 
2
strstr : if : 		retval = -EINVAL; : 
2
strstr : for : 		retval = -EINVAL; : 
2
strstr : while : 		retval = -EINVAL; : 
2
str : 		goto out_put_task;[20]
strstr : INIT : 		goto out_put_task; : 
2
strstr : if : 		goto out_put_task; : 
2
strstr : for : 		goto out_put_task; : 
2
strstr : while : 		goto out_put_task; : 
2
str : 	if (!alloc_cpumask_var(&cpus_allowed, GFP_KERNEL)) {[53]
strstr : INIT : 	if (!alloc_cpumask_var(&cpus_allowed, GFP_KERNEL)) { : 
2
strstr : if : 	if (!alloc_cpumask_var(&cpus_allowed, GFP_KERNEL)) { : 
2
strstr : for : 	if (!alloc_cpumask_var(&cpus_allowed, GFP_KERNEL)) { : 
2
strstr : while : 	if (!alloc_cpumask_var(&cpus_allowed, GFP_KERNEL)) { : 
2
str : 		retval = -ENOMEM;[19]
strstr : INIT : 		retval = -ENOMEM; : 
2
strstr : if : 		retval = -ENOMEM; : 
2
strstr : for : 		retval = -ENOMEM; : 
2
strstr : while : 		retval = -ENOMEM; : 
2
str : 		goto out_put_task;[20]
strstr : INIT : 		goto out_put_task; : 
2
strstr : if : 		goto out_put_task; : 
2
strstr : for : 		goto out_put_task; : 
2
strstr : while : 		goto out_put_task; : 
2
str : 	if (!alloc_cpumask_var(&new_mask, GFP_KERNEL)) {[49]
strstr : INIT : 	if (!alloc_cpumask_var(&new_mask, GFP_KERNEL)) { : 
2
strstr : if : 	if (!alloc_cpumask_var(&new_mask, GFP_KERNEL)) { : 
2
strstr : for : 	if (!alloc_cpumask_var(&new_mask, GFP_KERNEL)) { : 
2
strstr : while : 	if (!alloc_cpumask_var(&new_mask, GFP_KERNEL)) { : 
2
str : 		retval = -ENOMEM;[19]
strstr : INIT : 		retval = -ENOMEM; : 
2
strstr : if : 		retval = -ENOMEM; : 
2
strstr : for : 		retval = -ENOMEM; : 
2
strstr : while : 		retval = -ENOMEM; : 
2
str : 		goto out_free_cpus_allowed;[29]
strstr : INIT : 		goto out_free_cpus_allowed; : 
2
strstr : if : 		goto out_free_cpus_allowed; : 
2
strstr : for : 		goto out_free_cpus_allowed; : 
2
strstr : while : 		goto out_free_cpus_allowed; : 
2
str : 	retval = -EPERM;[17]
strstr : INIT : 	retval = -EPERM; : 
2
strstr : if : 	retval = -EPERM; : 
2
strstr : for : 	retval = -EPERM; : 
2
strstr : while : 	retval = -EPERM; : 
2
str : 	if (!check_same_owner(p)) {[28]
strstr : INIT : 	if (!check_same_owner(p)) { : 
2
strstr : if : 	if (!check_same_owner(p)) { : 
2
strstr : for : 	if (!check_same_owner(p)) { : 
2
strstr : while : 	if (!check_same_owner(p)) { : 
2
str : 		rcu_read_lock();[18]
strstr : INIT : 		rcu_read_lock(); : 
2
strstr : if : 		rcu_read_lock(); : 
2
strstr : for : 		rcu_read_lock(); : 
2
strstr : while : 		rcu_read_lock(); : 
2
str : 		if (!ns_capable(__task_cred(p)->user_ns, CAP_SYS_NICE)) {[59]
strstr : INIT : 		if (!ns_capable(__task_cred(p)->user_ns, CAP_SYS_NICE)) { : 
2
strstr : if : 		if (!ns_capable(__task_cred(p)->user_ns, CAP_SYS_NICE)) { : 
2
strstr : for : 		if (!ns_capable(__task_cred(p)->user_ns, CAP_SYS_NICE)) { : 
2
strstr : while : 		if (!ns_capable(__task_cred(p)->user_ns, CAP_SYS_NICE)) { : 
2
str : 			rcu_read_unlock();[21]
strstr : INIT : 			rcu_read_unlock(); : 
2
strstr : if : 			rcu_read_unlock(); : 
2
strstr : for : 			rcu_read_unlock(); : 
2
strstr : while : 			rcu_read_unlock(); : 
2
str : 			goto out_unlock;[19]
strstr : INIT : 			goto out_unlock; : 
2
strstr : if : 			goto out_unlock; : 
2
strstr : for : 			goto out_unlock; : 
2
strstr : while : 			goto out_unlock; : 
2
str : 		}[3]
strstr : INIT : 		} : 
2
strstr : if : 		} : 
2
strstr : for : 		} : 
2
strstr : while : 		} : 
2
str : 		rcu_read_unlock();[20]
strstr : INIT : 		rcu_read_unlock(); : 
2
strstr : if : 		rcu_read_unlock(); : 
2
strstr : for : 		rcu_read_unlock(); : 
2
strstr : while : 		rcu_read_unlock(); : 
2
str : 	retval = security_task_setscheduler(p);[40]
strstr : INIT : 	retval = security_task_setscheduler(p); : 
2
strstr : if : 	retval = security_task_setscheduler(p); : 
2
strstr : for : 	retval = security_task_setscheduler(p); : 
2
strstr : while : 	retval = security_task_setscheduler(p); : 
2
str : 	if (retval)[12]
strstr : INIT : 	if (retval) : 
2
strstr : if : 	if (retval) : 
2
strstr : for : 	if (retval) : 
2
strstr : while : 	if (retval) : 
2
str : 		goto out_unlock;[18]
strstr : INIT : 		goto out_unlock; : 
2
strstr : if : 		goto out_unlock; : 
2
strstr : for : 		goto out_unlock; : 
2
strstr : while : 		goto out_unlock; : 
2
str : 	cpuset_cpus_allowed(p, cpus_allowed);[38]
strstr : INIT : 	cpuset_cpus_allowed(p, cpus_allowed); : 
2
strstr : if : 	cpuset_cpus_allowed(p, cpus_allowed); : 
2
strstr : for : 	cpuset_cpus_allowed(p, cpus_allowed); : 
2
strstr : while : 	cpuset_cpus_allowed(p, cpus_allowed); : 
2
str : 	cpumask_and(new_mask, in_mask, cpus_allowed);[46]
strstr : INIT : 	cpumask_and(new_mask, in_mask, cpus_allowed); : 
2
strstr : if : 	cpumask_and(new_mask, in_mask, cpus_allowed); : 
2
strstr : for : 	cpumask_and(new_mask, in_mask, cpus_allowed); : 
2
strstr : while : 	cpumask_and(new_mask, in_mask, cpus_allowed); : 
2
str : 	/*[3]
strstr : INIT : 	/* : 
2
strstr : if : 	/* : 
2
strstr : for : 	/* : 
2
strstr : while : 	/* : 
2
str : 	 * Since bandwidth control happens on root_domain basis,[57]
strstr : INIT : 	 * Since bandwidth control happens on root_domain basis, : 
2
strstr : if : 	 * Since bandwidth control happens on root_domain basis, : 
2
strstr : for : 	 * Since bandwidth control happens on root_domain basis, : 
2
strstr : while : 	 * Since bandwidth control happens on root_domain basis, : 
2
str : 	 * if admission test is enabled, we only admit -deadline[57]
strstr : INIT : 	 * if admission test is enabled, we only admit -deadline : 
2
strstr : if : 	 * if admission test is enabled, we only admit -deadline : 
2
strstr : for : 	 * if admission test is enabled, we only admit -deadline : 
2
strstr : while : 	 * if admission test is enabled, we only admit -deadline : 
2
str : 	 * tasks allowed to run on all the CPUs in the task's[54]
strstr : INIT : 	 * tasks allowed to run on all the CPUs in the task's : 
2
strstr : if : 	 * tasks allowed to run on all the CPUs in the task's : 
2
strstr : for : 	 * tasks allowed to run on all the CPUs in the task's : 
2
strstr : while : 	 * tasks allowed to run on all the CPUs in the task's : 
2
str : 	 * root_domain.[16]
strstr : INIT : 	 * root_domain. : 
2
strstr : if : 	 * root_domain. : 
2
strstr : for : 	 * root_domain. : 
2
strstr : while : 	 * root_domain. : 
2
str : 	 */[4]
strstr : INIT : 	 */ : 
2
strstr : if : 	 */ : 
2
strstr : for : 	 */ : 
2
strstr : while : 	 */ : 
2
str : #ifdef CONFIG_SMP[17]
strstr : INIT : #ifdef CONFIG_SMP : 
2
strstr : if : #ifdef CONFIG_SMP : 
2
strstr : for : #ifdef CONFIG_SMP : 
2
strstr : while : #ifdef CONFIG_SMP : 
2
str : 	if (task_has_dl_policy(p)) {[29]
strstr : INIT : 	if (task_has_dl_policy(p)) { : 
2
strstr : if : 	if (task_has_dl_policy(p)) { : 
2
strstr : for : 	if (task_has_dl_policy(p)) { : 
2
strstr : while : 	if (task_has_dl_policy(p)) { : 
2
str : 		const struct cpumask *span = task_rq(p)->rd->span;[52]
strstr : INIT : 		const struct cpumask *span = task_rq(p)->rd->span; : 
2
strstr : if : 		const struct cpumask *span = task_rq(p)->rd->span; : 
2
strstr : for : 		const struct cpumask *span = task_rq(p)->rd->span; : 
2
strstr : while : 		const struct cpumask *span = task_rq(p)->rd->span; : 
2
str : 		if (dl_bandwidth_enabled() && !cpumask_subset(span, new_mask)) {[66]
strstr : INIT : 		if (dl_bandwidth_enabled() && !cpumask_subset(span, new_mask)) { : 
2
strstr : if : 		if (dl_bandwidth_enabled() && !cpumask_subset(span, new_mask)) { : 
2
strstr : for : 		if (dl_bandwidth_enabled() && !cpumask_subset(span, new_mask)) { : 
2
strstr : while : 		if (dl_bandwidth_enabled() && !cpumask_subset(span, new_mask)) { : 
2
str : 			retval = -EBUSY;[19]
strstr : INIT : 			retval = -EBUSY; : 
2
strstr : if : 			retval = -EBUSY; : 
2
strstr : for : 			retval = -EBUSY; : 
2
strstr : while : 			retval = -EBUSY; : 
2
str : 			goto out_unlock;[19]
strstr : INIT : 			goto out_unlock; : 
2
strstr : if : 			goto out_unlock; : 
2
strstr : for : 			goto out_unlock; : 
2
strstr : while : 			goto out_unlock; : 
2
str : 		}[3]
strstr : INIT : 		} : 
2
strstr : if : 		} : 
2
strstr : for : 		} : 
2
strstr : while : 		} : 
2
str : #endif[6]
strstr : INIT : #endif : 
2
strstr : if : #endif : 
2
strstr : for : #endif : 
2
strstr : while : #endif : 
2
str : again:[6]
strstr : INIT : again: : 
2
strstr : if : again: : 
2
strstr : for : again: : 
2
strstr : while : again: : 
2
str : 	retval = set_cpus_allowed_ptr(p, new_mask);[44]
strstr : INIT : 	retval = set_cpus_allowed_ptr(p, new_mask); : 
2
strstr : if : 	retval = set_cpus_allowed_ptr(p, new_mask); : 
2
strstr : for : 	retval = set_cpus_allowed_ptr(p, new_mask); : 
2
strstr : while : 	retval = set_cpus_allowed_ptr(p, new_mask); : 
2
str : 	if (!retval) {[15]
strstr : INIT : 	if (!retval) { : 
2
strstr : if : 	if (!retval) { : 
2
strstr : for : 	if (!retval) { : 
2
strstr : while : 	if (!retval) { : 
2
str : 		cpuset_cpus_allowed(p, cpus_allowed);[39]
strstr : INIT : 		cpuset_cpus_allowed(p, cpus_allowed); : 
2
strstr : if : 		cpuset_cpus_allowed(p, cpus_allowed); : 
2
strstr : for : 		cpuset_cpus_allowed(p, cpus_allowed); : 
2
strstr : while : 		cpuset_cpus_allowed(p, cpus_allowed); : 
2
str : 		if (!cpumask_subset(new_mask, cpus_allowed)) {[48]
strstr : INIT : 		if (!cpumask_subset(new_mask, cpus_allowed)) { : 
2
strstr : if : 		if (!cpumask_subset(new_mask, cpus_allowed)) { : 
2
strstr : for : 		if (!cpumask_subset(new_mask, cpus_allowed)) { : 
2
strstr : while : 		if (!cpumask_subset(new_mask, cpus_allowed)) { : 
2
str : 			/*[5]
strstr : INIT : 			/* : 
2
strstr : if : 			/* : 
2
strstr : for : 			/* : 
2
strstr : while : 			/* : 
2
str : 			 * We must have raced with a concurrent cpuset[49]
strstr : INIT : 			 * We must have raced with a concurrent cpuset : 
2
strstr : if : 			 * We must have raced with a concurrent cpuset : 
2
strstr : for : 			 * We must have raced with a concurrent cpuset : 
2
strstr : while : 			 * We must have raced with a concurrent cpuset : 
2
str : 			 * update. Just reset the cpus_allowed to the[48]
strstr : INIT : 			 * update. Just reset the cpus_allowed to the : 
2
strstr : if : 			 * update. Just reset the cpus_allowed to the : 
2
strstr : for : 			 * update. Just reset the cpus_allowed to the : 
2
strstr : while : 			 * update. Just reset the cpus_allowed to the : 
2
str : 			 * cpuset's cpus_allowed[27]
strstr : INIT : 			 * cpuset's cpus_allowed : 
2
strstr : if : 			 * cpuset's cpus_allowed : 
2
strstr : for : 			 * cpuset's cpus_allowed : 
2
strstr : while : 			 * cpuset's cpus_allowed : 
2
str : 			 */[6]
strstr : INIT : 			 */ : 
2
strstr : if : 			 */ : 
2
strstr : for : 			 */ : 
2
strstr : while : 			 */ : 
2
str : 			cpumask_copy(new_mask, cpus_allowed);[40]
strstr : INIT : 			cpumask_copy(new_mask, cpus_allowed); : 
2
strstr : if : 			cpumask_copy(new_mask, cpus_allowed); : 
2
strstr : for : 			cpumask_copy(new_mask, cpus_allowed); : 
2
strstr : while : 			cpumask_copy(new_mask, cpus_allowed); : 
2
str : 			goto again;[14]
strstr : INIT : 			goto again; : 
2
strstr : if : 			goto again; : 
2
strstr : for : 			goto again; : 
2
strstr : while : 			goto again; : 
2
str : 		}[3]
strstr : INIT : 		} : 
2
strstr : if : 		} : 
2
strstr : for : 		} : 
2
strstr : while : 		} : 
2
str : out_unlock:[11]
strstr : INIT : out_unlock: : 
2
strstr : if : out_unlock: : 
2
strstr : for : out_unlock: : 
2
strstr : while : out_unlock: : 
2
str : 	free_cpumask_var(new_mask);[28]
strstr : INIT : 	free_cpumask_var(new_mask); : 
2
strstr : if : 	free_cpumask_var(new_mask); : 
2
strstr : for : 	free_cpumask_var(new_mask); : 
2
strstr : while : 	free_cpumask_var(new_mask); : 
2
str : out_free_cpus_allowed:[22]
strstr : INIT : out_free_cpus_allowed: : 
2
strstr : if : out_free_cpus_allowed: : 
2
strstr : for : out_free_cpus_allowed: : 
2
strstr : while : out_free_cpus_allowed: : 
2
str : 	free_cpumask_var(cpus_allowed);[32]
strstr : INIT : 	free_cpumask_var(cpus_allowed); : 
2
strstr : if : 	free_cpumask_var(cpus_allowed); : 
2
strstr : for : 	free_cpumask_var(cpus_allowed); : 
2
strstr : while : 	free_cpumask_var(cpus_allowed); : 
2
str : out_put_task:[13]
strstr : INIT : out_put_task: : 
2
strstr : if : out_put_task: : 
2
strstr : for : out_put_task: : 
2
strstr : while : out_put_task: : 
2
str : 	put_task_struct(p);[20]
strstr : INIT : 	put_task_struct(p); : 
2
strstr : if : 	put_task_struct(p); : 
2
strstr : for : 	put_task_struct(p); : 
2
strstr : while : 	put_task_struct(p); : 
2
str : 	return retval;[15]
strstr : INIT : 	return retval; : 
2
strstr : if : 	return retval; : 
2
strstr : for : 	return retval; : 
2
strstr : while : 	return retval; : 
2
str : static int get_user_cpu_mask(unsigned long __user *user_mask_ptr, unsigned len,[79]
strstr : INIT : static int get_user_cpu_mask(unsigned long __user *user_mask_ptr, unsigned len, : 
2
strstr : if : static int get_user_cpu_mask(unsigned long __user *user_mask_ptr, unsigned len, : 
2
strstr : for : static int get_user_cpu_mask(unsigned long __user *user_mask_ptr, unsigned len, : 
2
strstr : while : static int get_user_cpu_mask(unsigned long __user *user_mask_ptr, unsigned len, : 
2
str : 			     struct cpumask *new_mask)[33]
strstr : INIT : 			     struct cpumask *new_mask) : 
2
strstr : if : 			     struct cpumask *new_mask) : 
2
strstr : for : 			     struct cpumask *new_mask) : 
2
strstr : while : 			     struct cpumask *new_mask) : 
2
str : 	if (len < cpumask_size())[26]
strstr : INIT : 	if (len < cpumask_size()) : 
2
strstr : if : 	if (len < cpumask_size()) : 
2
strstr : for : 	if (len < cpumask_size()) : 
2
strstr : while : 	if (len < cpumask_size()) : 
2
str : 		cpumask_clear(new_mask);[26]
strstr : INIT : 		cpumask_clear(new_mask); : 
2
strstr : if : 		cpumask_clear(new_mask); : 
2
strstr : for : 		cpumask_clear(new_mask); : 
2
strstr : while : 		cpumask_clear(new_mask); : 
2
str : 	else if (len > cpumask_size())[31]
strstr : INIT : 	else if (len > cpumask_size()) : 
2
strstr : if : 	else if (len > cpumask_size()) : 
2
strstr : for : 	else if (len > cpumask_size()) : 
2
strstr : while : 	else if (len > cpumask_size()) : 
2
str : 		len = cpumask_size();[23]
strstr : INIT : 		len = cpumask_size(); : 
2
strstr : if : 		len = cpumask_size(); : 
2
strstr : for : 		len = cpumask_size(); : 
2
strstr : while : 		len = cpumask_size(); : 
2
str : 	return copy_from_user(new_mask, user_mask_ptr, len) ? -EFAULT : 0;[67]
strstr : INIT : 	return copy_from_user(new_mask, user_mask_ptr, len) ? -EFAULT : 0; : 
2
strstr : if : 	return copy_from_user(new_mask, user_mask_ptr, len) ? -EFAULT : 0; : 
2
strstr : for : 	return copy_from_user(new_mask, user_mask_ptr, len) ? -EFAULT : 0; : 
2
strstr : while : 	return copy_from_user(new_mask, user_mask_ptr, len) ? -EFAULT : 0; : 
2
str : /**[3]
strstr : INIT : /** : 
2
strstr : if : /** : 
2
strstr : for : /** : 
2
strstr : while : /** : 
2
str :  * sys_sched_setaffinity - set the cpu affinity of a process[60]
strstr : INIT :  * sys_sched_setaffinity - set the cpu affinity of a process : 
2
strstr : if :  * sys_sched_setaffinity - set the cpu affinity of a process : 
2
strstr : for :  * sys_sched_setaffinity - set the cpu affinity of a process : 
2
strstr : while :  * sys_sched_setaffinity - set the cpu affinity of a process : 
2
str :  * @pid: pid of the process[27]
strstr : INIT :  * @pid: pid of the process : 
2
strstr : if :  * @pid: pid of the process : 
2
strstr : for :  * @pid: pid of the process : 
2
strstr : while :  * @pid: pid of the process : 
2
str :  * @len: length in bytes of the bitmask pointed to by user_mask_ptr[67]
strstr : INIT :  * @len: length in bytes of the bitmask pointed to by user_mask_ptr : 
2
strstr : if :  * @len: length in bytes of the bitmask pointed to by user_mask_ptr : 
2
strstr : for :  * @len: length in bytes of the bitmask pointed to by user_mask_ptr : 
2
strstr : while :  * @len: length in bytes of the bitmask pointed to by user_mask_ptr : 
2
str :  * @user_mask_ptr: user-space pointer to the new cpu mask[57]
strstr : INIT :  * @user_mask_ptr: user-space pointer to the new cpu mask : 
2
strstr : if :  * @user_mask_ptr: user-space pointer to the new cpu mask : 
2
strstr : for :  * @user_mask_ptr: user-space pointer to the new cpu mask : 
2
strstr : while :  * @user_mask_ptr: user-space pointer to the new cpu mask : 
2
str :  * Return: 0 on success. An error code otherwise.[49]
strstr : INIT :  * Return: 0 on success. An error code otherwise. : 
2
strstr : if :  * Return: 0 on success. An error code otherwise. : 
2
strstr : for :  * Return: 0 on success. An error code otherwise. : 
2
strstr : while :  * Return: 0 on success. An error code otherwise. : 
2
str :  */[3]
strstr : INIT :  */ : 
2
strstr : if :  */ : 
2
strstr : for :  */ : 
2
strstr : while :  */ : 
2
str : SYSCALL_DEFINE3(sched_setaffinity, pid_t, pid, unsigned int, len,[65]
strstr : INIT : SYSCALL_DEFINE3(sched_setaffinity, pid_t, pid, unsigned int, len, : 
2
strstr : if : SYSCALL_DEFINE3(sched_setaffinity, pid_t, pid, unsigned int, len, : 
2
strstr : for : SYSCALL_DEFINE3(sched_setaffinity, pid_t, pid, unsigned int, len, : 
2
strstr : while : SYSCALL_DEFINE3(sched_setaffinity, pid_t, pid, unsigned int, len, : 
2
str : 		unsigned long __user *, user_mask_ptr)[40]
strstr : INIT : 		unsigned long __user *, user_mask_ptr) : 
2
strstr : if : 		unsigned long __user *, user_mask_ptr) : 
2
strstr : for : 		unsigned long __user *, user_mask_ptr) : 
2
strstr : while : 		unsigned long __user *, user_mask_ptr) : 
2
str : 	cpumask_var_t new_mask;[24]
strstr : INIT : 	cpumask_var_t new_mask; : 
2
strstr : if : 	cpumask_var_t new_mask; : 
2
strstr : for : 	cpumask_var_t new_mask; : 
2
strstr : while : 	cpumask_var_t new_mask; : 
2
str : 	int retval;[12]
strstr : INIT : 	int retval; : 
2
strstr : if : 	int retval; : 
2
strstr : for : 	int retval; : 
2
strstr : while : 	int retval; : 
2
str : 	if (!alloc_cpumask_var(&new_mask, GFP_KERNEL))[47]
strstr : INIT : 	if (!alloc_cpumask_var(&new_mask, GFP_KERNEL)) : 
2
strstr : if : 	if (!alloc_cpumask_var(&new_mask, GFP_KERNEL)) : 
2
strstr : for : 	if (!alloc_cpumask_var(&new_mask, GFP_KERNEL)) : 
2
strstr : while : 	if (!alloc_cpumask_var(&new_mask, GFP_KERNEL)) : 
2
str : 		return -ENOMEM;[17]
strstr : INIT : 		return -ENOMEM; : 
2
strstr : if : 		return -ENOMEM; : 
2
strstr : for : 		return -ENOMEM; : 
2
strstr : while : 		return -ENOMEM; : 
2
str : 	retval = get_user_cpu_mask(user_mask_ptr, len, new_mask);[58]
strstr : INIT : 	retval = get_user_cpu_mask(user_mask_ptr, len, new_mask); : 
2
strstr : if : 	retval = get_user_cpu_mask(user_mask_ptr, len, new_mask); : 
2
strstr : for : 	retval = get_user_cpu_mask(user_mask_ptr, len, new_mask); : 
2
strstr : while : 	retval = get_user_cpu_mask(user_mask_ptr, len, new_mask); : 
2
str : 	if (retval == 0)[17]
strstr : INIT : 	if (retval == 0) : 
2
strstr : if : 	if (retval == 0) : 
2
strstr : for : 	if (retval == 0) : 
2
strstr : while : 	if (retval == 0) : 
2
str : 		retval = sched_setaffinity(pid, new_mask);[44]
strstr : INIT : 		retval = sched_setaffinity(pid, new_mask); : 
2
strstr : if : 		retval = sched_setaffinity(pid, new_mask); : 
2
strstr : for : 		retval = sched_setaffinity(pid, new_mask); : 
2
strstr : while : 		retval = sched_setaffinity(pid, new_mask); : 
2
str : 	free_cpumask_var(new_mask);[28]
strstr : INIT : 	free_cpumask_var(new_mask); : 
2
strstr : if : 	free_cpumask_var(new_mask); : 
2
strstr : for : 	free_cpumask_var(new_mask); : 
2
strstr : while : 	free_cpumask_var(new_mask); : 
2
str : 	return retval;[15]
strstr : INIT : 	return retval; : 
2
strstr : if : 	return retval; : 
2
strstr : for : 	return retval; : 
2
strstr : while : 	return retval; : 
2
str : long sched_getaffinity(pid_t pid, struct cpumask *mask)[55]
strstr : INIT : long sched_getaffinity(pid_t pid, struct cpumask *mask) : 
2
strstr : if : long sched_getaffinity(pid_t pid, struct cpumask *mask) : 
2
strstr : for : long sched_getaffinity(pid_t pid, struct cpumask *mask) : 
2
strstr : while : long sched_getaffinity(pid_t pid, struct cpumask *mask) : 
2
str : 	struct task_struct *p;[23]
strstr : INIT : 	struct task_struct *p; : 
2
strstr : if : 	struct task_struct *p; : 
2
strstr : for : 	struct task_struct *p; : 
2
strstr : while : 	struct task_struct *p; : 
2
str : 	unsigned long flags;[21]
strstr : INIT : 	unsigned long flags; : 
2
strstr : if : 	unsigned long flags; : 
2
strstr : for : 	unsigned long flags; : 
2
strstr : while : 	unsigned long flags; : 
2
str : 	int retval;[12]
strstr : INIT : 	int retval; : 
2
strstr : if : 	int retval; : 
2
strstr : for : 	int retval; : 
2
strstr : while : 	int retval; : 
2
str : 	rcu_read_lock();[17]
strstr : INIT : 	rcu_read_lock(); : 
2
strstr : if : 	rcu_read_lock(); : 
2
strstr : for : 	rcu_read_lock(); : 
2
strstr : while : 	rcu_read_lock(); : 
2
str : 	retval = -ESRCH;[17]
strstr : INIT : 	retval = -ESRCH; : 
2
strstr : if : 	retval = -ESRCH; : 
2
strstr : for : 	retval = -ESRCH; : 
2
strstr : while : 	retval = -ESRCH; : 
2
str : 	p = find_process_by_pid(pid);[30]
strstr : INIT : 	p = find_process_by_pid(pid); : 
2
strstr : if : 	p = find_process_by_pid(pid); : 
2
strstr : for : 	p = find_process_by_pid(pid); : 
2
strstr : while : 	p = find_process_by_pid(pid); : 
2
str : 	if (!p)[8]
strstr : INIT : 	if (!p) : 
2
strstr : if : 	if (!p) : 
2
strstr : for : 	if (!p) : 
2
strstr : while : 	if (!p) : 
2
str : 		goto out_unlock;[18]
strstr : INIT : 		goto out_unlock; : 
2
strstr : if : 		goto out_unlock; : 
2
strstr : for : 		goto out_unlock; : 
2
strstr : while : 		goto out_unlock; : 
2
str : 	retval = security_task_getscheduler(p);[40]
strstr : INIT : 	retval = security_task_getscheduler(p); : 
2
strstr : if : 	retval = security_task_getscheduler(p); : 
2
strstr : for : 	retval = security_task_getscheduler(p); : 
2
strstr : while : 	retval = security_task_getscheduler(p); : 
2
str : 	if (retval)[12]
strstr : INIT : 	if (retval) : 
2
strstr : if : 	if (retval) : 
2
strstr : for : 	if (retval) : 
2
strstr : while : 	if (retval) : 
2
str : 		goto out_unlock;[18]
strstr : INIT : 		goto out_unlock; : 
2
strstr : if : 		goto out_unlock; : 
2
strstr : for : 		goto out_unlock; : 
2
strstr : while : 		goto out_unlock; : 
2
str : 	raw_spin_lock_irqsave(&p->pi_lock, flags);[43]
strstr : INIT : 	raw_spin_lock_irqsave(&p->pi_lock, flags); : 
2
strstr : if : 	raw_spin_lock_irqsave(&p->pi_lock, flags); : 
2
strstr : for : 	raw_spin_lock_irqsave(&p->pi_lock, flags); : 
2
strstr : while : 	raw_spin_lock_irqsave(&p->pi_lock, flags); : 
2
str : 	cpumask_and(mask, &p->cpus_allowed, cpu_active_mask);[54]
strstr : INIT : 	cpumask_and(mask, &p->cpus_allowed, cpu_active_mask); : 
2
strstr : if : 	cpumask_and(mask, &p->cpus_allowed, cpu_active_mask); : 
2
strstr : for : 	cpumask_and(mask, &p->cpus_allowed, cpu_active_mask); : 
2
strstr : while : 	cpumask_and(mask, &p->cpus_allowed, cpu_active_mask); : 
2
str : 	raw_spin_unlock_irqrestore(&p->pi_lock, flags);[48]
strstr : INIT : 	raw_spin_unlock_irqrestore(&p->pi_lock, flags); : 
2
strstr : if : 	raw_spin_unlock_irqrestore(&p->pi_lock, flags); : 
2
strstr : for : 	raw_spin_unlock_irqrestore(&p->pi_lock, flags); : 
2
strstr : while : 	raw_spin_unlock_irqrestore(&p->pi_lock, flags); : 
2
str : out_unlock:[11]
strstr : INIT : out_unlock: : 
2
strstr : if : out_unlock: : 
2
strstr : for : out_unlock: : 
2
strstr : while : out_unlock: : 
2
str : 	rcu_read_unlock();[19]
strstr : INIT : 	rcu_read_unlock(); : 
2
strstr : if : 	rcu_read_unlock(); : 
2
strstr : for : 	rcu_read_unlock(); : 
2
strstr : while : 	rcu_read_unlock(); : 
2
str : 	return retval;[15]
strstr : INIT : 	return retval; : 
2
strstr : if : 	return retval; : 
2
strstr : for : 	return retval; : 
2
strstr : while : 	return retval; : 
2
str : /**[3]
strstr : INIT : /** : 
2
strstr : if : /** : 
2
strstr : for : /** : 
2
strstr : while : /** : 
2
str :  * sys_sched_getaffinity - get the cpu affinity of a process[60]
strstr : INIT :  * sys_sched_getaffinity - get the cpu affinity of a process : 
2
strstr : if :  * sys_sched_getaffinity - get the cpu affinity of a process : 
2
strstr : for :  * sys_sched_getaffinity - get the cpu affinity of a process : 
2
strstr : while :  * sys_sched_getaffinity - get the cpu affinity of a process : 
2
str :  * @pid: pid of the process[27]
strstr : INIT :  * @pid: pid of the process : 
2
strstr : if :  * @pid: pid of the process : 
2
strstr : for :  * @pid: pid of the process : 
2
strstr : while :  * @pid: pid of the process : 
2
str :  * @len: length in bytes of the bitmask pointed to by user_mask_ptr[67]
strstr : INIT :  * @len: length in bytes of the bitmask pointed to by user_mask_ptr : 
2
strstr : if :  * @len: length in bytes of the bitmask pointed to by user_mask_ptr : 
2
strstr : for :  * @len: length in bytes of the bitmask pointed to by user_mask_ptr : 
2
strstr : while :  * @len: length in bytes of the bitmask pointed to by user_mask_ptr : 
2
str :  * @user_mask_ptr: user-space pointer to hold the current cpu mask[66]
strstr : INIT :  * @user_mask_ptr: user-space pointer to hold the current cpu mask : 
2
strstr : if :  * @user_mask_ptr: user-space pointer to hold the current cpu mask : 
2
strstr : for :  * @user_mask_ptr: user-space pointer to hold the current cpu mask : 
2
strstr : while :  * @user_mask_ptr: user-space pointer to hold the current cpu mask : 
2
str :  * Return: 0 on success. An error code otherwise.[49]
strstr : INIT :  * Return: 0 on success. An error code otherwise. : 
2
strstr : if :  * Return: 0 on success. An error code otherwise. : 
2
strstr : for :  * Return: 0 on success. An error code otherwise. : 
2
strstr : while :  * Return: 0 on success. An error code otherwise. : 
2
str :  */[3]
strstr : INIT :  */ : 
2
strstr : if :  */ : 
2
strstr : for :  */ : 
2
strstr : while :  */ : 
2
str : SYSCALL_DEFINE3(sched_getaffinity, pid_t, pid, unsigned int, len,[65]
strstr : INIT : SYSCALL_DEFINE3(sched_getaffinity, pid_t, pid, unsigned int, len, : 
2
strstr : if : SYSCALL_DEFINE3(sched_getaffinity, pid_t, pid, unsigned int, len, : 
2
strstr : for : SYSCALL_DEFINE3(sched_getaffinity, pid_t, pid, unsigned int, len, : 
2
strstr : while : SYSCALL_DEFINE3(sched_getaffinity, pid_t, pid, unsigned int, len, : 
2
str : 		unsigned long __user *, user_mask_ptr)[40]
strstr : INIT : 		unsigned long __user *, user_mask_ptr) : 
2
strstr : if : 		unsigned long __user *, user_mask_ptr) : 
2
strstr : for : 		unsigned long __user *, user_mask_ptr) : 
2
strstr : while : 		unsigned long __user *, user_mask_ptr) : 
2
str : 	int ret;[9]
strstr : INIT : 	int ret; : 
2
strstr : if : 	int ret; : 
2
strstr : for : 	int ret; : 
2
strstr : while : 	int ret; : 
2
str : 	cpumask_var_t mask;[20]
strstr : INIT : 	cpumask_var_t mask; : 
2
strstr : if : 	cpumask_var_t mask; : 
2
strstr : for : 	cpumask_var_t mask; : 
2
strstr : while : 	cpumask_var_t mask; : 
2
str : 	if ((len * BITS_PER_BYTE) < nr_cpu_ids)[40]
strstr : INIT : 	if ((len * BITS_PER_BYTE) < nr_cpu_ids) : 
2
strstr : if : 	if ((len * BITS_PER_BYTE) < nr_cpu_ids) : 
2
strstr : for : 	if ((len * BITS_PER_BYTE) < nr_cpu_ids) : 
2
strstr : while : 	if ((len * BITS_PER_BYTE) < nr_cpu_ids) : 
2
str : 		return -EINVAL;[17]
strstr : INIT : 		return -EINVAL; : 
2
strstr : if : 		return -EINVAL; : 
2
strstr : for : 		return -EINVAL; : 
2
strstr : while : 		return -EINVAL; : 
2
str : 	if (len & (sizeof(unsigned long)-1))[37]
strstr : INIT : 	if (len & (sizeof(unsigned long)-1)) : 
2
strstr : if : 	if (len & (sizeof(unsigned long)-1)) : 
2
strstr : for : 	if (len & (sizeof(unsigned long)-1)) : 
2
strstr : while : 	if (len & (sizeof(unsigned long)-1)) : 
2
str : 		return -EINVAL;[17]
strstr : INIT : 		return -EINVAL; : 
2
strstr : if : 		return -EINVAL; : 
2
strstr : for : 		return -EINVAL; : 
2
strstr : while : 		return -EINVAL; : 
2
str : 	if (!alloc_cpumask_var(&mask, GFP_KERNEL))[43]
strstr : INIT : 	if (!alloc_cpumask_var(&mask, GFP_KERNEL)) : 
2
strstr : if : 	if (!alloc_cpumask_var(&mask, GFP_KERNEL)) : 
2
strstr : for : 	if (!alloc_cpumask_var(&mask, GFP_KERNEL)) : 
2
strstr : while : 	if (!alloc_cpumask_var(&mask, GFP_KERNEL)) : 
2
str : 		return -ENOMEM;[17]
strstr : INIT : 		return -ENOMEM; : 
2
strstr : if : 		return -ENOMEM; : 
2
strstr : for : 		return -ENOMEM; : 
2
strstr : while : 		return -ENOMEM; : 
2
str : 	ret = sched_getaffinity(pid, mask);[36]
strstr : INIT : 	ret = sched_getaffinity(pid, mask); : 
2
strstr : if : 	ret = sched_getaffinity(pid, mask); : 
2
strstr : for : 	ret = sched_getaffinity(pid, mask); : 
2
strstr : while : 	ret = sched_getaffinity(pid, mask); : 
2
str : 	if (ret == 0) {[16]
strstr : INIT : 	if (ret == 0) { : 
2
strstr : if : 	if (ret == 0) { : 
2
strstr : for : 	if (ret == 0) { : 
2
strstr : while : 	if (ret == 0) { : 
2
str : 		size_t retlen = min_t(size_t, len, cpumask_size());[53]
strstr : INIT : 		size_t retlen = min_t(size_t, len, cpumask_size()); : 
2
strstr : if : 		size_t retlen = min_t(size_t, len, cpumask_size()); : 
2
strstr : for : 		size_t retlen = min_t(size_t, len, cpumask_size()); : 
2
strstr : while : 		size_t retlen = min_t(size_t, len, cpumask_size()); : 
2
str : 		if (copy_to_user(user_mask_ptr, mask, retlen))[48]
strstr : INIT : 		if (copy_to_user(user_mask_ptr, mask, retlen)) : 
2
strstr : if : 		if (copy_to_user(user_mask_ptr, mask, retlen)) : 
2
strstr : for : 		if (copy_to_user(user_mask_ptr, mask, retlen)) : 
2
strstr : while : 		if (copy_to_user(user_mask_ptr, mask, retlen)) : 
2
str : 			ret = -EFAULT;[17]
strstr : INIT : 			ret = -EFAULT; : 
2
strstr : if : 			ret = -EFAULT; : 
2
strstr : for : 			ret = -EFAULT; : 
2
strstr : while : 			ret = -EFAULT; : 
2
str : 		else[6]
strstr : INIT : 		else : 
2
strstr : if : 		else : 
2
strstr : for : 		else : 
2
strstr : while : 		else : 
2
str : 			ret = retlen;[16]
strstr : INIT : 			ret = retlen; : 
2
strstr : if : 			ret = retlen; : 
2
strstr : for : 			ret = retlen; : 
2
strstr : while : 			ret = retlen; : 
2
str : 	free_cpumask_var(mask);[24]
strstr : INIT : 	free_cpumask_var(mask); : 
2
strstr : if : 	free_cpumask_var(mask); : 
2
strstr : for : 	free_cpumask_var(mask); : 
2
strstr : while : 	free_cpumask_var(mask); : 
2
str : 	return ret;[12]
strstr : INIT : 	return ret; : 
2
strstr : if : 	return ret; : 
2
strstr : for : 	return ret; : 
2
strstr : while : 	return ret; : 
2
str : /**[3]
strstr : INIT : /** : 
2
strstr : if : /** : 
2
strstr : for : /** : 
2
strstr : while : /** : 
2
str :  * sys_sched_yield - yield the current processor to other threads.[66]
strstr : INIT :  * sys_sched_yield - yield the current processor to other threads. : 
2
strstr : if :  * sys_sched_yield - yield the current processor to other threads. : 
2
strstr : for :  * sys_sched_yield - yield the current processor to other threads. : 
2
strstr : while :  * sys_sched_yield - yield the current processor to other threads. : 
2
str :  * This function yields the current CPU to other tasks. If there are no[71]
strstr : INIT :  * This function yields the current CPU to other tasks. If there are no : 
2
strstr : if :  * This function yields the current CPU to other tasks. If there are no : 
2
strstr : for :  * This function yields the current CPU to other tasks. If there are no : 
2
strstr : while :  * This function yields the current CPU to other tasks. If there are no : 
2
str :  * other threads running on this CPU then this function will return.[68]
strstr : INIT :  * other threads running on this CPU then this function will return. : 
2
strstr : if :  * other threads running on this CPU then this function will return. : 
2
strstr : for :  * other threads running on this CPU then this function will return. : 
2
strstr : while :  * other threads running on this CPU then this function will return. : 
2
str :  * Return: 0.[13]
strstr : INIT :  * Return: 0. : 
2
strstr : if :  * Return: 0. : 
2
strstr : for :  * Return: 0. : 
2
strstr : while :  * Return: 0. : 
2
str :  */[3]
strstr : INIT :  */ : 
2
strstr : if :  */ : 
2
strstr : for :  */ : 
2
strstr : while :  */ : 
2
str : SYSCALL_DEFINE0(sched_yield)[28]
strstr : INIT : SYSCALL_DEFINE0(sched_yield) : 
2
strstr : if : SYSCALL_DEFINE0(sched_yield) : 
2
strstr : for : SYSCALL_DEFINE0(sched_yield) : 
2
strstr : while : SYSCALL_DEFINE0(sched_yield) : 
2
str : 	struct rq *rq = this_rq_lock();[32]
strstr : INIT : 	struct rq *rq = this_rq_lock(); : 
2
strstr : if : 	struct rq *rq = this_rq_lock(); : 
2
strstr : for : 	struct rq *rq = this_rq_lock(); : 
2
strstr : while : 	struct rq *rq = this_rq_lock(); : 
2
str : 	schedstat_inc(rq, yld_count);[30]
strstr : INIT : 	schedstat_inc(rq, yld_count); : 
2
strstr : if : 	schedstat_inc(rq, yld_count); : 
2
strstr : for : 	schedstat_inc(rq, yld_count); : 
2
strstr : while : 	schedstat_inc(rq, yld_count); : 
2
str : 	current->sched_class->yield_task(rq);[38]
strstr : INIT : 	current->sched_class->yield_task(rq); : 
2
strstr : if : 	current->sched_class->yield_task(rq); : 
2
strstr : for : 	current->sched_class->yield_task(rq); : 
2
strstr : while : 	current->sched_class->yield_task(rq); : 
2
str : 	/*[3]
strstr : INIT : 	/* : 
2
strstr : if : 	/* : 
2
strstr : for : 	/* : 
2
strstr : while : 	/* : 
2
str : 	 * Since we are going to call schedule() anyway, there's[57]
strstr : INIT : 	 * Since we are going to call schedule() anyway, there's : 
2
strstr : if : 	 * Since we are going to call schedule() anyway, there's : 
2
strstr : for : 	 * Since we are going to call schedule() anyway, there's : 
2
strstr : while : 	 * Since we are going to call schedule() anyway, there's : 
2
str : 	 * no need to preempt or enable interrupts:[44]
strstr : INIT : 	 * no need to preempt or enable interrupts: : 
2
strstr : if : 	 * no need to preempt or enable interrupts: : 
2
strstr : for : 	 * no need to preempt or enable interrupts: : 
2
strstr : while : 	 * no need to preempt or enable interrupts: : 
2
str : 	 */[4]
strstr : INIT : 	 */ : 
2
strstr : if : 	 */ : 
2
strstr : for : 	 */ : 
2
strstr : while : 	 */ : 
2
str : 	__release(rq->lock);[21]
strstr : INIT : 	__release(rq->lock); : 
2
strstr : if : 	__release(rq->lock); : 
2
strstr : for : 	__release(rq->lock); : 
2
strstr : while : 	__release(rq->lock); : 
2
str : 	spin_release(&rq->lock.dep_map, 1, _THIS_IP_);[47]
strstr : INIT : 	spin_release(&rq->lock.dep_map, 1, _THIS_IP_); : 
2
strstr : if : 	spin_release(&rq->lock.dep_map, 1, _THIS_IP_); : 
2
strstr : for : 	spin_release(&rq->lock.dep_map, 1, _THIS_IP_); : 
2
strstr : while : 	spin_release(&rq->lock.dep_map, 1, _THIS_IP_); : 
2
str : 	do_raw_spin_unlock(&rq->lock);[31]
strstr : INIT : 	do_raw_spin_unlock(&rq->lock); : 
2
strstr : if : 	do_raw_spin_unlock(&rq->lock); : 
2
strstr : for : 	do_raw_spin_unlock(&rq->lock); : 
2
strstr : while : 	do_raw_spin_unlock(&rq->lock); : 
2
str : 	sched_preempt_enable_no_resched();[35]
strstr : INIT : 	sched_preempt_enable_no_resched(); : 
2
strstr : if : 	sched_preempt_enable_no_resched(); : 
2
strstr : for : 	sched_preempt_enable_no_resched(); : 
2
strstr : while : 	sched_preempt_enable_no_resched(); : 
2
str : 	schedule();[12]
strstr : INIT : 	schedule(); : 
2
strstr : if : 	schedule(); : 
2
strstr : for : 	schedule(); : 
2
strstr : while : 	schedule(); : 
2
str : 	return 0;[10]
strstr : INIT : 	return 0; : 
2
strstr : if : 	return 0; : 
2
strstr : for : 	return 0; : 
2
strstr : while : 	return 0; : 
2
str : static void __cond_resched(void)[32]
strstr : INIT : static void __cond_resched(void) : 
2
strstr : if : static void __cond_resched(void) : 
2
strstr : for : static void __cond_resched(void) : 
2
strstr : while : static void __cond_resched(void) : 
2
str : 	__preempt_count_add(PREEMPT_ACTIVE);[37]
strstr : INIT : 	__preempt_count_add(PREEMPT_ACTIVE); : 
2
strstr : if : 	__preempt_count_add(PREEMPT_ACTIVE); : 
2
strstr : for : 	__preempt_count_add(PREEMPT_ACTIVE); : 
2
strstr : while : 	__preempt_count_add(PREEMPT_ACTIVE); : 
2
str : 	__schedule();[14]
strstr : INIT : 	__schedule(); : 
2
strstr : if : 	__schedule(); : 
2
strstr : for : 	__schedule(); : 
2
strstr : while : 	__schedule(); : 
2
str : 	__preempt_count_sub(PREEMPT_ACTIVE);[37]
strstr : INIT : 	__preempt_count_sub(PREEMPT_ACTIVE); : 
2
strstr : if : 	__preempt_count_sub(PREEMPT_ACTIVE); : 
2
strstr : for : 	__preempt_count_sub(PREEMPT_ACTIVE); : 
2
strstr : while : 	__preempt_count_sub(PREEMPT_ACTIVE); : 
2
str : int __sched _cond_resched(void)[31]
strstr : INIT : int __sched _cond_resched(void) : 
2
strstr : if : int __sched _cond_resched(void) : 
2
strstr : for : int __sched _cond_resched(void) : 
2
strstr : while : int __sched _cond_resched(void) : 
2
str : 	if (should_resched()) {[24]
strstr : INIT : 	if (should_resched()) { : 
2
strstr : if : 	if (should_resched()) { : 
2
strstr : for : 	if (should_resched()) { : 
2
strstr : while : 	if (should_resched()) { : 
2
str : 		__cond_resched();[19]
strstr : INIT : 		__cond_resched(); : 
2
strstr : if : 		__cond_resched(); : 
2
strstr : for : 		__cond_resched(); : 
2
strstr : while : 		__cond_resched(); : 
2
str : 		return 1;[11]
strstr : INIT : 		return 1; : 
2
strstr : if : 		return 1; : 
2
strstr : for : 		return 1; : 
2
strstr : while : 		return 1; : 
2
str : 	return 0;[10]
strstr : INIT : 	return 0; : 
2
strstr : if : 	return 0; : 
2
strstr : for : 	return 0; : 
2
strstr : while : 	return 0; : 
2
str : EXPORT_SYMBOL(_cond_resched);[29]
strstr : INIT : EXPORT_SYMBOL(_cond_resched); : 
2
strstr : if : EXPORT_SYMBOL(_cond_resched); : 
2
strstr : for : EXPORT_SYMBOL(_cond_resched); : 
2
strstr : while : EXPORT_SYMBOL(_cond_resched); : 
2
str :  * __cond_resched_lock() - if a reschedule is pending, drop the given lock,[75]
strstr : INIT :  * __cond_resched_lock() - if a reschedule is pending, drop the given lock, : 
2
strstr : if :  * __cond_resched_lock() - if a reschedule is pending, drop the given lock, : 
2
strstr : for :  * __cond_resched_lock() - if a reschedule is pending, drop the given lock, : 
2
strstr : while :  * __cond_resched_lock() - if a reschedule is pending, drop the given lock, : 
2
str :  * call schedule, and on return reacquire the lock.[51]
strstr : INIT :  * call schedule, and on return reacquire the lock. : 
2
strstr : if :  * call schedule, and on return reacquire the lock. : 
2
strstr : for :  * call schedule, and on return reacquire the lock. : 
2
strstr : while :  * call schedule, and on return reacquire the lock. : 
2
str :  * This works OK both with and without CONFIG_PREEMPT. We do strange low-level[78]
strstr : INIT :  * This works OK both with and without CONFIG_PREEMPT. We do strange low-level : 
2
strstr : if :  * This works OK both with and without CONFIG_PREEMPT. We do strange low-level : 
2
strstr : for :  * This works OK both with and without CONFIG_PREEMPT. We do strange low-level : 
2
strstr : while :  * This works OK both with and without CONFIG_PREEMPT. We do strange low-level : 
2
str :  * operations here to prevent schedule() from being called twice (once via[74]
strstr : INIT :  * operations here to prevent schedule() from being called twice (once via : 
2
strstr : if :  * operations here to prevent schedule() from being called twice (once via : 
2
strstr : for :  * operations here to prevent schedule() from being called twice (once via : 
2
strstr : while :  * operations here to prevent schedule() from being called twice (once via : 
2
str :  * spin_unlock(), once by hand).[32]
strstr : INIT :  * spin_unlock(), once by hand). : 
2
strstr : if :  * spin_unlock(), once by hand). : 
2
strstr : for :  * spin_unlock(), once by hand). : 
2
strstr : while :  * spin_unlock(), once by hand). : 
2
str :  */[3]
strstr : INIT :  */ : 
2
strstr : if :  */ : 
2
strstr : for :  */ : 
2
strstr : while :  */ : 
2
str : int __cond_resched_lock(spinlock_t *lock)[41]
strstr : INIT : int __cond_resched_lock(spinlock_t *lock) : 
2
strstr : if : int __cond_resched_lock(spinlock_t *lock) : 
2
strstr : for : int __cond_resched_lock(spinlock_t *lock) : 
2
strstr : while : int __cond_resched_lock(spinlock_t *lock) : 
2
str : 	int resched = should_resched();[32]
strstr : INIT : 	int resched = should_resched(); : 
2
strstr : if : 	int resched = should_resched(); : 
2
strstr : for : 	int resched = should_resched(); : 
2
strstr : while : 	int resched = should_resched(); : 
2
str : 	int ret = 0;[13]
strstr : INIT : 	int ret = 0; : 
2
strstr : if : 	int ret = 0; : 
2
strstr : for : 	int ret = 0; : 
2
strstr : while : 	int ret = 0; : 
2
str : 	lockdep_assert_held(lock);[27]
strstr : INIT : 	lockdep_assert_held(lock); : 
2
strstr : if : 	lockdep_assert_held(lock); : 
2
strstr : for : 	lockdep_assert_held(lock); : 
2
strstr : while : 	lockdep_assert_held(lock); : 
2
str : 	if (spin_needbreak(lock) || resched) {[39]
strstr : INIT : 	if (spin_needbreak(lock) || resched) { : 
2
strstr : if : 	if (spin_needbreak(lock) || resched) { : 
2
strstr : for : 	if (spin_needbreak(lock) || resched) { : 
2
strstr : while : 	if (spin_needbreak(lock) || resched) { : 
2
str : 		spin_unlock(lock);[20]
strstr : INIT : 		spin_unlock(lock); : 
2
strstr : if : 		spin_unlock(lock); : 
2
strstr : for : 		spin_unlock(lock); : 
2
strstr : while : 		spin_unlock(lock); : 
2
str : 		if (resched)[14]
strstr : INIT : 		if (resched) : 
2
strstr : if : 		if (resched) : 
2
strstr : for : 		if (resched) : 
2
strstr : while : 		if (resched) : 
2
str : 			__cond_resched();[20]
strstr : INIT : 			__cond_resched(); : 
2
strstr : if : 			__cond_resched(); : 
2
strstr : for : 			__cond_resched(); : 
2
strstr : while : 			__cond_resched(); : 
2
str : 		else[6]
strstr : INIT : 		else : 
2
strstr : if : 		else : 
2
strstr : for : 		else : 
2
strstr : while : 		else : 
2
str : 			cpu_relax();[15]
strstr : INIT : 			cpu_relax(); : 
2
strstr : if : 			cpu_relax(); : 
2
strstr : for : 			cpu_relax(); : 
2
strstr : while : 			cpu_relax(); : 
2
str : 		ret = 1;[10]
strstr : INIT : 		ret = 1; : 
2
strstr : if : 		ret = 1; : 
2
strstr : for : 		ret = 1; : 
2
strstr : while : 		ret = 1; : 
2
str : 		spin_lock(lock);[18]
strstr : INIT : 		spin_lock(lock); : 
2
strstr : if : 		spin_lock(lock); : 
2
strstr : for : 		spin_lock(lock); : 
2
strstr : while : 		spin_lock(lock); : 
2
str : 	return ret;[12]
strstr : INIT : 	return ret; : 
2
strstr : if : 	return ret; : 
2
strstr : for : 	return ret; : 
2
strstr : while : 	return ret; : 
2
str : EXPORT_SYMBOL(__cond_resched_lock);[35]
strstr : INIT : EXPORT_SYMBOL(__cond_resched_lock); : 
2
strstr : if : EXPORT_SYMBOL(__cond_resched_lock); : 
2
strstr : for : EXPORT_SYMBOL(__cond_resched_lock); : 
2
strstr : while : EXPORT_SYMBOL(__cond_resched_lock); : 
2
str : int __sched __cond_resched_softirq(void)[40]
strstr : INIT : int __sched __cond_resched_softirq(void) : 
2
strstr : if : int __sched __cond_resched_softirq(void) : 
2
strstr : for : int __sched __cond_resched_softirq(void) : 
2
strstr : while : int __sched __cond_resched_softirq(void) : 
2
str : 	BUG_ON(!in_softirq());[23]
strstr : INIT : 	BUG_ON(!in_softirq()); : 
2
strstr : if : 	BUG_ON(!in_softirq()); : 
2
strstr : for : 	BUG_ON(!in_softirq()); : 
2
strstr : while : 	BUG_ON(!in_softirq()); : 
2
str : 	if (should_resched()) {[24]
strstr : INIT : 	if (should_resched()) { : 
2
strstr : if : 	if (should_resched()) { : 
2
strstr : for : 	if (should_resched()) { : 
2
strstr : while : 	if (should_resched()) { : 
2
str : 		local_bh_enable();[20]
strstr : INIT : 		local_bh_enable(); : 
2
strstr : if : 		local_bh_enable(); : 
2
strstr : for : 		local_bh_enable(); : 
2
strstr : while : 		local_bh_enable(); : 
2
str : 		__cond_resched();[19]
strstr : INIT : 		__cond_resched(); : 
2
strstr : if : 		__cond_resched(); : 
2
strstr : for : 		__cond_resched(); : 
2
strstr : while : 		__cond_resched(); : 
2
str : 		local_bh_disable();[21]
strstr : INIT : 		local_bh_disable(); : 
2
strstr : if : 		local_bh_disable(); : 
2
strstr : for : 		local_bh_disable(); : 
2
strstr : while : 		local_bh_disable(); : 
2
str : 		return 1;[11]
strstr : INIT : 		return 1; : 
2
strstr : if : 		return 1; : 
2
strstr : for : 		return 1; : 
2
strstr : while : 		return 1; : 
2
str : 	return 0;[10]
strstr : INIT : 	return 0; : 
2
strstr : if : 	return 0; : 
2
strstr : for : 	return 0; : 
2
strstr : while : 	return 0; : 
2
str : EXPORT_SYMBOL(__cond_resched_softirq);[38]
strstr : INIT : EXPORT_SYMBOL(__cond_resched_softirq); : 
2
strstr : if : EXPORT_SYMBOL(__cond_resched_softirq); : 
2
strstr : for : EXPORT_SYMBOL(__cond_resched_softirq); : 
2
strstr : while : EXPORT_SYMBOL(__cond_resched_softirq); : 
2
str : /**[3]
strstr : INIT : /** : 
2
strstr : if : /** : 
2
strstr : for : /** : 
2
strstr : while : /** : 
2
str :  * yield - yield the current processor to other threads.[56]
strstr : INIT :  * yield - yield the current processor to other threads. : 
2
strstr : if :  * yield - yield the current processor to other threads. : 
2
strstr : for :  * yield - yield the current processor to other threads. : 
2
strstr : while :  * yield - yield the current processor to other threads. : 
2
str :  * Do not ever use this function, there's a 99% chance you're doing it wrong.[77]
strstr : INIT :  * Do not ever use this function, there's a 99% chance you're doing it wrong. : 
2
strstr : if :  * Do not ever use this function, there's a 99% chance you're doing it wrong. : 
2
strstr : for :  * Do not ever use this function, there's a 99% chance you're doing it wrong. : 
2
strstr : while :  * Do not ever use this function, there's a 99% chance you're doing it wrong. : 
2
str :  * The scheduler is at all times free to pick the calling task as the most[74]
strstr : INIT :  * The scheduler is at all times free to pick the calling task as the most : 
2
strstr : if :  * The scheduler is at all times free to pick the calling task as the most : 
2
strstr : for :  * The scheduler is at all times free to pick the calling task as the most : 
2
strstr : while :  * The scheduler is at all times free to pick the calling task as the most : 
2
str :  * eligible task to run, if removing the yield() call from your code breaks[75]
strstr : INIT :  * eligible task to run, if removing the yield() call from your code breaks : 
2
strstr : if :  * eligible task to run, if removing the yield() call from your code breaks : 
2
strstr : for :  * eligible task to run, if removing the yield() call from your code breaks : 
2
strstr : while :  * eligible task to run, if removing the yield() call from your code breaks : 
2
str :  * it, its already broken.[26]
strstr : INIT :  * it, its already broken. : 
2
strstr : if :  * it, its already broken. : 
2
strstr : for :  * it, its already broken. : 
2
strstr : while :  * it, its already broken. : 
2
str :  * Typical broken usage is:[27]
strstr : INIT :  * Typical broken usage is: : 
2
strstr : if :  * Typical broken usage is: : 
2
strstr : for :  * Typical broken usage is: : 
2
strstr : while :  * Typical broken usage is: : 
2
str :  * while (!event)[17]
strstr : INIT :  * while (!event) : 
2
strstr : if :  * while (!event) : 
2
strstr : for :  * while (!event) : 
2
strstr : while :  * while (!event) : 
2
str :  * 	yield();[12]
strstr : INIT :  * 	yield(); : 
2
strstr : if :  * 	yield(); : 
2
strstr : for :  * 	yield(); : 
2
strstr : while :  * 	yield(); : 
2
str :  * where one assumes that yield() will let 'the other' process run that will[76]
strstr : INIT :  * where one assumes that yield() will let 'the other' process run that will : 
2
strstr : if :  * where one assumes that yield() will let 'the other' process run that will : 
2
strstr : for :  * where one assumes that yield() will let 'the other' process run that will : 
2
strstr : while :  * where one assumes that yield() will let 'the other' process run that will : 
2
str :  * make event true. If the current task is a SCHED_FIFO task that will never[76]
strstr : INIT :  * make event true. If the current task is a SCHED_FIFO task that will never : 
2
strstr : if :  * make event true. If the current task is a SCHED_FIFO task that will never : 
2
strstr : for :  * make event true. If the current task is a SCHED_FIFO task that will never : 
2
strstr : while :  * make event true. If the current task is a SCHED_FIFO task that will never : 
2
str :  * happen. Never use yield() as a progress guarantee!![54]
strstr : INIT :  * happen. Never use yield() as a progress guarantee!! : 
2
strstr : if :  * happen. Never use yield() as a progress guarantee!! : 
2
strstr : for :  * happen. Never use yield() as a progress guarantee!! : 
2
strstr : while :  * happen. Never use yield() as a progress guarantee!! : 
2
str :  * If you want to use yield() to wait for something, use wait_event().[70]
strstr : INIT :  * If you want to use yield() to wait for something, use wait_event(). : 
2
strstr : if :  * If you want to use yield() to wait for something, use wait_event(). : 
2
strstr : for :  * If you want to use yield() to wait for something, use wait_event(). : 
2
strstr : while :  * If you want to use yield() to wait for something, use wait_event(). : 
2
str :  * If you want to use yield() to be 'nice' for others, use cond_resched().[74]
strstr : INIT :  * If you want to use yield() to be 'nice' for others, use cond_resched(). : 
2
strstr : if :  * If you want to use yield() to be 'nice' for others, use cond_resched(). : 
2
strstr : for :  * If you want to use yield() to be 'nice' for others, use cond_resched(). : 
2
strstr : while :  * If you want to use yield() to be 'nice' for others, use cond_resched(). : 
2
str :  * If you still want to use yield(), do not![44]
strstr : INIT :  * If you still want to use yield(), do not! : 
2
strstr : if :  * If you still want to use yield(), do not! : 
2
strstr : for :  * If you still want to use yield(), do not! : 
2
strstr : while :  * If you still want to use yield(), do not! : 
2
str :  */[3]
strstr : INIT :  */ : 
2
strstr : if :  */ : 
2
strstr : for :  */ : 
2
strstr : while :  */ : 
2
str : void __sched yield(void)[24]
strstr : INIT : void __sched yield(void) : 
2
strstr : if : void __sched yield(void) : 
2
strstr : for : void __sched yield(void) : 
2
strstr : while : void __sched yield(void) : 
2
str : 	set_current_state(TASK_RUNNING);[33]
strstr : INIT : 	set_current_state(TASK_RUNNING); : 
2
strstr : if : 	set_current_state(TASK_RUNNING); : 
2
strstr : for : 	set_current_state(TASK_RUNNING); : 
2
strstr : while : 	set_current_state(TASK_RUNNING); : 
2
str : 	sys_sched_yield();[19]
strstr : INIT : 	sys_sched_yield(); : 
2
strstr : if : 	sys_sched_yield(); : 
2
strstr : for : 	sys_sched_yield(); : 
2
strstr : while : 	sys_sched_yield(); : 
2
str : EXPORT_SYMBOL(yield);[21]
strstr : INIT : EXPORT_SYMBOL(yield); : 
2
strstr : if : EXPORT_SYMBOL(yield); : 
2
strstr : for : EXPORT_SYMBOL(yield); : 
2
strstr : while : EXPORT_SYMBOL(yield); : 
2
str : /**[3]
strstr : INIT : /** : 
2
strstr : if : /** : 
2
strstr : for : /** : 
2
strstr : while : /** : 
2
str :  * yield_to - yield the current processor to another thread in[62]
strstr : INIT :  * yield_to - yield the current processor to another thread in : 
2
strstr : if :  * yield_to - yield the current processor to another thread in : 
2
strstr : for :  * yield_to - yield the current processor to another thread in : 
2
strstr : while :  * yield_to - yield the current processor to another thread in : 
2
str :  * your thread group, or accelerate that thread toward the[58]
strstr : INIT :  * your thread group, or accelerate that thread toward the : 
2
strstr : if :  * your thread group, or accelerate that thread toward the : 
2
strstr : for :  * your thread group, or accelerate that thread toward the : 
2
strstr : while :  * your thread group, or accelerate that thread toward the : 
2
str :  * processor it's on.[21]
strstr : INIT :  * processor it's on. : 
2
strstr : if :  * processor it's on. : 
2
strstr : for :  * processor it's on. : 
2
strstr : while :  * processor it's on. : 
2
str :  * @p: target task[18]
strstr : INIT :  * @p: target task : 
2
strstr : if :  * @p: target task : 
2
strstr : for :  * @p: target task : 
2
strstr : while :  * @p: target task : 
2
str :  * @preempt: whether task preemption is allowed or not[54]
strstr : INIT :  * @preempt: whether task preemption is allowed or not : 
2
strstr : if :  * @preempt: whether task preemption is allowed or not : 
2
strstr : for :  * @preempt: whether task preemption is allowed or not : 
2
strstr : while :  * @preempt: whether task preemption is allowed or not : 
2
str :  * It's the caller's job to ensure that the target task struct[62]
strstr : INIT :  * It's the caller's job to ensure that the target task struct : 
2
strstr : if :  * It's the caller's job to ensure that the target task struct : 
2
strstr : for :  * It's the caller's job to ensure that the target task struct : 
2
strstr : while :  * It's the caller's job to ensure that the target task struct : 
2
str :  * can't go away on us before we can do any checks.[51]
strstr : INIT :  * can't go away on us before we can do any checks. : 
2
strstr : if :  * can't go away on us before we can do any checks. : 
2
strstr : for :  * can't go away on us before we can do any checks. : 
2
strstr : while :  * can't go away on us before we can do any checks. : 
2
str :  * Return:[10]
strstr : INIT :  * Return: : 
2
strstr : if :  * Return: : 
2
strstr : for :  * Return: : 
2
strstr : while :  * Return: : 
2
str :  *	true (>0) if we indeed boosted the target task.[50]
strstr : INIT :  *	true (>0) if we indeed boosted the target task. : 
2
strstr : if :  *	true (>0) if we indeed boosted the target task. : 
2
strstr : for :  *	true (>0) if we indeed boosted the target task. : 
2
strstr : while :  *	true (>0) if we indeed boosted the target task. : 
2
str :  *	false (0) if we failed to boost the target.[46]
strstr : INIT :  *	false (0) if we failed to boost the target. : 
2
strstr : if :  *	false (0) if we failed to boost the target. : 
2
strstr : for :  *	false (0) if we failed to boost the target. : 
2
strstr : while :  *	false (0) if we failed to boost the target. : 
2
str :  *	-ESRCH if there's no task to yield to.[41]
strstr : INIT :  *	-ESRCH if there's no task to yield to. : 
2
strstr : if :  *	-ESRCH if there's no task to yield to. : 
2
strstr : for :  *	-ESRCH if there's no task to yield to. : 
2
strstr : while :  *	-ESRCH if there's no task to yield to. : 
2
str :  */[3]
strstr : INIT :  */ : 
2
strstr : if :  */ : 
2
strstr : for :  */ : 
2
strstr : while :  */ : 
2
str : bool __sched yield_to(struct task_struct *p, bool preempt)[58]
strstr : INIT : bool __sched yield_to(struct task_struct *p, bool preempt) : 
2
strstr : if : bool __sched yield_to(struct task_struct *p, bool preempt) : 
2
strstr : for : bool __sched yield_to(struct task_struct *p, bool preempt) : 
2
strstr : while : bool __sched yield_to(struct task_struct *p, bool preempt) : 
2
str : 	struct task_struct *curr = current;[36]
strstr : INIT : 	struct task_struct *curr = current; : 
2
strstr : if : 	struct task_struct *curr = current; : 
2
strstr : for : 	struct task_struct *curr = current; : 
2
strstr : while : 	struct task_struct *curr = current; : 
2
str : 	struct rq *rq, *p_rq;[22]
strstr : INIT : 	struct rq *rq, *p_rq; : 
2
strstr : if : 	struct rq *rq, *p_rq; : 
2
strstr : for : 	struct rq *rq, *p_rq; : 
2
strstr : while : 	struct rq *rq, *p_rq; : 
2
str : 	unsigned long flags;[21]
strstr : INIT : 	unsigned long flags; : 
2
strstr : if : 	unsigned long flags; : 
2
strstr : for : 	unsigned long flags; : 
2
strstr : while : 	unsigned long flags; : 
2
str : 	int yielded = 0;[17]
strstr : INIT : 	int yielded = 0; : 
2
strstr : if : 	int yielded = 0; : 
2
strstr : for : 	int yielded = 0; : 
2
strstr : while : 	int yielded = 0; : 
2
str : 	local_irq_save(flags);[23]
strstr : INIT : 	local_irq_save(flags); : 
2
strstr : if : 	local_irq_save(flags); : 
2
strstr : for : 	local_irq_save(flags); : 
2
strstr : while : 	local_irq_save(flags); : 
2
str : 	rq = this_rq();[16]
strstr : INIT : 	rq = this_rq(); : 
2
strstr : if : 	rq = this_rq(); : 
2
strstr : for : 	rq = this_rq(); : 
2
strstr : while : 	rq = this_rq(); : 
2
str : again:[6]
strstr : INIT : again: : 
2
strstr : if : again: : 
2
strstr : for : again: : 
2
strstr : while : again: : 
2
str : 	p_rq = task_rq(p);[19]
strstr : INIT : 	p_rq = task_rq(p); : 
2
strstr : if : 	p_rq = task_rq(p); : 
2
strstr : for : 	p_rq = task_rq(p); : 
2
strstr : while : 	p_rq = task_rq(p); : 
2
str : 	/*[3]
strstr : INIT : 	/* : 
2
strstr : if : 	/* : 
2
strstr : for : 	/* : 
2
strstr : while : 	/* : 
2
str : 	 * If we're the only runnable task on the rq and target rq also[64]
strstr : INIT : 	 * If we're the only runnable task on the rq and target rq also : 
2
strstr : if : 	 * If we're the only runnable task on the rq and target rq also : 
2
strstr : for : 	 * If we're the only runnable task on the rq and target rq also : 
2
strstr : while : 	 * If we're the only runnable task on the rq and target rq also : 
2
str : 	 * has only one task, there's absolutely no point in yielding.[63]
strstr : INIT : 	 * has only one task, there's absolutely no point in yielding. : 
2
strstr : if : 	 * has only one task, there's absolutely no point in yielding. : 
2
strstr : for : 	 * has only one task, there's absolutely no point in yielding. : 
2
strstr : while : 	 * has only one task, there's absolutely no point in yielding. : 
2
str : 	 */[4]
strstr : INIT : 	 */ : 
2
strstr : if : 	 */ : 
2
strstr : for : 	 */ : 
2
strstr : while : 	 */ : 
2
str : 	if (rq->nr_running == 1 && p_rq->nr_running == 1) {[52]
strstr : INIT : 	if (rq->nr_running == 1 && p_rq->nr_running == 1) { : 
2
strstr : if : 	if (rq->nr_running == 1 && p_rq->nr_running == 1) { : 
2
strstr : for : 	if (rq->nr_running == 1 && p_rq->nr_running == 1) { : 
2
strstr : while : 	if (rq->nr_running == 1 && p_rq->nr_running == 1) { : 
2
str : 		yielded = -ESRCH;[19]
strstr : INIT : 		yielded = -ESRCH; : 
2
strstr : if : 		yielded = -ESRCH; : 
2
strstr : for : 		yielded = -ESRCH; : 
2
strstr : while : 		yielded = -ESRCH; : 
2
str : 		goto out_irq;[15]
strstr : INIT : 		goto out_irq; : 
2
strstr : if : 		goto out_irq; : 
2
strstr : for : 		goto out_irq; : 
2
strstr : while : 		goto out_irq; : 
2
str : 	double_rq_lock(rq, p_rq);[26]
strstr : INIT : 	double_rq_lock(rq, p_rq); : 
2
strstr : if : 	double_rq_lock(rq, p_rq); : 
2
strstr : for : 	double_rq_lock(rq, p_rq); : 
2
strstr : while : 	double_rq_lock(rq, p_rq); : 
2
str : 	if (task_rq(p) != p_rq) {[26]
strstr : INIT : 	if (task_rq(p) != p_rq) { : 
2
strstr : if : 	if (task_rq(p) != p_rq) { : 
2
strstr : for : 	if (task_rq(p) != p_rq) { : 
2
strstr : while : 	if (task_rq(p) != p_rq) { : 
2
str : 		double_rq_unlock(rq, p_rq);[29]
strstr : INIT : 		double_rq_unlock(rq, p_rq); : 
2
strstr : if : 		double_rq_unlock(rq, p_rq); : 
2
strstr : for : 		double_rq_unlock(rq, p_rq); : 
2
strstr : while : 		double_rq_unlock(rq, p_rq); : 
2
str : 		goto again;[13]
strstr : INIT : 		goto again; : 
2
strstr : if : 		goto again; : 
2
strstr : for : 		goto again; : 
2
strstr : while : 		goto again; : 
2
str : 	if (!curr->sched_class->yield_to_task)[39]
strstr : INIT : 	if (!curr->sched_class->yield_to_task) : 
2
strstr : if : 	if (!curr->sched_class->yield_to_task) : 
2
strstr : for : 	if (!curr->sched_class->yield_to_task) : 
2
strstr : while : 	if (!curr->sched_class->yield_to_task) : 
2
str : 		goto out_unlock;[18]
strstr : INIT : 		goto out_unlock; : 
2
strstr : if : 		goto out_unlock; : 
2
strstr : for : 		goto out_unlock; : 
2
strstr : while : 		goto out_unlock; : 
2
str : 	if (curr->sched_class != p->sched_class)[41]
strstr : INIT : 	if (curr->sched_class != p->sched_class) : 
2
strstr : if : 	if (curr->sched_class != p->sched_class) : 
2
strstr : for : 	if (curr->sched_class != p->sched_class) : 
2
strstr : while : 	if (curr->sched_class != p->sched_class) : 
2
str : 		goto out_unlock;[18]
strstr : INIT : 		goto out_unlock; : 
2
strstr : if : 		goto out_unlock; : 
2
strstr : for : 		goto out_unlock; : 
2
strstr : while : 		goto out_unlock; : 
2
str : 	if (task_running(p_rq, p) || p->state)[39]
strstr : INIT : 	if (task_running(p_rq, p) || p->state) : 
2
strstr : if : 	if (task_running(p_rq, p) || p->state) : 
2
strstr : for : 	if (task_running(p_rq, p) || p->state) : 
2
strstr : while : 	if (task_running(p_rq, p) || p->state) : 
2
str : 		goto out_unlock;[18]
strstr : INIT : 		goto out_unlock; : 
2
strstr : if : 		goto out_unlock; : 
2
strstr : for : 		goto out_unlock; : 
2
strstr : while : 		goto out_unlock; : 
2
str : 	yielded = curr->sched_class->yield_to_task(rq, p, preempt);[60]
strstr : INIT : 	yielded = curr->sched_class->yield_to_task(rq, p, preempt); : 
2
strstr : if : 	yielded = curr->sched_class->yield_to_task(rq, p, preempt); : 
2
strstr : for : 	yielded = curr->sched_class->yield_to_task(rq, p, preempt); : 
2
strstr : while : 	yielded = curr->sched_class->yield_to_task(rq, p, preempt); : 
2
str : 	if (yielded) {[15]
strstr : INIT : 	if (yielded) { : 
2
strstr : if : 	if (yielded) { : 
2
strstr : for : 	if (yielded) { : 
2
strstr : while : 	if (yielded) { : 
2
str : 		schedstat_inc(rq, yld_count);[31]
strstr : INIT : 		schedstat_inc(rq, yld_count); : 
2
strstr : if : 		schedstat_inc(rq, yld_count); : 
2
strstr : for : 		schedstat_inc(rq, yld_count); : 
2
strstr : while : 		schedstat_inc(rq, yld_count); : 
2
str : 		/*[4]
strstr : INIT : 		/* : 
2
strstr : if : 		/* : 
2
strstr : for : 		/* : 
2
strstr : while : 		/* : 
2
str : 		 * Make p's CPU reschedule; pick_next_entity takes care of[60]
strstr : INIT : 		 * Make p's CPU reschedule; pick_next_entity takes care of : 
2
strstr : if : 		 * Make p's CPU reschedule; pick_next_entity takes care of : 
2
strstr : for : 		 * Make p's CPU reschedule; pick_next_entity takes care of : 
2
strstr : while : 		 * Make p's CPU reschedule; pick_next_entity takes care of : 
2
str : 		 * fairness.[14]
strstr : INIT : 		 * fairness. : 
2
strstr : if : 		 * fairness. : 
2
strstr : for : 		 * fairness. : 
2
strstr : while : 		 * fairness. : 
2
str : 		 */[5]
strstr : INIT : 		 */ : 
2
strstr : if : 		 */ : 
2
strstr : for : 		 */ : 
2
strstr : while : 		 */ : 
2
str : 		if (preempt && rq != p_rq)[28]
strstr : INIT : 		if (preempt && rq != p_rq) : 
2
strstr : if : 		if (preempt && rq != p_rq) : 
2
strstr : for : 		if (preempt && rq != p_rq) : 
2
strstr : while : 		if (preempt && rq != p_rq) : 
2
str : 			resched_task(p_rq->curr);[28]
strstr : INIT : 			resched_task(p_rq->curr); : 
2
strstr : if : 			resched_task(p_rq->curr); : 
2
strstr : for : 			resched_task(p_rq->curr); : 
2
strstr : while : 			resched_task(p_rq->curr); : 
2
str : out_unlock:[11]
strstr : INIT : out_unlock: : 
2
strstr : if : out_unlock: : 
2
strstr : for : out_unlock: : 
2
strstr : while : out_unlock: : 
2
str : 	double_rq_unlock(rq, p_rq);[28]
strstr : INIT : 	double_rq_unlock(rq, p_rq); : 
2
strstr : if : 	double_rq_unlock(rq, p_rq); : 
2
strstr : for : 	double_rq_unlock(rq, p_rq); : 
2
strstr : while : 	double_rq_unlock(rq, p_rq); : 
2
str : out_irq:[8]
strstr : INIT : out_irq: : 
2
strstr : if : out_irq: : 
2
strstr : for : out_irq: : 
2
strstr : while : out_irq: : 
2
str : 	local_irq_restore(flags);[26]
strstr : INIT : 	local_irq_restore(flags); : 
2
strstr : if : 	local_irq_restore(flags); : 
2
strstr : for : 	local_irq_restore(flags); : 
2
strstr : while : 	local_irq_restore(flags); : 
2
str : 	if (yielded > 0)[17]
strstr : INIT : 	if (yielded > 0) : 
2
strstr : if : 	if (yielded > 0) : 
2
strstr : for : 	if (yielded > 0) : 
2
strstr : while : 	if (yielded > 0) : 
2
str : 		schedule();[13]
strstr : INIT : 		schedule(); : 
2
strstr : if : 		schedule(); : 
2
strstr : for : 		schedule(); : 
2
strstr : while : 		schedule(); : 
2
str : 	return yielded;[16]
strstr : INIT : 	return yielded; : 
2
strstr : if : 	return yielded; : 
2
strstr : for : 	return yielded; : 
2
strstr : while : 	return yielded; : 
2
str : EXPORT_SYMBOL_GPL(yield_to);[28]
strstr : INIT : EXPORT_SYMBOL_GPL(yield_to); : 
2
strstr : if : EXPORT_SYMBOL_GPL(yield_to); : 
2
strstr : for : EXPORT_SYMBOL_GPL(yield_to); : 
2
strstr : while : EXPORT_SYMBOL_GPL(yield_to); : 
2
str :  * This task is about to go to sleep on IO. Increment rq->nr_iowait so[70]
strstr : INIT :  * This task is about to go to sleep on IO. Increment rq->nr_iowait so : 
2
strstr : if :  * This task is about to go to sleep on IO. Increment rq->nr_iowait so : 
2
strstr : for :  * This task is about to go to sleep on IO. Increment rq->nr_iowait so : 
2
strstr : while :  * This task is about to go to sleep on IO. Increment rq->nr_iowait so : 
2
str :  * that process accounting knows that this is a task in IO wait state.[70]
strstr : INIT :  * that process accounting knows that this is a task in IO wait state. : 
2
strstr : if :  * that process accounting knows that this is a task in IO wait state. : 
2
strstr : for :  * that process accounting knows that this is a task in IO wait state. : 
2
strstr : while :  * that process accounting knows that this is a task in IO wait state. : 
2
str :  */[3]
strstr : INIT :  */ : 
2
strstr : if :  */ : 
2
strstr : for :  */ : 
2
strstr : while :  */ : 
2
str : void __sched io_schedule(void)[30]
strstr : INIT : void __sched io_schedule(void) : 
2
strstr : if : void __sched io_schedule(void) : 
2
strstr : for : void __sched io_schedule(void) : 
2
strstr : while : void __sched io_schedule(void) : 
2
str : 	struct rq *rq = raw_rq();[26]
strstr : INIT : 	struct rq *rq = raw_rq(); : 
2
strstr : if : 	struct rq *rq = raw_rq(); : 
2
strstr : for : 	struct rq *rq = raw_rq(); : 
2
strstr : while : 	struct rq *rq = raw_rq(); : 
2
str : 	delayacct_blkio_start();[25]
strstr : INIT : 	delayacct_blkio_start(); : 
2
strstr : if : 	delayacct_blkio_start(); : 
2
strstr : for : 	delayacct_blkio_start(); : 
2
strstr : while : 	delayacct_blkio_start(); : 
2
str : 	atomic_inc(&rq->nr_iowait);[28]
strstr : INIT : 	atomic_inc(&rq->nr_iowait); : 
2
strstr : if : 	atomic_inc(&rq->nr_iowait); : 
2
strstr : for : 	atomic_inc(&rq->nr_iowait); : 
2
strstr : while : 	atomic_inc(&rq->nr_iowait); : 
2
str : 	blk_flush_plug(current);[25]
strstr : INIT : 	blk_flush_plug(current); : 
2
strstr : if : 	blk_flush_plug(current); : 
2
strstr : for : 	blk_flush_plug(current); : 
2
strstr : while : 	blk_flush_plug(current); : 
2
str : 	current->in_iowait = 1;[24]
strstr : INIT : 	current->in_iowait = 1; : 
2
strstr : if : 	current->in_iowait = 1; : 
2
strstr : for : 	current->in_iowait = 1; : 
2
strstr : while : 	current->in_iowait = 1; : 
2
str : 	schedule();[12]
strstr : INIT : 	schedule(); : 
2
strstr : if : 	schedule(); : 
2
strstr : for : 	schedule(); : 
2
strstr : while : 	schedule(); : 
2
str : 	current->in_iowait = 0;[24]
strstr : INIT : 	current->in_iowait = 0; : 
2
strstr : if : 	current->in_iowait = 0; : 
2
strstr : for : 	current->in_iowait = 0; : 
2
strstr : while : 	current->in_iowait = 0; : 
2
str : 	atomic_dec(&rq->nr_iowait);[28]
strstr : INIT : 	atomic_dec(&rq->nr_iowait); : 
2
strstr : if : 	atomic_dec(&rq->nr_iowait); : 
2
strstr : for : 	atomic_dec(&rq->nr_iowait); : 
2
strstr : while : 	atomic_dec(&rq->nr_iowait); : 
2
str : 	delayacct_blkio_end();[23]
strstr : INIT : 	delayacct_blkio_end(); : 
2
strstr : if : 	delayacct_blkio_end(); : 
2
strstr : for : 	delayacct_blkio_end(); : 
2
strstr : while : 	delayacct_blkio_end(); : 
2
str : EXPORT_SYMBOL(io_schedule);[27]
strstr : INIT : EXPORT_SYMBOL(io_schedule); : 
2
strstr : if : EXPORT_SYMBOL(io_schedule); : 
2
strstr : for : EXPORT_SYMBOL(io_schedule); : 
2
strstr : while : EXPORT_SYMBOL(io_schedule); : 
2
str : long __sched io_schedule_timeout(long timeout)[46]
strstr : INIT : long __sched io_schedule_timeout(long timeout) : 
2
strstr : if : long __sched io_schedule_timeout(long timeout) : 
2
strstr : for : long __sched io_schedule_timeout(long timeout) : 
2
strstr : while : long __sched io_schedule_timeout(long timeout) : 
2
str : 	struct rq *rq = raw_rq();[26]
strstr : INIT : 	struct rq *rq = raw_rq(); : 
2
strstr : if : 	struct rq *rq = raw_rq(); : 
2
strstr : for : 	struct rq *rq = raw_rq(); : 
2
strstr : while : 	struct rq *rq = raw_rq(); : 
2
str : 	long ret;[10]
strstr : INIT : 	long ret; : 
2
strstr : if : 	long ret; : 
2
strstr : for : 	long ret; : 
2
strstr : while : 	long ret; : 
2
str : 	delayacct_blkio_start();[25]
strstr : INIT : 	delayacct_blkio_start(); : 
2
strstr : if : 	delayacct_blkio_start(); : 
2
strstr : for : 	delayacct_blkio_start(); : 
2
strstr : while : 	delayacct_blkio_start(); : 
2
str : 	atomic_inc(&rq->nr_iowait);[28]
strstr : INIT : 	atomic_inc(&rq->nr_iowait); : 
2
strstr : if : 	atomic_inc(&rq->nr_iowait); : 
2
strstr : for : 	atomic_inc(&rq->nr_iowait); : 
2
strstr : while : 	atomic_inc(&rq->nr_iowait); : 
2
str : 	blk_flush_plug(current);[25]
strstr : INIT : 	blk_flush_plug(current); : 
2
strstr : if : 	blk_flush_plug(current); : 
2
strstr : for : 	blk_flush_plug(current); : 
2
strstr : while : 	blk_flush_plug(current); : 
2
str : 	current->in_iowait = 1;[24]
strstr : INIT : 	current->in_iowait = 1; : 
2
strstr : if : 	current->in_iowait = 1; : 
2
strstr : for : 	current->in_iowait = 1; : 
2
strstr : while : 	current->in_iowait = 1; : 
2
str : 	ret = schedule_timeout(timeout);[33]
strstr : INIT : 	ret = schedule_timeout(timeout); : 
2
strstr : if : 	ret = schedule_timeout(timeout); : 
2
strstr : for : 	ret = schedule_timeout(timeout); : 
2
strstr : while : 	ret = schedule_timeout(timeout); : 
2
str : 	current->in_iowait = 0;[24]
strstr : INIT : 	current->in_iowait = 0; : 
2
strstr : if : 	current->in_iowait = 0; : 
2
strstr : for : 	current->in_iowait = 0; : 
2
strstr : while : 	current->in_iowait = 0; : 
2
str : 	atomic_dec(&rq->nr_iowait);[28]
strstr : INIT : 	atomic_dec(&rq->nr_iowait); : 
2
strstr : if : 	atomic_dec(&rq->nr_iowait); : 
2
strstr : for : 	atomic_dec(&rq->nr_iowait); : 
2
strstr : while : 	atomic_dec(&rq->nr_iowait); : 
2
str : 	delayacct_blkio_end();[23]
strstr : INIT : 	delayacct_blkio_end(); : 
2
strstr : if : 	delayacct_blkio_end(); : 
2
strstr : for : 	delayacct_blkio_end(); : 
2
strstr : while : 	delayacct_blkio_end(); : 
2
str : 	return ret;[12]
strstr : INIT : 	return ret; : 
2
strstr : if : 	return ret; : 
2
strstr : for : 	return ret; : 
2
strstr : while : 	return ret; : 
2
str : /**[3]
strstr : INIT : /** : 
2
strstr : if : /** : 
2
strstr : for : /** : 
2
strstr : while : /** : 
2
str :  * sys_sched_get_priority_max - return maximum RT priority.[59]
strstr : INIT :  * sys_sched_get_priority_max - return maximum RT priority. : 
2
strstr : if :  * sys_sched_get_priority_max - return maximum RT priority. : 
2
strstr : for :  * sys_sched_get_priority_max - return maximum RT priority. : 
2
strstr : while :  * sys_sched_get_priority_max - return maximum RT priority. : 
2
str :  * @policy: scheduling class.[29]
strstr : INIT :  * @policy: scheduling class. : 
2
strstr : if :  * @policy: scheduling class. : 
2
strstr : for :  * @policy: scheduling class. : 
2
strstr : while :  * @policy: scheduling class. : 
2
str :  * Return: On success, this syscall returns the maximum[55]
strstr : INIT :  * Return: On success, this syscall returns the maximum : 
2
strstr : if :  * Return: On success, this syscall returns the maximum : 
2
strstr : for :  * Return: On success, this syscall returns the maximum : 
2
strstr : while :  * Return: On success, this syscall returns the maximum : 
2
str :  * rt_priority that can be used by a given scheduling class.[60]
strstr : INIT :  * rt_priority that can be used by a given scheduling class. : 
2
strstr : if :  * rt_priority that can be used by a given scheduling class. : 
2
strstr : for :  * rt_priority that can be used by a given scheduling class. : 
2
strstr : while :  * rt_priority that can be used by a given scheduling class. : 
2
str :  * On failure, a negative error code is returned.[49]
strstr : INIT :  * On failure, a negative error code is returned. : 
2
strstr : if :  * On failure, a negative error code is returned. : 
2
strstr : for :  * On failure, a negative error code is returned. : 
2
strstr : while :  * On failure, a negative error code is returned. : 
2
str :  */[3]
strstr : INIT :  */ : 
2
strstr : if :  */ : 
2
strstr : for :  */ : 
2
strstr : while :  */ : 
2
str : SYSCALL_DEFINE1(sched_get_priority_max, int, policy)[52]
strstr : INIT : SYSCALL_DEFINE1(sched_get_priority_max, int, policy) : 
2
strstr : if : SYSCALL_DEFINE1(sched_get_priority_max, int, policy) : 
2
strstr : for : SYSCALL_DEFINE1(sched_get_priority_max, int, policy) : 
2
strstr : while : SYSCALL_DEFINE1(sched_get_priority_max, int, policy) : 
2
str : 	int ret = -EINVAL;[19]
strstr : INIT : 	int ret = -EINVAL; : 
2
strstr : if : 	int ret = -EINVAL; : 
2
strstr : for : 	int ret = -EINVAL; : 
2
strstr : while : 	int ret = -EINVAL; : 
2
str : 	switch (policy) {[18]
strstr : INIT : 	switch (policy) { : 
2
strstr : if : 	switch (policy) { : 
2
strstr : for : 	switch (policy) { : 
2
strstr : while : 	switch (policy) { : 
2
str : 	case SCHED_FIFO:[17]
strstr : INIT : 	case SCHED_FIFO: : 
2
strstr : if : 	case SCHED_FIFO: : 
2
strstr : for : 	case SCHED_FIFO: : 
2
strstr : while : 	case SCHED_FIFO: : 
2
str : 	case SCHED_RR:[15]
strstr : INIT : 	case SCHED_RR: : 
2
strstr : if : 	case SCHED_RR: : 
2
strstr : for : 	case SCHED_RR: : 
2
strstr : while : 	case SCHED_RR: : 
2
str : 		ret = MAX_USER_RT_PRIO-1;[27]
strstr : INIT : 		ret = MAX_USER_RT_PRIO-1; : 
2
strstr : if : 		ret = MAX_USER_RT_PRIO-1; : 
2
strstr : for : 		ret = MAX_USER_RT_PRIO-1; : 
2
strstr : while : 		ret = MAX_USER_RT_PRIO-1; : 
2
str : 		break;[8]
strstr : INIT : 		break; : 
2
strstr : if : 		break; : 
2
strstr : for : 		break; : 
2
strstr : while : 		break; : 
2
str : 	case SCHED_DEADLINE:[21]
strstr : INIT : 	case SCHED_DEADLINE: : 
2
strstr : if : 	case SCHED_DEADLINE: : 
2
strstr : for : 	case SCHED_DEADLINE: : 
2
strstr : while : 	case SCHED_DEADLINE: : 
2
str : 	case SCHED_NORMAL:[19]
strstr : INIT : 	case SCHED_NORMAL: : 
2
strstr : if : 	case SCHED_NORMAL: : 
2
strstr : for : 	case SCHED_NORMAL: : 
2
strstr : while : 	case SCHED_NORMAL: : 
2
str : 	case SCHED_BATCH:[18]
strstr : INIT : 	case SCHED_BATCH: : 
2
strstr : if : 	case SCHED_BATCH: : 
2
strstr : for : 	case SCHED_BATCH: : 
2
strstr : while : 	case SCHED_BATCH: : 
2
str : 	case SCHED_IDLE:[17]
strstr : INIT : 	case SCHED_IDLE: : 
2
strstr : if : 	case SCHED_IDLE: : 
2
strstr : for : 	case SCHED_IDLE: : 
2
strstr : while : 	case SCHED_IDLE: : 
2
str : 		ret = 0;[10]
strstr : INIT : 		ret = 0; : 
2
strstr : if : 		ret = 0; : 
2
strstr : for : 		ret = 0; : 
2
strstr : while : 		ret = 0; : 
2
str : 		break;[8]
strstr : INIT : 		break; : 
2
strstr : if : 		break; : 
2
strstr : for : 		break; : 
2
strstr : while : 		break; : 
2
str : 	return ret;[12]
strstr : INIT : 	return ret; : 
2
strstr : if : 	return ret; : 
2
strstr : for : 	return ret; : 
2
strstr : while : 	return ret; : 
2
str : /**[3]
strstr : INIT : /** : 
2
strstr : if : /** : 
2
strstr : for : /** : 
2
strstr : while : /** : 
2
str :  * sys_sched_get_priority_min - return minimum RT priority.[59]
strstr : INIT :  * sys_sched_get_priority_min - return minimum RT priority. : 
2
strstr : if :  * sys_sched_get_priority_min - return minimum RT priority. : 
2
strstr : for :  * sys_sched_get_priority_min - return minimum RT priority. : 
2
strstr : while :  * sys_sched_get_priority_min - return minimum RT priority. : 
2
str :  * @policy: scheduling class.[29]
strstr : INIT :  * @policy: scheduling class. : 
2
strstr : if :  * @policy: scheduling class. : 
2
strstr : for :  * @policy: scheduling class. : 
2
strstr : while :  * @policy: scheduling class. : 
2
str :  * Return: On success, this syscall returns the minimum[55]
strstr : INIT :  * Return: On success, this syscall returns the minimum : 
2
strstr : if :  * Return: On success, this syscall returns the minimum : 
2
strstr : for :  * Return: On success, this syscall returns the minimum : 
2
strstr : while :  * Return: On success, this syscall returns the minimum : 
2
str :  * rt_priority that can be used by a given scheduling class.[60]
strstr : INIT :  * rt_priority that can be used by a given scheduling class. : 
2
strstr : if :  * rt_priority that can be used by a given scheduling class. : 
2
strstr : for :  * rt_priority that can be used by a given scheduling class. : 
2
strstr : while :  * rt_priority that can be used by a given scheduling class. : 
2
str :  * On failure, a negative error code is returned.[49]
strstr : INIT :  * On failure, a negative error code is returned. : 
2
strstr : if :  * On failure, a negative error code is returned. : 
2
strstr : for :  * On failure, a negative error code is returned. : 
2
strstr : while :  * On failure, a negative error code is returned. : 
2
str :  */[3]
strstr : INIT :  */ : 
2
strstr : if :  */ : 
2
strstr : for :  */ : 
2
strstr : while :  */ : 
2
str : SYSCALL_DEFINE1(sched_get_priority_min, int, policy)[52]
strstr : INIT : SYSCALL_DEFINE1(sched_get_priority_min, int, policy) : 
2
strstr : if : SYSCALL_DEFINE1(sched_get_priority_min, int, policy) : 
2
strstr : for : SYSCALL_DEFINE1(sched_get_priority_min, int, policy) : 
2
strstr : while : SYSCALL_DEFINE1(sched_get_priority_min, int, policy) : 
2
str : 	int ret = -EINVAL;[19]
strstr : INIT : 	int ret = -EINVAL; : 
2
strstr : if : 	int ret = -EINVAL; : 
2
strstr : for : 	int ret = -EINVAL; : 
2
strstr : while : 	int ret = -EINVAL; : 
2
str : 	switch (policy) {[18]
strstr : INIT : 	switch (policy) { : 
2
strstr : if : 	switch (policy) { : 
2
strstr : for : 	switch (policy) { : 
2
strstr : while : 	switch (policy) { : 
2
str : 	case SCHED_FIFO:[17]
strstr : INIT : 	case SCHED_FIFO: : 
2
strstr : if : 	case SCHED_FIFO: : 
2
strstr : for : 	case SCHED_FIFO: : 
2
strstr : while : 	case SCHED_FIFO: : 
2
str : 	case SCHED_RR:[15]
strstr : INIT : 	case SCHED_RR: : 
2
strstr : if : 	case SCHED_RR: : 
2
strstr : for : 	case SCHED_RR: : 
2
strstr : while : 	case SCHED_RR: : 
2
str : 		ret = 1;[10]
strstr : INIT : 		ret = 1; : 
2
strstr : if : 		ret = 1; : 
2
strstr : for : 		ret = 1; : 
2
strstr : while : 		ret = 1; : 
2
str : 		break;[8]
strstr : INIT : 		break; : 
2
strstr : if : 		break; : 
2
strstr : for : 		break; : 
2
strstr : while : 		break; : 
2
str : 	case SCHED_DEADLINE:[21]
strstr : INIT : 	case SCHED_DEADLINE: : 
2
strstr : if : 	case SCHED_DEADLINE: : 
2
strstr : for : 	case SCHED_DEADLINE: : 
2
strstr : while : 	case SCHED_DEADLINE: : 
2
str : 	case SCHED_NORMAL:[19]
strstr : INIT : 	case SCHED_NORMAL: : 
2
strstr : if : 	case SCHED_NORMAL: : 
2
strstr : for : 	case SCHED_NORMAL: : 
2
strstr : while : 	case SCHED_NORMAL: : 
2
str : 	case SCHED_BATCH:[18]
strstr : INIT : 	case SCHED_BATCH: : 
2
strstr : if : 	case SCHED_BATCH: : 
2
strstr : for : 	case SCHED_BATCH: : 
2
strstr : while : 	case SCHED_BATCH: : 
2
str : 	case SCHED_IDLE:[17]
strstr : INIT : 	case SCHED_IDLE: : 
2
strstr : if : 	case SCHED_IDLE: : 
2
strstr : for : 	case SCHED_IDLE: : 
2
strstr : while : 	case SCHED_IDLE: : 
2
str : 		ret = 0;[10]
strstr : INIT : 		ret = 0; : 
2
strstr : if : 		ret = 0; : 
2
strstr : for : 		ret = 0; : 
2
strstr : while : 		ret = 0; : 
2
str : 	return ret;[12]
strstr : INIT : 	return ret; : 
2
strstr : if : 	return ret; : 
2
strstr : for : 	return ret; : 
2
strstr : while : 	return ret; : 
2
str : /**[3]
strstr : INIT : /** : 
2
strstr : if : /** : 
2
strstr : for : /** : 
2
strstr : while : /** : 
2
str :  * sys_sched_rr_get_interval - return the default timeslice of a process.[73]
strstr : INIT :  * sys_sched_rr_get_interval - return the default timeslice of a process. : 
2
strstr : if :  * sys_sched_rr_get_interval - return the default timeslice of a process. : 
2
strstr : for :  * sys_sched_rr_get_interval - return the default timeslice of a process. : 
2
strstr : while :  * sys_sched_rr_get_interval - return the default timeslice of a process. : 
2
str :  * @pid: pid of the process.[28]
strstr : INIT :  * @pid: pid of the process. : 
2
strstr : if :  * @pid: pid of the process. : 
2
strstr : for :  * @pid: pid of the process. : 
2
strstr : while :  * @pid: pid of the process. : 
2
str :  * @interval: userspace pointer to the timeslice value.[55]
strstr : INIT :  * @interval: userspace pointer to the timeslice value. : 
2
strstr : if :  * @interval: userspace pointer to the timeslice value. : 
2
strstr : for :  * @interval: userspace pointer to the timeslice value. : 
2
strstr : while :  * @interval: userspace pointer to the timeslice value. : 
2
str :  * this syscall writes the default timeslice value of a given process[69]
strstr : INIT :  * this syscall writes the default timeslice value of a given process : 
2
strstr : if :  * this syscall writes the default timeslice value of a given process : 
2
strstr : for :  * this syscall writes the default timeslice value of a given process : 
2
strstr : while :  * this syscall writes the default timeslice value of a given process : 
2
str :  * into the user-space timespec buffer. A value of '0' means infinity.[70]
strstr : INIT :  * into the user-space timespec buffer. A value of '0' means infinity. : 
2
strstr : if :  * into the user-space timespec buffer. A value of '0' means infinity. : 
2
strstr : for :  * into the user-space timespec buffer. A value of '0' means infinity. : 
2
strstr : while :  * into the user-space timespec buffer. A value of '0' means infinity. : 
2
str :  * Return: On success, 0 and the timeslice is in @interval. Otherwise,[70]
strstr : INIT :  * Return: On success, 0 and the timeslice is in @interval. Otherwise, : 
2
strstr : if :  * Return: On success, 0 and the timeslice is in @interval. Otherwise, : 
2
strstr : for :  * Return: On success, 0 and the timeslice is in @interval. Otherwise, : 
2
strstr : while :  * Return: On success, 0 and the timeslice is in @interval. Otherwise, : 
2
str :  * an error code.[17]
strstr : INIT :  * an error code. : 
2
strstr : if :  * an error code. : 
2
strstr : for :  * an error code. : 
2
strstr : while :  * an error code. : 
2
str :  */[3]
strstr : INIT :  */ : 
2
strstr : if :  */ : 
2
strstr : for :  */ : 
2
strstr : while :  */ : 
2
str : SYSCALL_DEFINE2(sched_rr_get_interval, pid_t, pid,[50]
strstr : INIT : SYSCALL_DEFINE2(sched_rr_get_interval, pid_t, pid, : 
2
strstr : if : SYSCALL_DEFINE2(sched_rr_get_interval, pid_t, pid, : 
2
strstr : for : SYSCALL_DEFINE2(sched_rr_get_interval, pid_t, pid, : 
2
strstr : while : SYSCALL_DEFINE2(sched_rr_get_interval, pid_t, pid, : 
2
str : 		struct timespec __user *, interval)[37]
strstr : INIT : 		struct timespec __user *, interval) : 
2
strstr : if : 		struct timespec __user *, interval) : 
2
strstr : for : 		struct timespec __user *, interval) : 
2
strstr : while : 		struct timespec __user *, interval) : 
2
str : 	struct task_struct *p;[23]
strstr : INIT : 	struct task_struct *p; : 
2
strstr : if : 	struct task_struct *p; : 
2
strstr : for : 	struct task_struct *p; : 
2
strstr : while : 	struct task_struct *p; : 
2
str : 	unsigned int time_slice;[25]
strstr : INIT : 	unsigned int time_slice; : 
2
strstr : if : 	unsigned int time_slice; : 
2
strstr : for : 	unsigned int time_slice; : 
2
strstr : while : 	unsigned int time_slice; : 
2
str : 	unsigned long flags;[21]
strstr : INIT : 	unsigned long flags; : 
2
strstr : if : 	unsigned long flags; : 
2
strstr : for : 	unsigned long flags; : 
2
strstr : while : 	unsigned long flags; : 
2
str : 	struct rq *rq;[15]
strstr : INIT : 	struct rq *rq; : 
2
strstr : if : 	struct rq *rq; : 
2
strstr : for : 	struct rq *rq; : 
2
strstr : while : 	struct rq *rq; : 
2
str : 	int retval;[12]
strstr : INIT : 	int retval; : 
2
strstr : if : 	int retval; : 
2
strstr : for : 	int retval; : 
2
strstr : while : 	int retval; : 
2
str : 	struct timespec t;[19]
strstr : INIT : 	struct timespec t; : 
2
strstr : if : 	struct timespec t; : 
2
strstr : for : 	struct timespec t; : 
2
strstr : while : 	struct timespec t; : 
2
str : 	if (pid < 0)[13]
strstr : INIT : 	if (pid < 0) : 
2
strstr : if : 	if (pid < 0) : 
2
strstr : for : 	if (pid < 0) : 
2
strstr : while : 	if (pid < 0) : 
2
str : 		return -EINVAL;[17]
strstr : INIT : 		return -EINVAL; : 
2
strstr : if : 		return -EINVAL; : 
2
strstr : for : 		return -EINVAL; : 
2
strstr : while : 		return -EINVAL; : 
2
str : 	retval = -ESRCH;[17]
strstr : INIT : 	retval = -ESRCH; : 
2
strstr : if : 	retval = -ESRCH; : 
2
strstr : for : 	retval = -ESRCH; : 
2
strstr : while : 	retval = -ESRCH; : 
2
str : 	rcu_read_lock();[17]
strstr : INIT : 	rcu_read_lock(); : 
2
strstr : if : 	rcu_read_lock(); : 
2
strstr : for : 	rcu_read_lock(); : 
2
strstr : while : 	rcu_read_lock(); : 
2
str : 	p = find_process_by_pid(pid);[30]
strstr : INIT : 	p = find_process_by_pid(pid); : 
2
strstr : if : 	p = find_process_by_pid(pid); : 
2
strstr : for : 	p = find_process_by_pid(pid); : 
2
strstr : while : 	p = find_process_by_pid(pid); : 
2
str : 	if (!p)[8]
strstr : INIT : 	if (!p) : 
2
strstr : if : 	if (!p) : 
2
strstr : for : 	if (!p) : 
2
strstr : while : 	if (!p) : 
2
str : 		goto out_unlock;[18]
strstr : INIT : 		goto out_unlock; : 
2
strstr : if : 		goto out_unlock; : 
2
strstr : for : 		goto out_unlock; : 
2
strstr : while : 		goto out_unlock; : 
2
str : 	retval = security_task_getscheduler(p);[40]
strstr : INIT : 	retval = security_task_getscheduler(p); : 
2
strstr : if : 	retval = security_task_getscheduler(p); : 
2
strstr : for : 	retval = security_task_getscheduler(p); : 
2
strstr : while : 	retval = security_task_getscheduler(p); : 
2
str : 	if (retval)[12]
strstr : INIT : 	if (retval) : 
2
strstr : if : 	if (retval) : 
2
strstr : for : 	if (retval) : 
2
strstr : while : 	if (retval) : 
2
str : 		goto out_unlock;[18]
strstr : INIT : 		goto out_unlock; : 
2
strstr : if : 		goto out_unlock; : 
2
strstr : for : 		goto out_unlock; : 
2
strstr : while : 		goto out_unlock; : 
2
str : 	rq = task_rq_lock(p, &flags);[30]
strstr : INIT : 	rq = task_rq_lock(p, &flags); : 
2
strstr : if : 	rq = task_rq_lock(p, &flags); : 
2
strstr : for : 	rq = task_rq_lock(p, &flags); : 
2
strstr : while : 	rq = task_rq_lock(p, &flags); : 
2
str : 	time_slice = 0;[16]
strstr : INIT : 	time_slice = 0; : 
2
strstr : if : 	time_slice = 0; : 
2
strstr : for : 	time_slice = 0; : 
2
strstr : while : 	time_slice = 0; : 
2
str : 	if (p->sched_class->get_rr_interval)[37]
strstr : INIT : 	if (p->sched_class->get_rr_interval) : 
2
strstr : if : 	if (p->sched_class->get_rr_interval) : 
2
strstr : for : 	if (p->sched_class->get_rr_interval) : 
2
strstr : while : 	if (p->sched_class->get_rr_interval) : 
2
str : 		time_slice = p->sched_class->get_rr_interval(rq, p);[54]
strstr : INIT : 		time_slice = p->sched_class->get_rr_interval(rq, p); : 
2
strstr : if : 		time_slice = p->sched_class->get_rr_interval(rq, p); : 
2
strstr : for : 		time_slice = p->sched_class->get_rr_interval(rq, p); : 
2
strstr : while : 		time_slice = p->sched_class->get_rr_interval(rq, p); : 
2
str : 	task_rq_unlock(rq, p, &flags);[31]
strstr : INIT : 	task_rq_unlock(rq, p, &flags); : 
2
strstr : if : 	task_rq_unlock(rq, p, &flags); : 
2
strstr : for : 	task_rq_unlock(rq, p, &flags); : 
2
strstr : while : 	task_rq_unlock(rq, p, &flags); : 
2
str : 	rcu_read_unlock();[19]
strstr : INIT : 	rcu_read_unlock(); : 
2
strstr : if : 	rcu_read_unlock(); : 
2
strstr : for : 	rcu_read_unlock(); : 
2
strstr : while : 	rcu_read_unlock(); : 
2
str : 	jiffies_to_timespec(time_slice, &t);[37]
strstr : INIT : 	jiffies_to_timespec(time_slice, &t); : 
2
strstr : if : 	jiffies_to_timespec(time_slice, &t); : 
2
strstr : for : 	jiffies_to_timespec(time_slice, &t); : 
2
strstr : while : 	jiffies_to_timespec(time_slice, &t); : 
2
str : 	retval = copy_to_user(interval, &t, sizeof(t)) ? -EFAULT : 0;[62]
strstr : INIT : 	retval = copy_to_user(interval, &t, sizeof(t)) ? -EFAULT : 0; : 
2
strstr : if : 	retval = copy_to_user(interval, &t, sizeof(t)) ? -EFAULT : 0; : 
2
strstr : for : 	retval = copy_to_user(interval, &t, sizeof(t)) ? -EFAULT : 0; : 
2
strstr : while : 	retval = copy_to_user(interval, &t, sizeof(t)) ? -EFAULT : 0; : 
2
str : 	return retval;[15]
strstr : INIT : 	return retval; : 
2
strstr : if : 	return retval; : 
2
strstr : for : 	return retval; : 
2
strstr : while : 	return retval; : 
2
str : out_unlock:[11]
strstr : INIT : out_unlock: : 
2
strstr : if : out_unlock: : 
2
strstr : for : out_unlock: : 
2
strstr : while : out_unlock: : 
2
str : 	rcu_read_unlock();[19]
strstr : INIT : 	rcu_read_unlock(); : 
2
strstr : if : 	rcu_read_unlock(); : 
2
strstr : for : 	rcu_read_unlock(); : 
2
strstr : while : 	rcu_read_unlock(); : 
2
str : 	return retval;[15]
strstr : INIT : 	return retval; : 
2
strstr : if : 	return retval; : 
2
strstr : for : 	return retval; : 
2
strstr : while : 	return retval; : 
2
str : static const char stat_nam[] = TASK_STATE_TO_CHAR_STR;[54]
strstr : INIT : static const char stat_nam[] = TASK_STATE_TO_CHAR_STR; : 
2
strstr : if : static const char stat_nam[] = TASK_STATE_TO_CHAR_STR; : 
2
strstr : for : static const char stat_nam[] = TASK_STATE_TO_CHAR_STR; : 
2
strstr : while : static const char stat_nam[] = TASK_STATE_TO_CHAR_STR; : 
2
str : void sched_show_task(struct task_struct *p)[43]
strstr : INIT : void sched_show_task(struct task_struct *p) : 
2
strstr : if : void sched_show_task(struct task_struct *p) : 
2
strstr : for : void sched_show_task(struct task_struct *p) : 
2
strstr : while : void sched_show_task(struct task_struct *p) : 
2
str : 	unsigned long free = 0;[24]
strstr : INIT : 	unsigned long free = 0; : 
2
strstr : if : 	unsigned long free = 0; : 
2
strstr : for : 	unsigned long free = 0; : 
2
strstr : while : 	unsigned long free = 0; : 
2
str : 	int ppid;[10]
strstr : INIT : 	int ppid; : 
2
strstr : if : 	int ppid; : 
2
strstr : for : 	int ppid; : 
2
strstr : while : 	int ppid; : 
2
str : 	unsigned state;[16]
strstr : INIT : 	unsigned state; : 
2
strstr : if : 	unsigned state; : 
2
strstr : for : 	unsigned state; : 
2
strstr : while : 	unsigned state; : 
2
str : 	state = p->state ? __ffs(p->state) + 1 : 0;[44]
strstr : INIT : 	state = p->state ? __ffs(p->state) + 1 : 0; : 
2
strstr : if : 	state = p->state ? __ffs(p->state) + 1 : 0; : 
2
strstr : for : 	state = p->state ? __ffs(p->state) + 1 : 0; : 
2
strstr : while : 	state = p->state ? __ffs(p->state) + 1 : 0; : 
2
str : 	printk(KERN_INFO "%-15.15s %c", p->comm,[41]
strstr : INIT : 	printk(KERN_INFO "%-15.15s %c", p->comm, : 
2
strstr : if : 	printk(KERN_INFO "%-15.15s %c", p->comm, : 
2
strstr : for : 	printk(KERN_INFO "%-15.15s %c", p->comm, : 
2
strstr : while : 	printk(KERN_INFO "%-15.15s %c", p->comm, : 
2
str : 		state < sizeof(stat_nam) - 1 ? stat_nam[state] : '?');[56]
strstr : INIT : 		state < sizeof(stat_nam) - 1 ? stat_nam[state] : '?'); : 
2
strstr : if : 		state < sizeof(stat_nam) - 1 ? stat_nam[state] : '?'); : 
2
strstr : for : 		state < sizeof(stat_nam) - 1 ? stat_nam[state] : '?'); : 
2
strstr : while : 		state < sizeof(stat_nam) - 1 ? stat_nam[state] : '?'); : 
2
str : #if BITS_PER_LONG == 32[23]
strstr : INIT : #if BITS_PER_LONG == 32 : 
2
strstr : if : #if BITS_PER_LONG == 32 : 
2
strstr : for : #if BITS_PER_LONG == 32 : 
2
strstr : while : #if BITS_PER_LONG == 32 : 
2
str : 	if (state == TASK_RUNNING)[27]
strstr : INIT : 	if (state == TASK_RUNNING) : 
2
strstr : if : 	if (state == TASK_RUNNING) : 
2
strstr : for : 	if (state == TASK_RUNNING) : 
2
strstr : while : 	if (state == TASK_RUNNING) : 
2
str : 		printk(KERN_CONT " running  ");[33]
strstr : INIT : 		printk(KERN_CONT " running  "); : 
2
strstr : if : 		printk(KERN_CONT " running  "); : 
2
strstr : for : 		printk(KERN_CONT " running  "); : 
2
strstr : while : 		printk(KERN_CONT " running  "); : 
2
str : 	else[5]
strstr : INIT : 	else : 
2
strstr : if : 	else : 
2
strstr : for : 	else : 
2
strstr : while : 	else : 
2
str : 		printk(KERN_CONT " %08lx ", thread_saved_pc(p));[50]
strstr : INIT : 		printk(KERN_CONT " %08lx ", thread_saved_pc(p)); : 
2
strstr : if : 		printk(KERN_CONT " %08lx ", thread_saved_pc(p)); : 
2
strstr : for : 		printk(KERN_CONT " %08lx ", thread_saved_pc(p)); : 
2
strstr : while : 		printk(KERN_CONT " %08lx ", thread_saved_pc(p)); : 
2
str : #else[5]
strstr : INIT : #else : 
2
strstr : if : #else : 
2
strstr : for : #else : 
2
strstr : while : #else : 
2
str : 	if (state == TASK_RUNNING)[27]
strstr : INIT : 	if (state == TASK_RUNNING) : 
2
strstr : if : 	if (state == TASK_RUNNING) : 
2
strstr : for : 	if (state == TASK_RUNNING) : 
2
strstr : while : 	if (state == TASK_RUNNING) : 
2
str : 		printk(KERN_CONT "  running task    ");[41]
strstr : INIT : 		printk(KERN_CONT "  running task    "); : 
2
strstr : if : 		printk(KERN_CONT "  running task    "); : 
2
strstr : for : 		printk(KERN_CONT "  running task    "); : 
2
strstr : while : 		printk(KERN_CONT "  running task    "); : 
2
str : 	else[5]
strstr : INIT : 	else : 
2
strstr : if : 	else : 
2
strstr : for : 	else : 
2
strstr : while : 	else : 
2
str : 		printk(KERN_CONT " %016lx ", thread_saved_pc(p));[51]
strstr : INIT : 		printk(KERN_CONT " %016lx ", thread_saved_pc(p)); : 
2
strstr : if : 		printk(KERN_CONT " %016lx ", thread_saved_pc(p)); : 
2
strstr : for : 		printk(KERN_CONT " %016lx ", thread_saved_pc(p)); : 
2
strstr : while : 		printk(KERN_CONT " %016lx ", thread_saved_pc(p)); : 
2
str : #endif[6]
strstr : INIT : #endif : 
2
strstr : if : #endif : 
2
strstr : for : #endif : 
2
strstr : while : #endif : 
2
str : #ifdef CONFIG_DEBUG_STACK_USAGE[31]
strstr : INIT : #ifdef CONFIG_DEBUG_STACK_USAGE : 
2
strstr : if : #ifdef CONFIG_DEBUG_STACK_USAGE : 
2
strstr : for : #ifdef CONFIG_DEBUG_STACK_USAGE : 
2
strstr : while : #ifdef CONFIG_DEBUG_STACK_USAGE : 
2
str : 	free = stack_not_used(p);[26]
strstr : INIT : 	free = stack_not_used(p); : 
2
strstr : if : 	free = stack_not_used(p); : 
2
strstr : for : 	free = stack_not_used(p); : 
2
strstr : while : 	free = stack_not_used(p); : 
2
str : #endif[6]
strstr : INIT : #endif : 
2
strstr : if : #endif : 
2
strstr : for : #endif : 
2
strstr : while : #endif : 
2
str : 	rcu_read_lock();[17]
strstr : INIT : 	rcu_read_lock(); : 
2
strstr : if : 	rcu_read_lock(); : 
2
strstr : for : 	rcu_read_lock(); : 
2
strstr : while : 	rcu_read_lock(); : 
2
str : 	ppid = task_pid_nr(rcu_dereference(p->real_parent));[53]
strstr : INIT : 	ppid = task_pid_nr(rcu_dereference(p->real_parent)); : 
2
strstr : if : 	ppid = task_pid_nr(rcu_dereference(p->real_parent)); : 
2
strstr : for : 	ppid = task_pid_nr(rcu_dereference(p->real_parent)); : 
2
strstr : while : 	ppid = task_pid_nr(rcu_dereference(p->real_parent)); : 
2
str : 	rcu_read_unlock();[19]
strstr : INIT : 	rcu_read_unlock(); : 
2
strstr : if : 	rcu_read_unlock(); : 
2
strstr : for : 	rcu_read_unlock(); : 
2
strstr : while : 	rcu_read_unlock(); : 
2
str : 	printk(KERN_CONT "%5lu %5d %6d 0x%08lx\n", free,[49]
strstr : INIT : 	printk(KERN_CONT "%5lu %5d %6d 0x%08lx\n", free, : 
2
strstr : if : 	printk(KERN_CONT "%5lu %5d %6d 0x%08lx\n", free, : 
2
strstr : for : 	printk(KERN_CONT "%5lu %5d %6d 0x%08lx\n", free, : 
2
strstr : while : 	printk(KERN_CONT "%5lu %5d %6d 0x%08lx\n", free, : 
2
str : 		task_pid_nr(p), ppid,[23]
strstr : INIT : 		task_pid_nr(p), ppid, : 
2
strstr : if : 		task_pid_nr(p), ppid, : 
2
strstr : for : 		task_pid_nr(p), ppid, : 
2
strstr : while : 		task_pid_nr(p), ppid, : 
2
str : 		(unsigned long)task_thread_info(p)->flags);[45]
strstr : INIT : 		(unsigned long)task_thread_info(p)->flags); : 
2
strstr : if : 		(unsigned long)task_thread_info(p)->flags); : 
2
strstr : for : 		(unsigned long)task_thread_info(p)->flags); : 
2
strstr : while : 		(unsigned long)task_thread_info(p)->flags); : 
2
str : 	print_worker_info(KERN_INFO, p);[33]
strstr : INIT : 	print_worker_info(KERN_INFO, p); : 
2
strstr : if : 	print_worker_info(KERN_INFO, p); : 
2
strstr : for : 	print_worker_info(KERN_INFO, p); : 
2
strstr : while : 	print_worker_info(KERN_INFO, p); : 
2
str : 	show_stack(p, NULL);[21]
strstr : INIT : 	show_stack(p, NULL); : 
2
strstr : if : 	show_stack(p, NULL); : 
2
strstr : for : 	show_stack(p, NULL); : 
2
strstr : while : 	show_stack(p, NULL); : 
2
str : void show_state_filter(unsigned long state_filter)[50]
strstr : INIT : void show_state_filter(unsigned long state_filter) : 
2
strstr : if : void show_state_filter(unsigned long state_filter) : 
2
strstr : for : void show_state_filter(unsigned long state_filter) : 
2
strstr : while : void show_state_filter(unsigned long state_filter) : 
2
str : 	struct task_struct *g, *p;[27]
strstr : INIT : 	struct task_struct *g, *p; : 
2
strstr : if : 	struct task_struct *g, *p; : 
2
strstr : for : 	struct task_struct *g, *p; : 
2
strstr : while : 	struct task_struct *g, *p; : 
2
str : #if BITS_PER_LONG == 32[23]
strstr : INIT : #if BITS_PER_LONG == 32 : 
2
strstr : if : #if BITS_PER_LONG == 32 : 
2
strstr : for : #if BITS_PER_LONG == 32 : 
2
strstr : while : #if BITS_PER_LONG == 32 : 
2
str : 	printk(KERN_INFO[17]
strstr : INIT : 	printk(KERN_INFO : 
2
strstr : if : 	printk(KERN_INFO : 
2
strstr : for : 	printk(KERN_INFO : 
2
strstr : while : 	printk(KERN_INFO : 
2
str : 		"  task                PC stack   pid father\n");[51]
strstr : INIT : 		"  task                PC stack   pid father\n"); : 
2
strstr : if : 		"  task                PC stack   pid father\n"); : 
2
strstr : for : 		"  task                PC stack   pid father\n"); : 
2
strstr : while : 		"  task                PC stack   pid father\n"); : 
2
str : #else[5]
strstr : INIT : #else : 
2
strstr : if : #else : 
2
strstr : for : #else : 
2
strstr : while : #else : 
2
str : 	printk(KERN_INFO[17]
strstr : INIT : 	printk(KERN_INFO : 
2
strstr : if : 	printk(KERN_INFO : 
2
strstr : for : 	printk(KERN_INFO : 
2
strstr : while : 	printk(KERN_INFO : 
2
str : 		"  task                        PC stack   pid father\n");[59]
strstr : INIT : 		"  task                        PC stack   pid father\n"); : 
2
strstr : if : 		"  task                        PC stack   pid father\n"); : 
2
strstr : for : 		"  task                        PC stack   pid father\n"); : 
2
strstr : while : 		"  task                        PC stack   pid father\n"); : 
2
str : #endif[6]
strstr : INIT : #endif : 
2
strstr : if : #endif : 
2
strstr : for : #endif : 
2
strstr : while : #endif : 
2
str : 	rcu_read_lock();[17]
strstr : INIT : 	rcu_read_lock(); : 
2
strstr : if : 	rcu_read_lock(); : 
2
strstr : for : 	rcu_read_lock(); : 
2
strstr : while : 	rcu_read_lock(); : 
2
str : 	do_each_thread(g, p) {[23]
strstr : INIT : 	do_each_thread(g, p) { : 
2
strstr : if : 	do_each_thread(g, p) { : 
2
strstr : for : 	do_each_thread(g, p) { : 
2
strstr : while : 	do_each_thread(g, p) { : 
2
str : 		/*[4]
strstr : INIT : 		/* : 
2
strstr : if : 		/* : 
2
strstr : for : 		/* : 
2
strstr : while : 		/* : 
2
str : 		 * reset the NMI-timeout, listing all files on a slow[55]
strstr : INIT : 		 * reset the NMI-timeout, listing all files on a slow : 
2
strstr : if : 		 * reset the NMI-timeout, listing all files on a slow : 
2
strstr : for : 		 * reset the NMI-timeout, listing all files on a slow : 
2
strstr : while : 		 * reset the NMI-timeout, listing all files on a slow : 
2
str : 		 * console might take a lot of time:[38]
strstr : INIT : 		 * console might take a lot of time: : 
2
strstr : if : 		 * console might take a lot of time: : 
2
strstr : for : 		 * console might take a lot of time: : 
2
strstr : while : 		 * console might take a lot of time: : 
2
str : 		 */[5]
strstr : INIT : 		 */ : 
2
strstr : if : 		 */ : 
2
strstr : for : 		 */ : 
2
strstr : while : 		 */ : 
2
str : 		touch_nmi_watchdog();[23]
strstr : INIT : 		touch_nmi_watchdog(); : 
2
strstr : if : 		touch_nmi_watchdog(); : 
2
strstr : for : 		touch_nmi_watchdog(); : 
2
strstr : while : 		touch_nmi_watchdog(); : 
2
str : 		if (!state_filter || (p->state & state_filter))[49]
strstr : INIT : 		if (!state_filter || (p->state & state_filter)) : 
2
strstr : if : 		if (!state_filter || (p->state & state_filter)) : 
2
strstr : for : 		if (!state_filter || (p->state & state_filter)) : 
2
strstr : while : 		if (!state_filter || (p->state & state_filter)) : 
2
str : 			sched_show_task(p);[22]
strstr : INIT : 			sched_show_task(p); : 
2
strstr : if : 			sched_show_task(p); : 
2
strstr : for : 			sched_show_task(p); : 
2
strstr : while : 			sched_show_task(p); : 
2
str : 	} while_each_thread(g, p);[27]
strstr : INIT : 	} while_each_thread(g, p); : 
2
strstr : if : 	} while_each_thread(g, p); : 
2
strstr : for : 	} while_each_thread(g, p); : 
2
strstr : while : 	} while_each_thread(g, p); : 
2
str : 	touch_all_softlockup_watchdogs();[34]
strstr : INIT : 	touch_all_softlockup_watchdogs(); : 
2
strstr : if : 	touch_all_softlockup_watchdogs(); : 
2
strstr : for : 	touch_all_softlockup_watchdogs(); : 
2
strstr : while : 	touch_all_softlockup_watchdogs(); : 
2
str : #ifdef CONFIG_SCHED_DEBUG[25]
strstr : INIT : #ifdef CONFIG_SCHED_DEBUG : 
2
strstr : if : #ifdef CONFIG_SCHED_DEBUG : 
2
strstr : for : #ifdef CONFIG_SCHED_DEBUG : 
2
strstr : while : #ifdef CONFIG_SCHED_DEBUG : 
2
str : 	sysrq_sched_debug_show();[26]
strstr : INIT : 	sysrq_sched_debug_show(); : 
2
strstr : if : 	sysrq_sched_debug_show(); : 
2
strstr : for : 	sysrq_sched_debug_show(); : 
2
strstr : while : 	sysrq_sched_debug_show(); : 
2
str : #endif[6]
strstr : INIT : #endif : 
2
strstr : if : #endif : 
2
strstr : for : #endif : 
2
strstr : while : #endif : 
2
str : 	rcu_read_unlock();[19]
strstr : INIT : 	rcu_read_unlock(); : 
2
strstr : if : 	rcu_read_unlock(); : 
2
strstr : for : 	rcu_read_unlock(); : 
2
strstr : while : 	rcu_read_unlock(); : 
2
str : 	/*[3]
strstr : INIT : 	/* : 
2
strstr : if : 	/* : 
2
strstr : for : 	/* : 
2
strstr : while : 	/* : 
2
str : 	 * Only show locks if all tasks are dumped:[44]
strstr : INIT : 	 * Only show locks if all tasks are dumped: : 
2
strstr : if : 	 * Only show locks if all tasks are dumped: : 
2
strstr : for : 	 * Only show locks if all tasks are dumped: : 
2
strstr : while : 	 * Only show locks if all tasks are dumped: : 
2
str : 	 */[4]
strstr : INIT : 	 */ : 
2
strstr : if : 	 */ : 
2
strstr : for : 	 */ : 
2
strstr : while : 	 */ : 
2
str : 	if (!state_filter)[19]
strstr : INIT : 	if (!state_filter) : 
2
strstr : if : 	if (!state_filter) : 
2
strstr : for : 	if (!state_filter) : 
2
strstr : while : 	if (!state_filter) : 
2
str : 		debug_show_all_locks();[25]
strstr : INIT : 		debug_show_all_locks(); : 
2
strstr : if : 		debug_show_all_locks(); : 
2
strstr : for : 		debug_show_all_locks(); : 
2
strstr : while : 		debug_show_all_locks(); : 
2
str : void init_idle_bootup_task(struct task_struct *idle)[52]
strstr : INIT : void init_idle_bootup_task(struct task_struct *idle) : 
2
strstr : if : void init_idle_bootup_task(struct task_struct *idle) : 
2
strstr : for : void init_idle_bootup_task(struct task_struct *idle) : 
2
strstr : while : void init_idle_bootup_task(struct task_struct *idle) : 
2
str : 	idle->sched_class = &idle_sched_class;[39]
strstr : INIT : 	idle->sched_class = &idle_sched_class; : 
2
strstr : if : 	idle->sched_class = &idle_sched_class; : 
2
strstr : for : 	idle->sched_class = &idle_sched_class; : 
2
strstr : while : 	idle->sched_class = &idle_sched_class; : 
2
str : /**[3]
strstr : INIT : /** : 
2
strstr : if : /** : 
2
strstr : for : /** : 
2
strstr : while : /** : 
2
str :  * init_idle - set up an idle thread for a given CPU[52]
strstr : INIT :  * init_idle - set up an idle thread for a given CPU : 
2
strstr : if :  * init_idle - set up an idle thread for a given CPU : 
2
strstr : for :  * init_idle - set up an idle thread for a given CPU : 
2
strstr : while :  * init_idle - set up an idle thread for a given CPU : 
2
str :  * @idle: task in question[26]
strstr : INIT :  * @idle: task in question : 
2
strstr : if :  * @idle: task in question : 
2
strstr : for :  * @idle: task in question : 
2
strstr : while :  * @idle: task in question : 
2
str :  * @cpu: cpu the idle task belongs to[37]
strstr : INIT :  * @cpu: cpu the idle task belongs to : 
2
strstr : if :  * @cpu: cpu the idle task belongs to : 
2
strstr : for :  * @cpu: cpu the idle task belongs to : 
2
strstr : while :  * @cpu: cpu the idle task belongs to : 
2
str :  * NOTE: this function does not set the idle thread's NEED_RESCHED[66]
strstr : INIT :  * NOTE: this function does not set the idle thread's NEED_RESCHED : 
2
strstr : if :  * NOTE: this function does not set the idle thread's NEED_RESCHED : 
2
strstr : for :  * NOTE: this function does not set the idle thread's NEED_RESCHED : 
2
strstr : while :  * NOTE: this function does not set the idle thread's NEED_RESCHED : 
2
str :  * flag, to make booting more robust.[37]
strstr : INIT :  * flag, to make booting more robust. : 
2
strstr : if :  * flag, to make booting more robust. : 
2
strstr : for :  * flag, to make booting more robust. : 
2
strstr : while :  * flag, to make booting more robust. : 
2
str :  */[3]
strstr : INIT :  */ : 
2
strstr : if :  */ : 
2
strstr : for :  */ : 
2
strstr : while :  */ : 
2
str : void init_idle(struct task_struct *idle, int cpu)[49]
strstr : INIT : void init_idle(struct task_struct *idle, int cpu) : 
2
strstr : if : void init_idle(struct task_struct *idle, int cpu) : 
2
strstr : for : void init_idle(struct task_struct *idle, int cpu) : 
2
strstr : while : void init_idle(struct task_struct *idle, int cpu) : 
2
str : 	struct rq *rq = cpu_rq(cpu);[29]
strstr : INIT : 	struct rq *rq = cpu_rq(cpu); : 
2
strstr : if : 	struct rq *rq = cpu_rq(cpu); : 
2
strstr : for : 	struct rq *rq = cpu_rq(cpu); : 
2
strstr : while : 	struct rq *rq = cpu_rq(cpu); : 
2
str : 	unsigned long flags;[21]
strstr : INIT : 	unsigned long flags; : 
2
strstr : if : 	unsigned long flags; : 
2
strstr : for : 	unsigned long flags; : 
2
strstr : while : 	unsigned long flags; : 
2
str : 	raw_spin_lock_irqsave(&rq->lock, flags);[41]
strstr : INIT : 	raw_spin_lock_irqsave(&rq->lock, flags); : 
2
strstr : if : 	raw_spin_lock_irqsave(&rq->lock, flags); : 
2
strstr : for : 	raw_spin_lock_irqsave(&rq->lock, flags); : 
2
strstr : while : 	raw_spin_lock_irqsave(&rq->lock, flags); : 
2
str : 	__sched_fork(0, idle);[23]
strstr : INIT : 	__sched_fork(0, idle); : 
2
strstr : if : 	__sched_fork(0, idle); : 
2
strstr : for : 	__sched_fork(0, idle); : 
2
strstr : while : 	__sched_fork(0, idle); : 
2
str : 	idle->state = TASK_RUNNING;[28]
strstr : INIT : 	idle->state = TASK_RUNNING; : 
2
strstr : if : 	idle->state = TASK_RUNNING; : 
2
strstr : for : 	idle->state = TASK_RUNNING; : 
2
strstr : while : 	idle->state = TASK_RUNNING; : 
2
str : 	idle->se.exec_start = sched_clock();[37]
strstr : INIT : 	idle->se.exec_start = sched_clock(); : 
2
strstr : if : 	idle->se.exec_start = sched_clock(); : 
2
strstr : for : 	idle->se.exec_start = sched_clock(); : 
2
strstr : while : 	idle->se.exec_start = sched_clock(); : 
2
str : 	do_set_cpus_allowed(idle, cpumask_of(cpu));[44]
strstr : INIT : 	do_set_cpus_allowed(idle, cpumask_of(cpu)); : 
2
strstr : if : 	do_set_cpus_allowed(idle, cpumask_of(cpu)); : 
2
strstr : for : 	do_set_cpus_allowed(idle, cpumask_of(cpu)); : 
2
strstr : while : 	do_set_cpus_allowed(idle, cpumask_of(cpu)); : 
2
str : 	/*[3]
strstr : INIT : 	/* : 
2
strstr : if : 	/* : 
2
strstr : for : 	/* : 
2
strstr : while : 	/* : 
2
str : 	 * We're having a chicken and egg problem, even though we are[62]
strstr : INIT : 	 * We're having a chicken and egg problem, even though we are : 
2
strstr : if : 	 * We're having a chicken and egg problem, even though we are : 
2
strstr : for : 	 * We're having a chicken and egg problem, even though we are : 
2
strstr : while : 	 * We're having a chicken and egg problem, even though we are : 
2
str : 	 * holding rq->lock, the cpu isn't yet set to this cpu so the[62]
strstr : INIT : 	 * holding rq->lock, the cpu isn't yet set to this cpu so the : 
2
strstr : if : 	 * holding rq->lock, the cpu isn't yet set to this cpu so the : 
2
strstr : for : 	 * holding rq->lock, the cpu isn't yet set to this cpu so the : 
2
strstr : while : 	 * holding rq->lock, the cpu isn't yet set to this cpu so the : 
2
str : 	 * lockdep check in task_group() will fail.[44]
strstr : INIT : 	 * lockdep check in task_group() will fail. : 
2
strstr : if : 	 * lockdep check in task_group() will fail. : 
2
strstr : for : 	 * lockdep check in task_group() will fail. : 
2
strstr : while : 	 * lockdep check in task_group() will fail. : 
2
str : 	 *[3]
strstr : INIT : 	 * : 
2
strstr : if : 	 * : 
2
strstr : for : 	 * : 
2
strstr : while : 	 * : 
2
str : 	 * Similar case to sched_fork(). / Alternatively we could[58]
strstr : INIT : 	 * Similar case to sched_fork(). / Alternatively we could : 
2
strstr : if : 	 * Similar case to sched_fork(). / Alternatively we could : 
2
strstr : for : 	 * Similar case to sched_fork(). / Alternatively we could : 
2
strstr : while : 	 * Similar case to sched_fork(). / Alternatively we could : 
2
str : 	 * use task_rq_lock() here and obtain the other rq->lock.[58]
strstr : INIT : 	 * use task_rq_lock() here and obtain the other rq->lock. : 
2
strstr : if : 	 * use task_rq_lock() here and obtain the other rq->lock. : 
2
strstr : for : 	 * use task_rq_lock() here and obtain the other rq->lock. : 
2
strstr : while : 	 * use task_rq_lock() here and obtain the other rq->lock. : 
2
str : 	 *[3]
strstr : INIT : 	 * : 
2
strstr : if : 	 * : 
2
strstr : for : 	 * : 
2
strstr : while : 	 * : 
2
str : 	 * Silence PROVE_RCU[21]
strstr : INIT : 	 * Silence PROVE_RCU : 
2
strstr : if : 	 * Silence PROVE_RCU : 
2
strstr : for : 	 * Silence PROVE_RCU : 
2
strstr : while : 	 * Silence PROVE_RCU : 
2
str : 	 */[4]
strstr : INIT : 	 */ : 
2
strstr : if : 	 */ : 
2
strstr : for : 	 */ : 
2
strstr : while : 	 */ : 
2
str : 	rcu_read_lock();[17]
strstr : INIT : 	rcu_read_lock(); : 
2
strstr : if : 	rcu_read_lock(); : 
2
strstr : for : 	rcu_read_lock(); : 
2
strstr : while : 	rcu_read_lock(); : 
2
str : 	__set_task_cpu(idle, cpu);[27]
strstr : INIT : 	__set_task_cpu(idle, cpu); : 
2
strstr : if : 	__set_task_cpu(idle, cpu); : 
2
strstr : for : 	__set_task_cpu(idle, cpu); : 
2
strstr : while : 	__set_task_cpu(idle, cpu); : 
2
str : 	rcu_read_unlock();[19]
strstr : INIT : 	rcu_read_unlock(); : 
2
strstr : if : 	rcu_read_unlock(); : 
2
strstr : for : 	rcu_read_unlock(); : 
2
strstr : while : 	rcu_read_unlock(); : 
2
str : 	rq->curr = rq->idle = idle;[28]
strstr : INIT : 	rq->curr = rq->idle = idle; : 
2
strstr : if : 	rq->curr = rq->idle = idle; : 
2
strstr : for : 	rq->curr = rq->idle = idle; : 
2
strstr : while : 	rq->curr = rq->idle = idle; : 
2
str : #if defined(CONFIG_SMP)[23]
strstr : INIT : #if defined(CONFIG_SMP) : 
2
strstr : if : #if defined(CONFIG_SMP) : 
2
strstr : for : #if defined(CONFIG_SMP) : 
2
strstr : while : #if defined(CONFIG_SMP) : 
2
str : 	idle->on_cpu = 1;[18]
strstr : INIT : 	idle->on_cpu = 1; : 
2
strstr : if : 	idle->on_cpu = 1; : 
2
strstr : for : 	idle->on_cpu = 1; : 
2
strstr : while : 	idle->on_cpu = 1; : 
2
str : #endif[6]
strstr : INIT : #endif : 
2
strstr : if : #endif : 
2
strstr : for : #endif : 
2
strstr : while : #endif : 
2
str : 	raw_spin_unlock_irqrestore(&rq->lock, flags);[46]
strstr : INIT : 	raw_spin_unlock_irqrestore(&rq->lock, flags); : 
2
strstr : if : 	raw_spin_unlock_irqrestore(&rq->lock, flags); : 
2
strstr : for : 	raw_spin_unlock_irqrestore(&rq->lock, flags); : 
2
strstr : while : 	raw_spin_unlock_irqrestore(&rq->lock, flags); : 
2
str : 	/* Set the preempt count _outside_ the spinlocks! */[53]
strstr : INIT : 	/* Set the preempt count _outside_ the spinlocks! */ : 
2
strstr : if : 	/* Set the preempt count _outside_ the spinlocks! */ : 
2
strstr : for : 	/* Set the preempt count _outside_ the spinlocks! */ : 
2
strstr : while : 	/* Set the preempt count _outside_ the spinlocks! */ : 
2
str : 	init_idle_preempt_count(idle, cpu);[36]
strstr : INIT : 	init_idle_preempt_count(idle, cpu); : 
2
strstr : if : 	init_idle_preempt_count(idle, cpu); : 
2
strstr : for : 	init_idle_preempt_count(idle, cpu); : 
2
strstr : while : 	init_idle_preempt_count(idle, cpu); : 
2
str : 	/*[3]
strstr : INIT : 	/* : 
2
strstr : if : 	/* : 
2
strstr : for : 	/* : 
2
strstr : while : 	/* : 
2
str : 	 * The idle tasks have their own, simple scheduling class:[59]
strstr : INIT : 	 * The idle tasks have their own, simple scheduling class: : 
2
strstr : if : 	 * The idle tasks have their own, simple scheduling class: : 
2
strstr : for : 	 * The idle tasks have their own, simple scheduling class: : 
2
strstr : while : 	 * The idle tasks have their own, simple scheduling class: : 
2
str : 	 */[4]
strstr : INIT : 	 */ : 
2
strstr : if : 	 */ : 
2
strstr : for : 	 */ : 
2
strstr : while : 	 */ : 
2
str : 	idle->sched_class = &idle_sched_class;[39]
strstr : INIT : 	idle->sched_class = &idle_sched_class; : 
2
strstr : if : 	idle->sched_class = &idle_sched_class; : 
2
strstr : for : 	idle->sched_class = &idle_sched_class; : 
2
strstr : while : 	idle->sched_class = &idle_sched_class; : 
2
str : 	ftrace_graph_init_idle_task(idle, cpu);[40]
strstr : INIT : 	ftrace_graph_init_idle_task(idle, cpu); : 
2
strstr : if : 	ftrace_graph_init_idle_task(idle, cpu); : 
2
strstr : for : 	ftrace_graph_init_idle_task(idle, cpu); : 
2
strstr : while : 	ftrace_graph_init_idle_task(idle, cpu); : 
2
str : 	vtime_init_idle(idle, cpu);[28]
strstr : INIT : 	vtime_init_idle(idle, cpu); : 
2
strstr : if : 	vtime_init_idle(idle, cpu); : 
2
strstr : for : 	vtime_init_idle(idle, cpu); : 
2
strstr : while : 	vtime_init_idle(idle, cpu); : 
2
str : #if defined(CONFIG_SMP)[23]
strstr : INIT : #if defined(CONFIG_SMP) : 
2
strstr : if : #if defined(CONFIG_SMP) : 
2
strstr : for : #if defined(CONFIG_SMP) : 
2
strstr : while : #if defined(CONFIG_SMP) : 
2
str : 	sprintf(idle->comm, "%s/%d", INIT_TASK_COMM, cpu);[51]
strstr : INIT : 	sprintf(idle->comm, "%s/%d", INIT_TASK_COMM, cpu); : 
2
strstr : if : 	sprintf(idle->comm, "%s/%d", INIT_TASK_COMM, cpu); : 
2
strstr : for : 	sprintf(idle->comm, "%s/%d", INIT_TASK_COMM, cpu); : 
2
strstr : while : 	sprintf(idle->comm, "%s/%d", INIT_TASK_COMM, cpu); : 
2
str : #endif[6]
strstr : INIT : #endif : 
2
strstr : if : #endif : 
2
strstr : for : #endif : 
2
strstr : while : #endif : 
2
str : #ifdef CONFIG_SMP[17]
strstr : INIT : #ifdef CONFIG_SMP : 
2
strstr : if : #ifdef CONFIG_SMP : 
2
strstr : for : #ifdef CONFIG_SMP : 
2
strstr : while : #ifdef CONFIG_SMP : 
2
str : void do_set_cpus_allowed(struct task_struct *p, const struct cpumask *new_mask)[79]
strstr : INIT : void do_set_cpus_allowed(struct task_struct *p, const struct cpumask *new_mask) : 
2
strstr : if : void do_set_cpus_allowed(struct task_struct *p, const struct cpumask *new_mask) : 
2
strstr : for : void do_set_cpus_allowed(struct task_struct *p, const struct cpumask *new_mask) : 
2
strstr : while : void do_set_cpus_allowed(struct task_struct *p, const struct cpumask *new_mask) : 
2
str : 	if (p->sched_class && p->sched_class->set_cpus_allowed)[56]
strstr : INIT : 	if (p->sched_class && p->sched_class->set_cpus_allowed) : 
2
strstr : if : 	if (p->sched_class && p->sched_class->set_cpus_allowed) : 
2
strstr : for : 	if (p->sched_class && p->sched_class->set_cpus_allowed) : 
2
strstr : while : 	if (p->sched_class && p->sched_class->set_cpus_allowed) : 
2
str : 		p->sched_class->set_cpus_allowed(p, new_mask);[48]
strstr : INIT : 		p->sched_class->set_cpus_allowed(p, new_mask); : 
2
strstr : if : 		p->sched_class->set_cpus_allowed(p, new_mask); : 
2
strstr : for : 		p->sched_class->set_cpus_allowed(p, new_mask); : 
2
strstr : while : 		p->sched_class->set_cpus_allowed(p, new_mask); : 
2
str : 	cpumask_copy(&p->cpus_allowed, new_mask);[42]
strstr : INIT : 	cpumask_copy(&p->cpus_allowed, new_mask); : 
2
strstr : if : 	cpumask_copy(&p->cpus_allowed, new_mask); : 
2
strstr : for : 	cpumask_copy(&p->cpus_allowed, new_mask); : 
2
strstr : while : 	cpumask_copy(&p->cpus_allowed, new_mask); : 
2
str : 	p->nr_cpus_allowed = cpumask_weight(new_mask);[47]
strstr : INIT : 	p->nr_cpus_allowed = cpumask_weight(new_mask); : 
2
strstr : if : 	p->nr_cpus_allowed = cpumask_weight(new_mask); : 
2
strstr : for : 	p->nr_cpus_allowed = cpumask_weight(new_mask); : 
2
strstr : while : 	p->nr_cpus_allowed = cpumask_weight(new_mask); : 
2
str :  * This is how migration works:[31]
strstr : INIT :  * This is how migration works: : 
2
strstr : if :  * This is how migration works: : 
2
strstr : for :  * This is how migration works: : 
2
strstr : while :  * This is how migration works: : 
2
str :  * 1) we invoke migration_cpu_stop() on the target CPU using[60]
strstr : INIT :  * 1) we invoke migration_cpu_stop() on the target CPU using : 
2
strstr : if :  * 1) we invoke migration_cpu_stop() on the target CPU using : 
2
strstr : for :  * 1) we invoke migration_cpu_stop() on the target CPU using : 
2
strstr : while :  * 1) we invoke migration_cpu_stop() on the target CPU using : 
2
str :  *    stop_one_cpu().[21]
strstr : INIT :  *    stop_one_cpu(). : 
2
strstr : if :  *    stop_one_cpu(). : 
2
strstr : for :  *    stop_one_cpu(). : 
2
strstr : while :  *    stop_one_cpu(). : 
2
str :  * 2) stopper starts to run (implicitly forcing the migrated thread[67]
strstr : INIT :  * 2) stopper starts to run (implicitly forcing the migrated thread : 
2
strstr : if :  * 2) stopper starts to run (implicitly forcing the migrated thread : 
2
strstr : for :  * 2) stopper starts to run (implicitly forcing the migrated thread : 
2
strstr : while :  * 2) stopper starts to run (implicitly forcing the migrated thread : 
2
str :  *    off the CPU)[18]
strstr : INIT :  *    off the CPU) : 
2
strstr : if :  *    off the CPU) : 
2
strstr : for :  *    off the CPU) : 
2
strstr : while :  *    off the CPU) : 
2
str :  * 3) it checks whether the migrated task is still in the wrong runqueue.[73]
strstr : INIT :  * 3) it checks whether the migrated task is still in the wrong runqueue. : 
2
strstr : if :  * 3) it checks whether the migrated task is still in the wrong runqueue. : 
2
strstr : for :  * 3) it checks whether the migrated task is still in the wrong runqueue. : 
2
strstr : while :  * 3) it checks whether the migrated task is still in the wrong runqueue. : 
2
str :  * 4) if it's in the wrong runqueue then the migration thread removes[69]
strstr : INIT :  * 4) if it's in the wrong runqueue then the migration thread removes : 
2
strstr : if :  * 4) if it's in the wrong runqueue then the migration thread removes : 
2
strstr : for :  * 4) if it's in the wrong runqueue then the migration thread removes : 
2
strstr : while :  * 4) if it's in the wrong runqueue then the migration thread removes : 
2
str :  *    it and puts it into the right queue.[42]
strstr : INIT :  *    it and puts it into the right queue. : 
2
strstr : if :  *    it and puts it into the right queue. : 
2
strstr : for :  *    it and puts it into the right queue. : 
2
strstr : while :  *    it and puts it into the right queue. : 
2
str :  * 5) stopper completes and stop_one_cpu() returns and the migration[68]
strstr : INIT :  * 5) stopper completes and stop_one_cpu() returns and the migration : 
2
strstr : if :  * 5) stopper completes and stop_one_cpu() returns and the migration : 
2
strstr : for :  * 5) stopper completes and stop_one_cpu() returns and the migration : 
2
strstr : while :  * 5) stopper completes and stop_one_cpu() returns and the migration : 
2
str :  *    is done.[14]
strstr : INIT :  *    is done. : 
2
strstr : if :  *    is done. : 
2
strstr : for :  *    is done. : 
2
strstr : while :  *    is done. : 
2
str :  */[3]
strstr : INIT :  */ : 
2
strstr : if :  */ : 
2
strstr : for :  */ : 
2
strstr : while :  */ : 
2
str :  * Change a given task's CPU affinity. Migrate the thread to a[62]
strstr : INIT :  * Change a given task's CPU affinity. Migrate the thread to a : 
2
strstr : if :  * Change a given task's CPU affinity. Migrate the thread to a : 
2
strstr : for :  * Change a given task's CPU affinity. Migrate the thread to a : 
2
strstr : while :  * Change a given task's CPU affinity. Migrate the thread to a : 
2
str :  * proper CPU and schedule it away if the CPU it's executing on[63]
strstr : INIT :  * proper CPU and schedule it away if the CPU it's executing on : 
2
strstr : if :  * proper CPU and schedule it away if the CPU it's executing on : 
2
strstr : for :  * proper CPU and schedule it away if the CPU it's executing on : 
2
strstr : while :  * proper CPU and schedule it away if the CPU it's executing on : 
2
str :  * is removed from the allowed bitmask.[39]
strstr : INIT :  * is removed from the allowed bitmask. : 
2
strstr : if :  * is removed from the allowed bitmask. : 
2
strstr : for :  * is removed from the allowed bitmask. : 
2
strstr : while :  * is removed from the allowed bitmask. : 
2
str :  * NOTE: the caller must have a valid reference to the task, the[64]
strstr : INIT :  * NOTE: the caller must have a valid reference to the task, the : 
2
strstr : if :  * NOTE: the caller must have a valid reference to the task, the : 
2
strstr : for :  * NOTE: the caller must have a valid reference to the task, the : 
2
strstr : while :  * NOTE: the caller must have a valid reference to the task, the : 
2
str :  * task must not exit() & deallocate itself prematurely. The[60]
strstr : INIT :  * task must not exit() & deallocate itself prematurely. The : 
2
strstr : if :  * task must not exit() & deallocate itself prematurely. The : 
2
strstr : for :  * task must not exit() & deallocate itself prematurely. The : 
2
strstr : while :  * task must not exit() & deallocate itself prematurely. The : 
2
str :  * call is not atomic; no spinlocks may be held.[48]
strstr : INIT :  * call is not atomic; no spinlocks may be held. : 
2
strstr : if :  * call is not atomic; no spinlocks may be held. : 
2
strstr : for :  * call is not atomic; no spinlocks may be held. : 
2
strstr : while :  * call is not atomic; no spinlocks may be held. : 
2
str :  */[3]
strstr : INIT :  */ : 
2
strstr : if :  */ : 
2
strstr : for :  */ : 
2
strstr : while :  */ : 
2
str : int set_cpus_allowed_ptr(struct task_struct *p, const struct cpumask *new_mask)[79]
strstr : INIT : int set_cpus_allowed_ptr(struct task_struct *p, const struct cpumask *new_mask) : 
2
strstr : if : int set_cpus_allowed_ptr(struct task_struct *p, const struct cpumask *new_mask) : 
2
strstr : for : int set_cpus_allowed_ptr(struct task_struct *p, const struct cpumask *new_mask) : 
2
strstr : while : int set_cpus_allowed_ptr(struct task_struct *p, const struct cpumask *new_mask) : 
2
str : 	unsigned long flags;[21]
strstr : INIT : 	unsigned long flags; : 
2
strstr : if : 	unsigned long flags; : 
2
strstr : for : 	unsigned long flags; : 
2
strstr : while : 	unsigned long flags; : 
2
str : 	struct rq *rq;[15]
strstr : INIT : 	struct rq *rq; : 
2
strstr : if : 	struct rq *rq; : 
2
strstr : for : 	struct rq *rq; : 
2
strstr : while : 	struct rq *rq; : 
2
str : 	unsigned int dest_cpu;[23]
strstr : INIT : 	unsigned int dest_cpu; : 
2
strstr : if : 	unsigned int dest_cpu; : 
2
strstr : for : 	unsigned int dest_cpu; : 
2
strstr : while : 	unsigned int dest_cpu; : 
2
str : 	int ret = 0;[13]
strstr : INIT : 	int ret = 0; : 
2
strstr : if : 	int ret = 0; : 
2
strstr : for : 	int ret = 0; : 
2
strstr : while : 	int ret = 0; : 
2
str : 	rq = task_rq_lock(p, &flags);[30]
strstr : INIT : 	rq = task_rq_lock(p, &flags); : 
2
strstr : if : 	rq = task_rq_lock(p, &flags); : 
2
strstr : for : 	rq = task_rq_lock(p, &flags); : 
2
strstr : while : 	rq = task_rq_lock(p, &flags); : 
2
str : 	if (cpumask_equal(&p->cpus_allowed, new_mask))[47]
strstr : INIT : 	if (cpumask_equal(&p->cpus_allowed, new_mask)) : 
2
strstr : if : 	if (cpumask_equal(&p->cpus_allowed, new_mask)) : 
2
strstr : for : 	if (cpumask_equal(&p->cpus_allowed, new_mask)) : 
2
strstr : while : 	if (cpumask_equal(&p->cpus_allowed, new_mask)) : 
2
str : 		goto out;[11]
strstr : INIT : 		goto out; : 
2
strstr : if : 		goto out; : 
2
strstr : for : 		goto out; : 
2
strstr : while : 		goto out; : 
2
str : 	if (!cpumask_intersects(new_mask, cpu_active_mask)) {[54]
strstr : INIT : 	if (!cpumask_intersects(new_mask, cpu_active_mask)) { : 
2
strstr : if : 	if (!cpumask_intersects(new_mask, cpu_active_mask)) { : 
2
strstr : for : 	if (!cpumask_intersects(new_mask, cpu_active_mask)) { : 
2
strstr : while : 	if (!cpumask_intersects(new_mask, cpu_active_mask)) { : 
2
str : 		ret = -EINVAL;[16]
strstr : INIT : 		ret = -EINVAL; : 
2
strstr : if : 		ret = -EINVAL; : 
2
strstr : for : 		ret = -EINVAL; : 
2
strstr : while : 		ret = -EINVAL; : 
2
str : 		goto out;[11]
strstr : INIT : 		goto out; : 
2
strstr : if : 		goto out; : 
2
strstr : for : 		goto out; : 
2
strstr : while : 		goto out; : 
2
str : 	do_set_cpus_allowed(p, new_mask);[34]
strstr : INIT : 	do_set_cpus_allowed(p, new_mask); : 
2
strstr : if : 	do_set_cpus_allowed(p, new_mask); : 
2
strstr : for : 	do_set_cpus_allowed(p, new_mask); : 
2
strstr : while : 	do_set_cpus_allowed(p, new_mask); : 
2
str : 	/* Can the task run on the task's current CPU? If so, we're done */[68]
strstr : INIT : 	/* Can the task run on the task's current CPU? If so, we're done */ : 
2
strstr : if : 	/* Can the task run on the task's current CPU? If so, we're done */ : 
2
strstr : for : 	/* Can the task run on the task's current CPU? If so, we're done */ : 
2
strstr : while : 	/* Can the task run on the task's current CPU? If so, we're done */ : 
2
str : 	if (cpumask_test_cpu(task_cpu(p), new_mask))[45]
strstr : INIT : 	if (cpumask_test_cpu(task_cpu(p), new_mask)) : 
2
strstr : if : 	if (cpumask_test_cpu(task_cpu(p), new_mask)) : 
2
strstr : for : 	if (cpumask_test_cpu(task_cpu(p), new_mask)) : 
2
strstr : while : 	if (cpumask_test_cpu(task_cpu(p), new_mask)) : 
2
str : 		goto out;[11]
strstr : INIT : 		goto out; : 
2
strstr : if : 		goto out; : 
2
strstr : for : 		goto out; : 
2
strstr : while : 		goto out; : 
2
str : 	dest_cpu = cpumask_any_and(cpu_active_mask, new_mask);[55]
strstr : INIT : 	dest_cpu = cpumask_any_and(cpu_active_mask, new_mask); : 
2
strstr : if : 	dest_cpu = cpumask_any_and(cpu_active_mask, new_mask); : 
2
strstr : for : 	dest_cpu = cpumask_any_and(cpu_active_mask, new_mask); : 
2
strstr : while : 	dest_cpu = cpumask_any_and(cpu_active_mask, new_mask); : 
2
str : 	if (p->on_rq) {[16]
strstr : INIT : 	if (p->on_rq) { : 
2
strstr : if : 	if (p->on_rq) { : 
2
strstr : for : 	if (p->on_rq) { : 
2
strstr : while : 	if (p->on_rq) { : 
2
str : 		struct migration_arg arg = { p, dest_cpu };[45]
strstr : INIT : 		struct migration_arg arg = { p, dest_cpu }; : 
2
strstr : if : 		struct migration_arg arg = { p, dest_cpu }; : 
2
strstr : for : 		struct migration_arg arg = { p, dest_cpu }; : 
2
strstr : while : 		struct migration_arg arg = { p, dest_cpu }; : 
2
str : 		/* Need help from migration thread: drop lock and wait. */[60]
strstr : INIT : 		/* Need help from migration thread: drop lock and wait. */ : 
2
strstr : if : 		/* Need help from migration thread: drop lock and wait. */ : 
2
strstr : for : 		/* Need help from migration thread: drop lock and wait. */ : 
2
strstr : while : 		/* Need help from migration thread: drop lock and wait. */ : 
2
str : 		task_rq_unlock(rq, p, &flags);[32]
strstr : INIT : 		task_rq_unlock(rq, p, &flags); : 
2
strstr : if : 		task_rq_unlock(rq, p, &flags); : 
2
strstr : for : 		task_rq_unlock(rq, p, &flags); : 
2
strstr : while : 		task_rq_unlock(rq, p, &flags); : 
2
str : 		stop_one_cpu(cpu_of(rq), migration_cpu_stop, &arg);[53]
strstr : INIT : 		stop_one_cpu(cpu_of(rq), migration_cpu_stop, &arg); : 
2
strstr : if : 		stop_one_cpu(cpu_of(rq), migration_cpu_stop, &arg); : 
2
strstr : for : 		stop_one_cpu(cpu_of(rq), migration_cpu_stop, &arg); : 
2
strstr : while : 		stop_one_cpu(cpu_of(rq), migration_cpu_stop, &arg); : 
2
str : 		tlb_migrate_finish(p->mm);[28]
strstr : INIT : 		tlb_migrate_finish(p->mm); : 
2
strstr : if : 		tlb_migrate_finish(p->mm); : 
2
strstr : for : 		tlb_migrate_finish(p->mm); : 
2
strstr : while : 		tlb_migrate_finish(p->mm); : 
2
str : 		return 0;[11]
strstr : INIT : 		return 0; : 
2
strstr : if : 		return 0; : 
2
strstr : for : 		return 0; : 
2
strstr : while : 		return 0; : 
2
str : out:[4]
strstr : INIT : out: : 
2
strstr : if : out: : 
2
strstr : for : out: : 
2
strstr : while : out: : 
2
str : 	task_rq_unlock(rq, p, &flags);[31]
strstr : INIT : 	task_rq_unlock(rq, p, &flags); : 
2
strstr : if : 	task_rq_unlock(rq, p, &flags); : 
2
strstr : for : 	task_rq_unlock(rq, p, &flags); : 
2
strstr : while : 	task_rq_unlock(rq, p, &flags); : 
2
str : 	return ret;[12]
strstr : INIT : 	return ret; : 
2
strstr : if : 	return ret; : 
2
strstr : for : 	return ret; : 
2
strstr : while : 	return ret; : 
2
str : EXPORT_SYMBOL_GPL(set_cpus_allowed_ptr);[40]
strstr : INIT : EXPORT_SYMBOL_GPL(set_cpus_allowed_ptr); : 
2
strstr : if : EXPORT_SYMBOL_GPL(set_cpus_allowed_ptr); : 
2
strstr : for : EXPORT_SYMBOL_GPL(set_cpus_allowed_ptr); : 
2
strstr : while : EXPORT_SYMBOL_GPL(set_cpus_allowed_ptr); : 
2
str :  * Move (not current) task off this cpu, onto dest cpu. We're doing[67]
strstr : INIT :  * Move (not current) task off this cpu, onto dest cpu. We're doing : 
2
strstr : if :  * Move (not current) task off this cpu, onto dest cpu. We're doing : 
2
strstr : for :  * Move (not current) task off this cpu, onto dest cpu. We're doing : 
2
strstr : while :  * Move (not current) task off this cpu, onto dest cpu. We're doing : 
2
str :  * this because either it can't run here any more (set_cpus_allowed()[69]
strstr : INIT :  * this because either it can't run here any more (set_cpus_allowed() : 
2
strstr : if :  * this because either it can't run here any more (set_cpus_allowed() : 
2
strstr : for :  * this because either it can't run here any more (set_cpus_allowed() : 
2
strstr : while :  * this because either it can't run here any more (set_cpus_allowed() : 
2
str :  * away from this CPU, or CPU going down), or because we're[59]
strstr : INIT :  * away from this CPU, or CPU going down), or because we're : 
2
strstr : if :  * away from this CPU, or CPU going down), or because we're : 
2
strstr : for :  * away from this CPU, or CPU going down), or because we're : 
2
strstr : while :  * away from this CPU, or CPU going down), or because we're : 
2
str :  * attempting to rebalance this task on exec (sched_exec).[58]
strstr : INIT :  * attempting to rebalance this task on exec (sched_exec). : 
2
strstr : if :  * attempting to rebalance this task on exec (sched_exec). : 
2
strstr : for :  * attempting to rebalance this task on exec (sched_exec). : 
2
strstr : while :  * attempting to rebalance this task on exec (sched_exec). : 
2
str :  * So we race with normal scheduler movements, but that's OK, as long[69]
strstr : INIT :  * So we race with normal scheduler movements, but that's OK, as long : 
2
strstr : if :  * So we race with normal scheduler movements, but that's OK, as long : 
2
strstr : for :  * So we race with normal scheduler movements, but that's OK, as long : 
2
strstr : while :  * So we race with normal scheduler movements, but that's OK, as long : 
2
str :  * as the task is no longer on this CPU.[40]
strstr : INIT :  * as the task is no longer on this CPU. : 
2
strstr : if :  * as the task is no longer on this CPU. : 
2
strstr : for :  * as the task is no longer on this CPU. : 
2
strstr : while :  * as the task is no longer on this CPU. : 
2
str :  * Returns non-zero if task was successfully migrated.[54]
strstr : INIT :  * Returns non-zero if task was successfully migrated. : 
2
strstr : if :  * Returns non-zero if task was successfully migrated. : 
2
strstr : for :  * Returns non-zero if task was successfully migrated. : 
2
strstr : while :  * Returns non-zero if task was successfully migrated. : 
2
str :  */[3]
strstr : INIT :  */ : 
2
strstr : if :  */ : 
2
strstr : for :  */ : 
2
strstr : while :  */ : 
2
str : static int __migrate_task(struct task_struct *p, int src_cpu, int dest_cpu)[75]
strstr : INIT : static int __migrate_task(struct task_struct *p, int src_cpu, int dest_cpu) : 
2
strstr : if : static int __migrate_task(struct task_struct *p, int src_cpu, int dest_cpu) : 
2
strstr : for : static int __migrate_task(struct task_struct *p, int src_cpu, int dest_cpu) : 
2
strstr : while : static int __migrate_task(struct task_struct *p, int src_cpu, int dest_cpu) : 
2
str : 	struct rq *rq_dest, *rq_src;[29]
strstr : INIT : 	struct rq *rq_dest, *rq_src; : 
2
strstr : if : 	struct rq *rq_dest, *rq_src; : 
2
strstr : for : 	struct rq *rq_dest, *rq_src; : 
2
strstr : while : 	struct rq *rq_dest, *rq_src; : 
2
str : 	int ret = 0;[13]
strstr : INIT : 	int ret = 0; : 
2
strstr : if : 	int ret = 0; : 
2
strstr : for : 	int ret = 0; : 
2
strstr : while : 	int ret = 0; : 
2
str : 	if (unlikely(!cpu_active(dest_cpu)))[37]
strstr : INIT : 	if (unlikely(!cpu_active(dest_cpu))) : 
2
strstr : if : 	if (unlikely(!cpu_active(dest_cpu))) : 
2
strstr : for : 	if (unlikely(!cpu_active(dest_cpu))) : 
2
strstr : while : 	if (unlikely(!cpu_active(dest_cpu))) : 
2
str : 		return ret;[13]
strstr : INIT : 		return ret; : 
2
strstr : if : 		return ret; : 
2
strstr : for : 		return ret; : 
2
strstr : while : 		return ret; : 
2
str : 	rq_src = cpu_rq(src_cpu);[26]
strstr : INIT : 	rq_src = cpu_rq(src_cpu); : 
2
strstr : if : 	rq_src = cpu_rq(src_cpu); : 
2
strstr : for : 	rq_src = cpu_rq(src_cpu); : 
2
strstr : while : 	rq_src = cpu_rq(src_cpu); : 
2
str : 	rq_dest = cpu_rq(dest_cpu);[28]
strstr : INIT : 	rq_dest = cpu_rq(dest_cpu); : 
2
strstr : if : 	rq_dest = cpu_rq(dest_cpu); : 
2
strstr : for : 	rq_dest = cpu_rq(dest_cpu); : 
2
strstr : while : 	rq_dest = cpu_rq(dest_cpu); : 
2
str : 	raw_spin_lock(&p->pi_lock);[28]
strstr : INIT : 	raw_spin_lock(&p->pi_lock); : 
2
strstr : if : 	raw_spin_lock(&p->pi_lock); : 
2
strstr : for : 	raw_spin_lock(&p->pi_lock); : 
2
strstr : while : 	raw_spin_lock(&p->pi_lock); : 
2
str : 	double_rq_lock(rq_src, rq_dest);[33]
strstr : INIT : 	double_rq_lock(rq_src, rq_dest); : 
2
strstr : if : 	double_rq_lock(rq_src, rq_dest); : 
2
strstr : for : 	double_rq_lock(rq_src, rq_dest); : 
2
strstr : while : 	double_rq_lock(rq_src, rq_dest); : 
2
str : 	/* Already moved. */[21]
strstr : INIT : 	/* Already moved. */ : 
2
strstr : if : 	/* Already moved. */ : 
2
strstr : for : 	/* Already moved. */ : 
2
strstr : while : 	/* Already moved. */ : 
2
str : 	if (task_cpu(p) != src_cpu)[28]
strstr : INIT : 	if (task_cpu(p) != src_cpu) : 
2
strstr : if : 	if (task_cpu(p) != src_cpu) : 
2
strstr : for : 	if (task_cpu(p) != src_cpu) : 
2
strstr : while : 	if (task_cpu(p) != src_cpu) : 
2
str : 		goto done;[12]
strstr : INIT : 		goto done; : 
2
strstr : if : 		goto done; : 
2
strstr : for : 		goto done; : 
2
strstr : while : 		goto done; : 
2
str : 	/* Affinity changed (again). */[32]
strstr : INIT : 	/* Affinity changed (again). */ : 
2
strstr : if : 	/* Affinity changed (again). */ : 
2
strstr : for : 	/* Affinity changed (again). */ : 
2
strstr : while : 	/* Affinity changed (again). */ : 
2
str : 	if (!cpumask_test_cpu(dest_cpu, tsk_cpus_allowed(p)))[54]
strstr : INIT : 	if (!cpumask_test_cpu(dest_cpu, tsk_cpus_allowed(p))) : 
2
strstr : if : 	if (!cpumask_test_cpu(dest_cpu, tsk_cpus_allowed(p))) : 
2
strstr : for : 	if (!cpumask_test_cpu(dest_cpu, tsk_cpus_allowed(p))) : 
2
strstr : while : 	if (!cpumask_test_cpu(dest_cpu, tsk_cpus_allowed(p))) : 
2
str : 		goto fail;[12]
strstr : INIT : 		goto fail; : 
2
strstr : if : 		goto fail; : 
2
strstr : for : 		goto fail; : 
2
strstr : while : 		goto fail; : 
2
str : 	/*[3]
strstr : INIT : 	/* : 
2
strstr : if : 	/* : 
2
strstr : for : 	/* : 
2
strstr : while : 	/* : 
2
str : 	 * If we're not on a rq, the next wake-up will ensure we're[60]
strstr : INIT : 	 * If we're not on a rq, the next wake-up will ensure we're : 
2
strstr : if : 	 * If we're not on a rq, the next wake-up will ensure we're : 
2
strstr : for : 	 * If we're not on a rq, the next wake-up will ensure we're : 
2
strstr : while : 	 * If we're not on a rq, the next wake-up will ensure we're : 
2
str : 	 * placed properly.[20]
strstr : INIT : 	 * placed properly. : 
2
strstr : if : 	 * placed properly. : 
2
strstr : for : 	 * placed properly. : 
2
strstr : while : 	 * placed properly. : 
2
str : 	 */[4]
strstr : INIT : 	 */ : 
2
strstr : if : 	 */ : 
2
strstr : for : 	 */ : 
2
strstr : while : 	 */ : 
2
str : 	if (p->on_rq) {[16]
strstr : INIT : 	if (p->on_rq) { : 
2
strstr : if : 	if (p->on_rq) { : 
2
strstr : for : 	if (p->on_rq) { : 
2
strstr : while : 	if (p->on_rq) { : 
2
str : 		dequeue_task(rq_src, p, 0);[29]
strstr : INIT : 		dequeue_task(rq_src, p, 0); : 
2
strstr : if : 		dequeue_task(rq_src, p, 0); : 
2
strstr : for : 		dequeue_task(rq_src, p, 0); : 
2
strstr : while : 		dequeue_task(rq_src, p, 0); : 
2
str : 		set_task_cpu(p, dest_cpu);[28]
strstr : INIT : 		set_task_cpu(p, dest_cpu); : 
2
strstr : if : 		set_task_cpu(p, dest_cpu); : 
2
strstr : for : 		set_task_cpu(p, dest_cpu); : 
2
strstr : while : 		set_task_cpu(p, dest_cpu); : 
2
str : 		enqueue_task(rq_dest, p, 0);[30]
strstr : INIT : 		enqueue_task(rq_dest, p, 0); : 
2
strstr : if : 		enqueue_task(rq_dest, p, 0); : 
2
strstr : for : 		enqueue_task(rq_dest, p, 0); : 
2
strstr : while : 		enqueue_task(rq_dest, p, 0); : 
2
str : 		check_preempt_curr(rq_dest, p, 0);[36]
strstr : INIT : 		check_preempt_curr(rq_dest, p, 0); : 
2
strstr : if : 		check_preempt_curr(rq_dest, p, 0); : 
2
strstr : for : 		check_preempt_curr(rq_dest, p, 0); : 
2
strstr : while : 		check_preempt_curr(rq_dest, p, 0); : 
2
str : done:[5]
strstr : INIT : done: : 
2
strstr : if : done: : 
2
strstr : for : done: : 
2
strstr : while : done: : 
2
str : 	ret = 1;[9]
strstr : INIT : 	ret = 1; : 
2
strstr : if : 	ret = 1; : 
2
strstr : for : 	ret = 1; : 
2
strstr : while : 	ret = 1; : 
2
str : fail:[5]
strstr : INIT : fail: : 
2
strstr : if : fail: : 
2
strstr : for : fail: : 
2
strstr : while : fail: : 
2
str : 	double_rq_unlock(rq_src, rq_dest);[35]
strstr : INIT : 	double_rq_unlock(rq_src, rq_dest); : 
2
strstr : if : 	double_rq_unlock(rq_src, rq_dest); : 
2
strstr : for : 	double_rq_unlock(rq_src, rq_dest); : 
2
strstr : while : 	double_rq_unlock(rq_src, rq_dest); : 
2
str : 	raw_spin_unlock(&p->pi_lock);[30]
strstr : INIT : 	raw_spin_unlock(&p->pi_lock); : 
2
strstr : if : 	raw_spin_unlock(&p->pi_lock); : 
2
strstr : for : 	raw_spin_unlock(&p->pi_lock); : 
2
strstr : while : 	raw_spin_unlock(&p->pi_lock); : 
2
str : 	return ret;[12]
strstr : INIT : 	return ret; : 
2
strstr : if : 	return ret; : 
2
strstr : for : 	return ret; : 
2
strstr : while : 	return ret; : 
2
str : #ifdef CONFIG_NUMA_BALANCING[28]
strstr : INIT : #ifdef CONFIG_NUMA_BALANCING : 
2
strstr : if : #ifdef CONFIG_NUMA_BALANCING : 
2
strstr : for : #ifdef CONFIG_NUMA_BALANCING : 
2
strstr : while : #ifdef CONFIG_NUMA_BALANCING : 
2
str : /* Migrate current task p to target_cpu */[42]
strstr : INIT : /* Migrate current task p to target_cpu */ : 
2
strstr : if : /* Migrate current task p to target_cpu */ : 
2
strstr : for : /* Migrate current task p to target_cpu */ : 
2
strstr : while : /* Migrate current task p to target_cpu */ : 
2
str : int migrate_task_to(struct task_struct *p, int target_cpu)[58]
strstr : INIT : int migrate_task_to(struct task_struct *p, int target_cpu) : 
2
strstr : if : int migrate_task_to(struct task_struct *p, int target_cpu) : 
2
strstr : for : int migrate_task_to(struct task_struct *p, int target_cpu) : 
2
strstr : while : int migrate_task_to(struct task_struct *p, int target_cpu) : 
2
str : 	struct migration_arg arg = { p, target_cpu };[46]
strstr : INIT : 	struct migration_arg arg = { p, target_cpu }; : 
2
strstr : if : 	struct migration_arg arg = { p, target_cpu }; : 
2
strstr : for : 	struct migration_arg arg = { p, target_cpu }; : 
2
strstr : while : 	struct migration_arg arg = { p, target_cpu }; : 
2
str : 	int curr_cpu = task_cpu(p);[28]
strstr : INIT : 	int curr_cpu = task_cpu(p); : 
2
strstr : if : 	int curr_cpu = task_cpu(p); : 
2
strstr : for : 	int curr_cpu = task_cpu(p); : 
2
strstr : while : 	int curr_cpu = task_cpu(p); : 
2
str : 	if (curr_cpu == target_cpu)[28]
strstr : INIT : 	if (curr_cpu == target_cpu) : 
2
strstr : if : 	if (curr_cpu == target_cpu) : 
2
strstr : for : 	if (curr_cpu == target_cpu) : 
2
strstr : while : 	if (curr_cpu == target_cpu) : 
2
str : 		return 0;[11]
strstr : INIT : 		return 0; : 
2
strstr : if : 		return 0; : 
2
strstr : for : 		return 0; : 
2
strstr : while : 		return 0; : 
2
str : 	if (!cpumask_test_cpu(target_cpu, tsk_cpus_allowed(p)))[56]
strstr : INIT : 	if (!cpumask_test_cpu(target_cpu, tsk_cpus_allowed(p))) : 
2
strstr : if : 	if (!cpumask_test_cpu(target_cpu, tsk_cpus_allowed(p))) : 
2
strstr : for : 	if (!cpumask_test_cpu(target_cpu, tsk_cpus_allowed(p))) : 
2
strstr : while : 	if (!cpumask_test_cpu(target_cpu, tsk_cpus_allowed(p))) : 
2
str : 		return -EINVAL;[17]
strstr : INIT : 		return -EINVAL; : 
2
strstr : if : 		return -EINVAL; : 
2
strstr : for : 		return -EINVAL; : 
2
strstr : while : 		return -EINVAL; : 
2
str : 	/* TODO: This is not properly updating schedstats */[53]
strstr : INIT : 	/* TODO: This is not properly updating schedstats */ : 
2
strstr : if : 	/* TODO: This is not properly updating schedstats */ : 
2
strstr : for : 	/* TODO: This is not properly updating schedstats */ : 
2
strstr : while : 	/* TODO: This is not properly updating schedstats */ : 
2
str : 	trace_sched_move_numa(p, curr_cpu, target_cpu);[48]
strstr : INIT : 	trace_sched_move_numa(p, curr_cpu, target_cpu); : 
2
strstr : if : 	trace_sched_move_numa(p, curr_cpu, target_cpu); : 
2
strstr : for : 	trace_sched_move_numa(p, curr_cpu, target_cpu); : 
2
strstr : while : 	trace_sched_move_numa(p, curr_cpu, target_cpu); : 
2
str : 	return stop_one_cpu(curr_cpu, migration_cpu_stop, &arg);[57]
strstr : INIT : 	return stop_one_cpu(curr_cpu, migration_cpu_stop, &arg); : 
2
strstr : if : 	return stop_one_cpu(curr_cpu, migration_cpu_stop, &arg); : 
2
strstr : for : 	return stop_one_cpu(curr_cpu, migration_cpu_stop, &arg); : 
2
strstr : while : 	return stop_one_cpu(curr_cpu, migration_cpu_stop, &arg); : 
2
str :  * Requeue a task on a given node and accurately track the number of NUMA[73]
strstr : INIT :  * Requeue a task on a given node and accurately track the number of NUMA : 
2
strstr : if :  * Requeue a task on a given node and accurately track the number of NUMA : 
2
strstr : for :  * Requeue a task on a given node and accurately track the number of NUMA : 
2
strstr : while :  * Requeue a task on a given node and accurately track the number of NUMA : 
2
str :  * tasks on the runqueues[25]
strstr : INIT :  * tasks on the runqueues : 
2
strstr : if :  * tasks on the runqueues : 
2
strstr : for :  * tasks on the runqueues : 
2
strstr : while :  * tasks on the runqueues : 
2
str :  */[3]
strstr : INIT :  */ : 
2
strstr : if :  */ : 
2
strstr : for :  */ : 
2
strstr : while :  */ : 
2
str : void sched_setnuma(struct task_struct *p, int nid)[50]
strstr : INIT : void sched_setnuma(struct task_struct *p, int nid) : 
2
strstr : if : void sched_setnuma(struct task_struct *p, int nid) : 
2
strstr : for : void sched_setnuma(struct task_struct *p, int nid) : 
2
strstr : while : void sched_setnuma(struct task_struct *p, int nid) : 
2
str : 	struct rq *rq;[15]
strstr : INIT : 	struct rq *rq; : 
2
strstr : if : 	struct rq *rq; : 
2
strstr : for : 	struct rq *rq; : 
2
strstr : while : 	struct rq *rq; : 
2
str : 	unsigned long flags;[21]
strstr : INIT : 	unsigned long flags; : 
2
strstr : if : 	unsigned long flags; : 
2
strstr : for : 	unsigned long flags; : 
2
strstr : while : 	unsigned long flags; : 
2
str : 	bool on_rq, running;[21]
strstr : INIT : 	bool on_rq, running; : 
2
strstr : if : 	bool on_rq, running; : 
2
strstr : for : 	bool on_rq, running; : 
2
strstr : while : 	bool on_rq, running; : 
2
str : 	rq = task_rq_lock(p, &flags);[30]
strstr : INIT : 	rq = task_rq_lock(p, &flags); : 
2
strstr : if : 	rq = task_rq_lock(p, &flags); : 
2
strstr : for : 	rq = task_rq_lock(p, &flags); : 
2
strstr : while : 	rq = task_rq_lock(p, &flags); : 
2
str : 	on_rq = p->on_rq;[18]
strstr : INIT : 	on_rq = p->on_rq; : 
2
strstr : if : 	on_rq = p->on_rq; : 
2
strstr : for : 	on_rq = p->on_rq; : 
2
strstr : while : 	on_rq = p->on_rq; : 
2
str : 	running = task_current(rq, p);[31]
strstr : INIT : 	running = task_current(rq, p); : 
2
strstr : if : 	running = task_current(rq, p); : 
2
strstr : for : 	running = task_current(rq, p); : 
2
strstr : while : 	running = task_current(rq, p); : 
2
str : 	if (on_rq)[11]
strstr : INIT : 	if (on_rq) : 
2
strstr : if : 	if (on_rq) : 
2
strstr : for : 	if (on_rq) : 
2
strstr : while : 	if (on_rq) : 
2
str : 		dequeue_task(rq, p, 0);[25]
strstr : INIT : 		dequeue_task(rq, p, 0); : 
2
strstr : if : 		dequeue_task(rq, p, 0); : 
2
strstr : for : 		dequeue_task(rq, p, 0); : 
2
strstr : while : 		dequeue_task(rq, p, 0); : 
2
str : 	if (running)[13]
strstr : INIT : 	if (running) : 
2
strstr : if : 	if (running) : 
2
strstr : for : 	if (running) : 
2
strstr : while : 	if (running) : 
2
str : 		p->sched_class->put_prev_task(rq, p);[39]
strstr : INIT : 		p->sched_class->put_prev_task(rq, p); : 
2
strstr : if : 		p->sched_class->put_prev_task(rq, p); : 
2
strstr : for : 		p->sched_class->put_prev_task(rq, p); : 
2
strstr : while : 		p->sched_class->put_prev_task(rq, p); : 
2
str : 	p->numa_preferred_nid = nid;[29]
strstr : INIT : 	p->numa_preferred_nid = nid; : 
2
strstr : if : 	p->numa_preferred_nid = nid; : 
2
strstr : for : 	p->numa_preferred_nid = nid; : 
2
strstr : while : 	p->numa_preferred_nid = nid; : 
2
str : 	if (running)[13]
strstr : INIT : 	if (running) : 
2
strstr : if : 	if (running) : 
2
strstr : for : 	if (running) : 
2
strstr : while : 	if (running) : 
2
str : 		p->sched_class->set_curr_task(rq);[36]
strstr : INIT : 		p->sched_class->set_curr_task(rq); : 
2
strstr : if : 		p->sched_class->set_curr_task(rq); : 
2
strstr : for : 		p->sched_class->set_curr_task(rq); : 
2
strstr : while : 		p->sched_class->set_curr_task(rq); : 
2
str : 	if (on_rq)[11]
strstr : INIT : 	if (on_rq) : 
2
strstr : if : 	if (on_rq) : 
2
strstr : for : 	if (on_rq) : 
2
strstr : while : 	if (on_rq) : 
2
str : 		enqueue_task(rq, p, 0);[25]
strstr : INIT : 		enqueue_task(rq, p, 0); : 
2
strstr : if : 		enqueue_task(rq, p, 0); : 
2
strstr : for : 		enqueue_task(rq, p, 0); : 
2
strstr : while : 		enqueue_task(rq, p, 0); : 
2
str : 	task_rq_unlock(rq, p, &flags);[31]
strstr : INIT : 	task_rq_unlock(rq, p, &flags); : 
2
strstr : if : 	task_rq_unlock(rq, p, &flags); : 
2
strstr : for : 	task_rq_unlock(rq, p, &flags); : 
2
strstr : while : 	task_rq_unlock(rq, p, &flags); : 
2
str : #endif[6]
strstr : INIT : #endif : 
2
strstr : if : #endif : 
2
strstr : for : #endif : 
2
strstr : while : #endif : 
2
str :  * migration_cpu_stop - this will be executed by a highprio stopper thread[74]
strstr : INIT :  * migration_cpu_stop - this will be executed by a highprio stopper thread : 
2
strstr : if :  * migration_cpu_stop - this will be executed by a highprio stopper thread : 
2
strstr : for :  * migration_cpu_stop - this will be executed by a highprio stopper thread : 
2
strstr : while :  * migration_cpu_stop - this will be executed by a highprio stopper thread : 
2
str :  * and performs thread migration by bumping thread off CPU then[63]
strstr : INIT :  * and performs thread migration by bumping thread off CPU then : 
2
strstr : if :  * and performs thread migration by bumping thread off CPU then : 
2
strstr : for :  * and performs thread migration by bumping thread off CPU then : 
2
strstr : while :  * and performs thread migration by bumping thread off CPU then : 
2
str :  * 'pushing' onto another runqueue.[35]
strstr : INIT :  * 'pushing' onto another runqueue. : 
2
strstr : if :  * 'pushing' onto another runqueue. : 
2
strstr : for :  * 'pushing' onto another runqueue. : 
2
strstr : while :  * 'pushing' onto another runqueue. : 
2
str :  */[3]
strstr : INIT :  */ : 
2
strstr : if :  */ : 
2
strstr : for :  */ : 
2
strstr : while :  */ : 
2
str : static int migration_cpu_stop(void *data)[41]
strstr : INIT : static int migration_cpu_stop(void *data) : 
2
strstr : if : static int migration_cpu_stop(void *data) : 
2
strstr : for : static int migration_cpu_stop(void *data) : 
2
strstr : while : static int migration_cpu_stop(void *data) : 
2
str : 	struct migration_arg *arg = data;[34]
strstr : INIT : 	struct migration_arg *arg = data; : 
2
strstr : if : 	struct migration_arg *arg = data; : 
2
strstr : for : 	struct migration_arg *arg = data; : 
2
strstr : while : 	struct migration_arg *arg = data; : 
2
str : 	/*[3]
strstr : INIT : 	/* : 
2
strstr : if : 	/* : 
2
strstr : for : 	/* : 
2
strstr : while : 	/* : 
2
str : 	 * The original target cpu might have gone down and we might[61]
strstr : INIT : 	 * The original target cpu might have gone down and we might : 
2
strstr : if : 	 * The original target cpu might have gone down and we might : 
2
strstr : for : 	 * The original target cpu might have gone down and we might : 
2
strstr : while : 	 * The original target cpu might have gone down and we might : 
2
str : 	 * be on another cpu but it doesn't matter.[44]
strstr : INIT : 	 * be on another cpu but it doesn't matter. : 
2
strstr : if : 	 * be on another cpu but it doesn't matter. : 
2
strstr : for : 	 * be on another cpu but it doesn't matter. : 
2
strstr : while : 	 * be on another cpu but it doesn't matter. : 
2
str : 	 */[4]
strstr : INIT : 	 */ : 
2
strstr : if : 	 */ : 
2
strstr : for : 	 */ : 
2
strstr : while : 	 */ : 
2
str : 	local_irq_disable();[21]
strstr : INIT : 	local_irq_disable(); : 
2
strstr : if : 	local_irq_disable(); : 
2
strstr : for : 	local_irq_disable(); : 
2
strstr : while : 	local_irq_disable(); : 
2
str : 	__migrate_task(arg->task, raw_smp_processor_id(), arg->dest_cpu);[66]
strstr : INIT : 	__migrate_task(arg->task, raw_smp_processor_id(), arg->dest_cpu); : 
2
strstr : if : 	__migrate_task(arg->task, raw_smp_processor_id(), arg->dest_cpu); : 
2
strstr : for : 	__migrate_task(arg->task, raw_smp_processor_id(), arg->dest_cpu); : 
2
strstr : while : 	__migrate_task(arg->task, raw_smp_processor_id(), arg->dest_cpu); : 
2
str : 	local_irq_enable();[20]
strstr : INIT : 	local_irq_enable(); : 
2
strstr : if : 	local_irq_enable(); : 
2
strstr : for : 	local_irq_enable(); : 
2
strstr : while : 	local_irq_enable(); : 
2
str : 	return 0;[10]
strstr : INIT : 	return 0; : 
2
strstr : if : 	return 0; : 
2
strstr : for : 	return 0; : 
2
strstr : while : 	return 0; : 
2
str : #ifdef CONFIG_HOTPLUG_CPU[25]
strstr : INIT : #ifdef CONFIG_HOTPLUG_CPU : 
2
strstr : if : #ifdef CONFIG_HOTPLUG_CPU : 
2
strstr : for : #ifdef CONFIG_HOTPLUG_CPU : 
2
strstr : while : #ifdef CONFIG_HOTPLUG_CPU : 
2
str :  * Ensures that the idle task is using init_mm right before its cpu goes[72]
strstr : INIT :  * Ensures that the idle task is using init_mm right before its cpu goes : 
2
strstr : if :  * Ensures that the idle task is using init_mm right before its cpu goes : 
2
strstr : for :  * Ensures that the idle task is using init_mm right before its cpu goes : 
2
strstr : while :  * Ensures that the idle task is using init_mm right before its cpu goes : 
2
str :  * offline.[11]
strstr : INIT :  * offline. : 
2
strstr : if :  * offline. : 
2
strstr : for :  * offline. : 
2
strstr : while :  * offline. : 
2
str :  */[3]
strstr : INIT :  */ : 
2
strstr : if :  */ : 
2
strstr : for :  */ : 
2
strstr : while :  */ : 
2
str : void idle_task_exit(void)[25]
strstr : INIT : void idle_task_exit(void) : 
2
strstr : if : void idle_task_exit(void) : 
2
strstr : for : void idle_task_exit(void) : 
2
strstr : while : void idle_task_exit(void) : 
2
str : 	struct mm_struct *mm = current->active_mm;[43]
strstr : INIT : 	struct mm_struct *mm = current->active_mm; : 
2
strstr : if : 	struct mm_struct *mm = current->active_mm; : 
2
strstr : for : 	struct mm_struct *mm = current->active_mm; : 
2
strstr : while : 	struct mm_struct *mm = current->active_mm; : 
2
str : 	BUG_ON(cpu_online(smp_processor_id()));[40]
strstr : INIT : 	BUG_ON(cpu_online(smp_processor_id())); : 
2
strstr : if : 	BUG_ON(cpu_online(smp_processor_id())); : 
2
strstr : for : 	BUG_ON(cpu_online(smp_processor_id())); : 
2
strstr : while : 	BUG_ON(cpu_online(smp_processor_id())); : 
2
str : 	if (mm != &init_mm)[20]
strstr : INIT : 	if (mm != &init_mm) : 
2
strstr : if : 	if (mm != &init_mm) : 
2
strstr : for : 	if (mm != &init_mm) : 
2
strstr : while : 	if (mm != &init_mm) : 
2
str : 		switch_mm(mm, &init_mm, current);[35]
strstr : INIT : 		switch_mm(mm, &init_mm, current); : 
2
strstr : if : 		switch_mm(mm, &init_mm, current); : 
2
strstr : for : 		switch_mm(mm, &init_mm, current); : 
2
strstr : while : 		switch_mm(mm, &init_mm, current); : 
2
str : 	mmdrop(mm);[12]
strstr : INIT : 	mmdrop(mm); : 
2
strstr : if : 	mmdrop(mm); : 
2
strstr : for : 	mmdrop(mm); : 
2
strstr : while : 	mmdrop(mm); : 
2
str :  * Since this CPU is going 'away' for a while, fold any nr_active delta[71]
strstr : INIT :  * Since this CPU is going 'away' for a while, fold any nr_active delta : 
2
strstr : if :  * Since this CPU is going 'away' for a while, fold any nr_active delta : 
2
strstr : for :  * Since this CPU is going 'away' for a while, fold any nr_active delta : 
2
strstr : while :  * Since this CPU is going 'away' for a while, fold any nr_active delta : 
2
str :  * we might have. Assumes we're called after migrate_tasks() so that the[72]
strstr : INIT :  * we might have. Assumes we're called after migrate_tasks() so that the : 
2
strstr : if :  * we might have. Assumes we're called after migrate_tasks() so that the : 
2
strstr : for :  * we might have. Assumes we're called after migrate_tasks() so that the : 
2
strstr : while :  * we might have. Assumes we're called after migrate_tasks() so that the : 
2
str :  * nr_active count is stable.[29]
strstr : INIT :  * nr_active count is stable. : 
2
strstr : if :  * nr_active count is stable. : 
2
strstr : for :  * nr_active count is stable. : 
2
strstr : while :  * nr_active count is stable. : 
2
str :  * Also see the comment "Global load-average calculations".[59]
strstr : INIT :  * Also see the comment "Global load-average calculations". : 
2
strstr : if :  * Also see the comment "Global load-average calculations". : 
2
strstr : for :  * Also see the comment "Global load-average calculations". : 
2
strstr : while :  * Also see the comment "Global load-average calculations". : 
2
str :  */[3]
strstr : INIT :  */ : 
2
strstr : if :  */ : 
2
strstr : for :  */ : 
2
strstr : while :  */ : 
2
str : static void calc_load_migrate(struct rq *rq)[44]
strstr : INIT : static void calc_load_migrate(struct rq *rq) : 
2
strstr : if : static void calc_load_migrate(struct rq *rq) : 
2
strstr : for : static void calc_load_migrate(struct rq *rq) : 
2
strstr : while : static void calc_load_migrate(struct rq *rq) : 
2
str : 	long delta = calc_load_fold_active(rq);[40]
strstr : INIT : 	long delta = calc_load_fold_active(rq); : 
2
strstr : if : 	long delta = calc_load_fold_active(rq); : 
2
strstr : for : 	long delta = calc_load_fold_active(rq); : 
2
strstr : while : 	long delta = calc_load_fold_active(rq); : 
2
str : 	if (delta)[11]
strstr : INIT : 	if (delta) : 
2
strstr : if : 	if (delta) : 
2
strstr : for : 	if (delta) : 
2
strstr : while : 	if (delta) : 
2
str : 		atomic_long_add(delta, &calc_load_tasks);[43]
strstr : INIT : 		atomic_long_add(delta, &calc_load_tasks); : 
2
strstr : if : 		atomic_long_add(delta, &calc_load_tasks); : 
2
strstr : for : 		atomic_long_add(delta, &calc_load_tasks); : 
2
strstr : while : 		atomic_long_add(delta, &calc_load_tasks); : 
2
str :  * Migrate all tasks from the rq, sleeping tasks will be migrated by[68]
strstr : INIT :  * Migrate all tasks from the rq, sleeping tasks will be migrated by : 
2
strstr : if :  * Migrate all tasks from the rq, sleeping tasks will be migrated by : 
2
strstr : for :  * Migrate all tasks from the rq, sleeping tasks will be migrated by : 
2
strstr : while :  * Migrate all tasks from the rq, sleeping tasks will be migrated by : 
2
str :  * try_to_wake_up()->select_task_rq().[38]
strstr : INIT :  * try_to_wake_up()->select_task_rq(). : 
2
strstr : if :  * try_to_wake_up()->select_task_rq(). : 
2
strstr : for :  * try_to_wake_up()->select_task_rq(). : 
2
strstr : while :  * try_to_wake_up()->select_task_rq(). : 
2
str :  * Called with rq->lock held even though we'er in stop_machine() and[68]
strstr : INIT :  * Called with rq->lock held even though we'er in stop_machine() and : 
2
strstr : if :  * Called with rq->lock held even though we'er in stop_machine() and : 
2
strstr : for :  * Called with rq->lock held even though we'er in stop_machine() and : 
2
strstr : while :  * Called with rq->lock held even though we'er in stop_machine() and : 
2
str :  * there's no concurrency possible, we hold the required locks anyway[69]
strstr : INIT :  * there's no concurrency possible, we hold the required locks anyway : 
2
strstr : if :  * there's no concurrency possible, we hold the required locks anyway : 
2
strstr : for :  * there's no concurrency possible, we hold the required locks anyway : 
2
strstr : while :  * there's no concurrency possible, we hold the required locks anyway : 
2
str :  * because of lock validation efforts.[38]
strstr : INIT :  * because of lock validation efforts. : 
2
strstr : if :  * because of lock validation efforts. : 
2
strstr : for :  * because of lock validation efforts. : 
2
strstr : while :  * because of lock validation efforts. : 
2
str :  */[3]
strstr : INIT :  */ : 
2
strstr : if :  */ : 
2
strstr : for :  */ : 
2
strstr : while :  */ : 
2
str : static void migrate_tasks(unsigned int dead_cpu)[48]
strstr : INIT : static void migrate_tasks(unsigned int dead_cpu) : 
2
strstr : if : static void migrate_tasks(unsigned int dead_cpu) : 
2
strstr : for : static void migrate_tasks(unsigned int dead_cpu) : 
2
strstr : while : static void migrate_tasks(unsigned int dead_cpu) : 
2
str : 	struct rq *rq = cpu_rq(dead_cpu);[34]
strstr : INIT : 	struct rq *rq = cpu_rq(dead_cpu); : 
2
strstr : if : 	struct rq *rq = cpu_rq(dead_cpu); : 
2
strstr : for : 	struct rq *rq = cpu_rq(dead_cpu); : 
2
strstr : while : 	struct rq *rq = cpu_rq(dead_cpu); : 
2
str : 	struct task_struct *next, *stop = rq->stop;[44]
strstr : INIT : 	struct task_struct *next, *stop = rq->stop; : 
2
strstr : if : 	struct task_struct *next, *stop = rq->stop; : 
2
strstr : for : 	struct task_struct *next, *stop = rq->stop; : 
2
strstr : while : 	struct task_struct *next, *stop = rq->stop; : 
2
str : 	int dest_cpu;[14]
strstr : INIT : 	int dest_cpu; : 
2
strstr : if : 	int dest_cpu; : 
2
strstr : for : 	int dest_cpu; : 
2
strstr : while : 	int dest_cpu; : 
2
str : 	/*[3]
strstr : INIT : 	/* : 
2
strstr : if : 	/* : 
2
strstr : for : 	/* : 
2
strstr : while : 	/* : 
2
str : 	 * Fudge the rq selection such that the below task selection loop[66]
strstr : INIT : 	 * Fudge the rq selection such that the below task selection loop : 
2
strstr : if : 	 * Fudge the rq selection such that the below task selection loop : 
2
strstr : for : 	 * Fudge the rq selection such that the below task selection loop : 
2
strstr : while : 	 * Fudge the rq selection such that the below task selection loop : 
2
str : 	 * doesn't get stuck on the currently eligible stop task.[58]
strstr : INIT : 	 * doesn't get stuck on the currently eligible stop task. : 
2
strstr : if : 	 * doesn't get stuck on the currently eligible stop task. : 
2
strstr : for : 	 * doesn't get stuck on the currently eligible stop task. : 
2
strstr : while : 	 * doesn't get stuck on the currently eligible stop task. : 
2
str : 	 *[3]
strstr : INIT : 	 * : 
2
strstr : if : 	 * : 
2
strstr : for : 	 * : 
2
strstr : while : 	 * : 
2
str : 	 * We're currently inside stop_machine() and the rq is either stuck[68]
strstr : INIT : 	 * We're currently inside stop_machine() and the rq is either stuck : 
2
strstr : if : 	 * We're currently inside stop_machine() and the rq is either stuck : 
2
strstr : for : 	 * We're currently inside stop_machine() and the rq is either stuck : 
2
strstr : while : 	 * We're currently inside stop_machine() and the rq is either stuck : 
2
str : 	 * in the stop_machine_cpu_stop() loop, or we're executing this code,[70]
strstr : INIT : 	 * in the stop_machine_cpu_stop() loop, or we're executing this code, : 
2
strstr : if : 	 * in the stop_machine_cpu_stop() loop, or we're executing this code, : 
2
strstr : for : 	 * in the stop_machine_cpu_stop() loop, or we're executing this code, : 
2
strstr : while : 	 * in the stop_machine_cpu_stop() loop, or we're executing this code, : 
2
str : 	 * either way we should never end up calling schedule() until we're[68]
strstr : INIT : 	 * either way we should never end up calling schedule() until we're : 
2
strstr : if : 	 * either way we should never end up calling schedule() until we're : 
2
strstr : for : 	 * either way we should never end up calling schedule() until we're : 
2
strstr : while : 	 * either way we should never end up calling schedule() until we're : 
2
str : 	 * done here.[14]
strstr : INIT : 	 * done here. : 
2
strstr : if : 	 * done here. : 
2
strstr : for : 	 * done here. : 
2
strstr : while : 	 * done here. : 
2
str : 	 */[4]
strstr : INIT : 	 */ : 
2
strstr : if : 	 */ : 
2
strstr : for : 	 */ : 
2
strstr : while : 	 */ : 
2
str : 	rq->stop = NULL;[17]
strstr : INIT : 	rq->stop = NULL; : 
2
strstr : if : 	rq->stop = NULL; : 
2
strstr : for : 	rq->stop = NULL; : 
2
strstr : while : 	rq->stop = NULL; : 
2
str : 	/*[3]
strstr : INIT : 	/* : 
2
strstr : if : 	/* : 
2
strstr : for : 	/* : 
2
strstr : while : 	/* : 
2
str : 	 * put_prev_task() and pick_next_task() sched[46]
strstr : INIT : 	 * put_prev_task() and pick_next_task() sched : 
2
strstr : if : 	 * put_prev_task() and pick_next_task() sched : 
2
strstr : for : 	 * put_prev_task() and pick_next_task() sched : 
2
strstr : while : 	 * put_prev_task() and pick_next_task() sched : 
2
str : 	 * class method both need to have an up-to-date[48]
strstr : INIT : 	 * class method both need to have an up-to-date : 
2
strstr : if : 	 * class method both need to have an up-to-date : 
2
strstr : for : 	 * class method both need to have an up-to-date : 
2
strstr : while : 	 * class method both need to have an up-to-date : 
2
str : 	 * value of rq->clock[_task][29]
strstr : INIT : 	 * value of rq->clock[_task] : 
2
strstr : if : 	 * value of rq->clock[_task] : 
2
strstr : for : 	 * value of rq->clock[_task] : 
2
strstr : while : 	 * value of rq->clock[_task] : 
2
str : 	 */[4]
strstr : INIT : 	 */ : 
2
strstr : if : 	 */ : 
2
strstr : for : 	 */ : 
2
strstr : while : 	 */ : 
2
str : 	update_rq_clock(rq);[21]
strstr : INIT : 	update_rq_clock(rq); : 
2
strstr : if : 	update_rq_clock(rq); : 
2
strstr : for : 	update_rq_clock(rq); : 
2
strstr : while : 	update_rq_clock(rq); : 
2
str : 	for ( ; ; ) {[14]
strstr : INIT : 	for ( ; ; ) { : 
2
strstr : if : 	for ( ; ; ) { : 
2
strstr : for : 	for ( ; ; ) { : 
2
strstr : while : 	for ( ; ; ) { : 
2
str : 		/*[4]
strstr : INIT : 		/* : 
2
strstr : if : 		/* : 
2
strstr : for : 		/* : 
2
strstr : while : 		/* : 
2
str : 		 * There's this thread running, bail when that's the only[59]
strstr : INIT : 		 * There's this thread running, bail when that's the only : 
2
strstr : if : 		 * There's this thread running, bail when that's the only : 
2
strstr : for : 		 * There's this thread running, bail when that's the only : 
2
strstr : while : 		 * There's this thread running, bail when that's the only : 
2
str : 		 * remaining thread.[22]
strstr : INIT : 		 * remaining thread. : 
2
strstr : if : 		 * remaining thread. : 
2
strstr : for : 		 * remaining thread. : 
2
strstr : while : 		 * remaining thread. : 
2
str : 		 */[5]
strstr : INIT : 		 */ : 
2
strstr : if : 		 */ : 
2
strstr : for : 		 */ : 
2
strstr : while : 		 */ : 
2
str : 		if (rq->nr_running == 1)[26]
strstr : INIT : 		if (rq->nr_running == 1) : 
2
strstr : if : 		if (rq->nr_running == 1) : 
2
strstr : for : 		if (rq->nr_running == 1) : 
2
strstr : while : 		if (rq->nr_running == 1) : 
2
str : 			break;[9]
strstr : INIT : 			break; : 
2
strstr : if : 			break; : 
2
strstr : for : 			break; : 
2
strstr : while : 			break; : 
2
str : 		next = pick_next_task(rq);[28]
strstr : INIT : 		next = pick_next_task(rq); : 
2
strstr : if : 		next = pick_next_task(rq); : 
2
strstr : for : 		next = pick_next_task(rq); : 
2
strstr : while : 		next = pick_next_task(rq); : 
2
str : 		BUG_ON(!next);[16]
strstr : INIT : 		BUG_ON(!next); : 
2
strstr : if : 		BUG_ON(!next); : 
2
strstr : for : 		BUG_ON(!next); : 
2
strstr : while : 		BUG_ON(!next); : 
2
str : 		next->sched_class->put_prev_task(rq, next);[45]
strstr : INIT : 		next->sched_class->put_prev_task(rq, next); : 
2
strstr : if : 		next->sched_class->put_prev_task(rq, next); : 
2
strstr : for : 		next->sched_class->put_prev_task(rq, next); : 
2
strstr : while : 		next->sched_class->put_prev_task(rq, next); : 
2
str : 		/* Find suitable destination for @next, with force if needed. */[66]
strstr : INIT : 		/* Find suitable destination for @next, with force if needed. */ : 
2
strstr : if : 		/* Find suitable destination for @next, with force if needed. */ : 
2
strstr : for : 		/* Find suitable destination for @next, with force if needed. */ : 
2
strstr : while : 		/* Find suitable destination for @next, with force if needed. */ : 
2
str : 		dest_cpu = select_fallback_rq(dead_cpu, next);[48]
strstr : INIT : 		dest_cpu = select_fallback_rq(dead_cpu, next); : 
2
strstr : if : 		dest_cpu = select_fallback_rq(dead_cpu, next); : 
2
strstr : for : 		dest_cpu = select_fallback_rq(dead_cpu, next); : 
2
strstr : while : 		dest_cpu = select_fallback_rq(dead_cpu, next); : 
2
str : 		raw_spin_unlock(&rq->lock);[29]
strstr : INIT : 		raw_spin_unlock(&rq->lock); : 
2
strstr : if : 		raw_spin_unlock(&rq->lock); : 
2
strstr : for : 		raw_spin_unlock(&rq->lock); : 
2
strstr : while : 		raw_spin_unlock(&rq->lock); : 
2
str : 		__migrate_task(next, dead_cpu, dest_cpu);[43]
strstr : INIT : 		__migrate_task(next, dead_cpu, dest_cpu); : 
2
strstr : if : 		__migrate_task(next, dead_cpu, dest_cpu); : 
2
strstr : for : 		__migrate_task(next, dead_cpu, dest_cpu); : 
2
strstr : while : 		__migrate_task(next, dead_cpu, dest_cpu); : 
2
str : 		raw_spin_lock(&rq->lock);[27]
strstr : INIT : 		raw_spin_lock(&rq->lock); : 
2
strstr : if : 		raw_spin_lock(&rq->lock); : 
2
strstr : for : 		raw_spin_lock(&rq->lock); : 
2
strstr : while : 		raw_spin_lock(&rq->lock); : 
2
str : 	rq->stop = stop;[17]
strstr : INIT : 	rq->stop = stop; : 
2
strstr : if : 	rq->stop = stop; : 
2
strstr : for : 	rq->stop = stop; : 
2
strstr : while : 	rq->stop = stop; : 
2
str : #endif /* CONFIG_HOTPLUG_CPU */[31]
strstr : INIT : #endif /* CONFIG_HOTPLUG_CPU */ : 
2
strstr : if : #endif /* CONFIG_HOTPLUG_CPU */ : 
2
strstr : for : #endif /* CONFIG_HOTPLUG_CPU */ : 
2
strstr : while : #endif /* CONFIG_HOTPLUG_CPU */ : 
2
str : #if defined(CONFIG_SCHED_DEBUG) && defined(CONFIG_SYSCTL)[57]
strstr : INIT : #if defined(CONFIG_SCHED_DEBUG) && defined(CONFIG_SYSCTL) : 
2
strstr : if : #if defined(CONFIG_SCHED_DEBUG) && defined(CONFIG_SYSCTL) : 
2
strstr : for : #if defined(CONFIG_SCHED_DEBUG) && defined(CONFIG_SYSCTL) : 
2
strstr : while : #if defined(CONFIG_SCHED_DEBUG) && defined(CONFIG_SYSCTL) : 
2
str : static struct ctl_table sd_ctl_dir[] = {[40]
strstr : INIT : static struct ctl_table sd_ctl_dir[] = { : 
2
strstr : if : static struct ctl_table sd_ctl_dir[] = { : 
2
strstr : for : static struct ctl_table sd_ctl_dir[] = { : 
2
strstr : while : static struct ctl_table sd_ctl_dir[] = { : 
2
str : 		.procname	= "sched_domain",[29]
strstr : INIT : 		.procname	= "sched_domain", : 
2
strstr : if : 		.procname	= "sched_domain", : 
2
strstr : for : 		.procname	= "sched_domain", : 
2
strstr : while : 		.procname	= "sched_domain", : 
2
str : 		.mode		= 0555,[16]
strstr : INIT : 		.mode		= 0555, : 
2
strstr : if : 		.mode		= 0555, : 
2
strstr : for : 		.mode		= 0555, : 
2
strstr : while : 		.mode		= 0555, : 
2
str : 	},[3]
strstr : INIT : 	}, : 
2
strstr : if : 	}, : 
2
strstr : for : 	}, : 
2
strstr : while : 	}, : 
2
str : 	{}[3]
strstr : INIT : 	{} : 
2
strstr : if : 	{} : 
2
strstr : for : 	{} : 
2
strstr : while : 	{} : 
2
str : static struct ctl_table sd_ctl_root[] = {[41]
strstr : INIT : static struct ctl_table sd_ctl_root[] = { : 
2
strstr : if : static struct ctl_table sd_ctl_root[] = { : 
2
strstr : for : static struct ctl_table sd_ctl_root[] = { : 
2
strstr : while : static struct ctl_table sd_ctl_root[] = { : 
2
str : 		.procname	= "kernel",[23]
strstr : INIT : 		.procname	= "kernel", : 
2
strstr : if : 		.procname	= "kernel", : 
2
strstr : for : 		.procname	= "kernel", : 
2
strstr : while : 		.procname	= "kernel", : 
2
str : 		.mode		= 0555,[16]
strstr : INIT : 		.mode		= 0555, : 
2
strstr : if : 		.mode		= 0555, : 
2
strstr : for : 		.mode		= 0555, : 
2
strstr : while : 		.mode		= 0555, : 
2
str : 		.child		= sd_ctl_dir,[23]
strstr : INIT : 		.child		= sd_ctl_dir, : 
2
strstr : if : 		.child		= sd_ctl_dir, : 
2
strstr : for : 		.child		= sd_ctl_dir, : 
2
strstr : while : 		.child		= sd_ctl_dir, : 
2
str : 	},[3]
strstr : INIT : 	}, : 
2
strstr : if : 	}, : 
2
strstr : for : 	}, : 
2
strstr : while : 	}, : 
2
str : 	{}[3]
strstr : INIT : 	{} : 
2
strstr : if : 	{} : 
2
strstr : for : 	{} : 
2
strstr : while : 	{} : 
2
str : static struct ctl_table *sd_alloc_ctl_entry(int n)[50]
strstr : INIT : static struct ctl_table *sd_alloc_ctl_entry(int n) : 
2
strstr : if : static struct ctl_table *sd_alloc_ctl_entry(int n) : 
2
strstr : for : static struct ctl_table *sd_alloc_ctl_entry(int n) : 
2
strstr : while : static struct ctl_table *sd_alloc_ctl_entry(int n) : 
2
str : 	struct ctl_table *entry =[26]
strstr : INIT : 	struct ctl_table *entry = : 
2
strstr : if : 	struct ctl_table *entry = : 
2
strstr : for : 	struct ctl_table *entry = : 
2
strstr : while : 	struct ctl_table *entry = : 
2
str : 		kcalloc(n, sizeof(struct ctl_table), GFP_KERNEL);[51]
strstr : INIT : 		kcalloc(n, sizeof(struct ctl_table), GFP_KERNEL); : 
2
strstr : if : 		kcalloc(n, sizeof(struct ctl_table), GFP_KERNEL); : 
2
strstr : for : 		kcalloc(n, sizeof(struct ctl_table), GFP_KERNEL); : 
2
strstr : while : 		kcalloc(n, sizeof(struct ctl_table), GFP_KERNEL); : 
2
str : 	return entry;[14]
strstr : INIT : 	return entry; : 
2
strstr : if : 	return entry; : 
2
strstr : for : 	return entry; : 
2
strstr : while : 	return entry; : 
2
str : static void sd_free_ctl_entry(struct ctl_table **tablep)[56]
strstr : INIT : static void sd_free_ctl_entry(struct ctl_table **tablep) : 
2
strstr : if : static void sd_free_ctl_entry(struct ctl_table **tablep) : 
2
strstr : for : static void sd_free_ctl_entry(struct ctl_table **tablep) : 
2
strstr : while : static void sd_free_ctl_entry(struct ctl_table **tablep) : 
2
str : 	struct ctl_table *entry;[25]
strstr : INIT : 	struct ctl_table *entry; : 
2
strstr : if : 	struct ctl_table *entry; : 
2
strstr : for : 	struct ctl_table *entry; : 
2
strstr : while : 	struct ctl_table *entry; : 
2
str : 	/*[3]
strstr : INIT : 	/* : 
2
strstr : if : 	/* : 
2
strstr : for : 	/* : 
2
strstr : while : 	/* : 
2
str : 	 * In the intermediate directories, both the child directory and[65]
strstr : INIT : 	 * In the intermediate directories, both the child directory and : 
2
strstr : if : 	 * In the intermediate directories, both the child directory and : 
2
strstr : for : 	 * In the intermediate directories, both the child directory and : 
2
strstr : while : 	 * In the intermediate directories, both the child directory and : 
2
str : 	 * procname are dynamically allocated and could fail but the mode[66]
strstr : INIT : 	 * procname are dynamically allocated and could fail but the mode : 
2
strstr : if : 	 * procname are dynamically allocated and could fail but the mode : 
2
strstr : for : 	 * procname are dynamically allocated and could fail but the mode : 
2
strstr : while : 	 * procname are dynamically allocated and could fail but the mode : 
2
str : 	 * will always be set. In the lowest directory the names are[61]
strstr : INIT : 	 * will always be set. In the lowest directory the names are : 
2
strstr : if : 	 * will always be set. In the lowest directory the names are : 
2
strstr : for : 	 * will always be set. In the lowest directory the names are : 
2
strstr : while : 	 * will always be set. In the lowest directory the names are : 
2
str : 	 * static strings and all have proc handlers.[46]
strstr : INIT : 	 * static strings and all have proc handlers. : 
2
strstr : if : 	 * static strings and all have proc handlers. : 
2
strstr : for : 	 * static strings and all have proc handlers. : 
2
strstr : while : 	 * static strings and all have proc handlers. : 
2
str : 	 */[4]
strstr : INIT : 	 */ : 
2
strstr : if : 	 */ : 
2
strstr : for : 	 */ : 
2
strstr : while : 	 */ : 
2
str : 	for (entry = *tablep; entry->mode; entry++) {[46]
strstr : INIT : 	for (entry = *tablep; entry->mode; entry++) { : 
2
strstr : if : 	for (entry = *tablep; entry->mode; entry++) { : 
2
strstr : for : 	for (entry = *tablep; entry->mode; entry++) { : 
2
strstr : while : 	for (entry = *tablep; entry->mode; entry++) { : 
2
str : 		if (entry->child)[19]
strstr : INIT : 		if (entry->child) : 
2
strstr : if : 		if (entry->child) : 
2
strstr : for : 		if (entry->child) : 
2
strstr : while : 		if (entry->child) : 
2
str : 			sd_free_ctl_entry(&entry->child);[36]
strstr : INIT : 			sd_free_ctl_entry(&entry->child); : 
2
strstr : if : 			sd_free_ctl_entry(&entry->child); : 
2
strstr : for : 			sd_free_ctl_entry(&entry->child); : 
2
strstr : while : 			sd_free_ctl_entry(&entry->child); : 
2
str : 		if (entry->proc_handler == NULL)[34]
strstr : INIT : 		if (entry->proc_handler == NULL) : 
2
strstr : if : 		if (entry->proc_handler == NULL) : 
2
strstr : for : 		if (entry->proc_handler == NULL) : 
2
strstr : while : 		if (entry->proc_handler == NULL) : 
2
str : 			kfree(entry->procname);[26]
strstr : INIT : 			kfree(entry->procname); : 
2
strstr : if : 			kfree(entry->procname); : 
2
strstr : for : 			kfree(entry->procname); : 
2
strstr : while : 			kfree(entry->procname); : 
2
str : 	kfree(*tablep);[16]
strstr : INIT : 	kfree(*tablep); : 
2
strstr : if : 	kfree(*tablep); : 
2
strstr : for : 	kfree(*tablep); : 
2
strstr : while : 	kfree(*tablep); : 
2
str : 	*tablep = NULL;[16]
strstr : INIT : 	*tablep = NULL; : 
2
strstr : if : 	*tablep = NULL; : 
2
strstr : for : 	*tablep = NULL; : 
2
strstr : while : 	*tablep = NULL; : 
2
str : static int min_load_idx = 0;[28]
strstr : INIT : static int min_load_idx = 0; : 
2
strstr : if : static int min_load_idx = 0; : 
2
strstr : for : static int min_load_idx = 0; : 
2
strstr : while : static int min_load_idx = 0; : 
2
str : static int max_load_idx = CPU_LOAD_IDX_MAX-1;[45]
strstr : INIT : static int max_load_idx = CPU_LOAD_IDX_MAX-1; : 
2
strstr : if : static int max_load_idx = CPU_LOAD_IDX_MAX-1; : 
2
strstr : for : static int max_load_idx = CPU_LOAD_IDX_MAX-1; : 
2
strstr : while : static int max_load_idx = CPU_LOAD_IDX_MAX-1; : 
2
str : static void[11]
strstr : INIT : static void : 
2
strstr : if : static void : 
2
strstr : for : static void : 
2
strstr : while : static void : 
2
str : set_table_entry(struct ctl_table *entry,[40]
strstr : INIT : set_table_entry(struct ctl_table *entry, : 
2
strstr : if : set_table_entry(struct ctl_table *entry, : 
2
strstr : for : set_table_entry(struct ctl_table *entry, : 
2
strstr : while : set_table_entry(struct ctl_table *entry, : 
2
str : 		const char *procname, void *data, int maxlen,[47]
strstr : INIT : 		const char *procname, void *data, int maxlen, : 
2
strstr : if : 		const char *procname, void *data, int maxlen, : 
2
strstr : for : 		const char *procname, void *data, int maxlen, : 
2
strstr : while : 		const char *procname, void *data, int maxlen, : 
2
str : 		umode_t mode, proc_handler *proc_handler,[43]
strstr : INIT : 		umode_t mode, proc_handler *proc_handler, : 
2
strstr : if : 		umode_t mode, proc_handler *proc_handler, : 
2
strstr : for : 		umode_t mode, proc_handler *proc_handler, : 
2
strstr : while : 		umode_t mode, proc_handler *proc_handler, : 
2
str : 		bool load_idx)[16]
strstr : INIT : 		bool load_idx) : 
2
strstr : if : 		bool load_idx) : 
2
strstr : for : 		bool load_idx) : 
2
strstr : while : 		bool load_idx) : 
2
str : 	entry->procname = procname;[28]
strstr : INIT : 	entry->procname = procname; : 
2
strstr : if : 	entry->procname = procname; : 
2
strstr : for : 	entry->procname = procname; : 
2
strstr : while : 	entry->procname = procname; : 
2
str : 	entry->data = data;[20]
strstr : INIT : 	entry->data = data; : 
2
strstr : if : 	entry->data = data; : 
2
strstr : for : 	entry->data = data; : 
2
strstr : while : 	entry->data = data; : 
2
str : 	entry->maxlen = maxlen;[24]
strstr : INIT : 	entry->maxlen = maxlen; : 
2
strstr : if : 	entry->maxlen = maxlen; : 
2
strstr : for : 	entry->maxlen = maxlen; : 
2
strstr : while : 	entry->maxlen = maxlen; : 
2
str : 	entry->mode = mode;[20]
strstr : INIT : 	entry->mode = mode; : 
2
strstr : if : 	entry->mode = mode; : 
2
strstr : for : 	entry->mode = mode; : 
2
strstr : while : 	entry->mode = mode; : 
2
str : 	entry->proc_handler = proc_handler;[36]
strstr : INIT : 	entry->proc_handler = proc_handler; : 
2
strstr : if : 	entry->proc_handler = proc_handler; : 
2
strstr : for : 	entry->proc_handler = proc_handler; : 
2
strstr : while : 	entry->proc_handler = proc_handler; : 
2
str : 	if (load_idx) {[16]
strstr : INIT : 	if (load_idx) { : 
2
strstr : if : 	if (load_idx) { : 
2
strstr : for : 	if (load_idx) { : 
2
strstr : while : 	if (load_idx) { : 
2
str : 		entry->extra1 = &min_load_idx;[32]
strstr : INIT : 		entry->extra1 = &min_load_idx; : 
2
strstr : if : 		entry->extra1 = &min_load_idx; : 
2
strstr : for : 		entry->extra1 = &min_load_idx; : 
2
strstr : while : 		entry->extra1 = &min_load_idx; : 
2
str : 		entry->extra2 = &max_load_idx;[32]
strstr : INIT : 		entry->extra2 = &max_load_idx; : 
2
strstr : if : 		entry->extra2 = &max_load_idx; : 
2
strstr : for : 		entry->extra2 = &max_load_idx; : 
2
strstr : while : 		entry->extra2 = &max_load_idx; : 
2
str : static struct ctl_table *[25]
strstr : INIT : static struct ctl_table * : 
2
strstr : if : static struct ctl_table * : 
2
strstr : for : static struct ctl_table * : 
2
strstr : while : static struct ctl_table * : 
2
str : sd_alloc_ctl_domain_table(struct sched_domain *sd)[50]
strstr : INIT : sd_alloc_ctl_domain_table(struct sched_domain *sd) : 
2
strstr : if : sd_alloc_ctl_domain_table(struct sched_domain *sd) : 
2
strstr : for : sd_alloc_ctl_domain_table(struct sched_domain *sd) : 
2
strstr : while : sd_alloc_ctl_domain_table(struct sched_domain *sd) : 
2
str : 	struct ctl_table *table = sd_alloc_ctl_entry(13);[50]
strstr : INIT : 	struct ctl_table *table = sd_alloc_ctl_entry(13); : 
2
strstr : if : 	struct ctl_table *table = sd_alloc_ctl_entry(13); : 
2
strstr : for : 	struct ctl_table *table = sd_alloc_ctl_entry(13); : 
2
strstr : while : 	struct ctl_table *table = sd_alloc_ctl_entry(13); : 
2
str : 	if (table == NULL)[19]
strstr : INIT : 	if (table == NULL) : 
2
strstr : if : 	if (table == NULL) : 
2
strstr : for : 	if (table == NULL) : 
2
strstr : while : 	if (table == NULL) : 
2
str : 		return NULL;[14]
strstr : INIT : 		return NULL; : 
2
strstr : if : 		return NULL; : 
2
strstr : for : 		return NULL; : 
2
strstr : while : 		return NULL; : 
2
str : 	set_table_entry(&table[0], "min_interval", &sd->min_interval,[62]
strstr : INIT : 	set_table_entry(&table[0], "min_interval", &sd->min_interval, : 
2
strstr : if : 	set_table_entry(&table[0], "min_interval", &sd->min_interval, : 
2
strstr : for : 	set_table_entry(&table[0], "min_interval", &sd->min_interval, : 
2
strstr : while : 	set_table_entry(&table[0], "min_interval", &sd->min_interval, : 
2
str : 		sizeof(long), 0644, proc_doulongvec_minmax, false);[53]
strstr : INIT : 		sizeof(long), 0644, proc_doulongvec_minmax, false); : 
2
strstr : if : 		sizeof(long), 0644, proc_doulongvec_minmax, false); : 
2
strstr : for : 		sizeof(long), 0644, proc_doulongvec_minmax, false); : 
2
strstr : while : 		sizeof(long), 0644, proc_doulongvec_minmax, false); : 
2
str : 	set_table_entry(&table[1], "max_interval", &sd->max_interval,[62]
strstr : INIT : 	set_table_entry(&table[1], "max_interval", &sd->max_interval, : 
2
strstr : if : 	set_table_entry(&table[1], "max_interval", &sd->max_interval, : 
2
strstr : for : 	set_table_entry(&table[1], "max_interval", &sd->max_interval, : 
2
strstr : while : 	set_table_entry(&table[1], "max_interval", &sd->max_interval, : 
2
str : 		sizeof(long), 0644, proc_doulongvec_minmax, false);[53]
strstr : INIT : 		sizeof(long), 0644, proc_doulongvec_minmax, false); : 
2
strstr : if : 		sizeof(long), 0644, proc_doulongvec_minmax, false); : 
2
strstr : for : 		sizeof(long), 0644, proc_doulongvec_minmax, false); : 
2
strstr : while : 		sizeof(long), 0644, proc_doulongvec_minmax, false); : 
2
str : 	set_table_entry(&table[2], "busy_idx", &sd->busy_idx,[54]
strstr : INIT : 	set_table_entry(&table[2], "busy_idx", &sd->busy_idx, : 
2
strstr : if : 	set_table_entry(&table[2], "busy_idx", &sd->busy_idx, : 
2
strstr : for : 	set_table_entry(&table[2], "busy_idx", &sd->busy_idx, : 
2
strstr : while : 	set_table_entry(&table[2], "busy_idx", &sd->busy_idx, : 
2
str : 		sizeof(int), 0644, proc_dointvec_minmax, true);[49]
strstr : INIT : 		sizeof(int), 0644, proc_dointvec_minmax, true); : 
2
strstr : if : 		sizeof(int), 0644, proc_dointvec_minmax, true); : 
2
strstr : for : 		sizeof(int), 0644, proc_dointvec_minmax, true); : 
2
strstr : while : 		sizeof(int), 0644, proc_dointvec_minmax, true); : 
2
str : 	set_table_entry(&table[3], "idle_idx", &sd->idle_idx,[54]
strstr : INIT : 	set_table_entry(&table[3], "idle_idx", &sd->idle_idx, : 
2
strstr : if : 	set_table_entry(&table[3], "idle_idx", &sd->idle_idx, : 
2
strstr : for : 	set_table_entry(&table[3], "idle_idx", &sd->idle_idx, : 
2
strstr : while : 	set_table_entry(&table[3], "idle_idx", &sd->idle_idx, : 
2
str : 		sizeof(int), 0644, proc_dointvec_minmax, true);[49]
strstr : INIT : 		sizeof(int), 0644, proc_dointvec_minmax, true); : 
2
strstr : if : 		sizeof(int), 0644, proc_dointvec_minmax, true); : 
2
strstr : for : 		sizeof(int), 0644, proc_dointvec_minmax, true); : 
2
strstr : while : 		sizeof(int), 0644, proc_dointvec_minmax, true); : 
2
str : 	set_table_entry(&table[4], "newidle_idx", &sd->newidle_idx,[60]
strstr : INIT : 	set_table_entry(&table[4], "newidle_idx", &sd->newidle_idx, : 
2
strstr : if : 	set_table_entry(&table[4], "newidle_idx", &sd->newidle_idx, : 
2
strstr : for : 	set_table_entry(&table[4], "newidle_idx", &sd->newidle_idx, : 
2
strstr : while : 	set_table_entry(&table[4], "newidle_idx", &sd->newidle_idx, : 
2
str : 		sizeof(int), 0644, proc_dointvec_minmax, true);[49]
strstr : INIT : 		sizeof(int), 0644, proc_dointvec_minmax, true); : 
2
strstr : if : 		sizeof(int), 0644, proc_dointvec_minmax, true); : 
2
strstr : for : 		sizeof(int), 0644, proc_dointvec_minmax, true); : 
2
strstr : while : 		sizeof(int), 0644, proc_dointvec_minmax, true); : 
2
str : 	set_table_entry(&table[5], "wake_idx", &sd->wake_idx,[54]
strstr : INIT : 	set_table_entry(&table[5], "wake_idx", &sd->wake_idx, : 
2
strstr : if : 	set_table_entry(&table[5], "wake_idx", &sd->wake_idx, : 
2
strstr : for : 	set_table_entry(&table[5], "wake_idx", &sd->wake_idx, : 
2
strstr : while : 	set_table_entry(&table[5], "wake_idx", &sd->wake_idx, : 
2
str : 		sizeof(int), 0644, proc_dointvec_minmax, true);[49]
strstr : INIT : 		sizeof(int), 0644, proc_dointvec_minmax, true); : 
2
strstr : if : 		sizeof(int), 0644, proc_dointvec_minmax, true); : 
2
strstr : for : 		sizeof(int), 0644, proc_dointvec_minmax, true); : 
2
strstr : while : 		sizeof(int), 0644, proc_dointvec_minmax, true); : 
2
str : 	set_table_entry(&table[6], "forkexec_idx", &sd->forkexec_idx,[62]
strstr : INIT : 	set_table_entry(&table[6], "forkexec_idx", &sd->forkexec_idx, : 
2
strstr : if : 	set_table_entry(&table[6], "forkexec_idx", &sd->forkexec_idx, : 
2
strstr : for : 	set_table_entry(&table[6], "forkexec_idx", &sd->forkexec_idx, : 
2
strstr : while : 	set_table_entry(&table[6], "forkexec_idx", &sd->forkexec_idx, : 
2
str : 		sizeof(int), 0644, proc_dointvec_minmax, true);[49]
strstr : INIT : 		sizeof(int), 0644, proc_dointvec_minmax, true); : 
2
strstr : if : 		sizeof(int), 0644, proc_dointvec_minmax, true); : 
2
strstr : for : 		sizeof(int), 0644, proc_dointvec_minmax, true); : 
2
strstr : while : 		sizeof(int), 0644, proc_dointvec_minmax, true); : 
2
str : 	set_table_entry(&table[7], "busy_factor", &sd->busy_factor,[60]
strstr : INIT : 	set_table_entry(&table[7], "busy_factor", &sd->busy_factor, : 
2
strstr : if : 	set_table_entry(&table[7], "busy_factor", &sd->busy_factor, : 
2
strstr : for : 	set_table_entry(&table[7], "busy_factor", &sd->busy_factor, : 
2
strstr : while : 	set_table_entry(&table[7], "busy_factor", &sd->busy_factor, : 
2
str : 		sizeof(int), 0644, proc_dointvec_minmax, false);[50]
strstr : INIT : 		sizeof(int), 0644, proc_dointvec_minmax, false); : 
2
strstr : if : 		sizeof(int), 0644, proc_dointvec_minmax, false); : 
2
strstr : for : 		sizeof(int), 0644, proc_dointvec_minmax, false); : 
2
strstr : while : 		sizeof(int), 0644, proc_dointvec_minmax, false); : 
2
str : 	set_table_entry(&table[8], "imbalance_pct", &sd->imbalance_pct,[64]
strstr : INIT : 	set_table_entry(&table[8], "imbalance_pct", &sd->imbalance_pct, : 
2
strstr : if : 	set_table_entry(&table[8], "imbalance_pct", &sd->imbalance_pct, : 
2
strstr : for : 	set_table_entry(&table[8], "imbalance_pct", &sd->imbalance_pct, : 
2
strstr : while : 	set_table_entry(&table[8], "imbalance_pct", &sd->imbalance_pct, : 
2
str : 		sizeof(int), 0644, proc_dointvec_minmax, false);[50]
strstr : INIT : 		sizeof(int), 0644, proc_dointvec_minmax, false); : 
2
strstr : if : 		sizeof(int), 0644, proc_dointvec_minmax, false); : 
2
strstr : for : 		sizeof(int), 0644, proc_dointvec_minmax, false); : 
2
strstr : while : 		sizeof(int), 0644, proc_dointvec_minmax, false); : 
2
str : 	set_table_entry(&table[9], "cache_nice_tries",[47]
strstr : INIT : 	set_table_entry(&table[9], "cache_nice_tries", : 
2
strstr : if : 	set_table_entry(&table[9], "cache_nice_tries", : 
2
strstr : for : 	set_table_entry(&table[9], "cache_nice_tries", : 
2
strstr : while : 	set_table_entry(&table[9], "cache_nice_tries", : 
2
str : 		&sd->cache_nice_tries,[24]
strstr : INIT : 		&sd->cache_nice_tries, : 
2
strstr : if : 		&sd->cache_nice_tries, : 
2
strstr : for : 		&sd->cache_nice_tries, : 
2
strstr : while : 		&sd->cache_nice_tries, : 
2
str : 		sizeof(int), 0644, proc_dointvec_minmax, false);[50]
strstr : INIT : 		sizeof(int), 0644, proc_dointvec_minmax, false); : 
2
strstr : if : 		sizeof(int), 0644, proc_dointvec_minmax, false); : 
2
strstr : for : 		sizeof(int), 0644, proc_dointvec_minmax, false); : 
2
strstr : while : 		sizeof(int), 0644, proc_dointvec_minmax, false); : 
2
str : 	set_table_entry(&table[10], "flags", &sd->flags,[49]
strstr : INIT : 	set_table_entry(&table[10], "flags", &sd->flags, : 
2
strstr : if : 	set_table_entry(&table[10], "flags", &sd->flags, : 
2
strstr : for : 	set_table_entry(&table[10], "flags", &sd->flags, : 
2
strstr : while : 	set_table_entry(&table[10], "flags", &sd->flags, : 
2
str : 		sizeof(int), 0644, proc_dointvec_minmax, false);[50]
strstr : INIT : 		sizeof(int), 0644, proc_dointvec_minmax, false); : 
2
strstr : if : 		sizeof(int), 0644, proc_dointvec_minmax, false); : 
2
strstr : for : 		sizeof(int), 0644, proc_dointvec_minmax, false); : 
2
strstr : while : 		sizeof(int), 0644, proc_dointvec_minmax, false); : 
2
str : 	set_table_entry(&table[11], "name", sd->name,[46]
strstr : INIT : 	set_table_entry(&table[11], "name", sd->name, : 
2
strstr : if : 	set_table_entry(&table[11], "name", sd->name, : 
2
strstr : for : 	set_table_entry(&table[11], "name", sd->name, : 
2
strstr : while : 	set_table_entry(&table[11], "name", sd->name, : 
2
str : 		CORENAME_MAX_SIZE, 0444, proc_dostring, false);[49]
strstr : INIT : 		CORENAME_MAX_SIZE, 0444, proc_dostring, false); : 
2
strstr : if : 		CORENAME_MAX_SIZE, 0444, proc_dostring, false); : 
2
strstr : for : 		CORENAME_MAX_SIZE, 0444, proc_dostring, false); : 
2
strstr : while : 		CORENAME_MAX_SIZE, 0444, proc_dostring, false); : 
2
str : 	/* &table[12] is terminator */[31]
strstr : INIT : 	/* &table[12] is terminator */ : 
2
strstr : if : 	/* &table[12] is terminator */ : 
2
strstr : for : 	/* &table[12] is terminator */ : 
2
strstr : while : 	/* &table[12] is terminator */ : 
2
str : 	return table;[14]
strstr : INIT : 	return table; : 
2
strstr : if : 	return table; : 
2
strstr : for : 	return table; : 
2
strstr : while : 	return table; : 
2
str : static struct ctl_table *sd_alloc_ctl_cpu_table(int cpu)[56]
strstr : INIT : static struct ctl_table *sd_alloc_ctl_cpu_table(int cpu) : 
2
strstr : if : static struct ctl_table *sd_alloc_ctl_cpu_table(int cpu) : 
2
strstr : for : static struct ctl_table *sd_alloc_ctl_cpu_table(int cpu) : 
2
strstr : while : static struct ctl_table *sd_alloc_ctl_cpu_table(int cpu) : 
2
str : 	struct ctl_table *entry, *table;[33]
strstr : INIT : 	struct ctl_table *entry, *table; : 
2
strstr : if : 	struct ctl_table *entry, *table; : 
2
strstr : for : 	struct ctl_table *entry, *table; : 
2
strstr : while : 	struct ctl_table *entry, *table; : 
2
str : 	struct sched_domain *sd;[25]
strstr : INIT : 	struct sched_domain *sd; : 
2
strstr : if : 	struct sched_domain *sd; : 
2
strstr : for : 	struct sched_domain *sd; : 
2
strstr : while : 	struct sched_domain *sd; : 
2
str : 	int domain_num = 0, i;[23]
strstr : INIT : 	int domain_num = 0, i; : 
2
strstr : if : 	int domain_num = 0, i; : 
2
strstr : for : 	int domain_num = 0, i; : 
2
strstr : while : 	int domain_num = 0, i; : 
2
str : 	char buf[32];[14]
strstr : INIT : 	char buf[32]; : 
2
strstr : if : 	char buf[32]; : 
2
strstr : for : 	char buf[32]; : 
2
strstr : while : 	char buf[32]; : 
2
str : 	for_each_domain(cpu, sd)[25]
strstr : INIT : 	for_each_domain(cpu, sd) : 
2
strstr : if : 	for_each_domain(cpu, sd) : 
2
strstr : for : 	for_each_domain(cpu, sd) : 
2
strstr : while : 	for_each_domain(cpu, sd) : 
2
str : 		domain_num++;[15]
strstr : INIT : 		domain_num++; : 
2
strstr : if : 		domain_num++; : 
2
strstr : for : 		domain_num++; : 
2
strstr : while : 		domain_num++; : 
2
str : 	entry = table = sd_alloc_ctl_entry(domain_num + 1);[52]
strstr : INIT : 	entry = table = sd_alloc_ctl_entry(domain_num + 1); : 
2
strstr : if : 	entry = table = sd_alloc_ctl_entry(domain_num + 1); : 
2
strstr : for : 	entry = table = sd_alloc_ctl_entry(domain_num + 1); : 
2
strstr : while : 	entry = table = sd_alloc_ctl_entry(domain_num + 1); : 
2
str : 	if (table == NULL)[19]
strstr : INIT : 	if (table == NULL) : 
2
strstr : if : 	if (table == NULL) : 
2
strstr : for : 	if (table == NULL) : 
2
strstr : while : 	if (table == NULL) : 
2
str : 		return NULL;[14]
strstr : INIT : 		return NULL; : 
2
strstr : if : 		return NULL; : 
2
strstr : for : 		return NULL; : 
2
strstr : while : 		return NULL; : 
2
str : 	i = 0;[7]
strstr : INIT : 	i = 0; : 
2
strstr : if : 	i = 0; : 
2
strstr : for : 	i = 0; : 
2
strstr : while : 	i = 0; : 
2
str : 	for_each_domain(cpu, sd) {[27]
strstr : INIT : 	for_each_domain(cpu, sd) { : 
2
strstr : if : 	for_each_domain(cpu, sd) { : 
2
strstr : for : 	for_each_domain(cpu, sd) { : 
2
strstr : while : 	for_each_domain(cpu, sd) { : 
2
str : 		snprintf(buf, 32, "domain%d", i);[35]
strstr : INIT : 		snprintf(buf, 32, "domain%d", i); : 
2
strstr : if : 		snprintf(buf, 32, "domain%d", i); : 
2
strstr : for : 		snprintf(buf, 32, "domain%d", i); : 
2
strstr : while : 		snprintf(buf, 32, "domain%d", i); : 
2
str : 		entry->procname = kstrdup(buf, GFP_KERNEL);[45]
strstr : INIT : 		entry->procname = kstrdup(buf, GFP_KERNEL); : 
2
strstr : if : 		entry->procname = kstrdup(buf, GFP_KERNEL); : 
2
strstr : for : 		entry->procname = kstrdup(buf, GFP_KERNEL); : 
2
strstr : while : 		entry->procname = kstrdup(buf, GFP_KERNEL); : 
2
str : 		entry->mode = 0555;[21]
strstr : INIT : 		entry->mode = 0555; : 
2
strstr : if : 		entry->mode = 0555; : 
2
strstr : for : 		entry->mode = 0555; : 
2
strstr : while : 		entry->mode = 0555; : 
2
str : 		entry->child = sd_alloc_ctl_domain_table(sd);[47]
strstr : INIT : 		entry->child = sd_alloc_ctl_domain_table(sd); : 
2
strstr : if : 		entry->child = sd_alloc_ctl_domain_table(sd); : 
2
strstr : for : 		entry->child = sd_alloc_ctl_domain_table(sd); : 
2
strstr : while : 		entry->child = sd_alloc_ctl_domain_table(sd); : 
2
str : 		entry++;[10]
strstr : INIT : 		entry++; : 
2
strstr : if : 		entry++; : 
2
strstr : for : 		entry++; : 
2
strstr : while : 		entry++; : 
2
str : 		i++;[6]
strstr : INIT : 		i++; : 
2
strstr : if : 		i++; : 
2
strstr : for : 		i++; : 
2
strstr : while : 		i++; : 
2
str : 	return table;[14]
strstr : INIT : 	return table; : 
2
strstr : if : 	return table; : 
2
strstr : for : 	return table; : 
2
strstr : while : 	return table; : 
2
str : static struct ctl_table_header *sd_sysctl_header;[49]
strstr : INIT : static struct ctl_table_header *sd_sysctl_header; : 
2
strstr : if : static struct ctl_table_header *sd_sysctl_header; : 
2
strstr : for : static struct ctl_table_header *sd_sysctl_header; : 
2
strstr : while : static struct ctl_table_header *sd_sysctl_header; : 
2
str : static void register_sched_domain_sysctl(void)[46]
strstr : INIT : static void register_sched_domain_sysctl(void) : 
2
strstr : if : static void register_sched_domain_sysctl(void) : 
2
strstr : for : static void register_sched_domain_sysctl(void) : 
2
strstr : while : static void register_sched_domain_sysctl(void) : 
2
str : 	int i, cpu_num = num_possible_cpus();[38]
strstr : INIT : 	int i, cpu_num = num_possible_cpus(); : 
2
strstr : if : 	int i, cpu_num = num_possible_cpus(); : 
2
strstr : for : 	int i, cpu_num = num_possible_cpus(); : 
2
strstr : while : 	int i, cpu_num = num_possible_cpus(); : 
2
str : 	struct ctl_table *entry = sd_alloc_ctl_entry(cpu_num + 1);[59]
strstr : INIT : 	struct ctl_table *entry = sd_alloc_ctl_entry(cpu_num + 1); : 
2
strstr : if : 	struct ctl_table *entry = sd_alloc_ctl_entry(cpu_num + 1); : 
2
strstr : for : 	struct ctl_table *entry = sd_alloc_ctl_entry(cpu_num + 1); : 
2
strstr : while : 	struct ctl_table *entry = sd_alloc_ctl_entry(cpu_num + 1); : 
2
str : 	char buf[32];[14]
strstr : INIT : 	char buf[32]; : 
2
strstr : if : 	char buf[32]; : 
2
strstr : for : 	char buf[32]; : 
2
strstr : while : 	char buf[32]; : 
2
str : 	WARN_ON(sd_ctl_dir[0].child);[30]
strstr : INIT : 	WARN_ON(sd_ctl_dir[0].child); : 
2
strstr : if : 	WARN_ON(sd_ctl_dir[0].child); : 
2
strstr : for : 	WARN_ON(sd_ctl_dir[0].child); : 
2
strstr : while : 	WARN_ON(sd_ctl_dir[0].child); : 
2
str : 	sd_ctl_dir[0].child = entry;[29]
strstr : INIT : 	sd_ctl_dir[0].child = entry; : 
2
strstr : if : 	sd_ctl_dir[0].child = entry; : 
2
strstr : for : 	sd_ctl_dir[0].child = entry; : 
2
strstr : while : 	sd_ctl_dir[0].child = entry; : 
2
str : 	if (entry == NULL)[19]
strstr : INIT : 	if (entry == NULL) : 
2
strstr : if : 	if (entry == NULL) : 
2
strstr : for : 	if (entry == NULL) : 
2
strstr : while : 	if (entry == NULL) : 
2
str : 		return;[9]
strstr : INIT : 		return; : 
2
strstr : if : 		return; : 
2
strstr : for : 		return; : 
2
strstr : while : 		return; : 
2
str : 	for_each_possible_cpu(i) {[27]
strstr : INIT : 	for_each_possible_cpu(i) { : 
2
strstr : if : 	for_each_possible_cpu(i) { : 
2
strstr : for : 	for_each_possible_cpu(i) { : 
2
strstr : while : 	for_each_possible_cpu(i) { : 
2
str : 		snprintf(buf, 32, "cpu%d", i);[32]
strstr : INIT : 		snprintf(buf, 32, "cpu%d", i); : 
2
strstr : if : 		snprintf(buf, 32, "cpu%d", i); : 
2
strstr : for : 		snprintf(buf, 32, "cpu%d", i); : 
2
strstr : while : 		snprintf(buf, 32, "cpu%d", i); : 
2
str : 		entry->procname = kstrdup(buf, GFP_KERNEL);[45]
strstr : INIT : 		entry->procname = kstrdup(buf, GFP_KERNEL); : 
2
strstr : if : 		entry->procname = kstrdup(buf, GFP_KERNEL); : 
2
strstr : for : 		entry->procname = kstrdup(buf, GFP_KERNEL); : 
2
strstr : while : 		entry->procname = kstrdup(buf, GFP_KERNEL); : 
2
str : 		entry->mode = 0555;[21]
strstr : INIT : 		entry->mode = 0555; : 
2
strstr : if : 		entry->mode = 0555; : 
2
strstr : for : 		entry->mode = 0555; : 
2
strstr : while : 		entry->mode = 0555; : 
2
str : 		entry->child = sd_alloc_ctl_cpu_table(i);[43]
strstr : INIT : 		entry->child = sd_alloc_ctl_cpu_table(i); : 
2
strstr : if : 		entry->child = sd_alloc_ctl_cpu_table(i); : 
2
strstr : for : 		entry->child = sd_alloc_ctl_cpu_table(i); : 
2
strstr : while : 		entry->child = sd_alloc_ctl_cpu_table(i); : 
2
str : 		entry++;[10]
strstr : INIT : 		entry++; : 
2
strstr : if : 		entry++; : 
2
strstr : for : 		entry++; : 
2
strstr : while : 		entry++; : 
2
str : 	WARN_ON(sd_sysctl_header);[27]
strstr : INIT : 	WARN_ON(sd_sysctl_header); : 
2
strstr : if : 	WARN_ON(sd_sysctl_header); : 
2
strstr : for : 	WARN_ON(sd_sysctl_header); : 
2
strstr : while : 	WARN_ON(sd_sysctl_header); : 
2
str : 	sd_sysctl_header = register_sysctl_table(sd_ctl_root);[55]
strstr : INIT : 	sd_sysctl_header = register_sysctl_table(sd_ctl_root); : 
2
strstr : if : 	sd_sysctl_header = register_sysctl_table(sd_ctl_root); : 
2
strstr : for : 	sd_sysctl_header = register_sysctl_table(sd_ctl_root); : 
2
strstr : while : 	sd_sysctl_header = register_sysctl_table(sd_ctl_root); : 
2
str : /* may be called multiple times per register */[47]
strstr : INIT : /* may be called multiple times per register */ : 
2
strstr : if : /* may be called multiple times per register */ : 
2
strstr : for : /* may be called multiple times per register */ : 
2
strstr : while : /* may be called multiple times per register */ : 
2
str : static void unregister_sched_domain_sysctl(void)[48]
strstr : INIT : static void unregister_sched_domain_sysctl(void) : 
2
strstr : if : static void unregister_sched_domain_sysctl(void) : 
2
strstr : for : static void unregister_sched_domain_sysctl(void) : 
2
strstr : while : static void unregister_sched_domain_sysctl(void) : 
2
str : 	if (sd_sysctl_header)[22]
strstr : INIT : 	if (sd_sysctl_header) : 
2
strstr : if : 	if (sd_sysctl_header) : 
2
strstr : for : 	if (sd_sysctl_header) : 
2
strstr : while : 	if (sd_sysctl_header) : 
2
str : 		unregister_sysctl_table(sd_sysctl_header);[44]
strstr : INIT : 		unregister_sysctl_table(sd_sysctl_header); : 
2
strstr : if : 		unregister_sysctl_table(sd_sysctl_header); : 
2
strstr : for : 		unregister_sysctl_table(sd_sysctl_header); : 
2
strstr : while : 		unregister_sysctl_table(sd_sysctl_header); : 
2
str : 	sd_sysctl_header = NULL;[25]
strstr : INIT : 	sd_sysctl_header = NULL; : 
2
strstr : if : 	sd_sysctl_header = NULL; : 
2
strstr : for : 	sd_sysctl_header = NULL; : 
2
strstr : while : 	sd_sysctl_header = NULL; : 
2
str : 	if (sd_ctl_dir[0].child)[25]
strstr : INIT : 	if (sd_ctl_dir[0].child) : 
2
strstr : if : 	if (sd_ctl_dir[0].child) : 
2
strstr : for : 	if (sd_ctl_dir[0].child) : 
2
strstr : while : 	if (sd_ctl_dir[0].child) : 
2
str : 		sd_free_ctl_entry(&sd_ctl_dir[0].child);[42]
strstr : INIT : 		sd_free_ctl_entry(&sd_ctl_dir[0].child); : 
2
strstr : if : 		sd_free_ctl_entry(&sd_ctl_dir[0].child); : 
2
strstr : for : 		sd_free_ctl_entry(&sd_ctl_dir[0].child); : 
2
strstr : while : 		sd_free_ctl_entry(&sd_ctl_dir[0].child); : 
2
str : #else[5]
strstr : INIT : #else : 
2
strstr : if : #else : 
2
strstr : for : #else : 
2
strstr : while : #else : 
2
str : static void register_sched_domain_sysctl(void)[46]
strstr : INIT : static void register_sched_domain_sysctl(void) : 
2
strstr : if : static void register_sched_domain_sysctl(void) : 
2
strstr : for : static void register_sched_domain_sysctl(void) : 
2
strstr : while : static void register_sched_domain_sysctl(void) : 
2
str : static void unregister_sched_domain_sysctl(void)[48]
strstr : INIT : static void unregister_sched_domain_sysctl(void) : 
2
strstr : if : static void unregister_sched_domain_sysctl(void) : 
2
strstr : for : static void unregister_sched_domain_sysctl(void) : 
2
strstr : while : static void unregister_sched_domain_sysctl(void) : 
2
str : #endif[6]
strstr : INIT : #endif : 
2
strstr : if : #endif : 
2
strstr : for : #endif : 
2
strstr : while : #endif : 
2
str : static void set_rq_online(struct rq *rq)[40]
strstr : INIT : static void set_rq_online(struct rq *rq) : 
2
strstr : if : static void set_rq_online(struct rq *rq) : 
2
strstr : for : static void set_rq_online(struct rq *rq) : 
2
strstr : while : static void set_rq_online(struct rq *rq) : 
2
str : 	if (!rq->online) {[19]
strstr : INIT : 	if (!rq->online) { : 
2
strstr : if : 	if (!rq->online) { : 
2
strstr : for : 	if (!rq->online) { : 
2
strstr : while : 	if (!rq->online) { : 
2
str : 		const struct sched_class *class;[34]
strstr : INIT : 		const struct sched_class *class; : 
2
strstr : if : 		const struct sched_class *class; : 
2
strstr : for : 		const struct sched_class *class; : 
2
strstr : while : 		const struct sched_class *class; : 
2
str : 		cpumask_set_cpu(rq->cpu, rq->rd->online);[43]
strstr : INIT : 		cpumask_set_cpu(rq->cpu, rq->rd->online); : 
2
strstr : if : 		cpumask_set_cpu(rq->cpu, rq->rd->online); : 
2
strstr : for : 		cpumask_set_cpu(rq->cpu, rq->rd->online); : 
2
strstr : while : 		cpumask_set_cpu(rq->cpu, rq->rd->online); : 
2
str : 		rq->online = 1;[17]
strstr : INIT : 		rq->online = 1; : 
2
strstr : if : 		rq->online = 1; : 
2
strstr : for : 		rq->online = 1; : 
2
strstr : while : 		rq->online = 1; : 
2
str : 		for_each_class(class) {[25]
strstr : INIT : 		for_each_class(class) { : 
2
strstr : if : 		for_each_class(class) { : 
2
strstr : for : 		for_each_class(class) { : 
2
strstr : while : 		for_each_class(class) { : 
2
str : 			if (class->rq_online)[24]
strstr : INIT : 			if (class->rq_online) : 
2
strstr : if : 			if (class->rq_online) : 
2
strstr : for : 			if (class->rq_online) : 
2
strstr : while : 			if (class->rq_online) : 
2
str : 				class->rq_online(rq);[25]
strstr : INIT : 				class->rq_online(rq); : 
2
strstr : if : 				class->rq_online(rq); : 
2
strstr : for : 				class->rq_online(rq); : 
2
strstr : while : 				class->rq_online(rq); : 
2
str : 		}[3]
strstr : INIT : 		} : 
2
strstr : if : 		} : 
2
strstr : for : 		} : 
2
strstr : while : 		} : 
2
str : static void set_rq_offline(struct rq *rq)[41]
strstr : INIT : static void set_rq_offline(struct rq *rq) : 
2
strstr : if : static void set_rq_offline(struct rq *rq) : 
2
strstr : for : static void set_rq_offline(struct rq *rq) : 
2
strstr : while : static void set_rq_offline(struct rq *rq) : 
2
str : 	if (rq->online) {[18]
strstr : INIT : 	if (rq->online) { : 
2
strstr : if : 	if (rq->online) { : 
2
strstr : for : 	if (rq->online) { : 
2
strstr : while : 	if (rq->online) { : 
2
str : 		const struct sched_class *class;[34]
strstr : INIT : 		const struct sched_class *class; : 
2
strstr : if : 		const struct sched_class *class; : 
2
strstr : for : 		const struct sched_class *class; : 
2
strstr : while : 		const struct sched_class *class; : 
2
str : 		for_each_class(class) {[25]
strstr : INIT : 		for_each_class(class) { : 
2
strstr : if : 		for_each_class(class) { : 
2
strstr : for : 		for_each_class(class) { : 
2
strstr : while : 		for_each_class(class) { : 
2
str : 			if (class->rq_offline)[25]
strstr : INIT : 			if (class->rq_offline) : 
2
strstr : if : 			if (class->rq_offline) : 
2
strstr : for : 			if (class->rq_offline) : 
2
strstr : while : 			if (class->rq_offline) : 
2
str : 				class->rq_offline(rq);[26]
strstr : INIT : 				class->rq_offline(rq); : 
2
strstr : if : 				class->rq_offline(rq); : 
2
strstr : for : 				class->rq_offline(rq); : 
2
strstr : while : 				class->rq_offline(rq); : 
2
str : 		}[3]
strstr : INIT : 		} : 
2
strstr : if : 		} : 
2
strstr : for : 		} : 
2
strstr : while : 		} : 
2
str : 		cpumask_clear_cpu(rq->cpu, rq->rd->online);[45]
strstr : INIT : 		cpumask_clear_cpu(rq->cpu, rq->rd->online); : 
2
strstr : if : 		cpumask_clear_cpu(rq->cpu, rq->rd->online); : 
2
strstr : for : 		cpumask_clear_cpu(rq->cpu, rq->rd->online); : 
2
strstr : while : 		cpumask_clear_cpu(rq->cpu, rq->rd->online); : 
2
str : 		rq->online = 0;[17]
strstr : INIT : 		rq->online = 0; : 
2
strstr : if : 		rq->online = 0; : 
2
strstr : for : 		rq->online = 0; : 
2
strstr : while : 		rq->online = 0; : 
2
str :  * migration_call - callback that gets triggered when a CPU is added.[69]
strstr : INIT :  * migration_call - callback that gets triggered when a CPU is added. : 
2
strstr : if :  * migration_call - callback that gets triggered when a CPU is added. : 
2
strstr : for :  * migration_call - callback that gets triggered when a CPU is added. : 
2
strstr : while :  * migration_call - callback that gets triggered when a CPU is added. : 
2
str :  * Here we can start up the necessary migration thread for the new CPU.[71]
strstr : INIT :  * Here we can start up the necessary migration thread for the new CPU. : 
2
strstr : if :  * Here we can start up the necessary migration thread for the new CPU. : 
2
strstr : for :  * Here we can start up the necessary migration thread for the new CPU. : 
2
strstr : while :  * Here we can start up the necessary migration thread for the new CPU. : 
2
str :  */[3]
strstr : INIT :  */ : 
2
strstr : if :  */ : 
2
strstr : for :  */ : 
2
strstr : while :  */ : 
2
str : static int[10]
strstr : INIT : static int : 
2
strstr : if : static int : 
2
strstr : for : static int : 
2
strstr : while : static int : 
2
str : migration_call(struct notifier_block *nfb, unsigned long action, void *hcpu)[76]
strstr : INIT : migration_call(struct notifier_block *nfb, unsigned long action, void *hcpu) : 
2
strstr : if : migration_call(struct notifier_block *nfb, unsigned long action, void *hcpu) : 
2
strstr : for : migration_call(struct notifier_block *nfb, unsigned long action, void *hcpu) : 
2
strstr : while : migration_call(struct notifier_block *nfb, unsigned long action, void *hcpu) : 
2
str : 	int cpu = (long)hcpu;[22]
strstr : INIT : 	int cpu = (long)hcpu; : 
2
strstr : if : 	int cpu = (long)hcpu; : 
2
strstr : for : 	int cpu = (long)hcpu; : 
2
strstr : while : 	int cpu = (long)hcpu; : 
2
str : 	unsigned long flags;[21]
strstr : INIT : 	unsigned long flags; : 
2
strstr : if : 	unsigned long flags; : 
2
strstr : for : 	unsigned long flags; : 
2
strstr : while : 	unsigned long flags; : 
2
str : 	struct rq *rq = cpu_rq(cpu);[29]
strstr : INIT : 	struct rq *rq = cpu_rq(cpu); : 
2
strstr : if : 	struct rq *rq = cpu_rq(cpu); : 
2
strstr : for : 	struct rq *rq = cpu_rq(cpu); : 
2
strstr : while : 	struct rq *rq = cpu_rq(cpu); : 
2
str : 	switch (action & ~CPU_TASKS_FROZEN) {[38]
strstr : INIT : 	switch (action & ~CPU_TASKS_FROZEN) { : 
2
strstr : if : 	switch (action & ~CPU_TASKS_FROZEN) { : 
2
strstr : for : 	switch (action & ~CPU_TASKS_FROZEN) { : 
2
strstr : while : 	switch (action & ~CPU_TASKS_FROZEN) { : 
2
str : 	case CPU_UP_PREPARE:[21]
strstr : INIT : 	case CPU_UP_PREPARE: : 
2
strstr : if : 	case CPU_UP_PREPARE: : 
2
strstr : for : 	case CPU_UP_PREPARE: : 
2
strstr : while : 	case CPU_UP_PREPARE: : 
2
str : 		rq->calc_load_update = calc_load_update;[42]
strstr : INIT : 		rq->calc_load_update = calc_load_update; : 
2
strstr : if : 		rq->calc_load_update = calc_load_update; : 
2
strstr : for : 		rq->calc_load_update = calc_load_update; : 
2
strstr : while : 		rq->calc_load_update = calc_load_update; : 
2
str : 		break;[8]
strstr : INIT : 		break; : 
2
strstr : if : 		break; : 
2
strstr : for : 		break; : 
2
strstr : while : 		break; : 
2
str : 	case CPU_ONLINE:[17]
strstr : INIT : 	case CPU_ONLINE: : 
2
strstr : if : 	case CPU_ONLINE: : 
2
strstr : for : 	case CPU_ONLINE: : 
2
strstr : while : 	case CPU_ONLINE: : 
2
str : 		/* Update our root-domain */[30]
strstr : INIT : 		/* Update our root-domain */ : 
2
strstr : if : 		/* Update our root-domain */ : 
2
strstr : for : 		/* Update our root-domain */ : 
2
strstr : while : 		/* Update our root-domain */ : 
2
str : 		raw_spin_lock_irqsave(&rq->lock, flags);[42]
strstr : INIT : 		raw_spin_lock_irqsave(&rq->lock, flags); : 
2
strstr : if : 		raw_spin_lock_irqsave(&rq->lock, flags); : 
2
strstr : for : 		raw_spin_lock_irqsave(&rq->lock, flags); : 
2
strstr : while : 		raw_spin_lock_irqsave(&rq->lock, flags); : 
2
str : 		if (rq->rd) {[15]
strstr : INIT : 		if (rq->rd) { : 
2
strstr : if : 		if (rq->rd) { : 
2
strstr : for : 		if (rq->rd) { : 
2
strstr : while : 		if (rq->rd) { : 
2
str : 			BUG_ON(!cpumask_test_cpu(cpu, rq->rd->span));[48]
strstr : INIT : 			BUG_ON(!cpumask_test_cpu(cpu, rq->rd->span)); : 
2
strstr : if : 			BUG_ON(!cpumask_test_cpu(cpu, rq->rd->span)); : 
2
strstr : for : 			BUG_ON(!cpumask_test_cpu(cpu, rq->rd->span)); : 
2
strstr : while : 			BUG_ON(!cpumask_test_cpu(cpu, rq->rd->span)); : 
2
str : 			set_rq_online(rq);[21]
strstr : INIT : 			set_rq_online(rq); : 
2
strstr : if : 			set_rq_online(rq); : 
2
strstr : for : 			set_rq_online(rq); : 
2
strstr : while : 			set_rq_online(rq); : 
2
str : 		}[3]
strstr : INIT : 		} : 
2
strstr : if : 		} : 
2
strstr : for : 		} : 
2
strstr : while : 		} : 
2
str : 		raw_spin_unlock_irqrestore(&rq->lock, flags);[47]
strstr : INIT : 		raw_spin_unlock_irqrestore(&rq->lock, flags); : 
2
strstr : if : 		raw_spin_unlock_irqrestore(&rq->lock, flags); : 
2
strstr : for : 		raw_spin_unlock_irqrestore(&rq->lock, flags); : 
2
strstr : while : 		raw_spin_unlock_irqrestore(&rq->lock, flags); : 
2
str : 		break;[8]
strstr : INIT : 		break; : 
2
strstr : if : 		break; : 
2
strstr : for : 		break; : 
2
strstr : while : 		break; : 
2
str : #ifdef CONFIG_HOTPLUG_CPU[25]
strstr : INIT : #ifdef CONFIG_HOTPLUG_CPU : 
2
strstr : if : #ifdef CONFIG_HOTPLUG_CPU : 
2
strstr : for : #ifdef CONFIG_HOTPLUG_CPU : 
2
strstr : while : #ifdef CONFIG_HOTPLUG_CPU : 
2
str : 	case CPU_DYING:[16]
strstr : INIT : 	case CPU_DYING: : 
2
strstr : if : 	case CPU_DYING: : 
2
strstr : for : 	case CPU_DYING: : 
2
strstr : while : 	case CPU_DYING: : 
2
str : 		sched_ttwu_pending();[23]
strstr : INIT : 		sched_ttwu_pending(); : 
2
strstr : if : 		sched_ttwu_pending(); : 
2
strstr : for : 		sched_ttwu_pending(); : 
2
strstr : while : 		sched_ttwu_pending(); : 
2
str : 		/* Update our root-domain */[30]
strstr : INIT : 		/* Update our root-domain */ : 
2
strstr : if : 		/* Update our root-domain */ : 
2
strstr : for : 		/* Update our root-domain */ : 
2
strstr : while : 		/* Update our root-domain */ : 
2
str : 		raw_spin_lock_irqsave(&rq->lock, flags);[42]
strstr : INIT : 		raw_spin_lock_irqsave(&rq->lock, flags); : 
2
strstr : if : 		raw_spin_lock_irqsave(&rq->lock, flags); : 
2
strstr : for : 		raw_spin_lock_irqsave(&rq->lock, flags); : 
2
strstr : while : 		raw_spin_lock_irqsave(&rq->lock, flags); : 
2
str : 		if (rq->rd) {[15]
strstr : INIT : 		if (rq->rd) { : 
2
strstr : if : 		if (rq->rd) { : 
2
strstr : for : 		if (rq->rd) { : 
2
strstr : while : 		if (rq->rd) { : 
2
str : 			BUG_ON(!cpumask_test_cpu(cpu, rq->rd->span));[48]
strstr : INIT : 			BUG_ON(!cpumask_test_cpu(cpu, rq->rd->span)); : 
2
strstr : if : 			BUG_ON(!cpumask_test_cpu(cpu, rq->rd->span)); : 
2
strstr : for : 			BUG_ON(!cpumask_test_cpu(cpu, rq->rd->span)); : 
2
strstr : while : 			BUG_ON(!cpumask_test_cpu(cpu, rq->rd->span)); : 
2
str : 			set_rq_offline(rq);[22]
strstr : INIT : 			set_rq_offline(rq); : 
2
strstr : if : 			set_rq_offline(rq); : 
2
strstr : for : 			set_rq_offline(rq); : 
2
strstr : while : 			set_rq_offline(rq); : 
2
str : 		}[3]
strstr : INIT : 		} : 
2
strstr : if : 		} : 
2
strstr : for : 		} : 
2
strstr : while : 		} : 
2
str : 		migrate_tasks(cpu);[21]
strstr : INIT : 		migrate_tasks(cpu); : 
2
strstr : if : 		migrate_tasks(cpu); : 
2
strstr : for : 		migrate_tasks(cpu); : 
2
strstr : while : 		migrate_tasks(cpu); : 
2
str : 		BUG_ON(rq->nr_running != 1); /* the migration thread */[57]
strstr : INIT : 		BUG_ON(rq->nr_running != 1); /* the migration thread */ : 
2
strstr : if : 		BUG_ON(rq->nr_running != 1); /* the migration thread */ : 
2
strstr : for : 		BUG_ON(rq->nr_running != 1); /* the migration thread */ : 
2
strstr : while : 		BUG_ON(rq->nr_running != 1); /* the migration thread */ : 
2
str : 		raw_spin_unlock_irqrestore(&rq->lock, flags);[47]
strstr : INIT : 		raw_spin_unlock_irqrestore(&rq->lock, flags); : 
2
strstr : if : 		raw_spin_unlock_irqrestore(&rq->lock, flags); : 
2
strstr : for : 		raw_spin_unlock_irqrestore(&rq->lock, flags); : 
2
strstr : while : 		raw_spin_unlock_irqrestore(&rq->lock, flags); : 
2
str : 		break;[8]
strstr : INIT : 		break; : 
2
strstr : if : 		break; : 
2
strstr : for : 		break; : 
2
strstr : while : 		break; : 
2
str : 	case CPU_DEAD:[15]
strstr : INIT : 	case CPU_DEAD: : 
2
strstr : if : 	case CPU_DEAD: : 
2
strstr : for : 	case CPU_DEAD: : 
2
strstr : while : 	case CPU_DEAD: : 
2
str : 		calc_load_migrate(rq);[24]
strstr : INIT : 		calc_load_migrate(rq); : 
2
strstr : if : 		calc_load_migrate(rq); : 
2
strstr : for : 		calc_load_migrate(rq); : 
2
strstr : while : 		calc_load_migrate(rq); : 
2
str : 		break;[8]
strstr : INIT : 		break; : 
2
strstr : if : 		break; : 
2
strstr : for : 		break; : 
2
strstr : while : 		break; : 
2
str : #endif[6]
strstr : INIT : #endif : 
2
strstr : if : #endif : 
2
strstr : for : #endif : 
2
strstr : while : #endif : 
2
str : 	update_max_interval();[23]
strstr : INIT : 	update_max_interval(); : 
2
strstr : if : 	update_max_interval(); : 
2
strstr : for : 	update_max_interval(); : 
2
strstr : while : 	update_max_interval(); : 
2
str : 	return NOTIFY_OK;[18]
strstr : INIT : 	return NOTIFY_OK; : 
2
strstr : if : 	return NOTIFY_OK; : 
2
strstr : for : 	return NOTIFY_OK; : 
2
strstr : while : 	return NOTIFY_OK; : 
2
str :  * Register at high priority so that task migration (migrate_all_tasks)[71]
strstr : INIT :  * Register at high priority so that task migration (migrate_all_tasks) : 
2
strstr : if :  * Register at high priority so that task migration (migrate_all_tasks) : 
2
strstr : for :  * Register at high priority so that task migration (migrate_all_tasks) : 
2
strstr : while :  * Register at high priority so that task migration (migrate_all_tasks) : 
2
str :  * happens before everything else.  This has to be lower priority than[70]
strstr : INIT :  * happens before everything else.  This has to be lower priority than : 
2
strstr : if :  * happens before everything else.  This has to be lower priority than : 
2
strstr : for :  * happens before everything else.  This has to be lower priority than : 
2
strstr : while :  * happens before everything else.  This has to be lower priority than : 
2
str :  * the notifier in the perf_event subsystem, though.[52]
strstr : INIT :  * the notifier in the perf_event subsystem, though. : 
2
strstr : if :  * the notifier in the perf_event subsystem, though. : 
2
strstr : for :  * the notifier in the perf_event subsystem, though. : 
2
strstr : while :  * the notifier in the perf_event subsystem, though. : 
2
str :  */[3]
strstr : INIT :  */ : 
2
strstr : if :  */ : 
2
strstr : for :  */ : 
2
strstr : while :  */ : 
2
str : static struct notifier_block migration_notifier = {[51]
strstr : INIT : static struct notifier_block migration_notifier = { : 
2
strstr : if : static struct notifier_block migration_notifier = { : 
2
strstr : for : static struct notifier_block migration_notifier = { : 
2
strstr : while : static struct notifier_block migration_notifier = { : 
2
str : 	.notifier_call = migration_call,[33]
strstr : INIT : 	.notifier_call = migration_call, : 
2
strstr : if : 	.notifier_call = migration_call, : 
2
strstr : for : 	.notifier_call = migration_call, : 
2
strstr : while : 	.notifier_call = migration_call, : 
2
str : 	.priority = CPU_PRI_MIGRATION,[31]
strstr : INIT : 	.priority = CPU_PRI_MIGRATION, : 
2
strstr : if : 	.priority = CPU_PRI_MIGRATION, : 
2
strstr : for : 	.priority = CPU_PRI_MIGRATION, : 
2
strstr : while : 	.priority = CPU_PRI_MIGRATION, : 
2
str : static int sched_cpu_active(struct notifier_block *nfb,[55]
strstr : INIT : static int sched_cpu_active(struct notifier_block *nfb, : 
2
strstr : if : static int sched_cpu_active(struct notifier_block *nfb, : 
2
strstr : for : static int sched_cpu_active(struct notifier_block *nfb, : 
2
strstr : while : static int sched_cpu_active(struct notifier_block *nfb, : 
2
str : 				      unsigned long action, void *hcpu)[43]
strstr : INIT : 				      unsigned long action, void *hcpu) : 
2
strstr : if : 				      unsigned long action, void *hcpu) : 
2
strstr : for : 				      unsigned long action, void *hcpu) : 
2
strstr : while : 				      unsigned long action, void *hcpu) : 
2
str : 	switch (action & ~CPU_TASKS_FROZEN) {[38]
strstr : INIT : 	switch (action & ~CPU_TASKS_FROZEN) { : 
2
strstr : if : 	switch (action & ~CPU_TASKS_FROZEN) { : 
2
strstr : for : 	switch (action & ~CPU_TASKS_FROZEN) { : 
2
strstr : while : 	switch (action & ~CPU_TASKS_FROZEN) { : 
2
str : 	case CPU_DOWN_FAILED:[22]
strstr : INIT : 	case CPU_DOWN_FAILED: : 
2
strstr : if : 	case CPU_DOWN_FAILED: : 
2
strstr : for : 	case CPU_DOWN_FAILED: : 
2
strstr : while : 	case CPU_DOWN_FAILED: : 
2
str : 		set_cpu_active((long)hcpu, true);[35]
strstr : INIT : 		set_cpu_active((long)hcpu, true); : 
2
strstr : if : 		set_cpu_active((long)hcpu, true); : 
2
strstr : for : 		set_cpu_active((long)hcpu, true); : 
2
strstr : while : 		set_cpu_active((long)hcpu, true); : 
2
str : 		return NOTIFY_OK;[19]
strstr : INIT : 		return NOTIFY_OK; : 
2
strstr : if : 		return NOTIFY_OK; : 
2
strstr : for : 		return NOTIFY_OK; : 
2
strstr : while : 		return NOTIFY_OK; : 
2
str : 	default:[9]
strstr : INIT : 	default: : 
2
strstr : if : 	default: : 
2
strstr : for : 	default: : 
2
strstr : while : 	default: : 
2
str : 		return NOTIFY_DONE;[21]
strstr : INIT : 		return NOTIFY_DONE; : 
2
strstr : if : 		return NOTIFY_DONE; : 
2
strstr : for : 		return NOTIFY_DONE; : 
2
strstr : while : 		return NOTIFY_DONE; : 
2
str : static int sched_cpu_inactive(struct notifier_block *nfb,[57]
strstr : INIT : static int sched_cpu_inactive(struct notifier_block *nfb, : 
2
strstr : if : static int sched_cpu_inactive(struct notifier_block *nfb, : 
2
strstr : for : static int sched_cpu_inactive(struct notifier_block *nfb, : 
2
strstr : while : static int sched_cpu_inactive(struct notifier_block *nfb, : 
2
str : 					unsigned long action, void *hcpu)[38]
strstr : INIT : 					unsigned long action, void *hcpu) : 
2
strstr : if : 					unsigned long action, void *hcpu) : 
2
strstr : for : 					unsigned long action, void *hcpu) : 
2
strstr : while : 					unsigned long action, void *hcpu) : 
2
str : 	unsigned long flags;[21]
strstr : INIT : 	unsigned long flags; : 
2
strstr : if : 	unsigned long flags; : 
2
strstr : for : 	unsigned long flags; : 
2
strstr : while : 	unsigned long flags; : 
2
str : 	long cpu = (long)hcpu;[23]
strstr : INIT : 	long cpu = (long)hcpu; : 
2
strstr : if : 	long cpu = (long)hcpu; : 
2
strstr : for : 	long cpu = (long)hcpu; : 
2
strstr : while : 	long cpu = (long)hcpu; : 
2
str : 	switch (action & ~CPU_TASKS_FROZEN) {[38]
strstr : INIT : 	switch (action & ~CPU_TASKS_FROZEN) { : 
2
strstr : if : 	switch (action & ~CPU_TASKS_FROZEN) { : 
2
strstr : for : 	switch (action & ~CPU_TASKS_FROZEN) { : 
2
strstr : while : 	switch (action & ~CPU_TASKS_FROZEN) { : 
2
str : 	case CPU_DOWN_PREPARE:[23]
strstr : INIT : 	case CPU_DOWN_PREPARE: : 
2
strstr : if : 	case CPU_DOWN_PREPARE: : 
2
strstr : for : 	case CPU_DOWN_PREPARE: : 
2
strstr : while : 	case CPU_DOWN_PREPARE: : 
2
str : 		set_cpu_active(cpu, false);[29]
strstr : INIT : 		set_cpu_active(cpu, false); : 
2
strstr : if : 		set_cpu_active(cpu, false); : 
2
strstr : for : 		set_cpu_active(cpu, false); : 
2
strstr : while : 		set_cpu_active(cpu, false); : 
2
str : 		/* explicitly allow suspend */[32]
strstr : INIT : 		/* explicitly allow suspend */ : 
2
strstr : if : 		/* explicitly allow suspend */ : 
2
strstr : for : 		/* explicitly allow suspend */ : 
2
strstr : while : 		/* explicitly allow suspend */ : 
2
str : 		if (!(action & CPU_TASKS_FROZEN)) {[37]
strstr : INIT : 		if (!(action & CPU_TASKS_FROZEN)) { : 
2
strstr : if : 		if (!(action & CPU_TASKS_FROZEN)) { : 
2
strstr : for : 		if (!(action & CPU_TASKS_FROZEN)) { : 
2
strstr : while : 		if (!(action & CPU_TASKS_FROZEN)) { : 
2
str : 			struct dl_bw *dl_b = dl_bw_of(cpu);[38]
strstr : INIT : 			struct dl_bw *dl_b = dl_bw_of(cpu); : 
2
strstr : if : 			struct dl_bw *dl_b = dl_bw_of(cpu); : 
2
strstr : for : 			struct dl_bw *dl_b = dl_bw_of(cpu); : 
2
strstr : while : 			struct dl_bw *dl_b = dl_bw_of(cpu); : 
2
str : 			bool overflow;[17]
strstr : INIT : 			bool overflow; : 
2
strstr : if : 			bool overflow; : 
2
strstr : for : 			bool overflow; : 
2
strstr : while : 			bool overflow; : 
2
str : 			int cpus;[12]
strstr : INIT : 			int cpus; : 
2
strstr : if : 			int cpus; : 
2
strstr : for : 			int cpus; : 
2
strstr : while : 			int cpus; : 
2
str : 			raw_spin_lock_irqsave(&dl_b->lock, flags);[45]
strstr : INIT : 			raw_spin_lock_irqsave(&dl_b->lock, flags); : 
2
strstr : if : 			raw_spin_lock_irqsave(&dl_b->lock, flags); : 
2
strstr : for : 			raw_spin_lock_irqsave(&dl_b->lock, flags); : 
2
strstr : while : 			raw_spin_lock_irqsave(&dl_b->lock, flags); : 
2
str : 			cpus = dl_bw_cpus(cpu);[26]
strstr : INIT : 			cpus = dl_bw_cpus(cpu); : 
2
strstr : if : 			cpus = dl_bw_cpus(cpu); : 
2
strstr : for : 			cpus = dl_bw_cpus(cpu); : 
2
strstr : while : 			cpus = dl_bw_cpus(cpu); : 
2
str : 			overflow = __dl_overflow(dl_b, cpus, 0, 0);[46]
strstr : INIT : 			overflow = __dl_overflow(dl_b, cpus, 0, 0); : 
2
strstr : if : 			overflow = __dl_overflow(dl_b, cpus, 0, 0); : 
2
strstr : for : 			overflow = __dl_overflow(dl_b, cpus, 0, 0); : 
2
strstr : while : 			overflow = __dl_overflow(dl_b, cpus, 0, 0); : 
2
str : 			raw_spin_unlock_irqrestore(&dl_b->lock, flags);[50]
strstr : INIT : 			raw_spin_unlock_irqrestore(&dl_b->lock, flags); : 
2
strstr : if : 			raw_spin_unlock_irqrestore(&dl_b->lock, flags); : 
2
strstr : for : 			raw_spin_unlock_irqrestore(&dl_b->lock, flags); : 
2
strstr : while : 			raw_spin_unlock_irqrestore(&dl_b->lock, flags); : 
2
str : 			if (overflow)[16]
strstr : INIT : 			if (overflow) : 
2
strstr : if : 			if (overflow) : 
2
strstr : for : 			if (overflow) : 
2
strstr : while : 			if (overflow) : 
2
str : 				return notifier_from_errno(-EBUSY);[39]
strstr : INIT : 				return notifier_from_errno(-EBUSY); : 
2
strstr : if : 				return notifier_from_errno(-EBUSY); : 
2
strstr : for : 				return notifier_from_errno(-EBUSY); : 
2
strstr : while : 				return notifier_from_errno(-EBUSY); : 
2
str : 		}[3]
strstr : INIT : 		} : 
2
strstr : if : 		} : 
2
strstr : for : 		} : 
2
strstr : while : 		} : 
2
str : 		return NOTIFY_OK;[19]
strstr : INIT : 		return NOTIFY_OK; : 
2
strstr : if : 		return NOTIFY_OK; : 
2
strstr : for : 		return NOTIFY_OK; : 
2
strstr : while : 		return NOTIFY_OK; : 
2
str : 	return NOTIFY_DONE;[20]
strstr : INIT : 	return NOTIFY_DONE; : 
2
strstr : if : 	return NOTIFY_DONE; : 
2
strstr : for : 	return NOTIFY_DONE; : 
2
strstr : while : 	return NOTIFY_DONE; : 
2
str : static int __init migration_init(void)[38]
strstr : INIT : static int __init migration_init(void) : 
2
strstr : if : static int __init migration_init(void) : 
2
strstr : for : static int __init migration_init(void) : 
2
strstr : while : static int __init migration_init(void) : 
2
str : 	void *cpu = (void *)(long)smp_processor_id();[46]
strstr : INIT : 	void *cpu = (void *)(long)smp_processor_id(); : 
2
strstr : if : 	void *cpu = (void *)(long)smp_processor_id(); : 
2
strstr : for : 	void *cpu = (void *)(long)smp_processor_id(); : 
2
strstr : while : 	void *cpu = (void *)(long)smp_processor_id(); : 
2
str : 	int err;[9]
strstr : INIT : 	int err; : 
2
strstr : if : 	int err; : 
2
strstr : for : 	int err; : 
2
strstr : while : 	int err; : 
2
str : 	/* Initialize migration for the boot CPU */[44]
strstr : INIT : 	/* Initialize migration for the boot CPU */ : 
2
strstr : if : 	/* Initialize migration for the boot CPU */ : 
2
strstr : for : 	/* Initialize migration for the boot CPU */ : 
2
strstr : while : 	/* Initialize migration for the boot CPU */ : 
2
str : 	err = migration_call(&migration_notifier, CPU_UP_PREPARE, cpu);[64]
strstr : INIT : 	err = migration_call(&migration_notifier, CPU_UP_PREPARE, cpu); : 
2
strstr : if : 	err = migration_call(&migration_notifier, CPU_UP_PREPARE, cpu); : 
2
strstr : for : 	err = migration_call(&migration_notifier, CPU_UP_PREPARE, cpu); : 
2
strstr : while : 	err = migration_call(&migration_notifier, CPU_UP_PREPARE, cpu); : 
2
str : 	BUG_ON(err == NOTIFY_BAD);[27]
strstr : INIT : 	BUG_ON(err == NOTIFY_BAD); : 
2
strstr : if : 	BUG_ON(err == NOTIFY_BAD); : 
2
strstr : for : 	BUG_ON(err == NOTIFY_BAD); : 
2
strstr : while : 	BUG_ON(err == NOTIFY_BAD); : 
2
str : 	migration_call(&migration_notifier, CPU_ONLINE, cpu);[54]
strstr : INIT : 	migration_call(&migration_notifier, CPU_ONLINE, cpu); : 
2
strstr : if : 	migration_call(&migration_notifier, CPU_ONLINE, cpu); : 
2
strstr : for : 	migration_call(&migration_notifier, CPU_ONLINE, cpu); : 
2
strstr : while : 	migration_call(&migration_notifier, CPU_ONLINE, cpu); : 
2
str : 	register_cpu_notifier(&migration_notifier);[44]
strstr : INIT : 	register_cpu_notifier(&migration_notifier); : 
2
strstr : if : 	register_cpu_notifier(&migration_notifier); : 
2
strstr : for : 	register_cpu_notifier(&migration_notifier); : 
2
strstr : while : 	register_cpu_notifier(&migration_notifier); : 
2
str : 	/* Register cpu active notifiers */[36]
strstr : INIT : 	/* Register cpu active notifiers */ : 
2
strstr : if : 	/* Register cpu active notifiers */ : 
2
strstr : for : 	/* Register cpu active notifiers */ : 
2
strstr : while : 	/* Register cpu active notifiers */ : 
2
str : 	cpu_notifier(sched_cpu_active, CPU_PRI_SCHED_ACTIVE);[54]
strstr : INIT : 	cpu_notifier(sched_cpu_active, CPU_PRI_SCHED_ACTIVE); : 
2
strstr : if : 	cpu_notifier(sched_cpu_active, CPU_PRI_SCHED_ACTIVE); : 
2
strstr : for : 	cpu_notifier(sched_cpu_active, CPU_PRI_SCHED_ACTIVE); : 
2
strstr : while : 	cpu_notifier(sched_cpu_active, CPU_PRI_SCHED_ACTIVE); : 
2
str : 	cpu_notifier(sched_cpu_inactive, CPU_PRI_SCHED_INACTIVE);[58]
strstr : INIT : 	cpu_notifier(sched_cpu_inactive, CPU_PRI_SCHED_INACTIVE); : 
2
strstr : if : 	cpu_notifier(sched_cpu_inactive, CPU_PRI_SCHED_INACTIVE); : 
2
strstr : for : 	cpu_notifier(sched_cpu_inactive, CPU_PRI_SCHED_INACTIVE); : 
2
strstr : while : 	cpu_notifier(sched_cpu_inactive, CPU_PRI_SCHED_INACTIVE); : 
2
str : 	return 0;[10]
strstr : INIT : 	return 0; : 
2
strstr : if : 	return 0; : 
2
strstr : for : 	return 0; : 
2
strstr : while : 	return 0; : 
2
str : early_initcall(migration_init);[31]
strstr : INIT : early_initcall(migration_init); : 
2
strstr : if : early_initcall(migration_init); : 
2
strstr : for : early_initcall(migration_init); : 
2
strstr : while : early_initcall(migration_init); : 
2
str : #endif[6]
strstr : INIT : #endif : 
2
strstr : if : #endif : 
2
strstr : for : #endif : 
2
strstr : while : #endif : 
2
str : #ifdef CONFIG_SMP[17]
strstr : INIT : #ifdef CONFIG_SMP : 
2
strstr : if : #ifdef CONFIG_SMP : 
2
strstr : for : #ifdef CONFIG_SMP : 
2
strstr : while : #ifdef CONFIG_SMP : 
2
str : static cpumask_var_t sched_domains_tmpmask; /* sched_domains_mutex */[69]
strstr : INIT : static cpumask_var_t sched_domains_tmpmask; /* sched_domains_mutex */ : 
2
strstr : if : static cpumask_var_t sched_domains_tmpmask; /* sched_domains_mutex */ : 
2
strstr : for : static cpumask_var_t sched_domains_tmpmask; /* sched_domains_mutex */ : 
2
strstr : while : static cpumask_var_t sched_domains_tmpmask; /* sched_domains_mutex */ : 
2
str : #ifdef CONFIG_SCHED_DEBUG[25]
strstr : INIT : #ifdef CONFIG_SCHED_DEBUG : 
2
strstr : if : #ifdef CONFIG_SCHED_DEBUG : 
2
strstr : for : #ifdef CONFIG_SCHED_DEBUG : 
2
strstr : while : #ifdef CONFIG_SCHED_DEBUG : 
2
str : static __read_mostly int sched_debug_enabled;[45]
strstr : INIT : static __read_mostly int sched_debug_enabled; : 
2
strstr : if : static __read_mostly int sched_debug_enabled; : 
2
strstr : for : static __read_mostly int sched_debug_enabled; : 
2
strstr : while : static __read_mostly int sched_debug_enabled; : 
2
str : static int __init sched_debug_setup(char *str)[46]
strstr : INIT : static int __init sched_debug_setup(char *str) : 
2
strstr : if : static int __init sched_debug_setup(char *str) : 
2
strstr : for : static int __init sched_debug_setup(char *str) : 
2
strstr : while : static int __init sched_debug_setup(char *str) : 
2
str : 	sched_debug_enabled = 1;[25]
strstr : INIT : 	sched_debug_enabled = 1; : 
2
strstr : if : 	sched_debug_enabled = 1; : 
2
strstr : for : 	sched_debug_enabled = 1; : 
2
strstr : while : 	sched_debug_enabled = 1; : 
2
str : 	return 0;[10]
strstr : INIT : 	return 0; : 
2
strstr : if : 	return 0; : 
2
strstr : for : 	return 0; : 
2
strstr : while : 	return 0; : 
2
str : early_param("sched_debug", sched_debug_setup);[46]
strstr : INIT : early_param("sched_debug", sched_debug_setup); : 
2
strstr : if : early_param("sched_debug", sched_debug_setup); : 
2
strstr : for : early_param("sched_debug", sched_debug_setup); : 
2
strstr : while : early_param("sched_debug", sched_debug_setup); : 
2
str : static inline bool sched_debug(void)[36]
strstr : INIT : static inline bool sched_debug(void) : 
2
strstr : if : static inline bool sched_debug(void) : 
2
strstr : for : static inline bool sched_debug(void) : 
2
strstr : while : static inline bool sched_debug(void) : 
2
str : 	return sched_debug_enabled;[28]
strstr : INIT : 	return sched_debug_enabled; : 
2
strstr : if : 	return sched_debug_enabled; : 
2
strstr : for : 	return sched_debug_enabled; : 
2
strstr : while : 	return sched_debug_enabled; : 
2
str : static int sched_domain_debug_one(struct sched_domain *sd, int cpu, int level,[78]
strstr : INIT : static int sched_domain_debug_one(struct sched_domain *sd, int cpu, int level, : 
2
strstr : if : static int sched_domain_debug_one(struct sched_domain *sd, int cpu, int level, : 
2
strstr : for : static int sched_domain_debug_one(struct sched_domain *sd, int cpu, int level, : 
2
strstr : while : static int sched_domain_debug_one(struct sched_domain *sd, int cpu, int level, : 
2
str : 				  struct cpumask *groupmask)[32]
strstr : INIT : 				  struct cpumask *groupmask) : 
2
strstr : if : 				  struct cpumask *groupmask) : 
2
strstr : for : 				  struct cpumask *groupmask) : 
2
strstr : while : 				  struct cpumask *groupmask) : 
2
str : 	struct sched_group *group = sd->groups;[40]
strstr : INIT : 	struct sched_group *group = sd->groups; : 
2
strstr : if : 	struct sched_group *group = sd->groups; : 
2
strstr : for : 	struct sched_group *group = sd->groups; : 
2
strstr : while : 	struct sched_group *group = sd->groups; : 
2
str : 	char str[256];[15]
strstr : INIT : 	char str[256]; : 
2
strstr : if : 	char str[256]; : 
2
strstr : for : 	char str[256]; : 
2
strstr : while : 	char str[256]; : 
2
str : 	cpulist_scnprintf(str, sizeof(str), sched_domain_span(sd));[60]
strstr : INIT : 	cpulist_scnprintf(str, sizeof(str), sched_domain_span(sd)); : 
2
strstr : if : 	cpulist_scnprintf(str, sizeof(str), sched_domain_span(sd)); : 
2
strstr : for : 	cpulist_scnprintf(str, sizeof(str), sched_domain_span(sd)); : 
2
strstr : while : 	cpulist_scnprintf(str, sizeof(str), sched_domain_span(sd)); : 
2
str : 	cpumask_clear(groupmask);[26]
strstr : INIT : 	cpumask_clear(groupmask); : 
2
strstr : if : 	cpumask_clear(groupmask); : 
2
strstr : for : 	cpumask_clear(groupmask); : 
2
strstr : while : 	cpumask_clear(groupmask); : 
2
str : 	printk(KERN_DEBUG "%*s domain %d: ", level, "", level);[56]
strstr : INIT : 	printk(KERN_DEBUG "%*s domain %d: ", level, "", level); : 
2
strstr : if : 	printk(KERN_DEBUG "%*s domain %d: ", level, "", level); : 
2
strstr : for : 	printk(KERN_DEBUG "%*s domain %d: ", level, "", level); : 
2
strstr : while : 	printk(KERN_DEBUG "%*s domain %d: ", level, "", level); : 
2
str : 	if (!(sd->flags & SD_LOAD_BALANCE)) {[38]
strstr : INIT : 	if (!(sd->flags & SD_LOAD_BALANCE)) { : 
2
strstr : if : 	if (!(sd->flags & SD_LOAD_BALANCE)) { : 
2
strstr : for : 	if (!(sd->flags & SD_LOAD_BALANCE)) { : 
2
strstr : while : 	if (!(sd->flags & SD_LOAD_BALANCE)) { : 
2
str : 		printk("does not load-balance\n");[36]
strstr : INIT : 		printk("does not load-balance\n"); : 
2
strstr : if : 		printk("does not load-balance\n"); : 
2
strstr : for : 		printk("does not load-balance\n"); : 
2
strstr : while : 		printk("does not load-balance\n"); : 
2
str : 		if (sd->parent)[17]
strstr : INIT : 		if (sd->parent) : 
2
strstr : if : 		if (sd->parent) : 
2
strstr : for : 		if (sd->parent) : 
2
strstr : while : 		if (sd->parent) : 
2
str : 			printk(KERN_ERR "ERROR: !SD_LOAD_BALANCE domain"[51]
strstr : INIT : 			printk(KERN_ERR "ERROR: !SD_LOAD_BALANCE domain" : 
2
strstr : if : 			printk(KERN_ERR "ERROR: !SD_LOAD_BALANCE domain" : 
2
strstr : for : 			printk(KERN_ERR "ERROR: !SD_LOAD_BALANCE domain" : 
2
strstr : while : 			printk(KERN_ERR "ERROR: !SD_LOAD_BALANCE domain" : 
2
str : 					" has parent");[20]
strstr : INIT : 					" has parent"); : 
2
strstr : if : 					" has parent"); : 
2
strstr : for : 					" has parent"); : 
2
strstr : while : 					" has parent"); : 
2
str : 		return -1;[12]
strstr : INIT : 		return -1; : 
2
strstr : if : 		return -1; : 
2
strstr : for : 		return -1; : 
2
strstr : while : 		return -1; : 
2
str : 	printk(KERN_CONT "span %s level %s\n", str, sd->name);[55]
strstr : INIT : 	printk(KERN_CONT "span %s level %s\n", str, sd->name); : 
2
strstr : if : 	printk(KERN_CONT "span %s level %s\n", str, sd->name); : 
2
strstr : for : 	printk(KERN_CONT "span %s level %s\n", str, sd->name); : 
2
strstr : while : 	printk(KERN_CONT "span %s level %s\n", str, sd->name); : 
2
str : 	if (!cpumask_test_cpu(cpu, sched_domain_span(sd))) {[53]
strstr : INIT : 	if (!cpumask_test_cpu(cpu, sched_domain_span(sd))) { : 
2
strstr : if : 	if (!cpumask_test_cpu(cpu, sched_domain_span(sd))) { : 
2
strstr : for : 	if (!cpumask_test_cpu(cpu, sched_domain_span(sd))) { : 
2
strstr : while : 	if (!cpumask_test_cpu(cpu, sched_domain_span(sd))) { : 
2
str : 		printk(KERN_ERR "ERROR: domain->span does not contain "[57]
strstr : INIT : 		printk(KERN_ERR "ERROR: domain->span does not contain " : 
2
strstr : if : 		printk(KERN_ERR "ERROR: domain->span does not contain " : 
2
strstr : for : 		printk(KERN_ERR "ERROR: domain->span does not contain " : 
2
strstr : while : 		printk(KERN_ERR "ERROR: domain->span does not contain " : 
2
str : 				"CPU%d\n", cpu);[20]
strstr : INIT : 				"CPU%d\n", cpu); : 
2
strstr : if : 				"CPU%d\n", cpu); : 
2
strstr : for : 				"CPU%d\n", cpu); : 
2
strstr : while : 				"CPU%d\n", cpu); : 
2
str : 	if (!cpumask_test_cpu(cpu, sched_group_cpus(group))) {[55]
strstr : INIT : 	if (!cpumask_test_cpu(cpu, sched_group_cpus(group))) { : 
2
strstr : if : 	if (!cpumask_test_cpu(cpu, sched_group_cpus(group))) { : 
2
strstr : for : 	if (!cpumask_test_cpu(cpu, sched_group_cpus(group))) { : 
2
strstr : while : 	if (!cpumask_test_cpu(cpu, sched_group_cpus(group))) { : 
2
str : 		printk(KERN_ERR "ERROR: domain->groups does not contain"[58]
strstr : INIT : 		printk(KERN_ERR "ERROR: domain->groups does not contain" : 
2
strstr : if : 		printk(KERN_ERR "ERROR: domain->groups does not contain" : 
2
strstr : for : 		printk(KERN_ERR "ERROR: domain->groups does not contain" : 
2
strstr : while : 		printk(KERN_ERR "ERROR: domain->groups does not contain" : 
2
str : 				" CPU%d\n", cpu);[21]
strstr : INIT : 				" CPU%d\n", cpu); : 
2
strstr : if : 				" CPU%d\n", cpu); : 
2
strstr : for : 				" CPU%d\n", cpu); : 
2
strstr : while : 				" CPU%d\n", cpu); : 
2
str : 	printk(KERN_DEBUG "%*s groups:", level + 1, "");[49]
strstr : INIT : 	printk(KERN_DEBUG "%*s groups:", level + 1, ""); : 
2
strstr : if : 	printk(KERN_DEBUG "%*s groups:", level + 1, ""); : 
2
strstr : for : 	printk(KERN_DEBUG "%*s groups:", level + 1, ""); : 
2
strstr : while : 	printk(KERN_DEBUG "%*s groups:", level + 1, ""); : 
2
str : 	do {[5]
strstr : INIT : 	do { : 
2
strstr : if : 	do { : 
2
strstr : for : 	do { : 
2
strstr : while : 	do { : 
2
str : 		if (!group) {[15]
strstr : INIT : 		if (!group) { : 
2
strstr : if : 		if (!group) { : 
2
strstr : for : 		if (!group) { : 
2
strstr : while : 		if (!group) { : 
2
str : 			printk("\n");[16]
strstr : INIT : 			printk("\n"); : 
2
strstr : if : 			printk("\n"); : 
2
strstr : for : 			printk("\n"); : 
2
strstr : while : 			printk("\n"); : 
2
str : 			printk(KERN_ERR "ERROR: group is NULL\n");[45]
strstr : INIT : 			printk(KERN_ERR "ERROR: group is NULL\n"); : 
2
strstr : if : 			printk(KERN_ERR "ERROR: group is NULL\n"); : 
2
strstr : for : 			printk(KERN_ERR "ERROR: group is NULL\n"); : 
2
strstr : while : 			printk(KERN_ERR "ERROR: group is NULL\n"); : 
2
str : 			break;[9]
strstr : INIT : 			break; : 
2
strstr : if : 			break; : 
2
strstr : for : 			break; : 
2
strstr : while : 			break; : 
2
str : 		}[3]
strstr : INIT : 		} : 
2
strstr : if : 		} : 
2
strstr : for : 		} : 
2
strstr : while : 		} : 
2
str : 		/*[4]
strstr : INIT : 		/* : 
2
strstr : if : 		/* : 
2
strstr : for : 		/* : 
2
strstr : while : 		/* : 
2
str : 		 * Even though we initialize ->power to something semi-sane,[62]
strstr : INIT : 		 * Even though we initialize ->power to something semi-sane, : 
2
strstr : if : 		 * Even though we initialize ->power to something semi-sane, : 
2
strstr : for : 		 * Even though we initialize ->power to something semi-sane, : 
2
strstr : while : 		 * Even though we initialize ->power to something semi-sane, : 
2
str : 		 * we leave power_orig unset. This allows us to detect if[59]
strstr : INIT : 		 * we leave power_orig unset. This allows us to detect if : 
2
strstr : if : 		 * we leave power_orig unset. This allows us to detect if : 
2
strstr : for : 		 * we leave power_orig unset. This allows us to detect if : 
2
strstr : while : 		 * we leave power_orig unset. This allows us to detect if : 
2
str : 		 * domain iteration is still funny without causing /0 traps.[62]
strstr : INIT : 		 * domain iteration is still funny without causing /0 traps. : 
2
strstr : if : 		 * domain iteration is still funny without causing /0 traps. : 
2
strstr : for : 		 * domain iteration is still funny without causing /0 traps. : 
2
strstr : while : 		 * domain iteration is still funny without causing /0 traps. : 
2
str : 		 */[5]
strstr : INIT : 		 */ : 
2
strstr : if : 		 */ : 
2
strstr : for : 		 */ : 
2
strstr : while : 		 */ : 
2
str : 		if (!group->sgp->power_orig) {[32]
strstr : INIT : 		if (!group->sgp->power_orig) { : 
2
strstr : if : 		if (!group->sgp->power_orig) { : 
2
strstr : for : 		if (!group->sgp->power_orig) { : 
2
strstr : while : 		if (!group->sgp->power_orig) { : 
2
str : 			printk(KERN_CONT "\n");[26]
strstr : INIT : 			printk(KERN_CONT "\n"); : 
2
strstr : if : 			printk(KERN_CONT "\n"); : 
2
strstr : for : 			printk(KERN_CONT "\n"); : 
2
strstr : while : 			printk(KERN_CONT "\n"); : 
2
str : 			printk(KERN_ERR "ERROR: domain->cpu_power not "[50]
strstr : INIT : 			printk(KERN_ERR "ERROR: domain->cpu_power not " : 
2
strstr : if : 			printk(KERN_ERR "ERROR: domain->cpu_power not " : 
2
strstr : for : 			printk(KERN_ERR "ERROR: domain->cpu_power not " : 
2
strstr : while : 			printk(KERN_ERR "ERROR: domain->cpu_power not " : 
2
str : 					"set\n");[14]
strstr : INIT : 					"set\n"); : 
2
strstr : if : 					"set\n"); : 
2
strstr : for : 					"set\n"); : 
2
strstr : while : 					"set\n"); : 
2
str : 			break;[9]
strstr : INIT : 			break; : 
2
strstr : if : 			break; : 
2
strstr : for : 			break; : 
2
strstr : while : 			break; : 
2
str : 		}[3]
strstr : INIT : 		} : 
2
strstr : if : 		} : 
2
strstr : for : 		} : 
2
strstr : while : 		} : 
2
str : 		if (!cpumask_weight(sched_group_cpus(group))) {[49]
strstr : INIT : 		if (!cpumask_weight(sched_group_cpus(group))) { : 
2
strstr : if : 		if (!cpumask_weight(sched_group_cpus(group))) { : 
2
strstr : for : 		if (!cpumask_weight(sched_group_cpus(group))) { : 
2
strstr : while : 		if (!cpumask_weight(sched_group_cpus(group))) { : 
2
str : 			printk(KERN_CONT "\n");[26]
strstr : INIT : 			printk(KERN_CONT "\n"); : 
2
strstr : if : 			printk(KERN_CONT "\n"); : 
2
strstr : for : 			printk(KERN_CONT "\n"); : 
2
strstr : while : 			printk(KERN_CONT "\n"); : 
2
str : 			printk(KERN_ERR "ERROR: empty group\n");[43]
strstr : INIT : 			printk(KERN_ERR "ERROR: empty group\n"); : 
2
strstr : if : 			printk(KERN_ERR "ERROR: empty group\n"); : 
2
strstr : for : 			printk(KERN_ERR "ERROR: empty group\n"); : 
2
strstr : while : 			printk(KERN_ERR "ERROR: empty group\n"); : 
2
str : 			break;[9]
strstr : INIT : 			break; : 
2
strstr : if : 			break; : 
2
strstr : for : 			break; : 
2
strstr : while : 			break; : 
2
str : 		}[3]
strstr : INIT : 		} : 
2
strstr : if : 		} : 
2
strstr : for : 		} : 
2
strstr : while : 		} : 
2
str : 		if (!(sd->flags & SD_OVERLAP) &&[34]
strstr : INIT : 		if (!(sd->flags & SD_OVERLAP) && : 
2
strstr : if : 		if (!(sd->flags & SD_OVERLAP) && : 
2
strstr : for : 		if (!(sd->flags & SD_OVERLAP) && : 
2
strstr : while : 		if (!(sd->flags & SD_OVERLAP) && : 
2
str : 		    cpumask_intersects(groupmask, sched_group_cpus(group))) {[63]
strstr : INIT : 		    cpumask_intersects(groupmask, sched_group_cpus(group))) { : 
2
strstr : if : 		    cpumask_intersects(groupmask, sched_group_cpus(group))) { : 
2
strstr : for : 		    cpumask_intersects(groupmask, sched_group_cpus(group))) { : 
2
strstr : while : 		    cpumask_intersects(groupmask, sched_group_cpus(group))) { : 
2
str : 			printk(KERN_CONT "\n");[26]
strstr : INIT : 			printk(KERN_CONT "\n"); : 
2
strstr : if : 			printk(KERN_CONT "\n"); : 
2
strstr : for : 			printk(KERN_CONT "\n"); : 
2
strstr : while : 			printk(KERN_CONT "\n"); : 
2
str : 			printk(KERN_ERR "ERROR: repeated CPUs\n");[45]
strstr : INIT : 			printk(KERN_ERR "ERROR: repeated CPUs\n"); : 
2
strstr : if : 			printk(KERN_ERR "ERROR: repeated CPUs\n"); : 
2
strstr : for : 			printk(KERN_ERR "ERROR: repeated CPUs\n"); : 
2
strstr : while : 			printk(KERN_ERR "ERROR: repeated CPUs\n"); : 
2
str : 			break;[9]
strstr : INIT : 			break; : 
2
strstr : if : 			break; : 
2
strstr : for : 			break; : 
2
strstr : while : 			break; : 
2
str : 		}[3]
strstr : INIT : 		} : 
2
strstr : if : 		} : 
2
strstr : for : 		} : 
2
strstr : while : 		} : 
2
str : 		cpumask_or(groupmask, groupmask, sched_group_cpus(group));[60]
strstr : INIT : 		cpumask_or(groupmask, groupmask, sched_group_cpus(group)); : 
2
strstr : if : 		cpumask_or(groupmask, groupmask, sched_group_cpus(group)); : 
2
strstr : for : 		cpumask_or(groupmask, groupmask, sched_group_cpus(group)); : 
2
strstr : while : 		cpumask_or(groupmask, groupmask, sched_group_cpus(group)); : 
2
str : 		cpulist_scnprintf(str, sizeof(str), sched_group_cpus(group));[63]
strstr : INIT : 		cpulist_scnprintf(str, sizeof(str), sched_group_cpus(group)); : 
2
strstr : if : 		cpulist_scnprintf(str, sizeof(str), sched_group_cpus(group)); : 
2
strstr : for : 		cpulist_scnprintf(str, sizeof(str), sched_group_cpus(group)); : 
2
strstr : while : 		cpulist_scnprintf(str, sizeof(str), sched_group_cpus(group)); : 
2
str : 		printk(KERN_CONT " %s", str);[31]
strstr : INIT : 		printk(KERN_CONT " %s", str); : 
2
strstr : if : 		printk(KERN_CONT " %s", str); : 
2
strstr : for : 		printk(KERN_CONT " %s", str); : 
2
strstr : while : 		printk(KERN_CONT " %s", str); : 
2
str : 		if (group->sgp->power != SCHED_POWER_SCALE) {[47]
strstr : INIT : 		if (group->sgp->power != SCHED_POWER_SCALE) { : 
2
strstr : if : 		if (group->sgp->power != SCHED_POWER_SCALE) { : 
2
strstr : for : 		if (group->sgp->power != SCHED_POWER_SCALE) { : 
2
strstr : while : 		if (group->sgp->power != SCHED_POWER_SCALE) { : 
2
str : 			printk(KERN_CONT " (cpu_power = %d)",[40]
strstr : INIT : 			printk(KERN_CONT " (cpu_power = %d)", : 
2
strstr : if : 			printk(KERN_CONT " (cpu_power = %d)", : 
2
strstr : for : 			printk(KERN_CONT " (cpu_power = %d)", : 
2
strstr : while : 			printk(KERN_CONT " (cpu_power = %d)", : 
2
str : 				group->sgp->power);[23]
strstr : INIT : 				group->sgp->power); : 
2
strstr : if : 				group->sgp->power); : 
2
strstr : for : 				group->sgp->power); : 
2
strstr : while : 				group->sgp->power); : 
2
str : 		}[3]
strstr : INIT : 		} : 
2
strstr : if : 		} : 
2
strstr : for : 		} : 
2
strstr : while : 		} : 
2
str : 		group = group->next;[22]
strstr : INIT : 		group = group->next; : 
2
strstr : if : 		group = group->next; : 
2
strstr : for : 		group = group->next; : 
2
strstr : while : 		group = group->next; : 
2
str : 	} while (group != sd->groups);[31]
strstr : INIT : 	} while (group != sd->groups); : 
2
strstr : if : 	} while (group != sd->groups); : 
2
strstr : for : 	} while (group != sd->groups); : 
2
strstr : while : 	} while (group != sd->groups); : 
2
str : 	printk(KERN_CONT "\n");[24]
strstr : INIT : 	printk(KERN_CONT "\n"); : 
2
strstr : if : 	printk(KERN_CONT "\n"); : 
2
strstr : for : 	printk(KERN_CONT "\n"); : 
2
strstr : while : 	printk(KERN_CONT "\n"); : 
2
str : 	if (!cpumask_equal(sched_domain_span(sd), groupmask))[54]
strstr : INIT : 	if (!cpumask_equal(sched_domain_span(sd), groupmask)) : 
2
strstr : if : 	if (!cpumask_equal(sched_domain_span(sd), groupmask)) : 
2
strstr : for : 	if (!cpumask_equal(sched_domain_span(sd), groupmask)) : 
2
strstr : while : 	if (!cpumask_equal(sched_domain_span(sd), groupmask)) : 
2
str : 		printk(KERN_ERR "ERROR: groups don't span domain->span\n");[61]
strstr : INIT : 		printk(KERN_ERR "ERROR: groups don't span domain->span\n"); : 
2
strstr : if : 		printk(KERN_ERR "ERROR: groups don't span domain->span\n"); : 
2
strstr : for : 		printk(KERN_ERR "ERROR: groups don't span domain->span\n"); : 
2
strstr : while : 		printk(KERN_ERR "ERROR: groups don't span domain->span\n"); : 
2
str : 	if (sd->parent &&[18]
strstr : INIT : 	if (sd->parent && : 
2
strstr : if : 	if (sd->parent && : 
2
strstr : for : 	if (sd->parent && : 
2
strstr : while : 	if (sd->parent && : 
2
str : 	    !cpumask_subset(groupmask, sched_domain_span(sd->parent)))[63]
strstr : INIT : 	    !cpumask_subset(groupmask, sched_domain_span(sd->parent))) : 
2
strstr : if : 	    !cpumask_subset(groupmask, sched_domain_span(sd->parent))) : 
2
strstr : for : 	    !cpumask_subset(groupmask, sched_domain_span(sd->parent))) : 
2
strstr : while : 	    !cpumask_subset(groupmask, sched_domain_span(sd->parent))) : 
2
str : 		printk(KERN_ERR "ERROR: parent span is not a superset "[57]
strstr : INIT : 		printk(KERN_ERR "ERROR: parent span is not a superset " : 
2
strstr : if : 		printk(KERN_ERR "ERROR: parent span is not a superset " : 
2
strstr : for : 		printk(KERN_ERR "ERROR: parent span is not a superset " : 
2
strstr : while : 		printk(KERN_ERR "ERROR: parent span is not a superset " : 
2
str : 			"of domain->span\n");[24]
strstr : INIT : 			"of domain->span\n"); : 
2
strstr : if : 			"of domain->span\n"); : 
2
strstr : for : 			"of domain->span\n"); : 
2
strstr : while : 			"of domain->span\n"); : 
2
str : 	return 0;[10]
strstr : INIT : 	return 0; : 
2
strstr : if : 	return 0; : 
2
strstr : for : 	return 0; : 
2
strstr : while : 	return 0; : 
2
str : static void sched_domain_debug(struct sched_domain *sd, int cpu)[64]
strstr : INIT : static void sched_domain_debug(struct sched_domain *sd, int cpu) : 
2
strstr : if : static void sched_domain_debug(struct sched_domain *sd, int cpu) : 
2
strstr : for : static void sched_domain_debug(struct sched_domain *sd, int cpu) : 
2
strstr : while : static void sched_domain_debug(struct sched_domain *sd, int cpu) : 
2
str : 	int level = 0;[15]
strstr : INIT : 	int level = 0; : 
2
strstr : if : 	int level = 0; : 
2
strstr : for : 	int level = 0; : 
2
strstr : while : 	int level = 0; : 
2
str : 	if (!sched_debug_enabled)[26]
strstr : INIT : 	if (!sched_debug_enabled) : 
2
strstr : if : 	if (!sched_debug_enabled) : 
2
strstr : for : 	if (!sched_debug_enabled) : 
2
strstr : while : 	if (!sched_debug_enabled) : 
2
str : 		return;[9]
strstr : INIT : 		return; : 
2
strstr : if : 		return; : 
2
strstr : for : 		return; : 
2
strstr : while : 		return; : 
2
str : 	if (!sd) {[11]
strstr : INIT : 	if (!sd) { : 
2
strstr : if : 	if (!sd) { : 
2
strstr : for : 	if (!sd) { : 
2
strstr : while : 	if (!sd) { : 
2
str : 		printk(KERN_DEBUG "CPU%d attaching NULL sched-domain.\n", cpu);[65]
strstr : INIT : 		printk(KERN_DEBUG "CPU%d attaching NULL sched-domain.\n", cpu); : 
2
strstr : if : 		printk(KERN_DEBUG "CPU%d attaching NULL sched-domain.\n", cpu); : 
2
strstr : for : 		printk(KERN_DEBUG "CPU%d attaching NULL sched-domain.\n", cpu); : 
2
strstr : while : 		printk(KERN_DEBUG "CPU%d attaching NULL sched-domain.\n", cpu); : 
2
str : 		return;[9]
strstr : INIT : 		return; : 
2
strstr : if : 		return; : 
2
strstr : for : 		return; : 
2
strstr : while : 		return; : 
2
str : 	printk(KERN_DEBUG "CPU%d attaching sched-domain:\n", cpu);[59]
strstr : INIT : 	printk(KERN_DEBUG "CPU%d attaching sched-domain:\n", cpu); : 
2
strstr : if : 	printk(KERN_DEBUG "CPU%d attaching sched-domain:\n", cpu); : 
2
strstr : for : 	printk(KERN_DEBUG "CPU%d attaching sched-domain:\n", cpu); : 
2
strstr : while : 	printk(KERN_DEBUG "CPU%d attaching sched-domain:\n", cpu); : 
2
str : 	for (;;) {[11]
strstr : INIT : 	for (;;) { : 
2
strstr : if : 	for (;;) { : 
2
strstr : for : 	for (;;) { : 
2
strstr : while : 	for (;;) { : 
2
str : 		if (sched_domain_debug_one(sd, cpu, level, sched_domains_tmpmask))[68]
strstr : INIT : 		if (sched_domain_debug_one(sd, cpu, level, sched_domains_tmpmask)) : 
2
strstr : if : 		if (sched_domain_debug_one(sd, cpu, level, sched_domains_tmpmask)) : 
2
strstr : for : 		if (sched_domain_debug_one(sd, cpu, level, sched_domains_tmpmask)) : 
2
strstr : while : 		if (sched_domain_debug_one(sd, cpu, level, sched_domains_tmpmask)) : 
2
str : 			break;[9]
strstr : INIT : 			break; : 
2
strstr : if : 			break; : 
2
strstr : for : 			break; : 
2
strstr : while : 			break; : 
2
str : 		level++;[10]
strstr : INIT : 		level++; : 
2
strstr : if : 		level++; : 
2
strstr : for : 		level++; : 
2
strstr : while : 		level++; : 
2
str : 		sd = sd->parent;[18]
strstr : INIT : 		sd = sd->parent; : 
2
strstr : if : 		sd = sd->parent; : 
2
strstr : for : 		sd = sd->parent; : 
2
strstr : while : 		sd = sd->parent; : 
2
str : 		if (!sd)[10]
strstr : INIT : 		if (!sd) : 
2
strstr : if : 		if (!sd) : 
2
strstr : for : 		if (!sd) : 
2
strstr : while : 		if (!sd) : 
2
str : 			break;[9]
strstr : INIT : 			break; : 
2
strstr : if : 			break; : 
2
strstr : for : 			break; : 
2
strstr : while : 			break; : 
2
str : #else /* !CONFIG_SCHED_DEBUG */[31]
strstr : INIT : #else /* !CONFIG_SCHED_DEBUG */ : 
2
strstr : if : #else /* !CONFIG_SCHED_DEBUG */ : 
2
strstr : for : #else /* !CONFIG_SCHED_DEBUG */ : 
2
strstr : while : #else /* !CONFIG_SCHED_DEBUG */ : 
2
str : # define sched_domain_debug(sd, cpu) do { } while (0)[53]
strstr : INIT : # define sched_domain_debug(sd, cpu) do { } while (0) : 
2
strstr : if : # define sched_domain_debug(sd, cpu) do { } while (0) : 
2
strstr : for : # define sched_domain_debug(sd, cpu) do { } while (0) : 
2
strstr : while : # define sched_domain_debug(sd, cpu) do { } while (0) : 
2
str : static inline bool sched_debug(void)[36]
strstr : INIT : static inline bool sched_debug(void) : 
2
strstr : if : static inline bool sched_debug(void) : 
2
strstr : for : static inline bool sched_debug(void) : 
2
strstr : while : static inline bool sched_debug(void) : 
2
str : 	return false;[14]
strstr : INIT : 	return false; : 
2
strstr : if : 	return false; : 
2
strstr : for : 	return false; : 
2
strstr : while : 	return false; : 
2
str : #endif /* CONFIG_SCHED_DEBUG */[31]
strstr : INIT : #endif /* CONFIG_SCHED_DEBUG */ : 
2
strstr : if : #endif /* CONFIG_SCHED_DEBUG */ : 
2
strstr : for : #endif /* CONFIG_SCHED_DEBUG */ : 
2
strstr : while : #endif /* CONFIG_SCHED_DEBUG */ : 
2
str : static int sd_degenerate(struct sched_domain *sd)[49]
strstr : INIT : static int sd_degenerate(struct sched_domain *sd) : 
2
strstr : if : static int sd_degenerate(struct sched_domain *sd) : 
2
strstr : for : static int sd_degenerate(struct sched_domain *sd) : 
2
strstr : while : static int sd_degenerate(struct sched_domain *sd) : 
2
str : 	if (cpumask_weight(sched_domain_span(sd)) == 1)[48]
strstr : INIT : 	if (cpumask_weight(sched_domain_span(sd)) == 1) : 
2
strstr : if : 	if (cpumask_weight(sched_domain_span(sd)) == 1) : 
2
strstr : for : 	if (cpumask_weight(sched_domain_span(sd)) == 1) : 
2
strstr : while : 	if (cpumask_weight(sched_domain_span(sd)) == 1) : 
2
str : 		return 1;[11]
strstr : INIT : 		return 1; : 
2
strstr : if : 		return 1; : 
2
strstr : for : 		return 1; : 
2
strstr : while : 		return 1; : 
2
str : 	/* Following flags need at least 2 groups */[45]
strstr : INIT : 	/* Following flags need at least 2 groups */ : 
2
strstr : if : 	/* Following flags need at least 2 groups */ : 
2
strstr : for : 	/* Following flags need at least 2 groups */ : 
2
strstr : while : 	/* Following flags need at least 2 groups */ : 
2
str : 	if (sd->flags & (SD_LOAD_BALANCE |[35]
strstr : INIT : 	if (sd->flags & (SD_LOAD_BALANCE | : 
2
strstr : if : 	if (sd->flags & (SD_LOAD_BALANCE | : 
2
strstr : for : 	if (sd->flags & (SD_LOAD_BALANCE | : 
2
strstr : while : 	if (sd->flags & (SD_LOAD_BALANCE | : 
2
str : 			 SD_BALANCE_NEWIDLE |[24]
strstr : INIT : 			 SD_BALANCE_NEWIDLE | : 
2
strstr : if : 			 SD_BALANCE_NEWIDLE | : 
2
strstr : for : 			 SD_BALANCE_NEWIDLE | : 
2
strstr : while : 			 SD_BALANCE_NEWIDLE | : 
2
str : 			 SD_BALANCE_FORK |[21]
strstr : INIT : 			 SD_BALANCE_FORK | : 
2
strstr : if : 			 SD_BALANCE_FORK | : 
2
strstr : for : 			 SD_BALANCE_FORK | : 
2
strstr : while : 			 SD_BALANCE_FORK | : 
2
str : 			 SD_BALANCE_EXEC |[21]
strstr : INIT : 			 SD_BALANCE_EXEC | : 
2
strstr : if : 			 SD_BALANCE_EXEC | : 
2
strstr : for : 			 SD_BALANCE_EXEC | : 
2
strstr : while : 			 SD_BALANCE_EXEC | : 
2
str : 			 SD_SHARE_CPUPOWER |[23]
strstr : INIT : 			 SD_SHARE_CPUPOWER | : 
2
strstr : if : 			 SD_SHARE_CPUPOWER | : 
2
strstr : for : 			 SD_SHARE_CPUPOWER | : 
2
strstr : while : 			 SD_SHARE_CPUPOWER | : 
2
str : 			 SD_SHARE_PKG_RESOURCES)) {[30]
strstr : INIT : 			 SD_SHARE_PKG_RESOURCES)) { : 
2
strstr : if : 			 SD_SHARE_PKG_RESOURCES)) { : 
2
strstr : for : 			 SD_SHARE_PKG_RESOURCES)) { : 
2
strstr : while : 			 SD_SHARE_PKG_RESOURCES)) { : 
2
str : 		if (sd->groups != sd->groups->next)[37]
strstr : INIT : 		if (sd->groups != sd->groups->next) : 
2
strstr : if : 		if (sd->groups != sd->groups->next) : 
2
strstr : for : 		if (sd->groups != sd->groups->next) : 
2
strstr : while : 		if (sd->groups != sd->groups->next) : 
2
str : 			return 0;[12]
strstr : INIT : 			return 0; : 
2
strstr : if : 			return 0; : 
2
strstr : for : 			return 0; : 
2
strstr : while : 			return 0; : 
2
str : 	/* Following flags don't use groups */[39]
strstr : INIT : 	/* Following flags don't use groups */ : 
2
strstr : if : 	/* Following flags don't use groups */ : 
2
strstr : for : 	/* Following flags don't use groups */ : 
2
strstr : while : 	/* Following flags don't use groups */ : 
2
str : 	if (sd->flags & (SD_WAKE_AFFINE))[34]
strstr : INIT : 	if (sd->flags & (SD_WAKE_AFFINE)) : 
2
strstr : if : 	if (sd->flags & (SD_WAKE_AFFINE)) : 
2
strstr : for : 	if (sd->flags & (SD_WAKE_AFFINE)) : 
2
strstr : while : 	if (sd->flags & (SD_WAKE_AFFINE)) : 
2
str : 		return 0;[11]
strstr : INIT : 		return 0; : 
2
strstr : if : 		return 0; : 
2
strstr : for : 		return 0; : 
2
strstr : while : 		return 0; : 
2
str : 	return 1;[10]
strstr : INIT : 	return 1; : 
2
strstr : if : 	return 1; : 
2
strstr : for : 	return 1; : 
2
strstr : while : 	return 1; : 
2
str : static int[10]
strstr : INIT : static int : 
2
strstr : if : static int : 
2
strstr : for : static int : 
2
strstr : while : static int : 
2
str : sd_parent_degenerate(struct sched_domain *sd, struct sched_domain *parent)[74]
strstr : INIT : sd_parent_degenerate(struct sched_domain *sd, struct sched_domain *parent) : 
2
strstr : if : sd_parent_degenerate(struct sched_domain *sd, struct sched_domain *parent) : 
2
strstr : for : sd_parent_degenerate(struct sched_domain *sd, struct sched_domain *parent) : 
2
strstr : while : sd_parent_degenerate(struct sched_domain *sd, struct sched_domain *parent) : 
2
str : 	unsigned long cflags = sd->flags, pflags = parent->flags;[58]
strstr : INIT : 	unsigned long cflags = sd->flags, pflags = parent->flags; : 
2
strstr : if : 	unsigned long cflags = sd->flags, pflags = parent->flags; : 
2
strstr : for : 	unsigned long cflags = sd->flags, pflags = parent->flags; : 
2
strstr : while : 	unsigned long cflags = sd->flags, pflags = parent->flags; : 
2
str : 	if (sd_degenerate(parent))[27]
strstr : INIT : 	if (sd_degenerate(parent)) : 
2
strstr : if : 	if (sd_degenerate(parent)) : 
2
strstr : for : 	if (sd_degenerate(parent)) : 
2
strstr : while : 	if (sd_degenerate(parent)) : 
2
str : 		return 1;[11]
strstr : INIT : 		return 1; : 
2
strstr : if : 		return 1; : 
2
strstr : for : 		return 1; : 
2
strstr : while : 		return 1; : 
2
str : 	if (!cpumask_equal(sched_domain_span(sd), sched_domain_span(parent)))[70]
strstr : INIT : 	if (!cpumask_equal(sched_domain_span(sd), sched_domain_span(parent))) : 
2
strstr : if : 	if (!cpumask_equal(sched_domain_span(sd), sched_domain_span(parent))) : 
2
strstr : for : 	if (!cpumask_equal(sched_domain_span(sd), sched_domain_span(parent))) : 
2
strstr : while : 	if (!cpumask_equal(sched_domain_span(sd), sched_domain_span(parent))) : 
2
str : 		return 0;[11]
strstr : INIT : 		return 0; : 
2
strstr : if : 		return 0; : 
2
strstr : for : 		return 0; : 
2
strstr : while : 		return 0; : 
2
str : 	/* Flags needing groups don't count if only 1 group in parent */[65]
strstr : INIT : 	/* Flags needing groups don't count if only 1 group in parent */ : 
2
strstr : if : 	/* Flags needing groups don't count if only 1 group in parent */ : 
2
strstr : for : 	/* Flags needing groups don't count if only 1 group in parent */ : 
2
strstr : while : 	/* Flags needing groups don't count if only 1 group in parent */ : 
2
str : 	if (parent->groups == parent->groups->next) {[46]
strstr : INIT : 	if (parent->groups == parent->groups->next) { : 
2
strstr : if : 	if (parent->groups == parent->groups->next) { : 
2
strstr : for : 	if (parent->groups == parent->groups->next) { : 
2
strstr : while : 	if (parent->groups == parent->groups->next) { : 
2
str : 		pflags &= ~(SD_LOAD_BALANCE |[31]
strstr : INIT : 		pflags &= ~(SD_LOAD_BALANCE | : 
2
strstr : if : 		pflags &= ~(SD_LOAD_BALANCE | : 
2
strstr : for : 		pflags &= ~(SD_LOAD_BALANCE | : 
2
strstr : while : 		pflags &= ~(SD_LOAD_BALANCE | : 
2
str : 				SD_BALANCE_NEWIDLE |[24]
strstr : INIT : 				SD_BALANCE_NEWIDLE | : 
2
strstr : if : 				SD_BALANCE_NEWIDLE | : 
2
strstr : for : 				SD_BALANCE_NEWIDLE | : 
2
strstr : while : 				SD_BALANCE_NEWIDLE | : 
2
str : 				SD_BALANCE_FORK |[21]
strstr : INIT : 				SD_BALANCE_FORK | : 
2
strstr : if : 				SD_BALANCE_FORK | : 
2
strstr : for : 				SD_BALANCE_FORK | : 
2
strstr : while : 				SD_BALANCE_FORK | : 
2
str : 				SD_BALANCE_EXEC |[21]
strstr : INIT : 				SD_BALANCE_EXEC | : 
2
strstr : if : 				SD_BALANCE_EXEC | : 
2
strstr : for : 				SD_BALANCE_EXEC | : 
2
strstr : while : 				SD_BALANCE_EXEC | : 
2
str : 				SD_SHARE_CPUPOWER |[23]
strstr : INIT : 				SD_SHARE_CPUPOWER | : 
2
strstr : if : 				SD_SHARE_CPUPOWER | : 
2
strstr : for : 				SD_SHARE_CPUPOWER | : 
2
strstr : while : 				SD_SHARE_CPUPOWER | : 
2
str : 				SD_SHARE_PKG_RESOURCES |[28]
strstr : INIT : 				SD_SHARE_PKG_RESOURCES | : 
2
strstr : if : 				SD_SHARE_PKG_RESOURCES | : 
2
strstr : for : 				SD_SHARE_PKG_RESOURCES | : 
2
strstr : while : 				SD_SHARE_PKG_RESOURCES | : 
2
str : 				SD_PREFER_SIBLING);[23]
strstr : INIT : 				SD_PREFER_SIBLING); : 
2
strstr : if : 				SD_PREFER_SIBLING); : 
2
strstr : for : 				SD_PREFER_SIBLING); : 
2
strstr : while : 				SD_PREFER_SIBLING); : 
2
str : 		if (nr_node_ids == 1)[23]
strstr : INIT : 		if (nr_node_ids == 1) : 
2
strstr : if : 		if (nr_node_ids == 1) : 
2
strstr : for : 		if (nr_node_ids == 1) : 
2
strstr : while : 		if (nr_node_ids == 1) : 
2
str : 			pflags &= ~SD_SERIALIZE;[27]
strstr : INIT : 			pflags &= ~SD_SERIALIZE; : 
2
strstr : if : 			pflags &= ~SD_SERIALIZE; : 
2
strstr : for : 			pflags &= ~SD_SERIALIZE; : 
2
strstr : while : 			pflags &= ~SD_SERIALIZE; : 
2
str : 	if (~cflags & pflags)[22]
strstr : INIT : 	if (~cflags & pflags) : 
2
strstr : if : 	if (~cflags & pflags) : 
2
strstr : for : 	if (~cflags & pflags) : 
2
strstr : while : 	if (~cflags & pflags) : 
2
str : 		return 0;[11]
strstr : INIT : 		return 0; : 
2
strstr : if : 		return 0; : 
2
strstr : for : 		return 0; : 
2
strstr : while : 		return 0; : 
2
str : 	return 1;[10]
strstr : INIT : 	return 1; : 
2
strstr : if : 	return 1; : 
2
strstr : for : 	return 1; : 
2
strstr : while : 	return 1; : 
2
str : static void free_rootdomain(struct rcu_head *rcu)[49]
strstr : INIT : static void free_rootdomain(struct rcu_head *rcu) : 
2
strstr : if : static void free_rootdomain(struct rcu_head *rcu) : 
2
strstr : for : static void free_rootdomain(struct rcu_head *rcu) : 
2
strstr : while : static void free_rootdomain(struct rcu_head *rcu) : 
2
str : 	struct root_domain *rd = container_of(rcu, struct root_domain, rcu);[69]
strstr : INIT : 	struct root_domain *rd = container_of(rcu, struct root_domain, rcu); : 
2
strstr : if : 	struct root_domain *rd = container_of(rcu, struct root_domain, rcu); : 
2
strstr : for : 	struct root_domain *rd = container_of(rcu, struct root_domain, rcu); : 
2
strstr : while : 	struct root_domain *rd = container_of(rcu, struct root_domain, rcu); : 
2
str : 	cpupri_cleanup(&rd->cpupri);[29]
strstr : INIT : 	cpupri_cleanup(&rd->cpupri); : 
2
strstr : if : 	cpupri_cleanup(&rd->cpupri); : 
2
strstr : for : 	cpupri_cleanup(&rd->cpupri); : 
2
strstr : while : 	cpupri_cleanup(&rd->cpupri); : 
2
str : 	cpudl_cleanup(&rd->cpudl);[27]
strstr : INIT : 	cpudl_cleanup(&rd->cpudl); : 
2
strstr : if : 	cpudl_cleanup(&rd->cpudl); : 
2
strstr : for : 	cpudl_cleanup(&rd->cpudl); : 
2
strstr : while : 	cpudl_cleanup(&rd->cpudl); : 
2
str : 	free_cpumask_var(rd->dlo_mask);[32]
strstr : INIT : 	free_cpumask_var(rd->dlo_mask); : 
2
strstr : if : 	free_cpumask_var(rd->dlo_mask); : 
2
strstr : for : 	free_cpumask_var(rd->dlo_mask); : 
2
strstr : while : 	free_cpumask_var(rd->dlo_mask); : 
2
str : 	free_cpumask_var(rd->rto_mask);[32]
strstr : INIT : 	free_cpumask_var(rd->rto_mask); : 
2
strstr : if : 	free_cpumask_var(rd->rto_mask); : 
2
strstr : for : 	free_cpumask_var(rd->rto_mask); : 
2
strstr : while : 	free_cpumask_var(rd->rto_mask); : 
2
str : 	free_cpumask_var(rd->online);[30]
strstr : INIT : 	free_cpumask_var(rd->online); : 
2
strstr : if : 	free_cpumask_var(rd->online); : 
2
strstr : for : 	free_cpumask_var(rd->online); : 
2
strstr : while : 	free_cpumask_var(rd->online); : 
2
str : 	free_cpumask_var(rd->span);[28]
strstr : INIT : 	free_cpumask_var(rd->span); : 
2
strstr : if : 	free_cpumask_var(rd->span); : 
2
strstr : for : 	free_cpumask_var(rd->span); : 
2
strstr : while : 	free_cpumask_var(rd->span); : 
2
str : 	kfree(rd);[11]
strstr : INIT : 	kfree(rd); : 
2
strstr : if : 	kfree(rd); : 
2
strstr : for : 	kfree(rd); : 
2
strstr : while : 	kfree(rd); : 
2
str : static void rq_attach_root(struct rq *rq, struct root_domain *rd)[65]
strstr : INIT : static void rq_attach_root(struct rq *rq, struct root_domain *rd) : 
2
strstr : if : static void rq_attach_root(struct rq *rq, struct root_domain *rd) : 
2
strstr : for : static void rq_attach_root(struct rq *rq, struct root_domain *rd) : 
2
strstr : while : static void rq_attach_root(struct rq *rq, struct root_domain *rd) : 
2
str : 	struct root_domain *old_rd = NULL;[35]
strstr : INIT : 	struct root_domain *old_rd = NULL; : 
2
strstr : if : 	struct root_domain *old_rd = NULL; : 
2
strstr : for : 	struct root_domain *old_rd = NULL; : 
2
strstr : while : 	struct root_domain *old_rd = NULL; : 
2
str : 	unsigned long flags;[21]
strstr : INIT : 	unsigned long flags; : 
2
strstr : if : 	unsigned long flags; : 
2
strstr : for : 	unsigned long flags; : 
2
strstr : while : 	unsigned long flags; : 
2
str : 	raw_spin_lock_irqsave(&rq->lock, flags);[41]
strstr : INIT : 	raw_spin_lock_irqsave(&rq->lock, flags); : 
2
strstr : if : 	raw_spin_lock_irqsave(&rq->lock, flags); : 
2
strstr : for : 	raw_spin_lock_irqsave(&rq->lock, flags); : 
2
strstr : while : 	raw_spin_lock_irqsave(&rq->lock, flags); : 
2
str : 	if (rq->rd) {[14]
strstr : INIT : 	if (rq->rd) { : 
2
strstr : if : 	if (rq->rd) { : 
2
strstr : for : 	if (rq->rd) { : 
2
strstr : while : 	if (rq->rd) { : 
2
str : 		old_rd = rq->rd;[18]
strstr : INIT : 		old_rd = rq->rd; : 
2
strstr : if : 		old_rd = rq->rd; : 
2
strstr : for : 		old_rd = rq->rd; : 
2
strstr : while : 		old_rd = rq->rd; : 
2
str : 		if (cpumask_test_cpu(rq->cpu, old_rd->online))[48]
strstr : INIT : 		if (cpumask_test_cpu(rq->cpu, old_rd->online)) : 
2
strstr : if : 		if (cpumask_test_cpu(rq->cpu, old_rd->online)) : 
2
strstr : for : 		if (cpumask_test_cpu(rq->cpu, old_rd->online)) : 
2
strstr : while : 		if (cpumask_test_cpu(rq->cpu, old_rd->online)) : 
2
str : 			set_rq_offline(rq);[22]
strstr : INIT : 			set_rq_offline(rq); : 
2
strstr : if : 			set_rq_offline(rq); : 
2
strstr : for : 			set_rq_offline(rq); : 
2
strstr : while : 			set_rq_offline(rq); : 
2
str : 		cpumask_clear_cpu(rq->cpu, old_rd->span);[43]
strstr : INIT : 		cpumask_clear_cpu(rq->cpu, old_rd->span); : 
2
strstr : if : 		cpumask_clear_cpu(rq->cpu, old_rd->span); : 
2
strstr : for : 		cpumask_clear_cpu(rq->cpu, old_rd->span); : 
2
strstr : while : 		cpumask_clear_cpu(rq->cpu, old_rd->span); : 
2
str : 		/*[4]
strstr : INIT : 		/* : 
2
strstr : if : 		/* : 
2
strstr : for : 		/* : 
2
strstr : while : 		/* : 
2
str : 		 * If we dont want to free the old_rd yet then[48]
strstr : INIT : 		 * If we dont want to free the old_rd yet then : 
2
strstr : if : 		 * If we dont want to free the old_rd yet then : 
2
strstr : for : 		 * If we dont want to free the old_rd yet then : 
2
strstr : while : 		 * If we dont want to free the old_rd yet then : 
2
str : 		 * set old_rd to NULL to skip the freeing later[49]
strstr : INIT : 		 * set old_rd to NULL to skip the freeing later : 
2
strstr : if : 		 * set old_rd to NULL to skip the freeing later : 
2
strstr : for : 		 * set old_rd to NULL to skip the freeing later : 
2
strstr : while : 		 * set old_rd to NULL to skip the freeing later : 
2
str : 		 * in this function:[22]
strstr : INIT : 		 * in this function: : 
2
strstr : if : 		 * in this function: : 
2
strstr : for : 		 * in this function: : 
2
strstr : while : 		 * in this function: : 
2
str : 		 */[5]
strstr : INIT : 		 */ : 
2
strstr : if : 		 */ : 
2
strstr : for : 		 */ : 
2
strstr : while : 		 */ : 
2
str : 		if (!atomic_dec_and_test(&old_rd->refcount))[46]
strstr : INIT : 		if (!atomic_dec_and_test(&old_rd->refcount)) : 
2
strstr : if : 		if (!atomic_dec_and_test(&old_rd->refcount)) : 
2
strstr : for : 		if (!atomic_dec_and_test(&old_rd->refcount)) : 
2
strstr : while : 		if (!atomic_dec_and_test(&old_rd->refcount)) : 
2
str : 			old_rd = NULL;[17]
strstr : INIT : 			old_rd = NULL; : 
2
strstr : if : 			old_rd = NULL; : 
2
strstr : for : 			old_rd = NULL; : 
2
strstr : while : 			old_rd = NULL; : 
2
str : 	atomic_inc(&rd->refcount);[27]
strstr : INIT : 	atomic_inc(&rd->refcount); : 
2
strstr : if : 	atomic_inc(&rd->refcount); : 
2
strstr : for : 	atomic_inc(&rd->refcount); : 
2
strstr : while : 	atomic_inc(&rd->refcount); : 
2
str : 	rq->rd = rd;[13]
strstr : INIT : 	rq->rd = rd; : 
2
strstr : if : 	rq->rd = rd; : 
2
strstr : for : 	rq->rd = rd; : 
2
strstr : while : 	rq->rd = rd; : 
2
str : 	cpumask_set_cpu(rq->cpu, rd->span);[36]
strstr : INIT : 	cpumask_set_cpu(rq->cpu, rd->span); : 
2
strstr : if : 	cpumask_set_cpu(rq->cpu, rd->span); : 
2
strstr : for : 	cpumask_set_cpu(rq->cpu, rd->span); : 
2
strstr : while : 	cpumask_set_cpu(rq->cpu, rd->span); : 
2
str : 	if (cpumask_test_cpu(rq->cpu, cpu_active_mask))[48]
strstr : INIT : 	if (cpumask_test_cpu(rq->cpu, cpu_active_mask)) : 
2
strstr : if : 	if (cpumask_test_cpu(rq->cpu, cpu_active_mask)) : 
2
strstr : for : 	if (cpumask_test_cpu(rq->cpu, cpu_active_mask)) : 
2
strstr : while : 	if (cpumask_test_cpu(rq->cpu, cpu_active_mask)) : 
2
str : 		set_rq_online(rq);[20]
strstr : INIT : 		set_rq_online(rq); : 
2
strstr : if : 		set_rq_online(rq); : 
2
strstr : for : 		set_rq_online(rq); : 
2
strstr : while : 		set_rq_online(rq); : 
2
str : 	raw_spin_unlock_irqrestore(&rq->lock, flags);[46]
strstr : INIT : 	raw_spin_unlock_irqrestore(&rq->lock, flags); : 
2
strstr : if : 	raw_spin_unlock_irqrestore(&rq->lock, flags); : 
2
strstr : for : 	raw_spin_unlock_irqrestore(&rq->lock, flags); : 
2
strstr : while : 	raw_spin_unlock_irqrestore(&rq->lock, flags); : 
2
str : 	if (old_rd)[12]
strstr : INIT : 	if (old_rd) : 
2
strstr : if : 	if (old_rd) : 
2
strstr : for : 	if (old_rd) : 
2
strstr : while : 	if (old_rd) : 
2
str : 		call_rcu_sched(&old_rd->rcu, free_rootdomain);[48]
strstr : INIT : 		call_rcu_sched(&old_rd->rcu, free_rootdomain); : 
2
strstr : if : 		call_rcu_sched(&old_rd->rcu, free_rootdomain); : 
2
strstr : for : 		call_rcu_sched(&old_rd->rcu, free_rootdomain); : 
2
strstr : while : 		call_rcu_sched(&old_rd->rcu, free_rootdomain); : 
2
str : static int init_rootdomain(struct root_domain *rd)[50]
strstr : INIT : static int init_rootdomain(struct root_domain *rd) : 
2
strstr : if : static int init_rootdomain(struct root_domain *rd) : 
2
strstr : for : static int init_rootdomain(struct root_domain *rd) : 
2
strstr : while : static int init_rootdomain(struct root_domain *rd) : 
2
str : 	memset(rd, 0, sizeof(*rd));[28]
strstr : INIT : 	memset(rd, 0, sizeof(*rd)); : 
2
strstr : if : 	memset(rd, 0, sizeof(*rd)); : 
2
strstr : for : 	memset(rd, 0, sizeof(*rd)); : 
2
strstr : while : 	memset(rd, 0, sizeof(*rd)); : 
2
str : 	if (!alloc_cpumask_var(&rd->span, GFP_KERNEL))[47]
strstr : INIT : 	if (!alloc_cpumask_var(&rd->span, GFP_KERNEL)) : 
2
strstr : if : 	if (!alloc_cpumask_var(&rd->span, GFP_KERNEL)) : 
2
strstr : for : 	if (!alloc_cpumask_var(&rd->span, GFP_KERNEL)) : 
2
strstr : while : 	if (!alloc_cpumask_var(&rd->span, GFP_KERNEL)) : 
2
str : 		goto out;[11]
strstr : INIT : 		goto out; : 
2
strstr : if : 		goto out; : 
2
strstr : for : 		goto out; : 
2
strstr : while : 		goto out; : 
2
str : 	if (!alloc_cpumask_var(&rd->online, GFP_KERNEL))[49]
strstr : INIT : 	if (!alloc_cpumask_var(&rd->online, GFP_KERNEL)) : 
2
strstr : if : 	if (!alloc_cpumask_var(&rd->online, GFP_KERNEL)) : 
2
strstr : for : 	if (!alloc_cpumask_var(&rd->online, GFP_KERNEL)) : 
2
strstr : while : 	if (!alloc_cpumask_var(&rd->online, GFP_KERNEL)) : 
2
str : 		goto free_span;[17]
strstr : INIT : 		goto free_span; : 
2
strstr : if : 		goto free_span; : 
2
strstr : for : 		goto free_span; : 
2
strstr : while : 		goto free_span; : 
2
str : 	if (!alloc_cpumask_var(&rd->dlo_mask, GFP_KERNEL))[51]
strstr : INIT : 	if (!alloc_cpumask_var(&rd->dlo_mask, GFP_KERNEL)) : 
2
strstr : if : 	if (!alloc_cpumask_var(&rd->dlo_mask, GFP_KERNEL)) : 
2
strstr : for : 	if (!alloc_cpumask_var(&rd->dlo_mask, GFP_KERNEL)) : 
2
strstr : while : 	if (!alloc_cpumask_var(&rd->dlo_mask, GFP_KERNEL)) : 
2
str : 		goto free_online;[19]
strstr : INIT : 		goto free_online; : 
2
strstr : if : 		goto free_online; : 
2
strstr : for : 		goto free_online; : 
2
strstr : while : 		goto free_online; : 
2
str : 	if (!alloc_cpumask_var(&rd->rto_mask, GFP_KERNEL))[51]
strstr : INIT : 	if (!alloc_cpumask_var(&rd->rto_mask, GFP_KERNEL)) : 
2
strstr : if : 	if (!alloc_cpumask_var(&rd->rto_mask, GFP_KERNEL)) : 
2
strstr : for : 	if (!alloc_cpumask_var(&rd->rto_mask, GFP_KERNEL)) : 
2
strstr : while : 	if (!alloc_cpumask_var(&rd->rto_mask, GFP_KERNEL)) : 
2
str : 		goto free_dlo_mask;[21]
strstr : INIT : 		goto free_dlo_mask; : 
2
strstr : if : 		goto free_dlo_mask; : 
2
strstr : for : 		goto free_dlo_mask; : 
2
strstr : while : 		goto free_dlo_mask; : 
2
str : 	init_dl_bw(&rd->dl_bw);[24]
strstr : INIT : 	init_dl_bw(&rd->dl_bw); : 
2
strstr : if : 	init_dl_bw(&rd->dl_bw); : 
2
strstr : for : 	init_dl_bw(&rd->dl_bw); : 
2
strstr : while : 	init_dl_bw(&rd->dl_bw); : 
2
str : 	if (cpudl_init(&rd->cpudl) != 0)[33]
strstr : INIT : 	if (cpudl_init(&rd->cpudl) != 0) : 
2
strstr : if : 	if (cpudl_init(&rd->cpudl) != 0) : 
2
strstr : for : 	if (cpudl_init(&rd->cpudl) != 0) : 
2
strstr : while : 	if (cpudl_init(&rd->cpudl) != 0) : 
2
str : 		goto free_dlo_mask;[21]
strstr : INIT : 		goto free_dlo_mask; : 
2
strstr : if : 		goto free_dlo_mask; : 
2
strstr : for : 		goto free_dlo_mask; : 
2
strstr : while : 		goto free_dlo_mask; : 
2
str : 	if (cpupri_init(&rd->cpupri) != 0)[35]
strstr : INIT : 	if (cpupri_init(&rd->cpupri) != 0) : 
2
strstr : if : 	if (cpupri_init(&rd->cpupri) != 0) : 
2
strstr : for : 	if (cpupri_init(&rd->cpupri) != 0) : 
2
strstr : while : 	if (cpupri_init(&rd->cpupri) != 0) : 
2
str : 		goto free_rto_mask;[21]
strstr : INIT : 		goto free_rto_mask; : 
2
strstr : if : 		goto free_rto_mask; : 
2
strstr : for : 		goto free_rto_mask; : 
2
strstr : while : 		goto free_rto_mask; : 
2
str : 	return 0;[10]
strstr : INIT : 	return 0; : 
2
strstr : if : 	return 0; : 
2
strstr : for : 	return 0; : 
2
strstr : while : 	return 0; : 
2
str : free_rto_mask:[14]
strstr : INIT : free_rto_mask: : 
2
strstr : if : free_rto_mask: : 
2
strstr : for : free_rto_mask: : 
2
strstr : while : free_rto_mask: : 
2
str : 	free_cpumask_var(rd->rto_mask);[32]
strstr : INIT : 	free_cpumask_var(rd->rto_mask); : 
2
strstr : if : 	free_cpumask_var(rd->rto_mask); : 
2
strstr : for : 	free_cpumask_var(rd->rto_mask); : 
2
strstr : while : 	free_cpumask_var(rd->rto_mask); : 
2
str : free_dlo_mask:[14]
strstr : INIT : free_dlo_mask: : 
2
strstr : if : free_dlo_mask: : 
2
strstr : for : free_dlo_mask: : 
2
strstr : while : free_dlo_mask: : 
2
str : 	free_cpumask_var(rd->dlo_mask);[32]
strstr : INIT : 	free_cpumask_var(rd->dlo_mask); : 
2
strstr : if : 	free_cpumask_var(rd->dlo_mask); : 
2
strstr : for : 	free_cpumask_var(rd->dlo_mask); : 
2
strstr : while : 	free_cpumask_var(rd->dlo_mask); : 
2
str : free_online:[12]
strstr : INIT : free_online: : 
2
strstr : if : free_online: : 
2
strstr : for : free_online: : 
2
strstr : while : free_online: : 
2
str : 	free_cpumask_var(rd->online);[30]
strstr : INIT : 	free_cpumask_var(rd->online); : 
2
strstr : if : 	free_cpumask_var(rd->online); : 
2
strstr : for : 	free_cpumask_var(rd->online); : 
2
strstr : while : 	free_cpumask_var(rd->online); : 
2
str : free_span:[10]
strstr : INIT : free_span: : 
2
strstr : if : free_span: : 
2
strstr : for : free_span: : 
2
strstr : while : free_span: : 
2
str : 	free_cpumask_var(rd->span);[28]
strstr : INIT : 	free_cpumask_var(rd->span); : 
2
strstr : if : 	free_cpumask_var(rd->span); : 
2
strstr : for : 	free_cpumask_var(rd->span); : 
2
strstr : while : 	free_cpumask_var(rd->span); : 
2
str : out:[4]
strstr : INIT : out: : 
2
strstr : if : out: : 
2
strstr : for : out: : 
2
strstr : while : out: : 
2
str : 	return -ENOMEM;[16]
strstr : INIT : 	return -ENOMEM; : 
2
strstr : if : 	return -ENOMEM; : 
2
strstr : for : 	return -ENOMEM; : 
2
strstr : while : 	return -ENOMEM; : 
2
str :  * By default the system creates a single root-domain with all cpus as[70]
strstr : INIT :  * By default the system creates a single root-domain with all cpus as : 
2
strstr : if :  * By default the system creates a single root-domain with all cpus as : 
2
strstr : for :  * By default the system creates a single root-domain with all cpus as : 
2
strstr : while :  * By default the system creates a single root-domain with all cpus as : 
2
str :  * members (mimicking the global state we have today).[54]
strstr : INIT :  * members (mimicking the global state we have today). : 
2
strstr : if :  * members (mimicking the global state we have today). : 
2
strstr : for :  * members (mimicking the global state we have today). : 
2
strstr : while :  * members (mimicking the global state we have today). : 
2
str :  */[3]
strstr : INIT :  */ : 
2
strstr : if :  */ : 
2
strstr : for :  */ : 
2
strstr : while :  */ : 
2
str : struct root_domain def_root_domain;[35]
strstr : INIT : struct root_domain def_root_domain; : 
2
strstr : if : struct root_domain def_root_domain; : 
2
strstr : for : struct root_domain def_root_domain; : 
2
strstr : while : struct root_domain def_root_domain; : 
2
str : static void init_defrootdomain(void)[36]
strstr : INIT : static void init_defrootdomain(void) : 
2
strstr : if : static void init_defrootdomain(void) : 
2
strstr : for : static void init_defrootdomain(void) : 
2
strstr : while : static void init_defrootdomain(void) : 
2
str : 	init_rootdomain(&def_root_domain);[35]
strstr : INIT : 	init_rootdomain(&def_root_domain); : 
2
strstr : if : 	init_rootdomain(&def_root_domain); : 
2
strstr : for : 	init_rootdomain(&def_root_domain); : 
2
strstr : while : 	init_rootdomain(&def_root_domain); : 
2
str : 	atomic_set(&def_root_domain.refcount, 1);[42]
strstr : INIT : 	atomic_set(&def_root_domain.refcount, 1); : 
2
strstr : if : 	atomic_set(&def_root_domain.refcount, 1); : 
2
strstr : for : 	atomic_set(&def_root_domain.refcount, 1); : 
2
strstr : while : 	atomic_set(&def_root_domain.refcount, 1); : 
2
str : static struct root_domain *alloc_rootdomain(void)[49]
strstr : INIT : static struct root_domain *alloc_rootdomain(void) : 
2
strstr : if : static struct root_domain *alloc_rootdomain(void) : 
2
strstr : for : static struct root_domain *alloc_rootdomain(void) : 
2
strstr : while : static struct root_domain *alloc_rootdomain(void) : 
2
str : 	struct root_domain *rd;[24]
strstr : INIT : 	struct root_domain *rd; : 
2
strstr : if : 	struct root_domain *rd; : 
2
strstr : for : 	struct root_domain *rd; : 
2
strstr : while : 	struct root_domain *rd; : 
2
str : 	rd = kmalloc(sizeof(*rd), GFP_KERNEL);[39]
strstr : INIT : 	rd = kmalloc(sizeof(*rd), GFP_KERNEL); : 
2
strstr : if : 	rd = kmalloc(sizeof(*rd), GFP_KERNEL); : 
2
strstr : for : 	rd = kmalloc(sizeof(*rd), GFP_KERNEL); : 
2
strstr : while : 	rd = kmalloc(sizeof(*rd), GFP_KERNEL); : 
2
str : 	if (!rd)[9]
strstr : INIT : 	if (!rd) : 
2
strstr : if : 	if (!rd) : 
2
strstr : for : 	if (!rd) : 
2
strstr : while : 	if (!rd) : 
2
str : 		return NULL;[14]
strstr : INIT : 		return NULL; : 
2
strstr : if : 		return NULL; : 
2
strstr : for : 		return NULL; : 
2
strstr : while : 		return NULL; : 
2
str : 	if (init_rootdomain(rd) != 0) {[32]
strstr : INIT : 	if (init_rootdomain(rd) != 0) { : 
2
strstr : if : 	if (init_rootdomain(rd) != 0) { : 
2
strstr : for : 	if (init_rootdomain(rd) != 0) { : 
2
strstr : while : 	if (init_rootdomain(rd) != 0) { : 
2
str : 		kfree(rd);[12]
strstr : INIT : 		kfree(rd); : 
2
strstr : if : 		kfree(rd); : 
2
strstr : for : 		kfree(rd); : 
2
strstr : while : 		kfree(rd); : 
2
str : 		return NULL;[14]
strstr : INIT : 		return NULL; : 
2
strstr : if : 		return NULL; : 
2
strstr : for : 		return NULL; : 
2
strstr : while : 		return NULL; : 
2
str : 	return rd;[11]
strstr : INIT : 	return rd; : 
2
strstr : if : 	return rd; : 
2
strstr : for : 	return rd; : 
2
strstr : while : 	return rd; : 
2
str : static void free_sched_groups(struct sched_group *sg, int free_sgp)[67]
strstr : INIT : static void free_sched_groups(struct sched_group *sg, int free_sgp) : 
2
strstr : if : static void free_sched_groups(struct sched_group *sg, int free_sgp) : 
2
strstr : for : static void free_sched_groups(struct sched_group *sg, int free_sgp) : 
2
strstr : while : static void free_sched_groups(struct sched_group *sg, int free_sgp) : 
2
str : 	struct sched_group *tmp, *first;[33]
strstr : INIT : 	struct sched_group *tmp, *first; : 
2
strstr : if : 	struct sched_group *tmp, *first; : 
2
strstr : for : 	struct sched_group *tmp, *first; : 
2
strstr : while : 	struct sched_group *tmp, *first; : 
2
str : 	if (!sg)[9]
strstr : INIT : 	if (!sg) : 
2
strstr : if : 	if (!sg) : 
2
strstr : for : 	if (!sg) : 
2
strstr : while : 	if (!sg) : 
2
str : 		return;[9]
strstr : INIT : 		return; : 
2
strstr : if : 		return; : 
2
strstr : for : 		return; : 
2
strstr : while : 		return; : 
2
str : 	first = sg;[12]
strstr : INIT : 	first = sg; : 
2
strstr : if : 	first = sg; : 
2
strstr : for : 	first = sg; : 
2
strstr : while : 	first = sg; : 
2
str : 	do {[5]
strstr : INIT : 	do { : 
2
strstr : if : 	do { : 
2
strstr : for : 	do { : 
2
strstr : while : 	do { : 
2
str : 		tmp = sg->next;[17]
strstr : INIT : 		tmp = sg->next; : 
2
strstr : if : 		tmp = sg->next; : 
2
strstr : for : 		tmp = sg->next; : 
2
strstr : while : 		tmp = sg->next; : 
2
str : 		if (free_sgp && atomic_dec_and_test(&sg->sgp->ref))[53]
strstr : INIT : 		if (free_sgp && atomic_dec_and_test(&sg->sgp->ref)) : 
2
strstr : if : 		if (free_sgp && atomic_dec_and_test(&sg->sgp->ref)) : 
2
strstr : for : 		if (free_sgp && atomic_dec_and_test(&sg->sgp->ref)) : 
2
strstr : while : 		if (free_sgp && atomic_dec_and_test(&sg->sgp->ref)) : 
2
str : 			kfree(sg->sgp);[18]
strstr : INIT : 			kfree(sg->sgp); : 
2
strstr : if : 			kfree(sg->sgp); : 
2
strstr : for : 			kfree(sg->sgp); : 
2
strstr : while : 			kfree(sg->sgp); : 
2
str : 		kfree(sg);[12]
strstr : INIT : 		kfree(sg); : 
2
strstr : if : 		kfree(sg); : 
2
strstr : for : 		kfree(sg); : 
2
strstr : while : 		kfree(sg); : 
2
str : 		sg = tmp;[11]
strstr : INIT : 		sg = tmp; : 
2
strstr : if : 		sg = tmp; : 
2
strstr : for : 		sg = tmp; : 
2
strstr : while : 		sg = tmp; : 
2
str : 	} while (sg != first);[23]
strstr : INIT : 	} while (sg != first); : 
2
strstr : if : 	} while (sg != first); : 
2
strstr : for : 	} while (sg != first); : 
2
strstr : while : 	} while (sg != first); : 
2
str : static void free_sched_domain(struct rcu_head *rcu)[51]
strstr : INIT : static void free_sched_domain(struct rcu_head *rcu) : 
2
strstr : if : static void free_sched_domain(struct rcu_head *rcu) : 
2
strstr : for : static void free_sched_domain(struct rcu_head *rcu) : 
2
strstr : while : static void free_sched_domain(struct rcu_head *rcu) : 
2
str : 	struct sched_domain *sd = container_of(rcu, struct sched_domain, rcu);[71]
strstr : INIT : 	struct sched_domain *sd = container_of(rcu, struct sched_domain, rcu); : 
2
strstr : if : 	struct sched_domain *sd = container_of(rcu, struct sched_domain, rcu); : 
2
strstr : for : 	struct sched_domain *sd = container_of(rcu, struct sched_domain, rcu); : 
2
strstr : while : 	struct sched_domain *sd = container_of(rcu, struct sched_domain, rcu); : 
2
str : 	/*[3]
strstr : INIT : 	/* : 
2
strstr : if : 	/* : 
2
strstr : for : 	/* : 
2
strstr : while : 	/* : 
2
str : 	 * If its an overlapping domain it has private groups, iterate and[67]
strstr : INIT : 	 * If its an overlapping domain it has private groups, iterate and : 
2
strstr : if : 	 * If its an overlapping domain it has private groups, iterate and : 
2
strstr : for : 	 * If its an overlapping domain it has private groups, iterate and : 
2
strstr : while : 	 * If its an overlapping domain it has private groups, iterate and : 
2
str : 	 * nuke them all.[18]
strstr : INIT : 	 * nuke them all. : 
2
strstr : if : 	 * nuke them all. : 
2
strstr : for : 	 * nuke them all. : 
2
strstr : while : 	 * nuke them all. : 
2
str : 	 */[4]
strstr : INIT : 	 */ : 
2
strstr : if : 	 */ : 
2
strstr : for : 	 */ : 
2
strstr : while : 	 */ : 
2
str : 	if (sd->flags & SD_OVERLAP) {[30]
strstr : INIT : 	if (sd->flags & SD_OVERLAP) { : 
2
strstr : if : 	if (sd->flags & SD_OVERLAP) { : 
2
strstr : for : 	if (sd->flags & SD_OVERLAP) { : 
2
strstr : while : 	if (sd->flags & SD_OVERLAP) { : 
2
str : 		free_sched_groups(sd->groups, 1);[35]
strstr : INIT : 		free_sched_groups(sd->groups, 1); : 
2
strstr : if : 		free_sched_groups(sd->groups, 1); : 
2
strstr : for : 		free_sched_groups(sd->groups, 1); : 
2
strstr : while : 		free_sched_groups(sd->groups, 1); : 
2
str : 	} else if (atomic_dec_and_test(&sd->groups->ref)) {[52]
strstr : INIT : 	} else if (atomic_dec_and_test(&sd->groups->ref)) { : 
2
strstr : if : 	} else if (atomic_dec_and_test(&sd->groups->ref)) { : 
2
strstr : for : 	} else if (atomic_dec_and_test(&sd->groups->ref)) { : 
2
strstr : while : 	} else if (atomic_dec_and_test(&sd->groups->ref)) { : 
2
str : 		kfree(sd->groups->sgp);[25]
strstr : INIT : 		kfree(sd->groups->sgp); : 
2
strstr : if : 		kfree(sd->groups->sgp); : 
2
strstr : for : 		kfree(sd->groups->sgp); : 
2
strstr : while : 		kfree(sd->groups->sgp); : 
2
str : 		kfree(sd->groups);[20]
strstr : INIT : 		kfree(sd->groups); : 
2
strstr : if : 		kfree(sd->groups); : 
2
strstr : for : 		kfree(sd->groups); : 
2
strstr : while : 		kfree(sd->groups); : 
2
str : 	kfree(sd);[11]
strstr : INIT : 	kfree(sd); : 
2
strstr : if : 	kfree(sd); : 
2
strstr : for : 	kfree(sd); : 
2
strstr : while : 	kfree(sd); : 
2
str : static void destroy_sched_domain(struct sched_domain *sd, int cpu)[66]
strstr : INIT : static void destroy_sched_domain(struct sched_domain *sd, int cpu) : 
2
strstr : if : static void destroy_sched_domain(struct sched_domain *sd, int cpu) : 
2
strstr : for : static void destroy_sched_domain(struct sched_domain *sd, int cpu) : 
2
strstr : while : static void destroy_sched_domain(struct sched_domain *sd, int cpu) : 
2
str : 	call_rcu(&sd->rcu, free_sched_domain);[39]
strstr : INIT : 	call_rcu(&sd->rcu, free_sched_domain); : 
2
strstr : if : 	call_rcu(&sd->rcu, free_sched_domain); : 
2
strstr : for : 	call_rcu(&sd->rcu, free_sched_domain); : 
2
strstr : while : 	call_rcu(&sd->rcu, free_sched_domain); : 
2
str : static void destroy_sched_domains(struct sched_domain *sd, int cpu)[67]
strstr : INIT : static void destroy_sched_domains(struct sched_domain *sd, int cpu) : 
2
strstr : if : static void destroy_sched_domains(struct sched_domain *sd, int cpu) : 
2
strstr : for : static void destroy_sched_domains(struct sched_domain *sd, int cpu) : 
2
strstr : while : static void destroy_sched_domains(struct sched_domain *sd, int cpu) : 
2
str : 	for (; sd; sd = sd->parent)[28]
strstr : INIT : 	for (; sd; sd = sd->parent) : 
2
strstr : if : 	for (; sd; sd = sd->parent) : 
2
strstr : for : 	for (; sd; sd = sd->parent) : 
2
strstr : while : 	for (; sd; sd = sd->parent) : 
2
str : 		destroy_sched_domain(sd, cpu);[32]
strstr : INIT : 		destroy_sched_domain(sd, cpu); : 
2
strstr : if : 		destroy_sched_domain(sd, cpu); : 
2
strstr : for : 		destroy_sched_domain(sd, cpu); : 
2
strstr : while : 		destroy_sched_domain(sd, cpu); : 
2
str :  * Keep a special pointer to the highest sched_domain that has[62]
strstr : INIT :  * Keep a special pointer to the highest sched_domain that has : 
2
strstr : if :  * Keep a special pointer to the highest sched_domain that has : 
2
strstr : for :  * Keep a special pointer to the highest sched_domain that has : 
2
strstr : while :  * Keep a special pointer to the highest sched_domain that has : 
2
str :  * SD_SHARE_PKG_RESOURCE set (Last Level Cache Domain) for this[63]
strstr : INIT :  * SD_SHARE_PKG_RESOURCE set (Last Level Cache Domain) for this : 
2
strstr : if :  * SD_SHARE_PKG_RESOURCE set (Last Level Cache Domain) for this : 
2
strstr : for :  * SD_SHARE_PKG_RESOURCE set (Last Level Cache Domain) for this : 
2
strstr : while :  * SD_SHARE_PKG_RESOURCE set (Last Level Cache Domain) for this : 
2
str :  * allows us to avoid some pointer chasing select_idle_sibling().[65]
strstr : INIT :  * allows us to avoid some pointer chasing select_idle_sibling(). : 
2
strstr : if :  * allows us to avoid some pointer chasing select_idle_sibling(). : 
2
strstr : for :  * allows us to avoid some pointer chasing select_idle_sibling(). : 
2
strstr : while :  * allows us to avoid some pointer chasing select_idle_sibling(). : 
2
str :  * Also keep a unique ID per domain (we use the first cpu number in[67]
strstr : INIT :  * Also keep a unique ID per domain (we use the first cpu number in : 
2
strstr : if :  * Also keep a unique ID per domain (we use the first cpu number in : 
2
strstr : for :  * Also keep a unique ID per domain (we use the first cpu number in : 
2
strstr : while :  * Also keep a unique ID per domain (we use the first cpu number in : 
2
str :  * the cpumask of the domain), this allows us to quickly tell if[64]
strstr : INIT :  * the cpumask of the domain), this allows us to quickly tell if : 
2
strstr : if :  * the cpumask of the domain), this allows us to quickly tell if : 
2
strstr : for :  * the cpumask of the domain), this allows us to quickly tell if : 
2
strstr : while :  * the cpumask of the domain), this allows us to quickly tell if : 
2
str :  * two cpus are in the same cache domain, see cpus_share_cache().[65]
strstr : INIT :  * two cpus are in the same cache domain, see cpus_share_cache(). : 
2
strstr : if :  * two cpus are in the same cache domain, see cpus_share_cache(). : 
2
strstr : for :  * two cpus are in the same cache domain, see cpus_share_cache(). : 
2
strstr : while :  * two cpus are in the same cache domain, see cpus_share_cache(). : 
2
str :  */[3]
strstr : INIT :  */ : 
2
strstr : if :  */ : 
2
strstr : for :  */ : 
2
strstr : while :  */ : 
2
str : DEFINE_PER_CPU(struct sched_domain *, sd_llc);[46]
strstr : INIT : DEFINE_PER_CPU(struct sched_domain *, sd_llc); : 
2
strstr : if : DEFINE_PER_CPU(struct sched_domain *, sd_llc); : 
2
strstr : for : DEFINE_PER_CPU(struct sched_domain *, sd_llc); : 
2
strstr : while : DEFINE_PER_CPU(struct sched_domain *, sd_llc); : 
2
str : DEFINE_PER_CPU(int, sd_llc_size);[33]
strstr : INIT : DEFINE_PER_CPU(int, sd_llc_size); : 
2
strstr : if : DEFINE_PER_CPU(int, sd_llc_size); : 
2
strstr : for : DEFINE_PER_CPU(int, sd_llc_size); : 
2
strstr : while : DEFINE_PER_CPU(int, sd_llc_size); : 
2
str : DEFINE_PER_CPU(int, sd_llc_id);[31]
strstr : INIT : DEFINE_PER_CPU(int, sd_llc_id); : 
2
strstr : if : DEFINE_PER_CPU(int, sd_llc_id); : 
2
strstr : for : DEFINE_PER_CPU(int, sd_llc_id); : 
2
strstr : while : DEFINE_PER_CPU(int, sd_llc_id); : 
2
str : DEFINE_PER_CPU(struct sched_domain *, sd_numa);[47]
strstr : INIT : DEFINE_PER_CPU(struct sched_domain *, sd_numa); : 
2
strstr : if : DEFINE_PER_CPU(struct sched_domain *, sd_numa); : 
2
strstr : for : DEFINE_PER_CPU(struct sched_domain *, sd_numa); : 
2
strstr : while : DEFINE_PER_CPU(struct sched_domain *, sd_numa); : 
2
str : DEFINE_PER_CPU(struct sched_domain *, sd_busy);[47]
strstr : INIT : DEFINE_PER_CPU(struct sched_domain *, sd_busy); : 
2
strstr : if : DEFINE_PER_CPU(struct sched_domain *, sd_busy); : 
2
strstr : for : DEFINE_PER_CPU(struct sched_domain *, sd_busy); : 
2
strstr : while : DEFINE_PER_CPU(struct sched_domain *, sd_busy); : 
2
str : DEFINE_PER_CPU(struct sched_domain *, sd_asym);[47]
strstr : INIT : DEFINE_PER_CPU(struct sched_domain *, sd_asym); : 
2
strstr : if : DEFINE_PER_CPU(struct sched_domain *, sd_asym); : 
2
strstr : for : DEFINE_PER_CPU(struct sched_domain *, sd_asym); : 
2
strstr : while : DEFINE_PER_CPU(struct sched_domain *, sd_asym); : 
2
str : static void update_top_cache_domain(int cpu)[44]
strstr : INIT : static void update_top_cache_domain(int cpu) : 
2
strstr : if : static void update_top_cache_domain(int cpu) : 
2
strstr : for : static void update_top_cache_domain(int cpu) : 
2
strstr : while : static void update_top_cache_domain(int cpu) : 
2
str : 	struct sched_domain *sd;[25]
strstr : INIT : 	struct sched_domain *sd; : 
2
strstr : if : 	struct sched_domain *sd; : 
2
strstr : for : 	struct sched_domain *sd; : 
2
strstr : while : 	struct sched_domain *sd; : 
2
str : 	struct sched_domain *busy_sd = NULL;[37]
strstr : INIT : 	struct sched_domain *busy_sd = NULL; : 
2
strstr : if : 	struct sched_domain *busy_sd = NULL; : 
2
strstr : for : 	struct sched_domain *busy_sd = NULL; : 
2
strstr : while : 	struct sched_domain *busy_sd = NULL; : 
2
str : 	int id = cpu;[14]
strstr : INIT : 	int id = cpu; : 
2
strstr : if : 	int id = cpu; : 
2
strstr : for : 	int id = cpu; : 
2
strstr : while : 	int id = cpu; : 
2
str : 	int size = 1;[14]
strstr : INIT : 	int size = 1; : 
2
strstr : if : 	int size = 1; : 
2
strstr : for : 	int size = 1; : 
2
strstr : while : 	int size = 1; : 
2
str : 	sd = highest_flag_domain(cpu, SD_SHARE_PKG_RESOURCES);[55]
strstr : INIT : 	sd = highest_flag_domain(cpu, SD_SHARE_PKG_RESOURCES); : 
2
strstr : if : 	sd = highest_flag_domain(cpu, SD_SHARE_PKG_RESOURCES); : 
2
strstr : for : 	sd = highest_flag_domain(cpu, SD_SHARE_PKG_RESOURCES); : 
2
strstr : while : 	sd = highest_flag_domain(cpu, SD_SHARE_PKG_RESOURCES); : 
2
str : 	if (sd) {[10]
strstr : INIT : 	if (sd) { : 
2
strstr : if : 	if (sd) { : 
2
strstr : for : 	if (sd) { : 
2
strstr : while : 	if (sd) { : 
2
str : 		id = cpumask_first(sched_domain_span(sd));[44]
strstr : INIT : 		id = cpumask_first(sched_domain_span(sd)); : 
2
strstr : if : 		id = cpumask_first(sched_domain_span(sd)); : 
2
strstr : for : 		id = cpumask_first(sched_domain_span(sd)); : 
2
strstr : while : 		id = cpumask_first(sched_domain_span(sd)); : 
2
str : 		size = cpumask_weight(sched_domain_span(sd));[47]
strstr : INIT : 		size = cpumask_weight(sched_domain_span(sd)); : 
2
strstr : if : 		size = cpumask_weight(sched_domain_span(sd)); : 
2
strstr : for : 		size = cpumask_weight(sched_domain_span(sd)); : 
2
strstr : while : 		size = cpumask_weight(sched_domain_span(sd)); : 
2
str : 		busy_sd = sd->parent; /* sd_busy */[37]
strstr : INIT : 		busy_sd = sd->parent; /* sd_busy */ : 
2
strstr : if : 		busy_sd = sd->parent; /* sd_busy */ : 
2
strstr : for : 		busy_sd = sd->parent; /* sd_busy */ : 
2
strstr : while : 		busy_sd = sd->parent; /* sd_busy */ : 
2
str : 	rcu_assign_pointer(per_cpu(sd_busy, cpu), busy_sd);[52]
strstr : INIT : 	rcu_assign_pointer(per_cpu(sd_busy, cpu), busy_sd); : 
2
strstr : if : 	rcu_assign_pointer(per_cpu(sd_busy, cpu), busy_sd); : 
2
strstr : for : 	rcu_assign_pointer(per_cpu(sd_busy, cpu), busy_sd); : 
2
strstr : while : 	rcu_assign_pointer(per_cpu(sd_busy, cpu), busy_sd); : 
2
str : 	rcu_assign_pointer(per_cpu(sd_llc, cpu), sd);[46]
strstr : INIT : 	rcu_assign_pointer(per_cpu(sd_llc, cpu), sd); : 
2
strstr : if : 	rcu_assign_pointer(per_cpu(sd_llc, cpu), sd); : 
2
strstr : for : 	rcu_assign_pointer(per_cpu(sd_llc, cpu), sd); : 
2
strstr : while : 	rcu_assign_pointer(per_cpu(sd_llc, cpu), sd); : 
2
str : 	per_cpu(sd_llc_size, cpu) = size;[34]
strstr : INIT : 	per_cpu(sd_llc_size, cpu) = size; : 
2
strstr : if : 	per_cpu(sd_llc_size, cpu) = size; : 
2
strstr : for : 	per_cpu(sd_llc_size, cpu) = size; : 
2
strstr : while : 	per_cpu(sd_llc_size, cpu) = size; : 
2
str : 	per_cpu(sd_llc_id, cpu) = id;[30]
strstr : INIT : 	per_cpu(sd_llc_id, cpu) = id; : 
2
strstr : if : 	per_cpu(sd_llc_id, cpu) = id; : 
2
strstr : for : 	per_cpu(sd_llc_id, cpu) = id; : 
2
strstr : while : 	per_cpu(sd_llc_id, cpu) = id; : 
2
str : 	sd = lowest_flag_domain(cpu, SD_NUMA);[39]
strstr : INIT : 	sd = lowest_flag_domain(cpu, SD_NUMA); : 
2
strstr : if : 	sd = lowest_flag_domain(cpu, SD_NUMA); : 
2
strstr : for : 	sd = lowest_flag_domain(cpu, SD_NUMA); : 
2
strstr : while : 	sd = lowest_flag_domain(cpu, SD_NUMA); : 
2
str : 	rcu_assign_pointer(per_cpu(sd_numa, cpu), sd);[47]
strstr : INIT : 	rcu_assign_pointer(per_cpu(sd_numa, cpu), sd); : 
2
strstr : if : 	rcu_assign_pointer(per_cpu(sd_numa, cpu), sd); : 
2
strstr : for : 	rcu_assign_pointer(per_cpu(sd_numa, cpu), sd); : 
2
strstr : while : 	rcu_assign_pointer(per_cpu(sd_numa, cpu), sd); : 
2
str : 	sd = highest_flag_domain(cpu, SD_ASYM_PACKING);[48]
strstr : INIT : 	sd = highest_flag_domain(cpu, SD_ASYM_PACKING); : 
2
strstr : if : 	sd = highest_flag_domain(cpu, SD_ASYM_PACKING); : 
2
strstr : for : 	sd = highest_flag_domain(cpu, SD_ASYM_PACKING); : 
2
strstr : while : 	sd = highest_flag_domain(cpu, SD_ASYM_PACKING); : 
2
str : 	rcu_assign_pointer(per_cpu(sd_asym, cpu), sd);[47]
strstr : INIT : 	rcu_assign_pointer(per_cpu(sd_asym, cpu), sd); : 
2
strstr : if : 	rcu_assign_pointer(per_cpu(sd_asym, cpu), sd); : 
2
strstr : for : 	rcu_assign_pointer(per_cpu(sd_asym, cpu), sd); : 
2
strstr : while : 	rcu_assign_pointer(per_cpu(sd_asym, cpu), sd); : 
2
str :  * Attach the domain 'sd' to 'cpu' as its base domain. Callers must[67]
strstr : INIT :  * Attach the domain 'sd' to 'cpu' as its base domain. Callers must : 
2
strstr : if :  * Attach the domain 'sd' to 'cpu' as its base domain. Callers must : 
2
strstr : for :  * Attach the domain 'sd' to 'cpu' as its base domain. Callers must : 
2
strstr : while :  * Attach the domain 'sd' to 'cpu' as its base domain. Callers must : 
2
str :  * hold the hotplug lock.[25]
strstr : INIT :  * hold the hotplug lock. : 
2
strstr : if :  * hold the hotplug lock. : 
2
strstr : for :  * hold the hotplug lock. : 
2
strstr : while :  * hold the hotplug lock. : 
2
str :  */[3]
strstr : INIT :  */ : 
2
strstr : if :  */ : 
2
strstr : for :  */ : 
2
strstr : while :  */ : 
2
str : static void[11]
strstr : INIT : static void : 
2
strstr : if : static void : 
2
strstr : for : static void : 
2
strstr : while : static void : 
2
str : cpu_attach_domain(struct sched_domain *sd, struct root_domain *rd, int cpu)[75]
strstr : INIT : cpu_attach_domain(struct sched_domain *sd, struct root_domain *rd, int cpu) : 
2
strstr : if : cpu_attach_domain(struct sched_domain *sd, struct root_domain *rd, int cpu) : 
2
strstr : for : cpu_attach_domain(struct sched_domain *sd, struct root_domain *rd, int cpu) : 
2
strstr : while : cpu_attach_domain(struct sched_domain *sd, struct root_domain *rd, int cpu) : 
2
str : 	struct rq *rq = cpu_rq(cpu);[29]
strstr : INIT : 	struct rq *rq = cpu_rq(cpu); : 
2
strstr : if : 	struct rq *rq = cpu_rq(cpu); : 
2
strstr : for : 	struct rq *rq = cpu_rq(cpu); : 
2
strstr : while : 	struct rq *rq = cpu_rq(cpu); : 
2
str : 	struct sched_domain *tmp;[26]
strstr : INIT : 	struct sched_domain *tmp; : 
2
strstr : if : 	struct sched_domain *tmp; : 
2
strstr : for : 	struct sched_domain *tmp; : 
2
strstr : while : 	struct sched_domain *tmp; : 
2
str : 	/* Remove the sched domains which do not contribute to scheduling. */[70]
strstr : INIT : 	/* Remove the sched domains which do not contribute to scheduling. */ : 
2
strstr : if : 	/* Remove the sched domains which do not contribute to scheduling. */ : 
2
strstr : for : 	/* Remove the sched domains which do not contribute to scheduling. */ : 
2
strstr : while : 	/* Remove the sched domains which do not contribute to scheduling. */ : 
2
str : 	for (tmp = sd; tmp; ) {[24]
strstr : INIT : 	for (tmp = sd; tmp; ) { : 
2
strstr : if : 	for (tmp = sd; tmp; ) { : 
2
strstr : for : 	for (tmp = sd; tmp; ) { : 
2
strstr : while : 	for (tmp = sd; tmp; ) { : 
2
str : 		struct sched_domain *parent = tmp->parent;[44]
strstr : INIT : 		struct sched_domain *parent = tmp->parent; : 
2
strstr : if : 		struct sched_domain *parent = tmp->parent; : 
2
strstr : for : 		struct sched_domain *parent = tmp->parent; : 
2
strstr : while : 		struct sched_domain *parent = tmp->parent; : 
2
str : 		if (!parent)[14]
strstr : INIT : 		if (!parent) : 
2
strstr : if : 		if (!parent) : 
2
strstr : for : 		if (!parent) : 
2
strstr : while : 		if (!parent) : 
2
str : 			break;[9]
strstr : INIT : 			break; : 
2
strstr : if : 			break; : 
2
strstr : for : 			break; : 
2
strstr : while : 			break; : 
2
str : 		if (sd_parent_degenerate(tmp, parent)) {[42]
strstr : INIT : 		if (sd_parent_degenerate(tmp, parent)) { : 
2
strstr : if : 		if (sd_parent_degenerate(tmp, parent)) { : 
2
strstr : for : 		if (sd_parent_degenerate(tmp, parent)) { : 
2
strstr : while : 		if (sd_parent_degenerate(tmp, parent)) { : 
2
str : 			tmp->parent = parent->parent;[32]
strstr : INIT : 			tmp->parent = parent->parent; : 
2
strstr : if : 			tmp->parent = parent->parent; : 
2
strstr : for : 			tmp->parent = parent->parent; : 
2
strstr : while : 			tmp->parent = parent->parent; : 
2
str : 			if (parent->parent)[22]
strstr : INIT : 			if (parent->parent) : 
2
strstr : if : 			if (parent->parent) : 
2
strstr : for : 			if (parent->parent) : 
2
strstr : while : 			if (parent->parent) : 
2
str : 				parent->parent->child = tmp;[32]
strstr : INIT : 				parent->parent->child = tmp; : 
2
strstr : if : 				parent->parent->child = tmp; : 
2
strstr : for : 				parent->parent->child = tmp; : 
2
strstr : while : 				parent->parent->child = tmp; : 
2
str : 			/*[5]
strstr : INIT : 			/* : 
2
strstr : if : 			/* : 
2
strstr : for : 			/* : 
2
strstr : while : 			/* : 
2
str : 			 * Transfer SD_PREFER_SIBLING down in case of a[50]
strstr : INIT : 			 * Transfer SD_PREFER_SIBLING down in case of a : 
2
strstr : if : 			 * Transfer SD_PREFER_SIBLING down in case of a : 
2
strstr : for : 			 * Transfer SD_PREFER_SIBLING down in case of a : 
2
strstr : while : 			 * Transfer SD_PREFER_SIBLING down in case of a : 
2
str : 			 * degenerate parent; the spans match for this[49]
strstr : INIT : 			 * degenerate parent; the spans match for this : 
2
strstr : if : 			 * degenerate parent; the spans match for this : 
2
strstr : for : 			 * degenerate parent; the spans match for this : 
2
strstr : while : 			 * degenerate parent; the spans match for this : 
2
str : 			 * so the property transfers.[32]
strstr : INIT : 			 * so the property transfers. : 
2
strstr : if : 			 * so the property transfers. : 
2
strstr : for : 			 * so the property transfers. : 
2
strstr : while : 			 * so the property transfers. : 
2
str : 			 */[6]
strstr : INIT : 			 */ : 
2
strstr : if : 			 */ : 
2
strstr : for : 			 */ : 
2
strstr : while : 			 */ : 
2
str : 			if (parent->flags & SD_PREFER_SIBLING)[41]
strstr : INIT : 			if (parent->flags & SD_PREFER_SIBLING) : 
2
strstr : if : 			if (parent->flags & SD_PREFER_SIBLING) : 
2
strstr : for : 			if (parent->flags & SD_PREFER_SIBLING) : 
2
strstr : while : 			if (parent->flags & SD_PREFER_SIBLING) : 
2
str : 				tmp->flags |= SD_PREFER_SIBLING;[36]
strstr : INIT : 				tmp->flags |= SD_PREFER_SIBLING; : 
2
strstr : if : 				tmp->flags |= SD_PREFER_SIBLING; : 
2
strstr : for : 				tmp->flags |= SD_PREFER_SIBLING; : 
2
strstr : while : 				tmp->flags |= SD_PREFER_SIBLING; : 
2
str : 			destroy_sched_domain(parent, cpu);[37]
strstr : INIT : 			destroy_sched_domain(parent, cpu); : 
2
strstr : if : 			destroy_sched_domain(parent, cpu); : 
2
strstr : for : 			destroy_sched_domain(parent, cpu); : 
2
strstr : while : 			destroy_sched_domain(parent, cpu); : 
2
str : 		} else[8]
strstr : INIT : 		} else : 
2
strstr : if : 		} else : 
2
strstr : for : 		} else : 
2
strstr : while : 		} else : 
2
str : 			tmp = tmp->parent;[21]
strstr : INIT : 			tmp = tmp->parent; : 
2
strstr : if : 			tmp = tmp->parent; : 
2
strstr : for : 			tmp = tmp->parent; : 
2
strstr : while : 			tmp = tmp->parent; : 
2
str : 	if (sd && sd_degenerate(sd)) {[31]
strstr : INIT : 	if (sd && sd_degenerate(sd)) { : 
2
strstr : if : 	if (sd && sd_degenerate(sd)) { : 
2
strstr : for : 	if (sd && sd_degenerate(sd)) { : 
2
strstr : while : 	if (sd && sd_degenerate(sd)) { : 
2
str : 		tmp = sd;[11]
strstr : INIT : 		tmp = sd; : 
2
strstr : if : 		tmp = sd; : 
2
strstr : for : 		tmp = sd; : 
2
strstr : while : 		tmp = sd; : 
2
str : 		sd = sd->parent;[18]
strstr : INIT : 		sd = sd->parent; : 
2
strstr : if : 		sd = sd->parent; : 
2
strstr : for : 		sd = sd->parent; : 
2
strstr : while : 		sd = sd->parent; : 
2
str : 		destroy_sched_domain(tmp, cpu);[33]
strstr : INIT : 		destroy_sched_domain(tmp, cpu); : 
2
strstr : if : 		destroy_sched_domain(tmp, cpu); : 
2
strstr : for : 		destroy_sched_domain(tmp, cpu); : 
2
strstr : while : 		destroy_sched_domain(tmp, cpu); : 
2
str : 		if (sd)[9]
strstr : INIT : 		if (sd) : 
2
strstr : if : 		if (sd) : 
2
strstr : for : 		if (sd) : 
2
strstr : while : 		if (sd) : 
2
str : 			sd->child = NULL;[20]
strstr : INIT : 			sd->child = NULL; : 
2
strstr : if : 			sd->child = NULL; : 
2
strstr : for : 			sd->child = NULL; : 
2
strstr : while : 			sd->child = NULL; : 
2
str : 	sched_domain_debug(sd, cpu);[29]
strstr : INIT : 	sched_domain_debug(sd, cpu); : 
2
strstr : if : 	sched_domain_debug(sd, cpu); : 
2
strstr : for : 	sched_domain_debug(sd, cpu); : 
2
strstr : while : 	sched_domain_debug(sd, cpu); : 
2
str : 	rq_attach_root(rq, rd);[24]
strstr : INIT : 	rq_attach_root(rq, rd); : 
2
strstr : if : 	rq_attach_root(rq, rd); : 
2
strstr : for : 	rq_attach_root(rq, rd); : 
2
strstr : while : 	rq_attach_root(rq, rd); : 
2
str : 	tmp = rq->sd;[14]
strstr : INIT : 	tmp = rq->sd; : 
2
strstr : if : 	tmp = rq->sd; : 
2
strstr : for : 	tmp = rq->sd; : 
2
strstr : while : 	tmp = rq->sd; : 
2
str : 	rcu_assign_pointer(rq->sd, sd);[32]
strstr : INIT : 	rcu_assign_pointer(rq->sd, sd); : 
2
strstr : if : 	rcu_assign_pointer(rq->sd, sd); : 
2
strstr : for : 	rcu_assign_pointer(rq->sd, sd); : 
2
strstr : while : 	rcu_assign_pointer(rq->sd, sd); : 
2
str : 	destroy_sched_domains(tmp, cpu);[33]
strstr : INIT : 	destroy_sched_domains(tmp, cpu); : 
2
strstr : if : 	destroy_sched_domains(tmp, cpu); : 
2
strstr : for : 	destroy_sched_domains(tmp, cpu); : 
2
strstr : while : 	destroy_sched_domains(tmp, cpu); : 
2
str : 	update_top_cache_domain(cpu);[30]
strstr : INIT : 	update_top_cache_domain(cpu); : 
2
strstr : if : 	update_top_cache_domain(cpu); : 
2
strstr : for : 	update_top_cache_domain(cpu); : 
2
strstr : while : 	update_top_cache_domain(cpu); : 
2
str : /* cpus with isolated domains */[32]
strstr : INIT : /* cpus with isolated domains */ : 
2
strstr : if : /* cpus with isolated domains */ : 
2
strstr : for : /* cpus with isolated domains */ : 
2
strstr : while : /* cpus with isolated domains */ : 
2
str : static cpumask_var_t cpu_isolated_map;[38]
strstr : INIT : static cpumask_var_t cpu_isolated_map; : 
2
strstr : if : static cpumask_var_t cpu_isolated_map; : 
2
strstr : for : static cpumask_var_t cpu_isolated_map; : 
2
strstr : while : static cpumask_var_t cpu_isolated_map; : 
2
str : /* Setup the mask of cpus configured for isolated domains */[60]
strstr : INIT : /* Setup the mask of cpus configured for isolated domains */ : 
2
strstr : if : /* Setup the mask of cpus configured for isolated domains */ : 
2
strstr : for : /* Setup the mask of cpus configured for isolated domains */ : 
2
strstr : while : /* Setup the mask of cpus configured for isolated domains */ : 
2
str : static int __init isolated_cpu_setup(char *str)[47]
strstr : INIT : static int __init isolated_cpu_setup(char *str) : 
2
strstr : if : static int __init isolated_cpu_setup(char *str) : 
2
strstr : for : static int __init isolated_cpu_setup(char *str) : 
2
strstr : while : static int __init isolated_cpu_setup(char *str) : 
2
str : 	alloc_bootmem_cpumask_var(&cpu_isolated_map);[46]
strstr : INIT : 	alloc_bootmem_cpumask_var(&cpu_isolated_map); : 
2
strstr : if : 	alloc_bootmem_cpumask_var(&cpu_isolated_map); : 
2
strstr : for : 	alloc_bootmem_cpumask_var(&cpu_isolated_map); : 
2
strstr : while : 	alloc_bootmem_cpumask_var(&cpu_isolated_map); : 
2
str : 	cpulist_parse(str, cpu_isolated_map);[38]
strstr : INIT : 	cpulist_parse(str, cpu_isolated_map); : 
2
strstr : if : 	cpulist_parse(str, cpu_isolated_map); : 
2
strstr : for : 	cpulist_parse(str, cpu_isolated_map); : 
2
strstr : while : 	cpulist_parse(str, cpu_isolated_map); : 
2
str : 	return 1;[10]
strstr : INIT : 	return 1; : 
2
strstr : if : 	return 1; : 
2
strstr : for : 	return 1; : 
2
strstr : while : 	return 1; : 
2
str : __setup("isolcpus=", isolated_cpu_setup);[41]
strstr : INIT : __setup("isolcpus=", isolated_cpu_setup); : 
2
strstr : if : __setup("isolcpus=", isolated_cpu_setup); : 
2
strstr : for : __setup("isolcpus=", isolated_cpu_setup); : 
2
strstr : while : __setup("isolcpus=", isolated_cpu_setup); : 
2
str : static const struct cpumask *cpu_cpu_mask(int cpu)[50]
strstr : INIT : static const struct cpumask *cpu_cpu_mask(int cpu) : 
2
strstr : if : static const struct cpumask *cpu_cpu_mask(int cpu) : 
2
strstr : for : static const struct cpumask *cpu_cpu_mask(int cpu) : 
2
strstr : while : static const struct cpumask *cpu_cpu_mask(int cpu) : 
2
str : 	return cpumask_of_node(cpu_to_node(cpu));[42]
strstr : INIT : 	return cpumask_of_node(cpu_to_node(cpu)); : 
2
strstr : if : 	return cpumask_of_node(cpu_to_node(cpu)); : 
2
strstr : for : 	return cpumask_of_node(cpu_to_node(cpu)); : 
2
strstr : while : 	return cpumask_of_node(cpu_to_node(cpu)); : 
2
str : struct sd_data {[16]
strstr : INIT : struct sd_data { : 
2
strstr : if : struct sd_data { : 
2
strstr : for : struct sd_data { : 
2
strstr : while : struct sd_data { : 
2
str : 	struct sched_domain **__percpu sd;[35]
strstr : INIT : 	struct sched_domain **__percpu sd; : 
2
strstr : if : 	struct sched_domain **__percpu sd; : 
2
strstr : for : 	struct sched_domain **__percpu sd; : 
2
strstr : while : 	struct sched_domain **__percpu sd; : 
2
str : 	struct sched_group **__percpu sg;[34]
strstr : INIT : 	struct sched_group **__percpu sg; : 
2
strstr : if : 	struct sched_group **__percpu sg; : 
2
strstr : for : 	struct sched_group **__percpu sg; : 
2
strstr : while : 	struct sched_group **__percpu sg; : 
2
str : 	struct sched_group_power **__percpu sgp;[41]
strstr : INIT : 	struct sched_group_power **__percpu sgp; : 
2
strstr : if : 	struct sched_group_power **__percpu sgp; : 
2
strstr : for : 	struct sched_group_power **__percpu sgp; : 
2
strstr : while : 	struct sched_group_power **__percpu sgp; : 
2
str : struct s_data {[15]
strstr : INIT : struct s_data { : 
2
strstr : if : struct s_data { : 
2
strstr : for : struct s_data { : 
2
strstr : while : struct s_data { : 
2
str : 	struct sched_domain ** __percpu sd;[36]
strstr : INIT : 	struct sched_domain ** __percpu sd; : 
2
strstr : if : 	struct sched_domain ** __percpu sd; : 
2
strstr : for : 	struct sched_domain ** __percpu sd; : 
2
strstr : while : 	struct sched_domain ** __percpu sd; : 
2
str : 	struct root_domain	*rd;[24]
strstr : INIT : 	struct root_domain	*rd; : 
2
strstr : if : 	struct root_domain	*rd; : 
2
strstr : for : 	struct root_domain	*rd; : 
2
strstr : while : 	struct root_domain	*rd; : 
2
str : enum s_alloc {[14]
strstr : INIT : enum s_alloc { : 
2
strstr : if : enum s_alloc { : 
2
strstr : for : enum s_alloc { : 
2
strstr : while : enum s_alloc { : 
2
str : 	sa_rootdomain,[15]
strstr : INIT : 	sa_rootdomain, : 
2
strstr : if : 	sa_rootdomain, : 
2
strstr : for : 	sa_rootdomain, : 
2
strstr : while : 	sa_rootdomain, : 
2
str : 	sa_sd,[7]
strstr : INIT : 	sa_sd, : 
2
strstr : if : 	sa_sd, : 
2
strstr : for : 	sa_sd, : 
2
strstr : while : 	sa_sd, : 
2
str : 	sa_sd_storage,[15]
strstr : INIT : 	sa_sd_storage, : 
2
strstr : if : 	sa_sd_storage, : 
2
strstr : for : 	sa_sd_storage, : 
2
strstr : while : 	sa_sd_storage, : 
2
str : 	sa_none,[9]
strstr : INIT : 	sa_none, : 
2
strstr : if : 	sa_none, : 
2
strstr : for : 	sa_none, : 
2
strstr : while : 	sa_none, : 
2
str : struct sched_domain_topology_level;[35]
strstr : INIT : struct sched_domain_topology_level; : 
2
strstr : if : struct sched_domain_topology_level; : 
2
strstr : for : struct sched_domain_topology_level; : 
2
strstr : while : struct sched_domain_topology_level; : 
2
str : typedef struct sched_domain *(*sched_domain_init_f)(struct sched_domain_topology_level *tl, int cpu);[101]
strstr : INIT : typedef struct sched_domain *(*sched_domain_init_f)(struct sched_domain_topology_level *tl, int cpu); : 
2
strstr : if : typedef struct sched_domain *(*sched_domain_init_f)(struct sched_domain_topology_level *tl, int cpu); : 
2
strstr : for : typedef struct sched_domain *(*sched_domain_init_f)(struct sched_domain_topology_level *tl, int cpu); : 
2
strstr : while : typedef struct sched_domain *(*sched_domain_init_f)(struct sched_domain_topology_level *tl, int cpu); : 
2
str : typedef const struct cpumask *(*sched_domain_mask_f)(int cpu);[62]
strstr : INIT : typedef const struct cpumask *(*sched_domain_mask_f)(int cpu); : 
2
strstr : if : typedef const struct cpumask *(*sched_domain_mask_f)(int cpu); : 
2
strstr : for : typedef const struct cpumask *(*sched_domain_mask_f)(int cpu); : 
2
strstr : while : typedef const struct cpumask *(*sched_domain_mask_f)(int cpu); : 
2
str : #define SDTL_OVERLAP	0x01[25]
strstr : INIT : #define SDTL_OVERLAP	0x01 : 
2
strstr : if : #define SDTL_OVERLAP	0x01 : 
2
strstr : for : #define SDTL_OVERLAP	0x01 : 
2
strstr : while : #define SDTL_OVERLAP	0x01 : 
2
str : struct sched_domain_topology_level {[36]
strstr : INIT : struct sched_domain_topology_level { : 
2
strstr : if : struct sched_domain_topology_level { : 
2
strstr : for : struct sched_domain_topology_level { : 
2
strstr : while : struct sched_domain_topology_level { : 
2
str : 	sched_domain_init_f init;[26]
strstr : INIT : 	sched_domain_init_f init; : 
2
strstr : if : 	sched_domain_init_f init; : 
2
strstr : for : 	sched_domain_init_f init; : 
2
strstr : while : 	sched_domain_init_f init; : 
2
str : 	sched_domain_mask_f mask;[26]
strstr : INIT : 	sched_domain_mask_f mask; : 
2
strstr : if : 	sched_domain_mask_f mask; : 
2
strstr : for : 	sched_domain_mask_f mask; : 
2
strstr : while : 	sched_domain_mask_f mask; : 
2
str : 	int		    flags;[16]
strstr : INIT : 	int		    flags; : 
2
strstr : if : 	int		    flags; : 
2
strstr : for : 	int		    flags; : 
2
strstr : while : 	int		    flags; : 
2
str : 	int		    numa_level;[21]
strstr : INIT : 	int		    numa_level; : 
2
strstr : if : 	int		    numa_level; : 
2
strstr : for : 	int		    numa_level; : 
2
strstr : while : 	int		    numa_level; : 
2
str : 	struct sd_data      data;[26]
strstr : INIT : 	struct sd_data      data; : 
2
strstr : if : 	struct sd_data      data; : 
2
strstr : for : 	struct sd_data      data; : 
2
strstr : while : 	struct sd_data      data; : 
2
str :  * Build an iteration mask that can exclude certain CPUs from the upwards[73]
strstr : INIT :  * Build an iteration mask that can exclude certain CPUs from the upwards : 
2
strstr : if :  * Build an iteration mask that can exclude certain CPUs from the upwards : 
2
strstr : for :  * Build an iteration mask that can exclude certain CPUs from the upwards : 
2
strstr : while :  * Build an iteration mask that can exclude certain CPUs from the upwards : 
2
str :  * domain traversal.[20]
strstr : INIT :  * domain traversal. : 
2
strstr : if :  * domain traversal. : 
2
strstr : for :  * domain traversal. : 
2
strstr : while :  * domain traversal. : 
2
str :  * Asymmetric node setups can result in situations where the domain tree is of[78]
strstr : INIT :  * Asymmetric node setups can result in situations where the domain tree is of : 
2
strstr : if :  * Asymmetric node setups can result in situations where the domain tree is of : 
2
strstr : for :  * Asymmetric node setups can result in situations where the domain tree is of : 
2
strstr : while :  * Asymmetric node setups can result in situations where the domain tree is of : 
2
str :  * unequal depth, make sure to skip domains that already cover the entire[73]
strstr : INIT :  * unequal depth, make sure to skip domains that already cover the entire : 
2
strstr : if :  * unequal depth, make sure to skip domains that already cover the entire : 
2
strstr : for :  * unequal depth, make sure to skip domains that already cover the entire : 
2
strstr : while :  * unequal depth, make sure to skip domains that already cover the entire : 
2
str :  * range.[9]
strstr : INIT :  * range. : 
2
strstr : if :  * range. : 
2
strstr : for :  * range. : 
2
strstr : while :  * range. : 
2
str :  * In that case build_sched_domains() will have terminated the iteration early[78]
strstr : INIT :  * In that case build_sched_domains() will have terminated the iteration early : 
2
strstr : if :  * In that case build_sched_domains() will have terminated the iteration early : 
2
strstr : for :  * In that case build_sched_domains() will have terminated the iteration early : 
2
strstr : while :  * In that case build_sched_domains() will have terminated the iteration early : 
2
str :  * and our sibling sd spans will be empty. Domains should always include the[76]
strstr : INIT :  * and our sibling sd spans will be empty. Domains should always include the : 
2
strstr : if :  * and our sibling sd spans will be empty. Domains should always include the : 
2
strstr : for :  * and our sibling sd spans will be empty. Domains should always include the : 
2
strstr : while :  * and our sibling sd spans will be empty. Domains should always include the : 
2
str :  * cpu they're built on, so check that.[39]
strstr : INIT :  * cpu they're built on, so check that. : 
2
strstr : if :  * cpu they're built on, so check that. : 
2
strstr : for :  * cpu they're built on, so check that. : 
2
strstr : while :  * cpu they're built on, so check that. : 
2
str :  */[3]
strstr : INIT :  */ : 
2
strstr : if :  */ : 
2
strstr : for :  */ : 
2
strstr : while :  */ : 
2
str : static void build_group_mask(struct sched_domain *sd, struct sched_group *sg)[77]
strstr : INIT : static void build_group_mask(struct sched_domain *sd, struct sched_group *sg) : 
2
strstr : if : static void build_group_mask(struct sched_domain *sd, struct sched_group *sg) : 
2
strstr : for : static void build_group_mask(struct sched_domain *sd, struct sched_group *sg) : 
2
strstr : while : static void build_group_mask(struct sched_domain *sd, struct sched_group *sg) : 
2
str : 	const struct cpumask *span = sched_domain_span(sd);[52]
strstr : INIT : 	const struct cpumask *span = sched_domain_span(sd); : 
2
strstr : if : 	const struct cpumask *span = sched_domain_span(sd); : 
2
strstr : for : 	const struct cpumask *span = sched_domain_span(sd); : 
2
strstr : while : 	const struct cpumask *span = sched_domain_span(sd); : 
2
str : 	struct sd_data *sdd = sd->private;[35]
strstr : INIT : 	struct sd_data *sdd = sd->private; : 
2
strstr : if : 	struct sd_data *sdd = sd->private; : 
2
strstr : for : 	struct sd_data *sdd = sd->private; : 
2
strstr : while : 	struct sd_data *sdd = sd->private; : 
2
str : 	struct sched_domain *sibling;[30]
strstr : INIT : 	struct sched_domain *sibling; : 
2
strstr : if : 	struct sched_domain *sibling; : 
2
strstr : for : 	struct sched_domain *sibling; : 
2
strstr : while : 	struct sched_domain *sibling; : 
2
str : 	int i;[7]
strstr : INIT : 	int i; : 
2
strstr : if : 	int i; : 
2
strstr : for : 	int i; : 
2
strstr : while : 	int i; : 
2
str : 	for_each_cpu(i, span) {[24]
strstr : INIT : 	for_each_cpu(i, span) { : 
2
strstr : if : 	for_each_cpu(i, span) { : 
2
strstr : for : 	for_each_cpu(i, span) { : 
2
strstr : while : 	for_each_cpu(i, span) { : 
2
str : 		sibling = *per_cpu_ptr(sdd->sd, i);[37]
strstr : INIT : 		sibling = *per_cpu_ptr(sdd->sd, i); : 
2
strstr : if : 		sibling = *per_cpu_ptr(sdd->sd, i); : 
2
strstr : for : 		sibling = *per_cpu_ptr(sdd->sd, i); : 
2
strstr : while : 		sibling = *per_cpu_ptr(sdd->sd, i); : 
2
str : 		if (!cpumask_test_cpu(i, sched_domain_span(sibling)))[55]
strstr : INIT : 		if (!cpumask_test_cpu(i, sched_domain_span(sibling))) : 
2
strstr : if : 		if (!cpumask_test_cpu(i, sched_domain_span(sibling))) : 
2
strstr : for : 		if (!cpumask_test_cpu(i, sched_domain_span(sibling))) : 
2
strstr : while : 		if (!cpumask_test_cpu(i, sched_domain_span(sibling))) : 
2
str : 			continue;[12]
strstr : INIT : 			continue; : 
2
strstr : if : 			continue; : 
2
strstr : for : 			continue; : 
2
strstr : while : 			continue; : 
2
str : 		cpumask_set_cpu(i, sched_group_mask(sg));[43]
strstr : INIT : 		cpumask_set_cpu(i, sched_group_mask(sg)); : 
2
strstr : if : 		cpumask_set_cpu(i, sched_group_mask(sg)); : 
2
strstr : for : 		cpumask_set_cpu(i, sched_group_mask(sg)); : 
2
strstr : while : 		cpumask_set_cpu(i, sched_group_mask(sg)); : 
2
str :  * Return the canonical balance cpu for this group, this is the first cpu[73]
strstr : INIT :  * Return the canonical balance cpu for this group, this is the first cpu : 
2
strstr : if :  * Return the canonical balance cpu for this group, this is the first cpu : 
2
strstr : for :  * Return the canonical balance cpu for this group, this is the first cpu : 
2
strstr : while :  * Return the canonical balance cpu for this group, this is the first cpu : 
2
str :  * of this group that's also in the iteration mask.[51]
strstr : INIT :  * of this group that's also in the iteration mask. : 
2
strstr : if :  * of this group that's also in the iteration mask. : 
2
strstr : for :  * of this group that's also in the iteration mask. : 
2
strstr : while :  * of this group that's also in the iteration mask. : 
2
str :  */[3]
strstr : INIT :  */ : 
2
strstr : if :  */ : 
2
strstr : for :  */ : 
2
strstr : while :  */ : 
2
str : int group_balance_cpu(struct sched_group *sg)[45]
strstr : INIT : int group_balance_cpu(struct sched_group *sg) : 
2
strstr : if : int group_balance_cpu(struct sched_group *sg) : 
2
strstr : for : int group_balance_cpu(struct sched_group *sg) : 
2
strstr : while : int group_balance_cpu(struct sched_group *sg) : 
2
str : 	return cpumask_first_and(sched_group_cpus(sg), sched_group_mask(sg));[70]
strstr : INIT : 	return cpumask_first_and(sched_group_cpus(sg), sched_group_mask(sg)); : 
2
strstr : if : 	return cpumask_first_and(sched_group_cpus(sg), sched_group_mask(sg)); : 
2
strstr : for : 	return cpumask_first_and(sched_group_cpus(sg), sched_group_mask(sg)); : 
2
strstr : while : 	return cpumask_first_and(sched_group_cpus(sg), sched_group_mask(sg)); : 
2
str : static int[10]
strstr : INIT : static int : 
2
strstr : if : static int : 
2
strstr : for : static int : 
2
strstr : while : static int : 
2
str : build_overlap_sched_groups(struct sched_domain *sd, int cpu)[60]
strstr : INIT : build_overlap_sched_groups(struct sched_domain *sd, int cpu) : 
2
strstr : if : build_overlap_sched_groups(struct sched_domain *sd, int cpu) : 
2
strstr : for : build_overlap_sched_groups(struct sched_domain *sd, int cpu) : 
2
strstr : while : build_overlap_sched_groups(struct sched_domain *sd, int cpu) : 
2
str : 	struct sched_group *first = NULL, *last = NULL, *groups = NULL, *sg;[69]
strstr : INIT : 	struct sched_group *first = NULL, *last = NULL, *groups = NULL, *sg; : 
2
strstr : if : 	struct sched_group *first = NULL, *last = NULL, *groups = NULL, *sg; : 
2
strstr : for : 	struct sched_group *first = NULL, *last = NULL, *groups = NULL, *sg; : 
2
strstr : while : 	struct sched_group *first = NULL, *last = NULL, *groups = NULL, *sg; : 
2
str : 	const struct cpumask *span = sched_domain_span(sd);[52]
strstr : INIT : 	const struct cpumask *span = sched_domain_span(sd); : 
2
strstr : if : 	const struct cpumask *span = sched_domain_span(sd); : 
2
strstr : for : 	const struct cpumask *span = sched_domain_span(sd); : 
2
strstr : while : 	const struct cpumask *span = sched_domain_span(sd); : 
2
str : 	struct cpumask *covered = sched_domains_tmpmask;[49]
strstr : INIT : 	struct cpumask *covered = sched_domains_tmpmask; : 
2
strstr : if : 	struct cpumask *covered = sched_domains_tmpmask; : 
2
strstr : for : 	struct cpumask *covered = sched_domains_tmpmask; : 
2
strstr : while : 	struct cpumask *covered = sched_domains_tmpmask; : 
2
str : 	struct sd_data *sdd = sd->private;[35]
strstr : INIT : 	struct sd_data *sdd = sd->private; : 
2
strstr : if : 	struct sd_data *sdd = sd->private; : 
2
strstr : for : 	struct sd_data *sdd = sd->private; : 
2
strstr : while : 	struct sd_data *sdd = sd->private; : 
2
str : 	struct sched_domain *child;[28]
strstr : INIT : 	struct sched_domain *child; : 
2
strstr : if : 	struct sched_domain *child; : 
2
strstr : for : 	struct sched_domain *child; : 
2
strstr : while : 	struct sched_domain *child; : 
2
str : 	int i;[7]
strstr : INIT : 	int i; : 
2
strstr : if : 	int i; : 
2
strstr : for : 	int i; : 
2
strstr : while : 	int i; : 
2
str : 	cpumask_clear(covered);[24]
strstr : INIT : 	cpumask_clear(covered); : 
2
strstr : if : 	cpumask_clear(covered); : 
2
strstr : for : 	cpumask_clear(covered); : 
2
strstr : while : 	cpumask_clear(covered); : 
2
str : 	for_each_cpu(i, span) {[24]
strstr : INIT : 	for_each_cpu(i, span) { : 
2
strstr : if : 	for_each_cpu(i, span) { : 
2
strstr : for : 	for_each_cpu(i, span) { : 
2
strstr : while : 	for_each_cpu(i, span) { : 
2
str : 		struct cpumask *sg_span;[26]
strstr : INIT : 		struct cpumask *sg_span; : 
2
strstr : if : 		struct cpumask *sg_span; : 
2
strstr : for : 		struct cpumask *sg_span; : 
2
strstr : while : 		struct cpumask *sg_span; : 
2
str : 		if (cpumask_test_cpu(i, covered))[35]
strstr : INIT : 		if (cpumask_test_cpu(i, covered)) : 
2
strstr : if : 		if (cpumask_test_cpu(i, covered)) : 
2
strstr : for : 		if (cpumask_test_cpu(i, covered)) : 
2
strstr : while : 		if (cpumask_test_cpu(i, covered)) : 
2
str : 			continue;[12]
strstr : INIT : 			continue; : 
2
strstr : if : 			continue; : 
2
strstr : for : 			continue; : 
2
strstr : while : 			continue; : 
2
str : 		child = *per_cpu_ptr(sdd->sd, i);[35]
strstr : INIT : 		child = *per_cpu_ptr(sdd->sd, i); : 
2
strstr : if : 		child = *per_cpu_ptr(sdd->sd, i); : 
2
strstr : for : 		child = *per_cpu_ptr(sdd->sd, i); : 
2
strstr : while : 		child = *per_cpu_ptr(sdd->sd, i); : 
2
str : 		/* See the comment near build_group_mask(). */[48]
strstr : INIT : 		/* See the comment near build_group_mask(). */ : 
2
strstr : if : 		/* See the comment near build_group_mask(). */ : 
2
strstr : for : 		/* See the comment near build_group_mask(). */ : 
2
strstr : while : 		/* See the comment near build_group_mask(). */ : 
2
str : 		if (!cpumask_test_cpu(i, sched_domain_span(child)))[53]
strstr : INIT : 		if (!cpumask_test_cpu(i, sched_domain_span(child))) : 
2
strstr : if : 		if (!cpumask_test_cpu(i, sched_domain_span(child))) : 
2
strstr : for : 		if (!cpumask_test_cpu(i, sched_domain_span(child))) : 
2
strstr : while : 		if (!cpumask_test_cpu(i, sched_domain_span(child))) : 
2
str : 			continue;[12]
strstr : INIT : 			continue; : 
2
strstr : if : 			continue; : 
2
strstr : for : 			continue; : 
2
strstr : while : 			continue; : 
2
str : 		sg = kzalloc_node(sizeof(struct sched_group) + cpumask_size(),[64]
strstr : INIT : 		sg = kzalloc_node(sizeof(struct sched_group) + cpumask_size(), : 
2
strstr : if : 		sg = kzalloc_node(sizeof(struct sched_group) + cpumask_size(), : 
2
strstr : for : 		sg = kzalloc_node(sizeof(struct sched_group) + cpumask_size(), : 
2
strstr : while : 		sg = kzalloc_node(sizeof(struct sched_group) + cpumask_size(), : 
2
str : 				GFP_KERNEL, cpu_to_node(cpu));[34]
strstr : INIT : 				GFP_KERNEL, cpu_to_node(cpu)); : 
2
strstr : if : 				GFP_KERNEL, cpu_to_node(cpu)); : 
2
strstr : for : 				GFP_KERNEL, cpu_to_node(cpu)); : 
2
strstr : while : 				GFP_KERNEL, cpu_to_node(cpu)); : 
2
str : 		if (!sg)[10]
strstr : INIT : 		if (!sg) : 
2
strstr : if : 		if (!sg) : 
2
strstr : for : 		if (!sg) : 
2
strstr : while : 		if (!sg) : 
2
str : 			goto fail;[13]
strstr : INIT : 			goto fail; : 
2
strstr : if : 			goto fail; : 
2
strstr : for : 			goto fail; : 
2
strstr : while : 			goto fail; : 
2
str : 		sg_span = sched_group_cpus(sg);[33]
strstr : INIT : 		sg_span = sched_group_cpus(sg); : 
2
strstr : if : 		sg_span = sched_group_cpus(sg); : 
2
strstr : for : 		sg_span = sched_group_cpus(sg); : 
2
strstr : while : 		sg_span = sched_group_cpus(sg); : 
2
str : 		if (child->child) {[21]
strstr : INIT : 		if (child->child) { : 
2
strstr : if : 		if (child->child) { : 
2
strstr : for : 		if (child->child) { : 
2
strstr : while : 		if (child->child) { : 
2
str : 			child = child->child;[24]
strstr : INIT : 			child = child->child; : 
2
strstr : if : 			child = child->child; : 
2
strstr : for : 			child = child->child; : 
2
strstr : while : 			child = child->child; : 
2
str : 			cpumask_copy(sg_span, sched_domain_span(child));[51]
strstr : INIT : 			cpumask_copy(sg_span, sched_domain_span(child)); : 
2
strstr : if : 			cpumask_copy(sg_span, sched_domain_span(child)); : 
2
strstr : for : 			cpumask_copy(sg_span, sched_domain_span(child)); : 
2
strstr : while : 			cpumask_copy(sg_span, sched_domain_span(child)); : 
2
str : 		} else[8]
strstr : INIT : 		} else : 
2
strstr : if : 		} else : 
2
strstr : for : 		} else : 
2
strstr : while : 		} else : 
2
str : 			cpumask_set_cpu(i, sg_span);[31]
strstr : INIT : 			cpumask_set_cpu(i, sg_span); : 
2
strstr : if : 			cpumask_set_cpu(i, sg_span); : 
2
strstr : for : 			cpumask_set_cpu(i, sg_span); : 
2
strstr : while : 			cpumask_set_cpu(i, sg_span); : 
2
str : 		cpumask_or(covered, covered, sg_span);[40]
strstr : INIT : 		cpumask_or(covered, covered, sg_span); : 
2
strstr : if : 		cpumask_or(covered, covered, sg_span); : 
2
strstr : for : 		cpumask_or(covered, covered, sg_span); : 
2
strstr : while : 		cpumask_or(covered, covered, sg_span); : 
2
str : 		sg->sgp = *per_cpu_ptr(sdd->sgp, i);[38]
strstr : INIT : 		sg->sgp = *per_cpu_ptr(sdd->sgp, i); : 
2
strstr : if : 		sg->sgp = *per_cpu_ptr(sdd->sgp, i); : 
2
strstr : for : 		sg->sgp = *per_cpu_ptr(sdd->sgp, i); : 
2
strstr : while : 		sg->sgp = *per_cpu_ptr(sdd->sgp, i); : 
2
str : 		if (atomic_inc_return(&sg->sgp->ref) == 1)[44]
strstr : INIT : 		if (atomic_inc_return(&sg->sgp->ref) == 1) : 
2
strstr : if : 		if (atomic_inc_return(&sg->sgp->ref) == 1) : 
2
strstr : for : 		if (atomic_inc_return(&sg->sgp->ref) == 1) : 
2
strstr : while : 		if (atomic_inc_return(&sg->sgp->ref) == 1) : 
2
str : 			build_group_mask(sd, sg);[28]
strstr : INIT : 			build_group_mask(sd, sg); : 
2
strstr : if : 			build_group_mask(sd, sg); : 
2
strstr : for : 			build_group_mask(sd, sg); : 
2
strstr : while : 			build_group_mask(sd, sg); : 
2
str : 		/*[4]
strstr : INIT : 		/* : 
2
strstr : if : 		/* : 
2
strstr : for : 		/* : 
2
strstr : while : 		/* : 
2
str : 		 * Initialize sgp->power such that even if we mess up the[59]
strstr : INIT : 		 * Initialize sgp->power such that even if we mess up the : 
2
strstr : if : 		 * Initialize sgp->power such that even if we mess up the : 
2
strstr : for : 		 * Initialize sgp->power such that even if we mess up the : 
2
strstr : while : 		 * Initialize sgp->power such that even if we mess up the : 
2
str : 		 * domains and no possible iteration will get us here, we won't[65]
strstr : INIT : 		 * domains and no possible iteration will get us here, we won't : 
2
strstr : if : 		 * domains and no possible iteration will get us here, we won't : 
2
strstr : for : 		 * domains and no possible iteration will get us here, we won't : 
2
strstr : while : 		 * domains and no possible iteration will get us here, we won't : 
2
str : 		 * die on a /0 trap.[22]
strstr : INIT : 		 * die on a /0 trap. : 
2
strstr : if : 		 * die on a /0 trap. : 
2
strstr : for : 		 * die on a /0 trap. : 
2
strstr : while : 		 * die on a /0 trap. : 
2
str : 		 */[5]
strstr : INIT : 		 */ : 
2
strstr : if : 		 */ : 
2
strstr : for : 		 */ : 
2
strstr : while : 		 */ : 
2
str : 		sg->sgp->power = SCHED_POWER_SCALE * cpumask_weight(sg_span);[63]
strstr : INIT : 		sg->sgp->power = SCHED_POWER_SCALE * cpumask_weight(sg_span); : 
2
strstr : if : 		sg->sgp->power = SCHED_POWER_SCALE * cpumask_weight(sg_span); : 
2
strstr : for : 		sg->sgp->power = SCHED_POWER_SCALE * cpumask_weight(sg_span); : 
2
strstr : while : 		sg->sgp->power = SCHED_POWER_SCALE * cpumask_weight(sg_span); : 
2
str : 		sg->sgp->power_orig = sg->sgp->power;[39]
strstr : INIT : 		sg->sgp->power_orig = sg->sgp->power; : 
2
strstr : if : 		sg->sgp->power_orig = sg->sgp->power; : 
2
strstr : for : 		sg->sgp->power_orig = sg->sgp->power; : 
2
strstr : while : 		sg->sgp->power_orig = sg->sgp->power; : 
2
str : 		/*[4]
strstr : INIT : 		/* : 
2
strstr : if : 		/* : 
2
strstr : for : 		/* : 
2
strstr : while : 		/* : 
2
str : 		 * Make sure the first group of this domain contains the[58]
strstr : INIT : 		 * Make sure the first group of this domain contains the : 
2
strstr : if : 		 * Make sure the first group of this domain contains the : 
2
strstr : for : 		 * Make sure the first group of this domain contains the : 
2
strstr : while : 		 * Make sure the first group of this domain contains the : 
2
str : 		 * canonical balance cpu. Otherwise the sched_domain iteration[64]
strstr : INIT : 		 * canonical balance cpu. Otherwise the sched_domain iteration : 
2
strstr : if : 		 * canonical balance cpu. Otherwise the sched_domain iteration : 
2
strstr : for : 		 * canonical balance cpu. Otherwise the sched_domain iteration : 
2
strstr : while : 		 * canonical balance cpu. Otherwise the sched_domain iteration : 
2
str : 		 * breaks. See update_sg_lb_stats().[38]
strstr : INIT : 		 * breaks. See update_sg_lb_stats(). : 
2
strstr : if : 		 * breaks. See update_sg_lb_stats(). : 
2
strstr : for : 		 * breaks. See update_sg_lb_stats(). : 
2
strstr : while : 		 * breaks. See update_sg_lb_stats(). : 
2
str : 		 */[5]
strstr : INIT : 		 */ : 
2
strstr : if : 		 */ : 
2
strstr : for : 		 */ : 
2
strstr : while : 		 */ : 
2
str : 		if ((!groups && cpumask_test_cpu(cpu, sg_span)) ||[52]
strstr : INIT : 		if ((!groups && cpumask_test_cpu(cpu, sg_span)) || : 
2
strstr : if : 		if ((!groups && cpumask_test_cpu(cpu, sg_span)) || : 
2
strstr : for : 		if ((!groups && cpumask_test_cpu(cpu, sg_span)) || : 
2
strstr : while : 		if ((!groups && cpumask_test_cpu(cpu, sg_span)) || : 
2
str : 		    group_balance_cpu(sg) == cpu)[35]
strstr : INIT : 		    group_balance_cpu(sg) == cpu) : 
2
strstr : if : 		    group_balance_cpu(sg) == cpu) : 
2
strstr : for : 		    group_balance_cpu(sg) == cpu) : 
2
strstr : while : 		    group_balance_cpu(sg) == cpu) : 
2
str : 			groups = sg;[15]
strstr : INIT : 			groups = sg; : 
2
strstr : if : 			groups = sg; : 
2
strstr : for : 			groups = sg; : 
2
strstr : while : 			groups = sg; : 
2
str : 		if (!first)[13]
strstr : INIT : 		if (!first) : 
2
strstr : if : 		if (!first) : 
2
strstr : for : 		if (!first) : 
2
strstr : while : 		if (!first) : 
2
str : 			first = sg;[14]
strstr : INIT : 			first = sg; : 
2
strstr : if : 			first = sg; : 
2
strstr : for : 			first = sg; : 
2
strstr : while : 			first = sg; : 
2
str : 		if (last)[11]
strstr : INIT : 		if (last) : 
2
strstr : if : 		if (last) : 
2
strstr : for : 		if (last) : 
2
strstr : while : 		if (last) : 
2
str : 			last->next = sg;[19]
strstr : INIT : 			last->next = sg; : 
2
strstr : if : 			last->next = sg; : 
2
strstr : for : 			last->next = sg; : 
2
strstr : while : 			last->next = sg; : 
2
str : 		last = sg;[12]
strstr : INIT : 		last = sg; : 
2
strstr : if : 		last = sg; : 
2
strstr : for : 		last = sg; : 
2
strstr : while : 		last = sg; : 
2
str : 		last->next = first;[21]
strstr : INIT : 		last->next = first; : 
2
strstr : if : 		last->next = first; : 
2
strstr : for : 		last->next = first; : 
2
strstr : while : 		last->next = first; : 
2
str : 	sd->groups = groups;[21]
strstr : INIT : 	sd->groups = groups; : 
2
strstr : if : 	sd->groups = groups; : 
2
strstr : for : 	sd->groups = groups; : 
2
strstr : while : 	sd->groups = groups; : 
2
str : 	return 0;[10]
strstr : INIT : 	return 0; : 
2
strstr : if : 	return 0; : 
2
strstr : for : 	return 0; : 
2
strstr : while : 	return 0; : 
2
str : fail:[5]
strstr : INIT : fail: : 
2
strstr : if : fail: : 
2
strstr : for : fail: : 
2
strstr : while : fail: : 
2
str : 	free_sched_groups(first, 0);[29]
strstr : INIT : 	free_sched_groups(first, 0); : 
2
strstr : if : 	free_sched_groups(first, 0); : 
2
strstr : for : 	free_sched_groups(first, 0); : 
2
strstr : while : 	free_sched_groups(first, 0); : 
2
str : 	return -ENOMEM;[16]
strstr : INIT : 	return -ENOMEM; : 
2
strstr : if : 	return -ENOMEM; : 
2
strstr : for : 	return -ENOMEM; : 
2
strstr : while : 	return -ENOMEM; : 
2
str : static int get_group(int cpu, struct sd_data *sdd, struct sched_group **sg)[75]
strstr : INIT : static int get_group(int cpu, struct sd_data *sdd, struct sched_group **sg) : 
2
strstr : if : static int get_group(int cpu, struct sd_data *sdd, struct sched_group **sg) : 
2
strstr : for : static int get_group(int cpu, struct sd_data *sdd, struct sched_group **sg) : 
2
strstr : while : static int get_group(int cpu, struct sd_data *sdd, struct sched_group **sg) : 
2
str : 	struct sched_domain *sd = *per_cpu_ptr(sdd->sd, cpu);[54]
strstr : INIT : 	struct sched_domain *sd = *per_cpu_ptr(sdd->sd, cpu); : 
2
strstr : if : 	struct sched_domain *sd = *per_cpu_ptr(sdd->sd, cpu); : 
2
strstr : for : 	struct sched_domain *sd = *per_cpu_ptr(sdd->sd, cpu); : 
2
strstr : while : 	struct sched_domain *sd = *per_cpu_ptr(sdd->sd, cpu); : 
2
str : 	struct sched_domain *child = sd->child;[40]
strstr : INIT : 	struct sched_domain *child = sd->child; : 
2
strstr : if : 	struct sched_domain *child = sd->child; : 
2
strstr : for : 	struct sched_domain *child = sd->child; : 
2
strstr : while : 	struct sched_domain *child = sd->child; : 
2
str : 	if (child)[11]
strstr : INIT : 	if (child) : 
2
strstr : if : 	if (child) : 
2
strstr : for : 	if (child) : 
2
strstr : while : 	if (child) : 
2
str : 		cpu = cpumask_first(sched_domain_span(child));[48]
strstr : INIT : 		cpu = cpumask_first(sched_domain_span(child)); : 
2
strstr : if : 		cpu = cpumask_first(sched_domain_span(child)); : 
2
strstr : for : 		cpu = cpumask_first(sched_domain_span(child)); : 
2
strstr : while : 		cpu = cpumask_first(sched_domain_span(child)); : 
2
str : 	if (sg) {[10]
strstr : INIT : 	if (sg) { : 
2
strstr : if : 	if (sg) { : 
2
strstr : for : 	if (sg) { : 
2
strstr : while : 	if (sg) { : 
2
str : 		*sg = *per_cpu_ptr(sdd->sg, cpu);[35]
strstr : INIT : 		*sg = *per_cpu_ptr(sdd->sg, cpu); : 
2
strstr : if : 		*sg = *per_cpu_ptr(sdd->sg, cpu); : 
2
strstr : for : 		*sg = *per_cpu_ptr(sdd->sg, cpu); : 
2
strstr : while : 		*sg = *per_cpu_ptr(sdd->sg, cpu); : 
2
str : 		(*sg)->sgp = *per_cpu_ptr(sdd->sgp, cpu);[43]
strstr : INIT : 		(*sg)->sgp = *per_cpu_ptr(sdd->sgp, cpu); : 
2
strstr : if : 		(*sg)->sgp = *per_cpu_ptr(sdd->sgp, cpu); : 
2
strstr : for : 		(*sg)->sgp = *per_cpu_ptr(sdd->sgp, cpu); : 
2
strstr : while : 		(*sg)->sgp = *per_cpu_ptr(sdd->sgp, cpu); : 
2
str : 		atomic_set(&(*sg)->sgp->ref, 1); /* for claim_allocations */[62]
strstr : INIT : 		atomic_set(&(*sg)->sgp->ref, 1); /* for claim_allocations */ : 
2
strstr : if : 		atomic_set(&(*sg)->sgp->ref, 1); /* for claim_allocations */ : 
2
strstr : for : 		atomic_set(&(*sg)->sgp->ref, 1); /* for claim_allocations */ : 
2
strstr : while : 		atomic_set(&(*sg)->sgp->ref, 1); /* for claim_allocations */ : 
2
str : 	return cpu;[12]
strstr : INIT : 	return cpu; : 
2
strstr : if : 	return cpu; : 
2
strstr : for : 	return cpu; : 
2
strstr : while : 	return cpu; : 
2
str :  * build_sched_groups will build a circular linked list of the groups[69]
strstr : INIT :  * build_sched_groups will build a circular linked list of the groups : 
2
strstr : if :  * build_sched_groups will build a circular linked list of the groups : 
2
strstr : for :  * build_sched_groups will build a circular linked list of the groups : 
2
strstr : while :  * build_sched_groups will build a circular linked list of the groups : 
2
str :  * covered by the given span, and will set each group's ->cpumask correctly,[76]
strstr : INIT :  * covered by the given span, and will set each group's ->cpumask correctly, : 
2
strstr : if :  * covered by the given span, and will set each group's ->cpumask correctly, : 
2
strstr : for :  * covered by the given span, and will set each group's ->cpumask correctly, : 
2
strstr : while :  * covered by the given span, and will set each group's ->cpumask correctly, : 
2
str :  * and ->cpu_power to 0.[24]
strstr : INIT :  * and ->cpu_power to 0. : 
2
strstr : if :  * and ->cpu_power to 0. : 
2
strstr : for :  * and ->cpu_power to 0. : 
2
strstr : while :  * and ->cpu_power to 0. : 
2
str :  * Assumes the sched_domain tree is fully constructed[53]
strstr : INIT :  * Assumes the sched_domain tree is fully constructed : 
2
strstr : if :  * Assumes the sched_domain tree is fully constructed : 
2
strstr : for :  * Assumes the sched_domain tree is fully constructed : 
2
strstr : while :  * Assumes the sched_domain tree is fully constructed : 
2
str :  */[3]
strstr : INIT :  */ : 
2
strstr : if :  */ : 
2
strstr : for :  */ : 
2
strstr : while :  */ : 
2
str : static int[10]
strstr : INIT : static int : 
2
strstr : if : static int : 
2
strstr : for : static int : 
2
strstr : while : static int : 
2
str : build_sched_groups(struct sched_domain *sd, int cpu)[52]
strstr : INIT : build_sched_groups(struct sched_domain *sd, int cpu) : 
2
strstr : if : build_sched_groups(struct sched_domain *sd, int cpu) : 
2
strstr : for : build_sched_groups(struct sched_domain *sd, int cpu) : 
2
strstr : while : build_sched_groups(struct sched_domain *sd, int cpu) : 
2
str : 	struct sched_group *first = NULL, *last = NULL;[48]
strstr : INIT : 	struct sched_group *first = NULL, *last = NULL; : 
2
strstr : if : 	struct sched_group *first = NULL, *last = NULL; : 
2
strstr : for : 	struct sched_group *first = NULL, *last = NULL; : 
2
strstr : while : 	struct sched_group *first = NULL, *last = NULL; : 
2
str : 	struct sd_data *sdd = sd->private;[35]
strstr : INIT : 	struct sd_data *sdd = sd->private; : 
2
strstr : if : 	struct sd_data *sdd = sd->private; : 
2
strstr : for : 	struct sd_data *sdd = sd->private; : 
2
strstr : while : 	struct sd_data *sdd = sd->private; : 
2
str : 	const struct cpumask *span = sched_domain_span(sd);[52]
strstr : INIT : 	const struct cpumask *span = sched_domain_span(sd); : 
2
strstr : if : 	const struct cpumask *span = sched_domain_span(sd); : 
2
strstr : for : 	const struct cpumask *span = sched_domain_span(sd); : 
2
strstr : while : 	const struct cpumask *span = sched_domain_span(sd); : 
2
str : 	struct cpumask *covered;[25]
strstr : INIT : 	struct cpumask *covered; : 
2
strstr : if : 	struct cpumask *covered; : 
2
strstr : for : 	struct cpumask *covered; : 
2
strstr : while : 	struct cpumask *covered; : 
2
str : 	int i;[7]
strstr : INIT : 	int i; : 
2
strstr : if : 	int i; : 
2
strstr : for : 	int i; : 
2
strstr : while : 	int i; : 
2
str : 	get_group(cpu, sdd, &sd->groups);[34]
strstr : INIT : 	get_group(cpu, sdd, &sd->groups); : 
2
strstr : if : 	get_group(cpu, sdd, &sd->groups); : 
2
strstr : for : 	get_group(cpu, sdd, &sd->groups); : 
2
strstr : while : 	get_group(cpu, sdd, &sd->groups); : 
2
str : 	atomic_inc(&sd->groups->ref);[30]
strstr : INIT : 	atomic_inc(&sd->groups->ref); : 
2
strstr : if : 	atomic_inc(&sd->groups->ref); : 
2
strstr : for : 	atomic_inc(&sd->groups->ref); : 
2
strstr : while : 	atomic_inc(&sd->groups->ref); : 
2
str : 	if (cpu != cpumask_first(span))[32]
strstr : INIT : 	if (cpu != cpumask_first(span)) : 
2
strstr : if : 	if (cpu != cpumask_first(span)) : 
2
strstr : for : 	if (cpu != cpumask_first(span)) : 
2
strstr : while : 	if (cpu != cpumask_first(span)) : 
2
str : 		return 0;[11]
strstr : INIT : 		return 0; : 
2
strstr : if : 		return 0; : 
2
strstr : for : 		return 0; : 
2
strstr : while : 		return 0; : 
2
str : 	lockdep_assert_held(&sched_domains_mutex);[43]
strstr : INIT : 	lockdep_assert_held(&sched_domains_mutex); : 
2
strstr : if : 	lockdep_assert_held(&sched_domains_mutex); : 
2
strstr : for : 	lockdep_assert_held(&sched_domains_mutex); : 
2
strstr : while : 	lockdep_assert_held(&sched_domains_mutex); : 
2
str : 	covered = sched_domains_tmpmask;[33]
strstr : INIT : 	covered = sched_domains_tmpmask; : 
2
strstr : if : 	covered = sched_domains_tmpmask; : 
2
strstr : for : 	covered = sched_domains_tmpmask; : 
2
strstr : while : 	covered = sched_domains_tmpmask; : 
2
str : 	cpumask_clear(covered);[24]
strstr : INIT : 	cpumask_clear(covered); : 
2
strstr : if : 	cpumask_clear(covered); : 
2
strstr : for : 	cpumask_clear(covered); : 
2
strstr : while : 	cpumask_clear(covered); : 
2
str : 	for_each_cpu(i, span) {[24]
strstr : INIT : 	for_each_cpu(i, span) { : 
2
strstr : if : 	for_each_cpu(i, span) { : 
2
strstr : for : 	for_each_cpu(i, span) { : 
2
strstr : while : 	for_each_cpu(i, span) { : 
2
str : 		struct sched_group *sg;[25]
strstr : INIT : 		struct sched_group *sg; : 
2
strstr : if : 		struct sched_group *sg; : 
2
strstr : for : 		struct sched_group *sg; : 
2
strstr : while : 		struct sched_group *sg; : 
2
str : 		int group, j;[15]
strstr : INIT : 		int group, j; : 
2
strstr : if : 		int group, j; : 
2
strstr : for : 		int group, j; : 
2
strstr : while : 		int group, j; : 
2
str : 		if (cpumask_test_cpu(i, covered))[35]
strstr : INIT : 		if (cpumask_test_cpu(i, covered)) : 
2
strstr : if : 		if (cpumask_test_cpu(i, covered)) : 
2
strstr : for : 		if (cpumask_test_cpu(i, covered)) : 
2
strstr : while : 		if (cpumask_test_cpu(i, covered)) : 
2
str : 			continue;[12]
strstr : INIT : 			continue; : 
2
strstr : if : 			continue; : 
2
strstr : for : 			continue; : 
2
strstr : while : 			continue; : 
2
str : 		group = get_group(i, sdd, &sg);[33]
strstr : INIT : 		group = get_group(i, sdd, &sg); : 
2
strstr : if : 		group = get_group(i, sdd, &sg); : 
2
strstr : for : 		group = get_group(i, sdd, &sg); : 
2
strstr : while : 		group = get_group(i, sdd, &sg); : 
2
str : 		cpumask_clear(sched_group_cpus(sg));[38]
strstr : INIT : 		cpumask_clear(sched_group_cpus(sg)); : 
2
strstr : if : 		cpumask_clear(sched_group_cpus(sg)); : 
2
strstr : for : 		cpumask_clear(sched_group_cpus(sg)); : 
2
strstr : while : 		cpumask_clear(sched_group_cpus(sg)); : 
2
str : 		sg->sgp->power = 0;[21]
strstr : INIT : 		sg->sgp->power = 0; : 
2
strstr : if : 		sg->sgp->power = 0; : 
2
strstr : for : 		sg->sgp->power = 0; : 
2
strstr : while : 		sg->sgp->power = 0; : 
2
str : 		cpumask_setall(sched_group_mask(sg));[39]
strstr : INIT : 		cpumask_setall(sched_group_mask(sg)); : 
2
strstr : if : 		cpumask_setall(sched_group_mask(sg)); : 
2
strstr : for : 		cpumask_setall(sched_group_mask(sg)); : 
2
strstr : while : 		cpumask_setall(sched_group_mask(sg)); : 
2
str : 		for_each_cpu(j, span) {[25]
strstr : INIT : 		for_each_cpu(j, span) { : 
2
strstr : if : 		for_each_cpu(j, span) { : 
2
strstr : for : 		for_each_cpu(j, span) { : 
2
strstr : while : 		for_each_cpu(j, span) { : 
2
str : 			if (get_group(j, sdd, NULL) != group)[40]
strstr : INIT : 			if (get_group(j, sdd, NULL) != group) : 
2
strstr : if : 			if (get_group(j, sdd, NULL) != group) : 
2
strstr : for : 			if (get_group(j, sdd, NULL) != group) : 
2
strstr : while : 			if (get_group(j, sdd, NULL) != group) : 
2
str : 				continue;[13]
strstr : INIT : 				continue; : 
2
strstr : if : 				continue; : 
2
strstr : for : 				continue; : 
2
strstr : while : 				continue; : 
2
str : 			cpumask_set_cpu(j, covered);[31]
strstr : INIT : 			cpumask_set_cpu(j, covered); : 
2
strstr : if : 			cpumask_set_cpu(j, covered); : 
2
strstr : for : 			cpumask_set_cpu(j, covered); : 
2
strstr : while : 			cpumask_set_cpu(j, covered); : 
2
str : 			cpumask_set_cpu(j, sched_group_cpus(sg));[44]
strstr : INIT : 			cpumask_set_cpu(j, sched_group_cpus(sg)); : 
2
strstr : if : 			cpumask_set_cpu(j, sched_group_cpus(sg)); : 
2
strstr : for : 			cpumask_set_cpu(j, sched_group_cpus(sg)); : 
2
strstr : while : 			cpumask_set_cpu(j, sched_group_cpus(sg)); : 
2
str : 		}[3]
strstr : INIT : 		} : 
2
strstr : if : 		} : 
2
strstr : for : 		} : 
2
strstr : while : 		} : 
2
str : 		if (!first)[13]
strstr : INIT : 		if (!first) : 
2
strstr : if : 		if (!first) : 
2
strstr : for : 		if (!first) : 
2
strstr : while : 		if (!first) : 
2
str : 			first = sg;[14]
strstr : INIT : 			first = sg; : 
2
strstr : if : 			first = sg; : 
2
strstr : for : 			first = sg; : 
2
strstr : while : 			first = sg; : 
2
str : 		if (last)[11]
strstr : INIT : 		if (last) : 
2
strstr : if : 		if (last) : 
2
strstr : for : 		if (last) : 
2
strstr : while : 		if (last) : 
2
str : 			last->next = sg;[19]
strstr : INIT : 			last->next = sg; : 
2
strstr : if : 			last->next = sg; : 
2
strstr : for : 			last->next = sg; : 
2
strstr : while : 			last->next = sg; : 
2
str : 		last = sg;[12]
strstr : INIT : 		last = sg; : 
2
strstr : if : 		last = sg; : 
2
strstr : for : 		last = sg; : 
2
strstr : while : 		last = sg; : 
2
str : 	last->next = first;[20]
strstr : INIT : 	last->next = first; : 
2
strstr : if : 	last->next = first; : 
2
strstr : for : 	last->next = first; : 
2
strstr : while : 	last->next = first; : 
2
str : 	return 0;[10]
strstr : INIT : 	return 0; : 
2
strstr : if : 	return 0; : 
2
strstr : for : 	return 0; : 
2
strstr : while : 	return 0; : 
2
str :  * Initialize sched groups cpu_power.[37]
strstr : INIT :  * Initialize sched groups cpu_power. : 
2
strstr : if :  * Initialize sched groups cpu_power. : 
2
strstr : for :  * Initialize sched groups cpu_power. : 
2
strstr : while :  * Initialize sched groups cpu_power. : 
2
str :  * cpu_power indicates the capacity of sched group, which is used while[71]
strstr : INIT :  * cpu_power indicates the capacity of sched group, which is used while : 
2
strstr : if :  * cpu_power indicates the capacity of sched group, which is used while : 
2
strstr : for :  * cpu_power indicates the capacity of sched group, which is used while : 
2
strstr : while :  * cpu_power indicates the capacity of sched group, which is used while : 
2
str :  * distributing the load between different sched groups in a sched domain.[74]
strstr : INIT :  * distributing the load between different sched groups in a sched domain. : 
2
strstr : if :  * distributing the load between different sched groups in a sched domain. : 
2
strstr : for :  * distributing the load between different sched groups in a sched domain. : 
2
strstr : while :  * distributing the load between different sched groups in a sched domain. : 
2
str :  * Typically cpu_power for all the groups in a sched domain will be same unless[79]
strstr : INIT :  * Typically cpu_power for all the groups in a sched domain will be same unless : 
2
strstr : if :  * Typically cpu_power for all the groups in a sched domain will be same unless : 
2
strstr : for :  * Typically cpu_power for all the groups in a sched domain will be same unless : 
2
strstr : while :  * Typically cpu_power for all the groups in a sched domain will be same unless : 
2
str :  * there are asymmetries in the topology. If there are asymmetries, group[73]
strstr : INIT :  * there are asymmetries in the topology. If there are asymmetries, group : 
2
strstr : if :  * there are asymmetries in the topology. If there are asymmetries, group : 
2
strstr : for :  * there are asymmetries in the topology. If there are asymmetries, group : 
2
strstr : while :  * there are asymmetries in the topology. If there are asymmetries, group : 
2
str :  * having more cpu_power will pickup more load compared to the group having[75]
strstr : INIT :  * having more cpu_power will pickup more load compared to the group having : 
2
strstr : if :  * having more cpu_power will pickup more load compared to the group having : 
2
strstr : for :  * having more cpu_power will pickup more load compared to the group having : 
2
strstr : while :  * having more cpu_power will pickup more load compared to the group having : 
2
str :  * less cpu_power.[18]
strstr : INIT :  * less cpu_power. : 
2
strstr : if :  * less cpu_power. : 
2
strstr : for :  * less cpu_power. : 
2
strstr : while :  * less cpu_power. : 
2
str :  */[3]
strstr : INIT :  */ : 
2
strstr : if :  */ : 
2
strstr : for :  */ : 
2
strstr : while :  */ : 
2
str : static void init_sched_groups_power(int cpu, struct sched_domain *sd)[69]
strstr : INIT : static void init_sched_groups_power(int cpu, struct sched_domain *sd) : 
2
strstr : if : static void init_sched_groups_power(int cpu, struct sched_domain *sd) : 
2
strstr : for : static void init_sched_groups_power(int cpu, struct sched_domain *sd) : 
2
strstr : while : static void init_sched_groups_power(int cpu, struct sched_domain *sd) : 
2
str : 	struct sched_group *sg = sd->groups;[37]
strstr : INIT : 	struct sched_group *sg = sd->groups; : 
2
strstr : if : 	struct sched_group *sg = sd->groups; : 
2
strstr : for : 	struct sched_group *sg = sd->groups; : 
2
strstr : while : 	struct sched_group *sg = sd->groups; : 
2
str : 	WARN_ON(!sg);[14]
strstr : INIT : 	WARN_ON(!sg); : 
2
strstr : if : 	WARN_ON(!sg); : 
2
strstr : for : 	WARN_ON(!sg); : 
2
strstr : while : 	WARN_ON(!sg); : 
2
str : 	do {[5]
strstr : INIT : 	do { : 
2
strstr : if : 	do { : 
2
strstr : for : 	do { : 
2
strstr : while : 	do { : 
2
str : 		sg->group_weight = cpumask_weight(sched_group_cpus(sg));[58]
strstr : INIT : 		sg->group_weight = cpumask_weight(sched_group_cpus(sg)); : 
2
strstr : if : 		sg->group_weight = cpumask_weight(sched_group_cpus(sg)); : 
2
strstr : for : 		sg->group_weight = cpumask_weight(sched_group_cpus(sg)); : 
2
strstr : while : 		sg->group_weight = cpumask_weight(sched_group_cpus(sg)); : 
2
str : 		sg = sg->next;[16]
strstr : INIT : 		sg = sg->next; : 
2
strstr : if : 		sg = sg->next; : 
2
strstr : for : 		sg = sg->next; : 
2
strstr : while : 		sg = sg->next; : 
2
str : 	} while (sg != sd->groups);[28]
strstr : INIT : 	} while (sg != sd->groups); : 
2
strstr : if : 	} while (sg != sd->groups); : 
2
strstr : for : 	} while (sg != sd->groups); : 
2
strstr : while : 	} while (sg != sd->groups); : 
2
str : 	if (cpu != group_balance_cpu(sg))[34]
strstr : INIT : 	if (cpu != group_balance_cpu(sg)) : 
2
strstr : if : 	if (cpu != group_balance_cpu(sg)) : 
2
strstr : for : 	if (cpu != group_balance_cpu(sg)) : 
2
strstr : while : 	if (cpu != group_balance_cpu(sg)) : 
2
str : 		return;[9]
strstr : INIT : 		return; : 
2
strstr : if : 		return; : 
2
strstr : for : 		return; : 
2
strstr : while : 		return; : 
2
str : 	update_group_power(sd, cpu);[29]
strstr : INIT : 	update_group_power(sd, cpu); : 
2
strstr : if : 	update_group_power(sd, cpu); : 
2
strstr : for : 	update_group_power(sd, cpu); : 
2
strstr : while : 	update_group_power(sd, cpu); : 
2
str : 	atomic_set(&sg->sgp->nr_busy_cpus, sg->group_weight);[54]
strstr : INIT : 	atomic_set(&sg->sgp->nr_busy_cpus, sg->group_weight); : 
2
strstr : if : 	atomic_set(&sg->sgp->nr_busy_cpus, sg->group_weight); : 
2
strstr : for : 	atomic_set(&sg->sgp->nr_busy_cpus, sg->group_weight); : 
2
strstr : while : 	atomic_set(&sg->sgp->nr_busy_cpus, sg->group_weight); : 
2
str : int __weak arch_sd_sibling_asym_packing(void)[45]
strstr : INIT : int __weak arch_sd_sibling_asym_packing(void) : 
2
strstr : if : int __weak arch_sd_sibling_asym_packing(void) : 
2
strstr : for : int __weak arch_sd_sibling_asym_packing(void) : 
2
strstr : while : int __weak arch_sd_sibling_asym_packing(void) : 
2
str :        return 0*SD_ASYM_PACKING;[32]
strstr : INIT :        return 0*SD_ASYM_PACKING; : 
2
strstr : if :        return 0*SD_ASYM_PACKING; : 
2
strstr : for :        return 0*SD_ASYM_PACKING; : 
2
strstr : while :        return 0*SD_ASYM_PACKING; : 
2
str :  * Initializers for schedule domains[36]
strstr : INIT :  * Initializers for schedule domains : 
2
strstr : if :  * Initializers for schedule domains : 
2
strstr : for :  * Initializers for schedule domains : 
2
strstr : while :  * Initializers for schedule domains : 
2
str :  * Non-inlined to reduce accumulated stack pressure in build_sched_domains()[76]
strstr : INIT :  * Non-inlined to reduce accumulated stack pressure in build_sched_domains() : 
2
strstr : if :  * Non-inlined to reduce accumulated stack pressure in build_sched_domains() : 
2
strstr : for :  * Non-inlined to reduce accumulated stack pressure in build_sched_domains() : 
2
strstr : while :  * Non-inlined to reduce accumulated stack pressure in build_sched_domains() : 
2
str :  */[3]
strstr : INIT :  */ : 
2
strstr : if :  */ : 
2
strstr : for :  */ : 
2
strstr : while :  */ : 
2
str : #ifdef CONFIG_SCHED_DEBUG[25]
strstr : INIT : #ifdef CONFIG_SCHED_DEBUG : 
2
strstr : if : #ifdef CONFIG_SCHED_DEBUG : 
2
strstr : for : #ifdef CONFIG_SCHED_DEBUG : 
2
strstr : while : #ifdef CONFIG_SCHED_DEBUG : 
2
str : # define SD_INIT_NAME(sd, type)		sd->name = #type[49]
strstr : INIT : # define SD_INIT_NAME(sd, type)		sd->name = #type : 
2
strstr : if : # define SD_INIT_NAME(sd, type)		sd->name = #type : 
2
strstr : for : # define SD_INIT_NAME(sd, type)		sd->name = #type : 
2
strstr : while : # define SD_INIT_NAME(sd, type)		sd->name = #type : 
2
str : #else[5]
strstr : INIT : #else : 
2
strstr : if : #else : 
2
strstr : for : #else : 
2
strstr : while : #else : 
2
str : # define SD_INIT_NAME(sd, type)		do { } while (0)[49]
strstr : INIT : # define SD_INIT_NAME(sd, type)		do { } while (0) : 
2
strstr : if : # define SD_INIT_NAME(sd, type)		do { } while (0) : 
2
strstr : for : # define SD_INIT_NAME(sd, type)		do { } while (0) : 
2
strstr : while : # define SD_INIT_NAME(sd, type)		do { } while (0) : 
2
str : #endif[6]
strstr : INIT : #endif : 
2
strstr : if : #endif : 
2
strstr : for : #endif : 
2
strstr : while : #endif : 
2
str : #define SD_INIT_FUNC(type)						\[33]
strstr : INIT : #define SD_INIT_FUNC(type)						\ : 
2
strstr : if : #define SD_INIT_FUNC(type)						\ : 
2
strstr : for : #define SD_INIT_FUNC(type)						\ : 
2
strstr : while : #define SD_INIT_FUNC(type)						\ : 
2
str : static noinline struct sched_domain *					\[43]
strstr : INIT : static noinline struct sched_domain *					\ : 
2
strstr : if : static noinline struct sched_domain *					\ : 
2
strstr : for : static noinline struct sched_domain *					\ : 
2
strstr : while : static noinline struct sched_domain *					\ : 
2
str : sd_init_##type(struct sched_domain_topology_level *tl, int cpu) 	\[66]
strstr : INIT : sd_init_##type(struct sched_domain_topology_level *tl, int cpu) 	\ : 
2
strstr : if : sd_init_##type(struct sched_domain_topology_level *tl, int cpu) 	\ : 
2
strstr : for : sd_init_##type(struct sched_domain_topology_level *tl, int cpu) 	\ : 
2
strstr : while : sd_init_##type(struct sched_domain_topology_level *tl, int cpu) 	\ : 
2
str : {									\[11]
strstr : INIT : {									\ : 
2
strstr : if : {									\ : 
2
strstr : for : {									\ : 
2
strstr : while : {									\ : 
2
str : 	struct sched_domain *sd = *per_cpu_ptr(tl->data.sd, cpu);	\[60]
strstr : INIT : 	struct sched_domain *sd = *per_cpu_ptr(tl->data.sd, cpu);	\ : 
2
strstr : if : 	struct sched_domain *sd = *per_cpu_ptr(tl->data.sd, cpu);	\ : 
2
strstr : for : 	struct sched_domain *sd = *per_cpu_ptr(tl->data.sd, cpu);	\ : 
2
strstr : while : 	struct sched_domain *sd = *per_cpu_ptr(tl->data.sd, cpu);	\ : 
2
str : 	*sd = SD_##type##_INIT;						\[31]
strstr : INIT : 	*sd = SD_##type##_INIT;						\ : 
2
strstr : if : 	*sd = SD_##type##_INIT;						\ : 
2
strstr : for : 	*sd = SD_##type##_INIT;						\ : 
2
strstr : while : 	*sd = SD_##type##_INIT;						\ : 
2
str : 	SD_INIT_NAME(sd, type);						\[31]
strstr : INIT : 	SD_INIT_NAME(sd, type);						\ : 
2
strstr : if : 	SD_INIT_NAME(sd, type);						\ : 
2
strstr : for : 	SD_INIT_NAME(sd, type);						\ : 
2
strstr : while : 	SD_INIT_NAME(sd, type);						\ : 
2
str : 	sd->private = &tl->data;					\[31]
strstr : INIT : 	sd->private = &tl->data;					\ : 
2
strstr : if : 	sd->private = &tl->data;					\ : 
2
strstr : for : 	sd->private = &tl->data;					\ : 
2
strstr : while : 	sd->private = &tl->data;					\ : 
2
str : 	return sd;							\[19]
strstr : INIT : 	return sd;							\ : 
2
strstr : if : 	return sd;							\ : 
2
strstr : for : 	return sd;							\ : 
2
strstr : while : 	return sd;							\ : 
2
str : SD_INIT_FUNC(CPU)[17]
strstr : INIT : SD_INIT_FUNC(CPU) : 
2
strstr : if : SD_INIT_FUNC(CPU) : 
2
strstr : for : SD_INIT_FUNC(CPU) : 
2
strstr : while : SD_INIT_FUNC(CPU) : 
2
str : #ifdef CONFIG_SCHED_SMT[23]
strstr : INIT : #ifdef CONFIG_SCHED_SMT : 
2
strstr : if : #ifdef CONFIG_SCHED_SMT : 
2
strstr : for : #ifdef CONFIG_SCHED_SMT : 
2
strstr : while : #ifdef CONFIG_SCHED_SMT : 
2
str :  SD_INIT_FUNC(SIBLING)[22]
strstr : INIT :  SD_INIT_FUNC(SIBLING) : 
2
strstr : if :  SD_INIT_FUNC(SIBLING) : 
2
strstr : for :  SD_INIT_FUNC(SIBLING) : 
2
strstr : while :  SD_INIT_FUNC(SIBLING) : 
2
str : #endif[6]
strstr : INIT : #endif : 
2
strstr : if : #endif : 
2
strstr : for : #endif : 
2
strstr : while : #endif : 
2
str : #ifdef CONFIG_SCHED_MC[22]
strstr : INIT : #ifdef CONFIG_SCHED_MC : 
2
strstr : if : #ifdef CONFIG_SCHED_MC : 
2
strstr : for : #ifdef CONFIG_SCHED_MC : 
2
strstr : while : #ifdef CONFIG_SCHED_MC : 
2
str :  SD_INIT_FUNC(MC)[17]
strstr : INIT :  SD_INIT_FUNC(MC) : 
2
strstr : if :  SD_INIT_FUNC(MC) : 
2
strstr : for :  SD_INIT_FUNC(MC) : 
2
strstr : while :  SD_INIT_FUNC(MC) : 
2
str : #endif[6]
strstr : INIT : #endif : 
2
strstr : if : #endif : 
2
strstr : for : #endif : 
2
strstr : while : #endif : 
2
str : #ifdef CONFIG_SCHED_BOOK[24]
strstr : INIT : #ifdef CONFIG_SCHED_BOOK : 
2
strstr : if : #ifdef CONFIG_SCHED_BOOK : 
2
strstr : for : #ifdef CONFIG_SCHED_BOOK : 
2
strstr : while : #ifdef CONFIG_SCHED_BOOK : 
2
str :  SD_INIT_FUNC(BOOK)[19]
strstr : INIT :  SD_INIT_FUNC(BOOK) : 
2
strstr : if :  SD_INIT_FUNC(BOOK) : 
2
strstr : for :  SD_INIT_FUNC(BOOK) : 
2
strstr : while :  SD_INIT_FUNC(BOOK) : 
2
str : #endif[6]
strstr : INIT : #endif : 
2
strstr : if : #endif : 
2
strstr : for : #endif : 
2
strstr : while : #endif : 
2
str : static int default_relax_domain_level = -1;[43]
strstr : INIT : static int default_relax_domain_level = -1; : 
2
strstr : if : static int default_relax_domain_level = -1; : 
2
strstr : for : static int default_relax_domain_level = -1; : 
2
strstr : while : static int default_relax_domain_level = -1; : 
2
str : int sched_domain_level_max;[27]
strstr : INIT : int sched_domain_level_max; : 
2
strstr : if : int sched_domain_level_max; : 
2
strstr : for : int sched_domain_level_max; : 
2
strstr : while : int sched_domain_level_max; : 
2
str : static int __init setup_relax_domain_level(char *str)[53]
strstr : INIT : static int __init setup_relax_domain_level(char *str) : 
2
strstr : if : static int __init setup_relax_domain_level(char *str) : 
2
strstr : for : static int __init setup_relax_domain_level(char *str) : 
2
strstr : while : static int __init setup_relax_domain_level(char *str) : 
2
str : 	if (kstrtoint(str, 0, &default_relax_domain_level))[52]
strstr : INIT : 	if (kstrtoint(str, 0, &default_relax_domain_level)) : 
2
strstr : if : 	if (kstrtoint(str, 0, &default_relax_domain_level)) : 
2
strstr : for : 	if (kstrtoint(str, 0, &default_relax_domain_level)) : 
2
strstr : while : 	if (kstrtoint(str, 0, &default_relax_domain_level)) : 
2
str : 		pr_warn("Unable to set relax_domain_level\n");[48]
strstr : INIT : 		pr_warn("Unable to set relax_domain_level\n"); : 
2
strstr : if : 		pr_warn("Unable to set relax_domain_level\n"); : 
2
strstr : for : 		pr_warn("Unable to set relax_domain_level\n"); : 
2
strstr : while : 		pr_warn("Unable to set relax_domain_level\n"); : 
2
str : 	return 1;[10]
strstr : INIT : 	return 1; : 
2
strstr : if : 	return 1; : 
2
strstr : for : 	return 1; : 
2
strstr : while : 	return 1; : 
2
str : __setup("relax_domain_level=", setup_relax_domain_level);[57]
strstr : INIT : __setup("relax_domain_level=", setup_relax_domain_level); : 
2
strstr : if : __setup("relax_domain_level=", setup_relax_domain_level); : 
2
strstr : for : __setup("relax_domain_level=", setup_relax_domain_level); : 
2
strstr : while : __setup("relax_domain_level=", setup_relax_domain_level); : 
2
str : static void set_domain_attribute(struct sched_domain *sd,[57]
strstr : INIT : static void set_domain_attribute(struct sched_domain *sd, : 
2
strstr : if : static void set_domain_attribute(struct sched_domain *sd, : 
2
strstr : for : static void set_domain_attribute(struct sched_domain *sd, : 
2
strstr : while : static void set_domain_attribute(struct sched_domain *sd, : 
2
str : 				 struct sched_domain_attr *attr)[36]
strstr : INIT : 				 struct sched_domain_attr *attr) : 
2
strstr : if : 				 struct sched_domain_attr *attr) : 
2
strstr : for : 				 struct sched_domain_attr *attr) : 
2
strstr : while : 				 struct sched_domain_attr *attr) : 
2
str : 	int request;[13]
strstr : INIT : 	int request; : 
2
strstr : if : 	int request; : 
2
strstr : for : 	int request; : 
2
strstr : while : 	int request; : 
2
str : 	if (!attr || attr->relax_domain_level < 0) {[45]
strstr : INIT : 	if (!attr || attr->relax_domain_level < 0) { : 
2
strstr : if : 	if (!attr || attr->relax_domain_level < 0) { : 
2
strstr : for : 	if (!attr || attr->relax_domain_level < 0) { : 
2
strstr : while : 	if (!attr || attr->relax_domain_level < 0) { : 
2
str : 		if (default_relax_domain_level < 0)[37]
strstr : INIT : 		if (default_relax_domain_level < 0) : 
2
strstr : if : 		if (default_relax_domain_level < 0) : 
2
strstr : for : 		if (default_relax_domain_level < 0) : 
2
strstr : while : 		if (default_relax_domain_level < 0) : 
2
str : 			return;[10]
strstr : INIT : 			return; : 
2
strstr : if : 			return; : 
2
strstr : for : 			return; : 
2
strstr : while : 			return; : 
2
str : 		else[6]
strstr : INIT : 		else : 
2
strstr : if : 		else : 
2
strstr : for : 		else : 
2
strstr : while : 		else : 
2
str : 			request = default_relax_domain_level;[40]
strstr : INIT : 			request = default_relax_domain_level; : 
2
strstr : if : 			request = default_relax_domain_level; : 
2
strstr : for : 			request = default_relax_domain_level; : 
2
strstr : while : 			request = default_relax_domain_level; : 
2
str : 	} else[7]
strstr : INIT : 	} else : 
2
strstr : if : 	} else : 
2
strstr : for : 	} else : 
2
strstr : while : 	} else : 
2
str : 		request = attr->relax_domain_level;[37]
strstr : INIT : 		request = attr->relax_domain_level; : 
2
strstr : if : 		request = attr->relax_domain_level; : 
2
strstr : for : 		request = attr->relax_domain_level; : 
2
strstr : while : 		request = attr->relax_domain_level; : 
2
str : 	if (request < sd->level) {[27]
strstr : INIT : 	if (request < sd->level) { : 
2
strstr : if : 	if (request < sd->level) { : 
2
strstr : for : 	if (request < sd->level) { : 
2
strstr : while : 	if (request < sd->level) { : 
2
str : 		/* turn off idle balance on this domain */[44]
strstr : INIT : 		/* turn off idle balance on this domain */ : 
2
strstr : if : 		/* turn off idle balance on this domain */ : 
2
strstr : for : 		/* turn off idle balance on this domain */ : 
2
strstr : while : 		/* turn off idle balance on this domain */ : 
2
str : 		sd->flags &= ~(SD_BALANCE_WAKE|SD_BALANCE_NEWIDLE);[53]
strstr : INIT : 		sd->flags &= ~(SD_BALANCE_WAKE|SD_BALANCE_NEWIDLE); : 
2
strstr : if : 		sd->flags &= ~(SD_BALANCE_WAKE|SD_BALANCE_NEWIDLE); : 
2
strstr : for : 		sd->flags &= ~(SD_BALANCE_WAKE|SD_BALANCE_NEWIDLE); : 
2
strstr : while : 		sd->flags &= ~(SD_BALANCE_WAKE|SD_BALANCE_NEWIDLE); : 
2
str : 	} else {[9]
strstr : INIT : 	} else { : 
2
strstr : if : 	} else { : 
2
strstr : for : 	} else { : 
2
strstr : while : 	} else { : 
2
str : 		/* turn on idle balance on this domain */[43]
strstr : INIT : 		/* turn on idle balance on this domain */ : 
2
strstr : if : 		/* turn on idle balance on this domain */ : 
2
strstr : for : 		/* turn on idle balance on this domain */ : 
2
strstr : while : 		/* turn on idle balance on this domain */ : 
2
str : 		sd->flags |= (SD_BALANCE_WAKE|SD_BALANCE_NEWIDLE);[52]
strstr : INIT : 		sd->flags |= (SD_BALANCE_WAKE|SD_BALANCE_NEWIDLE); : 
2
strstr : if : 		sd->flags |= (SD_BALANCE_WAKE|SD_BALANCE_NEWIDLE); : 
2
strstr : for : 		sd->flags |= (SD_BALANCE_WAKE|SD_BALANCE_NEWIDLE); : 
2
strstr : while : 		sd->flags |= (SD_BALANCE_WAKE|SD_BALANCE_NEWIDLE); : 
2
str : static void __sdt_free(const struct cpumask *cpu_map);[54]
strstr : INIT : static void __sdt_free(const struct cpumask *cpu_map); : 
2
strstr : if : static void __sdt_free(const struct cpumask *cpu_map); : 
2
strstr : for : static void __sdt_free(const struct cpumask *cpu_map); : 
2
strstr : while : static void __sdt_free(const struct cpumask *cpu_map); : 
2
str : static int __sdt_alloc(const struct cpumask *cpu_map);[54]
strstr : INIT : static int __sdt_alloc(const struct cpumask *cpu_map); : 
2
strstr : if : static int __sdt_alloc(const struct cpumask *cpu_map); : 
2
strstr : for : static int __sdt_alloc(const struct cpumask *cpu_map); : 
2
strstr : while : static int __sdt_alloc(const struct cpumask *cpu_map); : 
2
str : static void __free_domain_allocs(struct s_data *d, enum s_alloc what,[69]
strstr : INIT : static void __free_domain_allocs(struct s_data *d, enum s_alloc what, : 
2
strstr : if : static void __free_domain_allocs(struct s_data *d, enum s_alloc what, : 
2
strstr : for : static void __free_domain_allocs(struct s_data *d, enum s_alloc what, : 
2
strstr : while : static void __free_domain_allocs(struct s_data *d, enum s_alloc what, : 
2
str : 				 const struct cpumask *cpu_map)[35]
strstr : INIT : 				 const struct cpumask *cpu_map) : 
2
strstr : if : 				 const struct cpumask *cpu_map) : 
2
strstr : for : 				 const struct cpumask *cpu_map) : 
2
strstr : while : 				 const struct cpumask *cpu_map) : 
2
str : 	switch (what) {[16]
strstr : INIT : 	switch (what) { : 
2
strstr : if : 	switch (what) { : 
2
strstr : for : 	switch (what) { : 
2
strstr : while : 	switch (what) { : 
2
str : 	case sa_rootdomain:[20]
strstr : INIT : 	case sa_rootdomain: : 
2
strstr : if : 	case sa_rootdomain: : 
2
strstr : for : 	case sa_rootdomain: : 
2
strstr : while : 	case sa_rootdomain: : 
2
str : 		if (!atomic_read(&d->rd->refcount))[37]
strstr : INIT : 		if (!atomic_read(&d->rd->refcount)) : 
2
strstr : if : 		if (!atomic_read(&d->rd->refcount)) : 
2
strstr : for : 		if (!atomic_read(&d->rd->refcount)) : 
2
strstr : while : 		if (!atomic_read(&d->rd->refcount)) : 
2
str : 			free_rootdomain(&d->rd->rcu); /* fall through */[51]
strstr : INIT : 			free_rootdomain(&d->rd->rcu); /* fall through */ : 
2
strstr : if : 			free_rootdomain(&d->rd->rcu); /* fall through */ : 
2
strstr : for : 			free_rootdomain(&d->rd->rcu); /* fall through */ : 
2
strstr : while : 			free_rootdomain(&d->rd->rcu); /* fall through */ : 
2
str : 	case sa_sd:[12]
strstr : INIT : 	case sa_sd: : 
2
strstr : if : 	case sa_sd: : 
2
strstr : for : 	case sa_sd: : 
2
strstr : while : 	case sa_sd: : 
2
str : 		free_percpu(d->sd); /* fall through */[40]
strstr : INIT : 		free_percpu(d->sd); /* fall through */ : 
2
strstr : if : 		free_percpu(d->sd); /* fall through */ : 
2
strstr : for : 		free_percpu(d->sd); /* fall through */ : 
2
strstr : while : 		free_percpu(d->sd); /* fall through */ : 
2
str : 	case sa_sd_storage:[20]
strstr : INIT : 	case sa_sd_storage: : 
2
strstr : if : 	case sa_sd_storage: : 
2
strstr : for : 	case sa_sd_storage: : 
2
strstr : while : 	case sa_sd_storage: : 
2
str : 		__sdt_free(cpu_map); /* fall through */[41]
strstr : INIT : 		__sdt_free(cpu_map); /* fall through */ : 
2
strstr : if : 		__sdt_free(cpu_map); /* fall through */ : 
2
strstr : for : 		__sdt_free(cpu_map); /* fall through */ : 
2
strstr : while : 		__sdt_free(cpu_map); /* fall through */ : 
2
str : 	case sa_none:[14]
strstr : INIT : 	case sa_none: : 
2
strstr : if : 	case sa_none: : 
2
strstr : for : 	case sa_none: : 
2
strstr : while : 	case sa_none: : 
2
str : 		break;[8]
strstr : INIT : 		break; : 
2
strstr : if : 		break; : 
2
strstr : for : 		break; : 
2
strstr : while : 		break; : 
2
str : static enum s_alloc __visit_domain_allocation_hell(struct s_data *d,[68]
strstr : INIT : static enum s_alloc __visit_domain_allocation_hell(struct s_data *d, : 
2
strstr : if : static enum s_alloc __visit_domain_allocation_hell(struct s_data *d, : 
2
strstr : for : static enum s_alloc __visit_domain_allocation_hell(struct s_data *d, : 
2
strstr : while : static enum s_alloc __visit_domain_allocation_hell(struct s_data *d, : 
2
str : 						   const struct cpumask *cpu_map)[39]
strstr : INIT : 						   const struct cpumask *cpu_map) : 
2
strstr : if : 						   const struct cpumask *cpu_map) : 
2
strstr : for : 						   const struct cpumask *cpu_map) : 
2
strstr : while : 						   const struct cpumask *cpu_map) : 
2
str : 	memset(d, 0, sizeof(*d));[26]
strstr : INIT : 	memset(d, 0, sizeof(*d)); : 
2
strstr : if : 	memset(d, 0, sizeof(*d)); : 
2
strstr : for : 	memset(d, 0, sizeof(*d)); : 
2
strstr : while : 	memset(d, 0, sizeof(*d)); : 
2
str : 	if (__sdt_alloc(cpu_map))[26]
strstr : INIT : 	if (__sdt_alloc(cpu_map)) : 
2
strstr : if : 	if (__sdt_alloc(cpu_map)) : 
2
strstr : for : 	if (__sdt_alloc(cpu_map)) : 
2
strstr : while : 	if (__sdt_alloc(cpu_map)) : 
2
str : 		return sa_sd_storage;[23]
strstr : INIT : 		return sa_sd_storage; : 
2
strstr : if : 		return sa_sd_storage; : 
2
strstr : for : 		return sa_sd_storage; : 
2
strstr : while : 		return sa_sd_storage; : 
2
str : 	d->sd = alloc_percpu(struct sched_domain *);[45]
strstr : INIT : 	d->sd = alloc_percpu(struct sched_domain *); : 
2
strstr : if : 	d->sd = alloc_percpu(struct sched_domain *); : 
2
strstr : for : 	d->sd = alloc_percpu(struct sched_domain *); : 
2
strstr : while : 	d->sd = alloc_percpu(struct sched_domain *); : 
2
str : 	if (!d->sd)[12]
strstr : INIT : 	if (!d->sd) : 
2
strstr : if : 	if (!d->sd) : 
2
strstr : for : 	if (!d->sd) : 
2
strstr : while : 	if (!d->sd) : 
2
str : 		return sa_sd_storage;[23]
strstr : INIT : 		return sa_sd_storage; : 
2
strstr : if : 		return sa_sd_storage; : 
2
strstr : for : 		return sa_sd_storage; : 
2
strstr : while : 		return sa_sd_storage; : 
2
str : 	d->rd = alloc_rootdomain();[28]
strstr : INIT : 	d->rd = alloc_rootdomain(); : 
2
strstr : if : 	d->rd = alloc_rootdomain(); : 
2
strstr : for : 	d->rd = alloc_rootdomain(); : 
2
strstr : while : 	d->rd = alloc_rootdomain(); : 
2
str : 	if (!d->rd)[12]
strstr : INIT : 	if (!d->rd) : 
2
strstr : if : 	if (!d->rd) : 
2
strstr : for : 	if (!d->rd) : 
2
strstr : while : 	if (!d->rd) : 
2
str : 		return sa_sd;[15]
strstr : INIT : 		return sa_sd; : 
2
strstr : if : 		return sa_sd; : 
2
strstr : for : 		return sa_sd; : 
2
strstr : while : 		return sa_sd; : 
2
str : 	return sa_rootdomain;[22]
strstr : INIT : 	return sa_rootdomain; : 
2
strstr : if : 	return sa_rootdomain; : 
2
strstr : for : 	return sa_rootdomain; : 
2
strstr : while : 	return sa_rootdomain; : 
2
str :  * NULL the sd_data elements we've used to build the sched_domain and[69]
strstr : INIT :  * NULL the sd_data elements we've used to build the sched_domain and : 
2
strstr : if :  * NULL the sd_data elements we've used to build the sched_domain and : 
2
strstr : for :  * NULL the sd_data elements we've used to build the sched_domain and : 
2
strstr : while :  * NULL the sd_data elements we've used to build the sched_domain and : 
2
str :  * sched_group structure so that the subsequent __free_domain_allocs()[70]
strstr : INIT :  * sched_group structure so that the subsequent __free_domain_allocs() : 
2
strstr : if :  * sched_group structure so that the subsequent __free_domain_allocs() : 
2
strstr : for :  * sched_group structure so that the subsequent __free_domain_allocs() : 
2
strstr : while :  * sched_group structure so that the subsequent __free_domain_allocs() : 
2
str :  * will not free the data we're using.[38]
strstr : INIT :  * will not free the data we're using. : 
2
strstr : if :  * will not free the data we're using. : 
2
strstr : for :  * will not free the data we're using. : 
2
strstr : while :  * will not free the data we're using. : 
2
str :  */[3]
strstr : INIT :  */ : 
2
strstr : if :  */ : 
2
strstr : for :  */ : 
2
strstr : while :  */ : 
2
str : static void claim_allocations(int cpu, struct sched_domain *sd)[63]
strstr : INIT : static void claim_allocations(int cpu, struct sched_domain *sd) : 
2
strstr : if : static void claim_allocations(int cpu, struct sched_domain *sd) : 
2
strstr : for : static void claim_allocations(int cpu, struct sched_domain *sd) : 
2
strstr : while : static void claim_allocations(int cpu, struct sched_domain *sd) : 
2
str : 	struct sd_data *sdd = sd->private;[35]
strstr : INIT : 	struct sd_data *sdd = sd->private; : 
2
strstr : if : 	struct sd_data *sdd = sd->private; : 
2
strstr : for : 	struct sd_data *sdd = sd->private; : 
2
strstr : while : 	struct sd_data *sdd = sd->private; : 
2
str : 	WARN_ON_ONCE(*per_cpu_ptr(sdd->sd, cpu) != sd);[48]
strstr : INIT : 	WARN_ON_ONCE(*per_cpu_ptr(sdd->sd, cpu) != sd); : 
2
strstr : if : 	WARN_ON_ONCE(*per_cpu_ptr(sdd->sd, cpu) != sd); : 
2
strstr : for : 	WARN_ON_ONCE(*per_cpu_ptr(sdd->sd, cpu) != sd); : 
2
strstr : while : 	WARN_ON_ONCE(*per_cpu_ptr(sdd->sd, cpu) != sd); : 
2
str : 	*per_cpu_ptr(sdd->sd, cpu) = NULL;[35]
strstr : INIT : 	*per_cpu_ptr(sdd->sd, cpu) = NULL; : 
2
strstr : if : 	*per_cpu_ptr(sdd->sd, cpu) = NULL; : 
2
strstr : for : 	*per_cpu_ptr(sdd->sd, cpu) = NULL; : 
2
strstr : while : 	*per_cpu_ptr(sdd->sd, cpu) = NULL; : 
2
str : 	if (atomic_read(&(*per_cpu_ptr(sdd->sg, cpu))->ref))[53]
strstr : INIT : 	if (atomic_read(&(*per_cpu_ptr(sdd->sg, cpu))->ref)) : 
2
strstr : if : 	if (atomic_read(&(*per_cpu_ptr(sdd->sg, cpu))->ref)) : 
2
strstr : for : 	if (atomic_read(&(*per_cpu_ptr(sdd->sg, cpu))->ref)) : 
2
strstr : while : 	if (atomic_read(&(*per_cpu_ptr(sdd->sg, cpu))->ref)) : 
2
str : 		*per_cpu_ptr(sdd->sg, cpu) = NULL;[36]
strstr : INIT : 		*per_cpu_ptr(sdd->sg, cpu) = NULL; : 
2
strstr : if : 		*per_cpu_ptr(sdd->sg, cpu) = NULL; : 
2
strstr : for : 		*per_cpu_ptr(sdd->sg, cpu) = NULL; : 
2
strstr : while : 		*per_cpu_ptr(sdd->sg, cpu) = NULL; : 
2
str : 	if (atomic_read(&(*per_cpu_ptr(sdd->sgp, cpu))->ref))[54]
strstr : INIT : 	if (atomic_read(&(*per_cpu_ptr(sdd->sgp, cpu))->ref)) : 
2
strstr : if : 	if (atomic_read(&(*per_cpu_ptr(sdd->sgp, cpu))->ref)) : 
2
strstr : for : 	if (atomic_read(&(*per_cpu_ptr(sdd->sgp, cpu))->ref)) : 
2
strstr : while : 	if (atomic_read(&(*per_cpu_ptr(sdd->sgp, cpu))->ref)) : 
2
str : 		*per_cpu_ptr(sdd->sgp, cpu) = NULL;[37]
strstr : INIT : 		*per_cpu_ptr(sdd->sgp, cpu) = NULL; : 
2
strstr : if : 		*per_cpu_ptr(sdd->sgp, cpu) = NULL; : 
2
strstr : for : 		*per_cpu_ptr(sdd->sgp, cpu) = NULL; : 
2
strstr : while : 		*per_cpu_ptr(sdd->sgp, cpu) = NULL; : 
2
str : #ifdef CONFIG_SCHED_SMT[23]
strstr : INIT : #ifdef CONFIG_SCHED_SMT : 
2
strstr : if : #ifdef CONFIG_SCHED_SMT : 
2
strstr : for : #ifdef CONFIG_SCHED_SMT : 
2
strstr : while : #ifdef CONFIG_SCHED_SMT : 
2
str : static const struct cpumask *cpu_smt_mask(int cpu)[50]
strstr : INIT : static const struct cpumask *cpu_smt_mask(int cpu) : 
2
strstr : if : static const struct cpumask *cpu_smt_mask(int cpu) : 
2
strstr : for : static const struct cpumask *cpu_smt_mask(int cpu) : 
2
strstr : while : static const struct cpumask *cpu_smt_mask(int cpu) : 
2
str : 	return topology_thread_cpumask(cpu);[37]
strstr : INIT : 	return topology_thread_cpumask(cpu); : 
2
strstr : if : 	return topology_thread_cpumask(cpu); : 
2
strstr : for : 	return topology_thread_cpumask(cpu); : 
2
strstr : while : 	return topology_thread_cpumask(cpu); : 
2
str : #endif[6]
strstr : INIT : #endif : 
2
strstr : if : #endif : 
2
strstr : for : #endif : 
2
strstr : while : #endif : 
2
str :  * Topology list, bottom-up.[28]
strstr : INIT :  * Topology list, bottom-up. : 
2
strstr : if :  * Topology list, bottom-up. : 
2
strstr : for :  * Topology list, bottom-up. : 
2
strstr : while :  * Topology list, bottom-up. : 
2
str :  */[3]
strstr : INIT :  */ : 
2
strstr : if :  */ : 
2
strstr : for :  */ : 
2
strstr : while :  */ : 
2
str : static struct sched_domain_topology_level default_topology[] = {[64]
strstr : INIT : static struct sched_domain_topology_level default_topology[] = { : 
2
strstr : if : static struct sched_domain_topology_level default_topology[] = { : 
2
strstr : for : static struct sched_domain_topology_level default_topology[] = { : 
2
strstr : while : static struct sched_domain_topology_level default_topology[] = { : 
2
str : #ifdef CONFIG_SCHED_SMT[23]
strstr : INIT : #ifdef CONFIG_SCHED_SMT : 
2
strstr : if : #ifdef CONFIG_SCHED_SMT : 
2
strstr : for : #ifdef CONFIG_SCHED_SMT : 
2
strstr : while : #ifdef CONFIG_SCHED_SMT : 
2
str : 	{ sd_init_SIBLING, cpu_smt_mask, },[36]
strstr : INIT : 	{ sd_init_SIBLING, cpu_smt_mask, }, : 
2
strstr : if : 	{ sd_init_SIBLING, cpu_smt_mask, }, : 
2
strstr : for : 	{ sd_init_SIBLING, cpu_smt_mask, }, : 
2
strstr : while : 	{ sd_init_SIBLING, cpu_smt_mask, }, : 
2
str : #endif[6]
strstr : INIT : #endif : 
2
strstr : if : #endif : 
2
strstr : for : #endif : 
2
strstr : while : #endif : 
2
str : #ifdef CONFIG_SCHED_MC[22]
strstr : INIT : #ifdef CONFIG_SCHED_MC : 
2
strstr : if : #ifdef CONFIG_SCHED_MC : 
2
strstr : for : #ifdef CONFIG_SCHED_MC : 
2
strstr : while : #ifdef CONFIG_SCHED_MC : 
2
str : 	{ sd_init_MC, cpu_coregroup_mask, },[37]
strstr : INIT : 	{ sd_init_MC, cpu_coregroup_mask, }, : 
2
strstr : if : 	{ sd_init_MC, cpu_coregroup_mask, }, : 
2
strstr : for : 	{ sd_init_MC, cpu_coregroup_mask, }, : 
2
strstr : while : 	{ sd_init_MC, cpu_coregroup_mask, }, : 
2
str : #endif[6]
strstr : INIT : #endif : 
2
strstr : if : #endif : 
2
strstr : for : #endif : 
2
strstr : while : #endif : 
2
str : #ifdef CONFIG_SCHED_BOOK[24]
strstr : INIT : #ifdef CONFIG_SCHED_BOOK : 
2
strstr : if : #ifdef CONFIG_SCHED_BOOK : 
2
strstr : for : #ifdef CONFIG_SCHED_BOOK : 
2
strstr : while : #ifdef CONFIG_SCHED_BOOK : 
2
str : 	{ sd_init_BOOK, cpu_book_mask, },[34]
strstr : INIT : 	{ sd_init_BOOK, cpu_book_mask, }, : 
2
strstr : if : 	{ sd_init_BOOK, cpu_book_mask, }, : 
2
strstr : for : 	{ sd_init_BOOK, cpu_book_mask, }, : 
2
strstr : while : 	{ sd_init_BOOK, cpu_book_mask, }, : 
2
str : #endif[6]
strstr : INIT : #endif : 
2
strstr : if : #endif : 
2
strstr : for : #endif : 
2
strstr : while : #endif : 
2
str : 	{ sd_init_CPU, cpu_cpu_mask, },[32]
strstr : INIT : 	{ sd_init_CPU, cpu_cpu_mask, }, : 
2
strstr : if : 	{ sd_init_CPU, cpu_cpu_mask, }, : 
2
strstr : for : 	{ sd_init_CPU, cpu_cpu_mask, }, : 
2
strstr : while : 	{ sd_init_CPU, cpu_cpu_mask, }, : 
2
str : 	{ NULL, },[11]
strstr : INIT : 	{ NULL, }, : 
2
strstr : if : 	{ NULL, }, : 
2
strstr : for : 	{ NULL, }, : 
2
strstr : while : 	{ NULL, }, : 
2
str : static struct sched_domain_topology_level *sched_domain_topology = default_topology;[84]
strstr : INIT : static struct sched_domain_topology_level *sched_domain_topology = default_topology; : 
2
strstr : if : static struct sched_domain_topology_level *sched_domain_topology = default_topology; : 
2
strstr : for : static struct sched_domain_topology_level *sched_domain_topology = default_topology; : 
2
strstr : while : static struct sched_domain_topology_level *sched_domain_topology = default_topology; : 
2
str : #define for_each_sd_topology(tl)			\[36]
strstr : INIT : #define for_each_sd_topology(tl)			\ : 
2
strstr : if : #define for_each_sd_topology(tl)			\ : 
2
strstr : for : #define for_each_sd_topology(tl)			\ : 
2
strstr : while : #define for_each_sd_topology(tl)			\ : 
2
str : 	for (tl = sched_domain_topology; tl->init; tl++)[49]
strstr : INIT : 	for (tl = sched_domain_topology; tl->init; tl++) : 
2
strstr : if : 	for (tl = sched_domain_topology; tl->init; tl++) : 
2
strstr : for : 	for (tl = sched_domain_topology; tl->init; tl++) : 
2
strstr : while : 	for (tl = sched_domain_topology; tl->init; tl++) : 
2
str : #ifdef CONFIG_NUMA[18]
strstr : INIT : #ifdef CONFIG_NUMA : 
2
strstr : if : #ifdef CONFIG_NUMA : 
2
strstr : for : #ifdef CONFIG_NUMA : 
2
strstr : while : #ifdef CONFIG_NUMA : 
2
str : static int sched_domains_numa_levels;[37]
strstr : INIT : static int sched_domains_numa_levels; : 
2
strstr : if : static int sched_domains_numa_levels; : 
2
strstr : for : static int sched_domains_numa_levels; : 
2
strstr : while : static int sched_domains_numa_levels; : 
2
str : static int *sched_domains_numa_distance;[40]
strstr : INIT : static int *sched_domains_numa_distance; : 
2
strstr : if : static int *sched_domains_numa_distance; : 
2
strstr : for : static int *sched_domains_numa_distance; : 
2
strstr : while : static int *sched_domains_numa_distance; : 
2
str : static struct cpumask ***sched_domains_numa_masks;[50]
strstr : INIT : static struct cpumask ***sched_domains_numa_masks; : 
2
strstr : if : static struct cpumask ***sched_domains_numa_masks; : 
2
strstr : for : static struct cpumask ***sched_domains_numa_masks; : 
2
strstr : while : static struct cpumask ***sched_domains_numa_masks; : 
2
str : static int sched_domains_curr_level;[36]
strstr : INIT : static int sched_domains_curr_level; : 
2
strstr : if : static int sched_domains_curr_level; : 
2
strstr : for : static int sched_domains_curr_level; : 
2
strstr : while : static int sched_domains_curr_level; : 
2
str : static inline int sd_local_flags(int level)[43]
strstr : INIT : static inline int sd_local_flags(int level) : 
2
strstr : if : static inline int sd_local_flags(int level) : 
2
strstr : for : static inline int sd_local_flags(int level) : 
2
strstr : while : static inline int sd_local_flags(int level) : 
2
str : 	if (sched_domains_numa_distance[level] > RECLAIM_DISTANCE)[59]
strstr : INIT : 	if (sched_domains_numa_distance[level] > RECLAIM_DISTANCE) : 
2
strstr : if : 	if (sched_domains_numa_distance[level] > RECLAIM_DISTANCE) : 
2
strstr : for : 	if (sched_domains_numa_distance[level] > RECLAIM_DISTANCE) : 
2
strstr : while : 	if (sched_domains_numa_distance[level] > RECLAIM_DISTANCE) : 
2
str : 		return 0;[11]
strstr : INIT : 		return 0; : 
2
strstr : if : 		return 0; : 
2
strstr : for : 		return 0; : 
2
strstr : while : 		return 0; : 
2
str : 	return SD_BALANCE_EXEC | SD_BALANCE_FORK | SD_WAKE_AFFINE;[59]
strstr : INIT : 	return SD_BALANCE_EXEC | SD_BALANCE_FORK | SD_WAKE_AFFINE; : 
2
strstr : if : 	return SD_BALANCE_EXEC | SD_BALANCE_FORK | SD_WAKE_AFFINE; : 
2
strstr : for : 	return SD_BALANCE_EXEC | SD_BALANCE_FORK | SD_WAKE_AFFINE; : 
2
strstr : while : 	return SD_BALANCE_EXEC | SD_BALANCE_FORK | SD_WAKE_AFFINE; : 
2
str : static struct sched_domain *[28]
strstr : INIT : static struct sched_domain * : 
2
strstr : if : static struct sched_domain * : 
2
strstr : for : static struct sched_domain * : 
2
strstr : while : static struct sched_domain * : 
2
str : sd_numa_init(struct sched_domain_topology_level *tl, int cpu)[61]
strstr : INIT : sd_numa_init(struct sched_domain_topology_level *tl, int cpu) : 
2
strstr : if : sd_numa_init(struct sched_domain_topology_level *tl, int cpu) : 
2
strstr : for : sd_numa_init(struct sched_domain_topology_level *tl, int cpu) : 
2
strstr : while : sd_numa_init(struct sched_domain_topology_level *tl, int cpu) : 
2
str : 	struct sched_domain *sd = *per_cpu_ptr(tl->data.sd, cpu);[58]
strstr : INIT : 	struct sched_domain *sd = *per_cpu_ptr(tl->data.sd, cpu); : 
2
strstr : if : 	struct sched_domain *sd = *per_cpu_ptr(tl->data.sd, cpu); : 
2
strstr : for : 	struct sched_domain *sd = *per_cpu_ptr(tl->data.sd, cpu); : 
2
strstr : while : 	struct sched_domain *sd = *per_cpu_ptr(tl->data.sd, cpu); : 
2
str : 	int level = tl->numa_level;[28]
strstr : INIT : 	int level = tl->numa_level; : 
2
strstr : if : 	int level = tl->numa_level; : 
2
strstr : for : 	int level = tl->numa_level; : 
2
strstr : while : 	int level = tl->numa_level; : 
2
str : 	int sd_weight = cpumask_weight([32]
strstr : INIT : 	int sd_weight = cpumask_weight( : 
2
strstr : if : 	int sd_weight = cpumask_weight( : 
2
strstr : for : 	int sd_weight = cpumask_weight( : 
2
strstr : while : 	int sd_weight = cpumask_weight( : 
2
str : 			sched_domains_numa_masks[level][cpu_to_node(cpu)]);[54]
strstr : INIT : 			sched_domains_numa_masks[level][cpu_to_node(cpu)]); : 
2
strstr : if : 			sched_domains_numa_masks[level][cpu_to_node(cpu)]); : 
2
strstr : for : 			sched_domains_numa_masks[level][cpu_to_node(cpu)]); : 
2
strstr : while : 			sched_domains_numa_masks[level][cpu_to_node(cpu)]); : 
2
str : 	*sd = (struct sched_domain){[29]
strstr : INIT : 	*sd = (struct sched_domain){ : 
2
strstr : if : 	*sd = (struct sched_domain){ : 
2
strstr : for : 	*sd = (struct sched_domain){ : 
2
strstr : while : 	*sd = (struct sched_domain){ : 
2
str : 		.min_interval		= sd_weight,[29]
strstr : INIT : 		.min_interval		= sd_weight, : 
2
strstr : if : 		.min_interval		= sd_weight, : 
2
strstr : for : 		.min_interval		= sd_weight, : 
2
strstr : while : 		.min_interval		= sd_weight, : 
2
str : 		.max_interval		= 2*sd_weight,[31]
strstr : INIT : 		.max_interval		= 2*sd_weight, : 
2
strstr : if : 		.max_interval		= 2*sd_weight, : 
2
strstr : for : 		.max_interval		= 2*sd_weight, : 
2
strstr : while : 		.max_interval		= 2*sd_weight, : 
2
str : 		.busy_factor		= 32,[21]
strstr : INIT : 		.busy_factor		= 32, : 
2
strstr : if : 		.busy_factor		= 32, : 
2
strstr : for : 		.busy_factor		= 32, : 
2
strstr : while : 		.busy_factor		= 32, : 
2
str : 		.imbalance_pct		= 125,[24]
strstr : INIT : 		.imbalance_pct		= 125, : 
2
strstr : if : 		.imbalance_pct		= 125, : 
2
strstr : for : 		.imbalance_pct		= 125, : 
2
strstr : while : 		.imbalance_pct		= 125, : 
2
str : 		.cache_nice_tries	= 2,[24]
strstr : INIT : 		.cache_nice_tries	= 2, : 
2
strstr : if : 		.cache_nice_tries	= 2, : 
2
strstr : for : 		.cache_nice_tries	= 2, : 
2
strstr : while : 		.cache_nice_tries	= 2, : 
2
str : 		.busy_idx		= 3,[17]
strstr : INIT : 		.busy_idx		= 3, : 
2
strstr : if : 		.busy_idx		= 3, : 
2
strstr : for : 		.busy_idx		= 3, : 
2
strstr : while : 		.busy_idx		= 3, : 
2
str : 		.idle_idx		= 2,[17]
strstr : INIT : 		.idle_idx		= 2, : 
2
strstr : if : 		.idle_idx		= 2, : 
2
strstr : for : 		.idle_idx		= 2, : 
2
strstr : while : 		.idle_idx		= 2, : 
2
str : 		.newidle_idx		= 0,[20]
strstr : INIT : 		.newidle_idx		= 0, : 
2
strstr : if : 		.newidle_idx		= 0, : 
2
strstr : for : 		.newidle_idx		= 0, : 
2
strstr : while : 		.newidle_idx		= 0, : 
2
str : 		.wake_idx		= 0,[17]
strstr : INIT : 		.wake_idx		= 0, : 
2
strstr : if : 		.wake_idx		= 0, : 
2
strstr : for : 		.wake_idx		= 0, : 
2
strstr : while : 		.wake_idx		= 0, : 
2
str : 		.forkexec_idx		= 0,[21]
strstr : INIT : 		.forkexec_idx		= 0, : 
2
strstr : if : 		.forkexec_idx		= 0, : 
2
strstr : for : 		.forkexec_idx		= 0, : 
2
strstr : while : 		.forkexec_idx		= 0, : 
2
str : 		.flags			= 1*SD_LOAD_BALANCE[30]
strstr : INIT : 		.flags			= 1*SD_LOAD_BALANCE : 
2
strstr : if : 		.flags			= 1*SD_LOAD_BALANCE : 
2
strstr : for : 		.flags			= 1*SD_LOAD_BALANCE : 
2
strstr : while : 		.flags			= 1*SD_LOAD_BALANCE : 
2
str : 					| 1*SD_BALANCE_NEWIDLE[27]
strstr : INIT : 					| 1*SD_BALANCE_NEWIDLE : 
2
strstr : if : 					| 1*SD_BALANCE_NEWIDLE : 
2
strstr : for : 					| 1*SD_BALANCE_NEWIDLE : 
2
strstr : while : 					| 1*SD_BALANCE_NEWIDLE : 
2
str : 					| 0*SD_BALANCE_EXEC[24]
strstr : INIT : 					| 0*SD_BALANCE_EXEC : 
2
strstr : if : 					| 0*SD_BALANCE_EXEC : 
2
strstr : for : 					| 0*SD_BALANCE_EXEC : 
2
strstr : while : 					| 0*SD_BALANCE_EXEC : 
2
str : 					| 0*SD_BALANCE_FORK[24]
strstr : INIT : 					| 0*SD_BALANCE_FORK : 
2
strstr : if : 					| 0*SD_BALANCE_FORK : 
2
strstr : for : 					| 0*SD_BALANCE_FORK : 
2
strstr : while : 					| 0*SD_BALANCE_FORK : 
2
str : 					| 0*SD_BALANCE_WAKE[24]
strstr : INIT : 					| 0*SD_BALANCE_WAKE : 
2
strstr : if : 					| 0*SD_BALANCE_WAKE : 
2
strstr : for : 					| 0*SD_BALANCE_WAKE : 
2
strstr : while : 					| 0*SD_BALANCE_WAKE : 
2
str : 					| 0*SD_WAKE_AFFINE[23]
strstr : INIT : 					| 0*SD_WAKE_AFFINE : 
2
strstr : if : 					| 0*SD_WAKE_AFFINE : 
2
strstr : for : 					| 0*SD_WAKE_AFFINE : 
2
strstr : while : 					| 0*SD_WAKE_AFFINE : 
2
str : 					| 0*SD_SHARE_CPUPOWER[26]
strstr : INIT : 					| 0*SD_SHARE_CPUPOWER : 
2
strstr : if : 					| 0*SD_SHARE_CPUPOWER : 
2
strstr : for : 					| 0*SD_SHARE_CPUPOWER : 
2
strstr : while : 					| 0*SD_SHARE_CPUPOWER : 
2
str : 					| 0*SD_SHARE_PKG_RESOURCES[31]
strstr : INIT : 					| 0*SD_SHARE_PKG_RESOURCES : 
2
strstr : if : 					| 0*SD_SHARE_PKG_RESOURCES : 
2
strstr : for : 					| 0*SD_SHARE_PKG_RESOURCES : 
2
strstr : while : 					| 0*SD_SHARE_PKG_RESOURCES : 
2
str : 					| 1*SD_SERIALIZE[21]
strstr : INIT : 					| 1*SD_SERIALIZE : 
2
strstr : if : 					| 1*SD_SERIALIZE : 
2
strstr : for : 					| 1*SD_SERIALIZE : 
2
strstr : while : 					| 1*SD_SERIALIZE : 
2
str : 					| 0*SD_PREFER_SIBLING[26]
strstr : INIT : 					| 0*SD_PREFER_SIBLING : 
2
strstr : if : 					| 0*SD_PREFER_SIBLING : 
2
strstr : for : 					| 0*SD_PREFER_SIBLING : 
2
strstr : while : 					| 0*SD_PREFER_SIBLING : 
2
str : 					| 1*SD_NUMA[16]
strstr : INIT : 					| 1*SD_NUMA : 
2
strstr : if : 					| 1*SD_NUMA : 
2
strstr : for : 					| 1*SD_NUMA : 
2
strstr : while : 					| 1*SD_NUMA : 
2
str : 					| sd_local_flags(level)[28]
strstr : INIT : 					| sd_local_flags(level) : 
2
strstr : if : 					| sd_local_flags(level) : 
2
strstr : for : 					| sd_local_flags(level) : 
2
strstr : while : 					| sd_local_flags(level) : 
2
str : 					,[6]
strstr : INIT : 					, : 
2
strstr : if : 					, : 
2
strstr : for : 					, : 
2
strstr : while : 					, : 
2
str : 		.last_balance		= jiffies,[27]
strstr : INIT : 		.last_balance		= jiffies, : 
2
strstr : if : 		.last_balance		= jiffies, : 
2
strstr : for : 		.last_balance		= jiffies, : 
2
strstr : while : 		.last_balance		= jiffies, : 
2
str : 		.balance_interval	= sd_weight,[32]
strstr : INIT : 		.balance_interval	= sd_weight, : 
2
strstr : if : 		.balance_interval	= sd_weight, : 
2
strstr : for : 		.balance_interval	= sd_weight, : 
2
strstr : while : 		.balance_interval	= sd_weight, : 
2
str : 	};[3]
strstr : INIT : 	}; : 
2
strstr : if : 	}; : 
2
strstr : for : 	}; : 
2
strstr : while : 	}; : 
2
str : 	SD_INIT_NAME(sd, NUMA);[24]
strstr : INIT : 	SD_INIT_NAME(sd, NUMA); : 
2
strstr : if : 	SD_INIT_NAME(sd, NUMA); : 
2
strstr : for : 	SD_INIT_NAME(sd, NUMA); : 
2
strstr : while : 	SD_INIT_NAME(sd, NUMA); : 
2
str : 	sd->private = &tl->data;[25]
strstr : INIT : 	sd->private = &tl->data; : 
2
strstr : if : 	sd->private = &tl->data; : 
2
strstr : for : 	sd->private = &tl->data; : 
2
strstr : while : 	sd->private = &tl->data; : 
2
str : 	/*[3]
strstr : INIT : 	/* : 
2
strstr : if : 	/* : 
2
strstr : for : 	/* : 
2
strstr : while : 	/* : 
2
str : 	 * Ugly hack to pass state to sd_numa_mask()...[48]
strstr : INIT : 	 * Ugly hack to pass state to sd_numa_mask()... : 
2
strstr : if : 	 * Ugly hack to pass state to sd_numa_mask()... : 
2
strstr : for : 	 * Ugly hack to pass state to sd_numa_mask()... : 
2
strstr : while : 	 * Ugly hack to pass state to sd_numa_mask()... : 
2
str : 	 */[4]
strstr : INIT : 	 */ : 
2
strstr : if : 	 */ : 
2
strstr : for : 	 */ : 
2
strstr : while : 	 */ : 
2
str : 	sched_domains_curr_level = tl->numa_level;[43]
strstr : INIT : 	sched_domains_curr_level = tl->numa_level; : 
2
strstr : if : 	sched_domains_curr_level = tl->numa_level; : 
2
strstr : for : 	sched_domains_curr_level = tl->numa_level; : 
2
strstr : while : 	sched_domains_curr_level = tl->numa_level; : 
2
str : 	return sd;[11]
strstr : INIT : 	return sd; : 
2
strstr : if : 	return sd; : 
2
strstr : for : 	return sd; : 
2
strstr : while : 	return sd; : 
2
str : static const struct cpumask *sd_numa_mask(int cpu)[50]
strstr : INIT : static const struct cpumask *sd_numa_mask(int cpu) : 
2
strstr : if : static const struct cpumask *sd_numa_mask(int cpu) : 
2
strstr : for : static const struct cpumask *sd_numa_mask(int cpu) : 
2
strstr : while : static const struct cpumask *sd_numa_mask(int cpu) : 
2
str : 	return sched_domains_numa_masks[sched_domains_curr_level][cpu_to_node(cpu)];[77]
strstr : INIT : 	return sched_domains_numa_masks[sched_domains_curr_level][cpu_to_node(cpu)]; : 
2
strstr : if : 	return sched_domains_numa_masks[sched_domains_curr_level][cpu_to_node(cpu)]; : 
2
strstr : for : 	return sched_domains_numa_masks[sched_domains_curr_level][cpu_to_node(cpu)]; : 
2
strstr : while : 	return sched_domains_numa_masks[sched_domains_curr_level][cpu_to_node(cpu)]; : 
2
str : static void sched_numa_warn(const char *str)[44]
strstr : INIT : static void sched_numa_warn(const char *str) : 
2
strstr : if : static void sched_numa_warn(const char *str) : 
2
strstr : for : static void sched_numa_warn(const char *str) : 
2
strstr : while : static void sched_numa_warn(const char *str) : 
2
str : 	static int done = false;[25]
strstr : INIT : 	static int done = false; : 
2
strstr : if : 	static int done = false; : 
2
strstr : for : 	static int done = false; : 
2
strstr : while : 	static int done = false; : 
2
str : 	int i,j;[9]
strstr : INIT : 	int i,j; : 
2
strstr : if : 	int i,j; : 
2
strstr : for : 	int i,j; : 
2
strstr : while : 	int i,j; : 
2
str : 	if (done)[10]
strstr : INIT : 	if (done) : 
2
strstr : if : 	if (done) : 
2
strstr : for : 	if (done) : 
2
strstr : while : 	if (done) : 
2
str : 		return;[9]
strstr : INIT : 		return; : 
2
strstr : if : 		return; : 
2
strstr : for : 		return; : 
2
strstr : while : 		return; : 
2
str : 	done = true;[13]
strstr : INIT : 	done = true; : 
2
strstr : if : 	done = true; : 
2
strstr : for : 	done = true; : 
2
strstr : while : 	done = true; : 
2
str : 	printk(KERN_WARNING "ERROR: %s\n\n", str);[43]
strstr : INIT : 	printk(KERN_WARNING "ERROR: %s\n\n", str); : 
2
strstr : if : 	printk(KERN_WARNING "ERROR: %s\n\n", str); : 
2
strstr : for : 	printk(KERN_WARNING "ERROR: %s\n\n", str); : 
2
strstr : while : 	printk(KERN_WARNING "ERROR: %s\n\n", str); : 
2
str : 	for (i = 0; i < nr_node_ids; i++) {[36]
strstr : INIT : 	for (i = 0; i < nr_node_ids; i++) { : 
2
strstr : if : 	for (i = 0; i < nr_node_ids; i++) { : 
2
strstr : for : 	for (i = 0; i < nr_node_ids; i++) { : 
2
strstr : while : 	for (i = 0; i < nr_node_ids; i++) { : 
2
str : 		printk(KERN_WARNING "  ");[28]
strstr : INIT : 		printk(KERN_WARNING "  "); : 
2
strstr : if : 		printk(KERN_WARNING "  "); : 
2
strstr : for : 		printk(KERN_WARNING "  "); : 
2
strstr : while : 		printk(KERN_WARNING "  "); : 
2
str : 		for (j = 0; j < nr_node_ids; j++)[35]
strstr : INIT : 		for (j = 0; j < nr_node_ids; j++) : 
2
strstr : if : 		for (j = 0; j < nr_node_ids; j++) : 
2
strstr : for : 		for (j = 0; j < nr_node_ids; j++) : 
2
strstr : while : 		for (j = 0; j < nr_node_ids; j++) : 
2
str : 			printk(KERN_CONT "%02d ", node_distance(i,j));[49]
strstr : INIT : 			printk(KERN_CONT "%02d ", node_distance(i,j)); : 
2
strstr : if : 			printk(KERN_CONT "%02d ", node_distance(i,j)); : 
2
strstr : for : 			printk(KERN_CONT "%02d ", node_distance(i,j)); : 
2
strstr : while : 			printk(KERN_CONT "%02d ", node_distance(i,j)); : 
2
str : 		printk(KERN_CONT "\n");[25]
strstr : INIT : 		printk(KERN_CONT "\n"); : 
2
strstr : if : 		printk(KERN_CONT "\n"); : 
2
strstr : for : 		printk(KERN_CONT "\n"); : 
2
strstr : while : 		printk(KERN_CONT "\n"); : 
2
str : 	printk(KERN_WARNING "\n");[27]
strstr : INIT : 	printk(KERN_WARNING "\n"); : 
2
strstr : if : 	printk(KERN_WARNING "\n"); : 
2
strstr : for : 	printk(KERN_WARNING "\n"); : 
2
strstr : while : 	printk(KERN_WARNING "\n"); : 
2
str : static bool find_numa_distance(int distance)[44]
strstr : INIT : static bool find_numa_distance(int distance) : 
2
strstr : if : static bool find_numa_distance(int distance) : 
2
strstr : for : static bool find_numa_distance(int distance) : 
2
strstr : while : static bool find_numa_distance(int distance) : 
2
str : 	int i;[7]
strstr : INIT : 	int i; : 
2
strstr : if : 	int i; : 
2
strstr : for : 	int i; : 
2
strstr : while : 	int i; : 
2
str : 	if (distance == node_distance(0, 0))[37]
strstr : INIT : 	if (distance == node_distance(0, 0)) : 
2
strstr : if : 	if (distance == node_distance(0, 0)) : 
2
strstr : for : 	if (distance == node_distance(0, 0)) : 
2
strstr : while : 	if (distance == node_distance(0, 0)) : 
2
str : 		return true;[14]
strstr : INIT : 		return true; : 
2
strstr : if : 		return true; : 
2
strstr : for : 		return true; : 
2
strstr : while : 		return true; : 
2
str : 	for (i = 0; i < sched_domains_numa_levels; i++) {[50]
strstr : INIT : 	for (i = 0; i < sched_domains_numa_levels; i++) { : 
2
strstr : if : 	for (i = 0; i < sched_domains_numa_levels; i++) { : 
2
strstr : for : 	for (i = 0; i < sched_domains_numa_levels; i++) { : 
2
strstr : while : 	for (i = 0; i < sched_domains_numa_levels; i++) { : 
2
str : 		if (sched_domains_numa_distance[i] == distance)[49]
strstr : INIT : 		if (sched_domains_numa_distance[i] == distance) : 
2
strstr : if : 		if (sched_domains_numa_distance[i] == distance) : 
2
strstr : for : 		if (sched_domains_numa_distance[i] == distance) : 
2
strstr : while : 		if (sched_domains_numa_distance[i] == distance) : 
2
str : 			return true;[15]
strstr : INIT : 			return true; : 
2
strstr : if : 			return true; : 
2
strstr : for : 			return true; : 
2
strstr : while : 			return true; : 
2
str : 	return false;[14]
strstr : INIT : 	return false; : 
2
strstr : if : 	return false; : 
2
strstr : for : 	return false; : 
2
strstr : while : 	return false; : 
2
str : static void sched_init_numa(void)[33]
strstr : INIT : static void sched_init_numa(void) : 
2
strstr : if : static void sched_init_numa(void) : 
2
strstr : for : static void sched_init_numa(void) : 
2
strstr : while : static void sched_init_numa(void) : 
2
str : 	int next_distance, curr_distance = node_distance(0, 0);[56]
strstr : INIT : 	int next_distance, curr_distance = node_distance(0, 0); : 
2
strstr : if : 	int next_distance, curr_distance = node_distance(0, 0); : 
2
strstr : for : 	int next_distance, curr_distance = node_distance(0, 0); : 
2
strstr : while : 	int next_distance, curr_distance = node_distance(0, 0); : 
2
str : 	struct sched_domain_topology_level *tl;[40]
strstr : INIT : 	struct sched_domain_topology_level *tl; : 
2
strstr : if : 	struct sched_domain_topology_level *tl; : 
2
strstr : for : 	struct sched_domain_topology_level *tl; : 
2
strstr : while : 	struct sched_domain_topology_level *tl; : 
2
str : 	int level = 0;[15]
strstr : INIT : 	int level = 0; : 
2
strstr : if : 	int level = 0; : 
2
strstr : for : 	int level = 0; : 
2
strstr : while : 	int level = 0; : 
2
str : 	int i, j, k;[13]
strstr : INIT : 	int i, j, k; : 
2
strstr : if : 	int i, j, k; : 
2
strstr : for : 	int i, j, k; : 
2
strstr : while : 	int i, j, k; : 
2
str : 	sched_domains_numa_distance = kzalloc(sizeof(int) * nr_node_ids, GFP_KERNEL);[78]
strstr : INIT : 	sched_domains_numa_distance = kzalloc(sizeof(int) * nr_node_ids, GFP_KERNEL); : 
2
strstr : if : 	sched_domains_numa_distance = kzalloc(sizeof(int) * nr_node_ids, GFP_KERNEL); : 
2
strstr : for : 	sched_domains_numa_distance = kzalloc(sizeof(int) * nr_node_ids, GFP_KERNEL); : 
2
strstr : while : 	sched_domains_numa_distance = kzalloc(sizeof(int) * nr_node_ids, GFP_KERNEL); : 
2
str : 	if (!sched_domains_numa_distance)[34]
strstr : INIT : 	if (!sched_domains_numa_distance) : 
2
strstr : if : 	if (!sched_domains_numa_distance) : 
2
strstr : for : 	if (!sched_domains_numa_distance) : 
2
strstr : while : 	if (!sched_domains_numa_distance) : 
2
str : 		return;[9]
strstr : INIT : 		return; : 
2
strstr : if : 		return; : 
2
strstr : for : 		return; : 
2
strstr : while : 		return; : 
2
str : 	/*[3]
strstr : INIT : 	/* : 
2
strstr : if : 	/* : 
2
strstr : for : 	/* : 
2
strstr : while : 	/* : 
2
str : 	 * O(nr_nodes^2) deduplicating selection sort -- in order to find the[70]
strstr : INIT : 	 * O(nr_nodes^2) deduplicating selection sort -- in order to find the : 
2
strstr : if : 	 * O(nr_nodes^2) deduplicating selection sort -- in order to find the : 
2
strstr : for : 	 * O(nr_nodes^2) deduplicating selection sort -- in order to find the : 
2
strstr : while : 	 * O(nr_nodes^2) deduplicating selection sort -- in order to find the : 
2
str : 	 * unique distances in the node_distance() table.[50]
strstr : INIT : 	 * unique distances in the node_distance() table. : 
2
strstr : if : 	 * unique distances in the node_distance() table. : 
2
strstr : for : 	 * unique distances in the node_distance() table. : 
2
strstr : while : 	 * unique distances in the node_distance() table. : 
2
str : 	 *[3]
strstr : INIT : 	 * : 
2
strstr : if : 	 * : 
2
strstr : for : 	 * : 
2
strstr : while : 	 * : 
2
str : 	 * Assumes node_distance(0,j) includes all distances in[56]
strstr : INIT : 	 * Assumes node_distance(0,j) includes all distances in : 
2
strstr : if : 	 * Assumes node_distance(0,j) includes all distances in : 
2
strstr : for : 	 * Assumes node_distance(0,j) includes all distances in : 
2
strstr : while : 	 * Assumes node_distance(0,j) includes all distances in : 
2
str : 	 * node_distance(i,j) in order to avoid cubic time.[52]
strstr : INIT : 	 * node_distance(i,j) in order to avoid cubic time. : 
2
strstr : if : 	 * node_distance(i,j) in order to avoid cubic time. : 
2
strstr : for : 	 * node_distance(i,j) in order to avoid cubic time. : 
2
strstr : while : 	 * node_distance(i,j) in order to avoid cubic time. : 
2
str : 	 */[4]
strstr : INIT : 	 */ : 
2
strstr : if : 	 */ : 
2
strstr : for : 	 */ : 
2
strstr : while : 	 */ : 
2
str : 	next_distance = curr_distance;[31]
strstr : INIT : 	next_distance = curr_distance; : 
2
strstr : if : 	next_distance = curr_distance; : 
2
strstr : for : 	next_distance = curr_distance; : 
2
strstr : while : 	next_distance = curr_distance; : 
2
str : 	for (i = 0; i < nr_node_ids; i++) {[36]
strstr : INIT : 	for (i = 0; i < nr_node_ids; i++) { : 
2
strstr : if : 	for (i = 0; i < nr_node_ids; i++) { : 
2
strstr : for : 	for (i = 0; i < nr_node_ids; i++) { : 
2
strstr : while : 	for (i = 0; i < nr_node_ids; i++) { : 
2
str : 		for (j = 0; j < nr_node_ids; j++) {[37]
strstr : INIT : 		for (j = 0; j < nr_node_ids; j++) { : 
2
strstr : if : 		for (j = 0; j < nr_node_ids; j++) { : 
2
strstr : for : 		for (j = 0; j < nr_node_ids; j++) { : 
2
strstr : while : 		for (j = 0; j < nr_node_ids; j++) { : 
2
str : 			for (k = 0; k < nr_node_ids; k++) {[38]
strstr : INIT : 			for (k = 0; k < nr_node_ids; k++) { : 
2
strstr : if : 			for (k = 0; k < nr_node_ids; k++) { : 
2
strstr : for : 			for (k = 0; k < nr_node_ids; k++) { : 
2
strstr : while : 			for (k = 0; k < nr_node_ids; k++) { : 
2
str : 				int distance = node_distance(i, k);[39]
strstr : INIT : 				int distance = node_distance(i, k); : 
2
strstr : if : 				int distance = node_distance(i, k); : 
2
strstr : for : 				int distance = node_distance(i, k); : 
2
strstr : while : 				int distance = node_distance(i, k); : 
2
str : 				if (distance > curr_distance &&[35]
strstr : INIT : 				if (distance > curr_distance && : 
2
strstr : if : 				if (distance > curr_distance && : 
2
strstr : for : 				if (distance > curr_distance && : 
2
strstr : while : 				if (distance > curr_distance && : 
2
str : 				    (distance < next_distance ||[36]
strstr : INIT : 				    (distance < next_distance || : 
2
strstr : if : 				    (distance < next_distance || : 
2
strstr : for : 				    (distance < next_distance || : 
2
strstr : while : 				    (distance < next_distance || : 
2
str : 				     next_distance == curr_distance))[41]
strstr : INIT : 				     next_distance == curr_distance)) : 
2
strstr : if : 				     next_distance == curr_distance)) : 
2
strstr : for : 				     next_distance == curr_distance)) : 
2
strstr : while : 				     next_distance == curr_distance)) : 
2
str : 					next_distance = distance;[30]
strstr : INIT : 					next_distance = distance; : 
2
strstr : if : 					next_distance = distance; : 
2
strstr : for : 					next_distance = distance; : 
2
strstr : while : 					next_distance = distance; : 
2
str : 				/*[6]
strstr : INIT : 				/* : 
2
strstr : if : 				/* : 
2
strstr : for : 				/* : 
2
strstr : while : 				/* : 
2
str : 				 * While not a strong assumption it would be nice to know[61]
strstr : INIT : 				 * While not a strong assumption it would be nice to know : 
2
strstr : if : 				 * While not a strong assumption it would be nice to know : 
2
strstr : for : 				 * While not a strong assumption it would be nice to know : 
2
strstr : while : 				 * While not a strong assumption it would be nice to know : 
2
str : 				 * about cases where if node A is connected to B, B is not[62]
strstr : INIT : 				 * about cases where if node A is connected to B, B is not : 
2
strstr : if : 				 * about cases where if node A is connected to B, B is not : 
2
strstr : for : 				 * about cases where if node A is connected to B, B is not : 
2
strstr : while : 				 * about cases where if node A is connected to B, B is not : 
2
str : 				 * equally connected to A.[30]
strstr : INIT : 				 * equally connected to A. : 
2
strstr : if : 				 * equally connected to A. : 
2
strstr : for : 				 * equally connected to A. : 
2
strstr : while : 				 * equally connected to A. : 
2
str : 				 */[7]
strstr : INIT : 				 */ : 
2
strstr : if : 				 */ : 
2
strstr : for : 				 */ : 
2
strstr : while : 				 */ : 
2
str : 				if (sched_debug() && node_distance(k, i) != distance)[57]
strstr : INIT : 				if (sched_debug() && node_distance(k, i) != distance) : 
2
strstr : if : 				if (sched_debug() && node_distance(k, i) != distance) : 
2
strstr : for : 				if (sched_debug() && node_distance(k, i) != distance) : 
2
strstr : while : 				if (sched_debug() && node_distance(k, i) != distance) : 
2
str : 					sched_numa_warn("Node-distance not symmetric");[52]
strstr : INIT : 					sched_numa_warn("Node-distance not symmetric"); : 
2
strstr : if : 					sched_numa_warn("Node-distance not symmetric"); : 
2
strstr : for : 					sched_numa_warn("Node-distance not symmetric"); : 
2
strstr : while : 					sched_numa_warn("Node-distance not symmetric"); : 
2
str : 				if (sched_debug() && i && !find_numa_distance(distance))[60]
strstr : INIT : 				if (sched_debug() && i && !find_numa_distance(distance)) : 
2
strstr : if : 				if (sched_debug() && i && !find_numa_distance(distance)) : 
2
strstr : for : 				if (sched_debug() && i && !find_numa_distance(distance)) : 
2
strstr : while : 				if (sched_debug() && i && !find_numa_distance(distance)) : 
2
str : 					sched_numa_warn("Node-0 not representative");[50]
strstr : INIT : 					sched_numa_warn("Node-0 not representative"); : 
2
strstr : if : 					sched_numa_warn("Node-0 not representative"); : 
2
strstr : for : 					sched_numa_warn("Node-0 not representative"); : 
2
strstr : while : 					sched_numa_warn("Node-0 not representative"); : 
2
str : 			}[4]
strstr : INIT : 			} : 
2
strstr : if : 			} : 
2
strstr : for : 			} : 
2
strstr : while : 			} : 
2
str : 			if (next_distance != curr_distance) {[40]
strstr : INIT : 			if (next_distance != curr_distance) { : 
2
strstr : if : 			if (next_distance != curr_distance) { : 
2
strstr : for : 			if (next_distance != curr_distance) { : 
2
strstr : while : 			if (next_distance != curr_distance) { : 
2
str : 				sched_domains_numa_distance[level++] = next_distance;[57]
strstr : INIT : 				sched_domains_numa_distance[level++] = next_distance; : 
2
strstr : if : 				sched_domains_numa_distance[level++] = next_distance; : 
2
strstr : for : 				sched_domains_numa_distance[level++] = next_distance; : 
2
strstr : while : 				sched_domains_numa_distance[level++] = next_distance; : 
2
str : 				sched_domains_numa_levels = level;[38]
strstr : INIT : 				sched_domains_numa_levels = level; : 
2
strstr : if : 				sched_domains_numa_levels = level; : 
2
strstr : for : 				sched_domains_numa_levels = level; : 
2
strstr : while : 				sched_domains_numa_levels = level; : 
2
str : 				curr_distance = next_distance;[34]
strstr : INIT : 				curr_distance = next_distance; : 
2
strstr : if : 				curr_distance = next_distance; : 
2
strstr : for : 				curr_distance = next_distance; : 
2
strstr : while : 				curr_distance = next_distance; : 
2
str : 			} else break;[16]
strstr : INIT : 			} else break; : 
2
strstr : if : 			} else break; : 
2
strstr : for : 			} else break; : 
2
strstr : while : 			} else break; : 
2
str : 		}[3]
strstr : INIT : 		} : 
2
strstr : if : 		} : 
2
strstr : for : 		} : 
2
strstr : while : 		} : 
2
str : 		/*[4]
strstr : INIT : 		/* : 
2
strstr : if : 		/* : 
2
strstr : for : 		/* : 
2
strstr : while : 		/* : 
2
str : 		 * In case of sched_debug() we verify the above assumption.[61]
strstr : INIT : 		 * In case of sched_debug() we verify the above assumption. : 
2
strstr : if : 		 * In case of sched_debug() we verify the above assumption. : 
2
strstr : for : 		 * In case of sched_debug() we verify the above assumption. : 
2
strstr : while : 		 * In case of sched_debug() we verify the above assumption. : 
2
str : 		 */[5]
strstr : INIT : 		 */ : 
2
strstr : if : 		 */ : 
2
strstr : for : 		 */ : 
2
strstr : while : 		 */ : 
2
str : 		if (!sched_debug())[21]
strstr : INIT : 		if (!sched_debug()) : 
2
strstr : if : 		if (!sched_debug()) : 
2
strstr : for : 		if (!sched_debug()) : 
2
strstr : while : 		if (!sched_debug()) : 
2
str : 			break;[9]
strstr : INIT : 			break; : 
2
strstr : if : 			break; : 
2
strstr : for : 			break; : 
2
strstr : while : 			break; : 
2
str : 	/*[3]
strstr : INIT : 	/* : 
2
strstr : if : 	/* : 
2
strstr : for : 	/* : 
2
strstr : while : 	/* : 
2
str : 	 * 'level' contains the number of unique distances, excluding the[66]
strstr : INIT : 	 * 'level' contains the number of unique distances, excluding the : 
2
strstr : if : 	 * 'level' contains the number of unique distances, excluding the : 
2
strstr : for : 	 * 'level' contains the number of unique distances, excluding the : 
2
strstr : while : 	 * 'level' contains the number of unique distances, excluding the : 
2
str : 	 * identity distance node_distance(i,i).[41]
strstr : INIT : 	 * identity distance node_distance(i,i). : 
2
strstr : if : 	 * identity distance node_distance(i,i). : 
2
strstr : for : 	 * identity distance node_distance(i,i). : 
2
strstr : while : 	 * identity distance node_distance(i,i). : 
2
str : 	 *[3]
strstr : INIT : 	 * : 
2
strstr : if : 	 * : 
2
strstr : for : 	 * : 
2
strstr : while : 	 * : 
2
str : 	 * The sched_domains_numa_distance[] array includes the actual distance[72]
strstr : INIT : 	 * The sched_domains_numa_distance[] array includes the actual distance : 
2
strstr : if : 	 * The sched_domains_numa_distance[] array includes the actual distance : 
2
strstr : for : 	 * The sched_domains_numa_distance[] array includes the actual distance : 
2
strstr : while : 	 * The sched_domains_numa_distance[] array includes the actual distance : 
2
str : 	 * numbers.[12]
strstr : INIT : 	 * numbers. : 
2
strstr : if : 	 * numbers. : 
2
strstr : for : 	 * numbers. : 
2
strstr : while : 	 * numbers. : 
2
str : 	 */[4]
strstr : INIT : 	 */ : 
2
strstr : if : 	 */ : 
2
strstr : for : 	 */ : 
2
strstr : while : 	 */ : 
2
str : 	/*[3]
strstr : INIT : 	/* : 
2
strstr : if : 	/* : 
2
strstr : for : 	/* : 
2
strstr : while : 	/* : 
2
str : 	 * Here, we should temporarily reset sched_domains_numa_levels to 0.[69]
strstr : INIT : 	 * Here, we should temporarily reset sched_domains_numa_levels to 0. : 
2
strstr : if : 	 * Here, we should temporarily reset sched_domains_numa_levels to 0. : 
2
strstr : for : 	 * Here, we should temporarily reset sched_domains_numa_levels to 0. : 
2
strstr : while : 	 * Here, we should temporarily reset sched_domains_numa_levels to 0. : 
2
str : 	 * If it fails to allocate memory for array sched_domains_numa_masks[][],[74]
strstr : INIT : 	 * If it fails to allocate memory for array sched_domains_numa_masks[][], : 
2
strstr : if : 	 * If it fails to allocate memory for array sched_domains_numa_masks[][], : 
2
strstr : for : 	 * If it fails to allocate memory for array sched_domains_numa_masks[][], : 
2
strstr : while : 	 * If it fails to allocate memory for array sched_domains_numa_masks[][], : 
2
str : 	 * the array will contain less then 'level' members. This could be[67]
strstr : INIT : 	 * the array will contain less then 'level' members. This could be : 
2
strstr : if : 	 * the array will contain less then 'level' members. This could be : 
2
strstr : for : 	 * the array will contain less then 'level' members. This could be : 
2
strstr : while : 	 * the array will contain less then 'level' members. This could be : 
2
str : 	 * dangerous when we use it to iterate array sched_domains_numa_masks[][][74]
strstr : INIT : 	 * dangerous when we use it to iterate array sched_domains_numa_masks[][] : 
2
strstr : if : 	 * dangerous when we use it to iterate array sched_domains_numa_masks[][] : 
2
strstr : for : 	 * dangerous when we use it to iterate array sched_domains_numa_masks[][] : 
2
strstr : while : 	 * dangerous when we use it to iterate array sched_domains_numa_masks[][] : 
2
str : 	 * in other functions.[23]
strstr : INIT : 	 * in other functions. : 
2
strstr : if : 	 * in other functions. : 
2
strstr : for : 	 * in other functions. : 
2
strstr : while : 	 * in other functions. : 
2
str : 	 *[3]
strstr : INIT : 	 * : 
2
strstr : if : 	 * : 
2
strstr : for : 	 * : 
2
strstr : while : 	 * : 
2
str : 	 * We reset it to 'level' at the end of this function.[55]
strstr : INIT : 	 * We reset it to 'level' at the end of this function. : 
2
strstr : if : 	 * We reset it to 'level' at the end of this function. : 
2
strstr : for : 	 * We reset it to 'level' at the end of this function. : 
2
strstr : while : 	 * We reset it to 'level' at the end of this function. : 
2
str : 	 */[4]
strstr : INIT : 	 */ : 
2
strstr : if : 	 */ : 
2
strstr : for : 	 */ : 
2
strstr : while : 	 */ : 
2
str : 	sched_domains_numa_levels = 0;[31]
strstr : INIT : 	sched_domains_numa_levels = 0; : 
2
strstr : if : 	sched_domains_numa_levels = 0; : 
2
strstr : for : 	sched_domains_numa_levels = 0; : 
2
strstr : while : 	sched_domains_numa_levels = 0; : 
2
str : 	sched_domains_numa_masks = kzalloc(sizeof(void *) * level, GFP_KERNEL);[72]
strstr : INIT : 	sched_domains_numa_masks = kzalloc(sizeof(void *) * level, GFP_KERNEL); : 
2
strstr : if : 	sched_domains_numa_masks = kzalloc(sizeof(void *) * level, GFP_KERNEL); : 
2
strstr : for : 	sched_domains_numa_masks = kzalloc(sizeof(void *) * level, GFP_KERNEL); : 
2
strstr : while : 	sched_domains_numa_masks = kzalloc(sizeof(void *) * level, GFP_KERNEL); : 
2
str : 	if (!sched_domains_numa_masks)[31]
strstr : INIT : 	if (!sched_domains_numa_masks) : 
2
strstr : if : 	if (!sched_domains_numa_masks) : 
2
strstr : for : 	if (!sched_domains_numa_masks) : 
2
strstr : while : 	if (!sched_domains_numa_masks) : 
2
str : 		return;[9]
strstr : INIT : 		return; : 
2
strstr : if : 		return; : 
2
strstr : for : 		return; : 
2
strstr : while : 		return; : 
2
str : 	/*[3]
strstr : INIT : 	/* : 
2
strstr : if : 	/* : 
2
strstr : for : 	/* : 
2
strstr : while : 	/* : 
2
str : 	 * Now for each level, construct a mask per node which contains all[68]
strstr : INIT : 	 * Now for each level, construct a mask per node which contains all : 
2
strstr : if : 	 * Now for each level, construct a mask per node which contains all : 
2
strstr : for : 	 * Now for each level, construct a mask per node which contains all : 
2
strstr : while : 	 * Now for each level, construct a mask per node which contains all : 
2
str : 	 * cpus of nodes that are that many hops away from us.[55]
strstr : INIT : 	 * cpus of nodes that are that many hops away from us. : 
2
strstr : if : 	 * cpus of nodes that are that many hops away from us. : 
2
strstr : for : 	 * cpus of nodes that are that many hops away from us. : 
2
strstr : while : 	 * cpus of nodes that are that many hops away from us. : 
2
str : 	 */[4]
strstr : INIT : 	 */ : 
2
strstr : if : 	 */ : 
2
strstr : for : 	 */ : 
2
strstr : while : 	 */ : 
2
str : 	for (i = 0; i < level; i++) {[30]
strstr : INIT : 	for (i = 0; i < level; i++) { : 
2
strstr : if : 	for (i = 0; i < level; i++) { : 
2
strstr : for : 	for (i = 0; i < level; i++) { : 
2
strstr : while : 	for (i = 0; i < level; i++) { : 
2
str : 		sched_domains_numa_masks[i] =[31]
strstr : INIT : 		sched_domains_numa_masks[i] = : 
2
strstr : if : 		sched_domains_numa_masks[i] = : 
2
strstr : for : 		sched_domains_numa_masks[i] = : 
2
strstr : while : 		sched_domains_numa_masks[i] = : 
2
str : 			kzalloc(nr_node_ids * sizeof(void *), GFP_KERNEL);[53]
strstr : INIT : 			kzalloc(nr_node_ids * sizeof(void *), GFP_KERNEL); : 
2
strstr : if : 			kzalloc(nr_node_ids * sizeof(void *), GFP_KERNEL); : 
2
strstr : for : 			kzalloc(nr_node_ids * sizeof(void *), GFP_KERNEL); : 
2
strstr : while : 			kzalloc(nr_node_ids * sizeof(void *), GFP_KERNEL); : 
2
str : 		if (!sched_domains_numa_masks[i])[35]
strstr : INIT : 		if (!sched_domains_numa_masks[i]) : 
2
strstr : if : 		if (!sched_domains_numa_masks[i]) : 
2
strstr : for : 		if (!sched_domains_numa_masks[i]) : 
2
strstr : while : 		if (!sched_domains_numa_masks[i]) : 
2
str : 			return;[10]
strstr : INIT : 			return; : 
2
strstr : if : 			return; : 
2
strstr : for : 			return; : 
2
strstr : while : 			return; : 
2
str : 		for (j = 0; j < nr_node_ids; j++) {[37]
strstr : INIT : 		for (j = 0; j < nr_node_ids; j++) { : 
2
strstr : if : 		for (j = 0; j < nr_node_ids; j++) { : 
2
strstr : for : 		for (j = 0; j < nr_node_ids; j++) { : 
2
strstr : while : 		for (j = 0; j < nr_node_ids; j++) { : 
2
str : 			struct cpumask *mask = kzalloc(cpumask_size(), GFP_KERNEL);[62]
strstr : INIT : 			struct cpumask *mask = kzalloc(cpumask_size(), GFP_KERNEL); : 
2
strstr : if : 			struct cpumask *mask = kzalloc(cpumask_size(), GFP_KERNEL); : 
2
strstr : for : 			struct cpumask *mask = kzalloc(cpumask_size(), GFP_KERNEL); : 
2
strstr : while : 			struct cpumask *mask = kzalloc(cpumask_size(), GFP_KERNEL); : 
2
str : 			if (!mask)[13]
strstr : INIT : 			if (!mask) : 
2
strstr : if : 			if (!mask) : 
2
strstr : for : 			if (!mask) : 
2
strstr : while : 			if (!mask) : 
2
str : 				return;[11]
strstr : INIT : 				return; : 
2
strstr : if : 				return; : 
2
strstr : for : 				return; : 
2
strstr : while : 				return; : 
2
str : 			sched_domains_numa_masks[i][j] = mask;[41]
strstr : INIT : 			sched_domains_numa_masks[i][j] = mask; : 
2
strstr : if : 			sched_domains_numa_masks[i][j] = mask; : 
2
strstr : for : 			sched_domains_numa_masks[i][j] = mask; : 
2
strstr : while : 			sched_domains_numa_masks[i][j] = mask; : 
2
str : 			for (k = 0; k < nr_node_ids; k++) {[38]
strstr : INIT : 			for (k = 0; k < nr_node_ids; k++) { : 
2
strstr : if : 			for (k = 0; k < nr_node_ids; k++) { : 
2
strstr : for : 			for (k = 0; k < nr_node_ids; k++) { : 
2
strstr : while : 			for (k = 0; k < nr_node_ids; k++) { : 
2
str : 				if (node_distance(j, k) > sched_domains_numa_distance[i])[61]
strstr : INIT : 				if (node_distance(j, k) > sched_domains_numa_distance[i]) : 
2
strstr : if : 				if (node_distance(j, k) > sched_domains_numa_distance[i]) : 
2
strstr : for : 				if (node_distance(j, k) > sched_domains_numa_distance[i]) : 
2
strstr : while : 				if (node_distance(j, k) > sched_domains_numa_distance[i]) : 
2
str : 					continue;[14]
strstr : INIT : 					continue; : 
2
strstr : if : 					continue; : 
2
strstr : for : 					continue; : 
2
strstr : while : 					continue; : 
2
str : 				cpumask_or(mask, mask, cpumask_of_node(k));[47]
strstr : INIT : 				cpumask_or(mask, mask, cpumask_of_node(k)); : 
2
strstr : if : 				cpumask_or(mask, mask, cpumask_of_node(k)); : 
2
strstr : for : 				cpumask_or(mask, mask, cpumask_of_node(k)); : 
2
strstr : while : 				cpumask_or(mask, mask, cpumask_of_node(k)); : 
2
str : 			}[4]
strstr : INIT : 			} : 
2
strstr : if : 			} : 
2
strstr : for : 			} : 
2
strstr : while : 			} : 
2
str : 		}[3]
strstr : INIT : 		} : 
2
strstr : if : 		} : 
2
strstr : for : 		} : 
2
strstr : while : 		} : 
2
str : 	tl = kzalloc((ARRAY_SIZE(default_topology) + level) *[54]
strstr : INIT : 	tl = kzalloc((ARRAY_SIZE(default_topology) + level) * : 
2
strstr : if : 	tl = kzalloc((ARRAY_SIZE(default_topology) + level) * : 
2
strstr : for : 	tl = kzalloc((ARRAY_SIZE(default_topology) + level) * : 
2
strstr : while : 	tl = kzalloc((ARRAY_SIZE(default_topology) + level) * : 
2
str : 			sizeof(struct sched_domain_topology_level), GFP_KERNEL);[59]
strstr : INIT : 			sizeof(struct sched_domain_topology_level), GFP_KERNEL); : 
2
strstr : if : 			sizeof(struct sched_domain_topology_level), GFP_KERNEL); : 
2
strstr : for : 			sizeof(struct sched_domain_topology_level), GFP_KERNEL); : 
2
strstr : while : 			sizeof(struct sched_domain_topology_level), GFP_KERNEL); : 
2
str : 	if (!tl)[9]
strstr : INIT : 	if (!tl) : 
2
strstr : if : 	if (!tl) : 
2
strstr : for : 	if (!tl) : 
2
strstr : while : 	if (!tl) : 
2
str : 		return;[9]
strstr : INIT : 		return; : 
2
strstr : if : 		return; : 
2
strstr : for : 		return; : 
2
strstr : while : 		return; : 
2
str : 	/*[3]
strstr : INIT : 	/* : 
2
strstr : if : 	/* : 
2
strstr : for : 	/* : 
2
strstr : while : 	/* : 
2
str : 	 * Copy the default topology bits..[36]
strstr : INIT : 	 * Copy the default topology bits.. : 
2
strstr : if : 	 * Copy the default topology bits.. : 
2
strstr : for : 	 * Copy the default topology bits.. : 
2
strstr : while : 	 * Copy the default topology bits.. : 
2
str : 	 */[4]
strstr : INIT : 	 */ : 
2
strstr : if : 	 */ : 
2
strstr : for : 	 */ : 
2
strstr : while : 	 */ : 
2
str : 	for (i = 0; default_topology[i].init; i++)[43]
strstr : INIT : 	for (i = 0; default_topology[i].init; i++) : 
2
strstr : if : 	for (i = 0; default_topology[i].init; i++) : 
2
strstr : for : 	for (i = 0; default_topology[i].init; i++) : 
2
strstr : while : 	for (i = 0; default_topology[i].init; i++) : 
2
str : 		tl[i] = default_topology[i];[30]
strstr : INIT : 		tl[i] = default_topology[i]; : 
2
strstr : if : 		tl[i] = default_topology[i]; : 
2
strstr : for : 		tl[i] = default_topology[i]; : 
2
strstr : while : 		tl[i] = default_topology[i]; : 
2
str : 	/*[3]
strstr : INIT : 	/* : 
2
strstr : if : 	/* : 
2
strstr : for : 	/* : 
2
strstr : while : 	/* : 
2
str : 	 * .. and append 'j' levels of NUMA goodness.[46]
strstr : INIT : 	 * .. and append 'j' levels of NUMA goodness. : 
2
strstr : if : 	 * .. and append 'j' levels of NUMA goodness. : 
2
strstr : for : 	 * .. and append 'j' levels of NUMA goodness. : 
2
strstr : while : 	 * .. and append 'j' levels of NUMA goodness. : 
2
str : 	 */[4]
strstr : INIT : 	 */ : 
2
strstr : if : 	 */ : 
2
strstr : for : 	 */ : 
2
strstr : while : 	 */ : 
2
str : 	for (j = 0; j < level; i++, j++) {[35]
strstr : INIT : 	for (j = 0; j < level; i++, j++) { : 
2
strstr : if : 	for (j = 0; j < level; i++, j++) { : 
2
strstr : for : 	for (j = 0; j < level; i++, j++) { : 
2
strstr : while : 	for (j = 0; j < level; i++, j++) { : 
2
str : 		tl[i] = (struct sched_domain_topology_level){[47]
strstr : INIT : 		tl[i] = (struct sched_domain_topology_level){ : 
2
strstr : if : 		tl[i] = (struct sched_domain_topology_level){ : 
2
strstr : for : 		tl[i] = (struct sched_domain_topology_level){ : 
2
strstr : while : 		tl[i] = (struct sched_domain_topology_level){ : 
2
str : 			.init = sd_numa_init,[24]
strstr : INIT : 			.init = sd_numa_init, : 
2
strstr : if : 			.init = sd_numa_init, : 
2
strstr : for : 			.init = sd_numa_init, : 
2
strstr : while : 			.init = sd_numa_init, : 
2
str : 			.mask = sd_numa_mask,[24]
strstr : INIT : 			.mask = sd_numa_mask, : 
2
strstr : if : 			.mask = sd_numa_mask, : 
2
strstr : for : 			.mask = sd_numa_mask, : 
2
strstr : while : 			.mask = sd_numa_mask, : 
2
str : 			.flags = SDTL_OVERLAP,[25]
strstr : INIT : 			.flags = SDTL_OVERLAP, : 
2
strstr : if : 			.flags = SDTL_OVERLAP, : 
2
strstr : for : 			.flags = SDTL_OVERLAP, : 
2
strstr : while : 			.flags = SDTL_OVERLAP, : 
2
str : 			.numa_level = j,[19]
strstr : INIT : 			.numa_level = j, : 
2
strstr : if : 			.numa_level = j, : 
2
strstr : for : 			.numa_level = j, : 
2
strstr : while : 			.numa_level = j, : 
2
str : 		};[4]
strstr : INIT : 		}; : 
2
strstr : if : 		}; : 
2
strstr : for : 		}; : 
2
strstr : while : 		}; : 
2
str : 	sched_domain_topology = tl;[28]
strstr : INIT : 	sched_domain_topology = tl; : 
2
strstr : if : 	sched_domain_topology = tl; : 
2
strstr : for : 	sched_domain_topology = tl; : 
2
strstr : while : 	sched_domain_topology = tl; : 
2
str : 	sched_domains_numa_levels = level;[35]
strstr : INIT : 	sched_domains_numa_levels = level; : 
2
strstr : if : 	sched_domains_numa_levels = level; : 
2
strstr : for : 	sched_domains_numa_levels = level; : 
2
strstr : while : 	sched_domains_numa_levels = level; : 
2
str : static void sched_domains_numa_masks_set(int cpu)[49]
strstr : INIT : static void sched_domains_numa_masks_set(int cpu) : 
2
strstr : if : static void sched_domains_numa_masks_set(int cpu) : 
2
strstr : for : static void sched_domains_numa_masks_set(int cpu) : 
2
strstr : while : static void sched_domains_numa_masks_set(int cpu) : 
2
str : 	int i, j;[10]
strstr : INIT : 	int i, j; : 
2
strstr : if : 	int i, j; : 
2
strstr : for : 	int i, j; : 
2
strstr : while : 	int i, j; : 
2
str : 	int node = cpu_to_node(cpu);[29]
strstr : INIT : 	int node = cpu_to_node(cpu); : 
2
strstr : if : 	int node = cpu_to_node(cpu); : 
2
strstr : for : 	int node = cpu_to_node(cpu); : 
2
strstr : while : 	int node = cpu_to_node(cpu); : 
2
str : 	for (i = 0; i < sched_domains_numa_levels; i++) {[50]
strstr : INIT : 	for (i = 0; i < sched_domains_numa_levels; i++) { : 
2
strstr : if : 	for (i = 0; i < sched_domains_numa_levels; i++) { : 
2
strstr : for : 	for (i = 0; i < sched_domains_numa_levels; i++) { : 
2
strstr : while : 	for (i = 0; i < sched_domains_numa_levels; i++) { : 
2
str : 		for (j = 0; j < nr_node_ids; j++) {[37]
strstr : INIT : 		for (j = 0; j < nr_node_ids; j++) { : 
2
strstr : if : 		for (j = 0; j < nr_node_ids; j++) { : 
2
strstr : for : 		for (j = 0; j < nr_node_ids; j++) { : 
2
strstr : while : 		for (j = 0; j < nr_node_ids; j++) { : 
2
str : 			if (node_distance(j, node) <= sched_domains_numa_distance[i])[64]
strstr : INIT : 			if (node_distance(j, node) <= sched_domains_numa_distance[i]) : 
2
strstr : if : 			if (node_distance(j, node) <= sched_domains_numa_distance[i]) : 
2
strstr : for : 			if (node_distance(j, node) <= sched_domains_numa_distance[i]) : 
2
strstr : while : 			if (node_distance(j, node) <= sched_domains_numa_distance[i]) : 
2
str : 				cpumask_set_cpu(cpu, sched_domains_numa_masks[i][j]);[57]
strstr : INIT : 				cpumask_set_cpu(cpu, sched_domains_numa_masks[i][j]); : 
2
strstr : if : 				cpumask_set_cpu(cpu, sched_domains_numa_masks[i][j]); : 
2
strstr : for : 				cpumask_set_cpu(cpu, sched_domains_numa_masks[i][j]); : 
2
strstr : while : 				cpumask_set_cpu(cpu, sched_domains_numa_masks[i][j]); : 
2
str : 		}[3]
strstr : INIT : 		} : 
2
strstr : if : 		} : 
2
strstr : for : 		} : 
2
strstr : while : 		} : 
2
str : static void sched_domains_numa_masks_clear(int cpu)[51]
strstr : INIT : static void sched_domains_numa_masks_clear(int cpu) : 
2
strstr : if : static void sched_domains_numa_masks_clear(int cpu) : 
2
strstr : for : static void sched_domains_numa_masks_clear(int cpu) : 
2
strstr : while : static void sched_domains_numa_masks_clear(int cpu) : 
2
str : 	int i, j;[10]
strstr : INIT : 	int i, j; : 
2
strstr : if : 	int i, j; : 
2
strstr : for : 	int i, j; : 
2
strstr : while : 	int i, j; : 
2
str : 	for (i = 0; i < sched_domains_numa_levels; i++) {[50]
strstr : INIT : 	for (i = 0; i < sched_domains_numa_levels; i++) { : 
2
strstr : if : 	for (i = 0; i < sched_domains_numa_levels; i++) { : 
2
strstr : for : 	for (i = 0; i < sched_domains_numa_levels; i++) { : 
2
strstr : while : 	for (i = 0; i < sched_domains_numa_levels; i++) { : 
2
str : 		for (j = 0; j < nr_node_ids; j++)[35]
strstr : INIT : 		for (j = 0; j < nr_node_ids; j++) : 
2
strstr : if : 		for (j = 0; j < nr_node_ids; j++) : 
2
strstr : for : 		for (j = 0; j < nr_node_ids; j++) : 
2
strstr : while : 		for (j = 0; j < nr_node_ids; j++) : 
2
str : 			cpumask_clear_cpu(cpu, sched_domains_numa_masks[i][j]);[58]
strstr : INIT : 			cpumask_clear_cpu(cpu, sched_domains_numa_masks[i][j]); : 
2
strstr : if : 			cpumask_clear_cpu(cpu, sched_domains_numa_masks[i][j]); : 
2
strstr : for : 			cpumask_clear_cpu(cpu, sched_domains_numa_masks[i][j]); : 
2
strstr : while : 			cpumask_clear_cpu(cpu, sched_domains_numa_masks[i][j]); : 
2
str :  * Update sched_domains_numa_masks[level][node] array when new cpus[67]
strstr : INIT :  * Update sched_domains_numa_masks[level][node] array when new cpus : 
2
strstr : if :  * Update sched_domains_numa_masks[level][node] array when new cpus : 
2
strstr : for :  * Update sched_domains_numa_masks[level][node] array when new cpus : 
2
strstr : while :  * Update sched_domains_numa_masks[level][node] array when new cpus : 
2
str :  * are onlined.[15]
strstr : INIT :  * are onlined. : 
2
strstr : if :  * are onlined. : 
2
strstr : for :  * are onlined. : 
2
strstr : while :  * are onlined. : 
2
str :  */[3]
strstr : INIT :  */ : 
2
strstr : if :  */ : 
2
strstr : for :  */ : 
2
strstr : while :  */ : 
2
str : static int sched_domains_numa_masks_update(struct notifier_block *nfb,[70]
strstr : INIT : static int sched_domains_numa_masks_update(struct notifier_block *nfb, : 
2
strstr : if : static int sched_domains_numa_masks_update(struct notifier_block *nfb, : 
2
strstr : for : static int sched_domains_numa_masks_update(struct notifier_block *nfb, : 
2
strstr : while : static int sched_domains_numa_masks_update(struct notifier_block *nfb, : 
2
str : 					   unsigned long action,[29]
strstr : INIT : 					   unsigned long action, : 
2
strstr : if : 					   unsigned long action, : 
2
strstr : for : 					   unsigned long action, : 
2
strstr : while : 					   unsigned long action, : 
2
str : 					   void *hcpu)[19]
strstr : INIT : 					   void *hcpu) : 
2
strstr : if : 					   void *hcpu) : 
2
strstr : for : 					   void *hcpu) : 
2
strstr : while : 					   void *hcpu) : 
2
str : 	int cpu = (long)hcpu;[22]
strstr : INIT : 	int cpu = (long)hcpu; : 
2
strstr : if : 	int cpu = (long)hcpu; : 
2
strstr : for : 	int cpu = (long)hcpu; : 
2
strstr : while : 	int cpu = (long)hcpu; : 
2
str : 	switch (action & ~CPU_TASKS_FROZEN) {[38]
strstr : INIT : 	switch (action & ~CPU_TASKS_FROZEN) { : 
2
strstr : if : 	switch (action & ~CPU_TASKS_FROZEN) { : 
2
strstr : for : 	switch (action & ~CPU_TASKS_FROZEN) { : 
2
strstr : while : 	switch (action & ~CPU_TASKS_FROZEN) { : 
2
str : 	case CPU_ONLINE:[17]
strstr : INIT : 	case CPU_ONLINE: : 
2
strstr : if : 	case CPU_ONLINE: : 
2
strstr : for : 	case CPU_ONLINE: : 
2
strstr : while : 	case CPU_ONLINE: : 
2
str : 		sched_domains_numa_masks_set(cpu);[36]
strstr : INIT : 		sched_domains_numa_masks_set(cpu); : 
2
strstr : if : 		sched_domains_numa_masks_set(cpu); : 
2
strstr : for : 		sched_domains_numa_masks_set(cpu); : 
2
strstr : while : 		sched_domains_numa_masks_set(cpu); : 
2
str : 		break;[8]
strstr : INIT : 		break; : 
2
strstr : if : 		break; : 
2
strstr : for : 		break; : 
2
strstr : while : 		break; : 
2
str : 	case CPU_DEAD:[15]
strstr : INIT : 	case CPU_DEAD: : 
2
strstr : if : 	case CPU_DEAD: : 
2
strstr : for : 	case CPU_DEAD: : 
2
strstr : while : 	case CPU_DEAD: : 
2
str : 		sched_domains_numa_masks_clear(cpu);[38]
strstr : INIT : 		sched_domains_numa_masks_clear(cpu); : 
2
strstr : if : 		sched_domains_numa_masks_clear(cpu); : 
2
strstr : for : 		sched_domains_numa_masks_clear(cpu); : 
2
strstr : while : 		sched_domains_numa_masks_clear(cpu); : 
2
str : 		break;[8]
strstr : INIT : 		break; : 
2
strstr : if : 		break; : 
2
strstr : for : 		break; : 
2
strstr : while : 		break; : 
2
str : 	default:[9]
strstr : INIT : 	default: : 
2
strstr : if : 	default: : 
2
strstr : for : 	default: : 
2
strstr : while : 	default: : 
2
str : 		return NOTIFY_DONE;[21]
strstr : INIT : 		return NOTIFY_DONE; : 
2
strstr : if : 		return NOTIFY_DONE; : 
2
strstr : for : 		return NOTIFY_DONE; : 
2
strstr : while : 		return NOTIFY_DONE; : 
2
str : 	return NOTIFY_OK;[18]
strstr : INIT : 	return NOTIFY_OK; : 
2
strstr : if : 	return NOTIFY_OK; : 
2
strstr : for : 	return NOTIFY_OK; : 
2
strstr : while : 	return NOTIFY_OK; : 
2
str : #else[5]
strstr : INIT : #else : 
2
strstr : if : #else : 
2
strstr : for : #else : 
2
strstr : while : #else : 
2
str : static inline void sched_init_numa(void)[40]
strstr : INIT : static inline void sched_init_numa(void) : 
2
strstr : if : static inline void sched_init_numa(void) : 
2
strstr : for : static inline void sched_init_numa(void) : 
2
strstr : while : static inline void sched_init_numa(void) : 
2
str : static int sched_domains_numa_masks_update(struct notifier_block *nfb,[70]
strstr : INIT : static int sched_domains_numa_masks_update(struct notifier_block *nfb, : 
2
strstr : if : static int sched_domains_numa_masks_update(struct notifier_block *nfb, : 
2
strstr : for : static int sched_domains_numa_masks_update(struct notifier_block *nfb, : 
2
strstr : while : static int sched_domains_numa_masks_update(struct notifier_block *nfb, : 
2
str : 					   unsigned long action,[29]
strstr : INIT : 					   unsigned long action, : 
2
strstr : if : 					   unsigned long action, : 
2
strstr : for : 					   unsigned long action, : 
2
strstr : while : 					   unsigned long action, : 
2
str : 					   void *hcpu)[19]
strstr : INIT : 					   void *hcpu) : 
2
strstr : if : 					   void *hcpu) : 
2
strstr : for : 					   void *hcpu) : 
2
strstr : while : 					   void *hcpu) : 
2
str : 	return 0;[10]
strstr : INIT : 	return 0; : 
2
strstr : if : 	return 0; : 
2
strstr : for : 	return 0; : 
2
strstr : while : 	return 0; : 
2
str : #endif /* CONFIG_NUMA */[24]
strstr : INIT : #endif /* CONFIG_NUMA */ : 
2
strstr : if : #endif /* CONFIG_NUMA */ : 
2
strstr : for : #endif /* CONFIG_NUMA */ : 
2
strstr : while : #endif /* CONFIG_NUMA */ : 
2
str : static int __sdt_alloc(const struct cpumask *cpu_map)[53]
strstr : INIT : static int __sdt_alloc(const struct cpumask *cpu_map) : 
2
strstr : if : static int __sdt_alloc(const struct cpumask *cpu_map) : 
2
strstr : for : static int __sdt_alloc(const struct cpumask *cpu_map) : 
2
strstr : while : static int __sdt_alloc(const struct cpumask *cpu_map) : 
2
str : 	struct sched_domain_topology_level *tl;[40]
strstr : INIT : 	struct sched_domain_topology_level *tl; : 
2
strstr : if : 	struct sched_domain_topology_level *tl; : 
2
strstr : for : 	struct sched_domain_topology_level *tl; : 
2
strstr : while : 	struct sched_domain_topology_level *tl; : 
2
str : 	int j;[7]
strstr : INIT : 	int j; : 
2
strstr : if : 	int j; : 
2
strstr : for : 	int j; : 
2
strstr : while : 	int j; : 
2
str : 	for_each_sd_topology(tl) {[27]
strstr : INIT : 	for_each_sd_topology(tl) { : 
2
strstr : if : 	for_each_sd_topology(tl) { : 
2
strstr : for : 	for_each_sd_topology(tl) { : 
2
strstr : while : 	for_each_sd_topology(tl) { : 
2
str : 		struct sd_data *sdd = &tl->data;[34]
strstr : INIT : 		struct sd_data *sdd = &tl->data; : 
2
strstr : if : 		struct sd_data *sdd = &tl->data; : 
2
strstr : for : 		struct sd_data *sdd = &tl->data; : 
2
strstr : while : 		struct sd_data *sdd = &tl->data; : 
2
str : 		sdd->sd = alloc_percpu(struct sched_domain *);[48]
strstr : INIT : 		sdd->sd = alloc_percpu(struct sched_domain *); : 
2
strstr : if : 		sdd->sd = alloc_percpu(struct sched_domain *); : 
2
strstr : for : 		sdd->sd = alloc_percpu(struct sched_domain *); : 
2
strstr : while : 		sdd->sd = alloc_percpu(struct sched_domain *); : 
2
str : 		if (!sdd->sd)[15]
strstr : INIT : 		if (!sdd->sd) : 
2
strstr : if : 		if (!sdd->sd) : 
2
strstr : for : 		if (!sdd->sd) : 
2
strstr : while : 		if (!sdd->sd) : 
2
str : 			return -ENOMEM;[18]
strstr : INIT : 			return -ENOMEM; : 
2
strstr : if : 			return -ENOMEM; : 
2
strstr : for : 			return -ENOMEM; : 
2
strstr : while : 			return -ENOMEM; : 
2
str : 		sdd->sg = alloc_percpu(struct sched_group *);[47]
strstr : INIT : 		sdd->sg = alloc_percpu(struct sched_group *); : 
2
strstr : if : 		sdd->sg = alloc_percpu(struct sched_group *); : 
2
strstr : for : 		sdd->sg = alloc_percpu(struct sched_group *); : 
2
strstr : while : 		sdd->sg = alloc_percpu(struct sched_group *); : 
2
str : 		if (!sdd->sg)[15]
strstr : INIT : 		if (!sdd->sg) : 
2
strstr : if : 		if (!sdd->sg) : 
2
strstr : for : 		if (!sdd->sg) : 
2
strstr : while : 		if (!sdd->sg) : 
2
str : 			return -ENOMEM;[18]
strstr : INIT : 			return -ENOMEM; : 
2
strstr : if : 			return -ENOMEM; : 
2
strstr : for : 			return -ENOMEM; : 
2
strstr : while : 			return -ENOMEM; : 
2
str : 		sdd->sgp = alloc_percpu(struct sched_group_power *);[54]
strstr : INIT : 		sdd->sgp = alloc_percpu(struct sched_group_power *); : 
2
strstr : if : 		sdd->sgp = alloc_percpu(struct sched_group_power *); : 
2
strstr : for : 		sdd->sgp = alloc_percpu(struct sched_group_power *); : 
2
strstr : while : 		sdd->sgp = alloc_percpu(struct sched_group_power *); : 
2
str : 		if (!sdd->sgp)[16]
strstr : INIT : 		if (!sdd->sgp) : 
2
strstr : if : 		if (!sdd->sgp) : 
2
strstr : for : 		if (!sdd->sgp) : 
2
strstr : while : 		if (!sdd->sgp) : 
2
str : 			return -ENOMEM;[18]
strstr : INIT : 			return -ENOMEM; : 
2
strstr : if : 			return -ENOMEM; : 
2
strstr : for : 			return -ENOMEM; : 
2
strstr : while : 			return -ENOMEM; : 
2
str : 		for_each_cpu(j, cpu_map) {[28]
strstr : INIT : 		for_each_cpu(j, cpu_map) { : 
2
strstr : if : 		for_each_cpu(j, cpu_map) { : 
2
strstr : for : 		for_each_cpu(j, cpu_map) { : 
2
strstr : while : 		for_each_cpu(j, cpu_map) { : 
2
str : 			struct sched_domain *sd;[27]
strstr : INIT : 			struct sched_domain *sd; : 
2
strstr : if : 			struct sched_domain *sd; : 
2
strstr : for : 			struct sched_domain *sd; : 
2
strstr : while : 			struct sched_domain *sd; : 
2
str : 			struct sched_group *sg;[26]
strstr : INIT : 			struct sched_group *sg; : 
2
strstr : if : 			struct sched_group *sg; : 
2
strstr : for : 			struct sched_group *sg; : 
2
strstr : while : 			struct sched_group *sg; : 
2
str : 			struct sched_group_power *sgp;[33]
strstr : INIT : 			struct sched_group_power *sgp; : 
2
strstr : if : 			struct sched_group_power *sgp; : 
2
strstr : for : 			struct sched_group_power *sgp; : 
2
strstr : while : 			struct sched_group_power *sgp; : 
2
str : 		       	sd = kzalloc_node(sizeof(struct sched_domain) + cpumask_size(),[73]
strstr : INIT : 		       	sd = kzalloc_node(sizeof(struct sched_domain) + cpumask_size(), : 
2
strstr : if : 		       	sd = kzalloc_node(sizeof(struct sched_domain) + cpumask_size(), : 
2
strstr : for : 		       	sd = kzalloc_node(sizeof(struct sched_domain) + cpumask_size(), : 
2
strstr : while : 		       	sd = kzalloc_node(sizeof(struct sched_domain) + cpumask_size(), : 
2
str : 					GFP_KERNEL, cpu_to_node(j));[33]
strstr : INIT : 					GFP_KERNEL, cpu_to_node(j)); : 
2
strstr : if : 					GFP_KERNEL, cpu_to_node(j)); : 
2
strstr : for : 					GFP_KERNEL, cpu_to_node(j)); : 
2
strstr : while : 					GFP_KERNEL, cpu_to_node(j)); : 
2
str : 			if (!sd)[11]
strstr : INIT : 			if (!sd) : 
2
strstr : if : 			if (!sd) : 
2
strstr : for : 			if (!sd) : 
2
strstr : while : 			if (!sd) : 
2
str : 				return -ENOMEM;[19]
strstr : INIT : 				return -ENOMEM; : 
2
strstr : if : 				return -ENOMEM; : 
2
strstr : for : 				return -ENOMEM; : 
2
strstr : while : 				return -ENOMEM; : 
2
str : 			*per_cpu_ptr(sdd->sd, j) = sd;[33]
strstr : INIT : 			*per_cpu_ptr(sdd->sd, j) = sd; : 
2
strstr : if : 			*per_cpu_ptr(sdd->sd, j) = sd; : 
2
strstr : for : 			*per_cpu_ptr(sdd->sd, j) = sd; : 
2
strstr : while : 			*per_cpu_ptr(sdd->sd, j) = sd; : 
2
str : 			sg = kzalloc_node(sizeof(struct sched_group) + cpumask_size(),[65]
strstr : INIT : 			sg = kzalloc_node(sizeof(struct sched_group) + cpumask_size(), : 
2
strstr : if : 			sg = kzalloc_node(sizeof(struct sched_group) + cpumask_size(), : 
2
strstr : for : 			sg = kzalloc_node(sizeof(struct sched_group) + cpumask_size(), : 
2
strstr : while : 			sg = kzalloc_node(sizeof(struct sched_group) + cpumask_size(), : 
2
str : 					GFP_KERNEL, cpu_to_node(j));[33]
strstr : INIT : 					GFP_KERNEL, cpu_to_node(j)); : 
2
strstr : if : 					GFP_KERNEL, cpu_to_node(j)); : 
2
strstr : for : 					GFP_KERNEL, cpu_to_node(j)); : 
2
strstr : while : 					GFP_KERNEL, cpu_to_node(j)); : 
2
str : 			if (!sg)[11]
strstr : INIT : 			if (!sg) : 
2
strstr : if : 			if (!sg) : 
2
strstr : for : 			if (!sg) : 
2
strstr : while : 			if (!sg) : 
2
str : 				return -ENOMEM;[19]
strstr : INIT : 				return -ENOMEM; : 
2
strstr : if : 				return -ENOMEM; : 
2
strstr : for : 				return -ENOMEM; : 
2
strstr : while : 				return -ENOMEM; : 
2
str : 			sg->next = sg;[17]
strstr : INIT : 			sg->next = sg; : 
2
strstr : if : 			sg->next = sg; : 
2
strstr : for : 			sg->next = sg; : 
2
strstr : while : 			sg->next = sg; : 
2
str : 			*per_cpu_ptr(sdd->sg, j) = sg;[33]
strstr : INIT : 			*per_cpu_ptr(sdd->sg, j) = sg; : 
2
strstr : if : 			*per_cpu_ptr(sdd->sg, j) = sg; : 
2
strstr : for : 			*per_cpu_ptr(sdd->sg, j) = sg; : 
2
strstr : while : 			*per_cpu_ptr(sdd->sg, j) = sg; : 
2
str : 			sgp = kzalloc_node(sizeof(struct sched_group_power) + cpumask_size(),[72]
strstr : INIT : 			sgp = kzalloc_node(sizeof(struct sched_group_power) + cpumask_size(), : 
2
strstr : if : 			sgp = kzalloc_node(sizeof(struct sched_group_power) + cpumask_size(), : 
2
strstr : for : 			sgp = kzalloc_node(sizeof(struct sched_group_power) + cpumask_size(), : 
2
strstr : while : 			sgp = kzalloc_node(sizeof(struct sched_group_power) + cpumask_size(), : 
2
str : 					GFP_KERNEL, cpu_to_node(j));[33]
strstr : INIT : 					GFP_KERNEL, cpu_to_node(j)); : 
2
strstr : if : 					GFP_KERNEL, cpu_to_node(j)); : 
2
strstr : for : 					GFP_KERNEL, cpu_to_node(j)); : 
2
strstr : while : 					GFP_KERNEL, cpu_to_node(j)); : 
2
str : 			if (!sgp)[12]
strstr : INIT : 			if (!sgp) : 
2
strstr : if : 			if (!sgp) : 
2
strstr : for : 			if (!sgp) : 
2
strstr : while : 			if (!sgp) : 
2
str : 				return -ENOMEM;[19]
strstr : INIT : 				return -ENOMEM; : 
2
strstr : if : 				return -ENOMEM; : 
2
strstr : for : 				return -ENOMEM; : 
2
strstr : while : 				return -ENOMEM; : 
2
str : 			*per_cpu_ptr(sdd->sgp, j) = sgp;[35]
strstr : INIT : 			*per_cpu_ptr(sdd->sgp, j) = sgp; : 
2
strstr : if : 			*per_cpu_ptr(sdd->sgp, j) = sgp; : 
2
strstr : for : 			*per_cpu_ptr(sdd->sgp, j) = sgp; : 
2
strstr : while : 			*per_cpu_ptr(sdd->sgp, j) = sgp; : 
2
str : 		}[3]
strstr : INIT : 		} : 
2
strstr : if : 		} : 
2
strstr : for : 		} : 
2
strstr : while : 		} : 
2
str : 	return 0;[10]
strstr : INIT : 	return 0; : 
2
strstr : if : 	return 0; : 
2
strstr : for : 	return 0; : 
2
strstr : while : 	return 0; : 
2
str : static void __sdt_free(const struct cpumask *cpu_map)[53]
strstr : INIT : static void __sdt_free(const struct cpumask *cpu_map) : 
2
strstr : if : static void __sdt_free(const struct cpumask *cpu_map) : 
2
strstr : for : static void __sdt_free(const struct cpumask *cpu_map) : 
2
strstr : while : static void __sdt_free(const struct cpumask *cpu_map) : 
2
str : 	struct sched_domain_topology_level *tl;[40]
strstr : INIT : 	struct sched_domain_topology_level *tl; : 
2
strstr : if : 	struct sched_domain_topology_level *tl; : 
2
strstr : for : 	struct sched_domain_topology_level *tl; : 
2
strstr : while : 	struct sched_domain_topology_level *tl; : 
2
str : 	int j;[7]
strstr : INIT : 	int j; : 
2
strstr : if : 	int j; : 
2
strstr : for : 	int j; : 
2
strstr : while : 	int j; : 
2
str : 	for_each_sd_topology(tl) {[27]
strstr : INIT : 	for_each_sd_topology(tl) { : 
2
strstr : if : 	for_each_sd_topology(tl) { : 
2
strstr : for : 	for_each_sd_topology(tl) { : 
2
strstr : while : 	for_each_sd_topology(tl) { : 
2
str : 		struct sd_data *sdd = &tl->data;[34]
strstr : INIT : 		struct sd_data *sdd = &tl->data; : 
2
strstr : if : 		struct sd_data *sdd = &tl->data; : 
2
strstr : for : 		struct sd_data *sdd = &tl->data; : 
2
strstr : while : 		struct sd_data *sdd = &tl->data; : 
2
str : 		for_each_cpu(j, cpu_map) {[28]
strstr : INIT : 		for_each_cpu(j, cpu_map) { : 
2
strstr : if : 		for_each_cpu(j, cpu_map) { : 
2
strstr : for : 		for_each_cpu(j, cpu_map) { : 
2
strstr : while : 		for_each_cpu(j, cpu_map) { : 
2
str : 			struct sched_domain *sd;[27]
strstr : INIT : 			struct sched_domain *sd; : 
2
strstr : if : 			struct sched_domain *sd; : 
2
strstr : for : 			struct sched_domain *sd; : 
2
strstr : while : 			struct sched_domain *sd; : 
2
str : 			if (sdd->sd) {[17]
strstr : INIT : 			if (sdd->sd) { : 
2
strstr : if : 			if (sdd->sd) { : 
2
strstr : for : 			if (sdd->sd) { : 
2
strstr : while : 			if (sdd->sd) { : 
2
str : 				sd = *per_cpu_ptr(sdd->sd, j);[34]
strstr : INIT : 				sd = *per_cpu_ptr(sdd->sd, j); : 
2
strstr : if : 				sd = *per_cpu_ptr(sdd->sd, j); : 
2
strstr : for : 				sd = *per_cpu_ptr(sdd->sd, j); : 
2
strstr : while : 				sd = *per_cpu_ptr(sdd->sd, j); : 
2
str : 				if (sd && (sd->flags & SD_OVERLAP))[39]
strstr : INIT : 				if (sd && (sd->flags & SD_OVERLAP)) : 
2
strstr : if : 				if (sd && (sd->flags & SD_OVERLAP)) : 
2
strstr : for : 				if (sd && (sd->flags & SD_OVERLAP)) : 
2
strstr : while : 				if (sd && (sd->flags & SD_OVERLAP)) : 
2
str : 					free_sched_groups(sd->groups, 0);[38]
strstr : INIT : 					free_sched_groups(sd->groups, 0); : 
2
strstr : if : 					free_sched_groups(sd->groups, 0); : 
2
strstr : for : 					free_sched_groups(sd->groups, 0); : 
2
strstr : while : 					free_sched_groups(sd->groups, 0); : 
2
str : 				kfree(*per_cpu_ptr(sdd->sd, j));[36]
strstr : INIT : 				kfree(*per_cpu_ptr(sdd->sd, j)); : 
2
strstr : if : 				kfree(*per_cpu_ptr(sdd->sd, j)); : 
2
strstr : for : 				kfree(*per_cpu_ptr(sdd->sd, j)); : 
2
strstr : while : 				kfree(*per_cpu_ptr(sdd->sd, j)); : 
2
str : 			}[4]
strstr : INIT : 			} : 
2
strstr : if : 			} : 
2
strstr : for : 			} : 
2
strstr : while : 			} : 
2
str : 			if (sdd->sg)[15]
strstr : INIT : 			if (sdd->sg) : 
2
strstr : if : 			if (sdd->sg) : 
2
strstr : for : 			if (sdd->sg) : 
2
strstr : while : 			if (sdd->sg) : 
2
str : 				kfree(*per_cpu_ptr(sdd->sg, j));[36]
strstr : INIT : 				kfree(*per_cpu_ptr(sdd->sg, j)); : 
2
strstr : if : 				kfree(*per_cpu_ptr(sdd->sg, j)); : 
2
strstr : for : 				kfree(*per_cpu_ptr(sdd->sg, j)); : 
2
strstr : while : 				kfree(*per_cpu_ptr(sdd->sg, j)); : 
2
str : 			if (sdd->sgp)[16]
strstr : INIT : 			if (sdd->sgp) : 
2
strstr : if : 			if (sdd->sgp) : 
2
strstr : for : 			if (sdd->sgp) : 
2
strstr : while : 			if (sdd->sgp) : 
2
str : 				kfree(*per_cpu_ptr(sdd->sgp, j));[37]
strstr : INIT : 				kfree(*per_cpu_ptr(sdd->sgp, j)); : 
2
strstr : if : 				kfree(*per_cpu_ptr(sdd->sgp, j)); : 
2
strstr : for : 				kfree(*per_cpu_ptr(sdd->sgp, j)); : 
2
strstr : while : 				kfree(*per_cpu_ptr(sdd->sgp, j)); : 
2
str : 		}[3]
strstr : INIT : 		} : 
2
strstr : if : 		} : 
2
strstr : for : 		} : 
2
strstr : while : 		} : 
2
str : 		free_percpu(sdd->sd);[23]
strstr : INIT : 		free_percpu(sdd->sd); : 
2
strstr : if : 		free_percpu(sdd->sd); : 
2
strstr : for : 		free_percpu(sdd->sd); : 
2
strstr : while : 		free_percpu(sdd->sd); : 
2
str : 		sdd->sd = NULL;[17]
strstr : INIT : 		sdd->sd = NULL; : 
2
strstr : if : 		sdd->sd = NULL; : 
2
strstr : for : 		sdd->sd = NULL; : 
2
strstr : while : 		sdd->sd = NULL; : 
2
str : 		free_percpu(sdd->sg);[23]
strstr : INIT : 		free_percpu(sdd->sg); : 
2
strstr : if : 		free_percpu(sdd->sg); : 
2
strstr : for : 		free_percpu(sdd->sg); : 
2
strstr : while : 		free_percpu(sdd->sg); : 
2
str : 		sdd->sg = NULL;[17]
strstr : INIT : 		sdd->sg = NULL; : 
2
strstr : if : 		sdd->sg = NULL; : 
2
strstr : for : 		sdd->sg = NULL; : 
2
strstr : while : 		sdd->sg = NULL; : 
2
str : 		free_percpu(sdd->sgp);[24]
strstr : INIT : 		free_percpu(sdd->sgp); : 
2
strstr : if : 		free_percpu(sdd->sgp); : 
2
strstr : for : 		free_percpu(sdd->sgp); : 
2
strstr : while : 		free_percpu(sdd->sgp); : 
2
str : 		sdd->sgp = NULL;[18]
strstr : INIT : 		sdd->sgp = NULL; : 
2
strstr : if : 		sdd->sgp = NULL; : 
2
strstr : for : 		sdd->sgp = NULL; : 
2
strstr : while : 		sdd->sgp = NULL; : 
2
str : struct sched_domain *build_sched_domain(struct sched_domain_topology_level *tl,[79]
strstr : INIT : struct sched_domain *build_sched_domain(struct sched_domain_topology_level *tl, : 
2
strstr : if : struct sched_domain *build_sched_domain(struct sched_domain_topology_level *tl, : 
2
strstr : for : struct sched_domain *build_sched_domain(struct sched_domain_topology_level *tl, : 
2
strstr : while : struct sched_domain *build_sched_domain(struct sched_domain_topology_level *tl, : 
2
str : 		const struct cpumask *cpu_map, struct sched_domain_attr *attr,[64]
strstr : INIT : 		const struct cpumask *cpu_map, struct sched_domain_attr *attr, : 
2
strstr : if : 		const struct cpumask *cpu_map, struct sched_domain_attr *attr, : 
2
strstr : for : 		const struct cpumask *cpu_map, struct sched_domain_attr *attr, : 
2
strstr : while : 		const struct cpumask *cpu_map, struct sched_domain_attr *attr, : 
2
str : 		struct sched_domain *child, int cpu)[38]
strstr : INIT : 		struct sched_domain *child, int cpu) : 
2
strstr : if : 		struct sched_domain *child, int cpu) : 
2
strstr : for : 		struct sched_domain *child, int cpu) : 
2
strstr : while : 		struct sched_domain *child, int cpu) : 
2
str : 	struct sched_domain *sd = tl->init(tl, cpu);[45]
strstr : INIT : 	struct sched_domain *sd = tl->init(tl, cpu); : 
2
strstr : if : 	struct sched_domain *sd = tl->init(tl, cpu); : 
2
strstr : for : 	struct sched_domain *sd = tl->init(tl, cpu); : 
2
strstr : while : 	struct sched_domain *sd = tl->init(tl, cpu); : 
2
str : 	if (!sd)[9]
strstr : INIT : 	if (!sd) : 
2
strstr : if : 	if (!sd) : 
2
strstr : for : 	if (!sd) : 
2
strstr : while : 	if (!sd) : 
2
str : 		return child;[15]
strstr : INIT : 		return child; : 
2
strstr : if : 		return child; : 
2
strstr : for : 		return child; : 
2
strstr : while : 		return child; : 
2
str : 	cpumask_and(sched_domain_span(sd), cpu_map, tl->mask(cpu));[60]
strstr : INIT : 	cpumask_and(sched_domain_span(sd), cpu_map, tl->mask(cpu)); : 
2
strstr : if : 	cpumask_and(sched_domain_span(sd), cpu_map, tl->mask(cpu)); : 
2
strstr : for : 	cpumask_and(sched_domain_span(sd), cpu_map, tl->mask(cpu)); : 
2
strstr : while : 	cpumask_and(sched_domain_span(sd), cpu_map, tl->mask(cpu)); : 
2
str : 	if (child) {[13]
strstr : INIT : 	if (child) { : 
2
strstr : if : 	if (child) { : 
2
strstr : for : 	if (child) { : 
2
strstr : while : 	if (child) { : 
2
str : 		sd->level = child->level + 1;[31]
strstr : INIT : 		sd->level = child->level + 1; : 
2
strstr : if : 		sd->level = child->level + 1; : 
2
strstr : for : 		sd->level = child->level + 1; : 
2
strstr : while : 		sd->level = child->level + 1; : 
2
str : 		sched_domain_level_max = max(sched_domain_level_max, sd->level);[66]
strstr : INIT : 		sched_domain_level_max = max(sched_domain_level_max, sd->level); : 
2
strstr : if : 		sched_domain_level_max = max(sched_domain_level_max, sd->level); : 
2
strstr : for : 		sched_domain_level_max = max(sched_domain_level_max, sd->level); : 
2
strstr : while : 		sched_domain_level_max = max(sched_domain_level_max, sd->level); : 
2
str : 		child->parent = sd;[21]
strstr : INIT : 		child->parent = sd; : 
2
strstr : if : 		child->parent = sd; : 
2
strstr : for : 		child->parent = sd; : 
2
strstr : while : 		child->parent = sd; : 
2
str : 		sd->child = child;[20]
strstr : INIT : 		sd->child = child; : 
2
strstr : if : 		sd->child = child; : 
2
strstr : for : 		sd->child = child; : 
2
strstr : while : 		sd->child = child; : 
2
str : 	set_domain_attribute(sd, attr);[32]
strstr : INIT : 	set_domain_attribute(sd, attr); : 
2
strstr : if : 	set_domain_attribute(sd, attr); : 
2
strstr : for : 	set_domain_attribute(sd, attr); : 
2
strstr : while : 	set_domain_attribute(sd, attr); : 
2
str : 	return sd;[11]
strstr : INIT : 	return sd; : 
2
strstr : if : 	return sd; : 
2
strstr : for : 	return sd; : 
2
strstr : while : 	return sd; : 
2
str :  * Build sched domains for a given set of cpus and attach the sched domains[75]
strstr : INIT :  * Build sched domains for a given set of cpus and attach the sched domains : 
2
strstr : if :  * Build sched domains for a given set of cpus and attach the sched domains : 
2
strstr : for :  * Build sched domains for a given set of cpus and attach the sched domains : 
2
strstr : while :  * Build sched domains for a given set of cpus and attach the sched domains : 
2
str :  * to the individual cpus[25]
strstr : INIT :  * to the individual cpus : 
2
strstr : if :  * to the individual cpus : 
2
strstr : for :  * to the individual cpus : 
2
strstr : while :  * to the individual cpus : 
2
str :  */[3]
strstr : INIT :  */ : 
2
strstr : if :  */ : 
2
strstr : for :  */ : 
2
strstr : while :  */ : 
2
str : static int build_sched_domains(const struct cpumask *cpu_map,[61]
strstr : INIT : static int build_sched_domains(const struct cpumask *cpu_map, : 
2
strstr : if : static int build_sched_domains(const struct cpumask *cpu_map, : 
2
strstr : for : static int build_sched_domains(const struct cpumask *cpu_map, : 
2
strstr : while : static int build_sched_domains(const struct cpumask *cpu_map, : 
2
str : 			       struct sched_domain_attr *attr)[41]
strstr : INIT : 			       struct sched_domain_attr *attr) : 
2
strstr : if : 			       struct sched_domain_attr *attr) : 
2
strstr : for : 			       struct sched_domain_attr *attr) : 
2
strstr : while : 			       struct sched_domain_attr *attr) : 
2
str : 	enum s_alloc alloc_state;[26]
strstr : INIT : 	enum s_alloc alloc_state; : 
2
strstr : if : 	enum s_alloc alloc_state; : 
2
strstr : for : 	enum s_alloc alloc_state; : 
2
strstr : while : 	enum s_alloc alloc_state; : 
2
str : 	struct sched_domain *sd;[25]
strstr : INIT : 	struct sched_domain *sd; : 
2
strstr : if : 	struct sched_domain *sd; : 
2
strstr : for : 	struct sched_domain *sd; : 
2
strstr : while : 	struct sched_domain *sd; : 
2
str : 	struct s_data d;[17]
strstr : INIT : 	struct s_data d; : 
2
strstr : if : 	struct s_data d; : 
2
strstr : for : 	struct s_data d; : 
2
strstr : while : 	struct s_data d; : 
2
str : 	int i, ret = -ENOMEM;[22]
strstr : INIT : 	int i, ret = -ENOMEM; : 
2
strstr : if : 	int i, ret = -ENOMEM; : 
2
strstr : for : 	int i, ret = -ENOMEM; : 
2
strstr : while : 	int i, ret = -ENOMEM; : 
2
str : 	alloc_state = __visit_domain_allocation_hell(&d, cpu_map);[59]
strstr : INIT : 	alloc_state = __visit_domain_allocation_hell(&d, cpu_map); : 
2
strstr : if : 	alloc_state = __visit_domain_allocation_hell(&d, cpu_map); : 
2
strstr : for : 	alloc_state = __visit_domain_allocation_hell(&d, cpu_map); : 
2
strstr : while : 	alloc_state = __visit_domain_allocation_hell(&d, cpu_map); : 
2
str : 	if (alloc_state != sa_rootdomain)[34]
strstr : INIT : 	if (alloc_state != sa_rootdomain) : 
2
strstr : if : 	if (alloc_state != sa_rootdomain) : 
2
strstr : for : 	if (alloc_state != sa_rootdomain) : 
2
strstr : while : 	if (alloc_state != sa_rootdomain) : 
2
str : 		goto error;[13]
strstr : INIT : 		goto error; : 
2
strstr : if : 		goto error; : 
2
strstr : for : 		goto error; : 
2
strstr : while : 		goto error; : 
2
str : 	/* Set up domains for cpus specified by the cpu_map. */[56]
strstr : INIT : 	/* Set up domains for cpus specified by the cpu_map. */ : 
2
strstr : if : 	/* Set up domains for cpus specified by the cpu_map. */ : 
2
strstr : for : 	/* Set up domains for cpus specified by the cpu_map. */ : 
2
strstr : while : 	/* Set up domains for cpus specified by the cpu_map. */ : 
2
str : 	for_each_cpu(i, cpu_map) {[27]
strstr : INIT : 	for_each_cpu(i, cpu_map) { : 
2
strstr : if : 	for_each_cpu(i, cpu_map) { : 
2
strstr : for : 	for_each_cpu(i, cpu_map) { : 
2
strstr : while : 	for_each_cpu(i, cpu_map) { : 
2
str : 		struct sched_domain_topology_level *tl;[41]
strstr : INIT : 		struct sched_domain_topology_level *tl; : 
2
strstr : if : 		struct sched_domain_topology_level *tl; : 
2
strstr : for : 		struct sched_domain_topology_level *tl; : 
2
strstr : while : 		struct sched_domain_topology_level *tl; : 
2
str : 		sd = NULL;[12]
strstr : INIT : 		sd = NULL; : 
2
strstr : if : 		sd = NULL; : 
2
strstr : for : 		sd = NULL; : 
2
strstr : while : 		sd = NULL; : 
2
str : 		for_each_sd_topology(tl) {[28]
strstr : INIT : 		for_each_sd_topology(tl) { : 
2
strstr : if : 		for_each_sd_topology(tl) { : 
2
strstr : for : 		for_each_sd_topology(tl) { : 
2
strstr : while : 		for_each_sd_topology(tl) { : 
2
str : 			sd = build_sched_domain(tl, cpu_map, attr, sd, i);[53]
strstr : INIT : 			sd = build_sched_domain(tl, cpu_map, attr, sd, i); : 
2
strstr : if : 			sd = build_sched_domain(tl, cpu_map, attr, sd, i); : 
2
strstr : for : 			sd = build_sched_domain(tl, cpu_map, attr, sd, i); : 
2
strstr : while : 			sd = build_sched_domain(tl, cpu_map, attr, sd, i); : 
2
str : 			if (tl == sched_domain_topology)[35]
strstr : INIT : 			if (tl == sched_domain_topology) : 
2
strstr : if : 			if (tl == sched_domain_topology) : 
2
strstr : for : 			if (tl == sched_domain_topology) : 
2
strstr : while : 			if (tl == sched_domain_topology) : 
2
str : 				*per_cpu_ptr(d.sd, i) = sd;[31]
strstr : INIT : 				*per_cpu_ptr(d.sd, i) = sd; : 
2
strstr : if : 				*per_cpu_ptr(d.sd, i) = sd; : 
2
strstr : for : 				*per_cpu_ptr(d.sd, i) = sd; : 
2
strstr : while : 				*per_cpu_ptr(d.sd, i) = sd; : 
2
str : 			if (tl->flags & SDTL_OVERLAP || sched_feat(FORCE_SD_OVERLAP))[64]
strstr : INIT : 			if (tl->flags & SDTL_OVERLAP || sched_feat(FORCE_SD_OVERLAP)) : 
2
strstr : if : 			if (tl->flags & SDTL_OVERLAP || sched_feat(FORCE_SD_OVERLAP)) : 
2
strstr : for : 			if (tl->flags & SDTL_OVERLAP || sched_feat(FORCE_SD_OVERLAP)) : 
2
strstr : while : 			if (tl->flags & SDTL_OVERLAP || sched_feat(FORCE_SD_OVERLAP)) : 
2
str : 				sd->flags |= SD_OVERLAP;[28]
strstr : INIT : 				sd->flags |= SD_OVERLAP; : 
2
strstr : if : 				sd->flags |= SD_OVERLAP; : 
2
strstr : for : 				sd->flags |= SD_OVERLAP; : 
2
strstr : while : 				sd->flags |= SD_OVERLAP; : 
2
str : 			if (cpumask_equal(cpu_map, sched_domain_span(sd)))[53]
strstr : INIT : 			if (cpumask_equal(cpu_map, sched_domain_span(sd))) : 
2
strstr : if : 			if (cpumask_equal(cpu_map, sched_domain_span(sd))) : 
2
strstr : for : 			if (cpumask_equal(cpu_map, sched_domain_span(sd))) : 
2
strstr : while : 			if (cpumask_equal(cpu_map, sched_domain_span(sd))) : 
2
str : 				break;[10]
strstr : INIT : 				break; : 
2
strstr : if : 				break; : 
2
strstr : for : 				break; : 
2
strstr : while : 				break; : 
2
str : 		}[3]
strstr : INIT : 		} : 
2
strstr : if : 		} : 
2
strstr : for : 		} : 
2
strstr : while : 		} : 
2
str : 	/* Build the groups for the domains */[39]
strstr : INIT : 	/* Build the groups for the domains */ : 
2
strstr : if : 	/* Build the groups for the domains */ : 
2
strstr : for : 	/* Build the groups for the domains */ : 
2
strstr : while : 	/* Build the groups for the domains */ : 
2
str : 	for_each_cpu(i, cpu_map) {[27]
strstr : INIT : 	for_each_cpu(i, cpu_map) { : 
2
strstr : if : 	for_each_cpu(i, cpu_map) { : 
2
strstr : for : 	for_each_cpu(i, cpu_map) { : 
2
strstr : while : 	for_each_cpu(i, cpu_map) { : 
2
str : 		for (sd = *per_cpu_ptr(d.sd, i); sd; sd = sd->parent) {[57]
strstr : INIT : 		for (sd = *per_cpu_ptr(d.sd, i); sd; sd = sd->parent) { : 
2
strstr : if : 		for (sd = *per_cpu_ptr(d.sd, i); sd; sd = sd->parent) { : 
2
strstr : for : 		for (sd = *per_cpu_ptr(d.sd, i); sd; sd = sd->parent) { : 
2
strstr : while : 		for (sd = *per_cpu_ptr(d.sd, i); sd; sd = sd->parent) { : 
2
str : 			sd->span_weight = cpumask_weight(sched_domain_span(sd));[59]
strstr : INIT : 			sd->span_weight = cpumask_weight(sched_domain_span(sd)); : 
2
strstr : if : 			sd->span_weight = cpumask_weight(sched_domain_span(sd)); : 
2
strstr : for : 			sd->span_weight = cpumask_weight(sched_domain_span(sd)); : 
2
strstr : while : 			sd->span_weight = cpumask_weight(sched_domain_span(sd)); : 
2
str : 			if (sd->flags & SD_OVERLAP) {[32]
strstr : INIT : 			if (sd->flags & SD_OVERLAP) { : 
2
strstr : if : 			if (sd->flags & SD_OVERLAP) { : 
2
strstr : for : 			if (sd->flags & SD_OVERLAP) { : 
2
strstr : while : 			if (sd->flags & SD_OVERLAP) { : 
2
str : 				if (build_overlap_sched_groups(sd, i))[42]
strstr : INIT : 				if (build_overlap_sched_groups(sd, i)) : 
2
strstr : if : 				if (build_overlap_sched_groups(sd, i)) : 
2
strstr : for : 				if (build_overlap_sched_groups(sd, i)) : 
2
strstr : while : 				if (build_overlap_sched_groups(sd, i)) : 
2
str : 					goto error;[16]
strstr : INIT : 					goto error; : 
2
strstr : if : 					goto error; : 
2
strstr : for : 					goto error; : 
2
strstr : while : 					goto error; : 
2
str : 			} else {[11]
strstr : INIT : 			} else { : 
2
strstr : if : 			} else { : 
2
strstr : for : 			} else { : 
2
strstr : while : 			} else { : 
2
str : 				if (build_sched_groups(sd, i))[34]
strstr : INIT : 				if (build_sched_groups(sd, i)) : 
2
strstr : if : 				if (build_sched_groups(sd, i)) : 
2
strstr : for : 				if (build_sched_groups(sd, i)) : 
2
strstr : while : 				if (build_sched_groups(sd, i)) : 
2
str : 					goto error;[16]
strstr : INIT : 					goto error; : 
2
strstr : if : 					goto error; : 
2
strstr : for : 					goto error; : 
2
strstr : while : 					goto error; : 
2
str : 			}[4]
strstr : INIT : 			} : 
2
strstr : if : 			} : 
2
strstr : for : 			} : 
2
strstr : while : 			} : 
2
str : 		}[3]
strstr : INIT : 		} : 
2
strstr : if : 		} : 
2
strstr : for : 		} : 
2
strstr : while : 		} : 
2
str : 	/* Calculate CPU power for physical packages and nodes */[58]
strstr : INIT : 	/* Calculate CPU power for physical packages and nodes */ : 
2
strstr : if : 	/* Calculate CPU power for physical packages and nodes */ : 
2
strstr : for : 	/* Calculate CPU power for physical packages and nodes */ : 
2
strstr : while : 	/* Calculate CPU power for physical packages and nodes */ : 
2
str : 	for (i = nr_cpumask_bits-1; i >= 0; i--) {[43]
strstr : INIT : 	for (i = nr_cpumask_bits-1; i >= 0; i--) { : 
2
strstr : if : 	for (i = nr_cpumask_bits-1; i >= 0; i--) { : 
2
strstr : for : 	for (i = nr_cpumask_bits-1; i >= 0; i--) { : 
2
strstr : while : 	for (i = nr_cpumask_bits-1; i >= 0; i--) { : 
2
str : 		if (!cpumask_test_cpu(i, cpu_map))[36]
strstr : INIT : 		if (!cpumask_test_cpu(i, cpu_map)) : 
2
strstr : if : 		if (!cpumask_test_cpu(i, cpu_map)) : 
2
strstr : for : 		if (!cpumask_test_cpu(i, cpu_map)) : 
2
strstr : while : 		if (!cpumask_test_cpu(i, cpu_map)) : 
2
str : 			continue;[12]
strstr : INIT : 			continue; : 
2
strstr : if : 			continue; : 
2
strstr : for : 			continue; : 
2
strstr : while : 			continue; : 
2
str : 		for (sd = *per_cpu_ptr(d.sd, i); sd; sd = sd->parent) {[57]
strstr : INIT : 		for (sd = *per_cpu_ptr(d.sd, i); sd; sd = sd->parent) { : 
2
strstr : if : 		for (sd = *per_cpu_ptr(d.sd, i); sd; sd = sd->parent) { : 
2
strstr : for : 		for (sd = *per_cpu_ptr(d.sd, i); sd; sd = sd->parent) { : 
2
strstr : while : 		for (sd = *per_cpu_ptr(d.sd, i); sd; sd = sd->parent) { : 
2
str : 			claim_allocations(i, sd);[28]
strstr : INIT : 			claim_allocations(i, sd); : 
2
strstr : if : 			claim_allocations(i, sd); : 
2
strstr : for : 			claim_allocations(i, sd); : 
2
strstr : while : 			claim_allocations(i, sd); : 
2
str : 			init_sched_groups_power(i, sd);[34]
strstr : INIT : 			init_sched_groups_power(i, sd); : 
2
strstr : if : 			init_sched_groups_power(i, sd); : 
2
strstr : for : 			init_sched_groups_power(i, sd); : 
2
strstr : while : 			init_sched_groups_power(i, sd); : 
2
str : 		}[3]
strstr : INIT : 		} : 
2
strstr : if : 		} : 
2
strstr : for : 		} : 
2
strstr : while : 		} : 
2
str : 	/* Attach the domains */[25]
strstr : INIT : 	/* Attach the domains */ : 
2
strstr : if : 	/* Attach the domains */ : 
2
strstr : for : 	/* Attach the domains */ : 
2
strstr : while : 	/* Attach the domains */ : 
2
str : 	rcu_read_lock();[17]
strstr : INIT : 	rcu_read_lock(); : 
2
strstr : if : 	rcu_read_lock(); : 
2
strstr : for : 	rcu_read_lock(); : 
2
strstr : while : 	rcu_read_lock(); : 
2
str : 	for_each_cpu(i, cpu_map) {[27]
strstr : INIT : 	for_each_cpu(i, cpu_map) { : 
2
strstr : if : 	for_each_cpu(i, cpu_map) { : 
2
strstr : for : 	for_each_cpu(i, cpu_map) { : 
2
strstr : while : 	for_each_cpu(i, cpu_map) { : 
2
str : 		sd = *per_cpu_ptr(d.sd, i);[29]
strstr : INIT : 		sd = *per_cpu_ptr(d.sd, i); : 
2
strstr : if : 		sd = *per_cpu_ptr(d.sd, i); : 
2
strstr : for : 		sd = *per_cpu_ptr(d.sd, i); : 
2
strstr : while : 		sd = *per_cpu_ptr(d.sd, i); : 
2
str : 		cpu_attach_domain(sd, d.rd, i);[33]
strstr : INIT : 		cpu_attach_domain(sd, d.rd, i); : 
2
strstr : if : 		cpu_attach_domain(sd, d.rd, i); : 
2
strstr : for : 		cpu_attach_domain(sd, d.rd, i); : 
2
strstr : while : 		cpu_attach_domain(sd, d.rd, i); : 
2
str : 	rcu_read_unlock();[19]
strstr : INIT : 	rcu_read_unlock(); : 
2
strstr : if : 	rcu_read_unlock(); : 
2
strstr : for : 	rcu_read_unlock(); : 
2
strstr : while : 	rcu_read_unlock(); : 
2
str : 	ret = 0;[9]
strstr : INIT : 	ret = 0; : 
2
strstr : if : 	ret = 0; : 
2
strstr : for : 	ret = 0; : 
2
strstr : while : 	ret = 0; : 
2
str : error:[6]
strstr : INIT : error: : 
2
strstr : if : error: : 
2
strstr : for : error: : 
2
strstr : while : error: : 
2
str : 	__free_domain_allocs(&d, alloc_state, cpu_map);[48]
strstr : INIT : 	__free_domain_allocs(&d, alloc_state, cpu_map); : 
2
strstr : if : 	__free_domain_allocs(&d, alloc_state, cpu_map); : 
2
strstr : for : 	__free_domain_allocs(&d, alloc_state, cpu_map); : 
2
strstr : while : 	__free_domain_allocs(&d, alloc_state, cpu_map); : 
2
str : 	return ret;[12]
strstr : INIT : 	return ret; : 
2
strstr : if : 	return ret; : 
2
strstr : for : 	return ret; : 
2
strstr : while : 	return ret; : 
2
str : static cpumask_var_t *doms_cur;	/* current sched domains */[59]
strstr : INIT : static cpumask_var_t *doms_cur;	/* current sched domains */ : 
2
strstr : if : static cpumask_var_t *doms_cur;	/* current sched domains */ : 
2
strstr : for : static cpumask_var_t *doms_cur;	/* current sched domains */ : 
2
strstr : while : static cpumask_var_t *doms_cur;	/* current sched domains */ : 
2
str : static int ndoms_cur;		/* number of sched domains in 'doms_cur' */[66]
strstr : INIT : static int ndoms_cur;		/* number of sched domains in 'doms_cur' */ : 
2
strstr : if : static int ndoms_cur;		/* number of sched domains in 'doms_cur' */ : 
2
strstr : for : static int ndoms_cur;		/* number of sched domains in 'doms_cur' */ : 
2
strstr : while : static int ndoms_cur;		/* number of sched domains in 'doms_cur' */ : 
2
str : static struct sched_domain_attr *dattr_cur;[43]
strstr : INIT : static struct sched_domain_attr *dattr_cur; : 
2
strstr : if : static struct sched_domain_attr *dattr_cur; : 
2
strstr : for : static struct sched_domain_attr *dattr_cur; : 
2
strstr : while : static struct sched_domain_attr *dattr_cur; : 
2
str : 				/* attribues of custom domains in 'doms_cur' */[51]
strstr : INIT : 				/* attribues of custom domains in 'doms_cur' */ : 
2
strstr : if : 				/* attribues of custom domains in 'doms_cur' */ : 
2
strstr : for : 				/* attribues of custom domains in 'doms_cur' */ : 
2
strstr : while : 				/* attribues of custom domains in 'doms_cur' */ : 
2
str :  * Special case: If a kmalloc of a doms_cur partition (array of[63]
strstr : INIT :  * Special case: If a kmalloc of a doms_cur partition (array of : 
2
strstr : if :  * Special case: If a kmalloc of a doms_cur partition (array of : 
2
strstr : for :  * Special case: If a kmalloc of a doms_cur partition (array of : 
2
strstr : while :  * Special case: If a kmalloc of a doms_cur partition (array of : 
2
str :  * cpumask) fails, then fallback to a single sched domain,[58]
strstr : INIT :  * cpumask) fails, then fallback to a single sched domain, : 
2
strstr : if :  * cpumask) fails, then fallback to a single sched domain, : 
2
strstr : for :  * cpumask) fails, then fallback to a single sched domain, : 
2
strstr : while :  * cpumask) fails, then fallback to a single sched domain, : 
2
str :  * as determined by the single cpumask fallback_doms.[53]
strstr : INIT :  * as determined by the single cpumask fallback_doms. : 
2
strstr : if :  * as determined by the single cpumask fallback_doms. : 
2
strstr : for :  * as determined by the single cpumask fallback_doms. : 
2
strstr : while :  * as determined by the single cpumask fallback_doms. : 
2
str :  */[3]
strstr : INIT :  */ : 
2
strstr : if :  */ : 
2
strstr : for :  */ : 
2
strstr : while :  */ : 
2
str : static cpumask_var_t fallback_doms;[35]
strstr : INIT : static cpumask_var_t fallback_doms; : 
2
strstr : if : static cpumask_var_t fallback_doms; : 
2
strstr : for : static cpumask_var_t fallback_doms; : 
2
strstr : while : static cpumask_var_t fallback_doms; : 
2
str :  * arch_update_cpu_topology lets virtualized architectures update the[69]
strstr : INIT :  * arch_update_cpu_topology lets virtualized architectures update the : 
2
strstr : if :  * arch_update_cpu_topology lets virtualized architectures update the : 
2
strstr : for :  * arch_update_cpu_topology lets virtualized architectures update the : 
2
strstr : while :  * arch_update_cpu_topology lets virtualized architectures update the : 
2
str :  * cpu core maps. It is supposed to return 1 if the topology changed[68]
strstr : INIT :  * cpu core maps. It is supposed to return 1 if the topology changed : 
2
strstr : if :  * cpu core maps. It is supposed to return 1 if the topology changed : 
2
strstr : for :  * cpu core maps. It is supposed to return 1 if the topology changed : 
2
strstr : while :  * cpu core maps. It is supposed to return 1 if the topology changed : 
2
str :  * or 0 if it stayed the same.[30]
strstr : INIT :  * or 0 if it stayed the same. : 
2
strstr : if :  * or 0 if it stayed the same. : 
2
strstr : for :  * or 0 if it stayed the same. : 
2
strstr : while :  * or 0 if it stayed the same. : 
2
str :  */[3]
strstr : INIT :  */ : 
2
strstr : if :  */ : 
2
strstr : for :  */ : 
2
strstr : while :  */ : 
2
str : int __attribute__((weak)) arch_update_cpu_topology(void)[56]
strstr : INIT : int __attribute__((weak)) arch_update_cpu_topology(void) : 
2
strstr : if : int __attribute__((weak)) arch_update_cpu_topology(void) : 
2
strstr : for : int __attribute__((weak)) arch_update_cpu_topology(void) : 
2
strstr : while : int __attribute__((weak)) arch_update_cpu_topology(void) : 
2
str : 	return 0;[10]
strstr : INIT : 	return 0; : 
2
strstr : if : 	return 0; : 
2
strstr : for : 	return 0; : 
2
strstr : while : 	return 0; : 
2
str : cpumask_var_t *alloc_sched_domains(unsigned int ndoms)[54]
strstr : INIT : cpumask_var_t *alloc_sched_domains(unsigned int ndoms) : 
2
strstr : if : cpumask_var_t *alloc_sched_domains(unsigned int ndoms) : 
2
strstr : for : cpumask_var_t *alloc_sched_domains(unsigned int ndoms) : 
2
strstr : while : cpumask_var_t *alloc_sched_domains(unsigned int ndoms) : 
2
str : 	int i;[7]
strstr : INIT : 	int i; : 
2
strstr : if : 	int i; : 
2
strstr : for : 	int i; : 
2
strstr : while : 	int i; : 
2
str : 	cpumask_var_t *doms;[21]
strstr : INIT : 	cpumask_var_t *doms; : 
2
strstr : if : 	cpumask_var_t *doms; : 
2
strstr : for : 	cpumask_var_t *doms; : 
2
strstr : while : 	cpumask_var_t *doms; : 
2
str : 	doms = kmalloc(sizeof(*doms) * ndoms, GFP_KERNEL);[51]
strstr : INIT : 	doms = kmalloc(sizeof(*doms) * ndoms, GFP_KERNEL); : 
2
strstr : if : 	doms = kmalloc(sizeof(*doms) * ndoms, GFP_KERNEL); : 
2
strstr : for : 	doms = kmalloc(sizeof(*doms) * ndoms, GFP_KERNEL); : 
2
strstr : while : 	doms = kmalloc(sizeof(*doms) * ndoms, GFP_KERNEL); : 
2
str : 	if (!doms)[11]
strstr : INIT : 	if (!doms) : 
2
strstr : if : 	if (!doms) : 
2
strstr : for : 	if (!doms) : 
2
strstr : while : 	if (!doms) : 
2
str : 		return NULL;[14]
strstr : INIT : 		return NULL; : 
2
strstr : if : 		return NULL; : 
2
strstr : for : 		return NULL; : 
2
strstr : while : 		return NULL; : 
2
str : 	for (i = 0; i < ndoms; i++) {[30]
strstr : INIT : 	for (i = 0; i < ndoms; i++) { : 
2
strstr : if : 	for (i = 0; i < ndoms; i++) { : 
2
strstr : for : 	for (i = 0; i < ndoms; i++) { : 
2
strstr : while : 	for (i = 0; i < ndoms; i++) { : 
2
str : 		if (!alloc_cpumask_var(&doms[i], GFP_KERNEL)) {[49]
strstr : INIT : 		if (!alloc_cpumask_var(&doms[i], GFP_KERNEL)) { : 
2
strstr : if : 		if (!alloc_cpumask_var(&doms[i], GFP_KERNEL)) { : 
2
strstr : for : 		if (!alloc_cpumask_var(&doms[i], GFP_KERNEL)) { : 
2
strstr : while : 		if (!alloc_cpumask_var(&doms[i], GFP_KERNEL)) { : 
2
str : 			free_sched_domains(doms, i);[31]
strstr : INIT : 			free_sched_domains(doms, i); : 
2
strstr : if : 			free_sched_domains(doms, i); : 
2
strstr : for : 			free_sched_domains(doms, i); : 
2
strstr : while : 			free_sched_domains(doms, i); : 
2
str : 			return NULL;[15]
strstr : INIT : 			return NULL; : 
2
strstr : if : 			return NULL; : 
2
strstr : for : 			return NULL; : 
2
strstr : while : 			return NULL; : 
2
str : 		}[3]
strstr : INIT : 		} : 
2
strstr : if : 		} : 
2
strstr : for : 		} : 
2
strstr : while : 		} : 
2
str : 	return doms;[13]
strstr : INIT : 	return doms; : 
2
strstr : if : 	return doms; : 
2
strstr : for : 	return doms; : 
2
strstr : while : 	return doms; : 
2
str : void free_sched_domains(cpumask_var_t doms[], unsigned int ndoms)[65]
strstr : INIT : void free_sched_domains(cpumask_var_t doms[], unsigned int ndoms) : 
2
strstr : if : void free_sched_domains(cpumask_var_t doms[], unsigned int ndoms) : 
2
strstr : for : void free_sched_domains(cpumask_var_t doms[], unsigned int ndoms) : 
2
strstr : while : void free_sched_domains(cpumask_var_t doms[], unsigned int ndoms) : 
2
str : 	unsigned int i;[16]
strstr : INIT : 	unsigned int i; : 
2
strstr : if : 	unsigned int i; : 
2
strstr : for : 	unsigned int i; : 
2
strstr : while : 	unsigned int i; : 
2
str : 	for (i = 0; i < ndoms; i++)[28]
strstr : INIT : 	for (i = 0; i < ndoms; i++) : 
2
strstr : if : 	for (i = 0; i < ndoms; i++) : 
2
strstr : for : 	for (i = 0; i < ndoms; i++) : 
2
strstr : while : 	for (i = 0; i < ndoms; i++) : 
2
str : 		free_cpumask_var(doms[i]);[28]
strstr : INIT : 		free_cpumask_var(doms[i]); : 
2
strstr : if : 		free_cpumask_var(doms[i]); : 
2
strstr : for : 		free_cpumask_var(doms[i]); : 
2
strstr : while : 		free_cpumask_var(doms[i]); : 
2
str : 	kfree(doms);[13]
strstr : INIT : 	kfree(doms); : 
2
strstr : if : 	kfree(doms); : 
2
strstr : for : 	kfree(doms); : 
2
strstr : while : 	kfree(doms); : 
2
str :  * Set up scheduler domains and groups. Callers must hold the hotplug lock.[75]
strstr : INIT :  * Set up scheduler domains and groups. Callers must hold the hotplug lock. : 
2
strstr : if :  * Set up scheduler domains and groups. Callers must hold the hotplug lock. : 
2
strstr : for :  * Set up scheduler domains and groups. Callers must hold the hotplug lock. : 
2
strstr : while :  * Set up scheduler domains and groups. Callers must hold the hotplug lock. : 
2
str :  * For now this just excludes isolated cpus, but could be used to[65]
strstr : INIT :  * For now this just excludes isolated cpus, but could be used to : 
2
strstr : if :  * For now this just excludes isolated cpus, but could be used to : 
2
strstr : for :  * For now this just excludes isolated cpus, but could be used to : 
2
strstr : while :  * For now this just excludes isolated cpus, but could be used to : 
2
str :  * exclude other special cases in the future.[45]
strstr : INIT :  * exclude other special cases in the future. : 
2
strstr : if :  * exclude other special cases in the future. : 
2
strstr : for :  * exclude other special cases in the future. : 
2
strstr : while :  * exclude other special cases in the future. : 
2
str :  */[3]
strstr : INIT :  */ : 
2
strstr : if :  */ : 
2
strstr : for :  */ : 
2
strstr : while :  */ : 
2
str : static int init_sched_domains(const struct cpumask *cpu_map)[60]
strstr : INIT : static int init_sched_domains(const struct cpumask *cpu_map) : 
2
strstr : if : static int init_sched_domains(const struct cpumask *cpu_map) : 
2
strstr : for : static int init_sched_domains(const struct cpumask *cpu_map) : 
2
strstr : while : static int init_sched_domains(const struct cpumask *cpu_map) : 
2
str : 	int err;[9]
strstr : INIT : 	int err; : 
2
strstr : if : 	int err; : 
2
strstr : for : 	int err; : 
2
strstr : while : 	int err; : 
2
str : 	arch_update_cpu_topology();[28]
strstr : INIT : 	arch_update_cpu_topology(); : 
2
strstr : if : 	arch_update_cpu_topology(); : 
2
strstr : for : 	arch_update_cpu_topology(); : 
2
strstr : while : 	arch_update_cpu_topology(); : 
2
str : 	ndoms_cur = 1;[15]
strstr : INIT : 	ndoms_cur = 1; : 
2
strstr : if : 	ndoms_cur = 1; : 
2
strstr : for : 	ndoms_cur = 1; : 
2
strstr : while : 	ndoms_cur = 1; : 
2
str : 	doms_cur = alloc_sched_domains(ndoms_cur);[43]
strstr : INIT : 	doms_cur = alloc_sched_domains(ndoms_cur); : 
2
strstr : if : 	doms_cur = alloc_sched_domains(ndoms_cur); : 
2
strstr : for : 	doms_cur = alloc_sched_domains(ndoms_cur); : 
2
strstr : while : 	doms_cur = alloc_sched_domains(ndoms_cur); : 
2
str : 	if (!doms_cur)[15]
strstr : INIT : 	if (!doms_cur) : 
2
strstr : if : 	if (!doms_cur) : 
2
strstr : for : 	if (!doms_cur) : 
2
strstr : while : 	if (!doms_cur) : 
2
str : 		doms_cur = &fallback_doms;[28]
strstr : INIT : 		doms_cur = &fallback_doms; : 
2
strstr : if : 		doms_cur = &fallback_doms; : 
2
strstr : for : 		doms_cur = &fallback_doms; : 
2
strstr : while : 		doms_cur = &fallback_doms; : 
2
str : 	cpumask_andnot(doms_cur[0], cpu_map, cpu_isolated_map);[56]
strstr : INIT : 	cpumask_andnot(doms_cur[0], cpu_map, cpu_isolated_map); : 
2
strstr : if : 	cpumask_andnot(doms_cur[0], cpu_map, cpu_isolated_map); : 
2
strstr : for : 	cpumask_andnot(doms_cur[0], cpu_map, cpu_isolated_map); : 
2
strstr : while : 	cpumask_andnot(doms_cur[0], cpu_map, cpu_isolated_map); : 
2
str : 	err = build_sched_domains(doms_cur[0], NULL);[46]
strstr : INIT : 	err = build_sched_domains(doms_cur[0], NULL); : 
2
strstr : if : 	err = build_sched_domains(doms_cur[0], NULL); : 
2
strstr : for : 	err = build_sched_domains(doms_cur[0], NULL); : 
2
strstr : while : 	err = build_sched_domains(doms_cur[0], NULL); : 
2
str : 	register_sched_domain_sysctl();[32]
strstr : INIT : 	register_sched_domain_sysctl(); : 
2
strstr : if : 	register_sched_domain_sysctl(); : 
2
strstr : for : 	register_sched_domain_sysctl(); : 
2
strstr : while : 	register_sched_domain_sysctl(); : 
2
str : 	return err;[12]
strstr : INIT : 	return err; : 
2
strstr : if : 	return err; : 
2
strstr : for : 	return err; : 
2
strstr : while : 	return err; : 
2
str :  * Detach sched domains from a group of cpus specified in cpu_map[65]
strstr : INIT :  * Detach sched domains from a group of cpus specified in cpu_map : 
2
strstr : if :  * Detach sched domains from a group of cpus specified in cpu_map : 
2
strstr : for :  * Detach sched domains from a group of cpus specified in cpu_map : 
2
strstr : while :  * Detach sched domains from a group of cpus specified in cpu_map : 
2
str :  * These cpus will now be attached to the NULL domain[53]
strstr : INIT :  * These cpus will now be attached to the NULL domain : 
2
strstr : if :  * These cpus will now be attached to the NULL domain : 
2
strstr : for :  * These cpus will now be attached to the NULL domain : 
2
strstr : while :  * These cpus will now be attached to the NULL domain : 
2
str :  */[3]
strstr : INIT :  */ : 
2
strstr : if :  */ : 
2
strstr : for :  */ : 
2
strstr : while :  */ : 
2
str : static void detach_destroy_domains(const struct cpumask *cpu_map)[65]
strstr : INIT : static void detach_destroy_domains(const struct cpumask *cpu_map) : 
2
strstr : if : static void detach_destroy_domains(const struct cpumask *cpu_map) : 
2
strstr : for : static void detach_destroy_domains(const struct cpumask *cpu_map) : 
2
strstr : while : static void detach_destroy_domains(const struct cpumask *cpu_map) : 
2
str : 	int i;[7]
strstr : INIT : 	int i; : 
2
strstr : if : 	int i; : 
2
strstr : for : 	int i; : 
2
strstr : while : 	int i; : 
2
str : 	rcu_read_lock();[17]
strstr : INIT : 	rcu_read_lock(); : 
2
strstr : if : 	rcu_read_lock(); : 
2
strstr : for : 	rcu_read_lock(); : 
2
strstr : while : 	rcu_read_lock(); : 
2
str : 	for_each_cpu(i, cpu_map)[25]
strstr : INIT : 	for_each_cpu(i, cpu_map) : 
2
strstr : if : 	for_each_cpu(i, cpu_map) : 
2
strstr : for : 	for_each_cpu(i, cpu_map) : 
2
strstr : while : 	for_each_cpu(i, cpu_map) : 
2
str : 		cpu_attach_domain(NULL, &def_root_domain, i);[47]
strstr : INIT : 		cpu_attach_domain(NULL, &def_root_domain, i); : 
2
strstr : if : 		cpu_attach_domain(NULL, &def_root_domain, i); : 
2
strstr : for : 		cpu_attach_domain(NULL, &def_root_domain, i); : 
2
strstr : while : 		cpu_attach_domain(NULL, &def_root_domain, i); : 
2
str : 	rcu_read_unlock();[19]
strstr : INIT : 	rcu_read_unlock(); : 
2
strstr : if : 	rcu_read_unlock(); : 
2
strstr : for : 	rcu_read_unlock(); : 
2
strstr : while : 	rcu_read_unlock(); : 
2
str : /* handle null as "default" */[30]
strstr : INIT : /* handle null as "default" */ : 
2
strstr : if : /* handle null as "default" */ : 
2
strstr : for : /* handle null as "default" */ : 
2
strstr : while : /* handle null as "default" */ : 
2
str : static int dattrs_equal(struct sched_domain_attr *cur, int idx_cur,[67]
strstr : INIT : static int dattrs_equal(struct sched_domain_attr *cur, int idx_cur, : 
2
strstr : if : static int dattrs_equal(struct sched_domain_attr *cur, int idx_cur, : 
2
strstr : for : static int dattrs_equal(struct sched_domain_attr *cur, int idx_cur, : 
2
strstr : while : static int dattrs_equal(struct sched_domain_attr *cur, int idx_cur, : 
2
str : 			struct sched_domain_attr *new, int idx_new)[46]
strstr : INIT : 			struct sched_domain_attr *new, int idx_new) : 
2
strstr : if : 			struct sched_domain_attr *new, int idx_new) : 
2
strstr : for : 			struct sched_domain_attr *new, int idx_new) : 
2
strstr : while : 			struct sched_domain_attr *new, int idx_new) : 
2
str : 	struct sched_domain_attr tmp;[30]
strstr : INIT : 	struct sched_domain_attr tmp; : 
2
strstr : if : 	struct sched_domain_attr tmp; : 
2
strstr : for : 	struct sched_domain_attr tmp; : 
2
strstr : while : 	struct sched_domain_attr tmp; : 
2
str : 	/* fast path */[16]
strstr : INIT : 	/* fast path */ : 
2
strstr : if : 	/* fast path */ : 
2
strstr : for : 	/* fast path */ : 
2
strstr : while : 	/* fast path */ : 
2
str : 	if (!new && !cur)[18]
strstr : INIT : 	if (!new && !cur) : 
2
strstr : if : 	if (!new && !cur) : 
2
strstr : for : 	if (!new && !cur) : 
2
strstr : while : 	if (!new && !cur) : 
2
str : 		return 1;[11]
strstr : INIT : 		return 1; : 
2
strstr : if : 		return 1; : 
2
strstr : for : 		return 1; : 
2
strstr : while : 		return 1; : 
2
str : 	tmp = SD_ATTR_INIT;[20]
strstr : INIT : 	tmp = SD_ATTR_INIT; : 
2
strstr : if : 	tmp = SD_ATTR_INIT; : 
2
strstr : for : 	tmp = SD_ATTR_INIT; : 
2
strstr : while : 	tmp = SD_ATTR_INIT; : 
2
str : 	return !memcmp(cur ? (cur + idx_cur) : &tmp,[45]
strstr : INIT : 	return !memcmp(cur ? (cur + idx_cur) : &tmp, : 
2
strstr : if : 	return !memcmp(cur ? (cur + idx_cur) : &tmp, : 
2
strstr : for : 	return !memcmp(cur ? (cur + idx_cur) : &tmp, : 
2
strstr : while : 	return !memcmp(cur ? (cur + idx_cur) : &tmp, : 
2
str : 			new ? (new + idx_new) : &tmp,[32]
strstr : INIT : 			new ? (new + idx_new) : &tmp, : 
2
strstr : if : 			new ? (new + idx_new) : &tmp, : 
2
strstr : for : 			new ? (new + idx_new) : &tmp, : 
2
strstr : while : 			new ? (new + idx_new) : &tmp, : 
2
str : 			sizeof(struct sched_domain_attr));[37]
strstr : INIT : 			sizeof(struct sched_domain_attr)); : 
2
strstr : if : 			sizeof(struct sched_domain_attr)); : 
2
strstr : for : 			sizeof(struct sched_domain_attr)); : 
2
strstr : while : 			sizeof(struct sched_domain_attr)); : 
2
str :  * Partition sched domains as specified by the 'ndoms_new'[58]
strstr : INIT :  * Partition sched domains as specified by the 'ndoms_new' : 
2
strstr : if :  * Partition sched domains as specified by the 'ndoms_new' : 
2
strstr : for :  * Partition sched domains as specified by the 'ndoms_new' : 
2
strstr : while :  * Partition sched domains as specified by the 'ndoms_new' : 
2
str :  * cpumasks in the array doms_new[] of cpumasks. This compares[62]
strstr : INIT :  * cpumasks in the array doms_new[] of cpumasks. This compares : 
2
strstr : if :  * cpumasks in the array doms_new[] of cpumasks. This compares : 
2
strstr : for :  * cpumasks in the array doms_new[] of cpumasks. This compares : 
2
strstr : while :  * cpumasks in the array doms_new[] of cpumasks. This compares : 
2
str :  * doms_new[] to the current sched domain partitioning, doms_cur[].[67]
strstr : INIT :  * doms_new[] to the current sched domain partitioning, doms_cur[]. : 
2
strstr : if :  * doms_new[] to the current sched domain partitioning, doms_cur[]. : 
2
strstr : for :  * doms_new[] to the current sched domain partitioning, doms_cur[]. : 
2
strstr : while :  * doms_new[] to the current sched domain partitioning, doms_cur[]. : 
2
str :  * It destroys each deleted domain and builds each new domain.[62]
strstr : INIT :  * It destroys each deleted domain and builds each new domain. : 
2
strstr : if :  * It destroys each deleted domain and builds each new domain. : 
2
strstr : for :  * It destroys each deleted domain and builds each new domain. : 
2
strstr : while :  * It destroys each deleted domain and builds each new domain. : 
2
str :  * 'doms_new' is an array of cpumask_var_t's of length 'ndoms_new'.[67]
strstr : INIT :  * 'doms_new' is an array of cpumask_var_t's of length 'ndoms_new'. : 
2
strstr : if :  * 'doms_new' is an array of cpumask_var_t's of length 'ndoms_new'. : 
2
strstr : for :  * 'doms_new' is an array of cpumask_var_t's of length 'ndoms_new'. : 
2
strstr : while :  * 'doms_new' is an array of cpumask_var_t's of length 'ndoms_new'. : 
2
str :  * The masks don't intersect (don't overlap.) We should setup one[65]
strstr : INIT :  * The masks don't intersect (don't overlap.) We should setup one : 
2
strstr : if :  * The masks don't intersect (don't overlap.) We should setup one : 
2
strstr : for :  * The masks don't intersect (don't overlap.) We should setup one : 
2
strstr : while :  * The masks don't intersect (don't overlap.) We should setup one : 
2
str :  * sched domain for each mask. CPUs not in any of the cpumasks will[67]
strstr : INIT :  * sched domain for each mask. CPUs not in any of the cpumasks will : 
2
strstr : if :  * sched domain for each mask. CPUs not in any of the cpumasks will : 
2
strstr : for :  * sched domain for each mask. CPUs not in any of the cpumasks will : 
2
strstr : while :  * sched domain for each mask. CPUs not in any of the cpumasks will : 
2
str :  * not be load balanced. If the same cpumask appears both in the[64]
strstr : INIT :  * not be load balanced. If the same cpumask appears both in the : 
2
strstr : if :  * not be load balanced. If the same cpumask appears both in the : 
2
strstr : for :  * not be load balanced. If the same cpumask appears both in the : 
2
strstr : while :  * not be load balanced. If the same cpumask appears both in the : 
2
str :  * current 'doms_cur' domains and in the new 'doms_new', we can leave[69]
strstr : INIT :  * current 'doms_cur' domains and in the new 'doms_new', we can leave : 
2
strstr : if :  * current 'doms_cur' domains and in the new 'doms_new', we can leave : 
2
strstr : for :  * current 'doms_cur' domains and in the new 'doms_new', we can leave : 
2
strstr : while :  * current 'doms_cur' domains and in the new 'doms_new', we can leave : 
2
str :  * it as it is.[15]
strstr : INIT :  * it as it is. : 
2
strstr : if :  * it as it is. : 
2
strstr : for :  * it as it is. : 
2
strstr : while :  * it as it is. : 
2
str :  * The passed in 'doms_new' should be allocated using[53]
strstr : INIT :  * The passed in 'doms_new' should be allocated using : 
2
strstr : if :  * The passed in 'doms_new' should be allocated using : 
2
strstr : for :  * The passed in 'doms_new' should be allocated using : 
2
strstr : while :  * The passed in 'doms_new' should be allocated using : 
2
str :  * alloc_sched_domains.  This routine takes ownership of it and will[68]
strstr : INIT :  * alloc_sched_domains.  This routine takes ownership of it and will : 
2
strstr : if :  * alloc_sched_domains.  This routine takes ownership of it and will : 
2
strstr : for :  * alloc_sched_domains.  This routine takes ownership of it and will : 
2
strstr : while :  * alloc_sched_domains.  This routine takes ownership of it and will : 
2
str :  * free_sched_domains it when done with it. If the caller failed the[68]
strstr : INIT :  * free_sched_domains it when done with it. If the caller failed the : 
2
strstr : if :  * free_sched_domains it when done with it. If the caller failed the : 
2
strstr : for :  * free_sched_domains it when done with it. If the caller failed the : 
2
strstr : while :  * free_sched_domains it when done with it. If the caller failed the : 
2
str :  * alloc call, then it can pass in doms_new == NULL && ndoms_new == 1,[70]
strstr : INIT :  * alloc call, then it can pass in doms_new == NULL && ndoms_new == 1, : 
2
strstr : if :  * alloc call, then it can pass in doms_new == NULL && ndoms_new == 1, : 
2
strstr : for :  * alloc call, then it can pass in doms_new == NULL && ndoms_new == 1, : 
2
strstr : while :  * alloc call, then it can pass in doms_new == NULL && ndoms_new == 1, : 
2
str :  * and partition_sched_domains() will fallback to the single partition[70]
strstr : INIT :  * and partition_sched_domains() will fallback to the single partition : 
2
strstr : if :  * and partition_sched_domains() will fallback to the single partition : 
2
strstr : for :  * and partition_sched_domains() will fallback to the single partition : 
2
strstr : while :  * and partition_sched_domains() will fallback to the single partition : 
2
str :  * 'fallback_doms', it also forces the domains to be rebuilt.[61]
strstr : INIT :  * 'fallback_doms', it also forces the domains to be rebuilt. : 
2
strstr : if :  * 'fallback_doms', it also forces the domains to be rebuilt. : 
2
strstr : for :  * 'fallback_doms', it also forces the domains to be rebuilt. : 
2
strstr : while :  * 'fallback_doms', it also forces the domains to be rebuilt. : 
2
str :  * If doms_new == NULL it will be replaced with cpu_online_mask.[64]
strstr : INIT :  * If doms_new == NULL it will be replaced with cpu_online_mask. : 
2
strstr : if :  * If doms_new == NULL it will be replaced with cpu_online_mask. : 
2
strstr : for :  * If doms_new == NULL it will be replaced with cpu_online_mask. : 
2
strstr : while :  * If doms_new == NULL it will be replaced with cpu_online_mask. : 
2
str :  * ndoms_new == 0 is a special case for destroying existing domains,[68]
strstr : INIT :  * ndoms_new == 0 is a special case for destroying existing domains, : 
2
strstr : if :  * ndoms_new == 0 is a special case for destroying existing domains, : 
2
strstr : for :  * ndoms_new == 0 is a special case for destroying existing domains, : 
2
strstr : while :  * ndoms_new == 0 is a special case for destroying existing domains, : 
2
str :  * and it will not create the default domain.[45]
strstr : INIT :  * and it will not create the default domain. : 
2
strstr : if :  * and it will not create the default domain. : 
2
strstr : for :  * and it will not create the default domain. : 
2
strstr : while :  * and it will not create the default domain. : 
2
str :  * Call with hotplug lock held[30]
strstr : INIT :  * Call with hotplug lock held : 
2
strstr : if :  * Call with hotplug lock held : 
2
strstr : for :  * Call with hotplug lock held : 
2
strstr : while :  * Call with hotplug lock held : 
2
str :  */[3]
strstr : INIT :  */ : 
2
strstr : if :  */ : 
2
strstr : for :  */ : 
2
strstr : while :  */ : 
2
str : void partition_sched_domains(int ndoms_new, cpumask_var_t doms_new[],[69]
strstr : INIT : void partition_sched_domains(int ndoms_new, cpumask_var_t doms_new[], : 
2
strstr : if : void partition_sched_domains(int ndoms_new, cpumask_var_t doms_new[], : 
2
strstr : for : void partition_sched_domains(int ndoms_new, cpumask_var_t doms_new[], : 
2
strstr : while : void partition_sched_domains(int ndoms_new, cpumask_var_t doms_new[], : 
2
str : 			     struct sched_domain_attr *dattr_new)[44]
strstr : INIT : 			     struct sched_domain_attr *dattr_new) : 
2
strstr : if : 			     struct sched_domain_attr *dattr_new) : 
2
strstr : for : 			     struct sched_domain_attr *dattr_new) : 
2
strstr : while : 			     struct sched_domain_attr *dattr_new) : 
2
str : 	int i, j, n;[13]
strstr : INIT : 	int i, j, n; : 
2
strstr : if : 	int i, j, n; : 
2
strstr : for : 	int i, j, n; : 
2
strstr : while : 	int i, j, n; : 
2
str : 	int new_topology;[18]
strstr : INIT : 	int new_topology; : 
2
strstr : if : 	int new_topology; : 
2
strstr : for : 	int new_topology; : 
2
strstr : while : 	int new_topology; : 
2
str : 	mutex_lock(&sched_domains_mutex);[34]
strstr : INIT : 	mutex_lock(&sched_domains_mutex); : 
2
strstr : if : 	mutex_lock(&sched_domains_mutex); : 
2
strstr : for : 	mutex_lock(&sched_domains_mutex); : 
2
strstr : while : 	mutex_lock(&sched_domains_mutex); : 
2
str : 	/* always unregister in case we don't destroy any domains */[61]
strstr : INIT : 	/* always unregister in case we don't destroy any domains */ : 
2
strstr : if : 	/* always unregister in case we don't destroy any domains */ : 
2
strstr : for : 	/* always unregister in case we don't destroy any domains */ : 
2
strstr : while : 	/* always unregister in case we don't destroy any domains */ : 
2
str : 	unregister_sched_domain_sysctl();[34]
strstr : INIT : 	unregister_sched_domain_sysctl(); : 
2
strstr : if : 	unregister_sched_domain_sysctl(); : 
2
strstr : for : 	unregister_sched_domain_sysctl(); : 
2
strstr : while : 	unregister_sched_domain_sysctl(); : 
2
str : 	/* Let architecture update cpu core mappings. */[49]
strstr : INIT : 	/* Let architecture update cpu core mappings. */ : 
2
strstr : if : 	/* Let architecture update cpu core mappings. */ : 
2
strstr : for : 	/* Let architecture update cpu core mappings. */ : 
2
strstr : while : 	/* Let architecture update cpu core mappings. */ : 
2
str : 	new_topology = arch_update_cpu_topology();[43]
strstr : INIT : 	new_topology = arch_update_cpu_topology(); : 
2
strstr : if : 	new_topology = arch_update_cpu_topology(); : 
2
strstr : for : 	new_topology = arch_update_cpu_topology(); : 
2
strstr : while : 	new_topology = arch_update_cpu_topology(); : 
2
str : 	n = doms_new ? ndoms_new : 0;[30]
strstr : INIT : 	n = doms_new ? ndoms_new : 0; : 
2
strstr : if : 	n = doms_new ? ndoms_new : 0; : 
2
strstr : for : 	n = doms_new ? ndoms_new : 0; : 
2
strstr : while : 	n = doms_new ? ndoms_new : 0; : 
2
str : 	/* Destroy deleted domains */[30]
strstr : INIT : 	/* Destroy deleted domains */ : 
2
strstr : if : 	/* Destroy deleted domains */ : 
2
strstr : for : 	/* Destroy deleted domains */ : 
2
strstr : while : 	/* Destroy deleted domains */ : 
2
str : 	for (i = 0; i < ndoms_cur; i++) {[34]
strstr : INIT : 	for (i = 0; i < ndoms_cur; i++) { : 
2
strstr : if : 	for (i = 0; i < ndoms_cur; i++) { : 
2
strstr : for : 	for (i = 0; i < ndoms_cur; i++) { : 
2
strstr : while : 	for (i = 0; i < ndoms_cur; i++) { : 
2
str : 		for (j = 0; j < n && !new_topology; j++) {[44]
strstr : INIT : 		for (j = 0; j < n && !new_topology; j++) { : 
2
strstr : if : 		for (j = 0; j < n && !new_topology; j++) { : 
2
strstr : for : 		for (j = 0; j < n && !new_topology; j++) { : 
2
strstr : while : 		for (j = 0; j < n && !new_topology; j++) { : 
2
str : 			if (cpumask_equal(doms_cur[i], doms_new[j])[46]
strstr : INIT : 			if (cpumask_equal(doms_cur[i], doms_new[j]) : 
2
strstr : if : 			if (cpumask_equal(doms_cur[i], doms_new[j]) : 
2
strstr : for : 			if (cpumask_equal(doms_cur[i], doms_new[j]) : 
2
strstr : while : 			if (cpumask_equal(doms_cur[i], doms_new[j]) : 
2
str : 			    && dattrs_equal(dattr_cur, i, dattr_new, j))[51]
strstr : INIT : 			    && dattrs_equal(dattr_cur, i, dattr_new, j)) : 
2
strstr : if : 			    && dattrs_equal(dattr_cur, i, dattr_new, j)) : 
2
strstr : for : 			    && dattrs_equal(dattr_cur, i, dattr_new, j)) : 
2
strstr : while : 			    && dattrs_equal(dattr_cur, i, dattr_new, j)) : 
2
str : 				goto match1;[16]
strstr : INIT : 				goto match1; : 
2
strstr : if : 				goto match1; : 
2
strstr : for : 				goto match1; : 
2
strstr : while : 				goto match1; : 
2
str : 		}[3]
strstr : INIT : 		} : 
2
strstr : if : 		} : 
2
strstr : for : 		} : 
2
strstr : while : 		} : 
2
str : 		/* no match - a current sched domain not in new doms_new[] */[63]
strstr : INIT : 		/* no match - a current sched domain not in new doms_new[] */ : 
2
strstr : if : 		/* no match - a current sched domain not in new doms_new[] */ : 
2
strstr : for : 		/* no match - a current sched domain not in new doms_new[] */ : 
2
strstr : while : 		/* no match - a current sched domain not in new doms_new[] */ : 
2
str : 		detach_destroy_domains(doms_cur[i]);[38]
strstr : INIT : 		detach_destroy_domains(doms_cur[i]); : 
2
strstr : if : 		detach_destroy_domains(doms_cur[i]); : 
2
strstr : for : 		detach_destroy_domains(doms_cur[i]); : 
2
strstr : while : 		detach_destroy_domains(doms_cur[i]); : 
2
str : match1:[7]
strstr : INIT : match1: : 
2
strstr : if : match1: : 
2
strstr : for : match1: : 
2
strstr : while : match1: : 
2
str : 		;[3]
strstr : INIT : 		; : 
2
strstr : if : 		; : 
2
strstr : for : 		; : 
2
strstr : while : 		; : 
2
str : 	n = ndoms_cur;[15]
strstr : INIT : 	n = ndoms_cur; : 
2
strstr : if : 	n = ndoms_cur; : 
2
strstr : for : 	n = ndoms_cur; : 
2
strstr : while : 	n = ndoms_cur; : 
2
str : 	if (doms_new == NULL) {[24]
strstr : INIT : 	if (doms_new == NULL) { : 
2
strstr : if : 	if (doms_new == NULL) { : 
2
strstr : for : 	if (doms_new == NULL) { : 
2
strstr : while : 	if (doms_new == NULL) { : 
2
str : 		n = 0;[8]
strstr : INIT : 		n = 0; : 
2
strstr : if : 		n = 0; : 
2
strstr : for : 		n = 0; : 
2
strstr : while : 		n = 0; : 
2
str : 		doms_new = &fallback_doms;[28]
strstr : INIT : 		doms_new = &fallback_doms; : 
2
strstr : if : 		doms_new = &fallback_doms; : 
2
strstr : for : 		doms_new = &fallback_doms; : 
2
strstr : while : 		doms_new = &fallback_doms; : 
2
str : 		cpumask_andnot(doms_new[0], cpu_active_mask, cpu_isolated_map);[65]
strstr : INIT : 		cpumask_andnot(doms_new[0], cpu_active_mask, cpu_isolated_map); : 
2
strstr : if : 		cpumask_andnot(doms_new[0], cpu_active_mask, cpu_isolated_map); : 
2
strstr : for : 		cpumask_andnot(doms_new[0], cpu_active_mask, cpu_isolated_map); : 
2
strstr : while : 		cpumask_andnot(doms_new[0], cpu_active_mask, cpu_isolated_map); : 
2
str : 		WARN_ON_ONCE(dattr_new);[26]
strstr : INIT : 		WARN_ON_ONCE(dattr_new); : 
2
strstr : if : 		WARN_ON_ONCE(dattr_new); : 
2
strstr : for : 		WARN_ON_ONCE(dattr_new); : 
2
strstr : while : 		WARN_ON_ONCE(dattr_new); : 
2
str : 	/* Build new domains */[24]
strstr : INIT : 	/* Build new domains */ : 
2
strstr : if : 	/* Build new domains */ : 
2
strstr : for : 	/* Build new domains */ : 
2
strstr : while : 	/* Build new domains */ : 
2
str : 	for (i = 0; i < ndoms_new; i++) {[34]
strstr : INIT : 	for (i = 0; i < ndoms_new; i++) { : 
2
strstr : if : 	for (i = 0; i < ndoms_new; i++) { : 
2
strstr : for : 	for (i = 0; i < ndoms_new; i++) { : 
2
strstr : while : 	for (i = 0; i < ndoms_new; i++) { : 
2
str : 		for (j = 0; j < n && !new_topology; j++) {[44]
strstr : INIT : 		for (j = 0; j < n && !new_topology; j++) { : 
2
strstr : if : 		for (j = 0; j < n && !new_topology; j++) { : 
2
strstr : for : 		for (j = 0; j < n && !new_topology; j++) { : 
2
strstr : while : 		for (j = 0; j < n && !new_topology; j++) { : 
2
str : 			if (cpumask_equal(doms_new[i], doms_cur[j])[46]
strstr : INIT : 			if (cpumask_equal(doms_new[i], doms_cur[j]) : 
2
strstr : if : 			if (cpumask_equal(doms_new[i], doms_cur[j]) : 
2
strstr : for : 			if (cpumask_equal(doms_new[i], doms_cur[j]) : 
2
strstr : while : 			if (cpumask_equal(doms_new[i], doms_cur[j]) : 
2
str : 			    && dattrs_equal(dattr_new, i, dattr_cur, j))[51]
strstr : INIT : 			    && dattrs_equal(dattr_new, i, dattr_cur, j)) : 
2
strstr : if : 			    && dattrs_equal(dattr_new, i, dattr_cur, j)) : 
2
strstr : for : 			    && dattrs_equal(dattr_new, i, dattr_cur, j)) : 
2
strstr : while : 			    && dattrs_equal(dattr_new, i, dattr_cur, j)) : 
2
str : 				goto match2;[16]
strstr : INIT : 				goto match2; : 
2
strstr : if : 				goto match2; : 
2
strstr : for : 				goto match2; : 
2
strstr : while : 				goto match2; : 
2
str : 		}[3]
strstr : INIT : 		} : 
2
strstr : if : 		} : 
2
strstr : for : 		} : 
2
strstr : while : 		} : 
2
str : 		/* no match - add a new doms_new */[37]
strstr : INIT : 		/* no match - add a new doms_new */ : 
2
strstr : if : 		/* no match - add a new doms_new */ : 
2
strstr : for : 		/* no match - add a new doms_new */ : 
2
strstr : while : 		/* no match - add a new doms_new */ : 
2
str : 		build_sched_domains(doms_new[i], dattr_new ? dattr_new + i : NULL);[69]
strstr : INIT : 		build_sched_domains(doms_new[i], dattr_new ? dattr_new + i : NULL); : 
2
strstr : if : 		build_sched_domains(doms_new[i], dattr_new ? dattr_new + i : NULL); : 
2
strstr : for : 		build_sched_domains(doms_new[i], dattr_new ? dattr_new + i : NULL); : 
2
strstr : while : 		build_sched_domains(doms_new[i], dattr_new ? dattr_new + i : NULL); : 
2
str : match2:[7]
strstr : INIT : match2: : 
2
strstr : if : match2: : 
2
strstr : for : match2: : 
2
strstr : while : match2: : 
2
str : 		;[3]
strstr : INIT : 		; : 
2
strstr : if : 		; : 
2
strstr : for : 		; : 
2
strstr : while : 		; : 
2
str : 	/* Remember the new sched domains */[37]
strstr : INIT : 	/* Remember the new sched domains */ : 
2
strstr : if : 	/* Remember the new sched domains */ : 
2
strstr : for : 	/* Remember the new sched domains */ : 
2
strstr : while : 	/* Remember the new sched domains */ : 
2
str : 	if (doms_cur != &fallback_doms)[32]
strstr : INIT : 	if (doms_cur != &fallback_doms) : 
2
strstr : if : 	if (doms_cur != &fallback_doms) : 
2
strstr : for : 	if (doms_cur != &fallback_doms) : 
2
strstr : while : 	if (doms_cur != &fallback_doms) : 
2
str : 		free_sched_domains(doms_cur, ndoms_cur);[42]
strstr : INIT : 		free_sched_domains(doms_cur, ndoms_cur); : 
2
strstr : if : 		free_sched_domains(doms_cur, ndoms_cur); : 
2
strstr : for : 		free_sched_domains(doms_cur, ndoms_cur); : 
2
strstr : while : 		free_sched_domains(doms_cur, ndoms_cur); : 
2
str : 	kfree(dattr_cur);	/* kfree(NULL) is safe */[44]
strstr : INIT : 	kfree(dattr_cur);	/* kfree(NULL) is safe */ : 
2
strstr : if : 	kfree(dattr_cur);	/* kfree(NULL) is safe */ : 
2
strstr : for : 	kfree(dattr_cur);	/* kfree(NULL) is safe */ : 
2
strstr : while : 	kfree(dattr_cur);	/* kfree(NULL) is safe */ : 
2
str : 	doms_cur = doms_new;[21]
strstr : INIT : 	doms_cur = doms_new; : 
2
strstr : if : 	doms_cur = doms_new; : 
2
strstr : for : 	doms_cur = doms_new; : 
2
strstr : while : 	doms_cur = doms_new; : 
2
str : 	dattr_cur = dattr_new;[23]
strstr : INIT : 	dattr_cur = dattr_new; : 
2
strstr : if : 	dattr_cur = dattr_new; : 
2
strstr : for : 	dattr_cur = dattr_new; : 
2
strstr : while : 	dattr_cur = dattr_new; : 
2
str : 	ndoms_cur = ndoms_new;[23]
strstr : INIT : 	ndoms_cur = ndoms_new; : 
2
strstr : if : 	ndoms_cur = ndoms_new; : 
2
strstr : for : 	ndoms_cur = ndoms_new; : 
2
strstr : while : 	ndoms_cur = ndoms_new; : 
2
str : 	register_sched_domain_sysctl();[32]
strstr : INIT : 	register_sched_domain_sysctl(); : 
2
strstr : if : 	register_sched_domain_sysctl(); : 
2
strstr : for : 	register_sched_domain_sysctl(); : 
2
strstr : while : 	register_sched_domain_sysctl(); : 
2
str : 	mutex_unlock(&sched_domains_mutex);[36]
strstr : INIT : 	mutex_unlock(&sched_domains_mutex); : 
2
strstr : if : 	mutex_unlock(&sched_domains_mutex); : 
2
strstr : for : 	mutex_unlock(&sched_domains_mutex); : 
2
strstr : while : 	mutex_unlock(&sched_domains_mutex); : 
2
str : static int num_cpus_frozen;	/* used to mark begin/end of suspend/resume */[74]
strstr : INIT : static int num_cpus_frozen;	/* used to mark begin/end of suspend/resume */ : 
2
strstr : if : static int num_cpus_frozen;	/* used to mark begin/end of suspend/resume */ : 
2
strstr : for : static int num_cpus_frozen;	/* used to mark begin/end of suspend/resume */ : 
2
strstr : while : static int num_cpus_frozen;	/* used to mark begin/end of suspend/resume */ : 
2
str :  * Update cpusets according to cpu_active mask.  If cpusets are[63]
strstr : INIT :  * Update cpusets according to cpu_active mask.  If cpusets are : 
2
strstr : if :  * Update cpusets according to cpu_active mask.  If cpusets are : 
2
strstr : for :  * Update cpusets according to cpu_active mask.  If cpusets are : 
2
strstr : while :  * Update cpusets according to cpu_active mask.  If cpusets are : 
2
str :  * disabled, cpuset_update_active_cpus() becomes a simple wrapper[65]
strstr : INIT :  * disabled, cpuset_update_active_cpus() becomes a simple wrapper : 
2
strstr : if :  * disabled, cpuset_update_active_cpus() becomes a simple wrapper : 
2
strstr : for :  * disabled, cpuset_update_active_cpus() becomes a simple wrapper : 
2
strstr : while :  * disabled, cpuset_update_active_cpus() becomes a simple wrapper : 
2
str :  * around partition_sched_domains().[36]
strstr : INIT :  * around partition_sched_domains(). : 
2
strstr : if :  * around partition_sched_domains(). : 
2
strstr : for :  * around partition_sched_domains(). : 
2
strstr : while :  * around partition_sched_domains(). : 
2
str :  * If we come here as part of a suspend/resume, don't touch cpusets because we[78]
strstr : INIT :  * If we come here as part of a suspend/resume, don't touch cpusets because we : 
2
strstr : if :  * If we come here as part of a suspend/resume, don't touch cpusets because we : 
2
strstr : for :  * If we come here as part of a suspend/resume, don't touch cpusets because we : 
2
strstr : while :  * If we come here as part of a suspend/resume, don't touch cpusets because we : 
2
str :  * want to restore it back to its original state upon resume anyway.[68]
strstr : INIT :  * want to restore it back to its original state upon resume anyway. : 
2
strstr : if :  * want to restore it back to its original state upon resume anyway. : 
2
strstr : for :  * want to restore it back to its original state upon resume anyway. : 
2
strstr : while :  * want to restore it back to its original state upon resume anyway. : 
2
str :  */[3]
strstr : INIT :  */ : 
2
strstr : if :  */ : 
2
strstr : for :  */ : 
2
strstr : while :  */ : 
2
str : static int cpuset_cpu_active(struct notifier_block *nfb, unsigned long action,[78]
strstr : INIT : static int cpuset_cpu_active(struct notifier_block *nfb, unsigned long action, : 
2
strstr : if : static int cpuset_cpu_active(struct notifier_block *nfb, unsigned long action, : 
2
strstr : for : static int cpuset_cpu_active(struct notifier_block *nfb, unsigned long action, : 
2
strstr : while : static int cpuset_cpu_active(struct notifier_block *nfb, unsigned long action, : 
2
str : 			     void *hcpu)[19]
strstr : INIT : 			     void *hcpu) : 
2
strstr : if : 			     void *hcpu) : 
2
strstr : for : 			     void *hcpu) : 
2
strstr : while : 			     void *hcpu) : 
2
str : 	switch (action) {[18]
strstr : INIT : 	switch (action) { : 
2
strstr : if : 	switch (action) { : 
2
strstr : for : 	switch (action) { : 
2
strstr : while : 	switch (action) { : 
2
str : 	case CPU_ONLINE_FROZEN:[24]
strstr : INIT : 	case CPU_ONLINE_FROZEN: : 
2
strstr : if : 	case CPU_ONLINE_FROZEN: : 
2
strstr : for : 	case CPU_ONLINE_FROZEN: : 
2
strstr : while : 	case CPU_ONLINE_FROZEN: : 
2
str : 	case CPU_DOWN_FAILED_FROZEN:[29]
strstr : INIT : 	case CPU_DOWN_FAILED_FROZEN: : 
2
strstr : if : 	case CPU_DOWN_FAILED_FROZEN: : 
2
strstr : for : 	case CPU_DOWN_FAILED_FROZEN: : 
2
strstr : while : 	case CPU_DOWN_FAILED_FROZEN: : 
2
str : 		/*[4]
strstr : INIT : 		/* : 
2
strstr : if : 		/* : 
2
strstr : for : 		/* : 
2
strstr : while : 		/* : 
2
str : 		 * num_cpus_frozen tracks how many CPUs are involved in suspend[65]
strstr : INIT : 		 * num_cpus_frozen tracks how many CPUs are involved in suspend : 
2
strstr : if : 		 * num_cpus_frozen tracks how many CPUs are involved in suspend : 
2
strstr : for : 		 * num_cpus_frozen tracks how many CPUs are involved in suspend : 
2
strstr : while : 		 * num_cpus_frozen tracks how many CPUs are involved in suspend : 
2
str : 		 * resume sequence. As long as this is not the last online[60]
strstr : INIT : 		 * resume sequence. As long as this is not the last online : 
2
strstr : if : 		 * resume sequence. As long as this is not the last online : 
2
strstr : for : 		 * resume sequence. As long as this is not the last online : 
2
strstr : while : 		 * resume sequence. As long as this is not the last online : 
2
str : 		 * operation in the resume sequence, just build a single sched[64]
strstr : INIT : 		 * operation in the resume sequence, just build a single sched : 
2
strstr : if : 		 * operation in the resume sequence, just build a single sched : 
2
strstr : for : 		 * operation in the resume sequence, just build a single sched : 
2
strstr : while : 		 * operation in the resume sequence, just build a single sched : 
2
str : 		 * domain, ignoring cpusets.[30]
strstr : INIT : 		 * domain, ignoring cpusets. : 
2
strstr : if : 		 * domain, ignoring cpusets. : 
2
strstr : for : 		 * domain, ignoring cpusets. : 
2
strstr : while : 		 * domain, ignoring cpusets. : 
2
str : 		 */[5]
strstr : INIT : 		 */ : 
2
strstr : if : 		 */ : 
2
strstr : for : 		 */ : 
2
strstr : while : 		 */ : 
2
str : 		num_cpus_frozen--;[20]
strstr : INIT : 		num_cpus_frozen--; : 
2
strstr : if : 		num_cpus_frozen--; : 
2
strstr : for : 		num_cpus_frozen--; : 
2
strstr : while : 		num_cpus_frozen--; : 
2
str : 		if (likely(num_cpus_frozen)) {[32]
strstr : INIT : 		if (likely(num_cpus_frozen)) { : 
2
strstr : if : 		if (likely(num_cpus_frozen)) { : 
2
strstr : for : 		if (likely(num_cpus_frozen)) { : 
2
strstr : while : 		if (likely(num_cpus_frozen)) { : 
2
str : 			partition_sched_domains(1, NULL, NULL);[42]
strstr : INIT : 			partition_sched_domains(1, NULL, NULL); : 
2
strstr : if : 			partition_sched_domains(1, NULL, NULL); : 
2
strstr : for : 			partition_sched_domains(1, NULL, NULL); : 
2
strstr : while : 			partition_sched_domains(1, NULL, NULL); : 
2
str : 			break;[9]
strstr : INIT : 			break; : 
2
strstr : if : 			break; : 
2
strstr : for : 			break; : 
2
strstr : while : 			break; : 
2
str : 		}[3]
strstr : INIT : 		} : 
2
strstr : if : 		} : 
2
strstr : for : 		} : 
2
strstr : while : 		} : 
2
str : 		/*[4]
strstr : INIT : 		/* : 
2
strstr : if : 		/* : 
2
strstr : for : 		/* : 
2
strstr : while : 		/* : 
2
str : 		 * This is the last CPU online operation. So fall through and[63]
strstr : INIT : 		 * This is the last CPU online operation. So fall through and : 
2
strstr : if : 		 * This is the last CPU online operation. So fall through and : 
2
strstr : for : 		 * This is the last CPU online operation. So fall through and : 
2
strstr : while : 		 * This is the last CPU online operation. So fall through and : 
2
str : 		 * restore the original sched domains by considering the[58]
strstr : INIT : 		 * restore the original sched domains by considering the : 
2
strstr : if : 		 * restore the original sched domains by considering the : 
2
strstr : for : 		 * restore the original sched domains by considering the : 
2
strstr : while : 		 * restore the original sched domains by considering the : 
2
str : 		 * cpuset configurations.[27]
strstr : INIT : 		 * cpuset configurations. : 
2
strstr : if : 		 * cpuset configurations. : 
2
strstr : for : 		 * cpuset configurations. : 
2
strstr : while : 		 * cpuset configurations. : 
2
str : 		 */[5]
strstr : INIT : 		 */ : 
2
strstr : if : 		 */ : 
2
strstr : for : 		 */ : 
2
strstr : while : 		 */ : 
2
str : 	case CPU_ONLINE:[17]
strstr : INIT : 	case CPU_ONLINE: : 
2
strstr : if : 	case CPU_ONLINE: : 
2
strstr : for : 	case CPU_ONLINE: : 
2
strstr : while : 	case CPU_ONLINE: : 
2
str : 	case CPU_DOWN_FAILED:[22]
strstr : INIT : 	case CPU_DOWN_FAILED: : 
2
strstr : if : 	case CPU_DOWN_FAILED: : 
2
strstr : for : 	case CPU_DOWN_FAILED: : 
2
strstr : while : 	case CPU_DOWN_FAILED: : 
2
str : 		cpuset_update_active_cpus(true);[34]
strstr : INIT : 		cpuset_update_active_cpus(true); : 
2
strstr : if : 		cpuset_update_active_cpus(true); : 
2
strstr : for : 		cpuset_update_active_cpus(true); : 
2
strstr : while : 		cpuset_update_active_cpus(true); : 
2
str : 		break;[8]
strstr : INIT : 		break; : 
2
strstr : if : 		break; : 
2
strstr : for : 		break; : 
2
strstr : while : 		break; : 
2
str : 	default:[9]
strstr : INIT : 	default: : 
2
strstr : if : 	default: : 
2
strstr : for : 	default: : 
2
strstr : while : 	default: : 
2
str : 		return NOTIFY_DONE;[21]
strstr : INIT : 		return NOTIFY_DONE; : 
2
strstr : if : 		return NOTIFY_DONE; : 
2
strstr : for : 		return NOTIFY_DONE; : 
2
strstr : while : 		return NOTIFY_DONE; : 
2
str : 	return NOTIFY_OK;[18]
strstr : INIT : 	return NOTIFY_OK; : 
2
strstr : if : 	return NOTIFY_OK; : 
2
strstr : for : 	return NOTIFY_OK; : 
2
strstr : while : 	return NOTIFY_OK; : 
2
str : static int cpuset_cpu_inactive(struct notifier_block *nfb, unsigned long action,[80]
strstr : INIT : static int cpuset_cpu_inactive(struct notifier_block *nfb, unsigned long action, : 
2
strstr : if : static int cpuset_cpu_inactive(struct notifier_block *nfb, unsigned long action, : 
2
strstr : for : static int cpuset_cpu_inactive(struct notifier_block *nfb, unsigned long action, : 
2
strstr : while : static int cpuset_cpu_inactive(struct notifier_block *nfb, unsigned long action, : 
2
str : 			       void *hcpu)[21]
strstr : INIT : 			       void *hcpu) : 
2
strstr : if : 			       void *hcpu) : 
2
strstr : for : 			       void *hcpu) : 
2
strstr : while : 			       void *hcpu) : 
2
str : 	switch (action) {[18]
strstr : INIT : 	switch (action) { : 
2
strstr : if : 	switch (action) { : 
2
strstr : for : 	switch (action) { : 
2
strstr : while : 	switch (action) { : 
2
str : 	case CPU_DOWN_PREPARE:[23]
strstr : INIT : 	case CPU_DOWN_PREPARE: : 
2
strstr : if : 	case CPU_DOWN_PREPARE: : 
2
strstr : for : 	case CPU_DOWN_PREPARE: : 
2
strstr : while : 	case CPU_DOWN_PREPARE: : 
2
str : 		cpuset_update_active_cpus(false);[35]
strstr : INIT : 		cpuset_update_active_cpus(false); : 
2
strstr : if : 		cpuset_update_active_cpus(false); : 
2
strstr : for : 		cpuset_update_active_cpus(false); : 
2
strstr : while : 		cpuset_update_active_cpus(false); : 
2
str : 		break;[8]
strstr : INIT : 		break; : 
2
strstr : if : 		break; : 
2
strstr : for : 		break; : 
2
strstr : while : 		break; : 
2
str : 	case CPU_DOWN_PREPARE_FROZEN:[30]
strstr : INIT : 	case CPU_DOWN_PREPARE_FROZEN: : 
2
strstr : if : 	case CPU_DOWN_PREPARE_FROZEN: : 
2
strstr : for : 	case CPU_DOWN_PREPARE_FROZEN: : 
2
strstr : while : 	case CPU_DOWN_PREPARE_FROZEN: : 
2
str : 		num_cpus_frozen++;[20]
strstr : INIT : 		num_cpus_frozen++; : 
2
strstr : if : 		num_cpus_frozen++; : 
2
strstr : for : 		num_cpus_frozen++; : 
2
strstr : while : 		num_cpus_frozen++; : 
2
str : 		partition_sched_domains(1, NULL, NULL);[41]
strstr : INIT : 		partition_sched_domains(1, NULL, NULL); : 
2
strstr : if : 		partition_sched_domains(1, NULL, NULL); : 
2
strstr : for : 		partition_sched_domains(1, NULL, NULL); : 
2
strstr : while : 		partition_sched_domains(1, NULL, NULL); : 
2
str : 		break;[8]
strstr : INIT : 		break; : 
2
strstr : if : 		break; : 
2
strstr : for : 		break; : 
2
strstr : while : 		break; : 
2
str : 	default:[9]
strstr : INIT : 	default: : 
2
strstr : if : 	default: : 
2
strstr : for : 	default: : 
2
strstr : while : 	default: : 
2
str : 		return NOTIFY_DONE;[21]
strstr : INIT : 		return NOTIFY_DONE; : 
2
strstr : if : 		return NOTIFY_DONE; : 
2
strstr : for : 		return NOTIFY_DONE; : 
2
strstr : while : 		return NOTIFY_DONE; : 
2
str : 	return NOTIFY_OK;[18]
strstr : INIT : 	return NOTIFY_OK; : 
2
strstr : if : 	return NOTIFY_OK; : 
2
strstr : for : 	return NOTIFY_OK; : 
2
strstr : while : 	return NOTIFY_OK; : 
2
str : void __init sched_init_smp(void)[32]
strstr : INIT : void __init sched_init_smp(void) : 
2
strstr : if : void __init sched_init_smp(void) : 
2
strstr : for : void __init sched_init_smp(void) : 
2
strstr : while : void __init sched_init_smp(void) : 
2
str : 	cpumask_var_t non_isolated_cpus;[33]
strstr : INIT : 	cpumask_var_t non_isolated_cpus; : 
2
strstr : if : 	cpumask_var_t non_isolated_cpus; : 
2
strstr : for : 	cpumask_var_t non_isolated_cpus; : 
2
strstr : while : 	cpumask_var_t non_isolated_cpus; : 
2
str : 	alloc_cpumask_var(&non_isolated_cpus, GFP_KERNEL);[51]
strstr : INIT : 	alloc_cpumask_var(&non_isolated_cpus, GFP_KERNEL); : 
2
strstr : if : 	alloc_cpumask_var(&non_isolated_cpus, GFP_KERNEL); : 
2
strstr : for : 	alloc_cpumask_var(&non_isolated_cpus, GFP_KERNEL); : 
2
strstr : while : 	alloc_cpumask_var(&non_isolated_cpus, GFP_KERNEL); : 
2
str : 	alloc_cpumask_var(&fallback_doms, GFP_KERNEL);[47]
strstr : INIT : 	alloc_cpumask_var(&fallback_doms, GFP_KERNEL); : 
2
strstr : if : 	alloc_cpumask_var(&fallback_doms, GFP_KERNEL); : 
2
strstr : for : 	alloc_cpumask_var(&fallback_doms, GFP_KERNEL); : 
2
strstr : while : 	alloc_cpumask_var(&fallback_doms, GFP_KERNEL); : 
2
str : 	sched_init_numa();[19]
strstr : INIT : 	sched_init_numa(); : 
2
strstr : if : 	sched_init_numa(); : 
2
strstr : for : 	sched_init_numa(); : 
2
strstr : while : 	sched_init_numa(); : 
2
str : 	/*[3]
strstr : INIT : 	/* : 
2
strstr : if : 	/* : 
2
strstr : for : 	/* : 
2
strstr : while : 	/* : 
2
str : 	 * There's no userspace yet to cause hotplug operations; hence all the[71]
strstr : INIT : 	 * There's no userspace yet to cause hotplug operations; hence all the : 
2
strstr : if : 	 * There's no userspace yet to cause hotplug operations; hence all the : 
2
strstr : for : 	 * There's no userspace yet to cause hotplug operations; hence all the : 
2
strstr : while : 	 * There's no userspace yet to cause hotplug operations; hence all the : 
2
str : 	 * cpu masks are stable and all blatant races in the below code cannot[71]
strstr : INIT : 	 * cpu masks are stable and all blatant races in the below code cannot : 
2
strstr : if : 	 * cpu masks are stable and all blatant races in the below code cannot : 
2
strstr : for : 	 * cpu masks are stable and all blatant races in the below code cannot : 
2
strstr : while : 	 * cpu masks are stable and all blatant races in the below code cannot : 
2
str : 	 * happen.[11]
strstr : INIT : 	 * happen. : 
2
strstr : if : 	 * happen. : 
2
strstr : for : 	 * happen. : 
2
strstr : while : 	 * happen. : 
2
str : 	 */[4]
strstr : INIT : 	 */ : 
2
strstr : if : 	 */ : 
2
strstr : for : 	 */ : 
2
strstr : while : 	 */ : 
2
str : 	mutex_lock(&sched_domains_mutex);[34]
strstr : INIT : 	mutex_lock(&sched_domains_mutex); : 
2
strstr : if : 	mutex_lock(&sched_domains_mutex); : 
2
strstr : for : 	mutex_lock(&sched_domains_mutex); : 
2
strstr : while : 	mutex_lock(&sched_domains_mutex); : 
2
str : 	init_sched_domains(cpu_active_mask);[37]
strstr : INIT : 	init_sched_domains(cpu_active_mask); : 
2
strstr : if : 	init_sched_domains(cpu_active_mask); : 
2
strstr : for : 	init_sched_domains(cpu_active_mask); : 
2
strstr : while : 	init_sched_domains(cpu_active_mask); : 
2
str : 	cpumask_andnot(non_isolated_cpus, cpu_possible_mask, cpu_isolated_map);[72]
strstr : INIT : 	cpumask_andnot(non_isolated_cpus, cpu_possible_mask, cpu_isolated_map); : 
2
strstr : if : 	cpumask_andnot(non_isolated_cpus, cpu_possible_mask, cpu_isolated_map); : 
2
strstr : for : 	cpumask_andnot(non_isolated_cpus, cpu_possible_mask, cpu_isolated_map); : 
2
strstr : while : 	cpumask_andnot(non_isolated_cpus, cpu_possible_mask, cpu_isolated_map); : 
2
str : 	if (cpumask_empty(non_isolated_cpus))[38]
strstr : INIT : 	if (cpumask_empty(non_isolated_cpus)) : 
2
strstr : if : 	if (cpumask_empty(non_isolated_cpus)) : 
2
strstr : for : 	if (cpumask_empty(non_isolated_cpus)) : 
2
strstr : while : 	if (cpumask_empty(non_isolated_cpus)) : 
2
str : 		cpumask_set_cpu(smp_processor_id(), non_isolated_cpus);[57]
strstr : INIT : 		cpumask_set_cpu(smp_processor_id(), non_isolated_cpus); : 
2
strstr : if : 		cpumask_set_cpu(smp_processor_id(), non_isolated_cpus); : 
2
strstr : for : 		cpumask_set_cpu(smp_processor_id(), non_isolated_cpus); : 
2
strstr : while : 		cpumask_set_cpu(smp_processor_id(), non_isolated_cpus); : 
2
str : 	mutex_unlock(&sched_domains_mutex);[36]
strstr : INIT : 	mutex_unlock(&sched_domains_mutex); : 
2
strstr : if : 	mutex_unlock(&sched_domains_mutex); : 
2
strstr : for : 	mutex_unlock(&sched_domains_mutex); : 
2
strstr : while : 	mutex_unlock(&sched_domains_mutex); : 
2
str : 	hotcpu_notifier(sched_domains_numa_masks_update, CPU_PRI_SCHED_ACTIVE);[72]
strstr : INIT : 	hotcpu_notifier(sched_domains_numa_masks_update, CPU_PRI_SCHED_ACTIVE); : 
2
strstr : if : 	hotcpu_notifier(sched_domains_numa_masks_update, CPU_PRI_SCHED_ACTIVE); : 
2
strstr : for : 	hotcpu_notifier(sched_domains_numa_masks_update, CPU_PRI_SCHED_ACTIVE); : 
2
strstr : while : 	hotcpu_notifier(sched_domains_numa_masks_update, CPU_PRI_SCHED_ACTIVE); : 
2
str : 	hotcpu_notifier(cpuset_cpu_active, CPU_PRI_CPUSET_ACTIVE);[59]
strstr : INIT : 	hotcpu_notifier(cpuset_cpu_active, CPU_PRI_CPUSET_ACTIVE); : 
2
strstr : if : 	hotcpu_notifier(cpuset_cpu_active, CPU_PRI_CPUSET_ACTIVE); : 
2
strstr : for : 	hotcpu_notifier(cpuset_cpu_active, CPU_PRI_CPUSET_ACTIVE); : 
2
strstr : while : 	hotcpu_notifier(cpuset_cpu_active, CPU_PRI_CPUSET_ACTIVE); : 
2
str : 	hotcpu_notifier(cpuset_cpu_inactive, CPU_PRI_CPUSET_INACTIVE);[63]
strstr : INIT : 	hotcpu_notifier(cpuset_cpu_inactive, CPU_PRI_CPUSET_INACTIVE); : 
2
strstr : if : 	hotcpu_notifier(cpuset_cpu_inactive, CPU_PRI_CPUSET_INACTIVE); : 
2
strstr : for : 	hotcpu_notifier(cpuset_cpu_inactive, CPU_PRI_CPUSET_INACTIVE); : 
2
strstr : while : 	hotcpu_notifier(cpuset_cpu_inactive, CPU_PRI_CPUSET_INACTIVE); : 
2
str : 	init_hrtick();[15]
strstr : INIT : 	init_hrtick(); : 
2
strstr : if : 	init_hrtick(); : 
2
strstr : for : 	init_hrtick(); : 
2
strstr : while : 	init_hrtick(); : 
2
str : 	/* Move init over to a non-isolated CPU */[43]
strstr : INIT : 	/* Move init over to a non-isolated CPU */ : 
2
strstr : if : 	/* Move init over to a non-isolated CPU */ : 
2
strstr : for : 	/* Move init over to a non-isolated CPU */ : 
2
strstr : while : 	/* Move init over to a non-isolated CPU */ : 
2
str : 	if (set_cpus_allowed_ptr(current, non_isolated_cpus) < 0)[58]
strstr : INIT : 	if (set_cpus_allowed_ptr(current, non_isolated_cpus) < 0) : 
2
strstr : if : 	if (set_cpus_allowed_ptr(current, non_isolated_cpus) < 0) : 
2
strstr : for : 	if (set_cpus_allowed_ptr(current, non_isolated_cpus) < 0) : 
2
strstr : while : 	if (set_cpus_allowed_ptr(current, non_isolated_cpus) < 0) : 
2
str : 		BUG();[8]
strstr : INIT : 		BUG(); : 
2
strstr : if : 		BUG(); : 
2
strstr : for : 		BUG(); : 
2
strstr : while : 		BUG(); : 
2
str : 	sched_init_granularity();[26]
strstr : INIT : 	sched_init_granularity(); : 
2
strstr : if : 	sched_init_granularity(); : 
2
strstr : for : 	sched_init_granularity(); : 
2
strstr : while : 	sched_init_granularity(); : 
2
str : 	free_cpumask_var(non_isolated_cpus);[37]
strstr : INIT : 	free_cpumask_var(non_isolated_cpus); : 
2
strstr : if : 	free_cpumask_var(non_isolated_cpus); : 
2
strstr : for : 	free_cpumask_var(non_isolated_cpus); : 
2
strstr : while : 	free_cpumask_var(non_isolated_cpus); : 
2
str : 	init_sched_rt_class();[23]
strstr : INIT : 	init_sched_rt_class(); : 
2
strstr : if : 	init_sched_rt_class(); : 
2
strstr : for : 	init_sched_rt_class(); : 
2
strstr : while : 	init_sched_rt_class(); : 
2
str : 	init_sched_dl_class();[23]
strstr : INIT : 	init_sched_dl_class(); : 
2
strstr : if : 	init_sched_dl_class(); : 
2
strstr : for : 	init_sched_dl_class(); : 
2
strstr : while : 	init_sched_dl_class(); : 
2
str : #else[5]
strstr : INIT : #else : 
2
strstr : if : #else : 
2
strstr : for : #else : 
2
strstr : while : #else : 
2
str : void __init sched_init_smp(void)[32]
strstr : INIT : void __init sched_init_smp(void) : 
2
strstr : if : void __init sched_init_smp(void) : 
2
strstr : for : void __init sched_init_smp(void) : 
2
strstr : while : void __init sched_init_smp(void) : 
2
str : 	sched_init_granularity();[26]
strstr : INIT : 	sched_init_granularity(); : 
2
strstr : if : 	sched_init_granularity(); : 
2
strstr : for : 	sched_init_granularity(); : 
2
strstr : while : 	sched_init_granularity(); : 
2
str : #endif /* CONFIG_SMP */[23]
strstr : INIT : #endif /* CONFIG_SMP */ : 
2
strstr : if : #endif /* CONFIG_SMP */ : 
2
strstr : for : #endif /* CONFIG_SMP */ : 
2
strstr : while : #endif /* CONFIG_SMP */ : 
2
str : const_debug unsigned int sysctl_timer_migration = 1;[52]
strstr : INIT : const_debug unsigned int sysctl_timer_migration = 1; : 
2
strstr : if : const_debug unsigned int sysctl_timer_migration = 1; : 
2
strstr : for : const_debug unsigned int sysctl_timer_migration = 1; : 
2
strstr : while : const_debug unsigned int sysctl_timer_migration = 1; : 
2
str : int in_sched_functions(unsigned long addr)[42]
strstr : INIT : int in_sched_functions(unsigned long addr) : 
2
strstr : if : int in_sched_functions(unsigned long addr) : 
2
strstr : for : int in_sched_functions(unsigned long addr) : 
2
strstr : while : int in_sched_functions(unsigned long addr) : 
2
str : 	return in_lock_functions(addr) ||[34]
strstr : INIT : 	return in_lock_functions(addr) || : 
2
strstr : if : 	return in_lock_functions(addr) || : 
2
strstr : for : 	return in_lock_functions(addr) || : 
2
strstr : while : 	return in_lock_functions(addr) || : 
2
str : 		(addr >= (unsigned long)__sched_text_start[44]
strstr : INIT : 		(addr >= (unsigned long)__sched_text_start : 
2
strstr : if : 		(addr >= (unsigned long)__sched_text_start : 
2
strstr : for : 		(addr >= (unsigned long)__sched_text_start : 
2
strstr : while : 		(addr >= (unsigned long)__sched_text_start : 
2
str : 		&& addr < (unsigned long)__sched_text_end);[45]
strstr : INIT : 		&& addr < (unsigned long)__sched_text_end); : 
2
strstr : if : 		&& addr < (unsigned long)__sched_text_end); : 
2
strstr : for : 		&& addr < (unsigned long)__sched_text_end); : 
2
strstr : while : 		&& addr < (unsigned long)__sched_text_end); : 
2
str : #ifdef CONFIG_CGROUP_SCHED[26]
strstr : INIT : #ifdef CONFIG_CGROUP_SCHED : 
2
strstr : if : #ifdef CONFIG_CGROUP_SCHED : 
2
strstr : for : #ifdef CONFIG_CGROUP_SCHED : 
2
strstr : while : #ifdef CONFIG_CGROUP_SCHED : 
2
str :  * Default task group.[22]
strstr : INIT :  * Default task group. : 
2
strstr : if :  * Default task group. : 
2
strstr : for :  * Default task group. : 
2
strstr : while :  * Default task group. : 
2
str :  * Every task in system belongs to this group at bootup.[56]
strstr : INIT :  * Every task in system belongs to this group at bootup. : 
2
strstr : if :  * Every task in system belongs to this group at bootup. : 
2
strstr : for :  * Every task in system belongs to this group at bootup. : 
2
strstr : while :  * Every task in system belongs to this group at bootup. : 
2
str :  */[3]
strstr : INIT :  */ : 
2
strstr : if :  */ : 
2
strstr : for :  */ : 
2
strstr : while :  */ : 
2
str : struct task_group root_task_group;[34]
strstr : INIT : struct task_group root_task_group; : 
2
strstr : if : struct task_group root_task_group; : 
2
strstr : for : struct task_group root_task_group; : 
2
strstr : while : struct task_group root_task_group; : 
2
str : LIST_HEAD(task_groups);[23]
strstr : INIT : LIST_HEAD(task_groups); : 
2
strstr : if : LIST_HEAD(task_groups); : 
2
strstr : for : LIST_HEAD(task_groups); : 
2
strstr : while : LIST_HEAD(task_groups); : 
2
str : #endif[6]
strstr : INIT : #endif : 
2
strstr : if : #endif : 
2
strstr : for : #endif : 
2
strstr : while : #endif : 
2
str : DECLARE_PER_CPU(cpumask_var_t, load_balance_mask);[50]
strstr : INIT : DECLARE_PER_CPU(cpumask_var_t, load_balance_mask); : 
2
strstr : if : DECLARE_PER_CPU(cpumask_var_t, load_balance_mask); : 
2
strstr : for : DECLARE_PER_CPU(cpumask_var_t, load_balance_mask); : 
2
strstr : while : DECLARE_PER_CPU(cpumask_var_t, load_balance_mask); : 
2
str : void __init sched_init(void)[28]
strstr : INIT : void __init sched_init(void) : 
2
strstr : if : void __init sched_init(void) : 
2
strstr : for : void __init sched_init(void) : 
2
strstr : while : void __init sched_init(void) : 
2
str : 	int i, j;[10]
strstr : INIT : 	int i, j; : 
2
strstr : if : 	int i, j; : 
2
strstr : for : 	int i, j; : 
2
strstr : while : 	int i, j; : 
2
str : 	unsigned long alloc_size = 0, ptr;[35]
strstr : INIT : 	unsigned long alloc_size = 0, ptr; : 
2
strstr : if : 	unsigned long alloc_size = 0, ptr; : 
2
strstr : for : 	unsigned long alloc_size = 0, ptr; : 
2
strstr : while : 	unsigned long alloc_size = 0, ptr; : 
2
str : #ifdef CONFIG_FAIR_GROUP_SCHED[30]
strstr : INIT : #ifdef CONFIG_FAIR_GROUP_SCHED : 
2
strstr : if : #ifdef CONFIG_FAIR_GROUP_SCHED : 
2
strstr : for : #ifdef CONFIG_FAIR_GROUP_SCHED : 
2
strstr : while : #ifdef CONFIG_FAIR_GROUP_SCHED : 
2
str : 	alloc_size += 2 * nr_cpu_ids * sizeof(void **);[48]
strstr : INIT : 	alloc_size += 2 * nr_cpu_ids * sizeof(void **); : 
2
strstr : if : 	alloc_size += 2 * nr_cpu_ids * sizeof(void **); : 
2
strstr : for : 	alloc_size += 2 * nr_cpu_ids * sizeof(void **); : 
2
strstr : while : 	alloc_size += 2 * nr_cpu_ids * sizeof(void **); : 
2
str : #endif[6]
strstr : INIT : #endif : 
2
strstr : if : #endif : 
2
strstr : for : #endif : 
2
strstr : while : #endif : 
2
str : #ifdef CONFIG_RT_GROUP_SCHED[28]
strstr : INIT : #ifdef CONFIG_RT_GROUP_SCHED : 
2
strstr : if : #ifdef CONFIG_RT_GROUP_SCHED : 
2
strstr : for : #ifdef CONFIG_RT_GROUP_SCHED : 
2
strstr : while : #ifdef CONFIG_RT_GROUP_SCHED : 
2
str : 	alloc_size += 2 * nr_cpu_ids * sizeof(void **);[48]
strstr : INIT : 	alloc_size += 2 * nr_cpu_ids * sizeof(void **); : 
2
strstr : if : 	alloc_size += 2 * nr_cpu_ids * sizeof(void **); : 
2
strstr : for : 	alloc_size += 2 * nr_cpu_ids * sizeof(void **); : 
2
strstr : while : 	alloc_size += 2 * nr_cpu_ids * sizeof(void **); : 
2
str : #endif[6]
strstr : INIT : #endif : 
2
strstr : if : #endif : 
2
strstr : for : #endif : 
2
strstr : while : #endif : 
2
str : #ifdef CONFIG_CPUMASK_OFFSTACK[30]
strstr : INIT : #ifdef CONFIG_CPUMASK_OFFSTACK : 
2
strstr : if : #ifdef CONFIG_CPUMASK_OFFSTACK : 
2
strstr : for : #ifdef CONFIG_CPUMASK_OFFSTACK : 
2
strstr : while : #ifdef CONFIG_CPUMASK_OFFSTACK : 
2
str : 	alloc_size += num_possible_cpus() * cpumask_size();[52]
strstr : INIT : 	alloc_size += num_possible_cpus() * cpumask_size(); : 
2
strstr : if : 	alloc_size += num_possible_cpus() * cpumask_size(); : 
2
strstr : for : 	alloc_size += num_possible_cpus() * cpumask_size(); : 
2
strstr : while : 	alloc_size += num_possible_cpus() * cpumask_size(); : 
2
str : #endif[6]
strstr : INIT : #endif : 
2
strstr : if : #endif : 
2
strstr : for : #endif : 
2
strstr : while : #endif : 
2
str : 	if (alloc_size) {[18]
strstr : INIT : 	if (alloc_size) { : 
2
strstr : if : 	if (alloc_size) { : 
2
strstr : for : 	if (alloc_size) { : 
2
strstr : while : 	if (alloc_size) { : 
2
str : 		ptr = (unsigned long)kzalloc(alloc_size, GFP_NOWAIT);[55]
strstr : INIT : 		ptr = (unsigned long)kzalloc(alloc_size, GFP_NOWAIT); : 
2
strstr : if : 		ptr = (unsigned long)kzalloc(alloc_size, GFP_NOWAIT); : 
2
strstr : for : 		ptr = (unsigned long)kzalloc(alloc_size, GFP_NOWAIT); : 
2
strstr : while : 		ptr = (unsigned long)kzalloc(alloc_size, GFP_NOWAIT); : 
2
str : #ifdef CONFIG_FAIR_GROUP_SCHED[30]
strstr : INIT : #ifdef CONFIG_FAIR_GROUP_SCHED : 
2
strstr : if : #ifdef CONFIG_FAIR_GROUP_SCHED : 
2
strstr : for : #ifdef CONFIG_FAIR_GROUP_SCHED : 
2
strstr : while : #ifdef CONFIG_FAIR_GROUP_SCHED : 
2
str : 		root_task_group.se = (struct sched_entity **)ptr;[51]
strstr : INIT : 		root_task_group.se = (struct sched_entity **)ptr; : 
2
strstr : if : 		root_task_group.se = (struct sched_entity **)ptr; : 
2
strstr : for : 		root_task_group.se = (struct sched_entity **)ptr; : 
2
strstr : while : 		root_task_group.se = (struct sched_entity **)ptr; : 
2
str : 		ptr += nr_cpu_ids * sizeof(void **);[38]
strstr : INIT : 		ptr += nr_cpu_ids * sizeof(void **); : 
2
strstr : if : 		ptr += nr_cpu_ids * sizeof(void **); : 
2
strstr : for : 		ptr += nr_cpu_ids * sizeof(void **); : 
2
strstr : while : 		ptr += nr_cpu_ids * sizeof(void **); : 
2
str : 		root_task_group.cfs_rq = (struct cfs_rq **)ptr;[49]
strstr : INIT : 		root_task_group.cfs_rq = (struct cfs_rq **)ptr; : 
2
strstr : if : 		root_task_group.cfs_rq = (struct cfs_rq **)ptr; : 
2
strstr : for : 		root_task_group.cfs_rq = (struct cfs_rq **)ptr; : 
2
strstr : while : 		root_task_group.cfs_rq = (struct cfs_rq **)ptr; : 
2
str : 		ptr += nr_cpu_ids * sizeof(void **);[38]
strstr : INIT : 		ptr += nr_cpu_ids * sizeof(void **); : 
2
strstr : if : 		ptr += nr_cpu_ids * sizeof(void **); : 
2
strstr : for : 		ptr += nr_cpu_ids * sizeof(void **); : 
2
strstr : while : 		ptr += nr_cpu_ids * sizeof(void **); : 
2
str : #endif /* CONFIG_FAIR_GROUP_SCHED */[36]
strstr : INIT : #endif /* CONFIG_FAIR_GROUP_SCHED */ : 
2
strstr : if : #endif /* CONFIG_FAIR_GROUP_SCHED */ : 
2
strstr : for : #endif /* CONFIG_FAIR_GROUP_SCHED */ : 
2
strstr : while : #endif /* CONFIG_FAIR_GROUP_SCHED */ : 
2
str : #ifdef CONFIG_RT_GROUP_SCHED[28]
strstr : INIT : #ifdef CONFIG_RT_GROUP_SCHED : 
2
strstr : if : #ifdef CONFIG_RT_GROUP_SCHED : 
2
strstr : for : #ifdef CONFIG_RT_GROUP_SCHED : 
2
strstr : while : #ifdef CONFIG_RT_GROUP_SCHED : 
2
str : 		root_task_group.rt_se = (struct sched_rt_entity **)ptr;[57]
strstr : INIT : 		root_task_group.rt_se = (struct sched_rt_entity **)ptr; : 
2
strstr : if : 		root_task_group.rt_se = (struct sched_rt_entity **)ptr; : 
2
strstr : for : 		root_task_group.rt_se = (struct sched_rt_entity **)ptr; : 
2
strstr : while : 		root_task_group.rt_se = (struct sched_rt_entity **)ptr; : 
2
str : 		ptr += nr_cpu_ids * sizeof(void **);[38]
strstr : INIT : 		ptr += nr_cpu_ids * sizeof(void **); : 
2
strstr : if : 		ptr += nr_cpu_ids * sizeof(void **); : 
2
strstr : for : 		ptr += nr_cpu_ids * sizeof(void **); : 
2
strstr : while : 		ptr += nr_cpu_ids * sizeof(void **); : 
2
str : 		root_task_group.rt_rq = (struct rt_rq **)ptr;[47]
strstr : INIT : 		root_task_group.rt_rq = (struct rt_rq **)ptr; : 
2
strstr : if : 		root_task_group.rt_rq = (struct rt_rq **)ptr; : 
2
strstr : for : 		root_task_group.rt_rq = (struct rt_rq **)ptr; : 
2
strstr : while : 		root_task_group.rt_rq = (struct rt_rq **)ptr; : 
2
str : 		ptr += nr_cpu_ids * sizeof(void **);[38]
strstr : INIT : 		ptr += nr_cpu_ids * sizeof(void **); : 
2
strstr : if : 		ptr += nr_cpu_ids * sizeof(void **); : 
2
strstr : for : 		ptr += nr_cpu_ids * sizeof(void **); : 
2
strstr : while : 		ptr += nr_cpu_ids * sizeof(void **); : 
2
str : #endif /* CONFIG_RT_GROUP_SCHED */[34]
strstr : INIT : #endif /* CONFIG_RT_GROUP_SCHED */ : 
2
strstr : if : #endif /* CONFIG_RT_GROUP_SCHED */ : 
2
strstr : for : #endif /* CONFIG_RT_GROUP_SCHED */ : 
2
strstr : while : #endif /* CONFIG_RT_GROUP_SCHED */ : 
2
str : #ifdef CONFIG_CPUMASK_OFFSTACK[30]
strstr : INIT : #ifdef CONFIG_CPUMASK_OFFSTACK : 
2
strstr : if : #ifdef CONFIG_CPUMASK_OFFSTACK : 
2
strstr : for : #ifdef CONFIG_CPUMASK_OFFSTACK : 
2
strstr : while : #ifdef CONFIG_CPUMASK_OFFSTACK : 
2
str : 		for_each_possible_cpu(i) {[28]
strstr : INIT : 		for_each_possible_cpu(i) { : 
2
strstr : if : 		for_each_possible_cpu(i) { : 
2
strstr : for : 		for_each_possible_cpu(i) { : 
2
strstr : while : 		for_each_possible_cpu(i) { : 
2
str : 			per_cpu(load_balance_mask, i) = (void *)ptr;[47]
strstr : INIT : 			per_cpu(load_balance_mask, i) = (void *)ptr; : 
2
strstr : if : 			per_cpu(load_balance_mask, i) = (void *)ptr; : 
2
strstr : for : 			per_cpu(load_balance_mask, i) = (void *)ptr; : 
2
strstr : while : 			per_cpu(load_balance_mask, i) = (void *)ptr; : 
2
str : 			ptr += cpumask_size();[25]
strstr : INIT : 			ptr += cpumask_size(); : 
2
strstr : if : 			ptr += cpumask_size(); : 
2
strstr : for : 			ptr += cpumask_size(); : 
2
strstr : while : 			ptr += cpumask_size(); : 
2
str : 		}[3]
strstr : INIT : 		} : 
2
strstr : if : 		} : 
2
strstr : for : 		} : 
2
strstr : while : 		} : 
2
str : #endif /* CONFIG_CPUMASK_OFFSTACK */[36]
strstr : INIT : #endif /* CONFIG_CPUMASK_OFFSTACK */ : 
2
strstr : if : #endif /* CONFIG_CPUMASK_OFFSTACK */ : 
2
strstr : for : #endif /* CONFIG_CPUMASK_OFFSTACK */ : 
2
strstr : while : #endif /* CONFIG_CPUMASK_OFFSTACK */ : 
2
str : 	init_rt_bandwidth(&def_rt_bandwidth,[37]
strstr : INIT : 	init_rt_bandwidth(&def_rt_bandwidth, : 
2
strstr : if : 	init_rt_bandwidth(&def_rt_bandwidth, : 
2
strstr : for : 	init_rt_bandwidth(&def_rt_bandwidth, : 
2
strstr : while : 	init_rt_bandwidth(&def_rt_bandwidth, : 
2
str : 			global_rt_period(), global_rt_runtime());[44]
strstr : INIT : 			global_rt_period(), global_rt_runtime()); : 
2
strstr : if : 			global_rt_period(), global_rt_runtime()); : 
2
strstr : for : 			global_rt_period(), global_rt_runtime()); : 
2
strstr : while : 			global_rt_period(), global_rt_runtime()); : 
2
str : 	init_dl_bandwidth(&def_dl_bandwidth,[37]
strstr : INIT : 	init_dl_bandwidth(&def_dl_bandwidth, : 
2
strstr : if : 	init_dl_bandwidth(&def_dl_bandwidth, : 
2
strstr : for : 	init_dl_bandwidth(&def_dl_bandwidth, : 
2
strstr : while : 	init_dl_bandwidth(&def_dl_bandwidth, : 
2
str : 			global_rt_period(), global_rt_runtime());[44]
strstr : INIT : 			global_rt_period(), global_rt_runtime()); : 
2
strstr : if : 			global_rt_period(), global_rt_runtime()); : 
2
strstr : for : 			global_rt_period(), global_rt_runtime()); : 
2
strstr : while : 			global_rt_period(), global_rt_runtime()); : 
2
str : #ifdef CONFIG_SMP[17]
strstr : INIT : #ifdef CONFIG_SMP : 
2
strstr : if : #ifdef CONFIG_SMP : 
2
strstr : for : #ifdef CONFIG_SMP : 
2
strstr : while : #ifdef CONFIG_SMP : 
2
str : 	init_defrootdomain();[22]
strstr : INIT : 	init_defrootdomain(); : 
2
strstr : if : 	init_defrootdomain(); : 
2
strstr : for : 	init_defrootdomain(); : 
2
strstr : while : 	init_defrootdomain(); : 
2
str : #endif[6]
strstr : INIT : #endif : 
2
strstr : if : #endif : 
2
strstr : for : #endif : 
2
strstr : while : #endif : 
2
str : #ifdef CONFIG_RT_GROUP_SCHED[28]
strstr : INIT : #ifdef CONFIG_RT_GROUP_SCHED : 
2
strstr : if : #ifdef CONFIG_RT_GROUP_SCHED : 
2
strstr : for : #ifdef CONFIG_RT_GROUP_SCHED : 
2
strstr : while : #ifdef CONFIG_RT_GROUP_SCHED : 
2
str : 	init_rt_bandwidth(&root_task_group.rt_bandwidth,[49]
strstr : INIT : 	init_rt_bandwidth(&root_task_group.rt_bandwidth, : 
2
strstr : if : 	init_rt_bandwidth(&root_task_group.rt_bandwidth, : 
2
strstr : for : 	init_rt_bandwidth(&root_task_group.rt_bandwidth, : 
2
strstr : while : 	init_rt_bandwidth(&root_task_group.rt_bandwidth, : 
2
str : 			global_rt_period(), global_rt_runtime());[44]
strstr : INIT : 			global_rt_period(), global_rt_runtime()); : 
2
strstr : if : 			global_rt_period(), global_rt_runtime()); : 
2
strstr : for : 			global_rt_period(), global_rt_runtime()); : 
2
strstr : while : 			global_rt_period(), global_rt_runtime()); : 
2
str : #endif /* CONFIG_RT_GROUP_SCHED */[34]
strstr : INIT : #endif /* CONFIG_RT_GROUP_SCHED */ : 
2
strstr : if : #endif /* CONFIG_RT_GROUP_SCHED */ : 
2
strstr : for : #endif /* CONFIG_RT_GROUP_SCHED */ : 
2
strstr : while : #endif /* CONFIG_RT_GROUP_SCHED */ : 
2
str : #ifdef CONFIG_CGROUP_SCHED[26]
strstr : INIT : #ifdef CONFIG_CGROUP_SCHED : 
2
strstr : if : #ifdef CONFIG_CGROUP_SCHED : 
2
strstr : for : #ifdef CONFIG_CGROUP_SCHED : 
2
strstr : while : #ifdef CONFIG_CGROUP_SCHED : 
2
str : 	list_add(&root_task_group.list, &task_groups);[47]
strstr : INIT : 	list_add(&root_task_group.list, &task_groups); : 
2
strstr : if : 	list_add(&root_task_group.list, &task_groups); : 
2
strstr : for : 	list_add(&root_task_group.list, &task_groups); : 
2
strstr : while : 	list_add(&root_task_group.list, &task_groups); : 
2
str : 	INIT_LIST_HEAD(&root_task_group.children);[43]
strstr : INIT : 	INIT_LIST_HEAD(&root_task_group.children); : 
2
strstr : if : 	INIT_LIST_HEAD(&root_task_group.children); : 
2
strstr : for : 	INIT_LIST_HEAD(&root_task_group.children); : 
2
strstr : while : 	INIT_LIST_HEAD(&root_task_group.children); : 
2
str : 	INIT_LIST_HEAD(&root_task_group.siblings);[43]
strstr : INIT : 	INIT_LIST_HEAD(&root_task_group.siblings); : 
2
strstr : if : 	INIT_LIST_HEAD(&root_task_group.siblings); : 
2
strstr : for : 	INIT_LIST_HEAD(&root_task_group.siblings); : 
2
strstr : while : 	INIT_LIST_HEAD(&root_task_group.siblings); : 
2
str : 	autogroup_init(&init_task);[28]
strstr : INIT : 	autogroup_init(&init_task); : 
2
strstr : if : 	autogroup_init(&init_task); : 
2
strstr : for : 	autogroup_init(&init_task); : 
2
strstr : while : 	autogroup_init(&init_task); : 
2
str : #endif /* CONFIG_CGROUP_SCHED */[32]
strstr : INIT : #endif /* CONFIG_CGROUP_SCHED */ : 
2
strstr : if : #endif /* CONFIG_CGROUP_SCHED */ : 
2
strstr : for : #endif /* CONFIG_CGROUP_SCHED */ : 
2
strstr : while : #endif /* CONFIG_CGROUP_SCHED */ : 
2
str : 	for_each_possible_cpu(i) {[27]
strstr : INIT : 	for_each_possible_cpu(i) { : 
2
strstr : if : 	for_each_possible_cpu(i) { : 
2
strstr : for : 	for_each_possible_cpu(i) { : 
2
strstr : while : 	for_each_possible_cpu(i) { : 
2
str : 		struct rq *rq;[16]
strstr : INIT : 		struct rq *rq; : 
2
strstr : if : 		struct rq *rq; : 
2
strstr : for : 		struct rq *rq; : 
2
strstr : while : 		struct rq *rq; : 
2
str : 		rq = cpu_rq(i);[17]
strstr : INIT : 		rq = cpu_rq(i); : 
2
strstr : if : 		rq = cpu_rq(i); : 
2
strstr : for : 		rq = cpu_rq(i); : 
2
strstr : while : 		rq = cpu_rq(i); : 
2
str : 		raw_spin_lock_init(&rq->lock);[32]
strstr : INIT : 		raw_spin_lock_init(&rq->lock); : 
2
strstr : if : 		raw_spin_lock_init(&rq->lock); : 
2
strstr : for : 		raw_spin_lock_init(&rq->lock); : 
2
strstr : while : 		raw_spin_lock_init(&rq->lock); : 
2
str : 		rq->nr_running = 0;[21]
strstr : INIT : 		rq->nr_running = 0; : 
2
strstr : if : 		rq->nr_running = 0; : 
2
strstr : for : 		rq->nr_running = 0; : 
2
strstr : while : 		rq->nr_running = 0; : 
2
str : 		rq->calc_load_active = 0;[27]
strstr : INIT : 		rq->calc_load_active = 0; : 
2
strstr : if : 		rq->calc_load_active = 0; : 
2
strstr : for : 		rq->calc_load_active = 0; : 
2
strstr : while : 		rq->calc_load_active = 0; : 
2
str : 		rq->calc_load_update = jiffies + LOAD_FREQ;[45]
strstr : INIT : 		rq->calc_load_update = jiffies + LOAD_FREQ; : 
2
strstr : if : 		rq->calc_load_update = jiffies + LOAD_FREQ; : 
2
strstr : for : 		rq->calc_load_update = jiffies + LOAD_FREQ; : 
2
strstr : while : 		rq->calc_load_update = jiffies + LOAD_FREQ; : 
2
str : 		init_cfs_rq(&rq->cfs);[24]
strstr : INIT : 		init_cfs_rq(&rq->cfs); : 
2
strstr : if : 		init_cfs_rq(&rq->cfs); : 
2
strstr : for : 		init_cfs_rq(&rq->cfs); : 
2
strstr : while : 		init_cfs_rq(&rq->cfs); : 
2
str : 		init_rt_rq(&rq->rt, rq);[26]
strstr : INIT : 		init_rt_rq(&rq->rt, rq); : 
2
strstr : if : 		init_rt_rq(&rq->rt, rq); : 
2
strstr : for : 		init_rt_rq(&rq->rt, rq); : 
2
strstr : while : 		init_rt_rq(&rq->rt, rq); : 
2
str : 		init_dl_rq(&rq->dl, rq);[26]
strstr : INIT : 		init_dl_rq(&rq->dl, rq); : 
2
strstr : if : 		init_dl_rq(&rq->dl, rq); : 
2
strstr : for : 		init_dl_rq(&rq->dl, rq); : 
2
strstr : while : 		init_dl_rq(&rq->dl, rq); : 
2
str : #ifdef CONFIG_FAIR_GROUP_SCHED[30]
strstr : INIT : #ifdef CONFIG_FAIR_GROUP_SCHED : 
2
strstr : if : #ifdef CONFIG_FAIR_GROUP_SCHED : 
2
strstr : for : #ifdef CONFIG_FAIR_GROUP_SCHED : 
2
strstr : while : #ifdef CONFIG_FAIR_GROUP_SCHED : 
2
str : 		root_task_group.shares = ROOT_TASK_GROUP_LOAD;[48]
strstr : INIT : 		root_task_group.shares = ROOT_TASK_GROUP_LOAD; : 
2
strstr : if : 		root_task_group.shares = ROOT_TASK_GROUP_LOAD; : 
2
strstr : for : 		root_task_group.shares = ROOT_TASK_GROUP_LOAD; : 
2
strstr : while : 		root_task_group.shares = ROOT_TASK_GROUP_LOAD; : 
2
str : 		INIT_LIST_HEAD(&rq->leaf_cfs_rq_list);[40]
strstr : INIT : 		INIT_LIST_HEAD(&rq->leaf_cfs_rq_list); : 
2
strstr : if : 		INIT_LIST_HEAD(&rq->leaf_cfs_rq_list); : 
2
strstr : for : 		INIT_LIST_HEAD(&rq->leaf_cfs_rq_list); : 
2
strstr : while : 		INIT_LIST_HEAD(&rq->leaf_cfs_rq_list); : 
2
str : 		/*[4]
strstr : INIT : 		/* : 
2
strstr : if : 		/* : 
2
strstr : for : 		/* : 
2
strstr : while : 		/* : 
2
str : 		 * How much cpu bandwidth does root_task_group get?[53]
strstr : INIT : 		 * How much cpu bandwidth does root_task_group get? : 
2
strstr : if : 		 * How much cpu bandwidth does root_task_group get? : 
2
strstr : for : 		 * How much cpu bandwidth does root_task_group get? : 
2
strstr : while : 		 * How much cpu bandwidth does root_task_group get? : 
2
str : 		 *[4]
strstr : INIT : 		 * : 
2
strstr : if : 		 * : 
2
strstr : for : 		 * : 
2
strstr : while : 		 * : 
2
str : 		 * In case of task-groups formed thr' the cgroup filesystem, it[65]
strstr : INIT : 		 * In case of task-groups formed thr' the cgroup filesystem, it : 
2
strstr : if : 		 * In case of task-groups formed thr' the cgroup filesystem, it : 
2
strstr : for : 		 * In case of task-groups formed thr' the cgroup filesystem, it : 
2
strstr : while : 		 * In case of task-groups formed thr' the cgroup filesystem, it : 
2
str : 		 * gets 100% of the cpu resources in the system. This overall[63]
strstr : INIT : 		 * gets 100% of the cpu resources in the system. This overall : 
2
strstr : if : 		 * gets 100% of the cpu resources in the system. This overall : 
2
strstr : for : 		 * gets 100% of the cpu resources in the system. This overall : 
2
strstr : while : 		 * gets 100% of the cpu resources in the system. This overall : 
2
str : 		 * system cpu resource is divided among the tasks of[54]
strstr : INIT : 		 * system cpu resource is divided among the tasks of : 
2
strstr : if : 		 * system cpu resource is divided among the tasks of : 
2
strstr : for : 		 * system cpu resource is divided among the tasks of : 
2
strstr : while : 		 * system cpu resource is divided among the tasks of : 
2
str : 		 * root_task_group and its child task-groups in a fair manner,[64]
strstr : INIT : 		 * root_task_group and its child task-groups in a fair manner, : 
2
strstr : if : 		 * root_task_group and its child task-groups in a fair manner, : 
2
strstr : for : 		 * root_task_group and its child task-groups in a fair manner, : 
2
strstr : while : 		 * root_task_group and its child task-groups in a fair manner, : 
2
str : 		 * based on each entity's (task or task-group's) weight[57]
strstr : INIT : 		 * based on each entity's (task or task-group's) weight : 
2
strstr : if : 		 * based on each entity's (task or task-group's) weight : 
2
strstr : for : 		 * based on each entity's (task or task-group's) weight : 
2
strstr : while : 		 * based on each entity's (task or task-group's) weight : 
2
str : 		 * (se->load.weight).[23]
strstr : INIT : 		 * (se->load.weight). : 
2
strstr : if : 		 * (se->load.weight). : 
2
strstr : for : 		 * (se->load.weight). : 
2
strstr : while : 		 * (se->load.weight). : 
2
str : 		 *[4]
strstr : INIT : 		 * : 
2
strstr : if : 		 * : 
2
strstr : for : 		 * : 
2
strstr : while : 		 * : 
2
str : 		 * In other words, if root_task_group has 10 tasks of weight[62]
strstr : INIT : 		 * In other words, if root_task_group has 10 tasks of weight : 
2
strstr : if : 		 * In other words, if root_task_group has 10 tasks of weight : 
2
strstr : for : 		 * In other words, if root_task_group has 10 tasks of weight : 
2
strstr : while : 		 * In other words, if root_task_group has 10 tasks of weight : 
2
str : 		 * 1024) and two child groups A0 and A1 (of weight 1024 each),[64]
strstr : INIT : 		 * 1024) and two child groups A0 and A1 (of weight 1024 each), : 
2
strstr : if : 		 * 1024) and two child groups A0 and A1 (of weight 1024 each), : 
2
strstr : for : 		 * 1024) and two child groups A0 and A1 (of weight 1024 each), : 
2
strstr : while : 		 * 1024) and two child groups A0 and A1 (of weight 1024 each), : 
2
str : 		 * then A0's share of the cpu resource is:[44]
strstr : INIT : 		 * then A0's share of the cpu resource is: : 
2
strstr : if : 		 * then A0's share of the cpu resource is: : 
2
strstr : for : 		 * then A0's share of the cpu resource is: : 
2
strstr : while : 		 * then A0's share of the cpu resource is: : 
2
str : 		 *[4]
strstr : INIT : 		 * : 
2
strstr : if : 		 * : 
2
strstr : for : 		 * : 
2
strstr : while : 		 * : 
2
str : 		 *	A0's bandwidth = 1024 / (10*1024 + 1024 + 1024) = 8.33%[60]
strstr : INIT : 		 *	A0's bandwidth = 1024 / (10*1024 + 1024 + 1024) = 8.33% : 
2
strstr : if : 		 *	A0's bandwidth = 1024 / (10*1024 + 1024 + 1024) = 8.33% : 
2
strstr : for : 		 *	A0's bandwidth = 1024 / (10*1024 + 1024 + 1024) = 8.33% : 
2
strstr : while : 		 *	A0's bandwidth = 1024 / (10*1024 + 1024 + 1024) = 8.33% : 
2
str : 		 *[4]
strstr : INIT : 		 * : 
2
strstr : if : 		 * : 
2
strstr : for : 		 * : 
2
strstr : while : 		 * : 
2
str : 		 * We achieve this by letting root_task_group's tasks sit[59]
strstr : INIT : 		 * We achieve this by letting root_task_group's tasks sit : 
2
strstr : if : 		 * We achieve this by letting root_task_group's tasks sit : 
2
strstr : for : 		 * We achieve this by letting root_task_group's tasks sit : 
2
strstr : while : 		 * We achieve this by letting root_task_group's tasks sit : 
2
str : 		 * directly in rq->cfs (i.e root_task_group->se[] = NULL).[60]
strstr : INIT : 		 * directly in rq->cfs (i.e root_task_group->se[] = NULL). : 
2
strstr : if : 		 * directly in rq->cfs (i.e root_task_group->se[] = NULL). : 
2
strstr : for : 		 * directly in rq->cfs (i.e root_task_group->se[] = NULL). : 
2
strstr : while : 		 * directly in rq->cfs (i.e root_task_group->se[] = NULL). : 
2
str : 		 */[5]
strstr : INIT : 		 */ : 
2
strstr : if : 		 */ : 
2
strstr : for : 		 */ : 
2
strstr : while : 		 */ : 
2
str : 		init_cfs_bandwidth(&root_task_group.cfs_bandwidth);[53]
strstr : INIT : 		init_cfs_bandwidth(&root_task_group.cfs_bandwidth); : 
2
strstr : if : 		init_cfs_bandwidth(&root_task_group.cfs_bandwidth); : 
2
strstr : for : 		init_cfs_bandwidth(&root_task_group.cfs_bandwidth); : 
2
strstr : while : 		init_cfs_bandwidth(&root_task_group.cfs_bandwidth); : 
2
str : 		init_tg_cfs_entry(&root_task_group, &rq->cfs, NULL, i, NULL);[63]
strstr : INIT : 		init_tg_cfs_entry(&root_task_group, &rq->cfs, NULL, i, NULL); : 
2
strstr : if : 		init_tg_cfs_entry(&root_task_group, &rq->cfs, NULL, i, NULL); : 
2
strstr : for : 		init_tg_cfs_entry(&root_task_group, &rq->cfs, NULL, i, NULL); : 
2
strstr : while : 		init_tg_cfs_entry(&root_task_group, &rq->cfs, NULL, i, NULL); : 
2
str : #endif /* CONFIG_FAIR_GROUP_SCHED */[36]
strstr : INIT : #endif /* CONFIG_FAIR_GROUP_SCHED */ : 
2
strstr : if : #endif /* CONFIG_FAIR_GROUP_SCHED */ : 
2
strstr : for : #endif /* CONFIG_FAIR_GROUP_SCHED */ : 
2
strstr : while : #endif /* CONFIG_FAIR_GROUP_SCHED */ : 
2
str : 		rq->rt.rt_runtime = def_rt_bandwidth.rt_runtime;[50]
strstr : INIT : 		rq->rt.rt_runtime = def_rt_bandwidth.rt_runtime; : 
2
strstr : if : 		rq->rt.rt_runtime = def_rt_bandwidth.rt_runtime; : 
2
strstr : for : 		rq->rt.rt_runtime = def_rt_bandwidth.rt_runtime; : 
2
strstr : while : 		rq->rt.rt_runtime = def_rt_bandwidth.rt_runtime; : 
2
str : #ifdef CONFIG_RT_GROUP_SCHED[28]
strstr : INIT : #ifdef CONFIG_RT_GROUP_SCHED : 
2
strstr : if : #ifdef CONFIG_RT_GROUP_SCHED : 
2
strstr : for : #ifdef CONFIG_RT_GROUP_SCHED : 
2
strstr : while : #ifdef CONFIG_RT_GROUP_SCHED : 
2
str : 		INIT_LIST_HEAD(&rq->leaf_rt_rq_list);[39]
strstr : INIT : 		INIT_LIST_HEAD(&rq->leaf_rt_rq_list); : 
2
strstr : if : 		INIT_LIST_HEAD(&rq->leaf_rt_rq_list); : 
2
strstr : for : 		INIT_LIST_HEAD(&rq->leaf_rt_rq_list); : 
2
strstr : while : 		INIT_LIST_HEAD(&rq->leaf_rt_rq_list); : 
2
str : 		init_tg_rt_entry(&root_task_group, &rq->rt, NULL, i, NULL);[61]
strstr : INIT : 		init_tg_rt_entry(&root_task_group, &rq->rt, NULL, i, NULL); : 
2
strstr : if : 		init_tg_rt_entry(&root_task_group, &rq->rt, NULL, i, NULL); : 
2
strstr : for : 		init_tg_rt_entry(&root_task_group, &rq->rt, NULL, i, NULL); : 
2
strstr : while : 		init_tg_rt_entry(&root_task_group, &rq->rt, NULL, i, NULL); : 
2
str : #endif[6]
strstr : INIT : #endif : 
2
strstr : if : #endif : 
2
strstr : for : #endif : 
2
strstr : while : #endif : 
2
str : 		for (j = 0; j < CPU_LOAD_IDX_MAX; j++)[40]
strstr : INIT : 		for (j = 0; j < CPU_LOAD_IDX_MAX; j++) : 
2
strstr : if : 		for (j = 0; j < CPU_LOAD_IDX_MAX; j++) : 
2
strstr : for : 		for (j = 0; j < CPU_LOAD_IDX_MAX; j++) : 
2
strstr : while : 		for (j = 0; j < CPU_LOAD_IDX_MAX; j++) : 
2
str : 			rq->cpu_load[j] = 0;[23]
strstr : INIT : 			rq->cpu_load[j] = 0; : 
2
strstr : if : 			rq->cpu_load[j] = 0; : 
2
strstr : for : 			rq->cpu_load[j] = 0; : 
2
strstr : while : 			rq->cpu_load[j] = 0; : 
2
str : 		rq->last_load_update_tick = jiffies;[38]
strstr : INIT : 		rq->last_load_update_tick = jiffies; : 
2
strstr : if : 		rq->last_load_update_tick = jiffies; : 
2
strstr : for : 		rq->last_load_update_tick = jiffies; : 
2
strstr : while : 		rq->last_load_update_tick = jiffies; : 
2
str : #ifdef CONFIG_SMP[17]
strstr : INIT : #ifdef CONFIG_SMP : 
2
strstr : if : #ifdef CONFIG_SMP : 
2
strstr : for : #ifdef CONFIG_SMP : 
2
strstr : while : #ifdef CONFIG_SMP : 
2
str : 		rq->sd = NULL;[16]
strstr : INIT : 		rq->sd = NULL; : 
2
strstr : if : 		rq->sd = NULL; : 
2
strstr : for : 		rq->sd = NULL; : 
2
strstr : while : 		rq->sd = NULL; : 
2
str : 		rq->rd = NULL;[16]
strstr : INIT : 		rq->rd = NULL; : 
2
strstr : if : 		rq->rd = NULL; : 
2
strstr : for : 		rq->rd = NULL; : 
2
strstr : while : 		rq->rd = NULL; : 
2
str : 		rq->cpu_power = SCHED_POWER_SCALE;[36]
strstr : INIT : 		rq->cpu_power = SCHED_POWER_SCALE; : 
2
strstr : if : 		rq->cpu_power = SCHED_POWER_SCALE; : 
2
strstr : for : 		rq->cpu_power = SCHED_POWER_SCALE; : 
2
strstr : while : 		rq->cpu_power = SCHED_POWER_SCALE; : 
2
str : 		rq->post_schedule = 0;[24]
strstr : INIT : 		rq->post_schedule = 0; : 
2
strstr : if : 		rq->post_schedule = 0; : 
2
strstr : for : 		rq->post_schedule = 0; : 
2
strstr : while : 		rq->post_schedule = 0; : 
2
str : 		rq->active_balance = 0;[25]
strstr : INIT : 		rq->active_balance = 0; : 
2
strstr : if : 		rq->active_balance = 0; : 
2
strstr : for : 		rq->active_balance = 0; : 
2
strstr : while : 		rq->active_balance = 0; : 
2
str : 		rq->next_balance = jiffies;[29]
strstr : INIT : 		rq->next_balance = jiffies; : 
2
strstr : if : 		rq->next_balance = jiffies; : 
2
strstr : for : 		rq->next_balance = jiffies; : 
2
strstr : while : 		rq->next_balance = jiffies; : 
2
str : 		rq->push_cpu = 0;[19]
strstr : INIT : 		rq->push_cpu = 0; : 
2
strstr : if : 		rq->push_cpu = 0; : 
2
strstr : for : 		rq->push_cpu = 0; : 
2
strstr : while : 		rq->push_cpu = 0; : 
2
str : 		rq->cpu = i;[14]
strstr : INIT : 		rq->cpu = i; : 
2
strstr : if : 		rq->cpu = i; : 
2
strstr : for : 		rq->cpu = i; : 
2
strstr : while : 		rq->cpu = i; : 
2
str : 		rq->online = 0;[17]
strstr : INIT : 		rq->online = 0; : 
2
strstr : if : 		rq->online = 0; : 
2
strstr : for : 		rq->online = 0; : 
2
strstr : while : 		rq->online = 0; : 
2
str : 		rq->idle_stamp = 0;[21]
strstr : INIT : 		rq->idle_stamp = 0; : 
2
strstr : if : 		rq->idle_stamp = 0; : 
2
strstr : for : 		rq->idle_stamp = 0; : 
2
strstr : while : 		rq->idle_stamp = 0; : 
2
str : 		rq->avg_idle = 2*sysctl_sched_migration_cost;[47]
strstr : INIT : 		rq->avg_idle = 2*sysctl_sched_migration_cost; : 
2
strstr : if : 		rq->avg_idle = 2*sysctl_sched_migration_cost; : 
2
strstr : for : 		rq->avg_idle = 2*sysctl_sched_migration_cost; : 
2
strstr : while : 		rq->avg_idle = 2*sysctl_sched_migration_cost; : 
2
str : 		rq->max_idle_balance_cost = sysctl_sched_migration_cost;[58]
strstr : INIT : 		rq->max_idle_balance_cost = sysctl_sched_migration_cost; : 
2
strstr : if : 		rq->max_idle_balance_cost = sysctl_sched_migration_cost; : 
2
strstr : for : 		rq->max_idle_balance_cost = sysctl_sched_migration_cost; : 
2
strstr : while : 		rq->max_idle_balance_cost = sysctl_sched_migration_cost; : 
2
str : 		INIT_LIST_HEAD(&rq->cfs_tasks);[33]
strstr : INIT : 		INIT_LIST_HEAD(&rq->cfs_tasks); : 
2
strstr : if : 		INIT_LIST_HEAD(&rq->cfs_tasks); : 
2
strstr : for : 		INIT_LIST_HEAD(&rq->cfs_tasks); : 
2
strstr : while : 		INIT_LIST_HEAD(&rq->cfs_tasks); : 
2
str : 		rq_attach_root(rq, &def_root_domain);[39]
strstr : INIT : 		rq_attach_root(rq, &def_root_domain); : 
2
strstr : if : 		rq_attach_root(rq, &def_root_domain); : 
2
strstr : for : 		rq_attach_root(rq, &def_root_domain); : 
2
strstr : while : 		rq_attach_root(rq, &def_root_domain); : 
2
str : #ifdef CONFIG_NO_HZ_COMMON[26]
strstr : INIT : #ifdef CONFIG_NO_HZ_COMMON : 
2
strstr : if : #ifdef CONFIG_NO_HZ_COMMON : 
2
strstr : for : #ifdef CONFIG_NO_HZ_COMMON : 
2
strstr : while : #ifdef CONFIG_NO_HZ_COMMON : 
2
str : 		rq->nohz_flags = 0;[21]
strstr : INIT : 		rq->nohz_flags = 0; : 
2
strstr : if : 		rq->nohz_flags = 0; : 
2
strstr : for : 		rq->nohz_flags = 0; : 
2
strstr : while : 		rq->nohz_flags = 0; : 
2
str : #endif[6]
strstr : INIT : #endif : 
2
strstr : if : #endif : 
2
strstr : for : #endif : 
2
strstr : while : #endif : 
2
str : #ifdef CONFIG_NO_HZ_FULL[24]
strstr : INIT : #ifdef CONFIG_NO_HZ_FULL : 
2
strstr : if : #ifdef CONFIG_NO_HZ_FULL : 
2
strstr : for : #ifdef CONFIG_NO_HZ_FULL : 
2
strstr : while : #ifdef CONFIG_NO_HZ_FULL : 
2
str : 		rq->last_sched_tick = 0;[26]
strstr : INIT : 		rq->last_sched_tick = 0; : 
2
strstr : if : 		rq->last_sched_tick = 0; : 
2
strstr : for : 		rq->last_sched_tick = 0; : 
2
strstr : while : 		rq->last_sched_tick = 0; : 
2
str : #endif[6]
strstr : INIT : #endif : 
2
strstr : if : #endif : 
2
strstr : for : #endif : 
2
strstr : while : #endif : 
2
str : #endif[6]
strstr : INIT : #endif : 
2
strstr : if : #endif : 
2
strstr : for : #endif : 
2
strstr : while : #endif : 
2
str : 		init_rq_hrtick(rq);[21]
strstr : INIT : 		init_rq_hrtick(rq); : 
2
strstr : if : 		init_rq_hrtick(rq); : 
2
strstr : for : 		init_rq_hrtick(rq); : 
2
strstr : while : 		init_rq_hrtick(rq); : 
2
str : 		atomic_set(&rq->nr_iowait, 0);[32]
strstr : INIT : 		atomic_set(&rq->nr_iowait, 0); : 
2
strstr : if : 		atomic_set(&rq->nr_iowait, 0); : 
2
strstr : for : 		atomic_set(&rq->nr_iowait, 0); : 
2
strstr : while : 		atomic_set(&rq->nr_iowait, 0); : 
2
str : 	set_load_weight(&init_task);[29]
strstr : INIT : 	set_load_weight(&init_task); : 
2
strstr : if : 	set_load_weight(&init_task); : 
2
strstr : for : 	set_load_weight(&init_task); : 
2
strstr : while : 	set_load_weight(&init_task); : 
2
str : #ifdef CONFIG_PREEMPT_NOTIFIERS[31]
strstr : INIT : #ifdef CONFIG_PREEMPT_NOTIFIERS : 
2
strstr : if : #ifdef CONFIG_PREEMPT_NOTIFIERS : 
2
strstr : for : #ifdef CONFIG_PREEMPT_NOTIFIERS : 
2
strstr : while : #ifdef CONFIG_PREEMPT_NOTIFIERS : 
2
str : 	INIT_HLIST_HEAD(&init_task.preempt_notifiers);[47]
strstr : INIT : 	INIT_HLIST_HEAD(&init_task.preempt_notifiers); : 
2
strstr : if : 	INIT_HLIST_HEAD(&init_task.preempt_notifiers); : 
2
strstr : for : 	INIT_HLIST_HEAD(&init_task.preempt_notifiers); : 
2
strstr : while : 	INIT_HLIST_HEAD(&init_task.preempt_notifiers); : 
2
str : #endif[6]
strstr : INIT : #endif : 
2
strstr : if : #endif : 
2
strstr : for : #endif : 
2
strstr : while : #endif : 
2
str : 	/*[3]
strstr : INIT : 	/* : 
2
strstr : if : 	/* : 
2
strstr : for : 	/* : 
2
strstr : while : 	/* : 
2
str : 	 * The boot idle thread does lazy MMU switching as well:[57]
strstr : INIT : 	 * The boot idle thread does lazy MMU switching as well: : 
2
strstr : if : 	 * The boot idle thread does lazy MMU switching as well: : 
2
strstr : for : 	 * The boot idle thread does lazy MMU switching as well: : 
2
strstr : while : 	 * The boot idle thread does lazy MMU switching as well: : 
2
str : 	 */[4]
strstr : INIT : 	 */ : 
2
strstr : if : 	 */ : 
2
strstr : for : 	 */ : 
2
strstr : while : 	 */ : 
2
str : 	atomic_inc(&init_mm.mm_count);[31]
strstr : INIT : 	atomic_inc(&init_mm.mm_count); : 
2
strstr : if : 	atomic_inc(&init_mm.mm_count); : 
2
strstr : for : 	atomic_inc(&init_mm.mm_count); : 
2
strstr : while : 	atomic_inc(&init_mm.mm_count); : 
2
str : 	enter_lazy_tlb(&init_mm, current);[35]
strstr : INIT : 	enter_lazy_tlb(&init_mm, current); : 
2
strstr : if : 	enter_lazy_tlb(&init_mm, current); : 
2
strstr : for : 	enter_lazy_tlb(&init_mm, current); : 
2
strstr : while : 	enter_lazy_tlb(&init_mm, current); : 
2
str : 	/*[3]
strstr : INIT : 	/* : 
2
strstr : if : 	/* : 
2
strstr : for : 	/* : 
2
strstr : while : 	/* : 
2
str : 	 * Make us the idle thread. Technically, schedule() should not be[66]
strstr : INIT : 	 * Make us the idle thread. Technically, schedule() should not be : 
2
strstr : if : 	 * Make us the idle thread. Technically, schedule() should not be : 
2
strstr : for : 	 * Make us the idle thread. Technically, schedule() should not be : 
2
strstr : while : 	 * Make us the idle thread. Technically, schedule() should not be : 
2
str : 	 * called from this thread, however somewhere below it might be,[65]
strstr : INIT : 	 * called from this thread, however somewhere below it might be, : 
2
strstr : if : 	 * called from this thread, however somewhere below it might be, : 
2
strstr : for : 	 * called from this thread, however somewhere below it might be, : 
2
strstr : while : 	 * called from this thread, however somewhere below it might be, : 
2
str : 	 * but because we are the idle thread, we just pick up running again[69]
strstr : INIT : 	 * but because we are the idle thread, we just pick up running again : 
2
strstr : if : 	 * but because we are the idle thread, we just pick up running again : 
2
strstr : for : 	 * but because we are the idle thread, we just pick up running again : 
2
strstr : while : 	 * but because we are the idle thread, we just pick up running again : 
2
str : 	 * when this runqueue becomes "idle".[38]
strstr : INIT : 	 * when this runqueue becomes "idle". : 
2
strstr : if : 	 * when this runqueue becomes "idle". : 
2
strstr : for : 	 * when this runqueue becomes "idle". : 
2
strstr : while : 	 * when this runqueue becomes "idle". : 
2
str : 	 */[4]
strstr : INIT : 	 */ : 
2
strstr : if : 	 */ : 
2
strstr : for : 	 */ : 
2
strstr : while : 	 */ : 
2
str : 	init_idle(current, smp_processor_id());[40]
strstr : INIT : 	init_idle(current, smp_processor_id()); : 
2
strstr : if : 	init_idle(current, smp_processor_id()); : 
2
strstr : for : 	init_idle(current, smp_processor_id()); : 
2
strstr : while : 	init_idle(current, smp_processor_id()); : 
2
str : 	calc_load_update = jiffies + LOAD_FREQ;[40]
strstr : INIT : 	calc_load_update = jiffies + LOAD_FREQ; : 
2
strstr : if : 	calc_load_update = jiffies + LOAD_FREQ; : 
2
strstr : for : 	calc_load_update = jiffies + LOAD_FREQ; : 
2
strstr : while : 	calc_load_update = jiffies + LOAD_FREQ; : 
2
str : 	/*[3]
strstr : INIT : 	/* : 
2
strstr : if : 	/* : 
2
strstr : for : 	/* : 
2
strstr : while : 	/* : 
2
str : 	 * During early bootup we pretend to be a normal task:[55]
strstr : INIT : 	 * During early bootup we pretend to be a normal task: : 
2
strstr : if : 	 * During early bootup we pretend to be a normal task: : 
2
strstr : for : 	 * During early bootup we pretend to be a normal task: : 
2
strstr : while : 	 * During early bootup we pretend to be a normal task: : 
2
str : 	 */[4]
strstr : INIT : 	 */ : 
2
strstr : if : 	 */ : 
2
strstr : for : 	 */ : 
2
strstr : while : 	 */ : 
2
str : 	current->sched_class = &fair_sched_class;[42]
strstr : INIT : 	current->sched_class = &fair_sched_class; : 
2
strstr : if : 	current->sched_class = &fair_sched_class; : 
2
strstr : for : 	current->sched_class = &fair_sched_class; : 
2
strstr : while : 	current->sched_class = &fair_sched_class; : 
2
str : #ifdef CONFIG_SMP[17]
strstr : INIT : #ifdef CONFIG_SMP : 
2
strstr : if : #ifdef CONFIG_SMP : 
2
strstr : for : #ifdef CONFIG_SMP : 
2
strstr : while : #ifdef CONFIG_SMP : 
2
str : 	zalloc_cpumask_var(&sched_domains_tmpmask, GFP_NOWAIT);[56]
strstr : INIT : 	zalloc_cpumask_var(&sched_domains_tmpmask, GFP_NOWAIT); : 
2
strstr : if : 	zalloc_cpumask_var(&sched_domains_tmpmask, GFP_NOWAIT); : 
2
strstr : for : 	zalloc_cpumask_var(&sched_domains_tmpmask, GFP_NOWAIT); : 
2
strstr : while : 	zalloc_cpumask_var(&sched_domains_tmpmask, GFP_NOWAIT); : 
2
str : 	/* May be allocated at isolcpus cmdline parse time */[54]
strstr : INIT : 	/* May be allocated at isolcpus cmdline parse time */ : 
2
strstr : if : 	/* May be allocated at isolcpus cmdline parse time */ : 
2
strstr : for : 	/* May be allocated at isolcpus cmdline parse time */ : 
2
strstr : while : 	/* May be allocated at isolcpus cmdline parse time */ : 
2
str : 	if (cpu_isolated_map == NULL)[30]
strstr : INIT : 	if (cpu_isolated_map == NULL) : 
2
strstr : if : 	if (cpu_isolated_map == NULL) : 
2
strstr : for : 	if (cpu_isolated_map == NULL) : 
2
strstr : while : 	if (cpu_isolated_map == NULL) : 
2
str : 		zalloc_cpumask_var(&cpu_isolated_map, GFP_NOWAIT);[52]
strstr : INIT : 		zalloc_cpumask_var(&cpu_isolated_map, GFP_NOWAIT); : 
2
strstr : if : 		zalloc_cpumask_var(&cpu_isolated_map, GFP_NOWAIT); : 
2
strstr : for : 		zalloc_cpumask_var(&cpu_isolated_map, GFP_NOWAIT); : 
2
strstr : while : 		zalloc_cpumask_var(&cpu_isolated_map, GFP_NOWAIT); : 
2
str : 	idle_thread_set_boot_cpu();[28]
strstr : INIT : 	idle_thread_set_boot_cpu(); : 
2
strstr : if : 	idle_thread_set_boot_cpu(); : 
2
strstr : for : 	idle_thread_set_boot_cpu(); : 
2
strstr : while : 	idle_thread_set_boot_cpu(); : 
2
str : #endif[6]
strstr : INIT : #endif : 
2
strstr : if : #endif : 
2
strstr : for : #endif : 
2
strstr : while : #endif : 
2
str : 	init_sched_fair_class();[25]
strstr : INIT : 	init_sched_fair_class(); : 
2
strstr : if : 	init_sched_fair_class(); : 
2
strstr : for : 	init_sched_fair_class(); : 
2
strstr : while : 	init_sched_fair_class(); : 
2
str : 	scheduler_running = 1;[23]
strstr : INIT : 	scheduler_running = 1; : 
2
strstr : if : 	scheduler_running = 1; : 
2
strstr : for : 	scheduler_running = 1; : 
2
strstr : while : 	scheduler_running = 1; : 
2
str : #ifdef CONFIG_DEBUG_ATOMIC_SLEEP[32]
strstr : INIT : #ifdef CONFIG_DEBUG_ATOMIC_SLEEP : 
2
strstr : if : #ifdef CONFIG_DEBUG_ATOMIC_SLEEP : 
2
strstr : for : #ifdef CONFIG_DEBUG_ATOMIC_SLEEP : 
2
strstr : while : #ifdef CONFIG_DEBUG_ATOMIC_SLEEP : 
2
str : static inline int preempt_count_equals(int preempt_offset)[58]
strstr : INIT : static inline int preempt_count_equals(int preempt_offset) : 
2
strstr : if : static inline int preempt_count_equals(int preempt_offset) : 
2
strstr : for : static inline int preempt_count_equals(int preempt_offset) : 
2
strstr : while : static inline int preempt_count_equals(int preempt_offset) : 
2
str : 	int nested = (preempt_count() & ~PREEMPT_ACTIVE) + rcu_preempt_depth();[72]
strstr : INIT : 	int nested = (preempt_count() & ~PREEMPT_ACTIVE) + rcu_preempt_depth(); : 
2
strstr : if : 	int nested = (preempt_count() & ~PREEMPT_ACTIVE) + rcu_preempt_depth(); : 
2
strstr : for : 	int nested = (preempt_count() & ~PREEMPT_ACTIVE) + rcu_preempt_depth(); : 
2
strstr : while : 	int nested = (preempt_count() & ~PREEMPT_ACTIVE) + rcu_preempt_depth(); : 
2
str : 	return (nested == preempt_offset);[35]
strstr : INIT : 	return (nested == preempt_offset); : 
2
strstr : if : 	return (nested == preempt_offset); : 
2
strstr : for : 	return (nested == preempt_offset); : 
2
strstr : while : 	return (nested == preempt_offset); : 
2
str : void __might_sleep(const char *file, int line, int preempt_offset)[66]
strstr : INIT : void __might_sleep(const char *file, int line, int preempt_offset) : 
2
strstr : if : void __might_sleep(const char *file, int line, int preempt_offset) : 
2
strstr : for : void __might_sleep(const char *file, int line, int preempt_offset) : 
2
strstr : while : void __might_sleep(const char *file, int line, int preempt_offset) : 
2
str : 	static unsigned long prev_jiffy;	/* ratelimiting */[52]
strstr : INIT : 	static unsigned long prev_jiffy;	/* ratelimiting */ : 
2
strstr : if : 	static unsigned long prev_jiffy;	/* ratelimiting */ : 
2
strstr : for : 	static unsigned long prev_jiffy;	/* ratelimiting */ : 
2
strstr : while : 	static unsigned long prev_jiffy;	/* ratelimiting */ : 
2
str : 	rcu_sleep_check(); /* WARN_ON_ONCE() by default, no rate limit reqd. */[72]
strstr : INIT : 	rcu_sleep_check(); /* WARN_ON_ONCE() by default, no rate limit reqd. */ : 
2
strstr : if : 	rcu_sleep_check(); /* WARN_ON_ONCE() by default, no rate limit reqd. */ : 
2
strstr : for : 	rcu_sleep_check(); /* WARN_ON_ONCE() by default, no rate limit reqd. */ : 
2
strstr : while : 	rcu_sleep_check(); /* WARN_ON_ONCE() by default, no rate limit reqd. */ : 
2
str : 	if ((preempt_count_equals(preempt_offset) && !irqs_disabled()) ||[66]
strstr : INIT : 	if ((preempt_count_equals(preempt_offset) && !irqs_disabled()) || : 
2
strstr : if : 	if ((preempt_count_equals(preempt_offset) && !irqs_disabled()) || : 
2
strstr : for : 	if ((preempt_count_equals(preempt_offset) && !irqs_disabled()) || : 
2
strstr : while : 	if ((preempt_count_equals(preempt_offset) && !irqs_disabled()) || : 
2
str : 	    system_state != SYSTEM_RUNNING || oops_in_progress)[56]
strstr : INIT : 	    system_state != SYSTEM_RUNNING || oops_in_progress) : 
2
strstr : if : 	    system_state != SYSTEM_RUNNING || oops_in_progress) : 
2
strstr : for : 	    system_state != SYSTEM_RUNNING || oops_in_progress) : 
2
strstr : while : 	    system_state != SYSTEM_RUNNING || oops_in_progress) : 
2
str : 		return;[9]
strstr : INIT : 		return; : 
2
strstr : if : 		return; : 
2
strstr : for : 		return; : 
2
strstr : while : 		return; : 
2
str : 	if (time_before(jiffies, prev_jiffy + HZ) && prev_jiffy)[57]
strstr : INIT : 	if (time_before(jiffies, prev_jiffy + HZ) && prev_jiffy) : 
2
strstr : if : 	if (time_before(jiffies, prev_jiffy + HZ) && prev_jiffy) : 
2
strstr : for : 	if (time_before(jiffies, prev_jiffy + HZ) && prev_jiffy) : 
2
strstr : while : 	if (time_before(jiffies, prev_jiffy + HZ) && prev_jiffy) : 
2
str : 		return;[9]
strstr : INIT : 		return; : 
2
strstr : if : 		return; : 
2
strstr : for : 		return; : 
2
strstr : while : 		return; : 
2
str : 	prev_jiffy = jiffies;[22]
strstr : INIT : 	prev_jiffy = jiffies; : 
2
strstr : if : 	prev_jiffy = jiffies; : 
2
strstr : for : 	prev_jiffy = jiffies; : 
2
strstr : while : 	prev_jiffy = jiffies; : 
2
str : 	printk(KERN_ERR[16]
strstr : INIT : 	printk(KERN_ERR : 
2
strstr : if : 	printk(KERN_ERR : 
2
strstr : for : 	printk(KERN_ERR : 
2
strstr : while : 	printk(KERN_ERR : 
2
str : 		"BUG: sleeping function called from invalid context at %s:%d\n",[66]
strstr : INIT : 		"BUG: sleeping function called from invalid context at %s:%d\n", : 
2
strstr : if : 		"BUG: sleeping function called from invalid context at %s:%d\n", : 
2
strstr : for : 		"BUG: sleeping function called from invalid context at %s:%d\n", : 
2
strstr : while : 		"BUG: sleeping function called from invalid context at %s:%d\n", : 
2
str : 			file, line);[15]
strstr : INIT : 			file, line); : 
2
strstr : if : 			file, line); : 
2
strstr : for : 			file, line); : 
2
strstr : while : 			file, line); : 
2
str : 	printk(KERN_ERR[16]
strstr : INIT : 	printk(KERN_ERR : 
2
strstr : if : 	printk(KERN_ERR : 
2
strstr : for : 	printk(KERN_ERR : 
2
strstr : while : 	printk(KERN_ERR : 
2
str : 		"in_atomic(): %d, irqs_disabled(): %d, pid: %d, name: %s\n",[62]
strstr : INIT : 		"in_atomic(): %d, irqs_disabled(): %d, pid: %d, name: %s\n", : 
2
strstr : if : 		"in_atomic(): %d, irqs_disabled(): %d, pid: %d, name: %s\n", : 
2
strstr : for : 		"in_atomic(): %d, irqs_disabled(): %d, pid: %d, name: %s\n", : 
2
strstr : while : 		"in_atomic(): %d, irqs_disabled(): %d, pid: %d, name: %s\n", : 
2
str : 			in_atomic(), irqs_disabled(),[32]
strstr : INIT : 			in_atomic(), irqs_disabled(), : 
2
strstr : if : 			in_atomic(), irqs_disabled(), : 
2
strstr : for : 			in_atomic(), irqs_disabled(), : 
2
strstr : while : 			in_atomic(), irqs_disabled(), : 
2
str : 			current->pid, current->comm);[32]
strstr : INIT : 			current->pid, current->comm); : 
2
strstr : if : 			current->pid, current->comm); : 
2
strstr : for : 			current->pid, current->comm); : 
2
strstr : while : 			current->pid, current->comm); : 
2
str : 	debug_show_held_locks(current);[32]
strstr : INIT : 	debug_show_held_locks(current); : 
2
strstr : if : 	debug_show_held_locks(current); : 
2
strstr : for : 	debug_show_held_locks(current); : 
2
strstr : while : 	debug_show_held_locks(current); : 
2
str : 	if (irqs_disabled())[21]
strstr : INIT : 	if (irqs_disabled()) : 
2
strstr : if : 	if (irqs_disabled()) : 
2
strstr : for : 	if (irqs_disabled()) : 
2
strstr : while : 	if (irqs_disabled()) : 
2
str : 		print_irqtrace_events(current);[33]
strstr : INIT : 		print_irqtrace_events(current); : 
2
strstr : if : 		print_irqtrace_events(current); : 
2
strstr : for : 		print_irqtrace_events(current); : 
2
strstr : while : 		print_irqtrace_events(current); : 
2
str : 	dump_stack();[14]
strstr : INIT : 	dump_stack(); : 
2
strstr : if : 	dump_stack(); : 
2
strstr : for : 	dump_stack(); : 
2
strstr : while : 	dump_stack(); : 
2
str : EXPORT_SYMBOL(__might_sleep);[29]
strstr : INIT : EXPORT_SYMBOL(__might_sleep); : 
2
strstr : if : EXPORT_SYMBOL(__might_sleep); : 
2
strstr : for : EXPORT_SYMBOL(__might_sleep); : 
2
strstr : while : EXPORT_SYMBOL(__might_sleep); : 
2
str : #endif[6]
strstr : INIT : #endif : 
2
strstr : if : #endif : 
2
strstr : for : #endif : 
2
strstr : while : #endif : 
2
str : #ifdef CONFIG_MAGIC_SYSRQ[25]
strstr : INIT : #ifdef CONFIG_MAGIC_SYSRQ : 
2
strstr : if : #ifdef CONFIG_MAGIC_SYSRQ : 
2
strstr : for : #ifdef CONFIG_MAGIC_SYSRQ : 
2
strstr : while : #ifdef CONFIG_MAGIC_SYSRQ : 
2
str : static void normalize_task(struct rq *rq, struct task_struct *p)[64]
strstr : INIT : static void normalize_task(struct rq *rq, struct task_struct *p) : 
2
strstr : if : static void normalize_task(struct rq *rq, struct task_struct *p) : 
2
strstr : for : static void normalize_task(struct rq *rq, struct task_struct *p) : 
2
strstr : while : static void normalize_task(struct rq *rq, struct task_struct *p) : 
2
str : 	const struct sched_class *prev_class = p->sched_class;[55]
strstr : INIT : 	const struct sched_class *prev_class = p->sched_class; : 
2
strstr : if : 	const struct sched_class *prev_class = p->sched_class; : 
2
strstr : for : 	const struct sched_class *prev_class = p->sched_class; : 
2
strstr : while : 	const struct sched_class *prev_class = p->sched_class; : 
2
str : 	struct sched_attr attr = {[27]
strstr : INIT : 	struct sched_attr attr = { : 
2
strstr : if : 	struct sched_attr attr = { : 
2
strstr : for : 	struct sched_attr attr = { : 
2
strstr : while : 	struct sched_attr attr = { : 
2
str : 		.sched_policy = SCHED_NORMAL,[31]
strstr : INIT : 		.sched_policy = SCHED_NORMAL, : 
2
strstr : if : 		.sched_policy = SCHED_NORMAL, : 
2
strstr : for : 		.sched_policy = SCHED_NORMAL, : 
2
strstr : while : 		.sched_policy = SCHED_NORMAL, : 
2
str : 	};[3]
strstr : INIT : 	}; : 
2
strstr : if : 	}; : 
2
strstr : for : 	}; : 
2
strstr : while : 	}; : 
2
str : 	int old_prio = p->prio;[24]
strstr : INIT : 	int old_prio = p->prio; : 
2
strstr : if : 	int old_prio = p->prio; : 
2
strstr : for : 	int old_prio = p->prio; : 
2
strstr : while : 	int old_prio = p->prio; : 
2
str : 	int on_rq;[11]
strstr : INIT : 	int on_rq; : 
2
strstr : if : 	int on_rq; : 
2
strstr : for : 	int on_rq; : 
2
strstr : while : 	int on_rq; : 
2
str : 	on_rq = p->on_rq;[18]
strstr : INIT : 	on_rq = p->on_rq; : 
2
strstr : if : 	on_rq = p->on_rq; : 
2
strstr : for : 	on_rq = p->on_rq; : 
2
strstr : while : 	on_rq = p->on_rq; : 
2
str : 	if (on_rq)[11]
strstr : INIT : 	if (on_rq) : 
2
strstr : if : 	if (on_rq) : 
2
strstr : for : 	if (on_rq) : 
2
strstr : while : 	if (on_rq) : 
2
str : 		dequeue_task(rq, p, 0);[25]
strstr : INIT : 		dequeue_task(rq, p, 0); : 
2
strstr : if : 		dequeue_task(rq, p, 0); : 
2
strstr : for : 		dequeue_task(rq, p, 0); : 
2
strstr : while : 		dequeue_task(rq, p, 0); : 
2
str : 	__setscheduler(rq, p, &attr);[30]
strstr : INIT : 	__setscheduler(rq, p, &attr); : 
2
strstr : if : 	__setscheduler(rq, p, &attr); : 
2
strstr : for : 	__setscheduler(rq, p, &attr); : 
2
strstr : while : 	__setscheduler(rq, p, &attr); : 
2
str : 	if (on_rq) {[13]
strstr : INIT : 	if (on_rq) { : 
2
strstr : if : 	if (on_rq) { : 
2
strstr : for : 	if (on_rq) { : 
2
strstr : while : 	if (on_rq) { : 
2
str : 		enqueue_task(rq, p, 0);[25]
strstr : INIT : 		enqueue_task(rq, p, 0); : 
2
strstr : if : 		enqueue_task(rq, p, 0); : 
2
strstr : for : 		enqueue_task(rq, p, 0); : 
2
strstr : while : 		enqueue_task(rq, p, 0); : 
2
str : 		resched_task(rq->curr);[25]
strstr : INIT : 		resched_task(rq->curr); : 
2
strstr : if : 		resched_task(rq->curr); : 
2
strstr : for : 		resched_task(rq->curr); : 
2
strstr : while : 		resched_task(rq->curr); : 
2
str : 	check_class_changed(rq, p, prev_class, old_prio);[50]
strstr : INIT : 	check_class_changed(rq, p, prev_class, old_prio); : 
2
strstr : if : 	check_class_changed(rq, p, prev_class, old_prio); : 
2
strstr : for : 	check_class_changed(rq, p, prev_class, old_prio); : 
2
strstr : while : 	check_class_changed(rq, p, prev_class, old_prio); : 
2
str : void normalize_rt_tasks(void)[29]
strstr : INIT : void normalize_rt_tasks(void) : 
2
strstr : if : void normalize_rt_tasks(void) : 
2
strstr : for : void normalize_rt_tasks(void) : 
2
strstr : while : void normalize_rt_tasks(void) : 
2
str : 	struct task_struct *g, *p;[27]
strstr : INIT : 	struct task_struct *g, *p; : 
2
strstr : if : 	struct task_struct *g, *p; : 
2
strstr : for : 	struct task_struct *g, *p; : 
2
strstr : while : 	struct task_struct *g, *p; : 
2
str : 	unsigned long flags;[21]
strstr : INIT : 	unsigned long flags; : 
2
strstr : if : 	unsigned long flags; : 
2
strstr : for : 	unsigned long flags; : 
2
strstr : while : 	unsigned long flags; : 
2
str : 	struct rq *rq;[15]
strstr : INIT : 	struct rq *rq; : 
2
strstr : if : 	struct rq *rq; : 
2
strstr : for : 	struct rq *rq; : 
2
strstr : while : 	struct rq *rq; : 
2
str : 	read_lock_irqsave(&tasklist_lock, flags);[42]
strstr : INIT : 	read_lock_irqsave(&tasklist_lock, flags); : 
2
strstr : if : 	read_lock_irqsave(&tasklist_lock, flags); : 
2
strstr : for : 	read_lock_irqsave(&tasklist_lock, flags); : 
2
strstr : while : 	read_lock_irqsave(&tasklist_lock, flags); : 
2
str : 	do_each_thread(g, p) {[23]
strstr : INIT : 	do_each_thread(g, p) { : 
2
strstr : if : 	do_each_thread(g, p) { : 
2
strstr : for : 	do_each_thread(g, p) { : 
2
strstr : while : 	do_each_thread(g, p) { : 
2
str : 		/*[4]
strstr : INIT : 		/* : 
2
strstr : if : 		/* : 
2
strstr : for : 		/* : 
2
strstr : while : 		/* : 
2
str : 		 * Only normalize user tasks:[31]
strstr : INIT : 		 * Only normalize user tasks: : 
2
strstr : if : 		 * Only normalize user tasks: : 
2
strstr : for : 		 * Only normalize user tasks: : 
2
strstr : while : 		 * Only normalize user tasks: : 
2
str : 		 */[5]
strstr : INIT : 		 */ : 
2
strstr : if : 		 */ : 
2
strstr : for : 		 */ : 
2
strstr : while : 		 */ : 
2
str : 		if (!p->mm)[13]
strstr : INIT : 		if (!p->mm) : 
2
strstr : if : 		if (!p->mm) : 
2
strstr : for : 		if (!p->mm) : 
2
strstr : while : 		if (!p->mm) : 
2
str : 			continue;[12]
strstr : INIT : 			continue; : 
2
strstr : if : 			continue; : 
2
strstr : for : 			continue; : 
2
strstr : while : 			continue; : 
2
str : 		p->se.exec_start		= 0;[24]
strstr : INIT : 		p->se.exec_start		= 0; : 
2
strstr : if : 		p->se.exec_start		= 0; : 
2
strstr : for : 		p->se.exec_start		= 0; : 
2
strstr : while : 		p->se.exec_start		= 0; : 
2
str : #ifdef CONFIG_SCHEDSTATS[24]
strstr : INIT : #ifdef CONFIG_SCHEDSTATS : 
2
strstr : if : #ifdef CONFIG_SCHEDSTATS : 
2
strstr : for : #ifdef CONFIG_SCHEDSTATS : 
2
strstr : while : #ifdef CONFIG_SCHEDSTATS : 
2
str : 		p->se.statistics.wait_start	= 0;[34]
strstr : INIT : 		p->se.statistics.wait_start	= 0; : 
2
strstr : if : 		p->se.statistics.wait_start	= 0; : 
2
strstr : for : 		p->se.statistics.wait_start	= 0; : 
2
strstr : while : 		p->se.statistics.wait_start	= 0; : 
2
str : 		p->se.statistics.sleep_start	= 0;[35]
strstr : INIT : 		p->se.statistics.sleep_start	= 0; : 
2
strstr : if : 		p->se.statistics.sleep_start	= 0; : 
2
strstr : for : 		p->se.statistics.sleep_start	= 0; : 
2
strstr : while : 		p->se.statistics.sleep_start	= 0; : 
2
str : 		p->se.statistics.block_start	= 0;[35]
strstr : INIT : 		p->se.statistics.block_start	= 0; : 
2
strstr : if : 		p->se.statistics.block_start	= 0; : 
2
strstr : for : 		p->se.statistics.block_start	= 0; : 
2
strstr : while : 		p->se.statistics.block_start	= 0; : 
2
str : #endif[6]
strstr : INIT : #endif : 
2
strstr : if : #endif : 
2
strstr : for : #endif : 
2
strstr : while : #endif : 
2
str : 		if (!dl_task(p) && !rt_task(p)) {[35]
strstr : INIT : 		if (!dl_task(p) && !rt_task(p)) { : 
2
strstr : if : 		if (!dl_task(p) && !rt_task(p)) { : 
2
strstr : for : 		if (!dl_task(p) && !rt_task(p)) { : 
2
strstr : while : 		if (!dl_task(p) && !rt_task(p)) { : 
2
str : 			/*[5]
strstr : INIT : 			/* : 
2
strstr : if : 			/* : 
2
strstr : for : 			/* : 
2
strstr : while : 			/* : 
2
str : 			 * Renice negative nice level userspace[42]
strstr : INIT : 			 * Renice negative nice level userspace : 
2
strstr : if : 			 * Renice negative nice level userspace : 
2
strstr : for : 			 * Renice negative nice level userspace : 
2
strstr : while : 			 * Renice negative nice level userspace : 
2
str : 			 * tasks back to 0:[22]
strstr : INIT : 			 * tasks back to 0: : 
2
strstr : if : 			 * tasks back to 0: : 
2
strstr : for : 			 * tasks back to 0: : 
2
strstr : while : 			 * tasks back to 0: : 
2
str : 			 */[6]
strstr : INIT : 			 */ : 
2
strstr : if : 			 */ : 
2
strstr : for : 			 */ : 
2
strstr : while : 			 */ : 
2
str : 			if (TASK_NICE(p) < 0 && p->mm)[33]
strstr : INIT : 			if (TASK_NICE(p) < 0 && p->mm) : 
2
strstr : if : 			if (TASK_NICE(p) < 0 && p->mm) : 
2
strstr : for : 			if (TASK_NICE(p) < 0 && p->mm) : 
2
strstr : while : 			if (TASK_NICE(p) < 0 && p->mm) : 
2
str : 				set_user_nice(p, 0);[24]
strstr : INIT : 				set_user_nice(p, 0); : 
2
strstr : if : 				set_user_nice(p, 0); : 
2
strstr : for : 				set_user_nice(p, 0); : 
2
strstr : while : 				set_user_nice(p, 0); : 
2
str : 			continue;[12]
strstr : INIT : 			continue; : 
2
strstr : if : 			continue; : 
2
strstr : for : 			continue; : 
2
strstr : while : 			continue; : 
2
str : 		}[3]
strstr : INIT : 		} : 
2
strstr : if : 		} : 
2
strstr : for : 		} : 
2
strstr : while : 		} : 
2
str : 		raw_spin_lock(&p->pi_lock);[29]
strstr : INIT : 		raw_spin_lock(&p->pi_lock); : 
2
strstr : if : 		raw_spin_lock(&p->pi_lock); : 
2
strstr : for : 		raw_spin_lock(&p->pi_lock); : 
2
strstr : while : 		raw_spin_lock(&p->pi_lock); : 
2
str : 		rq = __task_rq_lock(p);[25]
strstr : INIT : 		rq = __task_rq_lock(p); : 
2
strstr : if : 		rq = __task_rq_lock(p); : 
2
strstr : for : 		rq = __task_rq_lock(p); : 
2
strstr : while : 		rq = __task_rq_lock(p); : 
2
str : 		normalize_task(rq, p);[24]
strstr : INIT : 		normalize_task(rq, p); : 
2
strstr : if : 		normalize_task(rq, p); : 
2
strstr : for : 		normalize_task(rq, p); : 
2
strstr : while : 		normalize_task(rq, p); : 
2
str : 		__task_rq_unlock(rq);[23]
strstr : INIT : 		__task_rq_unlock(rq); : 
2
strstr : if : 		__task_rq_unlock(rq); : 
2
strstr : for : 		__task_rq_unlock(rq); : 
2
strstr : while : 		__task_rq_unlock(rq); : 
2
str : 		raw_spin_unlock(&p->pi_lock);[31]
strstr : INIT : 		raw_spin_unlock(&p->pi_lock); : 
2
strstr : if : 		raw_spin_unlock(&p->pi_lock); : 
2
strstr : for : 		raw_spin_unlock(&p->pi_lock); : 
2
strstr : while : 		raw_spin_unlock(&p->pi_lock); : 
2
str : 	} while_each_thread(g, p);[27]
strstr : INIT : 	} while_each_thread(g, p); : 
2
strstr : if : 	} while_each_thread(g, p); : 
2
strstr : for : 	} while_each_thread(g, p); : 
2
strstr : while : 	} while_each_thread(g, p); : 
2
str : 	read_unlock_irqrestore(&tasklist_lock, flags);[47]
strstr : INIT : 	read_unlock_irqrestore(&tasklist_lock, flags); : 
2
strstr : if : 	read_unlock_irqrestore(&tasklist_lock, flags); : 
2
strstr : for : 	read_unlock_irqrestore(&tasklist_lock, flags); : 
2
strstr : while : 	read_unlock_irqrestore(&tasklist_lock, flags); : 
2
str : #endif /* CONFIG_MAGIC_SYSRQ */[31]
strstr : INIT : #endif /* CONFIG_MAGIC_SYSRQ */ : 
2
strstr : if : #endif /* CONFIG_MAGIC_SYSRQ */ : 
2
strstr : for : #endif /* CONFIG_MAGIC_SYSRQ */ : 
2
strstr : while : #endif /* CONFIG_MAGIC_SYSRQ */ : 
2
str : #if defined(CONFIG_IA64) || defined(CONFIG_KGDB_KDB)[52]
strstr : INIT : #if defined(CONFIG_IA64) || defined(CONFIG_KGDB_KDB) : 
2
strstr : if : #if defined(CONFIG_IA64) || defined(CONFIG_KGDB_KDB) : 
2
strstr : for : #if defined(CONFIG_IA64) || defined(CONFIG_KGDB_KDB) : 
2
strstr : while : #if defined(CONFIG_IA64) || defined(CONFIG_KGDB_KDB) : 
2
str :  * These functions are only useful for the IA64 MCA handling, or kdb.[69]
strstr : INIT :  * These functions are only useful for the IA64 MCA handling, or kdb. : 
2
strstr : if :  * These functions are only useful for the IA64 MCA handling, or kdb. : 
2
strstr : for :  * These functions are only useful for the IA64 MCA handling, or kdb. : 
2
strstr : while :  * These functions are only useful for the IA64 MCA handling, or kdb. : 
2
str :  * They can only be called when the whole system has been[57]
strstr : INIT :  * They can only be called when the whole system has been : 
2
strstr : if :  * They can only be called when the whole system has been : 
2
strstr : for :  * They can only be called when the whole system has been : 
2
strstr : while :  * They can only be called when the whole system has been : 
2
str :  * stopped - every CPU needs to be quiescent, and no scheduling[63]
strstr : INIT :  * stopped - every CPU needs to be quiescent, and no scheduling : 
2
strstr : if :  * stopped - every CPU needs to be quiescent, and no scheduling : 
2
strstr : for :  * stopped - every CPU needs to be quiescent, and no scheduling : 
2
strstr : while :  * stopped - every CPU needs to be quiescent, and no scheduling : 
2
str :  * activity can take place. Using them for anything else would[62]
strstr : INIT :  * activity can take place. Using them for anything else would : 
2
strstr : if :  * activity can take place. Using them for anything else would : 
2
strstr : for :  * activity can take place. Using them for anything else would : 
2
strstr : while :  * activity can take place. Using them for anything else would : 
2
str :  * be a serious bug, and as a result, they aren't even visible[62]
strstr : INIT :  * be a serious bug, and as a result, they aren't even visible : 
2
strstr : if :  * be a serious bug, and as a result, they aren't even visible : 
2
strstr : for :  * be a serious bug, and as a result, they aren't even visible : 
2
strstr : while :  * be a serious bug, and as a result, they aren't even visible : 
2
str :  * under any other configuration.[33]
strstr : INIT :  * under any other configuration. : 
2
strstr : if :  * under any other configuration. : 
2
strstr : for :  * under any other configuration. : 
2
strstr : while :  * under any other configuration. : 
2
str :  */[3]
strstr : INIT :  */ : 
2
strstr : if :  */ : 
2
strstr : for :  */ : 
2
strstr : while :  */ : 
2
str : /**[3]
strstr : INIT : /** : 
2
strstr : if : /** : 
2
strstr : for : /** : 
2
strstr : while : /** : 
2
str :  * curr_task - return the current task for a given cpu.[55]
strstr : INIT :  * curr_task - return the current task for a given cpu. : 
2
strstr : if :  * curr_task - return the current task for a given cpu. : 
2
strstr : for :  * curr_task - return the current task for a given cpu. : 
2
strstr : while :  * curr_task - return the current task for a given cpu. : 
2
str :  * @cpu: the processor in question.[35]
strstr : INIT :  * @cpu: the processor in question. : 
2
strstr : if :  * @cpu: the processor in question. : 
2
strstr : for :  * @cpu: the processor in question. : 
2
strstr : while :  * @cpu: the processor in question. : 
2
str :  * ONLY VALID WHEN THE WHOLE SYSTEM IS STOPPED![47]
strstr : INIT :  * ONLY VALID WHEN THE WHOLE SYSTEM IS STOPPED! : 
2
strstr : if :  * ONLY VALID WHEN THE WHOLE SYSTEM IS STOPPED! : 
2
strstr : for :  * ONLY VALID WHEN THE WHOLE SYSTEM IS STOPPED! : 
2
strstr : while :  * ONLY VALID WHEN THE WHOLE SYSTEM IS STOPPED! : 
2
str :  * Return: The current task for @cpu.[37]
strstr : INIT :  * Return: The current task for @cpu. : 
2
strstr : if :  * Return: The current task for @cpu. : 
2
strstr : for :  * Return: The current task for @cpu. : 
2
strstr : while :  * Return: The current task for @cpu. : 
2
str :  */[3]
strstr : INIT :  */ : 
2
strstr : if :  */ : 
2
strstr : for :  */ : 
2
strstr : while :  */ : 
2
str : struct task_struct *curr_task(int cpu)[38]
strstr : INIT : struct task_struct *curr_task(int cpu) : 
2
strstr : if : struct task_struct *curr_task(int cpu) : 
2
strstr : for : struct task_struct *curr_task(int cpu) : 
2
strstr : while : struct task_struct *curr_task(int cpu) : 
2
str : 	return cpu_curr(cpu);[22]
strstr : INIT : 	return cpu_curr(cpu); : 
2
strstr : if : 	return cpu_curr(cpu); : 
2
strstr : for : 	return cpu_curr(cpu); : 
2
strstr : while : 	return cpu_curr(cpu); : 
2
str : #endif /* defined(CONFIG_IA64) || defined(CONFIG_KGDB_KDB) */[61]
strstr : INIT : #endif /* defined(CONFIG_IA64) || defined(CONFIG_KGDB_KDB) */ : 
2
strstr : if : #endif /* defined(CONFIG_IA64) || defined(CONFIG_KGDB_KDB) */ : 
2
strstr : for : #endif /* defined(CONFIG_IA64) || defined(CONFIG_KGDB_KDB) */ : 
2
strstr : while : #endif /* defined(CONFIG_IA64) || defined(CONFIG_KGDB_KDB) */ : 
2
str : #ifdef CONFIG_IA64[18]
strstr : INIT : #ifdef CONFIG_IA64 : 
2
strstr : if : #ifdef CONFIG_IA64 : 
2
strstr : for : #ifdef CONFIG_IA64 : 
2
strstr : while : #ifdef CONFIG_IA64 : 
2
str : /**[3]
strstr : INIT : /** : 
2
strstr : if : /** : 
2
strstr : for : /** : 
2
strstr : while : /** : 
2
str :  * set_curr_task - set the current task for a given cpu.[56]
strstr : INIT :  * set_curr_task - set the current task for a given cpu. : 
2
strstr : if :  * set_curr_task - set the current task for a given cpu. : 
2
strstr : for :  * set_curr_task - set the current task for a given cpu. : 
2
strstr : while :  * set_curr_task - set the current task for a given cpu. : 
2
str :  * @cpu: the processor in question.[35]
strstr : INIT :  * @cpu: the processor in question. : 
2
strstr : if :  * @cpu: the processor in question. : 
2
strstr : for :  * @cpu: the processor in question. : 
2
strstr : while :  * @cpu: the processor in question. : 
2
str :  * @p: the task pointer to set.[31]
strstr : INIT :  * @p: the task pointer to set. : 
2
strstr : if :  * @p: the task pointer to set. : 
2
strstr : for :  * @p: the task pointer to set. : 
2
strstr : while :  * @p: the task pointer to set. : 
2
str :  * Description: This function must only be used when non-maskable interrupts[76]
strstr : INIT :  * Description: This function must only be used when non-maskable interrupts : 
2
strstr : if :  * Description: This function must only be used when non-maskable interrupts : 
2
strstr : for :  * Description: This function must only be used when non-maskable interrupts : 
2
strstr : while :  * Description: This function must only be used when non-maskable interrupts : 
2
str :  * are serviced on a separate stack. It allows the architecture to switch the[77]
strstr : INIT :  * are serviced on a separate stack. It allows the architecture to switch the : 
2
strstr : if :  * are serviced on a separate stack. It allows the architecture to switch the : 
2
strstr : for :  * are serviced on a separate stack. It allows the architecture to switch the : 
2
strstr : while :  * are serviced on a separate stack. It allows the architecture to switch the : 
2
str :  * notion of the current task on a cpu in a non-blocking manner. This function[78]
strstr : INIT :  * notion of the current task on a cpu in a non-blocking manner. This function : 
2
strstr : if :  * notion of the current task on a cpu in a non-blocking manner. This function : 
2
strstr : for :  * notion of the current task on a cpu in a non-blocking manner. This function : 
2
strstr : while :  * notion of the current task on a cpu in a non-blocking manner. This function : 
2
str :  * must be called with all CPU's synchronized, and interrupts disabled, the[75]
strstr : INIT :  * must be called with all CPU's synchronized, and interrupts disabled, the : 
2
strstr : if :  * must be called with all CPU's synchronized, and interrupts disabled, the : 
2
strstr : for :  * must be called with all CPU's synchronized, and interrupts disabled, the : 
2
strstr : while :  * must be called with all CPU's synchronized, and interrupts disabled, the : 
2
str :  * and caller must save the original value of the current task (see[67]
strstr : INIT :  * and caller must save the original value of the current task (see : 
2
strstr : if :  * and caller must save the original value of the current task (see : 
2
strstr : for :  * and caller must save the original value of the current task (see : 
2
strstr : while :  * and caller must save the original value of the current task (see : 
2
str :  * curr_task() above) and restore that value before reenabling interrupts and[77]
strstr : INIT :  * curr_task() above) and restore that value before reenabling interrupts and : 
2
strstr : if :  * curr_task() above) and restore that value before reenabling interrupts and : 
2
strstr : for :  * curr_task() above) and restore that value before reenabling interrupts and : 
2
strstr : while :  * curr_task() above) and restore that value before reenabling interrupts and : 
2
str :  * re-starting the system.[26]
strstr : INIT :  * re-starting the system. : 
2
strstr : if :  * re-starting the system. : 
2
strstr : for :  * re-starting the system. : 
2
strstr : while :  * re-starting the system. : 
2
str :  * ONLY VALID WHEN THE WHOLE SYSTEM IS STOPPED![47]
strstr : INIT :  * ONLY VALID WHEN THE WHOLE SYSTEM IS STOPPED! : 
2
strstr : if :  * ONLY VALID WHEN THE WHOLE SYSTEM IS STOPPED! : 
2
strstr : for :  * ONLY VALID WHEN THE WHOLE SYSTEM IS STOPPED! : 
2
strstr : while :  * ONLY VALID WHEN THE WHOLE SYSTEM IS STOPPED! : 
2
str :  */[3]
strstr : INIT :  */ : 
2
strstr : if :  */ : 
2
strstr : for :  */ : 
2
strstr : while :  */ : 
2
str : void set_curr_task(int cpu, struct task_struct *p)[50]
strstr : INIT : void set_curr_task(int cpu, struct task_struct *p) : 
2
strstr : if : void set_curr_task(int cpu, struct task_struct *p) : 
2
strstr : for : void set_curr_task(int cpu, struct task_struct *p) : 
2
strstr : while : void set_curr_task(int cpu, struct task_struct *p) : 
2
str : 	cpu_curr(cpu) = p;[19]
strstr : INIT : 	cpu_curr(cpu) = p; : 
2
strstr : if : 	cpu_curr(cpu) = p; : 
2
strstr : for : 	cpu_curr(cpu) = p; : 
2
strstr : while : 	cpu_curr(cpu) = p; : 
2
str : #endif[6]
strstr : INIT : #endif : 
2
strstr : if : #endif : 
2
strstr : for : #endif : 
2
strstr : while : #endif : 
2
str : #ifdef CONFIG_CGROUP_SCHED[26]
strstr : INIT : #ifdef CONFIG_CGROUP_SCHED : 
2
strstr : if : #ifdef CONFIG_CGROUP_SCHED : 
2
strstr : for : #ifdef CONFIG_CGROUP_SCHED : 
2
strstr : while : #ifdef CONFIG_CGROUP_SCHED : 
2
str : /* task_group_lock serializes the addition/removal of task groups */[68]
strstr : INIT : /* task_group_lock serializes the addition/removal of task groups */ : 
2
strstr : if : /* task_group_lock serializes the addition/removal of task groups */ : 
2
strstr : for : /* task_group_lock serializes the addition/removal of task groups */ : 
2
strstr : while : /* task_group_lock serializes the addition/removal of task groups */ : 
2
str : static DEFINE_SPINLOCK(task_group_lock);[40]
strstr : INIT : static DEFINE_SPINLOCK(task_group_lock); : 
2
strstr : if : static DEFINE_SPINLOCK(task_group_lock); : 
2
strstr : for : static DEFINE_SPINLOCK(task_group_lock); : 
2
strstr : while : static DEFINE_SPINLOCK(task_group_lock); : 
2
str : static void free_sched_group(struct task_group *tg)[51]
strstr : INIT : static void free_sched_group(struct task_group *tg) : 
2
strstr : if : static void free_sched_group(struct task_group *tg) : 
2
strstr : for : static void free_sched_group(struct task_group *tg) : 
2
strstr : while : static void free_sched_group(struct task_group *tg) : 
2
str : 	free_fair_sched_group(tg);[27]
strstr : INIT : 	free_fair_sched_group(tg); : 
2
strstr : if : 	free_fair_sched_group(tg); : 
2
strstr : for : 	free_fair_sched_group(tg); : 
2
strstr : while : 	free_fair_sched_group(tg); : 
2
str : 	free_rt_sched_group(tg);[25]
strstr : INIT : 	free_rt_sched_group(tg); : 
2
strstr : if : 	free_rt_sched_group(tg); : 
2
strstr : for : 	free_rt_sched_group(tg); : 
2
strstr : while : 	free_rt_sched_group(tg); : 
2
str : 	autogroup_free(tg);[20]
strstr : INIT : 	autogroup_free(tg); : 
2
strstr : if : 	autogroup_free(tg); : 
2
strstr : for : 	autogroup_free(tg); : 
2
strstr : while : 	autogroup_free(tg); : 
2
str : 	kfree(tg);[11]
strstr : INIT : 	kfree(tg); : 
2
strstr : if : 	kfree(tg); : 
2
strstr : for : 	kfree(tg); : 
2
strstr : while : 	kfree(tg); : 
2
str : /* allocate runqueue etc for a new task group */[48]
strstr : INIT : /* allocate runqueue etc for a new task group */ : 
2
strstr : if : /* allocate runqueue etc for a new task group */ : 
2
strstr : for : /* allocate runqueue etc for a new task group */ : 
2
strstr : while : /* allocate runqueue etc for a new task group */ : 
2
str : struct task_group *sched_create_group(struct task_group *parent)[64]
strstr : INIT : struct task_group *sched_create_group(struct task_group *parent) : 
2
strstr : if : struct task_group *sched_create_group(struct task_group *parent) : 
2
strstr : for : struct task_group *sched_create_group(struct task_group *parent) : 
2
strstr : while : struct task_group *sched_create_group(struct task_group *parent) : 
2
str : 	struct task_group *tg;[23]
strstr : INIT : 	struct task_group *tg; : 
2
strstr : if : 	struct task_group *tg; : 
2
strstr : for : 	struct task_group *tg; : 
2
strstr : while : 	struct task_group *tg; : 
2
str : 	tg = kzalloc(sizeof(*tg), GFP_KERNEL);[39]
strstr : INIT : 	tg = kzalloc(sizeof(*tg), GFP_KERNEL); : 
2
strstr : if : 	tg = kzalloc(sizeof(*tg), GFP_KERNEL); : 
2
strstr : for : 	tg = kzalloc(sizeof(*tg), GFP_KERNEL); : 
2
strstr : while : 	tg = kzalloc(sizeof(*tg), GFP_KERNEL); : 
2
str : 	if (!tg)[9]
strstr : INIT : 	if (!tg) : 
2
strstr : if : 	if (!tg) : 
2
strstr : for : 	if (!tg) : 
2
strstr : while : 	if (!tg) : 
2
str : 		return ERR_PTR(-ENOMEM);[26]
strstr : INIT : 		return ERR_PTR(-ENOMEM); : 
2
strstr : if : 		return ERR_PTR(-ENOMEM); : 
2
strstr : for : 		return ERR_PTR(-ENOMEM); : 
2
strstr : while : 		return ERR_PTR(-ENOMEM); : 
2
str : 	if (!alloc_fair_sched_group(tg, parent))[41]
strstr : INIT : 	if (!alloc_fair_sched_group(tg, parent)) : 
2
strstr : if : 	if (!alloc_fair_sched_group(tg, parent)) : 
2
strstr : for : 	if (!alloc_fair_sched_group(tg, parent)) : 
2
strstr : while : 	if (!alloc_fair_sched_group(tg, parent)) : 
2
str : 		goto err;[11]
strstr : INIT : 		goto err; : 
2
strstr : if : 		goto err; : 
2
strstr : for : 		goto err; : 
2
strstr : while : 		goto err; : 
2
str : 	if (!alloc_rt_sched_group(tg, parent))[39]
strstr : INIT : 	if (!alloc_rt_sched_group(tg, parent)) : 
2
strstr : if : 	if (!alloc_rt_sched_group(tg, parent)) : 
2
strstr : for : 	if (!alloc_rt_sched_group(tg, parent)) : 
2
strstr : while : 	if (!alloc_rt_sched_group(tg, parent)) : 
2
str : 		goto err;[11]
strstr : INIT : 		goto err; : 
2
strstr : if : 		goto err; : 
2
strstr : for : 		goto err; : 
2
strstr : while : 		goto err; : 
2
str : 	return tg;[11]
strstr : INIT : 	return tg; : 
2
strstr : if : 	return tg; : 
2
strstr : for : 	return tg; : 
2
strstr : while : 	return tg; : 
2
str : err:[4]
strstr : INIT : err: : 
2
strstr : if : err: : 
2
strstr : for : err: : 
2
strstr : while : err: : 
2
str : 	free_sched_group(tg);[22]
strstr : INIT : 	free_sched_group(tg); : 
2
strstr : if : 	free_sched_group(tg); : 
2
strstr : for : 	free_sched_group(tg); : 
2
strstr : while : 	free_sched_group(tg); : 
2
str : 	return ERR_PTR(-ENOMEM);[25]
strstr : INIT : 	return ERR_PTR(-ENOMEM); : 
2
strstr : if : 	return ERR_PTR(-ENOMEM); : 
2
strstr : for : 	return ERR_PTR(-ENOMEM); : 
2
strstr : while : 	return ERR_PTR(-ENOMEM); : 
2
str : void sched_online_group(struct task_group *tg, struct task_group *parent)[73]
strstr : INIT : void sched_online_group(struct task_group *tg, struct task_group *parent) : 
2
strstr : if : void sched_online_group(struct task_group *tg, struct task_group *parent) : 
2
strstr : for : void sched_online_group(struct task_group *tg, struct task_group *parent) : 
2
strstr : while : void sched_online_group(struct task_group *tg, struct task_group *parent) : 
2
str : 	unsigned long flags;[21]
strstr : INIT : 	unsigned long flags; : 
2
strstr : if : 	unsigned long flags; : 
2
strstr : for : 	unsigned long flags; : 
2
strstr : while : 	unsigned long flags; : 
2
str : 	spin_lock_irqsave(&task_group_lock, flags);[44]
strstr : INIT : 	spin_lock_irqsave(&task_group_lock, flags); : 
2
strstr : if : 	spin_lock_irqsave(&task_group_lock, flags); : 
2
strstr : for : 	spin_lock_irqsave(&task_group_lock, flags); : 
2
strstr : while : 	spin_lock_irqsave(&task_group_lock, flags); : 
2
str : 	list_add_rcu(&tg->list, &task_groups);[39]
strstr : INIT : 	list_add_rcu(&tg->list, &task_groups); : 
2
strstr : if : 	list_add_rcu(&tg->list, &task_groups); : 
2
strstr : for : 	list_add_rcu(&tg->list, &task_groups); : 
2
strstr : while : 	list_add_rcu(&tg->list, &task_groups); : 
2
str : 	WARN_ON(!parent); /* root should already exist */[50]
strstr : INIT : 	WARN_ON(!parent); /* root should already exist */ : 
2
strstr : if : 	WARN_ON(!parent); /* root should already exist */ : 
2
strstr : for : 	WARN_ON(!parent); /* root should already exist */ : 
2
strstr : while : 	WARN_ON(!parent); /* root should already exist */ : 
2
str : 	tg->parent = parent;[21]
strstr : INIT : 	tg->parent = parent; : 
2
strstr : if : 	tg->parent = parent; : 
2
strstr : for : 	tg->parent = parent; : 
2
strstr : while : 	tg->parent = parent; : 
2
str : 	INIT_LIST_HEAD(&tg->children);[31]
strstr : INIT : 	INIT_LIST_HEAD(&tg->children); : 
2
strstr : if : 	INIT_LIST_HEAD(&tg->children); : 
2
strstr : for : 	INIT_LIST_HEAD(&tg->children); : 
2
strstr : while : 	INIT_LIST_HEAD(&tg->children); : 
2
str : 	list_add_rcu(&tg->siblings, &parent->children);[48]
strstr : INIT : 	list_add_rcu(&tg->siblings, &parent->children); : 
2
strstr : if : 	list_add_rcu(&tg->siblings, &parent->children); : 
2
strstr : for : 	list_add_rcu(&tg->siblings, &parent->children); : 
2
strstr : while : 	list_add_rcu(&tg->siblings, &parent->children); : 
2
str : 	spin_unlock_irqrestore(&task_group_lock, flags);[49]
strstr : INIT : 	spin_unlock_irqrestore(&task_group_lock, flags); : 
2
strstr : if : 	spin_unlock_irqrestore(&task_group_lock, flags); : 
2
strstr : for : 	spin_unlock_irqrestore(&task_group_lock, flags); : 
2
strstr : while : 	spin_unlock_irqrestore(&task_group_lock, flags); : 
2
str : /* rcu callback to free various structures associated with a task group */[74]
strstr : INIT : /* rcu callback to free various structures associated with a task group */ : 
2
strstr : if : /* rcu callback to free various structures associated with a task group */ : 
2
strstr : for : /* rcu callback to free various structures associated with a task group */ : 
2
strstr : while : /* rcu callback to free various structures associated with a task group */ : 
2
str : static void free_sched_group_rcu(struct rcu_head *rhp)[54]
strstr : INIT : static void free_sched_group_rcu(struct rcu_head *rhp) : 
2
strstr : if : static void free_sched_group_rcu(struct rcu_head *rhp) : 
2
strstr : for : static void free_sched_group_rcu(struct rcu_head *rhp) : 
2
strstr : while : static void free_sched_group_rcu(struct rcu_head *rhp) : 
2
str : 	/* now it should be safe to free those cfs_rqs */[50]
strstr : INIT : 	/* now it should be safe to free those cfs_rqs */ : 
2
strstr : if : 	/* now it should be safe to free those cfs_rqs */ : 
2
strstr : for : 	/* now it should be safe to free those cfs_rqs */ : 
2
strstr : while : 	/* now it should be safe to free those cfs_rqs */ : 
2
str : 	free_sched_group(container_of(rhp, struct task_group, rcu));[61]
strstr : INIT : 	free_sched_group(container_of(rhp, struct task_group, rcu)); : 
2
strstr : if : 	free_sched_group(container_of(rhp, struct task_group, rcu)); : 
2
strstr : for : 	free_sched_group(container_of(rhp, struct task_group, rcu)); : 
2
strstr : while : 	free_sched_group(container_of(rhp, struct task_group, rcu)); : 
2
str : /* Destroy runqueue etc associated with a task group */[55]
strstr : INIT : /* Destroy runqueue etc associated with a task group */ : 
2
strstr : if : /* Destroy runqueue etc associated with a task group */ : 
2
strstr : for : /* Destroy runqueue etc associated with a task group */ : 
2
strstr : while : /* Destroy runqueue etc associated with a task group */ : 
2
str : void sched_destroy_group(struct task_group *tg)[47]
strstr : INIT : void sched_destroy_group(struct task_group *tg) : 
2
strstr : if : void sched_destroy_group(struct task_group *tg) : 
2
strstr : for : void sched_destroy_group(struct task_group *tg) : 
2
strstr : while : void sched_destroy_group(struct task_group *tg) : 
2
str : 	/* wait for possible concurrent references to cfs_rqs complete */[66]
strstr : INIT : 	/* wait for possible concurrent references to cfs_rqs complete */ : 
2
strstr : if : 	/* wait for possible concurrent references to cfs_rqs complete */ : 
2
strstr : for : 	/* wait for possible concurrent references to cfs_rqs complete */ : 
2
strstr : while : 	/* wait for possible concurrent references to cfs_rqs complete */ : 
2
str : 	call_rcu(&tg->rcu, free_sched_group_rcu);[42]
strstr : INIT : 	call_rcu(&tg->rcu, free_sched_group_rcu); : 
2
strstr : if : 	call_rcu(&tg->rcu, free_sched_group_rcu); : 
2
strstr : for : 	call_rcu(&tg->rcu, free_sched_group_rcu); : 
2
strstr : while : 	call_rcu(&tg->rcu, free_sched_group_rcu); : 
2
str : void sched_offline_group(struct task_group *tg)[47]
strstr : INIT : void sched_offline_group(struct task_group *tg) : 
2
strstr : if : void sched_offline_group(struct task_group *tg) : 
2
strstr : for : void sched_offline_group(struct task_group *tg) : 
2
strstr : while : void sched_offline_group(struct task_group *tg) : 
2
str : 	unsigned long flags;[21]
strstr : INIT : 	unsigned long flags; : 
2
strstr : if : 	unsigned long flags; : 
2
strstr : for : 	unsigned long flags; : 
2
strstr : while : 	unsigned long flags; : 
2
str : 	int i;[7]
strstr : INIT : 	int i; : 
2
strstr : if : 	int i; : 
2
strstr : for : 	int i; : 
2
strstr : while : 	int i; : 
2
str : 	/* end participation in shares distribution */[47]
strstr : INIT : 	/* end participation in shares distribution */ : 
2
strstr : if : 	/* end participation in shares distribution */ : 
2
strstr : for : 	/* end participation in shares distribution */ : 
2
strstr : while : 	/* end participation in shares distribution */ : 
2
str : 	for_each_possible_cpu(i)[25]
strstr : INIT : 	for_each_possible_cpu(i) : 
2
strstr : if : 	for_each_possible_cpu(i) : 
2
strstr : for : 	for_each_possible_cpu(i) : 
2
strstr : while : 	for_each_possible_cpu(i) : 
2
str : 		unregister_fair_sched_group(tg, i);[37]
strstr : INIT : 		unregister_fair_sched_group(tg, i); : 
2
strstr : if : 		unregister_fair_sched_group(tg, i); : 
2
strstr : for : 		unregister_fair_sched_group(tg, i); : 
2
strstr : while : 		unregister_fair_sched_group(tg, i); : 
2
str : 	spin_lock_irqsave(&task_group_lock, flags);[44]
strstr : INIT : 	spin_lock_irqsave(&task_group_lock, flags); : 
2
strstr : if : 	spin_lock_irqsave(&task_group_lock, flags); : 
2
strstr : for : 	spin_lock_irqsave(&task_group_lock, flags); : 
2
strstr : while : 	spin_lock_irqsave(&task_group_lock, flags); : 
2
str : 	list_del_rcu(&tg->list);[25]
strstr : INIT : 	list_del_rcu(&tg->list); : 
2
strstr : if : 	list_del_rcu(&tg->list); : 
2
strstr : for : 	list_del_rcu(&tg->list); : 
2
strstr : while : 	list_del_rcu(&tg->list); : 
2
str : 	list_del_rcu(&tg->siblings);[29]
strstr : INIT : 	list_del_rcu(&tg->siblings); : 
2
strstr : if : 	list_del_rcu(&tg->siblings); : 
2
strstr : for : 	list_del_rcu(&tg->siblings); : 
2
strstr : while : 	list_del_rcu(&tg->siblings); : 
2
str : 	spin_unlock_irqrestore(&task_group_lock, flags);[49]
strstr : INIT : 	spin_unlock_irqrestore(&task_group_lock, flags); : 
2
strstr : if : 	spin_unlock_irqrestore(&task_group_lock, flags); : 
2
strstr : for : 	spin_unlock_irqrestore(&task_group_lock, flags); : 
2
strstr : while : 	spin_unlock_irqrestore(&task_group_lock, flags); : 
2
str : /* change task's runqueue when it moves between groups.[55]
strstr : INIT : /* change task's runqueue when it moves between groups. : 
2
strstr : if : /* change task's runqueue when it moves between groups. : 
2
strstr : for : /* change task's runqueue when it moves between groups. : 
2
strstr : while : /* change task's runqueue when it moves between groups. : 
2
str :  *	The caller of this function should have put the task in its new group[72]
strstr : INIT :  *	The caller of this function should have put the task in its new group : 
2
strstr : if :  *	The caller of this function should have put the task in its new group : 
2
strstr : for :  *	The caller of this function should have put the task in its new group : 
2
strstr : while :  *	The caller of this function should have put the task in its new group : 
2
str :  *	by now. This function just updates tsk->se.cfs_rq and tsk->se.parent to[74]
strstr : INIT :  *	by now. This function just updates tsk->se.cfs_rq and tsk->se.parent to : 
2
strstr : if :  *	by now. This function just updates tsk->se.cfs_rq and tsk->se.parent to : 
2
strstr : for :  *	by now. This function just updates tsk->se.cfs_rq and tsk->se.parent to : 
2
strstr : while :  *	by now. This function just updates tsk->se.cfs_rq and tsk->se.parent to : 
2
str :  *	reflect its new group.[25]
strstr : INIT :  *	reflect its new group. : 
2
strstr : if :  *	reflect its new group. : 
2
strstr : for :  *	reflect its new group. : 
2
strstr : while :  *	reflect its new group. : 
2
str :  */[3]
strstr : INIT :  */ : 
2
strstr : if :  */ : 
2
strstr : for :  */ : 
2
strstr : while :  */ : 
2
str : void sched_move_task(struct task_struct *tsk)[45]
strstr : INIT : void sched_move_task(struct task_struct *tsk) : 
2
strstr : if : void sched_move_task(struct task_struct *tsk) : 
2
strstr : for : void sched_move_task(struct task_struct *tsk) : 
2
strstr : while : void sched_move_task(struct task_struct *tsk) : 
2
str : 	struct task_group *tg;[23]
strstr : INIT : 	struct task_group *tg; : 
2
strstr : if : 	struct task_group *tg; : 
2
strstr : for : 	struct task_group *tg; : 
2
strstr : while : 	struct task_group *tg; : 
2
str : 	int on_rq, running;[20]
strstr : INIT : 	int on_rq, running; : 
2
strstr : if : 	int on_rq, running; : 
2
strstr : for : 	int on_rq, running; : 
2
strstr : while : 	int on_rq, running; : 
2
str : 	unsigned long flags;[21]
strstr : INIT : 	unsigned long flags; : 
2
strstr : if : 	unsigned long flags; : 
2
strstr : for : 	unsigned long flags; : 
2
strstr : while : 	unsigned long flags; : 
2
str : 	struct rq *rq;[15]
strstr : INIT : 	struct rq *rq; : 
2
strstr : if : 	struct rq *rq; : 
2
strstr : for : 	struct rq *rq; : 
2
strstr : while : 	struct rq *rq; : 
2
str : 	rq = task_rq_lock(tsk, &flags);[32]
strstr : INIT : 	rq = task_rq_lock(tsk, &flags); : 
2
strstr : if : 	rq = task_rq_lock(tsk, &flags); : 
2
strstr : for : 	rq = task_rq_lock(tsk, &flags); : 
2
strstr : while : 	rq = task_rq_lock(tsk, &flags); : 
2
str : 	running = task_current(rq, tsk);[33]
strstr : INIT : 	running = task_current(rq, tsk); : 
2
strstr : if : 	running = task_current(rq, tsk); : 
2
strstr : for : 	running = task_current(rq, tsk); : 
2
strstr : while : 	running = task_current(rq, tsk); : 
2
str : 	on_rq = tsk->on_rq;[20]
strstr : INIT : 	on_rq = tsk->on_rq; : 
2
strstr : if : 	on_rq = tsk->on_rq; : 
2
strstr : for : 	on_rq = tsk->on_rq; : 
2
strstr : while : 	on_rq = tsk->on_rq; : 
2
str : 	if (on_rq)[11]
strstr : INIT : 	if (on_rq) : 
2
strstr : if : 	if (on_rq) : 
2
strstr : for : 	if (on_rq) : 
2
strstr : while : 	if (on_rq) : 
2
str : 		dequeue_task(rq, tsk, 0);[27]
strstr : INIT : 		dequeue_task(rq, tsk, 0); : 
2
strstr : if : 		dequeue_task(rq, tsk, 0); : 
2
strstr : for : 		dequeue_task(rq, tsk, 0); : 
2
strstr : while : 		dequeue_task(rq, tsk, 0); : 
2
str : 	if (unlikely(running))[23]
strstr : INIT : 	if (unlikely(running)) : 
2
strstr : if : 	if (unlikely(running)) : 
2
strstr : for : 	if (unlikely(running)) : 
2
strstr : while : 	if (unlikely(running)) : 
2
str : 		tsk->sched_class->put_prev_task(rq, tsk);[43]
strstr : INIT : 		tsk->sched_class->put_prev_task(rq, tsk); : 
2
strstr : if : 		tsk->sched_class->put_prev_task(rq, tsk); : 
2
strstr : for : 		tsk->sched_class->put_prev_task(rq, tsk); : 
2
strstr : while : 		tsk->sched_class->put_prev_task(rq, tsk); : 
2
str : 	tg = container_of(task_css_check(tsk, cpu_cgroup_subsys_id,[60]
strstr : INIT : 	tg = container_of(task_css_check(tsk, cpu_cgroup_subsys_id, : 
2
strstr : if : 	tg = container_of(task_css_check(tsk, cpu_cgroup_subsys_id, : 
2
strstr : for : 	tg = container_of(task_css_check(tsk, cpu_cgroup_subsys_id, : 
2
strstr : while : 	tg = container_of(task_css_check(tsk, cpu_cgroup_subsys_id, : 
2
str : 				lockdep_is_held(&tsk->sighand->siglock)),[45]
strstr : INIT : 				lockdep_is_held(&tsk->sighand->siglock)), : 
2
strstr : if : 				lockdep_is_held(&tsk->sighand->siglock)), : 
2
strstr : for : 				lockdep_is_held(&tsk->sighand->siglock)), : 
2
strstr : while : 				lockdep_is_held(&tsk->sighand->siglock)), : 
2
str : 			  struct task_group, css);[29]
strstr : INIT : 			  struct task_group, css); : 
2
strstr : if : 			  struct task_group, css); : 
2
strstr : for : 			  struct task_group, css); : 
2
strstr : while : 			  struct task_group, css); : 
2
str : 	tg = autogroup_task_group(tsk, tg);[36]
strstr : INIT : 	tg = autogroup_task_group(tsk, tg); : 
2
strstr : if : 	tg = autogroup_task_group(tsk, tg); : 
2
strstr : for : 	tg = autogroup_task_group(tsk, tg); : 
2
strstr : while : 	tg = autogroup_task_group(tsk, tg); : 
2
str : 	tsk->sched_task_group = tg;[28]
strstr : INIT : 	tsk->sched_task_group = tg; : 
2
strstr : if : 	tsk->sched_task_group = tg; : 
2
strstr : for : 	tsk->sched_task_group = tg; : 
2
strstr : while : 	tsk->sched_task_group = tg; : 
2
str : #ifdef CONFIG_FAIR_GROUP_SCHED[30]
strstr : INIT : #ifdef CONFIG_FAIR_GROUP_SCHED : 
2
strstr : if : #ifdef CONFIG_FAIR_GROUP_SCHED : 
2
strstr : for : #ifdef CONFIG_FAIR_GROUP_SCHED : 
2
strstr : while : #ifdef CONFIG_FAIR_GROUP_SCHED : 
2
str : 	if (tsk->sched_class->task_move_group)[39]
strstr : INIT : 	if (tsk->sched_class->task_move_group) : 
2
strstr : if : 	if (tsk->sched_class->task_move_group) : 
2
strstr : for : 	if (tsk->sched_class->task_move_group) : 
2
strstr : while : 	if (tsk->sched_class->task_move_group) : 
2
str : 		tsk->sched_class->task_move_group(tsk, on_rq);[48]
strstr : INIT : 		tsk->sched_class->task_move_group(tsk, on_rq); : 
2
strstr : if : 		tsk->sched_class->task_move_group(tsk, on_rq); : 
2
strstr : for : 		tsk->sched_class->task_move_group(tsk, on_rq); : 
2
strstr : while : 		tsk->sched_class->task_move_group(tsk, on_rq); : 
2
str : 	else[5]
strstr : INIT : 	else : 
2
strstr : if : 	else : 
2
strstr : for : 	else : 
2
strstr : while : 	else : 
2
str : #endif[6]
strstr : INIT : #endif : 
2
strstr : if : #endif : 
2
strstr : for : #endif : 
2
strstr : while : #endif : 
2
str : 		set_task_rq(tsk, task_cpu(tsk));[34]
strstr : INIT : 		set_task_rq(tsk, task_cpu(tsk)); : 
2
strstr : if : 		set_task_rq(tsk, task_cpu(tsk)); : 
2
strstr : for : 		set_task_rq(tsk, task_cpu(tsk)); : 
2
strstr : while : 		set_task_rq(tsk, task_cpu(tsk)); : 
2
str : 	if (unlikely(running))[23]
strstr : INIT : 	if (unlikely(running)) : 
2
strstr : if : 	if (unlikely(running)) : 
2
strstr : for : 	if (unlikely(running)) : 
2
strstr : while : 	if (unlikely(running)) : 
2
str : 		tsk->sched_class->set_curr_task(rq);[38]
strstr : INIT : 		tsk->sched_class->set_curr_task(rq); : 
2
strstr : if : 		tsk->sched_class->set_curr_task(rq); : 
2
strstr : for : 		tsk->sched_class->set_curr_task(rq); : 
2
strstr : while : 		tsk->sched_class->set_curr_task(rq); : 
2
str : 	if (on_rq)[11]
strstr : INIT : 	if (on_rq) : 
2
strstr : if : 	if (on_rq) : 
2
strstr : for : 	if (on_rq) : 
2
strstr : while : 	if (on_rq) : 
2
str : 		enqueue_task(rq, tsk, 0);[27]
strstr : INIT : 		enqueue_task(rq, tsk, 0); : 
2
strstr : if : 		enqueue_task(rq, tsk, 0); : 
2
strstr : for : 		enqueue_task(rq, tsk, 0); : 
2
strstr : while : 		enqueue_task(rq, tsk, 0); : 
2
str : 	task_rq_unlock(rq, tsk, &flags);[33]
strstr : INIT : 	task_rq_unlock(rq, tsk, &flags); : 
2
strstr : if : 	task_rq_unlock(rq, tsk, &flags); : 
2
strstr : for : 	task_rq_unlock(rq, tsk, &flags); : 
2
strstr : while : 	task_rq_unlock(rq, tsk, &flags); : 
2
str : #endif /* CONFIG_CGROUP_SCHED */[32]
strstr : INIT : #endif /* CONFIG_CGROUP_SCHED */ : 
2
strstr : if : #endif /* CONFIG_CGROUP_SCHED */ : 
2
strstr : for : #endif /* CONFIG_CGROUP_SCHED */ : 
2
strstr : while : #endif /* CONFIG_CGROUP_SCHED */ : 
2
str : #ifdef CONFIG_RT_GROUP_SCHED[28]
strstr : INIT : #ifdef CONFIG_RT_GROUP_SCHED : 
2
strstr : if : #ifdef CONFIG_RT_GROUP_SCHED : 
2
strstr : for : #ifdef CONFIG_RT_GROUP_SCHED : 
2
strstr : while : #ifdef CONFIG_RT_GROUP_SCHED : 
2
str :  * Ensure that the real time constraints are schedulable.[57]
strstr : INIT :  * Ensure that the real time constraints are schedulable. : 
2
strstr : if :  * Ensure that the real time constraints are schedulable. : 
2
strstr : for :  * Ensure that the real time constraints are schedulable. : 
2
strstr : while :  * Ensure that the real time constraints are schedulable. : 
2
str :  */[3]
strstr : INIT :  */ : 
2
strstr : if :  */ : 
2
strstr : for :  */ : 
2
strstr : while :  */ : 
2
str : static DEFINE_MUTEX(rt_constraints_mutex);[42]
strstr : INIT : static DEFINE_MUTEX(rt_constraints_mutex); : 
2
strstr : if : static DEFINE_MUTEX(rt_constraints_mutex); : 
2
strstr : for : static DEFINE_MUTEX(rt_constraints_mutex); : 
2
strstr : while : static DEFINE_MUTEX(rt_constraints_mutex); : 
2
str : /* Must be called with tasklist_lock held */[44]
strstr : INIT : /* Must be called with tasklist_lock held */ : 
2
strstr : if : /* Must be called with tasklist_lock held */ : 
2
strstr : for : /* Must be called with tasklist_lock held */ : 
2
strstr : while : /* Must be called with tasklist_lock held */ : 
2
str : static inline int tg_has_rt_tasks(struct task_group *tg)[56]
strstr : INIT : static inline int tg_has_rt_tasks(struct task_group *tg) : 
2
strstr : if : static inline int tg_has_rt_tasks(struct task_group *tg) : 
2
strstr : for : static inline int tg_has_rt_tasks(struct task_group *tg) : 
2
strstr : while : static inline int tg_has_rt_tasks(struct task_group *tg) : 
2
str : 	struct task_struct *g, *p;[27]
strstr : INIT : 	struct task_struct *g, *p; : 
2
strstr : if : 	struct task_struct *g, *p; : 
2
strstr : for : 	struct task_struct *g, *p; : 
2
strstr : while : 	struct task_struct *g, *p; : 
2
str : 	do_each_thread(g, p) {[23]
strstr : INIT : 	do_each_thread(g, p) { : 
2
strstr : if : 	do_each_thread(g, p) { : 
2
strstr : for : 	do_each_thread(g, p) { : 
2
strstr : while : 	do_each_thread(g, p) { : 
2
str : 		if (rt_task(p) && task_rq(p)->rt.tg == tg)[44]
strstr : INIT : 		if (rt_task(p) && task_rq(p)->rt.tg == tg) : 
2
strstr : if : 		if (rt_task(p) && task_rq(p)->rt.tg == tg) : 
2
strstr : for : 		if (rt_task(p) && task_rq(p)->rt.tg == tg) : 
2
strstr : while : 		if (rt_task(p) && task_rq(p)->rt.tg == tg) : 
2
str : 			return 1;[12]
strstr : INIT : 			return 1; : 
2
strstr : if : 			return 1; : 
2
strstr : for : 			return 1; : 
2
strstr : while : 			return 1; : 
2
str : 	} while_each_thread(g, p);[27]
strstr : INIT : 	} while_each_thread(g, p); : 
2
strstr : if : 	} while_each_thread(g, p); : 
2
strstr : for : 	} while_each_thread(g, p); : 
2
strstr : while : 	} while_each_thread(g, p); : 
2
str : 	return 0;[10]
strstr : INIT : 	return 0; : 
2
strstr : if : 	return 0; : 
2
strstr : for : 	return 0; : 
2
strstr : while : 	return 0; : 
2
str : struct rt_schedulable_data {[28]
strstr : INIT : struct rt_schedulable_data { : 
2
strstr : if : struct rt_schedulable_data { : 
2
strstr : for : struct rt_schedulable_data { : 
2
strstr : while : struct rt_schedulable_data { : 
2
str : 	struct task_group *tg;[23]
strstr : INIT : 	struct task_group *tg; : 
2
strstr : if : 	struct task_group *tg; : 
2
strstr : for : 	struct task_group *tg; : 
2
strstr : while : 	struct task_group *tg; : 
2
str : 	u64 rt_period;[15]
strstr : INIT : 	u64 rt_period; : 
2
strstr : if : 	u64 rt_period; : 
2
strstr : for : 	u64 rt_period; : 
2
strstr : while : 	u64 rt_period; : 
2
str : 	u64 rt_runtime;[16]
strstr : INIT : 	u64 rt_runtime; : 
2
strstr : if : 	u64 rt_runtime; : 
2
strstr : for : 	u64 rt_runtime; : 
2
strstr : while : 	u64 rt_runtime; : 
2
str : static int tg_rt_schedulable(struct task_group *tg, void *data)[63]
strstr : INIT : static int tg_rt_schedulable(struct task_group *tg, void *data) : 
2
strstr : if : static int tg_rt_schedulable(struct task_group *tg, void *data) : 
2
strstr : for : static int tg_rt_schedulable(struct task_group *tg, void *data) : 
2
strstr : while : static int tg_rt_schedulable(struct task_group *tg, void *data) : 
2
str : 	struct rt_schedulable_data *d = data;[38]
strstr : INIT : 	struct rt_schedulable_data *d = data; : 
2
strstr : if : 	struct rt_schedulable_data *d = data; : 
2
strstr : for : 	struct rt_schedulable_data *d = data; : 
2
strstr : while : 	struct rt_schedulable_data *d = data; : 
2
str : 	struct task_group *child;[26]
strstr : INIT : 	struct task_group *child; : 
2
strstr : if : 	struct task_group *child; : 
2
strstr : for : 	struct task_group *child; : 
2
strstr : while : 	struct task_group *child; : 
2
str : 	unsigned long total, sum = 0;[30]
strstr : INIT : 	unsigned long total, sum = 0; : 
2
strstr : if : 	unsigned long total, sum = 0; : 
2
strstr : for : 	unsigned long total, sum = 0; : 
2
strstr : while : 	unsigned long total, sum = 0; : 
2
str : 	u64 period, runtime;[21]
strstr : INIT : 	u64 period, runtime; : 
2
strstr : if : 	u64 period, runtime; : 
2
strstr : for : 	u64 period, runtime; : 
2
strstr : while : 	u64 period, runtime; : 
2
str : 	period = ktime_to_ns(tg->rt_bandwidth.rt_period);[50]
strstr : INIT : 	period = ktime_to_ns(tg->rt_bandwidth.rt_period); : 
2
strstr : if : 	period = ktime_to_ns(tg->rt_bandwidth.rt_period); : 
2
strstr : for : 	period = ktime_to_ns(tg->rt_bandwidth.rt_period); : 
2
strstr : while : 	period = ktime_to_ns(tg->rt_bandwidth.rt_period); : 
2
str : 	runtime = tg->rt_bandwidth.rt_runtime;[39]
strstr : INIT : 	runtime = tg->rt_bandwidth.rt_runtime; : 
2
strstr : if : 	runtime = tg->rt_bandwidth.rt_runtime; : 
2
strstr : for : 	runtime = tg->rt_bandwidth.rt_runtime; : 
2
strstr : while : 	runtime = tg->rt_bandwidth.rt_runtime; : 
2
str : 	if (tg == d->tg) {[19]
strstr : INIT : 	if (tg == d->tg) { : 
2
strstr : if : 	if (tg == d->tg) { : 
2
strstr : for : 	if (tg == d->tg) { : 
2
strstr : while : 	if (tg == d->tg) { : 
2
str : 		period = d->rt_period;[24]
strstr : INIT : 		period = d->rt_period; : 
2
strstr : if : 		period = d->rt_period; : 
2
strstr : for : 		period = d->rt_period; : 
2
strstr : while : 		period = d->rt_period; : 
2
str : 		runtime = d->rt_runtime;[26]
strstr : INIT : 		runtime = d->rt_runtime; : 
2
strstr : if : 		runtime = d->rt_runtime; : 
2
strstr : for : 		runtime = d->rt_runtime; : 
2
strstr : while : 		runtime = d->rt_runtime; : 
2
str : 	/*[3]
strstr : INIT : 	/* : 
2
strstr : if : 	/* : 
2
strstr : for : 	/* : 
2
strstr : while : 	/* : 
2
str : 	 * Cannot have more runtime than the period.[45]
strstr : INIT : 	 * Cannot have more runtime than the period. : 
2
strstr : if : 	 * Cannot have more runtime than the period. : 
2
strstr : for : 	 * Cannot have more runtime than the period. : 
2
strstr : while : 	 * Cannot have more runtime than the period. : 
2
str : 	 */[4]
strstr : INIT : 	 */ : 
2
strstr : if : 	 */ : 
2
strstr : for : 	 */ : 
2
strstr : while : 	 */ : 
2
str : 	if (runtime > period && runtime != RUNTIME_INF)[48]
strstr : INIT : 	if (runtime > period && runtime != RUNTIME_INF) : 
2
strstr : if : 	if (runtime > period && runtime != RUNTIME_INF) : 
2
strstr : for : 	if (runtime > period && runtime != RUNTIME_INF) : 
2
strstr : while : 	if (runtime > period && runtime != RUNTIME_INF) : 
2
str : 		return -EINVAL;[17]
strstr : INIT : 		return -EINVAL; : 
2
strstr : if : 		return -EINVAL; : 
2
strstr : for : 		return -EINVAL; : 
2
strstr : while : 		return -EINVAL; : 
2
str : 	/*[3]
strstr : INIT : 	/* : 
2
strstr : if : 	/* : 
2
strstr : for : 	/* : 
2
strstr : while : 	/* : 
2
str : 	 * Ensure we don't starve existing RT tasks.[45]
strstr : INIT : 	 * Ensure we don't starve existing RT tasks. : 
2
strstr : if : 	 * Ensure we don't starve existing RT tasks. : 
2
strstr : for : 	 * Ensure we don't starve existing RT tasks. : 
2
strstr : while : 	 * Ensure we don't starve existing RT tasks. : 
2
str : 	 */[4]
strstr : INIT : 	 */ : 
2
strstr : if : 	 */ : 
2
strstr : for : 	 */ : 
2
strstr : while : 	 */ : 
2
str : 	if (rt_bandwidth_enabled() && !runtime && tg_has_rt_tasks(tg))[63]
strstr : INIT : 	if (rt_bandwidth_enabled() && !runtime && tg_has_rt_tasks(tg)) : 
2
strstr : if : 	if (rt_bandwidth_enabled() && !runtime && tg_has_rt_tasks(tg)) : 
2
strstr : for : 	if (rt_bandwidth_enabled() && !runtime && tg_has_rt_tasks(tg)) : 
2
strstr : while : 	if (rt_bandwidth_enabled() && !runtime && tg_has_rt_tasks(tg)) : 
2
str : 		return -EBUSY;[16]
strstr : INIT : 		return -EBUSY; : 
2
strstr : if : 		return -EBUSY; : 
2
strstr : for : 		return -EBUSY; : 
2
strstr : while : 		return -EBUSY; : 
2
str : 	total = to_ratio(period, runtime);[35]
strstr : INIT : 	total = to_ratio(period, runtime); : 
2
strstr : if : 	total = to_ratio(period, runtime); : 
2
strstr : for : 	total = to_ratio(period, runtime); : 
2
strstr : while : 	total = to_ratio(period, runtime); : 
2
str : 	/*[3]
strstr : INIT : 	/* : 
2
strstr : if : 	/* : 
2
strstr : for : 	/* : 
2
strstr : while : 	/* : 
2
str : 	 * Nobody can have more than the global setting allows.[56]
strstr : INIT : 	 * Nobody can have more than the global setting allows. : 
2
strstr : if : 	 * Nobody can have more than the global setting allows. : 
2
strstr : for : 	 * Nobody can have more than the global setting allows. : 
2
strstr : while : 	 * Nobody can have more than the global setting allows. : 
2
str : 	 */[4]
strstr : INIT : 	 */ : 
2
strstr : if : 	 */ : 
2
strstr : for : 	 */ : 
2
strstr : while : 	 */ : 
2
str : 	if (total > to_ratio(global_rt_period(), global_rt_runtime()))[63]
strstr : INIT : 	if (total > to_ratio(global_rt_period(), global_rt_runtime())) : 
2
strstr : if : 	if (total > to_ratio(global_rt_period(), global_rt_runtime())) : 
2
strstr : for : 	if (total > to_ratio(global_rt_period(), global_rt_runtime())) : 
2
strstr : while : 	if (total > to_ratio(global_rt_period(), global_rt_runtime())) : 
2
str : 		return -EINVAL;[17]
strstr : INIT : 		return -EINVAL; : 
2
strstr : if : 		return -EINVAL; : 
2
strstr : for : 		return -EINVAL; : 
2
strstr : while : 		return -EINVAL; : 
2
str : 	/*[3]
strstr : INIT : 	/* : 
2
strstr : if : 	/* : 
2
strstr : for : 	/* : 
2
strstr : while : 	/* : 
2
str : 	 * The sum of our children's runtime should not exceed our own.[64]
strstr : INIT : 	 * The sum of our children's runtime should not exceed our own. : 
2
strstr : if : 	 * The sum of our children's runtime should not exceed our own. : 
2
strstr : for : 	 * The sum of our children's runtime should not exceed our own. : 
2
strstr : while : 	 * The sum of our children's runtime should not exceed our own. : 
2
str : 	 */[4]
strstr : INIT : 	 */ : 
2
strstr : if : 	 */ : 
2
strstr : for : 	 */ : 
2
strstr : while : 	 */ : 
2
str : 	list_for_each_entry_rcu(child, &tg->children, siblings) {[58]
strstr : INIT : 	list_for_each_entry_rcu(child, &tg->children, siblings) { : 
2
strstr : if : 	list_for_each_entry_rcu(child, &tg->children, siblings) { : 
2
strstr : for : 	list_for_each_entry_rcu(child, &tg->children, siblings) { : 
2
strstr : while : 	list_for_each_entry_rcu(child, &tg->children, siblings) { : 
2
str : 		period = ktime_to_ns(child->rt_bandwidth.rt_period);[54]
strstr : INIT : 		period = ktime_to_ns(child->rt_bandwidth.rt_period); : 
2
strstr : if : 		period = ktime_to_ns(child->rt_bandwidth.rt_period); : 
2
strstr : for : 		period = ktime_to_ns(child->rt_bandwidth.rt_period); : 
2
strstr : while : 		period = ktime_to_ns(child->rt_bandwidth.rt_period); : 
2
str : 		runtime = child->rt_bandwidth.rt_runtime;[43]
strstr : INIT : 		runtime = child->rt_bandwidth.rt_runtime; : 
2
strstr : if : 		runtime = child->rt_bandwidth.rt_runtime; : 
2
strstr : for : 		runtime = child->rt_bandwidth.rt_runtime; : 
2
strstr : while : 		runtime = child->rt_bandwidth.rt_runtime; : 
2
str : 		if (child == d->tg) {[23]
strstr : INIT : 		if (child == d->tg) { : 
2
strstr : if : 		if (child == d->tg) { : 
2
strstr : for : 		if (child == d->tg) { : 
2
strstr : while : 		if (child == d->tg) { : 
2
str : 			period = d->rt_period;[25]
strstr : INIT : 			period = d->rt_period; : 
2
strstr : if : 			period = d->rt_period; : 
2
strstr : for : 			period = d->rt_period; : 
2
strstr : while : 			period = d->rt_period; : 
2
str : 			runtime = d->rt_runtime;[27]
strstr : INIT : 			runtime = d->rt_runtime; : 
2
strstr : if : 			runtime = d->rt_runtime; : 
2
strstr : for : 			runtime = d->rt_runtime; : 
2
strstr : while : 			runtime = d->rt_runtime; : 
2
str : 		}[3]
strstr : INIT : 		} : 
2
strstr : if : 		} : 
2
strstr : for : 		} : 
2
strstr : while : 		} : 
2
str : 		sum += to_ratio(period, runtime);[35]
strstr : INIT : 		sum += to_ratio(period, runtime); : 
2
strstr : if : 		sum += to_ratio(period, runtime); : 
2
strstr : for : 		sum += to_ratio(period, runtime); : 
2
strstr : while : 		sum += to_ratio(period, runtime); : 
2
str : 	if (sum > total)[17]
strstr : INIT : 	if (sum > total) : 
2
strstr : if : 	if (sum > total) : 
2
strstr : for : 	if (sum > total) : 
2
strstr : while : 	if (sum > total) : 
2
str : 		return -EINVAL;[17]
strstr : INIT : 		return -EINVAL; : 
2
strstr : if : 		return -EINVAL; : 
2
strstr : for : 		return -EINVAL; : 
2
strstr : while : 		return -EINVAL; : 
2
str : 	return 0;[10]
strstr : INIT : 	return 0; : 
2
strstr : if : 	return 0; : 
2
strstr : for : 	return 0; : 
2
strstr : while : 	return 0; : 
2
str : static int __rt_schedulable(struct task_group *tg, u64 period, u64 runtime)[75]
strstr : INIT : static int __rt_schedulable(struct task_group *tg, u64 period, u64 runtime) : 
2
strstr : if : static int __rt_schedulable(struct task_group *tg, u64 period, u64 runtime) : 
2
strstr : for : static int __rt_schedulable(struct task_group *tg, u64 period, u64 runtime) : 
2
strstr : while : static int __rt_schedulable(struct task_group *tg, u64 period, u64 runtime) : 
2
str : 	int ret;[9]
strstr : INIT : 	int ret; : 
2
strstr : if : 	int ret; : 
2
strstr : for : 	int ret; : 
2
strstr : while : 	int ret; : 
2
str : 	struct rt_schedulable_data data = {[36]
strstr : INIT : 	struct rt_schedulable_data data = { : 
2
strstr : if : 	struct rt_schedulable_data data = { : 
2
strstr : for : 	struct rt_schedulable_data data = { : 
2
strstr : while : 	struct rt_schedulable_data data = { : 
2
str : 		.tg = tg,[11]
strstr : INIT : 		.tg = tg, : 
2
strstr : if : 		.tg = tg, : 
2
strstr : for : 		.tg = tg, : 
2
strstr : while : 		.tg = tg, : 
2
str : 		.rt_period = period,[22]
strstr : INIT : 		.rt_period = period, : 
2
strstr : if : 		.rt_period = period, : 
2
strstr : for : 		.rt_period = period, : 
2
strstr : while : 		.rt_period = period, : 
2
str : 		.rt_runtime = runtime,[24]
strstr : INIT : 		.rt_runtime = runtime, : 
2
strstr : if : 		.rt_runtime = runtime, : 
2
strstr : for : 		.rt_runtime = runtime, : 
2
strstr : while : 		.rt_runtime = runtime, : 
2
str : 	};[3]
strstr : INIT : 	}; : 
2
strstr : if : 	}; : 
2
strstr : for : 	}; : 
2
strstr : while : 	}; : 
2
str : 	rcu_read_lock();[17]
strstr : INIT : 	rcu_read_lock(); : 
2
strstr : if : 	rcu_read_lock(); : 
2
strstr : for : 	rcu_read_lock(); : 
2
strstr : while : 	rcu_read_lock(); : 
2
str : 	ret = walk_tg_tree(tg_rt_schedulable, tg_nop, &data);[54]
strstr : INIT : 	ret = walk_tg_tree(tg_rt_schedulable, tg_nop, &data); : 
2
strstr : if : 	ret = walk_tg_tree(tg_rt_schedulable, tg_nop, &data); : 
2
strstr : for : 	ret = walk_tg_tree(tg_rt_schedulable, tg_nop, &data); : 
2
strstr : while : 	ret = walk_tg_tree(tg_rt_schedulable, tg_nop, &data); : 
2
str : 	rcu_read_unlock();[19]
strstr : INIT : 	rcu_read_unlock(); : 
2
strstr : if : 	rcu_read_unlock(); : 
2
strstr : for : 	rcu_read_unlock(); : 
2
strstr : while : 	rcu_read_unlock(); : 
2
str : 	return ret;[12]
strstr : INIT : 	return ret; : 
2
strstr : if : 	return ret; : 
2
strstr : for : 	return ret; : 
2
strstr : while : 	return ret; : 
2
str : static int tg_set_rt_bandwidth(struct task_group *tg,[53]
strstr : INIT : static int tg_set_rt_bandwidth(struct task_group *tg, : 
2
strstr : if : static int tg_set_rt_bandwidth(struct task_group *tg, : 
2
strstr : for : static int tg_set_rt_bandwidth(struct task_group *tg, : 
2
strstr : while : static int tg_set_rt_bandwidth(struct task_group *tg, : 
2
str : 		u64 rt_period, u64 rt_runtime)[32]
strstr : INIT : 		u64 rt_period, u64 rt_runtime) : 
2
strstr : if : 		u64 rt_period, u64 rt_runtime) : 
2
strstr : for : 		u64 rt_period, u64 rt_runtime) : 
2
strstr : while : 		u64 rt_period, u64 rt_runtime) : 
2
str : 	int i, err = 0;[16]
strstr : INIT : 	int i, err = 0; : 
2
strstr : if : 	int i, err = 0; : 
2
strstr : for : 	int i, err = 0; : 
2
strstr : while : 	int i, err = 0; : 
2
str : 	mutex_lock(&rt_constraints_mutex);[35]
strstr : INIT : 	mutex_lock(&rt_constraints_mutex); : 
2
strstr : if : 	mutex_lock(&rt_constraints_mutex); : 
2
strstr : for : 	mutex_lock(&rt_constraints_mutex); : 
2
strstr : while : 	mutex_lock(&rt_constraints_mutex); : 
2
str : 	read_lock(&tasklist_lock);[27]
strstr : INIT : 	read_lock(&tasklist_lock); : 
2
strstr : if : 	read_lock(&tasklist_lock); : 
2
strstr : for : 	read_lock(&tasklist_lock); : 
2
strstr : while : 	read_lock(&tasklist_lock); : 
2
str : 	err = __rt_schedulable(tg, rt_period, rt_runtime);[51]
strstr : INIT : 	err = __rt_schedulable(tg, rt_period, rt_runtime); : 
2
strstr : if : 	err = __rt_schedulable(tg, rt_period, rt_runtime); : 
2
strstr : for : 	err = __rt_schedulable(tg, rt_period, rt_runtime); : 
2
strstr : while : 	err = __rt_schedulable(tg, rt_period, rt_runtime); : 
2
str : 	if (err)[9]
strstr : INIT : 	if (err) : 
2
strstr : if : 	if (err) : 
2
strstr : for : 	if (err) : 
2
strstr : while : 	if (err) : 
2
str : 		goto unlock;[14]
strstr : INIT : 		goto unlock; : 
2
strstr : if : 		goto unlock; : 
2
strstr : for : 		goto unlock; : 
2
strstr : while : 		goto unlock; : 
2
str : 	raw_spin_lock_irq(&tg->rt_bandwidth.rt_runtime_lock);[54]
strstr : INIT : 	raw_spin_lock_irq(&tg->rt_bandwidth.rt_runtime_lock); : 
2
strstr : if : 	raw_spin_lock_irq(&tg->rt_bandwidth.rt_runtime_lock); : 
2
strstr : for : 	raw_spin_lock_irq(&tg->rt_bandwidth.rt_runtime_lock); : 
2
strstr : while : 	raw_spin_lock_irq(&tg->rt_bandwidth.rt_runtime_lock); : 
2
str : 	tg->rt_bandwidth.rt_period = ns_to_ktime(rt_period);[53]
strstr : INIT : 	tg->rt_bandwidth.rt_period = ns_to_ktime(rt_period); : 
2
strstr : if : 	tg->rt_bandwidth.rt_period = ns_to_ktime(rt_period); : 
2
strstr : for : 	tg->rt_bandwidth.rt_period = ns_to_ktime(rt_period); : 
2
strstr : while : 	tg->rt_bandwidth.rt_period = ns_to_ktime(rt_period); : 
2
str : 	tg->rt_bandwidth.rt_runtime = rt_runtime;[42]
strstr : INIT : 	tg->rt_bandwidth.rt_runtime = rt_runtime; : 
2
strstr : if : 	tg->rt_bandwidth.rt_runtime = rt_runtime; : 
2
strstr : for : 	tg->rt_bandwidth.rt_runtime = rt_runtime; : 
2
strstr : while : 	tg->rt_bandwidth.rt_runtime = rt_runtime; : 
2
str : 	for_each_possible_cpu(i) {[27]
strstr : INIT : 	for_each_possible_cpu(i) { : 
2
strstr : if : 	for_each_possible_cpu(i) { : 
2
strstr : for : 	for_each_possible_cpu(i) { : 
2
strstr : while : 	for_each_possible_cpu(i) { : 
2
str : 		struct rt_rq *rt_rq = tg->rt_rq[i];[37]
strstr : INIT : 		struct rt_rq *rt_rq = tg->rt_rq[i]; : 
2
strstr : if : 		struct rt_rq *rt_rq = tg->rt_rq[i]; : 
2
strstr : for : 		struct rt_rq *rt_rq = tg->rt_rq[i]; : 
2
strstr : while : 		struct rt_rq *rt_rq = tg->rt_rq[i]; : 
2
str : 		raw_spin_lock(&rt_rq->rt_runtime_lock);[41]
strstr : INIT : 		raw_spin_lock(&rt_rq->rt_runtime_lock); : 
2
strstr : if : 		raw_spin_lock(&rt_rq->rt_runtime_lock); : 
2
strstr : for : 		raw_spin_lock(&rt_rq->rt_runtime_lock); : 
2
strstr : while : 		raw_spin_lock(&rt_rq->rt_runtime_lock); : 
2
str : 		rt_rq->rt_runtime = rt_runtime;[33]
strstr : INIT : 		rt_rq->rt_runtime = rt_runtime; : 
2
strstr : if : 		rt_rq->rt_runtime = rt_runtime; : 
2
strstr : for : 		rt_rq->rt_runtime = rt_runtime; : 
2
strstr : while : 		rt_rq->rt_runtime = rt_runtime; : 
2
str : 		raw_spin_unlock(&rt_rq->rt_runtime_lock);[43]
strstr : INIT : 		raw_spin_unlock(&rt_rq->rt_runtime_lock); : 
2
strstr : if : 		raw_spin_unlock(&rt_rq->rt_runtime_lock); : 
2
strstr : for : 		raw_spin_unlock(&rt_rq->rt_runtime_lock); : 
2
strstr : while : 		raw_spin_unlock(&rt_rq->rt_runtime_lock); : 
2
str : 	raw_spin_unlock_irq(&tg->rt_bandwidth.rt_runtime_lock);[56]
strstr : INIT : 	raw_spin_unlock_irq(&tg->rt_bandwidth.rt_runtime_lock); : 
2
strstr : if : 	raw_spin_unlock_irq(&tg->rt_bandwidth.rt_runtime_lock); : 
2
strstr : for : 	raw_spin_unlock_irq(&tg->rt_bandwidth.rt_runtime_lock); : 
2
strstr : while : 	raw_spin_unlock_irq(&tg->rt_bandwidth.rt_runtime_lock); : 
2
str : unlock:[7]
strstr : INIT : unlock: : 
2
strstr : if : unlock: : 
2
strstr : for : unlock: : 
2
strstr : while : unlock: : 
2
str : 	read_unlock(&tasklist_lock);[29]
strstr : INIT : 	read_unlock(&tasklist_lock); : 
2
strstr : if : 	read_unlock(&tasklist_lock); : 
2
strstr : for : 	read_unlock(&tasklist_lock); : 
2
strstr : while : 	read_unlock(&tasklist_lock); : 
2
str : 	mutex_unlock(&rt_constraints_mutex);[37]
strstr : INIT : 	mutex_unlock(&rt_constraints_mutex); : 
2
strstr : if : 	mutex_unlock(&rt_constraints_mutex); : 
2
strstr : for : 	mutex_unlock(&rt_constraints_mutex); : 
2
strstr : while : 	mutex_unlock(&rt_constraints_mutex); : 
2
str : 	return err;[12]
strstr : INIT : 	return err; : 
2
strstr : if : 	return err; : 
2
strstr : for : 	return err; : 
2
strstr : while : 	return err; : 
2
str : static int sched_group_set_rt_runtime(struct task_group *tg, long rt_runtime_us)[80]
strstr : INIT : static int sched_group_set_rt_runtime(struct task_group *tg, long rt_runtime_us) : 
2
strstr : if : static int sched_group_set_rt_runtime(struct task_group *tg, long rt_runtime_us) : 
2
strstr : for : static int sched_group_set_rt_runtime(struct task_group *tg, long rt_runtime_us) : 
2
strstr : while : static int sched_group_set_rt_runtime(struct task_group *tg, long rt_runtime_us) : 
2
str : 	u64 rt_runtime, rt_period;[27]
strstr : INIT : 	u64 rt_runtime, rt_period; : 
2
strstr : if : 	u64 rt_runtime, rt_period; : 
2
strstr : for : 	u64 rt_runtime, rt_period; : 
2
strstr : while : 	u64 rt_runtime, rt_period; : 
2
str : 	rt_period = ktime_to_ns(tg->rt_bandwidth.rt_period);[53]
strstr : INIT : 	rt_period = ktime_to_ns(tg->rt_bandwidth.rt_period); : 
2
strstr : if : 	rt_period = ktime_to_ns(tg->rt_bandwidth.rt_period); : 
2
strstr : for : 	rt_period = ktime_to_ns(tg->rt_bandwidth.rt_period); : 
2
strstr : while : 	rt_period = ktime_to_ns(tg->rt_bandwidth.rt_period); : 
2
str : 	rt_runtime = (u64)rt_runtime_us * NSEC_PER_USEC;[49]
strstr : INIT : 	rt_runtime = (u64)rt_runtime_us * NSEC_PER_USEC; : 
2
strstr : if : 	rt_runtime = (u64)rt_runtime_us * NSEC_PER_USEC; : 
2
strstr : for : 	rt_runtime = (u64)rt_runtime_us * NSEC_PER_USEC; : 
2
strstr : while : 	rt_runtime = (u64)rt_runtime_us * NSEC_PER_USEC; : 
2
str : 	if (rt_runtime_us < 0)[23]
strstr : INIT : 	if (rt_runtime_us < 0) : 
2
strstr : if : 	if (rt_runtime_us < 0) : 
2
strstr : for : 	if (rt_runtime_us < 0) : 
2
strstr : while : 	if (rt_runtime_us < 0) : 
2
str : 		rt_runtime = RUNTIME_INF;[27]
strstr : INIT : 		rt_runtime = RUNTIME_INF; : 
2
strstr : if : 		rt_runtime = RUNTIME_INF; : 
2
strstr : for : 		rt_runtime = RUNTIME_INF; : 
2
strstr : while : 		rt_runtime = RUNTIME_INF; : 
2
str : 	return tg_set_rt_bandwidth(tg, rt_period, rt_runtime);[55]
strstr : INIT : 	return tg_set_rt_bandwidth(tg, rt_period, rt_runtime); : 
2
strstr : if : 	return tg_set_rt_bandwidth(tg, rt_period, rt_runtime); : 
2
strstr : for : 	return tg_set_rt_bandwidth(tg, rt_period, rt_runtime); : 
2
strstr : while : 	return tg_set_rt_bandwidth(tg, rt_period, rt_runtime); : 
2
str : static long sched_group_rt_runtime(struct task_group *tg)[57]
strstr : INIT : static long sched_group_rt_runtime(struct task_group *tg) : 
2
strstr : if : static long sched_group_rt_runtime(struct task_group *tg) : 
2
strstr : for : static long sched_group_rt_runtime(struct task_group *tg) : 
2
strstr : while : static long sched_group_rt_runtime(struct task_group *tg) : 
2
str : 	u64 rt_runtime_us;[19]
strstr : INIT : 	u64 rt_runtime_us; : 
2
strstr : if : 	u64 rt_runtime_us; : 
2
strstr : for : 	u64 rt_runtime_us; : 
2
strstr : while : 	u64 rt_runtime_us; : 
2
str : 	if (tg->rt_bandwidth.rt_runtime == RUNTIME_INF)[48]
strstr : INIT : 	if (tg->rt_bandwidth.rt_runtime == RUNTIME_INF) : 
2
strstr : if : 	if (tg->rt_bandwidth.rt_runtime == RUNTIME_INF) : 
2
strstr : for : 	if (tg->rt_bandwidth.rt_runtime == RUNTIME_INF) : 
2
strstr : while : 	if (tg->rt_bandwidth.rt_runtime == RUNTIME_INF) : 
2
str : 		return -1;[12]
strstr : INIT : 		return -1; : 
2
strstr : if : 		return -1; : 
2
strstr : for : 		return -1; : 
2
strstr : while : 		return -1; : 
2
str : 	rt_runtime_us = tg->rt_bandwidth.rt_runtime;[45]
strstr : INIT : 	rt_runtime_us = tg->rt_bandwidth.rt_runtime; : 
2
strstr : if : 	rt_runtime_us = tg->rt_bandwidth.rt_runtime; : 
2
strstr : for : 	rt_runtime_us = tg->rt_bandwidth.rt_runtime; : 
2
strstr : while : 	rt_runtime_us = tg->rt_bandwidth.rt_runtime; : 
2
str : 	do_div(rt_runtime_us, NSEC_PER_USEC);[38]
strstr : INIT : 	do_div(rt_runtime_us, NSEC_PER_USEC); : 
2
strstr : if : 	do_div(rt_runtime_us, NSEC_PER_USEC); : 
2
strstr : for : 	do_div(rt_runtime_us, NSEC_PER_USEC); : 
2
strstr : while : 	do_div(rt_runtime_us, NSEC_PER_USEC); : 
2
str : 	return rt_runtime_us;[22]
strstr : INIT : 	return rt_runtime_us; : 
2
strstr : if : 	return rt_runtime_us; : 
2
strstr : for : 	return rt_runtime_us; : 
2
strstr : while : 	return rt_runtime_us; : 
2
str : static int sched_group_set_rt_period(struct task_group *tg, long rt_period_us)[78]
strstr : INIT : static int sched_group_set_rt_period(struct task_group *tg, long rt_period_us) : 
2
strstr : if : static int sched_group_set_rt_period(struct task_group *tg, long rt_period_us) : 
2
strstr : for : static int sched_group_set_rt_period(struct task_group *tg, long rt_period_us) : 
2
strstr : while : static int sched_group_set_rt_period(struct task_group *tg, long rt_period_us) : 
2
str : 	u64 rt_runtime, rt_period;[27]
strstr : INIT : 	u64 rt_runtime, rt_period; : 
2
strstr : if : 	u64 rt_runtime, rt_period; : 
2
strstr : for : 	u64 rt_runtime, rt_period; : 
2
strstr : while : 	u64 rt_runtime, rt_period; : 
2
str : 	rt_period = (u64)rt_period_us * NSEC_PER_USEC;[47]
strstr : INIT : 	rt_period = (u64)rt_period_us * NSEC_PER_USEC; : 
2
strstr : if : 	rt_period = (u64)rt_period_us * NSEC_PER_USEC; : 
2
strstr : for : 	rt_period = (u64)rt_period_us * NSEC_PER_USEC; : 
2
strstr : while : 	rt_period = (u64)rt_period_us * NSEC_PER_USEC; : 
2
str : 	rt_runtime = tg->rt_bandwidth.rt_runtime;[42]
strstr : INIT : 	rt_runtime = tg->rt_bandwidth.rt_runtime; : 
2
strstr : if : 	rt_runtime = tg->rt_bandwidth.rt_runtime; : 
2
strstr : for : 	rt_runtime = tg->rt_bandwidth.rt_runtime; : 
2
strstr : while : 	rt_runtime = tg->rt_bandwidth.rt_runtime; : 
2
str : 	if (rt_period == 0)[20]
strstr : INIT : 	if (rt_period == 0) : 
2
strstr : if : 	if (rt_period == 0) : 
2
strstr : for : 	if (rt_period == 0) : 
2
strstr : while : 	if (rt_period == 0) : 
2
str : 		return -EINVAL;[17]
strstr : INIT : 		return -EINVAL; : 
2
strstr : if : 		return -EINVAL; : 
2
strstr : for : 		return -EINVAL; : 
2
strstr : while : 		return -EINVAL; : 
2
str : 	return tg_set_rt_bandwidth(tg, rt_period, rt_runtime);[55]
strstr : INIT : 	return tg_set_rt_bandwidth(tg, rt_period, rt_runtime); : 
2
strstr : if : 	return tg_set_rt_bandwidth(tg, rt_period, rt_runtime); : 
2
strstr : for : 	return tg_set_rt_bandwidth(tg, rt_period, rt_runtime); : 
2
strstr : while : 	return tg_set_rt_bandwidth(tg, rt_period, rt_runtime); : 
2
str : static long sched_group_rt_period(struct task_group *tg)[56]
strstr : INIT : static long sched_group_rt_period(struct task_group *tg) : 
2
strstr : if : static long sched_group_rt_period(struct task_group *tg) : 
2
strstr : for : static long sched_group_rt_period(struct task_group *tg) : 
2
strstr : while : static long sched_group_rt_period(struct task_group *tg) : 
2
str : 	u64 rt_period_us;[18]
strstr : INIT : 	u64 rt_period_us; : 
2
strstr : if : 	u64 rt_period_us; : 
2
strstr : for : 	u64 rt_period_us; : 
2
strstr : while : 	u64 rt_period_us; : 
2
str : 	rt_period_us = ktime_to_ns(tg->rt_bandwidth.rt_period);[56]
strstr : INIT : 	rt_period_us = ktime_to_ns(tg->rt_bandwidth.rt_period); : 
2
strstr : if : 	rt_period_us = ktime_to_ns(tg->rt_bandwidth.rt_period); : 
2
strstr : for : 	rt_period_us = ktime_to_ns(tg->rt_bandwidth.rt_period); : 
2
strstr : while : 	rt_period_us = ktime_to_ns(tg->rt_bandwidth.rt_period); : 
2
str : 	do_div(rt_period_us, NSEC_PER_USEC);[37]
strstr : INIT : 	do_div(rt_period_us, NSEC_PER_USEC); : 
2
strstr : if : 	do_div(rt_period_us, NSEC_PER_USEC); : 
2
strstr : for : 	do_div(rt_period_us, NSEC_PER_USEC); : 
2
strstr : while : 	do_div(rt_period_us, NSEC_PER_USEC); : 
2
str : 	return rt_period_us;[21]
strstr : INIT : 	return rt_period_us; : 
2
strstr : if : 	return rt_period_us; : 
2
strstr : for : 	return rt_period_us; : 
2
strstr : while : 	return rt_period_us; : 
2
str : #endif /* CONFIG_RT_GROUP_SCHED */[34]
strstr : INIT : #endif /* CONFIG_RT_GROUP_SCHED */ : 
2
strstr : if : #endif /* CONFIG_RT_GROUP_SCHED */ : 
2
strstr : for : #endif /* CONFIG_RT_GROUP_SCHED */ : 
2
strstr : while : #endif /* CONFIG_RT_GROUP_SCHED */ : 
2
str : #ifdef CONFIG_RT_GROUP_SCHED[28]
strstr : INIT : #ifdef CONFIG_RT_GROUP_SCHED : 
2
strstr : if : #ifdef CONFIG_RT_GROUP_SCHED : 
2
strstr : for : #ifdef CONFIG_RT_GROUP_SCHED : 
2
strstr : while : #ifdef CONFIG_RT_GROUP_SCHED : 
2
str : static int sched_rt_global_constraints(void)[44]
strstr : INIT : static int sched_rt_global_constraints(void) : 
2
strstr : if : static int sched_rt_global_constraints(void) : 
2
strstr : for : static int sched_rt_global_constraints(void) : 
2
strstr : while : static int sched_rt_global_constraints(void) : 
2
str : 	int ret = 0;[13]
strstr : INIT : 	int ret = 0; : 
2
strstr : if : 	int ret = 0; : 
2
strstr : for : 	int ret = 0; : 
2
strstr : while : 	int ret = 0; : 
2
str : 	mutex_lock(&rt_constraints_mutex);[35]
strstr : INIT : 	mutex_lock(&rt_constraints_mutex); : 
2
strstr : if : 	mutex_lock(&rt_constraints_mutex); : 
2
strstr : for : 	mutex_lock(&rt_constraints_mutex); : 
2
strstr : while : 	mutex_lock(&rt_constraints_mutex); : 
2
str : 	read_lock(&tasklist_lock);[27]
strstr : INIT : 	read_lock(&tasklist_lock); : 
2
strstr : if : 	read_lock(&tasklist_lock); : 
2
strstr : for : 	read_lock(&tasklist_lock); : 
2
strstr : while : 	read_lock(&tasklist_lock); : 
2
str : 	ret = __rt_schedulable(NULL, 0, 0);[36]
strstr : INIT : 	ret = __rt_schedulable(NULL, 0, 0); : 
2
strstr : if : 	ret = __rt_schedulable(NULL, 0, 0); : 
2
strstr : for : 	ret = __rt_schedulable(NULL, 0, 0); : 
2
strstr : while : 	ret = __rt_schedulable(NULL, 0, 0); : 
2
str : 	read_unlock(&tasklist_lock);[29]
strstr : INIT : 	read_unlock(&tasklist_lock); : 
2
strstr : if : 	read_unlock(&tasklist_lock); : 
2
strstr : for : 	read_unlock(&tasklist_lock); : 
2
strstr : while : 	read_unlock(&tasklist_lock); : 
2
str : 	mutex_unlock(&rt_constraints_mutex);[37]
strstr : INIT : 	mutex_unlock(&rt_constraints_mutex); : 
2
strstr : if : 	mutex_unlock(&rt_constraints_mutex); : 
2
strstr : for : 	mutex_unlock(&rt_constraints_mutex); : 
2
strstr : while : 	mutex_unlock(&rt_constraints_mutex); : 
2
str : 	return ret;[12]
strstr : INIT : 	return ret; : 
2
strstr : if : 	return ret; : 
2
strstr : for : 	return ret; : 
2
strstr : while : 	return ret; : 
2
str : static int sched_rt_can_attach(struct task_group *tg, struct task_struct *tsk)[78]
strstr : INIT : static int sched_rt_can_attach(struct task_group *tg, struct task_struct *tsk) : 
2
strstr : if : static int sched_rt_can_attach(struct task_group *tg, struct task_struct *tsk) : 
2
strstr : for : static int sched_rt_can_attach(struct task_group *tg, struct task_struct *tsk) : 
2
strstr : while : static int sched_rt_can_attach(struct task_group *tg, struct task_struct *tsk) : 
2
str : 	/* Don't accept realtime tasks when there is no way for them to run */[71]
strstr : INIT : 	/* Don't accept realtime tasks when there is no way for them to run */ : 
2
strstr : if : 	/* Don't accept realtime tasks when there is no way for them to run */ : 
2
strstr : for : 	/* Don't accept realtime tasks when there is no way for them to run */ : 
2
strstr : while : 	/* Don't accept realtime tasks when there is no way for them to run */ : 
2
str : 	if (rt_task(tsk) && tg->rt_bandwidth.rt_runtime == 0)[54]
strstr : INIT : 	if (rt_task(tsk) && tg->rt_bandwidth.rt_runtime == 0) : 
2
strstr : if : 	if (rt_task(tsk) && tg->rt_bandwidth.rt_runtime == 0) : 
2
strstr : for : 	if (rt_task(tsk) && tg->rt_bandwidth.rt_runtime == 0) : 
2
strstr : while : 	if (rt_task(tsk) && tg->rt_bandwidth.rt_runtime == 0) : 
2
str : 		return 0;[11]
strstr : INIT : 		return 0; : 
2
strstr : if : 		return 0; : 
2
strstr : for : 		return 0; : 
2
strstr : while : 		return 0; : 
2
str : 	return 1;[10]
strstr : INIT : 	return 1; : 
2
strstr : if : 	return 1; : 
2
strstr : for : 	return 1; : 
2
strstr : while : 	return 1; : 
2
str : #else /* !CONFIG_RT_GROUP_SCHED */[34]
strstr : INIT : #else /* !CONFIG_RT_GROUP_SCHED */ : 
2
strstr : if : #else /* !CONFIG_RT_GROUP_SCHED */ : 
2
strstr : for : #else /* !CONFIG_RT_GROUP_SCHED */ : 
2
strstr : while : #else /* !CONFIG_RT_GROUP_SCHED */ : 
2
str : static int sched_rt_global_constraints(void)[44]
strstr : INIT : static int sched_rt_global_constraints(void) : 
2
strstr : if : static int sched_rt_global_constraints(void) : 
2
strstr : for : static int sched_rt_global_constraints(void) : 
2
strstr : while : static int sched_rt_global_constraints(void) : 
2
str : 	unsigned long flags;[21]
strstr : INIT : 	unsigned long flags; : 
2
strstr : if : 	unsigned long flags; : 
2
strstr : for : 	unsigned long flags; : 
2
strstr : while : 	unsigned long flags; : 
2
str : 	int i, ret = 0;[16]
strstr : INIT : 	int i, ret = 0; : 
2
strstr : if : 	int i, ret = 0; : 
2
strstr : for : 	int i, ret = 0; : 
2
strstr : while : 	int i, ret = 0; : 
2
str : 	raw_spin_lock_irqsave(&def_rt_bandwidth.rt_runtime_lock, flags);[65]
strstr : INIT : 	raw_spin_lock_irqsave(&def_rt_bandwidth.rt_runtime_lock, flags); : 
2
strstr : if : 	raw_spin_lock_irqsave(&def_rt_bandwidth.rt_runtime_lock, flags); : 
2
strstr : for : 	raw_spin_lock_irqsave(&def_rt_bandwidth.rt_runtime_lock, flags); : 
2
strstr : while : 	raw_spin_lock_irqsave(&def_rt_bandwidth.rt_runtime_lock, flags); : 
2
str : 	for_each_possible_cpu(i) {[27]
strstr : INIT : 	for_each_possible_cpu(i) { : 
2
strstr : if : 	for_each_possible_cpu(i) { : 
2
strstr : for : 	for_each_possible_cpu(i) { : 
2
strstr : while : 	for_each_possible_cpu(i) { : 
2
str : 		struct rt_rq *rt_rq = &cpu_rq(i)->rt;[39]
strstr : INIT : 		struct rt_rq *rt_rq = &cpu_rq(i)->rt; : 
2
strstr : if : 		struct rt_rq *rt_rq = &cpu_rq(i)->rt; : 
2
strstr : for : 		struct rt_rq *rt_rq = &cpu_rq(i)->rt; : 
2
strstr : while : 		struct rt_rq *rt_rq = &cpu_rq(i)->rt; : 
2
str : 		raw_spin_lock(&rt_rq->rt_runtime_lock);[41]
strstr : INIT : 		raw_spin_lock(&rt_rq->rt_runtime_lock); : 
2
strstr : if : 		raw_spin_lock(&rt_rq->rt_runtime_lock); : 
2
strstr : for : 		raw_spin_lock(&rt_rq->rt_runtime_lock); : 
2
strstr : while : 		raw_spin_lock(&rt_rq->rt_runtime_lock); : 
2
str : 		rt_rq->rt_runtime = global_rt_runtime();[42]
strstr : INIT : 		rt_rq->rt_runtime = global_rt_runtime(); : 
2
strstr : if : 		rt_rq->rt_runtime = global_rt_runtime(); : 
2
strstr : for : 		rt_rq->rt_runtime = global_rt_runtime(); : 
2
strstr : while : 		rt_rq->rt_runtime = global_rt_runtime(); : 
2
str : 		raw_spin_unlock(&rt_rq->rt_runtime_lock);[43]
strstr : INIT : 		raw_spin_unlock(&rt_rq->rt_runtime_lock); : 
2
strstr : if : 		raw_spin_unlock(&rt_rq->rt_runtime_lock); : 
2
strstr : for : 		raw_spin_unlock(&rt_rq->rt_runtime_lock); : 
2
strstr : while : 		raw_spin_unlock(&rt_rq->rt_runtime_lock); : 
2
str : 	raw_spin_unlock_irqrestore(&def_rt_bandwidth.rt_runtime_lock, flags);[70]
strstr : INIT : 	raw_spin_unlock_irqrestore(&def_rt_bandwidth.rt_runtime_lock, flags); : 
2
strstr : if : 	raw_spin_unlock_irqrestore(&def_rt_bandwidth.rt_runtime_lock, flags); : 
2
strstr : for : 	raw_spin_unlock_irqrestore(&def_rt_bandwidth.rt_runtime_lock, flags); : 
2
strstr : while : 	raw_spin_unlock_irqrestore(&def_rt_bandwidth.rt_runtime_lock, flags); : 
2
str : 	return ret;[12]
strstr : INIT : 	return ret; : 
2
strstr : if : 	return ret; : 
2
strstr : for : 	return ret; : 
2
strstr : while : 	return ret; : 
2
str : #endif /* CONFIG_RT_GROUP_SCHED */[34]
strstr : INIT : #endif /* CONFIG_RT_GROUP_SCHED */ : 
2
strstr : if : #endif /* CONFIG_RT_GROUP_SCHED */ : 
2
strstr : for : #endif /* CONFIG_RT_GROUP_SCHED */ : 
2
strstr : while : #endif /* CONFIG_RT_GROUP_SCHED */ : 
2
str : static int sched_dl_global_constraints(void)[44]
strstr : INIT : static int sched_dl_global_constraints(void) : 
2
strstr : if : static int sched_dl_global_constraints(void) : 
2
strstr : for : static int sched_dl_global_constraints(void) : 
2
strstr : while : static int sched_dl_global_constraints(void) : 
2
str : 	u64 runtime = global_rt_runtime();[35]
strstr : INIT : 	u64 runtime = global_rt_runtime(); : 
2
strstr : if : 	u64 runtime = global_rt_runtime(); : 
2
strstr : for : 	u64 runtime = global_rt_runtime(); : 
2
strstr : while : 	u64 runtime = global_rt_runtime(); : 
2
str : 	u64 period = global_rt_period();[33]
strstr : INIT : 	u64 period = global_rt_period(); : 
2
strstr : if : 	u64 period = global_rt_period(); : 
2
strstr : for : 	u64 period = global_rt_period(); : 
2
strstr : while : 	u64 period = global_rt_period(); : 
2
str : 	u64 new_bw = to_ratio(period, runtime);[40]
strstr : INIT : 	u64 new_bw = to_ratio(period, runtime); : 
2
strstr : if : 	u64 new_bw = to_ratio(period, runtime); : 
2
strstr : for : 	u64 new_bw = to_ratio(period, runtime); : 
2
strstr : while : 	u64 new_bw = to_ratio(period, runtime); : 
2
str : 	int cpu, ret = 0;[18]
strstr : INIT : 	int cpu, ret = 0; : 
2
strstr : if : 	int cpu, ret = 0; : 
2
strstr : for : 	int cpu, ret = 0; : 
2
strstr : while : 	int cpu, ret = 0; : 
2
str : 	unsigned long flags;[21]
strstr : INIT : 	unsigned long flags; : 
2
strstr : if : 	unsigned long flags; : 
2
strstr : for : 	unsigned long flags; : 
2
strstr : while : 	unsigned long flags; : 
2
str : 	/*[3]
strstr : INIT : 	/* : 
2
strstr : if : 	/* : 
2
strstr : for : 	/* : 
2
strstr : while : 	/* : 
2
str : 	 * Here we want to check the bandwidth not being set to some[61]
strstr : INIT : 	 * Here we want to check the bandwidth not being set to some : 
2
strstr : if : 	 * Here we want to check the bandwidth not being set to some : 
2
strstr : for : 	 * Here we want to check the bandwidth not being set to some : 
2
strstr : while : 	 * Here we want to check the bandwidth not being set to some : 
2
str : 	 * value smaller than the currently allocated bandwidth in[59]
strstr : INIT : 	 * value smaller than the currently allocated bandwidth in : 
2
strstr : if : 	 * value smaller than the currently allocated bandwidth in : 
2
strstr : for : 	 * value smaller than the currently allocated bandwidth in : 
2
strstr : while : 	 * value smaller than the currently allocated bandwidth in : 
2
str : 	 * any of the root_domains.[28]
strstr : INIT : 	 * any of the root_domains. : 
2
strstr : if : 	 * any of the root_domains. : 
2
strstr : for : 	 * any of the root_domains. : 
2
strstr : while : 	 * any of the root_domains. : 
2
str : 	 *[3]
strstr : INIT : 	 * : 
2
strstr : if : 	 * : 
2
strstr : for : 	 * : 
2
strstr : while : 	 * : 
2
str : 	 * FIXME: Cycling on all the CPUs is overdoing, but simpler than[65]
strstr : INIT : 	 * FIXME: Cycling on all the CPUs is overdoing, but simpler than : 
2
strstr : if : 	 * FIXME: Cycling on all the CPUs is overdoing, but simpler than : 
2
strstr : for : 	 * FIXME: Cycling on all the CPUs is overdoing, but simpler than : 
2
strstr : while : 	 * FIXME: Cycling on all the CPUs is overdoing, but simpler than : 
2
str : 	 * cycling on root_domains... Discussion on different/better[61]
strstr : INIT : 	 * cycling on root_domains... Discussion on different/better : 
2
strstr : if : 	 * cycling on root_domains... Discussion on different/better : 
2
strstr : for : 	 * cycling on root_domains... Discussion on different/better : 
2
strstr : while : 	 * cycling on root_domains... Discussion on different/better : 
2
str : 	 * solutions is welcome![25]
strstr : INIT : 	 * solutions is welcome! : 
2
strstr : if : 	 * solutions is welcome! : 
2
strstr : for : 	 * solutions is welcome! : 
2
strstr : while : 	 * solutions is welcome! : 
2
str : 	 */[4]
strstr : INIT : 	 */ : 
2
strstr : if : 	 */ : 
2
strstr : for : 	 */ : 
2
strstr : while : 	 */ : 
2
str : 	for_each_possible_cpu(cpu) {[29]
strstr : INIT : 	for_each_possible_cpu(cpu) { : 
2
strstr : if : 	for_each_possible_cpu(cpu) { : 
2
strstr : for : 	for_each_possible_cpu(cpu) { : 
2
strstr : while : 	for_each_possible_cpu(cpu) { : 
2
str : 		struct dl_bw *dl_b = dl_bw_of(cpu);[37]
strstr : INIT : 		struct dl_bw *dl_b = dl_bw_of(cpu); : 
2
strstr : if : 		struct dl_bw *dl_b = dl_bw_of(cpu); : 
2
strstr : for : 		struct dl_bw *dl_b = dl_bw_of(cpu); : 
2
strstr : while : 		struct dl_bw *dl_b = dl_bw_of(cpu); : 
2
str : 		raw_spin_lock_irqsave(&dl_b->lock, flags);[44]
strstr : INIT : 		raw_spin_lock_irqsave(&dl_b->lock, flags); : 
2
strstr : if : 		raw_spin_lock_irqsave(&dl_b->lock, flags); : 
2
strstr : for : 		raw_spin_lock_irqsave(&dl_b->lock, flags); : 
2
strstr : while : 		raw_spin_lock_irqsave(&dl_b->lock, flags); : 
2
str : 		if (new_bw < dl_b->total_bw)[30]
strstr : INIT : 		if (new_bw < dl_b->total_bw) : 
2
strstr : if : 		if (new_bw < dl_b->total_bw) : 
2
strstr : for : 		if (new_bw < dl_b->total_bw) : 
2
strstr : while : 		if (new_bw < dl_b->total_bw) : 
2
str : 			ret = -EBUSY;[16]
strstr : INIT : 			ret = -EBUSY; : 
2
strstr : if : 			ret = -EBUSY; : 
2
strstr : for : 			ret = -EBUSY; : 
2
strstr : while : 			ret = -EBUSY; : 
2
str : 		raw_spin_unlock_irqrestore(&dl_b->lock, flags);[49]
strstr : INIT : 		raw_spin_unlock_irqrestore(&dl_b->lock, flags); : 
2
strstr : if : 		raw_spin_unlock_irqrestore(&dl_b->lock, flags); : 
2
strstr : for : 		raw_spin_unlock_irqrestore(&dl_b->lock, flags); : 
2
strstr : while : 		raw_spin_unlock_irqrestore(&dl_b->lock, flags); : 
2
str : 		if (ret)[10]
strstr : INIT : 		if (ret) : 
2
strstr : if : 		if (ret) : 
2
strstr : for : 		if (ret) : 
2
strstr : while : 		if (ret) : 
2
str : 			break;[9]
strstr : INIT : 			break; : 
2
strstr : if : 			break; : 
2
strstr : for : 			break; : 
2
strstr : while : 			break; : 
2
str : 	return ret;[12]
strstr : INIT : 	return ret; : 
2
strstr : if : 	return ret; : 
2
strstr : for : 	return ret; : 
2
strstr : while : 	return ret; : 
2
str : static void sched_dl_do_global(void)[36]
strstr : INIT : static void sched_dl_do_global(void) : 
2
strstr : if : static void sched_dl_do_global(void) : 
2
strstr : for : static void sched_dl_do_global(void) : 
2
strstr : while : static void sched_dl_do_global(void) : 
2
str : 	u64 new_bw = -1;[17]
strstr : INIT : 	u64 new_bw = -1; : 
2
strstr : if : 	u64 new_bw = -1; : 
2
strstr : for : 	u64 new_bw = -1; : 
2
strstr : while : 	u64 new_bw = -1; : 
2
str : 	int cpu;[9]
strstr : INIT : 	int cpu; : 
2
strstr : if : 	int cpu; : 
2
strstr : for : 	int cpu; : 
2
strstr : while : 	int cpu; : 
2
str : 	unsigned long flags;[21]
strstr : INIT : 	unsigned long flags; : 
2
strstr : if : 	unsigned long flags; : 
2
strstr : for : 	unsigned long flags; : 
2
strstr : while : 	unsigned long flags; : 
2
str : 	def_dl_bandwidth.dl_period = global_rt_period();[49]
strstr : INIT : 	def_dl_bandwidth.dl_period = global_rt_period(); : 
2
strstr : if : 	def_dl_bandwidth.dl_period = global_rt_period(); : 
2
strstr : for : 	def_dl_bandwidth.dl_period = global_rt_period(); : 
2
strstr : while : 	def_dl_bandwidth.dl_period = global_rt_period(); : 
2
str : 	def_dl_bandwidth.dl_runtime = global_rt_runtime();[51]
strstr : INIT : 	def_dl_bandwidth.dl_runtime = global_rt_runtime(); : 
2
strstr : if : 	def_dl_bandwidth.dl_runtime = global_rt_runtime(); : 
2
strstr : for : 	def_dl_bandwidth.dl_runtime = global_rt_runtime(); : 
2
strstr : while : 	def_dl_bandwidth.dl_runtime = global_rt_runtime(); : 
2
str : 	if (global_rt_runtime() != RUNTIME_INF)[40]
strstr : INIT : 	if (global_rt_runtime() != RUNTIME_INF) : 
2
strstr : if : 	if (global_rt_runtime() != RUNTIME_INF) : 
2
strstr : for : 	if (global_rt_runtime() != RUNTIME_INF) : 
2
strstr : while : 	if (global_rt_runtime() != RUNTIME_INF) : 
2
str : 		new_bw = to_ratio(global_rt_period(), global_rt_runtime());[61]
strstr : INIT : 		new_bw = to_ratio(global_rt_period(), global_rt_runtime()); : 
2
strstr : if : 		new_bw = to_ratio(global_rt_period(), global_rt_runtime()); : 
2
strstr : for : 		new_bw = to_ratio(global_rt_period(), global_rt_runtime()); : 
2
strstr : while : 		new_bw = to_ratio(global_rt_period(), global_rt_runtime()); : 
2
str : 	/*[3]
strstr : INIT : 	/* : 
2
strstr : if : 	/* : 
2
strstr : for : 	/* : 
2
strstr : while : 	/* : 
2
str : 	 * FIXME: As above...[22]
strstr : INIT : 	 * FIXME: As above... : 
2
strstr : if : 	 * FIXME: As above... : 
2
strstr : for : 	 * FIXME: As above... : 
2
strstr : while : 	 * FIXME: As above... : 
2
str : 	 */[4]
strstr : INIT : 	 */ : 
2
strstr : if : 	 */ : 
2
strstr : for : 	 */ : 
2
strstr : while : 	 */ : 
2
str : 	for_each_possible_cpu(cpu) {[29]
strstr : INIT : 	for_each_possible_cpu(cpu) { : 
2
strstr : if : 	for_each_possible_cpu(cpu) { : 
2
strstr : for : 	for_each_possible_cpu(cpu) { : 
2
strstr : while : 	for_each_possible_cpu(cpu) { : 
2
str : 		struct dl_bw *dl_b = dl_bw_of(cpu);[37]
strstr : INIT : 		struct dl_bw *dl_b = dl_bw_of(cpu); : 
2
strstr : if : 		struct dl_bw *dl_b = dl_bw_of(cpu); : 
2
strstr : for : 		struct dl_bw *dl_b = dl_bw_of(cpu); : 
2
strstr : while : 		struct dl_bw *dl_b = dl_bw_of(cpu); : 
2
str : 		raw_spin_lock_irqsave(&dl_b->lock, flags);[44]
strstr : INIT : 		raw_spin_lock_irqsave(&dl_b->lock, flags); : 
2
strstr : if : 		raw_spin_lock_irqsave(&dl_b->lock, flags); : 
2
strstr : for : 		raw_spin_lock_irqsave(&dl_b->lock, flags); : 
2
strstr : while : 		raw_spin_lock_irqsave(&dl_b->lock, flags); : 
2
str : 		dl_b->bw = new_bw;[20]
strstr : INIT : 		dl_b->bw = new_bw; : 
2
strstr : if : 		dl_b->bw = new_bw; : 
2
strstr : for : 		dl_b->bw = new_bw; : 
2
strstr : while : 		dl_b->bw = new_bw; : 
2
str : 		raw_spin_unlock_irqrestore(&dl_b->lock, flags);[49]
strstr : INIT : 		raw_spin_unlock_irqrestore(&dl_b->lock, flags); : 
2
strstr : if : 		raw_spin_unlock_irqrestore(&dl_b->lock, flags); : 
2
strstr : for : 		raw_spin_unlock_irqrestore(&dl_b->lock, flags); : 
2
strstr : while : 		raw_spin_unlock_irqrestore(&dl_b->lock, flags); : 
2
str : static int sched_rt_global_validate(void)[41]
strstr : INIT : static int sched_rt_global_validate(void) : 
2
strstr : if : static int sched_rt_global_validate(void) : 
2
strstr : for : static int sched_rt_global_validate(void) : 
2
strstr : while : static int sched_rt_global_validate(void) : 
2
str : 	if (sysctl_sched_rt_period <= 0)[33]
strstr : INIT : 	if (sysctl_sched_rt_period <= 0) : 
2
strstr : if : 	if (sysctl_sched_rt_period <= 0) : 
2
strstr : for : 	if (sysctl_sched_rt_period <= 0) : 
2
strstr : while : 	if (sysctl_sched_rt_period <= 0) : 
2
str : 		return -EINVAL;[17]
strstr : INIT : 		return -EINVAL; : 
2
strstr : if : 		return -EINVAL; : 
2
strstr : for : 		return -EINVAL; : 
2
strstr : while : 		return -EINVAL; : 
2
str : 	if ((sysctl_sched_rt_runtime != RUNTIME_INF) &&[48]
strstr : INIT : 	if ((sysctl_sched_rt_runtime != RUNTIME_INF) && : 
2
strstr : if : 	if ((sysctl_sched_rt_runtime != RUNTIME_INF) && : 
2
strstr : for : 	if ((sysctl_sched_rt_runtime != RUNTIME_INF) && : 
2
strstr : while : 	if ((sysctl_sched_rt_runtime != RUNTIME_INF) && : 
2
str : 		(sysctl_sched_rt_runtime > sysctl_sched_rt_period))[53]
strstr : INIT : 		(sysctl_sched_rt_runtime > sysctl_sched_rt_period)) : 
2
strstr : if : 		(sysctl_sched_rt_runtime > sysctl_sched_rt_period)) : 
2
strstr : for : 		(sysctl_sched_rt_runtime > sysctl_sched_rt_period)) : 
2
strstr : while : 		(sysctl_sched_rt_runtime > sysctl_sched_rt_period)) : 
2
str : 		return -EINVAL;[17]
strstr : INIT : 		return -EINVAL; : 
2
strstr : if : 		return -EINVAL; : 
2
strstr : for : 		return -EINVAL; : 
2
strstr : while : 		return -EINVAL; : 
2
str : 	return 0;[10]
strstr : INIT : 	return 0; : 
2
strstr : if : 	return 0; : 
2
strstr : for : 	return 0; : 
2
strstr : while : 	return 0; : 
2
str : static void sched_rt_do_global(void)[36]
strstr : INIT : static void sched_rt_do_global(void) : 
2
strstr : if : static void sched_rt_do_global(void) : 
2
strstr : for : static void sched_rt_do_global(void) : 
2
strstr : while : static void sched_rt_do_global(void) : 
2
str : 	def_rt_bandwidth.rt_runtime = global_rt_runtime();[51]
strstr : INIT : 	def_rt_bandwidth.rt_runtime = global_rt_runtime(); : 
2
strstr : if : 	def_rt_bandwidth.rt_runtime = global_rt_runtime(); : 
2
strstr : for : 	def_rt_bandwidth.rt_runtime = global_rt_runtime(); : 
2
strstr : while : 	def_rt_bandwidth.rt_runtime = global_rt_runtime(); : 
2
str : 	def_rt_bandwidth.rt_period = ns_to_ktime(global_rt_period());[62]
strstr : INIT : 	def_rt_bandwidth.rt_period = ns_to_ktime(global_rt_period()); : 
2
strstr : if : 	def_rt_bandwidth.rt_period = ns_to_ktime(global_rt_period()); : 
2
strstr : for : 	def_rt_bandwidth.rt_period = ns_to_ktime(global_rt_period()); : 
2
strstr : while : 	def_rt_bandwidth.rt_period = ns_to_ktime(global_rt_period()); : 
2
str : int sched_rt_handler(struct ctl_table *table, int write,[56]
strstr : INIT : int sched_rt_handler(struct ctl_table *table, int write, : 
2
strstr : if : int sched_rt_handler(struct ctl_table *table, int write, : 
2
strstr : for : int sched_rt_handler(struct ctl_table *table, int write, : 
2
strstr : while : int sched_rt_handler(struct ctl_table *table, int write, : 
2
str : 		void __user *buffer, size_t *lenp,[36]
strstr : INIT : 		void __user *buffer, size_t *lenp, : 
2
strstr : if : 		void __user *buffer, size_t *lenp, : 
2
strstr : for : 		void __user *buffer, size_t *lenp, : 
2
strstr : while : 		void __user *buffer, size_t *lenp, : 
2
str : 		loff_t *ppos)[15]
strstr : INIT : 		loff_t *ppos) : 
2
strstr : if : 		loff_t *ppos) : 
2
strstr : for : 		loff_t *ppos) : 
2
strstr : while : 		loff_t *ppos) : 
2
str : 	int old_period, old_runtime;[29]
strstr : INIT : 	int old_period, old_runtime; : 
2
strstr : if : 	int old_period, old_runtime; : 
2
strstr : for : 	int old_period, old_runtime; : 
2
strstr : while : 	int old_period, old_runtime; : 
2
str : 	static DEFINE_MUTEX(mutex);[28]
strstr : INIT : 	static DEFINE_MUTEX(mutex); : 
2
strstr : if : 	static DEFINE_MUTEX(mutex); : 
2
strstr : for : 	static DEFINE_MUTEX(mutex); : 
2
strstr : while : 	static DEFINE_MUTEX(mutex); : 
2
str : 	int ret;[9]
strstr : INIT : 	int ret; : 
2
strstr : if : 	int ret; : 
2
strstr : for : 	int ret; : 
2
strstr : while : 	int ret; : 
2
str : 	mutex_lock(&mutex);[20]
strstr : INIT : 	mutex_lock(&mutex); : 
2
strstr : if : 	mutex_lock(&mutex); : 
2
strstr : for : 	mutex_lock(&mutex); : 
2
strstr : while : 	mutex_lock(&mutex); : 
2
str : 	old_period = sysctl_sched_rt_period;[37]
strstr : INIT : 	old_period = sysctl_sched_rt_period; : 
2
strstr : if : 	old_period = sysctl_sched_rt_period; : 
2
strstr : for : 	old_period = sysctl_sched_rt_period; : 
2
strstr : while : 	old_period = sysctl_sched_rt_period; : 
2
str : 	old_runtime = sysctl_sched_rt_runtime;[39]
strstr : INIT : 	old_runtime = sysctl_sched_rt_runtime; : 
2
strstr : if : 	old_runtime = sysctl_sched_rt_runtime; : 
2
strstr : for : 	old_runtime = sysctl_sched_rt_runtime; : 
2
strstr : while : 	old_runtime = sysctl_sched_rt_runtime; : 
2
str : 	ret = proc_dointvec(table, write, buffer, lenp, ppos);[55]
strstr : INIT : 	ret = proc_dointvec(table, write, buffer, lenp, ppos); : 
2
strstr : if : 	ret = proc_dointvec(table, write, buffer, lenp, ppos); : 
2
strstr : for : 	ret = proc_dointvec(table, write, buffer, lenp, ppos); : 
2
strstr : while : 	ret = proc_dointvec(table, write, buffer, lenp, ppos); : 
2
str : 	if (!ret && write) {[21]
strstr : INIT : 	if (!ret && write) { : 
2
strstr : if : 	if (!ret && write) { : 
2
strstr : for : 	if (!ret && write) { : 
2
strstr : while : 	if (!ret && write) { : 
2
str : 		ret = sched_rt_global_validate();[35]
strstr : INIT : 		ret = sched_rt_global_validate(); : 
2
strstr : if : 		ret = sched_rt_global_validate(); : 
2
strstr : for : 		ret = sched_rt_global_validate(); : 
2
strstr : while : 		ret = sched_rt_global_validate(); : 
2
str : 		if (ret)[10]
strstr : INIT : 		if (ret) : 
2
strstr : if : 		if (ret) : 
2
strstr : for : 		if (ret) : 
2
strstr : while : 		if (ret) : 
2
str : 			goto undo;[13]
strstr : INIT : 			goto undo; : 
2
strstr : if : 			goto undo; : 
2
strstr : for : 			goto undo; : 
2
strstr : while : 			goto undo; : 
2
str : 		ret = sched_rt_global_constraints();[38]
strstr : INIT : 		ret = sched_rt_global_constraints(); : 
2
strstr : if : 		ret = sched_rt_global_constraints(); : 
2
strstr : for : 		ret = sched_rt_global_constraints(); : 
2
strstr : while : 		ret = sched_rt_global_constraints(); : 
2
str : 		if (ret)[10]
strstr : INIT : 		if (ret) : 
2
strstr : if : 		if (ret) : 
2
strstr : for : 		if (ret) : 
2
strstr : while : 		if (ret) : 
2
str : 			goto undo;[13]
strstr : INIT : 			goto undo; : 
2
strstr : if : 			goto undo; : 
2
strstr : for : 			goto undo; : 
2
strstr : while : 			goto undo; : 
2
str : 		ret = sched_dl_global_constraints();[38]
strstr : INIT : 		ret = sched_dl_global_constraints(); : 
2
strstr : if : 		ret = sched_dl_global_constraints(); : 
2
strstr : for : 		ret = sched_dl_global_constraints(); : 
2
strstr : while : 		ret = sched_dl_global_constraints(); : 
2
str : 		if (ret)[10]
strstr : INIT : 		if (ret) : 
2
strstr : if : 		if (ret) : 
2
strstr : for : 		if (ret) : 
2
strstr : while : 		if (ret) : 
2
str : 			goto undo;[13]
strstr : INIT : 			goto undo; : 
2
strstr : if : 			goto undo; : 
2
strstr : for : 			goto undo; : 
2
strstr : while : 			goto undo; : 
2
str : 		sched_rt_do_global();[23]
strstr : INIT : 		sched_rt_do_global(); : 
2
strstr : if : 		sched_rt_do_global(); : 
2
strstr : for : 		sched_rt_do_global(); : 
2
strstr : while : 		sched_rt_do_global(); : 
2
str : 		sched_dl_do_global();[23]
strstr : INIT : 		sched_dl_do_global(); : 
2
strstr : if : 		sched_dl_do_global(); : 
2
strstr : for : 		sched_dl_do_global(); : 
2
strstr : while : 		sched_dl_do_global(); : 
2
str : 	if (0) {[9]
strstr : INIT : 	if (0) { : 
2
strstr : if : 	if (0) { : 
2
strstr : for : 	if (0) { : 
2
strstr : while : 	if (0) { : 
2
str : undo:[5]
strstr : INIT : undo: : 
2
strstr : if : undo: : 
2
strstr : for : undo: : 
2
strstr : while : undo: : 
2
str : 		sysctl_sched_rt_period = old_period;[38]
strstr : INIT : 		sysctl_sched_rt_period = old_period; : 
2
strstr : if : 		sysctl_sched_rt_period = old_period; : 
2
strstr : for : 		sysctl_sched_rt_period = old_period; : 
2
strstr : while : 		sysctl_sched_rt_period = old_period; : 
2
str : 		sysctl_sched_rt_runtime = old_runtime;[40]
strstr : INIT : 		sysctl_sched_rt_runtime = old_runtime; : 
2
strstr : if : 		sysctl_sched_rt_runtime = old_runtime; : 
2
strstr : for : 		sysctl_sched_rt_runtime = old_runtime; : 
2
strstr : while : 		sysctl_sched_rt_runtime = old_runtime; : 
2
str : 	mutex_unlock(&mutex);[22]
strstr : INIT : 	mutex_unlock(&mutex); : 
2
strstr : if : 	mutex_unlock(&mutex); : 
2
strstr : for : 	mutex_unlock(&mutex); : 
2
strstr : while : 	mutex_unlock(&mutex); : 
2
str : 	return ret;[12]
strstr : INIT : 	return ret; : 
2
strstr : if : 	return ret; : 
2
strstr : for : 	return ret; : 
2
strstr : while : 	return ret; : 
2
str : int sched_rr_handler(struct ctl_table *table, int write,[56]
strstr : INIT : int sched_rr_handler(struct ctl_table *table, int write, : 
2
strstr : if : int sched_rr_handler(struct ctl_table *table, int write, : 
2
strstr : for : int sched_rr_handler(struct ctl_table *table, int write, : 
2
strstr : while : int sched_rr_handler(struct ctl_table *table, int write, : 
2
str : 		void __user *buffer, size_t *lenp,[36]
strstr : INIT : 		void __user *buffer, size_t *lenp, : 
2
strstr : if : 		void __user *buffer, size_t *lenp, : 
2
strstr : for : 		void __user *buffer, size_t *lenp, : 
2
strstr : while : 		void __user *buffer, size_t *lenp, : 
2
str : 		loff_t *ppos)[15]
strstr : INIT : 		loff_t *ppos) : 
2
strstr : if : 		loff_t *ppos) : 
2
strstr : for : 		loff_t *ppos) : 
2
strstr : while : 		loff_t *ppos) : 
2
str : 	int ret;[9]
strstr : INIT : 	int ret; : 
2
strstr : if : 	int ret; : 
2
strstr : for : 	int ret; : 
2
strstr : while : 	int ret; : 
2
str : 	static DEFINE_MUTEX(mutex);[28]
strstr : INIT : 	static DEFINE_MUTEX(mutex); : 
2
strstr : if : 	static DEFINE_MUTEX(mutex); : 
2
strstr : for : 	static DEFINE_MUTEX(mutex); : 
2
strstr : while : 	static DEFINE_MUTEX(mutex); : 
2
str : 	mutex_lock(&mutex);[20]
strstr : INIT : 	mutex_lock(&mutex); : 
2
strstr : if : 	mutex_lock(&mutex); : 
2
strstr : for : 	mutex_lock(&mutex); : 
2
strstr : while : 	mutex_lock(&mutex); : 
2
str : 	ret = proc_dointvec(table, write, buffer, lenp, ppos);[55]
strstr : INIT : 	ret = proc_dointvec(table, write, buffer, lenp, ppos); : 
2
strstr : if : 	ret = proc_dointvec(table, write, buffer, lenp, ppos); : 
2
strstr : for : 	ret = proc_dointvec(table, write, buffer, lenp, ppos); : 
2
strstr : while : 	ret = proc_dointvec(table, write, buffer, lenp, ppos); : 
2
str : 	/* make sure that internally we keep jiffies */[48]
strstr : INIT : 	/* make sure that internally we keep jiffies */ : 
2
strstr : if : 	/* make sure that internally we keep jiffies */ : 
2
strstr : for : 	/* make sure that internally we keep jiffies */ : 
2
strstr : while : 	/* make sure that internally we keep jiffies */ : 
2
str : 	/* also, writing zero resets timeslice to default */[53]
strstr : INIT : 	/* also, writing zero resets timeslice to default */ : 
2
strstr : if : 	/* also, writing zero resets timeslice to default */ : 
2
strstr : for : 	/* also, writing zero resets timeslice to default */ : 
2
strstr : while : 	/* also, writing zero resets timeslice to default */ : 
2
str : 	if (!ret && write) {[21]
strstr : INIT : 	if (!ret && write) { : 
2
strstr : if : 	if (!ret && write) { : 
2
strstr : for : 	if (!ret && write) { : 
2
strstr : while : 	if (!ret && write) { : 
2
str : 		sched_rr_timeslice = sched_rr_timeslice <= 0 ?[48]
strstr : INIT : 		sched_rr_timeslice = sched_rr_timeslice <= 0 ? : 
2
strstr : if : 		sched_rr_timeslice = sched_rr_timeslice <= 0 ? : 
2
strstr : for : 		sched_rr_timeslice = sched_rr_timeslice <= 0 ? : 
2
strstr : while : 		sched_rr_timeslice = sched_rr_timeslice <= 0 ? : 
2
str : 			RR_TIMESLICE : msecs_to_jiffies(sched_rr_timeslice);[55]
strstr : INIT : 			RR_TIMESLICE : msecs_to_jiffies(sched_rr_timeslice); : 
2
strstr : if : 			RR_TIMESLICE : msecs_to_jiffies(sched_rr_timeslice); : 
2
strstr : for : 			RR_TIMESLICE : msecs_to_jiffies(sched_rr_timeslice); : 
2
strstr : while : 			RR_TIMESLICE : msecs_to_jiffies(sched_rr_timeslice); : 
2
str : 	mutex_unlock(&mutex);[22]
strstr : INIT : 	mutex_unlock(&mutex); : 
2
strstr : if : 	mutex_unlock(&mutex); : 
2
strstr : for : 	mutex_unlock(&mutex); : 
2
strstr : while : 	mutex_unlock(&mutex); : 
2
str : 	return ret;[12]
strstr : INIT : 	return ret; : 
2
strstr : if : 	return ret; : 
2
strstr : for : 	return ret; : 
2
strstr : while : 	return ret; : 
2
str : #ifdef CONFIG_CGROUP_SCHED[26]
strstr : INIT : #ifdef CONFIG_CGROUP_SCHED : 
2
strstr : if : #ifdef CONFIG_CGROUP_SCHED : 
2
strstr : for : #ifdef CONFIG_CGROUP_SCHED : 
2
strstr : while : #ifdef CONFIG_CGROUP_SCHED : 
2
str : static inline struct task_group *css_tg(struct cgroup_subsys_state *css)[72]
strstr : INIT : static inline struct task_group *css_tg(struct cgroup_subsys_state *css) : 
2
strstr : if : static inline struct task_group *css_tg(struct cgroup_subsys_state *css) : 
2
strstr : for : static inline struct task_group *css_tg(struct cgroup_subsys_state *css) : 
2
strstr : while : static inline struct task_group *css_tg(struct cgroup_subsys_state *css) : 
2
str : 	return css ? container_of(css, struct task_group, css) : NULL;[63]
strstr : INIT : 	return css ? container_of(css, struct task_group, css) : NULL; : 
2
strstr : if : 	return css ? container_of(css, struct task_group, css) : NULL; : 
2
strstr : for : 	return css ? container_of(css, struct task_group, css) : NULL; : 
2
strstr : while : 	return css ? container_of(css, struct task_group, css) : NULL; : 
2
str : static struct cgroup_subsys_state *[35]
strstr : INIT : static struct cgroup_subsys_state * : 
2
strstr : if : static struct cgroup_subsys_state * : 
2
strstr : for : static struct cgroup_subsys_state * : 
2
strstr : while : static struct cgroup_subsys_state * : 
2
str : cpu_cgroup_css_alloc(struct cgroup_subsys_state *parent_css)[60]
strstr : INIT : cpu_cgroup_css_alloc(struct cgroup_subsys_state *parent_css) : 
2
strstr : if : cpu_cgroup_css_alloc(struct cgroup_subsys_state *parent_css) : 
2
strstr : for : cpu_cgroup_css_alloc(struct cgroup_subsys_state *parent_css) : 
2
strstr : while : cpu_cgroup_css_alloc(struct cgroup_subsys_state *parent_css) : 
2
str : 	struct task_group *parent = css_tg(parent_css);[48]
strstr : INIT : 	struct task_group *parent = css_tg(parent_css); : 
2
strstr : if : 	struct task_group *parent = css_tg(parent_css); : 
2
strstr : for : 	struct task_group *parent = css_tg(parent_css); : 
2
strstr : while : 	struct task_group *parent = css_tg(parent_css); : 
2
str : 	struct task_group *tg;[23]
strstr : INIT : 	struct task_group *tg; : 
2
strstr : if : 	struct task_group *tg; : 
2
strstr : for : 	struct task_group *tg; : 
2
strstr : while : 	struct task_group *tg; : 
2
str : 	if (!parent) {[15]
strstr : INIT : 	if (!parent) { : 
2
strstr : if : 	if (!parent) { : 
2
strstr : for : 	if (!parent) { : 
2
strstr : while : 	if (!parent) { : 
2
str : 		/* This is early initialization for the top cgroup */[55]
strstr : INIT : 		/* This is early initialization for the top cgroup */ : 
2
strstr : if : 		/* This is early initialization for the top cgroup */ : 
2
strstr : for : 		/* This is early initialization for the top cgroup */ : 
2
strstr : while : 		/* This is early initialization for the top cgroup */ : 
2
str : 		return &root_task_group.css;[30]
strstr : INIT : 		return &root_task_group.css; : 
2
strstr : if : 		return &root_task_group.css; : 
2
strstr : for : 		return &root_task_group.css; : 
2
strstr : while : 		return &root_task_group.css; : 
2
str : 	tg = sched_create_group(parent);[33]
strstr : INIT : 	tg = sched_create_group(parent); : 
2
strstr : if : 	tg = sched_create_group(parent); : 
2
strstr : for : 	tg = sched_create_group(parent); : 
2
strstr : while : 	tg = sched_create_group(parent); : 
2
str : 	if (IS_ERR(tg))[16]
strstr : INIT : 	if (IS_ERR(tg)) : 
2
strstr : if : 	if (IS_ERR(tg)) : 
2
strstr : for : 	if (IS_ERR(tg)) : 
2
strstr : while : 	if (IS_ERR(tg)) : 
2
str : 		return ERR_PTR(-ENOMEM);[26]
strstr : INIT : 		return ERR_PTR(-ENOMEM); : 
2
strstr : if : 		return ERR_PTR(-ENOMEM); : 
2
strstr : for : 		return ERR_PTR(-ENOMEM); : 
2
strstr : while : 		return ERR_PTR(-ENOMEM); : 
2
str : 	return &tg->css;[17]
strstr : INIT : 	return &tg->css; : 
2
strstr : if : 	return &tg->css; : 
2
strstr : for : 	return &tg->css; : 
2
strstr : while : 	return &tg->css; : 
2
str : static int cpu_cgroup_css_online(struct cgroup_subsys_state *css)[65]
strstr : INIT : static int cpu_cgroup_css_online(struct cgroup_subsys_state *css) : 
2
strstr : if : static int cpu_cgroup_css_online(struct cgroup_subsys_state *css) : 
2
strstr : for : static int cpu_cgroup_css_online(struct cgroup_subsys_state *css) : 
2
strstr : while : static int cpu_cgroup_css_online(struct cgroup_subsys_state *css) : 
2
str : 	struct task_group *tg = css_tg(css);[37]
strstr : INIT : 	struct task_group *tg = css_tg(css); : 
2
strstr : if : 	struct task_group *tg = css_tg(css); : 
2
strstr : for : 	struct task_group *tg = css_tg(css); : 
2
strstr : while : 	struct task_group *tg = css_tg(css); : 
2
str : 	struct task_group *parent = css_tg(css_parent(css));[53]
strstr : INIT : 	struct task_group *parent = css_tg(css_parent(css)); : 
2
strstr : if : 	struct task_group *parent = css_tg(css_parent(css)); : 
2
strstr : for : 	struct task_group *parent = css_tg(css_parent(css)); : 
2
strstr : while : 	struct task_group *parent = css_tg(css_parent(css)); : 
2
str : 	if (parent)[12]
strstr : INIT : 	if (parent) : 
2
strstr : if : 	if (parent) : 
2
strstr : for : 	if (parent) : 
2
strstr : while : 	if (parent) : 
2
str : 		sched_online_group(tg, parent);[33]
strstr : INIT : 		sched_online_group(tg, parent); : 
2
strstr : if : 		sched_online_group(tg, parent); : 
2
strstr : for : 		sched_online_group(tg, parent); : 
2
strstr : while : 		sched_online_group(tg, parent); : 
2
str : 	return 0;[10]
strstr : INIT : 	return 0; : 
2
strstr : if : 	return 0; : 
2
strstr : for : 	return 0; : 
2
strstr : while : 	return 0; : 
2
str : static void cpu_cgroup_css_free(struct cgroup_subsys_state *css)[64]
strstr : INIT : static void cpu_cgroup_css_free(struct cgroup_subsys_state *css) : 
2
strstr : if : static void cpu_cgroup_css_free(struct cgroup_subsys_state *css) : 
2
strstr : for : static void cpu_cgroup_css_free(struct cgroup_subsys_state *css) : 
2
strstr : while : static void cpu_cgroup_css_free(struct cgroup_subsys_state *css) : 
2
str : 	struct task_group *tg = css_tg(css);[37]
strstr : INIT : 	struct task_group *tg = css_tg(css); : 
2
strstr : if : 	struct task_group *tg = css_tg(css); : 
2
strstr : for : 	struct task_group *tg = css_tg(css); : 
2
strstr : while : 	struct task_group *tg = css_tg(css); : 
2
str : 	sched_destroy_group(tg);[25]
strstr : INIT : 	sched_destroy_group(tg); : 
2
strstr : if : 	sched_destroy_group(tg); : 
2
strstr : for : 	sched_destroy_group(tg); : 
2
strstr : while : 	sched_destroy_group(tg); : 
2
str : static void cpu_cgroup_css_offline(struct cgroup_subsys_state *css)[67]
strstr : INIT : static void cpu_cgroup_css_offline(struct cgroup_subsys_state *css) : 
2
strstr : if : static void cpu_cgroup_css_offline(struct cgroup_subsys_state *css) : 
2
strstr : for : static void cpu_cgroup_css_offline(struct cgroup_subsys_state *css) : 
2
strstr : while : static void cpu_cgroup_css_offline(struct cgroup_subsys_state *css) : 
2
str : 	struct task_group *tg = css_tg(css);[37]
strstr : INIT : 	struct task_group *tg = css_tg(css); : 
2
strstr : if : 	struct task_group *tg = css_tg(css); : 
2
strstr : for : 	struct task_group *tg = css_tg(css); : 
2
strstr : while : 	struct task_group *tg = css_tg(css); : 
2
str : 	sched_offline_group(tg);[25]
strstr : INIT : 	sched_offline_group(tg); : 
2
strstr : if : 	sched_offline_group(tg); : 
2
strstr : for : 	sched_offline_group(tg); : 
2
strstr : while : 	sched_offline_group(tg); : 
2
str : static int cpu_cgroup_can_attach(struct cgroup_subsys_state *css,[65]
strstr : INIT : static int cpu_cgroup_can_attach(struct cgroup_subsys_state *css, : 
2
strstr : if : static int cpu_cgroup_can_attach(struct cgroup_subsys_state *css, : 
2
strstr : for : static int cpu_cgroup_can_attach(struct cgroup_subsys_state *css, : 
2
strstr : while : static int cpu_cgroup_can_attach(struct cgroup_subsys_state *css, : 
2
str : 				 struct cgroup_taskset *tset)[33]
strstr : INIT : 				 struct cgroup_taskset *tset) : 
2
strstr : if : 				 struct cgroup_taskset *tset) : 
2
strstr : for : 				 struct cgroup_taskset *tset) : 
2
strstr : while : 				 struct cgroup_taskset *tset) : 
2
str : 	struct task_struct *task;[26]
strstr : INIT : 	struct task_struct *task; : 
2
strstr : if : 	struct task_struct *task; : 
2
strstr : for : 	struct task_struct *task; : 
2
strstr : while : 	struct task_struct *task; : 
2
str : 	cgroup_taskset_for_each(task, css, tset) {[43]
strstr : INIT : 	cgroup_taskset_for_each(task, css, tset) { : 
2
strstr : if : 	cgroup_taskset_for_each(task, css, tset) { : 
2
strstr : for : 	cgroup_taskset_for_each(task, css, tset) { : 
2
strstr : while : 	cgroup_taskset_for_each(task, css, tset) { : 
2
str : #ifdef CONFIG_RT_GROUP_SCHED[28]
strstr : INIT : #ifdef CONFIG_RT_GROUP_SCHED : 
2
strstr : if : #ifdef CONFIG_RT_GROUP_SCHED : 
2
strstr : for : #ifdef CONFIG_RT_GROUP_SCHED : 
2
strstr : while : #ifdef CONFIG_RT_GROUP_SCHED : 
2
str : 		if (!sched_rt_can_attach(css_tg(css), task))[46]
strstr : INIT : 		if (!sched_rt_can_attach(css_tg(css), task)) : 
2
strstr : if : 		if (!sched_rt_can_attach(css_tg(css), task)) : 
2
strstr : for : 		if (!sched_rt_can_attach(css_tg(css), task)) : 
2
strstr : while : 		if (!sched_rt_can_attach(css_tg(css), task)) : 
2
str : 			return -EINVAL;[18]
strstr : INIT : 			return -EINVAL; : 
2
strstr : if : 			return -EINVAL; : 
2
strstr : for : 			return -EINVAL; : 
2
strstr : while : 			return -EINVAL; : 
2
str : #else[5]
strstr : INIT : #else : 
2
strstr : if : #else : 
2
strstr : for : #else : 
2
strstr : while : #else : 
2
str : 		/* We don't support RT-tasks being in separate groups */[58]
strstr : INIT : 		/* We don't support RT-tasks being in separate groups */ : 
2
strstr : if : 		/* We don't support RT-tasks being in separate groups */ : 
2
strstr : for : 		/* We don't support RT-tasks being in separate groups */ : 
2
strstr : while : 		/* We don't support RT-tasks being in separate groups */ : 
2
str : 		if (task->sched_class != &fair_sched_class)[45]
strstr : INIT : 		if (task->sched_class != &fair_sched_class) : 
2
strstr : if : 		if (task->sched_class != &fair_sched_class) : 
2
strstr : for : 		if (task->sched_class != &fair_sched_class) : 
2
strstr : while : 		if (task->sched_class != &fair_sched_class) : 
2
str : 			return -EINVAL;[18]
strstr : INIT : 			return -EINVAL; : 
2
strstr : if : 			return -EINVAL; : 
2
strstr : for : 			return -EINVAL; : 
2
strstr : while : 			return -EINVAL; : 
2
str : #endif[6]
strstr : INIT : #endif : 
2
strstr : if : #endif : 
2
strstr : for : #endif : 
2
strstr : while : #endif : 
2
str : 	return 0;[10]
strstr : INIT : 	return 0; : 
2
strstr : if : 	return 0; : 
2
strstr : for : 	return 0; : 
2
strstr : while : 	return 0; : 
2
str : static void cpu_cgroup_attach(struct cgroup_subsys_state *css,[62]
strstr : INIT : static void cpu_cgroup_attach(struct cgroup_subsys_state *css, : 
2
strstr : if : static void cpu_cgroup_attach(struct cgroup_subsys_state *css, : 
2
strstr : for : static void cpu_cgroup_attach(struct cgroup_subsys_state *css, : 
2
strstr : while : static void cpu_cgroup_attach(struct cgroup_subsys_state *css, : 
2
str : 			      struct cgroup_taskset *tset)[37]
strstr : INIT : 			      struct cgroup_taskset *tset) : 
2
strstr : if : 			      struct cgroup_taskset *tset) : 
2
strstr : for : 			      struct cgroup_taskset *tset) : 
2
strstr : while : 			      struct cgroup_taskset *tset) : 
2
str : 	struct task_struct *task;[26]
strstr : INIT : 	struct task_struct *task; : 
2
strstr : if : 	struct task_struct *task; : 
2
strstr : for : 	struct task_struct *task; : 
2
strstr : while : 	struct task_struct *task; : 
2
str : 	cgroup_taskset_for_each(task, css, tset)[41]
strstr : INIT : 	cgroup_taskset_for_each(task, css, tset) : 
2
strstr : if : 	cgroup_taskset_for_each(task, css, tset) : 
2
strstr : for : 	cgroup_taskset_for_each(task, css, tset) : 
2
strstr : while : 	cgroup_taskset_for_each(task, css, tset) : 
2
str : 		sched_move_task(task);[24]
strstr : INIT : 		sched_move_task(task); : 
2
strstr : if : 		sched_move_task(task); : 
2
strstr : for : 		sched_move_task(task); : 
2
strstr : while : 		sched_move_task(task); : 
2
str : static void cpu_cgroup_exit(struct cgroup_subsys_state *css,[60]
strstr : INIT : static void cpu_cgroup_exit(struct cgroup_subsys_state *css, : 
2
strstr : if : static void cpu_cgroup_exit(struct cgroup_subsys_state *css, : 
2
strstr : for : static void cpu_cgroup_exit(struct cgroup_subsys_state *css, : 
2
strstr : while : static void cpu_cgroup_exit(struct cgroup_subsys_state *css, : 
2
str : 			    struct cgroup_subsys_state *old_css,[43]
strstr : INIT : 			    struct cgroup_subsys_state *old_css, : 
2
strstr : if : 			    struct cgroup_subsys_state *old_css, : 
2
strstr : for : 			    struct cgroup_subsys_state *old_css, : 
2
strstr : while : 			    struct cgroup_subsys_state *old_css, : 
2
str : 			    struct task_struct *task)[32]
strstr : INIT : 			    struct task_struct *task) : 
2
strstr : if : 			    struct task_struct *task) : 
2
strstr : for : 			    struct task_struct *task) : 
2
strstr : while : 			    struct task_struct *task) : 
2
str : 	/*[3]
strstr : INIT : 	/* : 
2
strstr : if : 	/* : 
2
strstr : for : 	/* : 
2
strstr : while : 	/* : 
2
str : 	 * cgroup_exit() is called in the copy_process() failure path.[63]
strstr : INIT : 	 * cgroup_exit() is called in the copy_process() failure path. : 
2
strstr : if : 	 * cgroup_exit() is called in the copy_process() failure path. : 
2
strstr : for : 	 * cgroup_exit() is called in the copy_process() failure path. : 
2
strstr : while : 	 * cgroup_exit() is called in the copy_process() failure path. : 
2
str : 	 * Ignore this case since the task hasn't ran yet, this avoids[63]
strstr : INIT : 	 * Ignore this case since the task hasn't ran yet, this avoids : 
2
strstr : if : 	 * Ignore this case since the task hasn't ran yet, this avoids : 
2
strstr : for : 	 * Ignore this case since the task hasn't ran yet, this avoids : 
2
strstr : while : 	 * Ignore this case since the task hasn't ran yet, this avoids : 
2
str : 	 * trying to poke a half freed task state from generic code.[61]
strstr : INIT : 	 * trying to poke a half freed task state from generic code. : 
2
strstr : if : 	 * trying to poke a half freed task state from generic code. : 
2
strstr : for : 	 * trying to poke a half freed task state from generic code. : 
2
strstr : while : 	 * trying to poke a half freed task state from generic code. : 
2
str : 	 */[4]
strstr : INIT : 	 */ : 
2
strstr : if : 	 */ : 
2
strstr : for : 	 */ : 
2
strstr : while : 	 */ : 
2
str : 	if (!(task->flags & PF_EXITING))[33]
strstr : INIT : 	if (!(task->flags & PF_EXITING)) : 
2
strstr : if : 	if (!(task->flags & PF_EXITING)) : 
2
strstr : for : 	if (!(task->flags & PF_EXITING)) : 
2
strstr : while : 	if (!(task->flags & PF_EXITING)) : 
2
str : 		return;[9]
strstr : INIT : 		return; : 
2
strstr : if : 		return; : 
2
strstr : for : 		return; : 
2
strstr : while : 		return; : 
2
str : 	sched_move_task(task);[23]
strstr : INIT : 	sched_move_task(task); : 
2
strstr : if : 	sched_move_task(task); : 
2
strstr : for : 	sched_move_task(task); : 
2
strstr : while : 	sched_move_task(task); : 
2
str : #ifdef CONFIG_FAIR_GROUP_SCHED[30]
strstr : INIT : #ifdef CONFIG_FAIR_GROUP_SCHED : 
2
strstr : if : #ifdef CONFIG_FAIR_GROUP_SCHED : 
2
strstr : for : #ifdef CONFIG_FAIR_GROUP_SCHED : 
2
strstr : while : #ifdef CONFIG_FAIR_GROUP_SCHED : 
2
str : static int cpu_shares_write_u64(struct cgroup_subsys_state *css,[64]
strstr : INIT : static int cpu_shares_write_u64(struct cgroup_subsys_state *css, : 
2
strstr : if : static int cpu_shares_write_u64(struct cgroup_subsys_state *css, : 
2
strstr : for : static int cpu_shares_write_u64(struct cgroup_subsys_state *css, : 
2
strstr : while : static int cpu_shares_write_u64(struct cgroup_subsys_state *css, : 
2
str : 				struct cftype *cftype, u64 shareval)[40]
strstr : INIT : 				struct cftype *cftype, u64 shareval) : 
2
strstr : if : 				struct cftype *cftype, u64 shareval) : 
2
strstr : for : 				struct cftype *cftype, u64 shareval) : 
2
strstr : while : 				struct cftype *cftype, u64 shareval) : 
2
str : 	return sched_group_set_shares(css_tg(css), scale_load(shareval));[66]
strstr : INIT : 	return sched_group_set_shares(css_tg(css), scale_load(shareval)); : 
2
strstr : if : 	return sched_group_set_shares(css_tg(css), scale_load(shareval)); : 
2
strstr : for : 	return sched_group_set_shares(css_tg(css), scale_load(shareval)); : 
2
strstr : while : 	return sched_group_set_shares(css_tg(css), scale_load(shareval)); : 
2
str : static u64 cpu_shares_read_u64(struct cgroup_subsys_state *css,[63]
strstr : INIT : static u64 cpu_shares_read_u64(struct cgroup_subsys_state *css, : 
2
strstr : if : static u64 cpu_shares_read_u64(struct cgroup_subsys_state *css, : 
2
strstr : for : static u64 cpu_shares_read_u64(struct cgroup_subsys_state *css, : 
2
strstr : while : static u64 cpu_shares_read_u64(struct cgroup_subsys_state *css, : 
2
str : 			       struct cftype *cft)[29]
strstr : INIT : 			       struct cftype *cft) : 
2
strstr : if : 			       struct cftype *cft) : 
2
strstr : for : 			       struct cftype *cft) : 
2
strstr : while : 			       struct cftype *cft) : 
2
str : 	struct task_group *tg = css_tg(css);[37]
strstr : INIT : 	struct task_group *tg = css_tg(css); : 
2
strstr : if : 	struct task_group *tg = css_tg(css); : 
2
strstr : for : 	struct task_group *tg = css_tg(css); : 
2
strstr : while : 	struct task_group *tg = css_tg(css); : 
2
str : 	return (u64) scale_load_down(tg->shares);[42]
strstr : INIT : 	return (u64) scale_load_down(tg->shares); : 
2
strstr : if : 	return (u64) scale_load_down(tg->shares); : 
2
strstr : for : 	return (u64) scale_load_down(tg->shares); : 
2
strstr : while : 	return (u64) scale_load_down(tg->shares); : 
2
str : #ifdef CONFIG_CFS_BANDWIDTH[27]
strstr : INIT : #ifdef CONFIG_CFS_BANDWIDTH : 
2
strstr : if : #ifdef CONFIG_CFS_BANDWIDTH : 
2
strstr : for : #ifdef CONFIG_CFS_BANDWIDTH : 
2
strstr : while : #ifdef CONFIG_CFS_BANDWIDTH : 
2
str : static DEFINE_MUTEX(cfs_constraints_mutex);[43]
strstr : INIT : static DEFINE_MUTEX(cfs_constraints_mutex); : 
2
strstr : if : static DEFINE_MUTEX(cfs_constraints_mutex); : 
2
strstr : for : static DEFINE_MUTEX(cfs_constraints_mutex); : 
2
strstr : while : static DEFINE_MUTEX(cfs_constraints_mutex); : 
2
str : const u64 max_cfs_quota_period = 1 * NSEC_PER_SEC; /* 1s */[59]
strstr : INIT : const u64 max_cfs_quota_period = 1 * NSEC_PER_SEC; /* 1s */ : 
2
strstr : if : const u64 max_cfs_quota_period = 1 * NSEC_PER_SEC; /* 1s */ : 
2
strstr : for : const u64 max_cfs_quota_period = 1 * NSEC_PER_SEC; /* 1s */ : 
2
strstr : while : const u64 max_cfs_quota_period = 1 * NSEC_PER_SEC; /* 1s */ : 
2
str : const u64 min_cfs_quota_period = 1 * NSEC_PER_MSEC; /* 1ms */[61]
strstr : INIT : const u64 min_cfs_quota_period = 1 * NSEC_PER_MSEC; /* 1ms */ : 
2
strstr : if : const u64 min_cfs_quota_period = 1 * NSEC_PER_MSEC; /* 1ms */ : 
2
strstr : for : const u64 min_cfs_quota_period = 1 * NSEC_PER_MSEC; /* 1ms */ : 
2
strstr : while : const u64 min_cfs_quota_period = 1 * NSEC_PER_MSEC; /* 1ms */ : 
2
str : static int __cfs_schedulable(struct task_group *tg, u64 period, u64 runtime);[77]
strstr : INIT : static int __cfs_schedulable(struct task_group *tg, u64 period, u64 runtime); : 
2
strstr : if : static int __cfs_schedulable(struct task_group *tg, u64 period, u64 runtime); : 
2
strstr : for : static int __cfs_schedulable(struct task_group *tg, u64 period, u64 runtime); : 
2
strstr : while : static int __cfs_schedulable(struct task_group *tg, u64 period, u64 runtime); : 
2
str : static int tg_set_cfs_bandwidth(struct task_group *tg, u64 period, u64 quota)[77]
strstr : INIT : static int tg_set_cfs_bandwidth(struct task_group *tg, u64 period, u64 quota) : 
2
strstr : if : static int tg_set_cfs_bandwidth(struct task_group *tg, u64 period, u64 quota) : 
2
strstr : for : static int tg_set_cfs_bandwidth(struct task_group *tg, u64 period, u64 quota) : 
2
strstr : while : static int tg_set_cfs_bandwidth(struct task_group *tg, u64 period, u64 quota) : 
2
str : 	int i, ret = 0, runtime_enabled, runtime_was_enabled;[54]
strstr : INIT : 	int i, ret = 0, runtime_enabled, runtime_was_enabled; : 
2
strstr : if : 	int i, ret = 0, runtime_enabled, runtime_was_enabled; : 
2
strstr : for : 	int i, ret = 0, runtime_enabled, runtime_was_enabled; : 
2
strstr : while : 	int i, ret = 0, runtime_enabled, runtime_was_enabled; : 
2
str : 	struct cfs_bandwidth *cfs_b = &tg->cfs_bandwidth;[50]
strstr : INIT : 	struct cfs_bandwidth *cfs_b = &tg->cfs_bandwidth; : 
2
strstr : if : 	struct cfs_bandwidth *cfs_b = &tg->cfs_bandwidth; : 
2
strstr : for : 	struct cfs_bandwidth *cfs_b = &tg->cfs_bandwidth; : 
2
strstr : while : 	struct cfs_bandwidth *cfs_b = &tg->cfs_bandwidth; : 
2
str : 	if (tg == &root_task_group)[28]
strstr : INIT : 	if (tg == &root_task_group) : 
2
strstr : if : 	if (tg == &root_task_group) : 
2
strstr : for : 	if (tg == &root_task_group) : 
2
strstr : while : 	if (tg == &root_task_group) : 
2
str : 		return -EINVAL;[17]
strstr : INIT : 		return -EINVAL; : 
2
strstr : if : 		return -EINVAL; : 
2
strstr : for : 		return -EINVAL; : 
2
strstr : while : 		return -EINVAL; : 
2
str : 	/*[3]
strstr : INIT : 	/* : 
2
strstr : if : 	/* : 
2
strstr : for : 	/* : 
2
strstr : while : 	/* : 
2
str : 	 * Ensure we have at some amount of bandwidth every period.  This is[69]
strstr : INIT : 	 * Ensure we have at some amount of bandwidth every period.  This is : 
2
strstr : if : 	 * Ensure we have at some amount of bandwidth every period.  This is : 
2
strstr : for : 	 * Ensure we have at some amount of bandwidth every period.  This is : 
2
strstr : while : 	 * Ensure we have at some amount of bandwidth every period.  This is : 
2
str : 	 * to prevent reaching a state of large arrears when throttled via[67]
strstr : INIT : 	 * to prevent reaching a state of large arrears when throttled via : 
2
strstr : if : 	 * to prevent reaching a state of large arrears when throttled via : 
2
strstr : for : 	 * to prevent reaching a state of large arrears when throttled via : 
2
strstr : while : 	 * to prevent reaching a state of large arrears when throttled via : 
2
str : 	 * entity_tick() resulting in prolonged exit starvation.[57]
strstr : INIT : 	 * entity_tick() resulting in prolonged exit starvation. : 
2
strstr : if : 	 * entity_tick() resulting in prolonged exit starvation. : 
2
strstr : for : 	 * entity_tick() resulting in prolonged exit starvation. : 
2
strstr : while : 	 * entity_tick() resulting in prolonged exit starvation. : 
2
str : 	 */[4]
strstr : INIT : 	 */ : 
2
strstr : if : 	 */ : 
2
strstr : for : 	 */ : 
2
strstr : while : 	 */ : 
2
str : 	if (quota < min_cfs_quota_period || period < min_cfs_quota_period)[67]
strstr : INIT : 	if (quota < min_cfs_quota_period || period < min_cfs_quota_period) : 
2
strstr : if : 	if (quota < min_cfs_quota_period || period < min_cfs_quota_period) : 
2
strstr : for : 	if (quota < min_cfs_quota_period || period < min_cfs_quota_period) : 
2
strstr : while : 	if (quota < min_cfs_quota_period || period < min_cfs_quota_period) : 
2
str : 		return -EINVAL;[17]
strstr : INIT : 		return -EINVAL; : 
2
strstr : if : 		return -EINVAL; : 
2
strstr : for : 		return -EINVAL; : 
2
strstr : while : 		return -EINVAL; : 
2
str : 	/*[3]
strstr : INIT : 	/* : 
2
strstr : if : 	/* : 
2
strstr : for : 	/* : 
2
strstr : while : 	/* : 
2
str : 	 * Likewise, bound things on the otherside by preventing insane quota[70]
strstr : INIT : 	 * Likewise, bound things on the otherside by preventing insane quota : 
2
strstr : if : 	 * Likewise, bound things on the otherside by preventing insane quota : 
2
strstr : for : 	 * Likewise, bound things on the otherside by preventing insane quota : 
2
strstr : while : 	 * Likewise, bound things on the otherside by preventing insane quota : 
2
str : 	 * periods.  This also allows us to normalize in computing quota[65]
strstr : INIT : 	 * periods.  This also allows us to normalize in computing quota : 
2
strstr : if : 	 * periods.  This also allows us to normalize in computing quota : 
2
strstr : for : 	 * periods.  This also allows us to normalize in computing quota : 
2
strstr : while : 	 * periods.  This also allows us to normalize in computing quota : 
2
str : 	 * feasibility.[16]
strstr : INIT : 	 * feasibility. : 
2
strstr : if : 	 * feasibility. : 
2
strstr : for : 	 * feasibility. : 
2
strstr : while : 	 * feasibility. : 
2
str : 	 */[4]
strstr : INIT : 	 */ : 
2
strstr : if : 	 */ : 
2
strstr : for : 	 */ : 
2
strstr : while : 	 */ : 
2
str : 	if (period > max_cfs_quota_period)[35]
strstr : INIT : 	if (period > max_cfs_quota_period) : 
2
strstr : if : 	if (period > max_cfs_quota_period) : 
2
strstr : for : 	if (period > max_cfs_quota_period) : 
2
strstr : while : 	if (period > max_cfs_quota_period) : 
2
str : 		return -EINVAL;[17]
strstr : INIT : 		return -EINVAL; : 
2
strstr : if : 		return -EINVAL; : 
2
strstr : for : 		return -EINVAL; : 
2
strstr : while : 		return -EINVAL; : 
2
str : 	mutex_lock(&cfs_constraints_mutex);[36]
strstr : INIT : 	mutex_lock(&cfs_constraints_mutex); : 
2
strstr : if : 	mutex_lock(&cfs_constraints_mutex); : 
2
strstr : for : 	mutex_lock(&cfs_constraints_mutex); : 
2
strstr : while : 	mutex_lock(&cfs_constraints_mutex); : 
2
str : 	ret = __cfs_schedulable(tg, period, quota);[44]
strstr : INIT : 	ret = __cfs_schedulable(tg, period, quota); : 
2
strstr : if : 	ret = __cfs_schedulable(tg, period, quota); : 
2
strstr : for : 	ret = __cfs_schedulable(tg, period, quota); : 
2
strstr : while : 	ret = __cfs_schedulable(tg, period, quota); : 
2
str : 	if (ret)[9]
strstr : INIT : 	if (ret) : 
2
strstr : if : 	if (ret) : 
2
strstr : for : 	if (ret) : 
2
strstr : while : 	if (ret) : 
2
str : 		goto out_unlock;[18]
strstr : INIT : 		goto out_unlock; : 
2
strstr : if : 		goto out_unlock; : 
2
strstr : for : 		goto out_unlock; : 
2
strstr : while : 		goto out_unlock; : 
2
str : 	runtime_enabled = quota != RUNTIME_INF;[40]
strstr : INIT : 	runtime_enabled = quota != RUNTIME_INF; : 
2
strstr : if : 	runtime_enabled = quota != RUNTIME_INF; : 
2
strstr : for : 	runtime_enabled = quota != RUNTIME_INF; : 
2
strstr : while : 	runtime_enabled = quota != RUNTIME_INF; : 
2
str : 	runtime_was_enabled = cfs_b->quota != RUNTIME_INF;[51]
strstr : INIT : 	runtime_was_enabled = cfs_b->quota != RUNTIME_INF; : 
2
strstr : if : 	runtime_was_enabled = cfs_b->quota != RUNTIME_INF; : 
2
strstr : for : 	runtime_was_enabled = cfs_b->quota != RUNTIME_INF; : 
2
strstr : while : 	runtime_was_enabled = cfs_b->quota != RUNTIME_INF; : 
2
str : 	/*[3]
strstr : INIT : 	/* : 
2
strstr : if : 	/* : 
2
strstr : for : 	/* : 
2
strstr : while : 	/* : 
2
str : 	 * If we need to toggle cfs_bandwidth_used, off->on must occur[63]
strstr : INIT : 	 * If we need to toggle cfs_bandwidth_used, off->on must occur : 
2
strstr : if : 	 * If we need to toggle cfs_bandwidth_used, off->on must occur : 
2
strstr : for : 	 * If we need to toggle cfs_bandwidth_used, off->on must occur : 
2
strstr : while : 	 * If we need to toggle cfs_bandwidth_used, off->on must occur : 
2
str : 	 * before making related changes, and on->off must occur afterwards[68]
strstr : INIT : 	 * before making related changes, and on->off must occur afterwards : 
2
strstr : if : 	 * before making related changes, and on->off must occur afterwards : 
2
strstr : for : 	 * before making related changes, and on->off must occur afterwards : 
2
strstr : while : 	 * before making related changes, and on->off must occur afterwards : 
2
str : 	 */[4]
strstr : INIT : 	 */ : 
2
strstr : if : 	 */ : 
2
strstr : for : 	 */ : 
2
strstr : while : 	 */ : 
2
str : 	if (runtime_enabled && !runtime_was_enabled)[45]
strstr : INIT : 	if (runtime_enabled && !runtime_was_enabled) : 
2
strstr : if : 	if (runtime_enabled && !runtime_was_enabled) : 
2
strstr : for : 	if (runtime_enabled && !runtime_was_enabled) : 
2
strstr : while : 	if (runtime_enabled && !runtime_was_enabled) : 
2
str : 		cfs_bandwidth_usage_inc();[28]
strstr : INIT : 		cfs_bandwidth_usage_inc(); : 
2
strstr : if : 		cfs_bandwidth_usage_inc(); : 
2
strstr : for : 		cfs_bandwidth_usage_inc(); : 
2
strstr : while : 		cfs_bandwidth_usage_inc(); : 
2
str : 	raw_spin_lock_irq(&cfs_b->lock);[33]
strstr : INIT : 	raw_spin_lock_irq(&cfs_b->lock); : 
2
strstr : if : 	raw_spin_lock_irq(&cfs_b->lock); : 
2
strstr : for : 	raw_spin_lock_irq(&cfs_b->lock); : 
2
strstr : while : 	raw_spin_lock_irq(&cfs_b->lock); : 
2
str : 	cfs_b->period = ns_to_ktime(period);[37]
strstr : INIT : 	cfs_b->period = ns_to_ktime(period); : 
2
strstr : if : 	cfs_b->period = ns_to_ktime(period); : 
2
strstr : for : 	cfs_b->period = ns_to_ktime(period); : 
2
strstr : while : 	cfs_b->period = ns_to_ktime(period); : 
2
str : 	cfs_b->quota = quota;[22]
strstr : INIT : 	cfs_b->quota = quota; : 
2
strstr : if : 	cfs_b->quota = quota; : 
2
strstr : for : 	cfs_b->quota = quota; : 
2
strstr : while : 	cfs_b->quota = quota; : 
2
str : 	__refill_cfs_bandwidth_runtime(cfs_b);[39]
strstr : INIT : 	__refill_cfs_bandwidth_runtime(cfs_b); : 
2
strstr : if : 	__refill_cfs_bandwidth_runtime(cfs_b); : 
2
strstr : for : 	__refill_cfs_bandwidth_runtime(cfs_b); : 
2
strstr : while : 	__refill_cfs_bandwidth_runtime(cfs_b); : 
2
str : 	/* restart the period timer (if active) to handle new period expiry */[71]
strstr : INIT : 	/* restart the period timer (if active) to handle new period expiry */ : 
2
strstr : if : 	/* restart the period timer (if active) to handle new period expiry */ : 
2
strstr : for : 	/* restart the period timer (if active) to handle new period expiry */ : 
2
strstr : while : 	/* restart the period timer (if active) to handle new period expiry */ : 
2
str : 	if (runtime_enabled && cfs_b->timer_active) {[46]
strstr : INIT : 	if (runtime_enabled && cfs_b->timer_active) { : 
2
strstr : if : 	if (runtime_enabled && cfs_b->timer_active) { : 
2
strstr : for : 	if (runtime_enabled && cfs_b->timer_active) { : 
2
strstr : while : 	if (runtime_enabled && cfs_b->timer_active) { : 
2
str : 		/* force a reprogram */[25]
strstr : INIT : 		/* force a reprogram */ : 
2
strstr : if : 		/* force a reprogram */ : 
2
strstr : for : 		/* force a reprogram */ : 
2
strstr : while : 		/* force a reprogram */ : 
2
str : 		cfs_b->timer_active = 0;[26]
strstr : INIT : 		cfs_b->timer_active = 0; : 
2
strstr : if : 		cfs_b->timer_active = 0; : 
2
strstr : for : 		cfs_b->timer_active = 0; : 
2
strstr : while : 		cfs_b->timer_active = 0; : 
2
str : 		__start_cfs_bandwidth(cfs_b);[31]
strstr : INIT : 		__start_cfs_bandwidth(cfs_b); : 
2
strstr : if : 		__start_cfs_bandwidth(cfs_b); : 
2
strstr : for : 		__start_cfs_bandwidth(cfs_b); : 
2
strstr : while : 		__start_cfs_bandwidth(cfs_b); : 
2
str : 	raw_spin_unlock_irq(&cfs_b->lock);[35]
strstr : INIT : 	raw_spin_unlock_irq(&cfs_b->lock); : 
2
strstr : if : 	raw_spin_unlock_irq(&cfs_b->lock); : 
2
strstr : for : 	raw_spin_unlock_irq(&cfs_b->lock); : 
2
strstr : while : 	raw_spin_unlock_irq(&cfs_b->lock); : 
2
str : 	for_each_possible_cpu(i) {[27]
strstr : INIT : 	for_each_possible_cpu(i) { : 
2
strstr : if : 	for_each_possible_cpu(i) { : 
2
strstr : for : 	for_each_possible_cpu(i) { : 
2
strstr : while : 	for_each_possible_cpu(i) { : 
2
str : 		struct cfs_rq *cfs_rq = tg->cfs_rq[i];[40]
strstr : INIT : 		struct cfs_rq *cfs_rq = tg->cfs_rq[i]; : 
2
strstr : if : 		struct cfs_rq *cfs_rq = tg->cfs_rq[i]; : 
2
strstr : for : 		struct cfs_rq *cfs_rq = tg->cfs_rq[i]; : 
2
strstr : while : 		struct cfs_rq *cfs_rq = tg->cfs_rq[i]; : 
2
str : 		struct rq *rq = cfs_rq->rq;[29]
strstr : INIT : 		struct rq *rq = cfs_rq->rq; : 
2
strstr : if : 		struct rq *rq = cfs_rq->rq; : 
2
strstr : for : 		struct rq *rq = cfs_rq->rq; : 
2
strstr : while : 		struct rq *rq = cfs_rq->rq; : 
2
str : 		raw_spin_lock_irq(&rq->lock);[31]
strstr : INIT : 		raw_spin_lock_irq(&rq->lock); : 
2
strstr : if : 		raw_spin_lock_irq(&rq->lock); : 
2
strstr : for : 		raw_spin_lock_irq(&rq->lock); : 
2
strstr : while : 		raw_spin_lock_irq(&rq->lock); : 
2
str : 		cfs_rq->runtime_enabled = runtime_enabled;[44]
strstr : INIT : 		cfs_rq->runtime_enabled = runtime_enabled; : 
2
strstr : if : 		cfs_rq->runtime_enabled = runtime_enabled; : 
2
strstr : for : 		cfs_rq->runtime_enabled = runtime_enabled; : 
2
strstr : while : 		cfs_rq->runtime_enabled = runtime_enabled; : 
2
str : 		cfs_rq->runtime_remaining = 0;[32]
strstr : INIT : 		cfs_rq->runtime_remaining = 0; : 
2
strstr : if : 		cfs_rq->runtime_remaining = 0; : 
2
strstr : for : 		cfs_rq->runtime_remaining = 0; : 
2
strstr : while : 		cfs_rq->runtime_remaining = 0; : 
2
str : 		if (cfs_rq->throttled)[24]
strstr : INIT : 		if (cfs_rq->throttled) : 
2
strstr : if : 		if (cfs_rq->throttled) : 
2
strstr : for : 		if (cfs_rq->throttled) : 
2
strstr : while : 		if (cfs_rq->throttled) : 
2
str : 			unthrottle_cfs_rq(cfs_rq);[29]
strstr : INIT : 			unthrottle_cfs_rq(cfs_rq); : 
2
strstr : if : 			unthrottle_cfs_rq(cfs_rq); : 
2
strstr : for : 			unthrottle_cfs_rq(cfs_rq); : 
2
strstr : while : 			unthrottle_cfs_rq(cfs_rq); : 
2
str : 		raw_spin_unlock_irq(&rq->lock);[33]
strstr : INIT : 		raw_spin_unlock_irq(&rq->lock); : 
2
strstr : if : 		raw_spin_unlock_irq(&rq->lock); : 
2
strstr : for : 		raw_spin_unlock_irq(&rq->lock); : 
2
strstr : while : 		raw_spin_unlock_irq(&rq->lock); : 
2
str : 	if (runtime_was_enabled && !runtime_enabled)[45]
strstr : INIT : 	if (runtime_was_enabled && !runtime_enabled) : 
2
strstr : if : 	if (runtime_was_enabled && !runtime_enabled) : 
2
strstr : for : 	if (runtime_was_enabled && !runtime_enabled) : 
2
strstr : while : 	if (runtime_was_enabled && !runtime_enabled) : 
2
str : 		cfs_bandwidth_usage_dec();[28]
strstr : INIT : 		cfs_bandwidth_usage_dec(); : 
2
strstr : if : 		cfs_bandwidth_usage_dec(); : 
2
strstr : for : 		cfs_bandwidth_usage_dec(); : 
2
strstr : while : 		cfs_bandwidth_usage_dec(); : 
2
str : out_unlock:[11]
strstr : INIT : out_unlock: : 
2
strstr : if : out_unlock: : 
2
strstr : for : out_unlock: : 
2
strstr : while : out_unlock: : 
2
str : 	mutex_unlock(&cfs_constraints_mutex);[38]
strstr : INIT : 	mutex_unlock(&cfs_constraints_mutex); : 
2
strstr : if : 	mutex_unlock(&cfs_constraints_mutex); : 
2
strstr : for : 	mutex_unlock(&cfs_constraints_mutex); : 
2
strstr : while : 	mutex_unlock(&cfs_constraints_mutex); : 
2
str : 	return ret;[12]
strstr : INIT : 	return ret; : 
2
strstr : if : 	return ret; : 
2
strstr : for : 	return ret; : 
2
strstr : while : 	return ret; : 
2
str : int tg_set_cfs_quota(struct task_group *tg, long cfs_quota_us)[62]
strstr : INIT : int tg_set_cfs_quota(struct task_group *tg, long cfs_quota_us) : 
2
strstr : if : int tg_set_cfs_quota(struct task_group *tg, long cfs_quota_us) : 
2
strstr : for : int tg_set_cfs_quota(struct task_group *tg, long cfs_quota_us) : 
2
strstr : while : int tg_set_cfs_quota(struct task_group *tg, long cfs_quota_us) : 
2
str : 	u64 quota, period;[19]
strstr : INIT : 	u64 quota, period; : 
2
strstr : if : 	u64 quota, period; : 
2
strstr : for : 	u64 quota, period; : 
2
strstr : while : 	u64 quota, period; : 
2
str : 	period = ktime_to_ns(tg->cfs_bandwidth.period);[48]
strstr : INIT : 	period = ktime_to_ns(tg->cfs_bandwidth.period); : 
2
strstr : if : 	period = ktime_to_ns(tg->cfs_bandwidth.period); : 
2
strstr : for : 	period = ktime_to_ns(tg->cfs_bandwidth.period); : 
2
strstr : while : 	period = ktime_to_ns(tg->cfs_bandwidth.period); : 
2
str : 	if (cfs_quota_us < 0)[22]
strstr : INIT : 	if (cfs_quota_us < 0) : 
2
strstr : if : 	if (cfs_quota_us < 0) : 
2
strstr : for : 	if (cfs_quota_us < 0) : 
2
strstr : while : 	if (cfs_quota_us < 0) : 
2
str : 		quota = RUNTIME_INF;[22]
strstr : INIT : 		quota = RUNTIME_INF; : 
2
strstr : if : 		quota = RUNTIME_INF; : 
2
strstr : for : 		quota = RUNTIME_INF; : 
2
strstr : while : 		quota = RUNTIME_INF; : 
2
str : 	else[5]
strstr : INIT : 	else : 
2
strstr : if : 	else : 
2
strstr : for : 	else : 
2
strstr : while : 	else : 
2
str : 		quota = (u64)cfs_quota_us * NSEC_PER_USEC;[44]
strstr : INIT : 		quota = (u64)cfs_quota_us * NSEC_PER_USEC; : 
2
strstr : if : 		quota = (u64)cfs_quota_us * NSEC_PER_USEC; : 
2
strstr : for : 		quota = (u64)cfs_quota_us * NSEC_PER_USEC; : 
2
strstr : while : 		quota = (u64)cfs_quota_us * NSEC_PER_USEC; : 
2
str : 	return tg_set_cfs_bandwidth(tg, period, quota);[48]
strstr : INIT : 	return tg_set_cfs_bandwidth(tg, period, quota); : 
2
strstr : if : 	return tg_set_cfs_bandwidth(tg, period, quota); : 
2
strstr : for : 	return tg_set_cfs_bandwidth(tg, period, quota); : 
2
strstr : while : 	return tg_set_cfs_bandwidth(tg, period, quota); : 
2
str : long tg_get_cfs_quota(struct task_group *tg)[44]
strstr : INIT : long tg_get_cfs_quota(struct task_group *tg) : 
2
strstr : if : long tg_get_cfs_quota(struct task_group *tg) : 
2
strstr : for : long tg_get_cfs_quota(struct task_group *tg) : 
2
strstr : while : long tg_get_cfs_quota(struct task_group *tg) : 
2
str : 	u64 quota_us;[14]
strstr : INIT : 	u64 quota_us; : 
2
strstr : if : 	u64 quota_us; : 
2
strstr : for : 	u64 quota_us; : 
2
strstr : while : 	u64 quota_us; : 
2
str : 	if (tg->cfs_bandwidth.quota == RUNTIME_INF)[44]
strstr : INIT : 	if (tg->cfs_bandwidth.quota == RUNTIME_INF) : 
2
strstr : if : 	if (tg->cfs_bandwidth.quota == RUNTIME_INF) : 
2
strstr : for : 	if (tg->cfs_bandwidth.quota == RUNTIME_INF) : 
2
strstr : while : 	if (tg->cfs_bandwidth.quota == RUNTIME_INF) : 
2
str : 		return -1;[12]
strstr : INIT : 		return -1; : 
2
strstr : if : 		return -1; : 
2
strstr : for : 		return -1; : 
2
strstr : while : 		return -1; : 
2
str : 	quota_us = tg->cfs_bandwidth.quota;[36]
strstr : INIT : 	quota_us = tg->cfs_bandwidth.quota; : 
2
strstr : if : 	quota_us = tg->cfs_bandwidth.quota; : 
2
strstr : for : 	quota_us = tg->cfs_bandwidth.quota; : 
2
strstr : while : 	quota_us = tg->cfs_bandwidth.quota; : 
2
str : 	do_div(quota_us, NSEC_PER_USEC);[33]
strstr : INIT : 	do_div(quota_us, NSEC_PER_USEC); : 
2
strstr : if : 	do_div(quota_us, NSEC_PER_USEC); : 
2
strstr : for : 	do_div(quota_us, NSEC_PER_USEC); : 
2
strstr : while : 	do_div(quota_us, NSEC_PER_USEC); : 
2
str : 	return quota_us;[17]
strstr : INIT : 	return quota_us; : 
2
strstr : if : 	return quota_us; : 
2
strstr : for : 	return quota_us; : 
2
strstr : while : 	return quota_us; : 
2
str : int tg_set_cfs_period(struct task_group *tg, long cfs_period_us)[64]
strstr : INIT : int tg_set_cfs_period(struct task_group *tg, long cfs_period_us) : 
2
strstr : if : int tg_set_cfs_period(struct task_group *tg, long cfs_period_us) : 
2
strstr : for : int tg_set_cfs_period(struct task_group *tg, long cfs_period_us) : 
2
strstr : while : int tg_set_cfs_period(struct task_group *tg, long cfs_period_us) : 
2
str : 	u64 quota, period;[19]
strstr : INIT : 	u64 quota, period; : 
2
strstr : if : 	u64 quota, period; : 
2
strstr : for : 	u64 quota, period; : 
2
strstr : while : 	u64 quota, period; : 
2
str : 	period = (u64)cfs_period_us * NSEC_PER_USEC;[45]
strstr : INIT : 	period = (u64)cfs_period_us * NSEC_PER_USEC; : 
2
strstr : if : 	period = (u64)cfs_period_us * NSEC_PER_USEC; : 
2
strstr : for : 	period = (u64)cfs_period_us * NSEC_PER_USEC; : 
2
strstr : while : 	period = (u64)cfs_period_us * NSEC_PER_USEC; : 
2
str : 	quota = tg->cfs_bandwidth.quota;[33]
strstr : INIT : 	quota = tg->cfs_bandwidth.quota; : 
2
strstr : if : 	quota = tg->cfs_bandwidth.quota; : 
2
strstr : for : 	quota = tg->cfs_bandwidth.quota; : 
2
strstr : while : 	quota = tg->cfs_bandwidth.quota; : 
2
str : 	return tg_set_cfs_bandwidth(tg, period, quota);[48]
strstr : INIT : 	return tg_set_cfs_bandwidth(tg, period, quota); : 
2
strstr : if : 	return tg_set_cfs_bandwidth(tg, period, quota); : 
2
strstr : for : 	return tg_set_cfs_bandwidth(tg, period, quota); : 
2
strstr : while : 	return tg_set_cfs_bandwidth(tg, period, quota); : 
2
str : long tg_get_cfs_period(struct task_group *tg)[45]
strstr : INIT : long tg_get_cfs_period(struct task_group *tg) : 
2
strstr : if : long tg_get_cfs_period(struct task_group *tg) : 
2
strstr : for : long tg_get_cfs_period(struct task_group *tg) : 
2
strstr : while : long tg_get_cfs_period(struct task_group *tg) : 
2
str : 	u64 cfs_period_us;[19]
strstr : INIT : 	u64 cfs_period_us; : 
2
strstr : if : 	u64 cfs_period_us; : 
2
strstr : for : 	u64 cfs_period_us; : 
2
strstr : while : 	u64 cfs_period_us; : 
2
str : 	cfs_period_us = ktime_to_ns(tg->cfs_bandwidth.period);[55]
strstr : INIT : 	cfs_period_us = ktime_to_ns(tg->cfs_bandwidth.period); : 
2
strstr : if : 	cfs_period_us = ktime_to_ns(tg->cfs_bandwidth.period); : 
2
strstr : for : 	cfs_period_us = ktime_to_ns(tg->cfs_bandwidth.period); : 
2
strstr : while : 	cfs_period_us = ktime_to_ns(tg->cfs_bandwidth.period); : 
2
str : 	do_div(cfs_period_us, NSEC_PER_USEC);[38]
strstr : INIT : 	do_div(cfs_period_us, NSEC_PER_USEC); : 
2
strstr : if : 	do_div(cfs_period_us, NSEC_PER_USEC); : 
2
strstr : for : 	do_div(cfs_period_us, NSEC_PER_USEC); : 
2
strstr : while : 	do_div(cfs_period_us, NSEC_PER_USEC); : 
2
str : 	return cfs_period_us;[22]
strstr : INIT : 	return cfs_period_us; : 
2
strstr : if : 	return cfs_period_us; : 
2
strstr : for : 	return cfs_period_us; : 
2
strstr : while : 	return cfs_period_us; : 
2
str : static s64 cpu_cfs_quota_read_s64(struct cgroup_subsys_state *css,[66]
strstr : INIT : static s64 cpu_cfs_quota_read_s64(struct cgroup_subsys_state *css, : 
2
strstr : if : static s64 cpu_cfs_quota_read_s64(struct cgroup_subsys_state *css, : 
2
strstr : for : static s64 cpu_cfs_quota_read_s64(struct cgroup_subsys_state *css, : 
2
strstr : while : static s64 cpu_cfs_quota_read_s64(struct cgroup_subsys_state *css, : 
2
str : 				  struct cftype *cft)[25]
strstr : INIT : 				  struct cftype *cft) : 
2
strstr : if : 				  struct cftype *cft) : 
2
strstr : for : 				  struct cftype *cft) : 
2
strstr : while : 				  struct cftype *cft) : 
2
str : 	return tg_get_cfs_quota(css_tg(css));[38]
strstr : INIT : 	return tg_get_cfs_quota(css_tg(css)); : 
2
strstr : if : 	return tg_get_cfs_quota(css_tg(css)); : 
2
strstr : for : 	return tg_get_cfs_quota(css_tg(css)); : 
2
strstr : while : 	return tg_get_cfs_quota(css_tg(css)); : 
2
str : static int cpu_cfs_quota_write_s64(struct cgroup_subsys_state *css,[67]
strstr : INIT : static int cpu_cfs_quota_write_s64(struct cgroup_subsys_state *css, : 
2
strstr : if : static int cpu_cfs_quota_write_s64(struct cgroup_subsys_state *css, : 
2
strstr : for : static int cpu_cfs_quota_write_s64(struct cgroup_subsys_state *css, : 
2
strstr : while : static int cpu_cfs_quota_write_s64(struct cgroup_subsys_state *css, : 
2
str : 				   struct cftype *cftype, s64 cfs_quota_us)[47]
strstr : INIT : 				   struct cftype *cftype, s64 cfs_quota_us) : 
2
strstr : if : 				   struct cftype *cftype, s64 cfs_quota_us) : 
2
strstr : for : 				   struct cftype *cftype, s64 cfs_quota_us) : 
2
strstr : while : 				   struct cftype *cftype, s64 cfs_quota_us) : 
2
str : 	return tg_set_cfs_quota(css_tg(css), cfs_quota_us);[52]
strstr : INIT : 	return tg_set_cfs_quota(css_tg(css), cfs_quota_us); : 
2
strstr : if : 	return tg_set_cfs_quota(css_tg(css), cfs_quota_us); : 
2
strstr : for : 	return tg_set_cfs_quota(css_tg(css), cfs_quota_us); : 
2
strstr : while : 	return tg_set_cfs_quota(css_tg(css), cfs_quota_us); : 
2
str : static u64 cpu_cfs_period_read_u64(struct cgroup_subsys_state *css,[67]
strstr : INIT : static u64 cpu_cfs_period_read_u64(struct cgroup_subsys_state *css, : 
2
strstr : if : static u64 cpu_cfs_period_read_u64(struct cgroup_subsys_state *css, : 
2
strstr : for : static u64 cpu_cfs_period_read_u64(struct cgroup_subsys_state *css, : 
2
strstr : while : static u64 cpu_cfs_period_read_u64(struct cgroup_subsys_state *css, : 
2
str : 				   struct cftype *cft)[26]
strstr : INIT : 				   struct cftype *cft) : 
2
strstr : if : 				   struct cftype *cft) : 
2
strstr : for : 				   struct cftype *cft) : 
2
strstr : while : 				   struct cftype *cft) : 
2
str : 	return tg_get_cfs_period(css_tg(css));[39]
strstr : INIT : 	return tg_get_cfs_period(css_tg(css)); : 
2
strstr : if : 	return tg_get_cfs_period(css_tg(css)); : 
2
strstr : for : 	return tg_get_cfs_period(css_tg(css)); : 
2
strstr : while : 	return tg_get_cfs_period(css_tg(css)); : 
2
str : static int cpu_cfs_period_write_u64(struct cgroup_subsys_state *css,[68]
strstr : INIT : static int cpu_cfs_period_write_u64(struct cgroup_subsys_state *css, : 
2
strstr : if : static int cpu_cfs_period_write_u64(struct cgroup_subsys_state *css, : 
2
strstr : for : static int cpu_cfs_period_write_u64(struct cgroup_subsys_state *css, : 
2
strstr : while : static int cpu_cfs_period_write_u64(struct cgroup_subsys_state *css, : 
2
str : 				    struct cftype *cftype, u64 cfs_period_us)[49]
strstr : INIT : 				    struct cftype *cftype, u64 cfs_period_us) : 
2
strstr : if : 				    struct cftype *cftype, u64 cfs_period_us) : 
2
strstr : for : 				    struct cftype *cftype, u64 cfs_period_us) : 
2
strstr : while : 				    struct cftype *cftype, u64 cfs_period_us) : 
2
str : 	return tg_set_cfs_period(css_tg(css), cfs_period_us);[54]
strstr : INIT : 	return tg_set_cfs_period(css_tg(css), cfs_period_us); : 
2
strstr : if : 	return tg_set_cfs_period(css_tg(css), cfs_period_us); : 
2
strstr : for : 	return tg_set_cfs_period(css_tg(css), cfs_period_us); : 
2
strstr : while : 	return tg_set_cfs_period(css_tg(css), cfs_period_us); : 
2
str : struct cfs_schedulable_data {[29]
strstr : INIT : struct cfs_schedulable_data { : 
2
strstr : if : struct cfs_schedulable_data { : 
2
strstr : for : struct cfs_schedulable_data { : 
2
strstr : while : struct cfs_schedulable_data { : 
2
str : 	struct task_group *tg;[23]
strstr : INIT : 	struct task_group *tg; : 
2
strstr : if : 	struct task_group *tg; : 
2
strstr : for : 	struct task_group *tg; : 
2
strstr : while : 	struct task_group *tg; : 
2
str : 	u64 period, quota;[19]
strstr : INIT : 	u64 period, quota; : 
2
strstr : if : 	u64 period, quota; : 
2
strstr : for : 	u64 period, quota; : 
2
strstr : while : 	u64 period, quota; : 
2
str :  * normalize group quota/period to be quota/max_period[54]
strstr : INIT :  * normalize group quota/period to be quota/max_period : 
2
strstr : if :  * normalize group quota/period to be quota/max_period : 
2
strstr : for :  * normalize group quota/period to be quota/max_period : 
2
strstr : while :  * normalize group quota/period to be quota/max_period : 
2
str :  * note: units are usecs[24]
strstr : INIT :  * note: units are usecs : 
2
strstr : if :  * note: units are usecs : 
2
strstr : for :  * note: units are usecs : 
2
strstr : while :  * note: units are usecs : 
2
str :  */[3]
strstr : INIT :  */ : 
2
strstr : if :  */ : 
2
strstr : for :  */ : 
2
strstr : while :  */ : 
2
str : static u64 normalize_cfs_quota(struct task_group *tg,[53]
strstr : INIT : static u64 normalize_cfs_quota(struct task_group *tg, : 
2
strstr : if : static u64 normalize_cfs_quota(struct task_group *tg, : 
2
strstr : for : static u64 normalize_cfs_quota(struct task_group *tg, : 
2
strstr : while : static u64 normalize_cfs_quota(struct task_group *tg, : 
2
str : 			       struct cfs_schedulable_data *d)[41]
strstr : INIT : 			       struct cfs_schedulable_data *d) : 
2
strstr : if : 			       struct cfs_schedulable_data *d) : 
2
strstr : for : 			       struct cfs_schedulable_data *d) : 
2
strstr : while : 			       struct cfs_schedulable_data *d) : 
2
str : 	u64 quota, period;[19]
strstr : INIT : 	u64 quota, period; : 
2
strstr : if : 	u64 quota, period; : 
2
strstr : for : 	u64 quota, period; : 
2
strstr : while : 	u64 quota, period; : 
2
str : 	if (tg == d->tg) {[19]
strstr : INIT : 	if (tg == d->tg) { : 
2
strstr : if : 	if (tg == d->tg) { : 
2
strstr : for : 	if (tg == d->tg) { : 
2
strstr : while : 	if (tg == d->tg) { : 
2
str : 		period = d->period;[21]
strstr : INIT : 		period = d->period; : 
2
strstr : if : 		period = d->period; : 
2
strstr : for : 		period = d->period; : 
2
strstr : while : 		period = d->period; : 
2
str : 		quota = d->quota;[19]
strstr : INIT : 		quota = d->quota; : 
2
strstr : if : 		quota = d->quota; : 
2
strstr : for : 		quota = d->quota; : 
2
strstr : while : 		quota = d->quota; : 
2
str : 	} else {[9]
strstr : INIT : 	} else { : 
2
strstr : if : 	} else { : 
2
strstr : for : 	} else { : 
2
strstr : while : 	} else { : 
2
str : 		period = tg_get_cfs_period(tg);[33]
strstr : INIT : 		period = tg_get_cfs_period(tg); : 
2
strstr : if : 		period = tg_get_cfs_period(tg); : 
2
strstr : for : 		period = tg_get_cfs_period(tg); : 
2
strstr : while : 		period = tg_get_cfs_period(tg); : 
2
str : 		quota = tg_get_cfs_quota(tg);[31]
strstr : INIT : 		quota = tg_get_cfs_quota(tg); : 
2
strstr : if : 		quota = tg_get_cfs_quota(tg); : 
2
strstr : for : 		quota = tg_get_cfs_quota(tg); : 
2
strstr : while : 		quota = tg_get_cfs_quota(tg); : 
2
str : 	/* note: these should typically be equivalent */[49]
strstr : INIT : 	/* note: these should typically be equivalent */ : 
2
strstr : if : 	/* note: these should typically be equivalent */ : 
2
strstr : for : 	/* note: these should typically be equivalent */ : 
2
strstr : while : 	/* note: these should typically be equivalent */ : 
2
str : 	if (quota == RUNTIME_INF || quota == -1)[41]
strstr : INIT : 	if (quota == RUNTIME_INF || quota == -1) : 
2
strstr : if : 	if (quota == RUNTIME_INF || quota == -1) : 
2
strstr : for : 	if (quota == RUNTIME_INF || quota == -1) : 
2
strstr : while : 	if (quota == RUNTIME_INF || quota == -1) : 
2
str : 		return RUNTIME_INF;[21]
strstr : INIT : 		return RUNTIME_INF; : 
2
strstr : if : 		return RUNTIME_INF; : 
2
strstr : for : 		return RUNTIME_INF; : 
2
strstr : while : 		return RUNTIME_INF; : 
2
str : 	return to_ratio(period, quota);[32]
strstr : INIT : 	return to_ratio(period, quota); : 
2
strstr : if : 	return to_ratio(period, quota); : 
2
strstr : for : 	return to_ratio(period, quota); : 
2
strstr : while : 	return to_ratio(period, quota); : 
2
str : static int tg_cfs_schedulable_down(struct task_group *tg, void *data)[69]
strstr : INIT : static int tg_cfs_schedulable_down(struct task_group *tg, void *data) : 
2
strstr : if : static int tg_cfs_schedulable_down(struct task_group *tg, void *data) : 
2
strstr : for : static int tg_cfs_schedulable_down(struct task_group *tg, void *data) : 
2
strstr : while : static int tg_cfs_schedulable_down(struct task_group *tg, void *data) : 
2
str : 	struct cfs_schedulable_data *d = data;[39]
strstr : INIT : 	struct cfs_schedulable_data *d = data; : 
2
strstr : if : 	struct cfs_schedulable_data *d = data; : 
2
strstr : for : 	struct cfs_schedulable_data *d = data; : 
2
strstr : while : 	struct cfs_schedulable_data *d = data; : 
2
str : 	struct cfs_bandwidth *cfs_b = &tg->cfs_bandwidth;[50]
strstr : INIT : 	struct cfs_bandwidth *cfs_b = &tg->cfs_bandwidth; : 
2
strstr : if : 	struct cfs_bandwidth *cfs_b = &tg->cfs_bandwidth; : 
2
strstr : for : 	struct cfs_bandwidth *cfs_b = &tg->cfs_bandwidth; : 
2
strstr : while : 	struct cfs_bandwidth *cfs_b = &tg->cfs_bandwidth; : 
2
str : 	s64 quota = 0, parent_quota = -1;[34]
strstr : INIT : 	s64 quota = 0, parent_quota = -1; : 
2
strstr : if : 	s64 quota = 0, parent_quota = -1; : 
2
strstr : for : 	s64 quota = 0, parent_quota = -1; : 
2
strstr : while : 	s64 quota = 0, parent_quota = -1; : 
2
str : 	if (!tg->parent) {[19]
strstr : INIT : 	if (!tg->parent) { : 
2
strstr : if : 	if (!tg->parent) { : 
2
strstr : for : 	if (!tg->parent) { : 
2
strstr : while : 	if (!tg->parent) { : 
2
str : 		quota = RUNTIME_INF;[22]
strstr : INIT : 		quota = RUNTIME_INF; : 
2
strstr : if : 		quota = RUNTIME_INF; : 
2
strstr : for : 		quota = RUNTIME_INF; : 
2
strstr : while : 		quota = RUNTIME_INF; : 
2
str : 	} else {[9]
strstr : INIT : 	} else { : 
2
strstr : if : 	} else { : 
2
strstr : for : 	} else { : 
2
strstr : while : 	} else { : 
2
str : 		struct cfs_bandwidth *parent_b = &tg->parent->cfs_bandwidth;[62]
strstr : INIT : 		struct cfs_bandwidth *parent_b = &tg->parent->cfs_bandwidth; : 
2
strstr : if : 		struct cfs_bandwidth *parent_b = &tg->parent->cfs_bandwidth; : 
2
strstr : for : 		struct cfs_bandwidth *parent_b = &tg->parent->cfs_bandwidth; : 
2
strstr : while : 		struct cfs_bandwidth *parent_b = &tg->parent->cfs_bandwidth; : 
2
str : 		quota = normalize_cfs_quota(tg, d);[37]
strstr : INIT : 		quota = normalize_cfs_quota(tg, d); : 
2
strstr : if : 		quota = normalize_cfs_quota(tg, d); : 
2
strstr : for : 		quota = normalize_cfs_quota(tg, d); : 
2
strstr : while : 		quota = normalize_cfs_quota(tg, d); : 
2
str : 		parent_quota = parent_b->hierarchal_quota;[44]
strstr : INIT : 		parent_quota = parent_b->hierarchal_quota; : 
2
strstr : if : 		parent_quota = parent_b->hierarchal_quota; : 
2
strstr : for : 		parent_quota = parent_b->hierarchal_quota; : 
2
strstr : while : 		parent_quota = parent_b->hierarchal_quota; : 
2
str : 		/*[4]
strstr : INIT : 		/* : 
2
strstr : if : 		/* : 
2
strstr : for : 		/* : 
2
strstr : while : 		/* : 
2
str : 		 * ensure max(child_quota) <= parent_quota, inherit when no[61]
strstr : INIT : 		 * ensure max(child_quota) <= parent_quota, inherit when no : 
2
strstr : if : 		 * ensure max(child_quota) <= parent_quota, inherit when no : 
2
strstr : for : 		 * ensure max(child_quota) <= parent_quota, inherit when no : 
2
strstr : while : 		 * ensure max(child_quota) <= parent_quota, inherit when no : 
2
str : 		 * limit is set[17]
strstr : INIT : 		 * limit is set : 
2
strstr : if : 		 * limit is set : 
2
strstr : for : 		 * limit is set : 
2
strstr : while : 		 * limit is set : 
2
str : 		 */[5]
strstr : INIT : 		 */ : 
2
strstr : if : 		 */ : 
2
strstr : for : 		 */ : 
2
strstr : while : 		 */ : 
2
str : 		if (quota == RUNTIME_INF)[27]
strstr : INIT : 		if (quota == RUNTIME_INF) : 
2
strstr : if : 		if (quota == RUNTIME_INF) : 
2
strstr : for : 		if (quota == RUNTIME_INF) : 
2
strstr : while : 		if (quota == RUNTIME_INF) : 
2
str : 			quota = parent_quota;[24]
strstr : INIT : 			quota = parent_quota; : 
2
strstr : if : 			quota = parent_quota; : 
2
strstr : for : 			quota = parent_quota; : 
2
strstr : while : 			quota = parent_quota; : 
2
str : 		else if (parent_quota != RUNTIME_INF && quota > parent_quota)[63]
strstr : INIT : 		else if (parent_quota != RUNTIME_INF && quota > parent_quota) : 
2
strstr : if : 		else if (parent_quota != RUNTIME_INF && quota > parent_quota) : 
2
strstr : for : 		else if (parent_quota != RUNTIME_INF && quota > parent_quota) : 
2
strstr : while : 		else if (parent_quota != RUNTIME_INF && quota > parent_quota) : 
2
str : 			return -EINVAL;[18]
strstr : INIT : 			return -EINVAL; : 
2
strstr : if : 			return -EINVAL; : 
2
strstr : for : 			return -EINVAL; : 
2
strstr : while : 			return -EINVAL; : 
2
str : 	cfs_b->hierarchal_quota = quota;[33]
strstr : INIT : 	cfs_b->hierarchal_quota = quota; : 
2
strstr : if : 	cfs_b->hierarchal_quota = quota; : 
2
strstr : for : 	cfs_b->hierarchal_quota = quota; : 
2
strstr : while : 	cfs_b->hierarchal_quota = quota; : 
2
str : 	return 0;[10]
strstr : INIT : 	return 0; : 
2
strstr : if : 	return 0; : 
2
strstr : for : 	return 0; : 
2
strstr : while : 	return 0; : 
2
str : static int __cfs_schedulable(struct task_group *tg, u64 period, u64 quota)[74]
strstr : INIT : static int __cfs_schedulable(struct task_group *tg, u64 period, u64 quota) : 
2
strstr : if : static int __cfs_schedulable(struct task_group *tg, u64 period, u64 quota) : 
2
strstr : for : static int __cfs_schedulable(struct task_group *tg, u64 period, u64 quota) : 
2
strstr : while : static int __cfs_schedulable(struct task_group *tg, u64 period, u64 quota) : 
2
str : 	int ret;[9]
strstr : INIT : 	int ret; : 
2
strstr : if : 	int ret; : 
2
strstr : for : 	int ret; : 
2
strstr : while : 	int ret; : 
2
str : 	struct cfs_schedulable_data data = {[37]
strstr : INIT : 	struct cfs_schedulable_data data = { : 
2
strstr : if : 	struct cfs_schedulable_data data = { : 
2
strstr : for : 	struct cfs_schedulable_data data = { : 
2
strstr : while : 	struct cfs_schedulable_data data = { : 
2
str : 		.tg = tg,[11]
strstr : INIT : 		.tg = tg, : 
2
strstr : if : 		.tg = tg, : 
2
strstr : for : 		.tg = tg, : 
2
strstr : while : 		.tg = tg, : 
2
str : 		.period = period,[19]
strstr : INIT : 		.period = period, : 
2
strstr : if : 		.period = period, : 
2
strstr : for : 		.period = period, : 
2
strstr : while : 		.period = period, : 
2
str : 		.quota = quota,[17]
strstr : INIT : 		.quota = quota, : 
2
strstr : if : 		.quota = quota, : 
2
strstr : for : 		.quota = quota, : 
2
strstr : while : 		.quota = quota, : 
2
str : 	};[3]
strstr : INIT : 	}; : 
2
strstr : if : 	}; : 
2
strstr : for : 	}; : 
2
strstr : while : 	}; : 
2
str : 	if (quota != RUNTIME_INF) {[28]
strstr : INIT : 	if (quota != RUNTIME_INF) { : 
2
strstr : if : 	if (quota != RUNTIME_INF) { : 
2
strstr : for : 	if (quota != RUNTIME_INF) { : 
2
strstr : while : 	if (quota != RUNTIME_INF) { : 
2
str : 		do_div(data.period, NSEC_PER_USEC);[37]
strstr : INIT : 		do_div(data.period, NSEC_PER_USEC); : 
2
strstr : if : 		do_div(data.period, NSEC_PER_USEC); : 
2
strstr : for : 		do_div(data.period, NSEC_PER_USEC); : 
2
strstr : while : 		do_div(data.period, NSEC_PER_USEC); : 
2
str : 		do_div(data.quota, NSEC_PER_USEC);[36]
strstr : INIT : 		do_div(data.quota, NSEC_PER_USEC); : 
2
strstr : if : 		do_div(data.quota, NSEC_PER_USEC); : 
2
strstr : for : 		do_div(data.quota, NSEC_PER_USEC); : 
2
strstr : while : 		do_div(data.quota, NSEC_PER_USEC); : 
2
str : 	rcu_read_lock();[17]
strstr : INIT : 	rcu_read_lock(); : 
2
strstr : if : 	rcu_read_lock(); : 
2
strstr : for : 	rcu_read_lock(); : 
2
strstr : while : 	rcu_read_lock(); : 
2
str : 	ret = walk_tg_tree(tg_cfs_schedulable_down, tg_nop, &data);[60]
strstr : INIT : 	ret = walk_tg_tree(tg_cfs_schedulable_down, tg_nop, &data); : 
2
strstr : if : 	ret = walk_tg_tree(tg_cfs_schedulable_down, tg_nop, &data); : 
2
strstr : for : 	ret = walk_tg_tree(tg_cfs_schedulable_down, tg_nop, &data); : 
2
strstr : while : 	ret = walk_tg_tree(tg_cfs_schedulable_down, tg_nop, &data); : 
2
str : 	rcu_read_unlock();[19]
strstr : INIT : 	rcu_read_unlock(); : 
2
strstr : if : 	rcu_read_unlock(); : 
2
strstr : for : 	rcu_read_unlock(); : 
2
strstr : while : 	rcu_read_unlock(); : 
2
str : 	return ret;[12]
strstr : INIT : 	return ret; : 
2
strstr : if : 	return ret; : 
2
strstr : for : 	return ret; : 
2
strstr : while : 	return ret; : 
2
str : static int cpu_stats_show(struct seq_file *sf, void *v)[55]
strstr : INIT : static int cpu_stats_show(struct seq_file *sf, void *v) : 
2
strstr : if : static int cpu_stats_show(struct seq_file *sf, void *v) : 
2
strstr : for : static int cpu_stats_show(struct seq_file *sf, void *v) : 
2
strstr : while : static int cpu_stats_show(struct seq_file *sf, void *v) : 
2
str : 	struct task_group *tg = css_tg(seq_css(sf));[45]
strstr : INIT : 	struct task_group *tg = css_tg(seq_css(sf)); : 
2
strstr : if : 	struct task_group *tg = css_tg(seq_css(sf)); : 
2
strstr : for : 	struct task_group *tg = css_tg(seq_css(sf)); : 
2
strstr : while : 	struct task_group *tg = css_tg(seq_css(sf)); : 
2
str : 	struct cfs_bandwidth *cfs_b = &tg->cfs_bandwidth;[50]
strstr : INIT : 	struct cfs_bandwidth *cfs_b = &tg->cfs_bandwidth; : 
2
strstr : if : 	struct cfs_bandwidth *cfs_b = &tg->cfs_bandwidth; : 
2
strstr : for : 	struct cfs_bandwidth *cfs_b = &tg->cfs_bandwidth; : 
2
strstr : while : 	struct cfs_bandwidth *cfs_b = &tg->cfs_bandwidth; : 
2
str : 	seq_printf(sf, "nr_periods %d\n", cfs_b->nr_periods);[54]
strstr : INIT : 	seq_printf(sf, "nr_periods %d\n", cfs_b->nr_periods); : 
2
strstr : if : 	seq_printf(sf, "nr_periods %d\n", cfs_b->nr_periods); : 
2
strstr : for : 	seq_printf(sf, "nr_periods %d\n", cfs_b->nr_periods); : 
2
strstr : while : 	seq_printf(sf, "nr_periods %d\n", cfs_b->nr_periods); : 
2
str : 	seq_printf(sf, "nr_throttled %d\n", cfs_b->nr_throttled);[58]
strstr : INIT : 	seq_printf(sf, "nr_throttled %d\n", cfs_b->nr_throttled); : 
2
strstr : if : 	seq_printf(sf, "nr_throttled %d\n", cfs_b->nr_throttled); : 
2
strstr : for : 	seq_printf(sf, "nr_throttled %d\n", cfs_b->nr_throttled); : 
2
strstr : while : 	seq_printf(sf, "nr_throttled %d\n", cfs_b->nr_throttled); : 
2
str : 	seq_printf(sf, "throttled_time %llu\n", cfs_b->throttled_time);[64]
strstr : INIT : 	seq_printf(sf, "throttled_time %llu\n", cfs_b->throttled_time); : 
2
strstr : if : 	seq_printf(sf, "throttled_time %llu\n", cfs_b->throttled_time); : 
2
strstr : for : 	seq_printf(sf, "throttled_time %llu\n", cfs_b->throttled_time); : 
2
strstr : while : 	seq_printf(sf, "throttled_time %llu\n", cfs_b->throttled_time); : 
2
str : 	return 0;[10]
strstr : INIT : 	return 0; : 
2
strstr : if : 	return 0; : 
2
strstr : for : 	return 0; : 
2
strstr : while : 	return 0; : 
2
str : #endif /* CONFIG_CFS_BANDWIDTH */[33]
strstr : INIT : #endif /* CONFIG_CFS_BANDWIDTH */ : 
2
strstr : if : #endif /* CONFIG_CFS_BANDWIDTH */ : 
2
strstr : for : #endif /* CONFIG_CFS_BANDWIDTH */ : 
2
strstr : while : #endif /* CONFIG_CFS_BANDWIDTH */ : 
2
str : #endif /* CONFIG_FAIR_GROUP_SCHED */[36]
strstr : INIT : #endif /* CONFIG_FAIR_GROUP_SCHED */ : 
2
strstr : if : #endif /* CONFIG_FAIR_GROUP_SCHED */ : 
2
strstr : for : #endif /* CONFIG_FAIR_GROUP_SCHED */ : 
2
strstr : while : #endif /* CONFIG_FAIR_GROUP_SCHED */ : 
2
str : #ifdef CONFIG_RT_GROUP_SCHED[28]
strstr : INIT : #ifdef CONFIG_RT_GROUP_SCHED : 
2
strstr : if : #ifdef CONFIG_RT_GROUP_SCHED : 
2
strstr : for : #ifdef CONFIG_RT_GROUP_SCHED : 
2
strstr : while : #ifdef CONFIG_RT_GROUP_SCHED : 
2
str : static int cpu_rt_runtime_write(struct cgroup_subsys_state *css,[64]
strstr : INIT : static int cpu_rt_runtime_write(struct cgroup_subsys_state *css, : 
2
strstr : if : static int cpu_rt_runtime_write(struct cgroup_subsys_state *css, : 
2
strstr : for : static int cpu_rt_runtime_write(struct cgroup_subsys_state *css, : 
2
strstr : while : static int cpu_rt_runtime_write(struct cgroup_subsys_state *css, : 
2
str : 				struct cftype *cft, s64 val)[32]
strstr : INIT : 				struct cftype *cft, s64 val) : 
2
strstr : if : 				struct cftype *cft, s64 val) : 
2
strstr : for : 				struct cftype *cft, s64 val) : 
2
strstr : while : 				struct cftype *cft, s64 val) : 
2
str : 	return sched_group_set_rt_runtime(css_tg(css), val);[53]
strstr : INIT : 	return sched_group_set_rt_runtime(css_tg(css), val); : 
2
strstr : if : 	return sched_group_set_rt_runtime(css_tg(css), val); : 
2
strstr : for : 	return sched_group_set_rt_runtime(css_tg(css), val); : 
2
strstr : while : 	return sched_group_set_rt_runtime(css_tg(css), val); : 
2
str : static s64 cpu_rt_runtime_read(struct cgroup_subsys_state *css,[63]
strstr : INIT : static s64 cpu_rt_runtime_read(struct cgroup_subsys_state *css, : 
2
strstr : if : static s64 cpu_rt_runtime_read(struct cgroup_subsys_state *css, : 
2
strstr : for : static s64 cpu_rt_runtime_read(struct cgroup_subsys_state *css, : 
2
strstr : while : static s64 cpu_rt_runtime_read(struct cgroup_subsys_state *css, : 
2
str : 			       struct cftype *cft)[29]
strstr : INIT : 			       struct cftype *cft) : 
2
strstr : if : 			       struct cftype *cft) : 
2
strstr : for : 			       struct cftype *cft) : 
2
strstr : while : 			       struct cftype *cft) : 
2
str : 	return sched_group_rt_runtime(css_tg(css));[44]
strstr : INIT : 	return sched_group_rt_runtime(css_tg(css)); : 
2
strstr : if : 	return sched_group_rt_runtime(css_tg(css)); : 
2
strstr : for : 	return sched_group_rt_runtime(css_tg(css)); : 
2
strstr : while : 	return sched_group_rt_runtime(css_tg(css)); : 
2
str : static int cpu_rt_period_write_uint(struct cgroup_subsys_state *css,[68]
strstr : INIT : static int cpu_rt_period_write_uint(struct cgroup_subsys_state *css, : 
2
strstr : if : static int cpu_rt_period_write_uint(struct cgroup_subsys_state *css, : 
2
strstr : for : static int cpu_rt_period_write_uint(struct cgroup_subsys_state *css, : 
2
strstr : while : static int cpu_rt_period_write_uint(struct cgroup_subsys_state *css, : 
2
str : 				    struct cftype *cftype, u64 rt_period_us)[48]
strstr : INIT : 				    struct cftype *cftype, u64 rt_period_us) : 
2
strstr : if : 				    struct cftype *cftype, u64 rt_period_us) : 
2
strstr : for : 				    struct cftype *cftype, u64 rt_period_us) : 
2
strstr : while : 				    struct cftype *cftype, u64 rt_period_us) : 
2
str : 	return sched_group_set_rt_period(css_tg(css), rt_period_us);[61]
strstr : INIT : 	return sched_group_set_rt_period(css_tg(css), rt_period_us); : 
2
strstr : if : 	return sched_group_set_rt_period(css_tg(css), rt_period_us); : 
2
strstr : for : 	return sched_group_set_rt_period(css_tg(css), rt_period_us); : 
2
strstr : while : 	return sched_group_set_rt_period(css_tg(css), rt_period_us); : 
2
str : static u64 cpu_rt_period_read_uint(struct cgroup_subsys_state *css,[67]
strstr : INIT : static u64 cpu_rt_period_read_uint(struct cgroup_subsys_state *css, : 
2
strstr : if : static u64 cpu_rt_period_read_uint(struct cgroup_subsys_state *css, : 
2
strstr : for : static u64 cpu_rt_period_read_uint(struct cgroup_subsys_state *css, : 
2
strstr : while : static u64 cpu_rt_period_read_uint(struct cgroup_subsys_state *css, : 
2
str : 				   struct cftype *cft)[26]
strstr : INIT : 				   struct cftype *cft) : 
2
strstr : if : 				   struct cftype *cft) : 
2
strstr : for : 				   struct cftype *cft) : 
2
strstr : while : 				   struct cftype *cft) : 
2
str : 	return sched_group_rt_period(css_tg(css));[43]
strstr : INIT : 	return sched_group_rt_period(css_tg(css)); : 
2
strstr : if : 	return sched_group_rt_period(css_tg(css)); : 
2
strstr : for : 	return sched_group_rt_period(css_tg(css)); : 
2
strstr : while : 	return sched_group_rt_period(css_tg(css)); : 
2
str : #endif /* CONFIG_RT_GROUP_SCHED */[34]
strstr : INIT : #endif /* CONFIG_RT_GROUP_SCHED */ : 
2
strstr : if : #endif /* CONFIG_RT_GROUP_SCHED */ : 
2
strstr : for : #endif /* CONFIG_RT_GROUP_SCHED */ : 
2
strstr : while : #endif /* CONFIG_RT_GROUP_SCHED */ : 
2
str : static struct cftype cpu_files[] = {[36]
strstr : INIT : static struct cftype cpu_files[] = { : 
2
strstr : if : static struct cftype cpu_files[] = { : 
2
strstr : for : static struct cftype cpu_files[] = { : 
2
strstr : while : static struct cftype cpu_files[] = { : 
2
str : #ifdef CONFIG_FAIR_GROUP_SCHED[30]
strstr : INIT : #ifdef CONFIG_FAIR_GROUP_SCHED : 
2
strstr : if : #ifdef CONFIG_FAIR_GROUP_SCHED : 
2
strstr : for : #ifdef CONFIG_FAIR_GROUP_SCHED : 
2
strstr : while : #ifdef CONFIG_FAIR_GROUP_SCHED : 
2
str : 		.name = "shares",[19]
strstr : INIT : 		.name = "shares", : 
2
strstr : if : 		.name = "shares", : 
2
strstr : for : 		.name = "shares", : 
2
strstr : while : 		.name = "shares", : 
2
str : 		.read_u64 = cpu_shares_read_u64,[34]
strstr : INIT : 		.read_u64 = cpu_shares_read_u64, : 
2
strstr : if : 		.read_u64 = cpu_shares_read_u64, : 
2
strstr : for : 		.read_u64 = cpu_shares_read_u64, : 
2
strstr : while : 		.read_u64 = cpu_shares_read_u64, : 
2
str : 		.write_u64 = cpu_shares_write_u64,[36]
strstr : INIT : 		.write_u64 = cpu_shares_write_u64, : 
2
strstr : if : 		.write_u64 = cpu_shares_write_u64, : 
2
strstr : for : 		.write_u64 = cpu_shares_write_u64, : 
2
strstr : while : 		.write_u64 = cpu_shares_write_u64, : 
2
str : 	},[3]
strstr : INIT : 	}, : 
2
strstr : if : 	}, : 
2
strstr : for : 	}, : 
2
strstr : while : 	}, : 
2
str : #endif[6]
strstr : INIT : #endif : 
2
strstr : if : #endif : 
2
strstr : for : #endif : 
2
strstr : while : #endif : 
2
str : #ifdef CONFIG_CFS_BANDWIDTH[27]
strstr : INIT : #ifdef CONFIG_CFS_BANDWIDTH : 
2
strstr : if : #ifdef CONFIG_CFS_BANDWIDTH : 
2
strstr : for : #ifdef CONFIG_CFS_BANDWIDTH : 
2
strstr : while : #ifdef CONFIG_CFS_BANDWIDTH : 
2
str : 		.name = "cfs_quota_us",[25]
strstr : INIT : 		.name = "cfs_quota_us", : 
2
strstr : if : 		.name = "cfs_quota_us", : 
2
strstr : for : 		.name = "cfs_quota_us", : 
2
strstr : while : 		.name = "cfs_quota_us", : 
2
str : 		.read_s64 = cpu_cfs_quota_read_s64,[37]
strstr : INIT : 		.read_s64 = cpu_cfs_quota_read_s64, : 
2
strstr : if : 		.read_s64 = cpu_cfs_quota_read_s64, : 
2
strstr : for : 		.read_s64 = cpu_cfs_quota_read_s64, : 
2
strstr : while : 		.read_s64 = cpu_cfs_quota_read_s64, : 
2
str : 		.write_s64 = cpu_cfs_quota_write_s64,[39]
strstr : INIT : 		.write_s64 = cpu_cfs_quota_write_s64, : 
2
strstr : if : 		.write_s64 = cpu_cfs_quota_write_s64, : 
2
strstr : for : 		.write_s64 = cpu_cfs_quota_write_s64, : 
2
strstr : while : 		.write_s64 = cpu_cfs_quota_write_s64, : 
2
str : 	},[3]
strstr : INIT : 	}, : 
2
strstr : if : 	}, : 
2
strstr : for : 	}, : 
2
strstr : while : 	}, : 
2
str : 		.name = "cfs_period_us",[26]
strstr : INIT : 		.name = "cfs_period_us", : 
2
strstr : if : 		.name = "cfs_period_us", : 
2
strstr : for : 		.name = "cfs_period_us", : 
2
strstr : while : 		.name = "cfs_period_us", : 
2
str : 		.read_u64 = cpu_cfs_period_read_u64,[38]
strstr : INIT : 		.read_u64 = cpu_cfs_period_read_u64, : 
2
strstr : if : 		.read_u64 = cpu_cfs_period_read_u64, : 
2
strstr : for : 		.read_u64 = cpu_cfs_period_read_u64, : 
2
strstr : while : 		.read_u64 = cpu_cfs_period_read_u64, : 
2
str : 		.write_u64 = cpu_cfs_period_write_u64,[40]
strstr : INIT : 		.write_u64 = cpu_cfs_period_write_u64, : 
2
strstr : if : 		.write_u64 = cpu_cfs_period_write_u64, : 
2
strstr : for : 		.write_u64 = cpu_cfs_period_write_u64, : 
2
strstr : while : 		.write_u64 = cpu_cfs_period_write_u64, : 
2
str : 	},[3]
strstr : INIT : 	}, : 
2
strstr : if : 	}, : 
2
strstr : for : 	}, : 
2
strstr : while : 	}, : 
2
str : 		.name = "stat",[17]
strstr : INIT : 		.name = "stat", : 
2
strstr : if : 		.name = "stat", : 
2
strstr : for : 		.name = "stat", : 
2
strstr : while : 		.name = "stat", : 
2
str : 		.seq_show = cpu_stats_show,[29]
strstr : INIT : 		.seq_show = cpu_stats_show, : 
2
strstr : if : 		.seq_show = cpu_stats_show, : 
2
strstr : for : 		.seq_show = cpu_stats_show, : 
2
strstr : while : 		.seq_show = cpu_stats_show, : 
2
str : 	},[3]
strstr : INIT : 	}, : 
2
strstr : if : 	}, : 
2
strstr : for : 	}, : 
2
strstr : while : 	}, : 
2
str : #endif[6]
strstr : INIT : #endif : 
2
strstr : if : #endif : 
2
strstr : for : #endif : 
2
strstr : while : #endif : 
2
str : #ifdef CONFIG_RT_GROUP_SCHED[28]
strstr : INIT : #ifdef CONFIG_RT_GROUP_SCHED : 
2
strstr : if : #ifdef CONFIG_RT_GROUP_SCHED : 
2
strstr : for : #ifdef CONFIG_RT_GROUP_SCHED : 
2
strstr : while : #ifdef CONFIG_RT_GROUP_SCHED : 
2
str : 		.name = "rt_runtime_us",[26]
strstr : INIT : 		.name = "rt_runtime_us", : 
2
strstr : if : 		.name = "rt_runtime_us", : 
2
strstr : for : 		.name = "rt_runtime_us", : 
2
strstr : while : 		.name = "rt_runtime_us", : 
2
str : 		.read_s64 = cpu_rt_runtime_read,[34]
strstr : INIT : 		.read_s64 = cpu_rt_runtime_read, : 
2
strstr : if : 		.read_s64 = cpu_rt_runtime_read, : 
2
strstr : for : 		.read_s64 = cpu_rt_runtime_read, : 
2
strstr : while : 		.read_s64 = cpu_rt_runtime_read, : 
2
str : 		.write_s64 = cpu_rt_runtime_write,[36]
strstr : INIT : 		.write_s64 = cpu_rt_runtime_write, : 
2
strstr : if : 		.write_s64 = cpu_rt_runtime_write, : 
2
strstr : for : 		.write_s64 = cpu_rt_runtime_write, : 
2
strstr : while : 		.write_s64 = cpu_rt_runtime_write, : 
2
str : 	},[3]
strstr : INIT : 	}, : 
2
strstr : if : 	}, : 
2
strstr : for : 	}, : 
2
strstr : while : 	}, : 
2
str : 		.name = "rt_period_us",[25]
strstr : INIT : 		.name = "rt_period_us", : 
2
strstr : if : 		.name = "rt_period_us", : 
2
strstr : for : 		.name = "rt_period_us", : 
2
strstr : while : 		.name = "rt_period_us", : 
2
str : 		.read_u64 = cpu_rt_period_read_uint,[38]
strstr : INIT : 		.read_u64 = cpu_rt_period_read_uint, : 
2
strstr : if : 		.read_u64 = cpu_rt_period_read_uint, : 
2
strstr : for : 		.read_u64 = cpu_rt_period_read_uint, : 
2
strstr : while : 		.read_u64 = cpu_rt_period_read_uint, : 
2
str : 		.write_u64 = cpu_rt_period_write_uint,[40]
strstr : INIT : 		.write_u64 = cpu_rt_period_write_uint, : 
2
strstr : if : 		.write_u64 = cpu_rt_period_write_uint, : 
2
strstr : for : 		.write_u64 = cpu_rt_period_write_uint, : 
2
strstr : while : 		.write_u64 = cpu_rt_period_write_uint, : 
2
str : 	},[3]
strstr : INIT : 	}, : 
2
strstr : if : 	}, : 
2
strstr : for : 	}, : 
2
strstr : while : 	}, : 
2
str : #endif[6]
strstr : INIT : #endif : 
2
strstr : if : #endif : 
2
strstr : for : #endif : 
2
strstr : while : #endif : 
2
str : 	{ }	/* terminate */[20]
strstr : INIT : 	{ }	/* terminate */ : 
2
strstr : if : 	{ }	/* terminate */ : 
2
strstr : for : 	{ }	/* terminate */ : 
2
strstr : while : 	{ }	/* terminate */ : 
2
str : struct cgroup_subsys cpu_cgroup_subsys = {[42]
strstr : INIT : struct cgroup_subsys cpu_cgroup_subsys = { : 
2
strstr : if : struct cgroup_subsys cpu_cgroup_subsys = { : 
2
strstr : for : struct cgroup_subsys cpu_cgroup_subsys = { : 
2
strstr : while : struct cgroup_subsys cpu_cgroup_subsys = { : 
2
str : 	.name		= "cpu",[16]
strstr : INIT : 	.name		= "cpu", : 
2
strstr : if : 	.name		= "cpu", : 
2
strstr : for : 	.name		= "cpu", : 
2
strstr : while : 	.name		= "cpu", : 
2
str : 	.css_alloc	= cpu_cgroup_css_alloc,[35]
strstr : INIT : 	.css_alloc	= cpu_cgroup_css_alloc, : 
2
strstr : if : 	.css_alloc	= cpu_cgroup_css_alloc, : 
2
strstr : for : 	.css_alloc	= cpu_cgroup_css_alloc, : 
2
strstr : while : 	.css_alloc	= cpu_cgroup_css_alloc, : 
2
str : 	.css_free	= cpu_cgroup_css_free,[33]
strstr : INIT : 	.css_free	= cpu_cgroup_css_free, : 
2
strstr : if : 	.css_free	= cpu_cgroup_css_free, : 
2
strstr : for : 	.css_free	= cpu_cgroup_css_free, : 
2
strstr : while : 	.css_free	= cpu_cgroup_css_free, : 
2
str : 	.css_online	= cpu_cgroup_css_online,[37]
strstr : INIT : 	.css_online	= cpu_cgroup_css_online, : 
2
strstr : if : 	.css_online	= cpu_cgroup_css_online, : 
2
strstr : for : 	.css_online	= cpu_cgroup_css_online, : 
2
strstr : while : 	.css_online	= cpu_cgroup_css_online, : 
2
str : 	.css_offline	= cpu_cgroup_css_offline,[39]
strstr : INIT : 	.css_offline	= cpu_cgroup_css_offline, : 
2
strstr : if : 	.css_offline	= cpu_cgroup_css_offline, : 
2
strstr : for : 	.css_offline	= cpu_cgroup_css_offline, : 
2
strstr : while : 	.css_offline	= cpu_cgroup_css_offline, : 
2
str : 	.can_attach	= cpu_cgroup_can_attach,[37]
strstr : INIT : 	.can_attach	= cpu_cgroup_can_attach, : 
2
strstr : if : 	.can_attach	= cpu_cgroup_can_attach, : 
2
strstr : for : 	.can_attach	= cpu_cgroup_can_attach, : 
2
strstr : while : 	.can_attach	= cpu_cgroup_can_attach, : 
2
str : 	.attach		= cpu_cgroup_attach,[30]
strstr : INIT : 	.attach		= cpu_cgroup_attach, : 
2
strstr : if : 	.attach		= cpu_cgroup_attach, : 
2
strstr : for : 	.attach		= cpu_cgroup_attach, : 
2
strstr : while : 	.attach		= cpu_cgroup_attach, : 
2
str : 	.exit		= cpu_cgroup_exit,[26]
strstr : INIT : 	.exit		= cpu_cgroup_exit, : 
2
strstr : if : 	.exit		= cpu_cgroup_exit, : 
2
strstr : for : 	.exit		= cpu_cgroup_exit, : 
2
strstr : while : 	.exit		= cpu_cgroup_exit, : 
2
str : 	.subsys_id	= cpu_cgroup_subsys_id,[35]
strstr : INIT : 	.subsys_id	= cpu_cgroup_subsys_id, : 
2
strstr : if : 	.subsys_id	= cpu_cgroup_subsys_id, : 
2
strstr : for : 	.subsys_id	= cpu_cgroup_subsys_id, : 
2
strstr : while : 	.subsys_id	= cpu_cgroup_subsys_id, : 
2
str : 	.base_cftypes	= cpu_files,[27]
strstr : INIT : 	.base_cftypes	= cpu_files, : 
2
strstr : if : 	.base_cftypes	= cpu_files, : 
2
strstr : for : 	.base_cftypes	= cpu_files, : 
2
strstr : while : 	.base_cftypes	= cpu_files, : 
2
str : 	.early_init	= 1,[17]
strstr : INIT : 	.early_init	= 1, : 
2
strstr : if : 	.early_init	= 1, : 
2
strstr : for : 	.early_init	= 1, : 
2
strstr : while : 	.early_init	= 1, : 
2
str : #endif	/* CONFIG_CGROUP_SCHED */[32]
strstr : INIT : #endif	/* CONFIG_CGROUP_SCHED */ : 
2
strstr : if : #endif	/* CONFIG_CGROUP_SCHED */ : 
2
strstr : for : #endif	/* CONFIG_CGROUP_SCHED */ : 
2
strstr : while : #endif	/* CONFIG_CGROUP_SCHED */ : 
2
str : void dump_cpu_task(int cpu)[27]
strstr : INIT : void dump_cpu_task(int cpu) : 
2
strstr : if : void dump_cpu_task(int cpu) : 
2
strstr : for : void dump_cpu_task(int cpu) : 
2
strstr : while : void dump_cpu_task(int cpu) : 
2
str : 	pr_info("Task dump for CPU %d:\n", cpu);[41]
strstr : INIT : 	pr_info("Task dump for CPU %d:\n", cpu); : 
2
strstr : if : 	pr_info("Task dump for CPU %d:\n", cpu); : 
2
strstr : for : 	pr_info("Task dump for CPU %d:\n", cpu); : 
2
strstr : while : 	pr_info("Task dump for CPU %d:\n", cpu); : 
2
str : 	sched_show_task(cpu_curr(cpu));[32]
strstr : INIT : 	sched_show_task(cpu_curr(cpu)); : 
2
strstr : if : 	sched_show_task(cpu_curr(cpu)); : 
2
strstr : for : 	sched_show_task(cpu_curr(cpu)); : 
2
strstr : while : 	sched_show_task(cpu_curr(cpu)); : 
2
