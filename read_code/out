list print :      (nil) ( 0x2055040       INIT)  0x2055060 
list print :  0x2055040 ( 0x2055060         if)  0x2055080 
list print :  0x2055060 ( 0x2055080        for)  0x20550a0 
list print :  0x2055080 ( 0x20550a0      while)      (nil) 
[ OK ] open : 3 ok... 
str : /*
strstr : INIT : /* : 
strstr : if : /* : 
strstr : for : /* : 
strstr : while : /* : 
str :  *  kernel/sched/core.c
strstr : INIT :  *  kernel/sched/core.c : 
strstr : if :  *  kernel/sched/core.c : 
strstr : for :  *  kernel/sched/core.c : 
strstr : while :  *  kernel/sched/core.c : 
str :  *
strstr : INIT :  * : 
strstr : if :  * : 
strstr : for :  * : 
strstr : while :  * : 
str :  *  Kernel scheduler and related syscalls
strstr : INIT :  *  Kernel scheduler and related syscalls : 
strstr : if :  *  Kernel scheduler and related syscalls : 
strstr : for :  *  Kernel scheduler and related syscalls : 
strstr : while :  *  Kernel scheduler and related syscalls : 
str :  *
strstr : INIT :  * : 
strstr : if :  * : 
strstr : for :  * : 
strstr : while :  * : 
str :  *  Copyright (C) 1991-2002  Linus Torvalds
strstr : INIT :  *  Copyright (C) 1991-2002  Linus Torvalds : 
strstr : if :  *  Copyright (C) 1991-2002  Linus Torvalds : 
strstr : for :  *  Copyright (C) 1991-2002  Linus Torvalds : 
strstr : while :  *  Copyright (C) 1991-2002  Linus Torvalds : 
str :  *
strstr : INIT :  * : 
strstr : if :  * : 
strstr : for :  * : 
strstr : while :  * : 
str :  *  1996-12-23  Modified by Dave Grothe to fix bugs in semaphores and
strstr : INIT :  *  1996-12-23  Modified by Dave Grothe to fix bugs in semaphores and : 
strstr : if :  *  1996-12-23  Modified by Dave Grothe to fix bugs in semaphores and : 
strstr : for :  *  1996-12-23  Modified by Dave Grothe to fix bugs in semaphores and : 
strstr : while :  *  1996-12-23  Modified by Dave Grothe to fix bugs in semaphores and : 
str :  *		make semaphores SMP safe
strstr : INIT :  *		make semaphores SMP safe : 
strstr : if :  *		make semaphores SMP safe : 
strstr : for :  *		make semaphores SMP safe : 
strstr : while :  *		make semaphores SMP safe : 
str :  *  1998-11-19	Implemented schedule_timeout() and related stuff
strstr : INIT :  *  1998-11-19	Implemented schedule_timeout() and related stuff : 
strstr : if :  *  1998-11-19	Implemented schedule_timeout() and related stuff : 
strstr : for :  *  1998-11-19	Implemented schedule_timeout() and related stuff : 
strstr : while :  *  1998-11-19	Implemented schedule_timeout() and related stuff : 
str :  *		by Andrea Arcangeli
strstr : INIT :  *		by Andrea Arcangeli : 
strstr : if :  *		by Andrea Arcangeli : 
strstr : for :  *		by Andrea Arcangeli : 
strstr : while :  *		by Andrea Arcangeli : 
str :  *  2002-01-04	New ultra-scalable O(1) scheduler by Ingo Molnar:
strstr : INIT :  *  2002-01-04	New ultra-scalable O(1) scheduler by Ingo Molnar: : 
strstr : if :  *  2002-01-04	New ultra-scalable O(1) scheduler by Ingo Molnar: : 
strstr : for :  *  2002-01-04	New ultra-scalable O(1) scheduler by Ingo Molnar: : 
strstr : while :  *  2002-01-04	New ultra-scalable O(1) scheduler by Ingo Molnar: : 
str :  *		hybrid priority-list and round-robin design with
strstr : INIT :  *		hybrid priority-list and round-robin design with : 
strstr : if :  *		hybrid priority-list and round-robin design with : 
strstr : for :  *		hybrid priority-list and round-robin design with : 
strstr : while :  *		hybrid priority-list and round-robin design with : 
str :  *		an array-switch method of distributing timeslices
strstr : INIT :  *		an array-switch method of distributing timeslices : 
strstr : if :  *		an array-switch method of distributing timeslices : 
strstr : for :  *		an array-switch method of distributing timeslices : 
strstr : while :  *		an array-switch method of distributing timeslices : 
str :  *		and per-CPU runqueues.  Cleanups and useful suggestions
strstr : INIT :  *		and per-CPU runqueues.  Cleanups and useful suggestions : 
strstr : if :  *		and per-CPU runqueues.  Cleanups and useful suggestions : 
strstr : for :  *		and per-CPU runqueues.  Cleanups and useful suggestions : 
strstr : while :  *		and per-CPU runqueues.  Cleanups and useful suggestions : 
str :  *		by Davide Libenzi, preemptible kernel bits by Robert Love.
strstr : INIT :  *		by Davide Libenzi, preemptible kernel bits by Robert Love. : 
strstr : if :  *		by Davide Libenzi, preemptible kernel bits by Robert Love. : 
strstr : for :  *		by Davide Libenzi, preemptible kernel bits by Robert Love. : 
strstr : while :  *		by Davide Libenzi, preemptible kernel bits by Robert Love. : 
str :  *  2003-09-03	Interactivity tuning by Con Kolivas.
strstr : INIT :  *  2003-09-03	Interactivity tuning by Con Kolivas. : 
strstr : if :  *  2003-09-03	Interactivity tuning by Con Kolivas. : 
strstr : for :  *  2003-09-03	Interactivity tuning by Con Kolivas. : 
strstr : while :  *  2003-09-03	Interactivity tuning by Con Kolivas. : 
str :  *  2004-04-02	Scheduler domains code by Nick Piggin
strstr : INIT :  *  2004-04-02	Scheduler domains code by Nick Piggin : 
strstr : if :  *  2004-04-02	Scheduler domains code by Nick Piggin : 
strstr : for :  *  2004-04-02	Scheduler domains code by Nick Piggin : 
strstr : while :  *  2004-04-02	Scheduler domains code by Nick Piggin : 
str :  *  2007-04-15  Work begun on replacing all interactivity tuning with a
strstr : INIT :  *  2007-04-15  Work begun on replacing all interactivity tuning with a : 
strstr : if :  *  2007-04-15  Work begun on replacing all interactivity tuning with a : 
strstr : for :  *  2007-04-15  Work begun on replacing all interactivity tuning with a : 
strstr : while :  *  2007-04-15  Work begun on replacing all interactivity tuning with a : 
str :  *              fair scheduling design by Con Kolivas.
strstr : INIT :  *              fair scheduling design by Con Kolivas. : 
strstr : if :  *              fair scheduling design by Con Kolivas. : 
strstr : for :  *              fair scheduling design by Con Kolivas. : 
strstr : while :  *              fair scheduling design by Con Kolivas. : 
str :  *  2007-05-05  Load balancing (smp-nice) and other improvements
strstr : INIT :  *  2007-05-05  Load balancing (smp-nice) and other improvements : 
strstr : if :  *  2007-05-05  Load balancing (smp-nice) and other improvements : 
strstr : for :  *  2007-05-05  Load balancing (smp-nice) and other improvements : 
strstr : while :  *  2007-05-05  Load balancing (smp-nice) and other improvements : 
str :  *              by Peter Williams
strstr : INIT :  *              by Peter Williams : 
strstr : if :  *              by Peter Williams : 
strstr : for :  *              by Peter Williams : 
strstr : while :  *              by Peter Williams : 
str :  *  2007-05-06  Interactivity improvements to CFS by Mike Galbraith
strstr : INIT :  *  2007-05-06  Interactivity improvements to CFS by Mike Galbraith : 
strstr : if :  *  2007-05-06  Interactivity improvements to CFS by Mike Galbraith : 
strstr : for :  *  2007-05-06  Interactivity improvements to CFS by Mike Galbraith : 
strstr : while :  *  2007-05-06  Interactivity improvements to CFS by Mike Galbraith : 
str :  *  2007-07-01  Group scheduling enhancements by Srivatsa Vaddagiri
strstr : INIT :  *  2007-07-01  Group scheduling enhancements by Srivatsa Vaddagiri : 
strstr : if :  *  2007-07-01  Group scheduling enhancements by Srivatsa Vaddagiri : 
strstr : for :  *  2007-07-01  Group scheduling enhancements by Srivatsa Vaddagiri : 
strstr : while :  *  2007-07-01  Group scheduling enhancements by Srivatsa Vaddagiri : 
str :  *  2007-11-29  RT balancing improvements by Steven Rostedt, Gregory Haskins,
strstr : INIT :  *  2007-11-29  RT balancing improvements by Steven Rostedt, Gregory Haskins, : 
strstr : if :  *  2007-11-29  RT balancing improvements by Steven Rostedt, Gregory Haskins, : 
strstr : for :  *  2007-11-29  RT balancing improvements by Steven Rostedt, Gregory Haskins, : 
strstr : while :  *  2007-11-29  RT balancing improvements by Steven Rostedt, Gregory Haskins, : 
str :  *              Thomas Gleixner, Mike Kravetz
strstr : INIT :  *              Thomas Gleixner, Mike Kravetz : 
strstr : if :  *              Thomas Gleixner, Mike Kravetz : 
strstr : for :  *              Thomas Gleixner, Mike Kravetz : 
strstr : while :  *              Thomas Gleixner, Mike Kravetz : 
str :  */
strstr : INIT :  */ : 
strstr : if :  */ : 
strstr : for :  */ : 
strstr : while :  */ : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : #include <linux/mm.h>
strstr : if : #include <linux/mm.h> : 
strstr : for : #include <linux/mm.h> : 
strstr : while : #include <linux/mm.h> : 
str : #include <linux/module.h>
strstr : INIT : #include <linux/module.h> : 
strstr : if : #include <linux/module.h> : 
strstr : for : #include <linux/module.h> : 
strstr : while : #include <linux/module.h> : 
str : #include <linux/nmi.h>
strstr : INIT : #include <linux/nmi.h> : 
strstr : if : #include <linux/nmi.h> : 
strstr : for : #include <linux/nmi.h> : 
strstr : while : #include <linux/nmi.h> : 
str : #include <linux/init.h>
strstr : INIT : #include <linux/init.h> : 
strstr : if : #include <linux/init.h> : 
strstr : for : #include <linux/init.h> : 
strstr : while : #include <linux/init.h> : 
str : #include <linux/uaccess.h>
strstr : INIT : #include <linux/uaccess.h> : 
strstr : if : #include <linux/uaccess.h> : 
strstr : for : #include <linux/uaccess.h> : 
strstr : while : #include <linux/uaccess.h> : 
str : #include <linux/highmem.h>
strstr : INIT : #include <linux/highmem.h> : 
strstr : if : #include <linux/highmem.h> : 
strstr : for : #include <linux/highmem.h> : 
strstr : while : #include <linux/highmem.h> : 
str : #include <asm/mmu_context.h>
strstr : INIT : #include <asm/mmu_context.h> : 
strstr : if : #include <asm/mmu_context.h> : 
strstr : for : #include <asm/mmu_context.h> : 
strstr : while : #include <asm/mmu_context.h> : 
str : #include <linux/interrupt.h>
strstr : INIT : #include <linux/interrupt.h> : 
strstr : if : #include <linux/interrupt.h> : 
strstr : for : #include <linux/interrupt.h> : 
strstr : while : #include <linux/interrupt.h> : 
str : #include <linux/capability.h>
strstr : INIT : #include <linux/capability.h> : 
strstr : if : #include <linux/capability.h> : 
strstr : for : #include <linux/capability.h> : 
strstr : while : #include <linux/capability.h> : 
str : #include <linux/completion.h>
strstr : INIT : #include <linux/completion.h> : 
strstr : if : #include <linux/completion.h> : 
strstr : for : #include <linux/completion.h> : 
strstr : while : #include <linux/completion.h> : 
str : #include <linux/kernel_stat.h>
strstr : INIT : #include <linux/kernel_stat.h> : 
strstr : if : #include <linux/kernel_stat.h> : 
strstr : for : #include <linux/kernel_stat.h> : 
strstr : while : #include <linux/kernel_stat.h> : 
str : #include <linux/debug_locks.h>
strstr : INIT : #include <linux/debug_locks.h> : 
strstr : if : #include <linux/debug_locks.h> : 
strstr : for : #include <linux/debug_locks.h> : 
strstr : while : #include <linux/debug_locks.h> : 
str : #include <linux/perf_event.h>
strstr : INIT : #include <linux/perf_event.h> : 
strstr : if : #include <linux/perf_event.h> : 
strstr : for : #include <linux/perf_event.h> : 
strstr : while : #include <linux/perf_event.h> : 
str : #include <linux/security.h>
strstr : INIT : #include <linux/security.h> : 
strstr : if : #include <linux/security.h> : 
strstr : for : #include <linux/security.h> : 
strstr : while : #include <linux/security.h> : 
str : #include <linux/notifier.h>
strstr : INIT : #include <linux/notifier.h> : 
strstr : if : #include <linux/notifier.h> : 
strstr : for : #include <linux/notifier.h> : 
strstr : while : #include <linux/notifier.h> : 
str : #include <linux/profile.h>
strstr : INIT : #include <linux/profile.h> : 
strstr : if : #include <linux/profile.h> : 
strstr : for : #include <linux/profile.h> : 
strstr : while : #include <linux/profile.h> : 
str : #include <linux/freezer.h>
strstr : INIT : #include <linux/freezer.h> : 
strstr : if : #include <linux/freezer.h> : 
strstr : for : #include <linux/freezer.h> : 
strstr : while : #include <linux/freezer.h> : 
str : #include <linux/vmalloc.h>
strstr : INIT : #include <linux/vmalloc.h> : 
strstr : if : #include <linux/vmalloc.h> : 
strstr : for : #include <linux/vmalloc.h> : 
strstr : while : #include <linux/vmalloc.h> : 
str : #include <linux/blkdev.h>
strstr : INIT : #include <linux/blkdev.h> : 
strstr : if : #include <linux/blkdev.h> : 
strstr : for : #include <linux/blkdev.h> : 
strstr : while : #include <linux/blkdev.h> : 
str : #include <linux/delay.h>
strstr : INIT : #include <linux/delay.h> : 
strstr : if : #include <linux/delay.h> : 
strstr : for : #include <linux/delay.h> : 
strstr : while : #include <linux/delay.h> : 
str : #include <linux/pid_namespace.h>
strstr : INIT : #include <linux/pid_namespace.h> : 
strstr : if : #include <linux/pid_namespace.h> : 
strstr : for : #include <linux/pid_namespace.h> : 
strstr : while : #include <linux/pid_namespace.h> : 
str : #include <linux/smp.h>
strstr : INIT : #include <linux/smp.h> : 
strstr : if : #include <linux/smp.h> : 
strstr : for : #include <linux/smp.h> : 
strstr : while : #include <linux/smp.h> : 
str : #include <linux/threads.h>
strstr : INIT : #include <linux/threads.h> : 
strstr : if : #include <linux/threads.h> : 
strstr : for : #include <linux/threads.h> : 
strstr : while : #include <linux/threads.h> : 
str : #include <linux/timer.h>
strstr : INIT : #include <linux/timer.h> : 
strstr : if : #include <linux/timer.h> : 
strstr : for : #include <linux/timer.h> : 
strstr : while : #include <linux/timer.h> : 
str : #include <linux/rcupdate.h>
strstr : INIT : #include <linux/rcupdate.h> : 
strstr : if : #include <linux/rcupdate.h> : 
strstr : for : #include <linux/rcupdate.h> : 
strstr : while : #include <linux/rcupdate.h> : 
str : #include <linux/cpu.h>
strstr : INIT : #include <linux/cpu.h> : 
strstr : if : #include <linux/cpu.h> : 
strstr : for : #include <linux/cpu.h> : 
strstr : while : #include <linux/cpu.h> : 
str : #include <linux/cpuset.h>
strstr : INIT : #include <linux/cpuset.h> : 
strstr : if : #include <linux/cpuset.h> : 
strstr : for : #include <linux/cpuset.h> : 
strstr : while : #include <linux/cpuset.h> : 
str : #include <linux/percpu.h>
strstr : INIT : #include <linux/percpu.h> : 
strstr : if : #include <linux/percpu.h> : 
strstr : for : #include <linux/percpu.h> : 
strstr : while : #include <linux/percpu.h> : 
str : #include <linux/proc_fs.h>
strstr : INIT : #include <linux/proc_fs.h> : 
strstr : if : #include <linux/proc_fs.h> : 
strstr : for : #include <linux/proc_fs.h> : 
strstr : while : #include <linux/proc_fs.h> : 
str : #include <linux/seq_file.h>
strstr : INIT : #include <linux/seq_file.h> : 
strstr : if : #include <linux/seq_file.h> : 
strstr : for : #include <linux/seq_file.h> : 
strstr : while : #include <linux/seq_file.h> : 
str : #include <linux/sysctl.h>
strstr : INIT : #include <linux/sysctl.h> : 
strstr : if : #include <linux/sysctl.h> : 
strstr : for : #include <linux/sysctl.h> : 
strstr : while : #include <linux/sysctl.h> : 
str : #include <linux/syscalls.h>
strstr : INIT : #include <linux/syscalls.h> : 
strstr : if : #include <linux/syscalls.h> : 
strstr : for : #include <linux/syscalls.h> : 
strstr : while : #include <linux/syscalls.h> : 
str : #include <linux/times.h>
strstr : INIT : #include <linux/times.h> : 
strstr : if : #include <linux/times.h> : 
strstr : for : #include <linux/times.h> : 
strstr : while : #include <linux/times.h> : 
str : #include <linux/tsacct_kern.h>
strstr : INIT : #include <linux/tsacct_kern.h> : 
strstr : if : #include <linux/tsacct_kern.h> : 
strstr : for : #include <linux/tsacct_kern.h> : 
strstr : while : #include <linux/tsacct_kern.h> : 
str : #include <linux/kprobes.h>
strstr : INIT : #include <linux/kprobes.h> : 
strstr : if : #include <linux/kprobes.h> : 
strstr : for : #include <linux/kprobes.h> : 
strstr : while : #include <linux/kprobes.h> : 
str : #include <linux/delayacct.h>
strstr : INIT : #include <linux/delayacct.h> : 
strstr : if : #include <linux/delayacct.h> : 
strstr : for : #include <linux/delayacct.h> : 
strstr : while : #include <linux/delayacct.h> : 
str : #include <linux/unistd.h>
strstr : INIT : #include <linux/unistd.h> : 
strstr : if : #include <linux/unistd.h> : 
strstr : for : #include <linux/unistd.h> : 
strstr : while : #include <linux/unistd.h> : 
str : #include <linux/pagemap.h>
strstr : INIT : #include <linux/pagemap.h> : 
strstr : if : #include <linux/pagemap.h> : 
strstr : for : #include <linux/pagemap.h> : 
strstr : while : #include <linux/pagemap.h> : 
str : #include <linux/hrtimer.h>
strstr : INIT : #include <linux/hrtimer.h> : 
strstr : if : #include <linux/hrtimer.h> : 
strstr : for : #include <linux/hrtimer.h> : 
strstr : while : #include <linux/hrtimer.h> : 
str : #include <linux/tick.h>
strstr : INIT : #include <linux/tick.h> : 
strstr : if : #include <linux/tick.h> : 
strstr : for : #include <linux/tick.h> : 
strstr : while : #include <linux/tick.h> : 
str : #include <linux/debugfs.h>
strstr : INIT : #include <linux/debugfs.h> : 
strstr : if : #include <linux/debugfs.h> : 
strstr : for : #include <linux/debugfs.h> : 
strstr : while : #include <linux/debugfs.h> : 
str : #include <linux/ctype.h>
strstr : INIT : #include <linux/ctype.h> : 
strstr : if : #include <linux/ctype.h> : 
strstr : for : #include <linux/ctype.h> : 
strstr : while : #include <linux/ctype.h> : 
str : #include <linux/ftrace.h>
strstr : INIT : #include <linux/ftrace.h> : 
strstr : if : #include <linux/ftrace.h> : 
strstr : for : #include <linux/ftrace.h> : 
strstr : while : #include <linux/ftrace.h> : 
str : #include <linux/slab.h>
strstr : INIT : #include <linux/slab.h> : 
strstr : if : #include <linux/slab.h> : 
strstr : for : #include <linux/slab.h> : 
strstr : while : #include <linux/slab.h> : 
str : #include <linux/init_task.h>
strstr : INIT : #include <linux/init_task.h> : 
strstr : if : #include <linux/init_task.h> : 
strstr : for : #include <linux/init_task.h> : 
strstr : while : #include <linux/init_task.h> : 
str : #include <linux/binfmts.h>
strstr : INIT : #include <linux/binfmts.h> : 
strstr : if : #include <linux/binfmts.h> : 
strstr : for : #include <linux/binfmts.h> : 
strstr : while : #include <linux/binfmts.h> : 
str : #include <linux/context_tracking.h>
strstr : INIT : #include <linux/context_tracking.h> : 
strstr : if : #include <linux/context_tracking.h> : 
strstr : for : #include <linux/context_tracking.h> : 
strstr : while : #include <linux/context_tracking.h> : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : #include <asm/switch_to.h>
strstr : if : #include <asm/switch_to.h> : 
strstr : for : #include <asm/switch_to.h> : 
strstr : while : #include <asm/switch_to.h> : 
str : #include <asm/tlb.h>
strstr : INIT : #include <asm/tlb.h> : 
strstr : if : #include <asm/tlb.h> : 
strstr : for : #include <asm/tlb.h> : 
strstr : while : #include <asm/tlb.h> : 
str : #include <asm/irq_regs.h>
strstr : INIT : #include <asm/irq_regs.h> : 
strstr : if : #include <asm/irq_regs.h> : 
strstr : for : #include <asm/irq_regs.h> : 
strstr : while : #include <asm/irq_regs.h> : 
str : #include <asm/mutex.h>
strstr : INIT : #include <asm/mutex.h> : 
strstr : if : #include <asm/mutex.h> : 
strstr : for : #include <asm/mutex.h> : 
strstr : while : #include <asm/mutex.h> : 
str : #ifdef CONFIG_PARAVIRT
strstr : INIT : #ifdef CONFIG_PARAVIRT : 
strstr : if : #ifdef CONFIG_PARAVIRT : 
strstr : for : #ifdef CONFIG_PARAVIRT : 
strstr : while : #ifdef CONFIG_PARAVIRT : 
str : #include <asm/paravirt.h>
strstr : INIT : #include <asm/paravirt.h> : 
strstr : if : #include <asm/paravirt.h> : 
strstr : for : #include <asm/paravirt.h> : 
strstr : while : #include <asm/paravirt.h> : 
str : #endif
strstr : INIT : #endif : 
strstr : if : #endif : 
strstr : for : #endif : 
strstr : while : #endif : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : #include "sched.h"
strstr : if : #include "sched.h" : 
strstr : for : #include "sched.h" : 
strstr : while : #include "sched.h" : 
str : #include "../workqueue_internal.h"
strstr : INIT : #include "../workqueue_internal.h" : 
strstr : if : #include "../workqueue_internal.h" : 
strstr : for : #include "../workqueue_internal.h" : 
strstr : while : #include "../workqueue_internal.h" : 
str : #include "../smpboot.h"
strstr : INIT : #include "../smpboot.h" : 
strstr : if : #include "../smpboot.h" : 
strstr : for : #include "../smpboot.h" : 
strstr : while : #include "../smpboot.h" : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : #define CREATE_TRACE_POINTS
strstr : if : #define CREATE_TRACE_POINTS : 
strstr : for : #define CREATE_TRACE_POINTS : 
strstr : while : #define CREATE_TRACE_POINTS : 
str : #include <trace/events/sched.h>
strstr : INIT : #include <trace/events/sched.h> : 
strstr : if : #include <trace/events/sched.h> : 
strstr : for : #include <trace/events/sched.h> : 
strstr : while : #include <trace/events/sched.h> : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : void start_bandwidth_timer(struct hrtimer *period_timer, ktime_t period)
strstr : if : void start_bandwidth_timer(struct hrtimer *period_timer, ktime_t period) : 
strstr : for : void start_bandwidth_timer(struct hrtimer *period_timer, ktime_t period) : 
strstr : while : void start_bandwidth_timer(struct hrtimer *period_timer, ktime_t period) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	unsigned long delta;
strstr : INIT : 	unsigned long delta; : 
strstr : if : 	unsigned long delta; : 
strstr : for : 	unsigned long delta; : 
strstr : while : 	unsigned long delta; : 
str : 	ktime_t soft, hard, now;
strstr : INIT : 	ktime_t soft, hard, now; : 
strstr : if : 	ktime_t soft, hard, now; : 
strstr : for : 	ktime_t soft, hard, now; : 
strstr : while : 	ktime_t soft, hard, now; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	for (;;) {
strstr : if : 	for (;;) { : 
strstr : for : 	for (;;) { : 
strstr : while : 	for (;;) { : 
str : 		if (hrtimer_active(period_timer))
strstr : INIT : 		if (hrtimer_active(period_timer)) : 
strstr : if : 		if (hrtimer_active(period_timer)) : 
strstr : for : 		if (hrtimer_active(period_timer)) : 
strstr : while : 		if (hrtimer_active(period_timer)) : 
str : 			break;
strstr : INIT : 			break; : 
strstr : if : 			break; : 
strstr : for : 			break; : 
strstr : while : 			break; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 		now = hrtimer_cb_get_time(period_timer);
strstr : if : 		now = hrtimer_cb_get_time(period_timer); : 
strstr : for : 		now = hrtimer_cb_get_time(period_timer); : 
strstr : while : 		now = hrtimer_cb_get_time(period_timer); : 
str : 		hrtimer_forward(period_timer, now, period);
strstr : INIT : 		hrtimer_forward(period_timer, now, period); : 
strstr : if : 		hrtimer_forward(period_timer, now, period); : 
strstr : for : 		hrtimer_forward(period_timer, now, period); : 
strstr : while : 		hrtimer_forward(period_timer, now, period); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 		soft = hrtimer_get_softexpires(period_timer);
strstr : if : 		soft = hrtimer_get_softexpires(period_timer); : 
strstr : for : 		soft = hrtimer_get_softexpires(period_timer); : 
strstr : while : 		soft = hrtimer_get_softexpires(period_timer); : 
str : 		hard = hrtimer_get_expires(period_timer);
strstr : INIT : 		hard = hrtimer_get_expires(period_timer); : 
strstr : if : 		hard = hrtimer_get_expires(period_timer); : 
strstr : for : 		hard = hrtimer_get_expires(period_timer); : 
strstr : while : 		hard = hrtimer_get_expires(period_timer); : 
str : 		delta = ktime_to_ns(ktime_sub(hard, soft));
strstr : INIT : 		delta = ktime_to_ns(ktime_sub(hard, soft)); : 
strstr : if : 		delta = ktime_to_ns(ktime_sub(hard, soft)); : 
strstr : for : 		delta = ktime_to_ns(ktime_sub(hard, soft)); : 
strstr : while : 		delta = ktime_to_ns(ktime_sub(hard, soft)); : 
str : 		__hrtimer_start_range_ns(period_timer, soft, delta,
strstr : INIT : 		__hrtimer_start_range_ns(period_timer, soft, delta, : 
strstr : if : 		__hrtimer_start_range_ns(period_timer, soft, delta, : 
strstr : for : 		__hrtimer_start_range_ns(period_timer, soft, delta, : 
strstr : while : 		__hrtimer_start_range_ns(period_timer, soft, delta, : 
str : 					 HRTIMER_MODE_ABS_PINNED, 0);
strstr : INIT : 					 HRTIMER_MODE_ABS_PINNED, 0); : 
strstr : if : 					 HRTIMER_MODE_ABS_PINNED, 0); : 
strstr : for : 					 HRTIMER_MODE_ABS_PINNED, 0); : 
strstr : while : 					 HRTIMER_MODE_ABS_PINNED, 0); : 
str : 	}
strstr : INIT : 	} : 
strstr : if : 	} : 
strstr : for : 	} : 
strstr : while : 	} : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : DEFINE_MUTEX(sched_domains_mutex);
strstr : if : DEFINE_MUTEX(sched_domains_mutex); : 
strstr : for : DEFINE_MUTEX(sched_domains_mutex); : 
strstr : while : DEFINE_MUTEX(sched_domains_mutex); : 
str : DEFINE_PER_CPU_SHARED_ALIGNED(struct rq, runqueues);
strstr : INIT : DEFINE_PER_CPU_SHARED_ALIGNED(struct rq, runqueues); : 
strstr : if : DEFINE_PER_CPU_SHARED_ALIGNED(struct rq, runqueues); : 
strstr : for : DEFINE_PER_CPU_SHARED_ALIGNED(struct rq, runqueues); : 
strstr : while : DEFINE_PER_CPU_SHARED_ALIGNED(struct rq, runqueues); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : static void update_rq_clock_task(struct rq *rq, s64 delta);
strstr : if : static void update_rq_clock_task(struct rq *rq, s64 delta); : 
strstr : for : static void update_rq_clock_task(struct rq *rq, s64 delta); : 
strstr : while : static void update_rq_clock_task(struct rq *rq, s64 delta); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : void update_rq_clock(struct rq *rq)
strstr : if : void update_rq_clock(struct rq *rq) : 
strstr : for : void update_rq_clock(struct rq *rq) : 
strstr : while : void update_rq_clock(struct rq *rq) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	s64 delta;
strstr : INIT : 	s64 delta; : 
strstr : if : 	s64 delta; : 
strstr : for : 	s64 delta; : 
strstr : while : 	s64 delta; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	if (rq->skip_clock_update > 0)
strstr : if : 	if (rq->skip_clock_update > 0) : 
strstr : for : 	if (rq->skip_clock_update > 0) : 
strstr : while : 	if (rq->skip_clock_update > 0) : 
str : 		return;
strstr : INIT : 		return; : 
strstr : if : 		return; : 
strstr : for : 		return; : 
strstr : while : 		return; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	delta = sched_clock_cpu(cpu_of(rq)) - rq->clock;
strstr : if : 	delta = sched_clock_cpu(cpu_of(rq)) - rq->clock; : 
strstr : for : 	delta = sched_clock_cpu(cpu_of(rq)) - rq->clock; : 
strstr : while : 	delta = sched_clock_cpu(cpu_of(rq)) - rq->clock; : 
str : 	rq->clock += delta;
strstr : INIT : 	rq->clock += delta; : 
strstr : if : 	rq->clock += delta; : 
strstr : for : 	rq->clock += delta; : 
strstr : while : 	rq->clock += delta; : 
str : 	update_rq_clock_task(rq, delta);
strstr : INIT : 	update_rq_clock_task(rq, delta); : 
strstr : if : 	update_rq_clock_task(rq, delta); : 
strstr : for : 	update_rq_clock_task(rq, delta); : 
strstr : while : 	update_rq_clock_task(rq, delta); : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : /*
strstr : if : /* : 
strstr : for : /* : 
strstr : while : /* : 
str :  * Debugging: various feature bits
strstr : INIT :  * Debugging: various feature bits : 
strstr : if :  * Debugging: various feature bits : 
strstr : for :  * Debugging: various feature bits : 
strstr : while :  * Debugging: various feature bits : 
str :  */
strstr : INIT :  */ : 
strstr : if :  */ : 
strstr : for :  */ : 
strstr : while :  */ : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : #define SCHED_FEAT(name, enabled)	\
strstr : if : #define SCHED_FEAT(name, enabled)	\ : 
strstr : for : #define SCHED_FEAT(name, enabled)	\ : 
strstr : while : #define SCHED_FEAT(name, enabled)	\ : 
str : 	(1UL << __SCHED_FEAT_##name) * enabled |
strstr : INIT : 	(1UL << __SCHED_FEAT_##name) * enabled | : 
strstr : if : 	(1UL << __SCHED_FEAT_##name) * enabled | : 
strstr : for : 	(1UL << __SCHED_FEAT_##name) * enabled | : 
strstr : while : 	(1UL << __SCHED_FEAT_##name) * enabled | : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : const_debug unsigned int sysctl_sched_features =
strstr : if : const_debug unsigned int sysctl_sched_features = : 
strstr : for : const_debug unsigned int sysctl_sched_features = : 
strstr : while : const_debug unsigned int sysctl_sched_features = : 
str : #include "features.h"
strstr : INIT : #include "features.h" : 
strstr : if : #include "features.h" : 
strstr : for : #include "features.h" : 
strstr : while : #include "features.h" : 
str : 	0;
strstr : INIT : 	0; : 
strstr : if : 	0; : 
strstr : for : 	0; : 
strstr : while : 	0; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : #undef SCHED_FEAT
strstr : if : #undef SCHED_FEAT : 
strstr : for : #undef SCHED_FEAT : 
strstr : while : #undef SCHED_FEAT : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : #ifdef CONFIG_SCHED_DEBUG
strstr : if : #ifdef CONFIG_SCHED_DEBUG : 
strstr : for : #ifdef CONFIG_SCHED_DEBUG : 
strstr : while : #ifdef CONFIG_SCHED_DEBUG : 
str : #define SCHED_FEAT(name, enabled)	\
strstr : INIT : #define SCHED_FEAT(name, enabled)	\ : 
strstr : if : #define SCHED_FEAT(name, enabled)	\ : 
strstr : for : #define SCHED_FEAT(name, enabled)	\ : 
strstr : while : #define SCHED_FEAT(name, enabled)	\ : 
str : 	#name ,
strstr : INIT : 	#name , : 
strstr : if : 	#name , : 
strstr : for : 	#name , : 
strstr : while : 	#name , : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : static const char * const sched_feat_names[] = {
strstr : if : static const char * const sched_feat_names[] = { : 
strstr : for : static const char * const sched_feat_names[] = { : 
strstr : while : static const char * const sched_feat_names[] = { : 
str : #include "features.h"
strstr : INIT : #include "features.h" : 
strstr : if : #include "features.h" : 
strstr : for : #include "features.h" : 
strstr : while : #include "features.h" : 
str : };
strstr : INIT : }; : 
strstr : if : }; : 
strstr : for : }; : 
strstr : while : }; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : #undef SCHED_FEAT
strstr : if : #undef SCHED_FEAT : 
strstr : for : #undef SCHED_FEAT : 
strstr : while : #undef SCHED_FEAT : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : static int sched_feat_show(struct seq_file *m, void *v)
strstr : if : static int sched_feat_show(struct seq_file *m, void *v) : 
strstr : for : static int sched_feat_show(struct seq_file *m, void *v) : 
strstr : while : static int sched_feat_show(struct seq_file *m, void *v) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	int i;
strstr : INIT : 	int i; : 
strstr : if : 	int i; : 
strstr : for : 	int i; : 
strstr : while : 	int i; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	for (i = 0; i < __SCHED_FEAT_NR; i++) {
strstr : if : 	for (i = 0; i < __SCHED_FEAT_NR; i++) { : 
strstr : for : 	for (i = 0; i < __SCHED_FEAT_NR; i++) { : 
strstr : while : 	for (i = 0; i < __SCHED_FEAT_NR; i++) { : 
str : 		if (!(sysctl_sched_features & (1UL << i)))
strstr : INIT : 		if (!(sysctl_sched_features & (1UL << i))) : 
strstr : if : 		if (!(sysctl_sched_features & (1UL << i))) : 
strstr : for : 		if (!(sysctl_sched_features & (1UL << i))) : 
strstr : while : 		if (!(sysctl_sched_features & (1UL << i))) : 
str : 			seq_puts(m, "NO_");
strstr : INIT : 			seq_puts(m, "NO_"); : 
strstr : if : 			seq_puts(m, "NO_"); : 
strstr : for : 			seq_puts(m, "NO_"); : 
strstr : while : 			seq_puts(m, "NO_"); : 
str : 		seq_printf(m, "%s ", sched_feat_names[i]);
strstr : INIT : 		seq_printf(m, "%s ", sched_feat_names[i]); : 
strstr : if : 		seq_printf(m, "%s ", sched_feat_names[i]); : 
strstr : for : 		seq_printf(m, "%s ", sched_feat_names[i]); : 
strstr : while : 		seq_printf(m, "%s ", sched_feat_names[i]); : 
str : 	}
strstr : INIT : 	} : 
strstr : if : 	} : 
strstr : for : 	} : 
strstr : while : 	} : 
str : 	seq_puts(m, "\n");
strstr : INIT : 	seq_puts(m, "\n"); : 
strstr : if : 	seq_puts(m, "\n"); : 
strstr : for : 	seq_puts(m, "\n"); : 
strstr : while : 	seq_puts(m, "\n"); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	return 0;
strstr : if : 	return 0; : 
strstr : for : 	return 0; : 
strstr : while : 	return 0; : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : #ifdef HAVE_JUMP_LABEL
strstr : if : #ifdef HAVE_JUMP_LABEL : 
strstr : for : #ifdef HAVE_JUMP_LABEL : 
strstr : while : #ifdef HAVE_JUMP_LABEL : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : #define jump_label_key__true  STATIC_KEY_INIT_TRUE
strstr : if : #define jump_label_key__true  STATIC_KEY_INIT_TRUE : 
strstr : for : #define jump_label_key__true  STATIC_KEY_INIT_TRUE : 
strstr : while : #define jump_label_key__true  STATIC_KEY_INIT_TRUE : 
str : #define jump_label_key__false STATIC_KEY_INIT_FALSE
strstr : INIT : #define jump_label_key__false STATIC_KEY_INIT_FALSE : 
strstr : if : #define jump_label_key__false STATIC_KEY_INIT_FALSE : 
strstr : for : #define jump_label_key__false STATIC_KEY_INIT_FALSE : 
strstr : while : #define jump_label_key__false STATIC_KEY_INIT_FALSE : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : #define SCHED_FEAT(name, enabled)	\
strstr : if : #define SCHED_FEAT(name, enabled)	\ : 
strstr : for : #define SCHED_FEAT(name, enabled)	\ : 
strstr : while : #define SCHED_FEAT(name, enabled)	\ : 
str : 	jump_label_key__##enabled ,
strstr : INIT : 	jump_label_key__##enabled , : 
strstr : if : 	jump_label_key__##enabled , : 
strstr : for : 	jump_label_key__##enabled , : 
strstr : while : 	jump_label_key__##enabled , : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : struct static_key sched_feat_keys[__SCHED_FEAT_NR] = {
strstr : if : struct static_key sched_feat_keys[__SCHED_FEAT_NR] = { : 
strstr : for : struct static_key sched_feat_keys[__SCHED_FEAT_NR] = { : 
strstr : while : struct static_key sched_feat_keys[__SCHED_FEAT_NR] = { : 
str : #include "features.h"
strstr : INIT : #include "features.h" : 
strstr : if : #include "features.h" : 
strstr : for : #include "features.h" : 
strstr : while : #include "features.h" : 
str : };
strstr : INIT : }; : 
strstr : if : }; : 
strstr : for : }; : 
strstr : while : }; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : #undef SCHED_FEAT
strstr : if : #undef SCHED_FEAT : 
strstr : for : #undef SCHED_FEAT : 
strstr : while : #undef SCHED_FEAT : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : static void sched_feat_disable(int i)
strstr : if : static void sched_feat_disable(int i) : 
strstr : for : static void sched_feat_disable(int i) : 
strstr : while : static void sched_feat_disable(int i) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	if (static_key_enabled(&sched_feat_keys[i]))
strstr : INIT : 	if (static_key_enabled(&sched_feat_keys[i])) : 
strstr : if : 	if (static_key_enabled(&sched_feat_keys[i])) : 
strstr : for : 	if (static_key_enabled(&sched_feat_keys[i])) : 
strstr : while : 	if (static_key_enabled(&sched_feat_keys[i])) : 
str : 		static_key_slow_dec(&sched_feat_keys[i]);
strstr : INIT : 		static_key_slow_dec(&sched_feat_keys[i]); : 
strstr : if : 		static_key_slow_dec(&sched_feat_keys[i]); : 
strstr : for : 		static_key_slow_dec(&sched_feat_keys[i]); : 
strstr : while : 		static_key_slow_dec(&sched_feat_keys[i]); : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : static void sched_feat_enable(int i)
strstr : if : static void sched_feat_enable(int i) : 
strstr : for : static void sched_feat_enable(int i) : 
strstr : while : static void sched_feat_enable(int i) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	if (!static_key_enabled(&sched_feat_keys[i]))
strstr : INIT : 	if (!static_key_enabled(&sched_feat_keys[i])) : 
strstr : if : 	if (!static_key_enabled(&sched_feat_keys[i])) : 
strstr : for : 	if (!static_key_enabled(&sched_feat_keys[i])) : 
strstr : while : 	if (!static_key_enabled(&sched_feat_keys[i])) : 
str : 		static_key_slow_inc(&sched_feat_keys[i]);
strstr : INIT : 		static_key_slow_inc(&sched_feat_keys[i]); : 
strstr : if : 		static_key_slow_inc(&sched_feat_keys[i]); : 
strstr : for : 		static_key_slow_inc(&sched_feat_keys[i]); : 
strstr : while : 		static_key_slow_inc(&sched_feat_keys[i]); : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : #else
strstr : INIT : #else : 
strstr : if : #else : 
strstr : for : #else : 
strstr : while : #else : 
str : static void sched_feat_disable(int i) { };
strstr : INIT : static void sched_feat_disable(int i) { }; : 
strstr : if : static void sched_feat_disable(int i) { }; : 
strstr : for : static void sched_feat_disable(int i) { }; : 
strstr : while : static void sched_feat_disable(int i) { }; : 
str : static void sched_feat_enable(int i) { };
strstr : INIT : static void sched_feat_enable(int i) { }; : 
strstr : if : static void sched_feat_enable(int i) { }; : 
strstr : for : static void sched_feat_enable(int i) { }; : 
strstr : while : static void sched_feat_enable(int i) { }; : 
str : #endif /* HAVE_JUMP_LABEL */
strstr : INIT : #endif /* HAVE_JUMP_LABEL */ : 
strstr : if : #endif /* HAVE_JUMP_LABEL */ : 
strstr : for : #endif /* HAVE_JUMP_LABEL */ : 
strstr : while : #endif /* HAVE_JUMP_LABEL */ : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : static int sched_feat_set(char *cmp)
strstr : if : static int sched_feat_set(char *cmp) : 
strstr : for : static int sched_feat_set(char *cmp) : 
strstr : while : static int sched_feat_set(char *cmp) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	int i;
strstr : INIT : 	int i; : 
strstr : if : 	int i; : 
strstr : for : 	int i; : 
strstr : while : 	int i; : 
str : 	int neg = 0;
strstr : INIT : 	int neg = 0; : 
strstr : if : 	int neg = 0; : 
strstr : for : 	int neg = 0; : 
strstr : while : 	int neg = 0; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	if (strncmp(cmp, "NO_", 3) == 0) {
strstr : if : 	if (strncmp(cmp, "NO_", 3) == 0) { : 
strstr : for : 	if (strncmp(cmp, "NO_", 3) == 0) { : 
strstr : while : 	if (strncmp(cmp, "NO_", 3) == 0) { : 
str : 		neg = 1;
strstr : INIT : 		neg = 1; : 
strstr : if : 		neg = 1; : 
strstr : for : 		neg = 1; : 
strstr : while : 		neg = 1; : 
str : 		cmp += 3;
strstr : INIT : 		cmp += 3; : 
strstr : if : 		cmp += 3; : 
strstr : for : 		cmp += 3; : 
strstr : while : 		cmp += 3; : 
str : 	}
strstr : INIT : 	} : 
strstr : if : 	} : 
strstr : for : 	} : 
strstr : while : 	} : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	for (i = 0; i < __SCHED_FEAT_NR; i++) {
strstr : if : 	for (i = 0; i < __SCHED_FEAT_NR; i++) { : 
strstr : for : 	for (i = 0; i < __SCHED_FEAT_NR; i++) { : 
strstr : while : 	for (i = 0; i < __SCHED_FEAT_NR; i++) { : 
str : 		if (strcmp(cmp, sched_feat_names[i]) == 0) {
strstr : INIT : 		if (strcmp(cmp, sched_feat_names[i]) == 0) { : 
strstr : if : 		if (strcmp(cmp, sched_feat_names[i]) == 0) { : 
strstr : for : 		if (strcmp(cmp, sched_feat_names[i]) == 0) { : 
strstr : while : 		if (strcmp(cmp, sched_feat_names[i]) == 0) { : 
str : 			if (neg) {
strstr : INIT : 			if (neg) { : 
strstr : if : 			if (neg) { : 
strstr : for : 			if (neg) { : 
strstr : while : 			if (neg) { : 
str : 				sysctl_sched_features &= ~(1UL << i);
strstr : INIT : 				sysctl_sched_features &= ~(1UL << i); : 
strstr : if : 				sysctl_sched_features &= ~(1UL << i); : 
strstr : for : 				sysctl_sched_features &= ~(1UL << i); : 
strstr : while : 				sysctl_sched_features &= ~(1UL << i); : 
str : 				sched_feat_disable(i);
strstr : INIT : 				sched_feat_disable(i); : 
strstr : if : 				sched_feat_disable(i); : 
strstr : for : 				sched_feat_disable(i); : 
strstr : while : 				sched_feat_disable(i); : 
str : 			} else {
strstr : INIT : 			} else { : 
strstr : if : 			} else { : 
strstr : for : 			} else { : 
strstr : while : 			} else { : 
str : 				sysctl_sched_features |= (1UL << i);
strstr : INIT : 				sysctl_sched_features |= (1UL << i); : 
strstr : if : 				sysctl_sched_features |= (1UL << i); : 
strstr : for : 				sysctl_sched_features |= (1UL << i); : 
strstr : while : 				sysctl_sched_features |= (1UL << i); : 
str : 				sched_feat_enable(i);
strstr : INIT : 				sched_feat_enable(i); : 
strstr : if : 				sched_feat_enable(i); : 
strstr : for : 				sched_feat_enable(i); : 
strstr : while : 				sched_feat_enable(i); : 
str : 			}
strstr : INIT : 			} : 
strstr : if : 			} : 
strstr : for : 			} : 
strstr : while : 			} : 
str : 			break;
strstr : INIT : 			break; : 
strstr : if : 			break; : 
strstr : for : 			break; : 
strstr : while : 			break; : 
str : 		}
strstr : INIT : 		} : 
strstr : if : 		} : 
strstr : for : 		} : 
strstr : while : 		} : 
str : 	}
strstr : INIT : 	} : 
strstr : if : 	} : 
strstr : for : 	} : 
strstr : while : 	} : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	return i;
strstr : if : 	return i; : 
strstr : for : 	return i; : 
strstr : while : 	return i; : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : static ssize_t
strstr : if : static ssize_t : 
strstr : for : static ssize_t : 
strstr : while : static ssize_t : 
str : sched_feat_write(struct file *filp, const char __user *ubuf,
strstr : INIT : sched_feat_write(struct file *filp, const char __user *ubuf, : 
strstr : if : sched_feat_write(struct file *filp, const char __user *ubuf, : 
strstr : for : sched_feat_write(struct file *filp, const char __user *ubuf, : 
strstr : while : sched_feat_write(struct file *filp, const char __user *ubuf, : 
str : 		size_t cnt, loff_t *ppos)
strstr : INIT : 		size_t cnt, loff_t *ppos) : 
strstr : if : 		size_t cnt, loff_t *ppos) : 
strstr : for : 		size_t cnt, loff_t *ppos) : 
strstr : while : 		size_t cnt, loff_t *ppos) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	char buf[64];
strstr : INIT : 	char buf[64]; : 
strstr : if : 	char buf[64]; : 
strstr : for : 	char buf[64]; : 
strstr : while : 	char buf[64]; : 
str : 	char *cmp;
strstr : INIT : 	char *cmp; : 
strstr : if : 	char *cmp; : 
strstr : for : 	char *cmp; : 
strstr : while : 	char *cmp; : 
str : 	int i;
strstr : INIT : 	int i; : 
strstr : if : 	int i; : 
strstr : for : 	int i; : 
strstr : while : 	int i; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	if (cnt > 63)
strstr : if : 	if (cnt > 63) : 
strstr : for : 	if (cnt > 63) : 
strstr : while : 	if (cnt > 63) : 
str : 		cnt = 63;
strstr : INIT : 		cnt = 63; : 
strstr : if : 		cnt = 63; : 
strstr : for : 		cnt = 63; : 
strstr : while : 		cnt = 63; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	if (copy_from_user(&buf, ubuf, cnt))
strstr : if : 	if (copy_from_user(&buf, ubuf, cnt)) : 
strstr : for : 	if (copy_from_user(&buf, ubuf, cnt)) : 
strstr : while : 	if (copy_from_user(&buf, ubuf, cnt)) : 
str : 		return -EFAULT;
strstr : INIT : 		return -EFAULT; : 
strstr : if : 		return -EFAULT; : 
strstr : for : 		return -EFAULT; : 
strstr : while : 		return -EFAULT; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	buf[cnt] = 0;
strstr : if : 	buf[cnt] = 0; : 
strstr : for : 	buf[cnt] = 0; : 
strstr : while : 	buf[cnt] = 0; : 
str : 	cmp = strstrip(buf);
strstr : INIT : 	cmp = strstrip(buf); : 
strstr : if : 	cmp = strstrip(buf); : 
strstr : for : 	cmp = strstrip(buf); : 
strstr : while : 	cmp = strstrip(buf); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	i = sched_feat_set(cmp);
strstr : if : 	i = sched_feat_set(cmp); : 
strstr : for : 	i = sched_feat_set(cmp); : 
strstr : while : 	i = sched_feat_set(cmp); : 
str : 	if (i == __SCHED_FEAT_NR)
strstr : INIT : 	if (i == __SCHED_FEAT_NR) : 
strstr : if : 	if (i == __SCHED_FEAT_NR) : 
strstr : for : 	if (i == __SCHED_FEAT_NR) : 
strstr : while : 	if (i == __SCHED_FEAT_NR) : 
str : 		return -EINVAL;
strstr : INIT : 		return -EINVAL; : 
strstr : if : 		return -EINVAL; : 
strstr : for : 		return -EINVAL; : 
strstr : while : 		return -EINVAL; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	*ppos += cnt;
strstr : if : 	*ppos += cnt; : 
strstr : for : 	*ppos += cnt; : 
strstr : while : 	*ppos += cnt; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	return cnt;
strstr : if : 	return cnt; : 
strstr : for : 	return cnt; : 
strstr : while : 	return cnt; : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : static int sched_feat_open(struct inode *inode, struct file *filp)
strstr : if : static int sched_feat_open(struct inode *inode, struct file *filp) : 
strstr : for : static int sched_feat_open(struct inode *inode, struct file *filp) : 
strstr : while : static int sched_feat_open(struct inode *inode, struct file *filp) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	return single_open(filp, sched_feat_show, NULL);
strstr : INIT : 	return single_open(filp, sched_feat_show, NULL); : 
strstr : if : 	return single_open(filp, sched_feat_show, NULL); : 
strstr : for : 	return single_open(filp, sched_feat_show, NULL); : 
strstr : while : 	return single_open(filp, sched_feat_show, NULL); : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : static const struct file_operations sched_feat_fops = {
strstr : if : static const struct file_operations sched_feat_fops = { : 
strstr : for : static const struct file_operations sched_feat_fops = { : 
strstr : while : static const struct file_operations sched_feat_fops = { : 
str : 	.open		= sched_feat_open,
strstr : INIT : 	.open		= sched_feat_open, : 
strstr : if : 	.open		= sched_feat_open, : 
strstr : for : 	.open		= sched_feat_open, : 
strstr : while : 	.open		= sched_feat_open, : 
str : 	.write		= sched_feat_write,
strstr : INIT : 	.write		= sched_feat_write, : 
strstr : if : 	.write		= sched_feat_write, : 
strstr : for : 	.write		= sched_feat_write, : 
strstr : while : 	.write		= sched_feat_write, : 
str : 	.read		= seq_read,
strstr : INIT : 	.read		= seq_read, : 
strstr : if : 	.read		= seq_read, : 
strstr : for : 	.read		= seq_read, : 
strstr : while : 	.read		= seq_read, : 
str : 	.llseek		= seq_lseek,
strstr : INIT : 	.llseek		= seq_lseek, : 
strstr : if : 	.llseek		= seq_lseek, : 
strstr : for : 	.llseek		= seq_lseek, : 
strstr : while : 	.llseek		= seq_lseek, : 
str : 	.release	= single_release,
strstr : INIT : 	.release	= single_release, : 
strstr : if : 	.release	= single_release, : 
strstr : for : 	.release	= single_release, : 
strstr : while : 	.release	= single_release, : 
str : };
strstr : INIT : }; : 
strstr : if : }; : 
strstr : for : }; : 
strstr : while : }; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : static __init int sched_init_debug(void)
strstr : if : static __init int sched_init_debug(void) : 
strstr : for : static __init int sched_init_debug(void) : 
strstr : while : static __init int sched_init_debug(void) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	debugfs_create_file("sched_features", 0644, NULL, NULL,
strstr : INIT : 	debugfs_create_file("sched_features", 0644, NULL, NULL, : 
strstr : if : 	debugfs_create_file("sched_features", 0644, NULL, NULL, : 
strstr : for : 	debugfs_create_file("sched_features", 0644, NULL, NULL, : 
strstr : while : 	debugfs_create_file("sched_features", 0644, NULL, NULL, : 
str : 			&sched_feat_fops);
strstr : INIT : 			&sched_feat_fops); : 
strstr : if : 			&sched_feat_fops); : 
strstr : for : 			&sched_feat_fops); : 
strstr : while : 			&sched_feat_fops); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	return 0;
strstr : if : 	return 0; : 
strstr : for : 	return 0; : 
strstr : while : 	return 0; : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : late_initcall(sched_init_debug);
strstr : INIT : late_initcall(sched_init_debug); : 
strstr : if : late_initcall(sched_init_debug); : 
strstr : for : late_initcall(sched_init_debug); : 
strstr : while : late_initcall(sched_init_debug); : 
str : #endif /* CONFIG_SCHED_DEBUG */
strstr : INIT : #endif /* CONFIG_SCHED_DEBUG */ : 
strstr : if : #endif /* CONFIG_SCHED_DEBUG */ : 
strstr : for : #endif /* CONFIG_SCHED_DEBUG */ : 
strstr : while : #endif /* CONFIG_SCHED_DEBUG */ : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : /*
strstr : if : /* : 
strstr : for : /* : 
strstr : while : /* : 
str :  * Number of tasks to iterate in a single balance run.
strstr : INIT :  * Number of tasks to iterate in a single balance run. : 
strstr : if :  * Number of tasks to iterate in a single balance run. : 
strstr : for :  * Number of tasks to iterate in a single balance run. : 
strstr : while :  * Number of tasks to iterate in a single balance run. : 
str :  * Limited because this is done with IRQs disabled.
strstr : INIT :  * Limited because this is done with IRQs disabled. : 
strstr : if :  * Limited because this is done with IRQs disabled. : 
strstr : for :  * Limited because this is done with IRQs disabled. : 
strstr : while :  * Limited because this is done with IRQs disabled. : 
str :  */
strstr : INIT :  */ : 
strstr : if :  */ : 
strstr : for :  */ : 
strstr : while :  */ : 
str : const_debug unsigned int sysctl_sched_nr_migrate = 32;
strstr : INIT : const_debug unsigned int sysctl_sched_nr_migrate = 32; : 
strstr : if : const_debug unsigned int sysctl_sched_nr_migrate = 32; : 
strstr : for : const_debug unsigned int sysctl_sched_nr_migrate = 32; : 
strstr : while : const_debug unsigned int sysctl_sched_nr_migrate = 32; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : /*
strstr : if : /* : 
strstr : for : /* : 
strstr : while : /* : 
str :  * period over which we average the RT time consumption, measured
strstr : INIT :  * period over which we average the RT time consumption, measured : 
strstr : if :  * period over which we average the RT time consumption, measured : 
strstr : for :  * period over which we average the RT time consumption, measured : 
strstr : while :  * period over which we average the RT time consumption, measured : 
str :  * in ms.
strstr : INIT :  * in ms. : 
strstr : if :  * in ms. : 
strstr : for :  * in ms. : 
strstr : while :  * in ms. : 
str :  *
strstr : INIT :  * : 
strstr : if :  * : 
strstr : for :  * : 
strstr : while :  * : 
str :  * default: 1s
strstr : INIT :  * default: 1s : 
strstr : if :  * default: 1s : 
strstr : for :  * default: 1s : 
strstr : while :  * default: 1s : 
str :  */
strstr : INIT :  */ : 
strstr : if :  */ : 
strstr : for :  */ : 
strstr : while :  */ : 
str : const_debug unsigned int sysctl_sched_time_avg = MSEC_PER_SEC;
strstr : INIT : const_debug unsigned int sysctl_sched_time_avg = MSEC_PER_SEC; : 
strstr : if : const_debug unsigned int sysctl_sched_time_avg = MSEC_PER_SEC; : 
strstr : for : const_debug unsigned int sysctl_sched_time_avg = MSEC_PER_SEC; : 
strstr : while : const_debug unsigned int sysctl_sched_time_avg = MSEC_PER_SEC; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : /*
strstr : if : /* : 
strstr : for : /* : 
strstr : while : /* : 
str :  * period over which we measure -rt task cpu usage in us.
strstr : INIT :  * period over which we measure -rt task cpu usage in us. : 
strstr : if :  * period over which we measure -rt task cpu usage in us. : 
strstr : for :  * period over which we measure -rt task cpu usage in us. : 
strstr : while :  * period over which we measure -rt task cpu usage in us. : 
str :  * default: 1s
strstr : INIT :  * default: 1s : 
strstr : if :  * default: 1s : 
strstr : for :  * default: 1s : 
strstr : while :  * default: 1s : 
str :  */
strstr : INIT :  */ : 
strstr : if :  */ : 
strstr : for :  */ : 
strstr : while :  */ : 
str : unsigned int sysctl_sched_rt_period = 1000000;
strstr : INIT : unsigned int sysctl_sched_rt_period = 1000000; : 
strstr : if : unsigned int sysctl_sched_rt_period = 1000000; : 
strstr : for : unsigned int sysctl_sched_rt_period = 1000000; : 
strstr : while : unsigned int sysctl_sched_rt_period = 1000000; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : __read_mostly int scheduler_running;
strstr : if : __read_mostly int scheduler_running; : 
strstr : for : __read_mostly int scheduler_running; : 
strstr : while : __read_mostly int scheduler_running; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : /*
strstr : if : /* : 
strstr : for : /* : 
strstr : while : /* : 
str :  * part of the period that we allow rt tasks to run in us.
strstr : INIT :  * part of the period that we allow rt tasks to run in us. : 
strstr : if :  * part of the period that we allow rt tasks to run in us. : 
strstr : for :  * part of the period that we allow rt tasks to run in us. : 
strstr : while :  * part of the period that we allow rt tasks to run in us. : 
str :  * default: 0.95s
strstr : INIT :  * default: 0.95s : 
strstr : if :  * default: 0.95s : 
strstr : for :  * default: 0.95s : 
strstr : while :  * default: 0.95s : 
str :  */
strstr : INIT :  */ : 
strstr : if :  */ : 
strstr : for :  */ : 
strstr : while :  */ : 
str : int sysctl_sched_rt_runtime = 950000;
strstr : INIT : int sysctl_sched_rt_runtime = 950000; : 
strstr : if : int sysctl_sched_rt_runtime = 950000; : 
strstr : for : int sysctl_sched_rt_runtime = 950000; : 
strstr : while : int sysctl_sched_rt_runtime = 950000; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : /*
strstr : if : /* : 
strstr : for : /* : 
strstr : while : /* : 
str :  * __task_rq_lock - lock the rq @p resides on.
strstr : INIT :  * __task_rq_lock - lock the rq @p resides on. : 
strstr : if :  * __task_rq_lock - lock the rq @p resides on. : 
strstr : for :  * __task_rq_lock - lock the rq @p resides on. : 
strstr : while :  * __task_rq_lock - lock the rq @p resides on. : 
str :  */
strstr : INIT :  */ : 
strstr : if :  */ : 
strstr : for :  */ : 
strstr : while :  */ : 
str : static inline struct rq *__task_rq_lock(struct task_struct *p)
strstr : INIT : static inline struct rq *__task_rq_lock(struct task_struct *p) : 
strstr : if : static inline struct rq *__task_rq_lock(struct task_struct *p) : 
strstr : for : static inline struct rq *__task_rq_lock(struct task_struct *p) : 
strstr : while : static inline struct rq *__task_rq_lock(struct task_struct *p) : 
str : 	__acquires(rq->lock)
strstr : INIT : 	__acquires(rq->lock) : 
strstr : if : 	__acquires(rq->lock) : 
strstr : for : 	__acquires(rq->lock) : 
strstr : while : 	__acquires(rq->lock) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	struct rq *rq;
strstr : INIT : 	struct rq *rq; : 
strstr : if : 	struct rq *rq; : 
strstr : for : 	struct rq *rq; : 
strstr : while : 	struct rq *rq; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	lockdep_assert_held(&p->pi_lock);
strstr : if : 	lockdep_assert_held(&p->pi_lock); : 
strstr : for : 	lockdep_assert_held(&p->pi_lock); : 
strstr : while : 	lockdep_assert_held(&p->pi_lock); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	for (;;) {
strstr : if : 	for (;;) { : 
strstr : for : 	for (;;) { : 
strstr : while : 	for (;;) { : 
str : 		rq = task_rq(p);
strstr : INIT : 		rq = task_rq(p); : 
strstr : if : 		rq = task_rq(p); : 
strstr : for : 		rq = task_rq(p); : 
strstr : while : 		rq = task_rq(p); : 
str : 		raw_spin_lock(&rq->lock);
strstr : INIT : 		raw_spin_lock(&rq->lock); : 
strstr : if : 		raw_spin_lock(&rq->lock); : 
strstr : for : 		raw_spin_lock(&rq->lock); : 
strstr : while : 		raw_spin_lock(&rq->lock); : 
str : 		if (likely(rq == task_rq(p)))
strstr : INIT : 		if (likely(rq == task_rq(p))) : 
strstr : if : 		if (likely(rq == task_rq(p))) : 
strstr : for : 		if (likely(rq == task_rq(p))) : 
strstr : while : 		if (likely(rq == task_rq(p))) : 
str : 			return rq;
strstr : INIT : 			return rq; : 
strstr : if : 			return rq; : 
strstr : for : 			return rq; : 
strstr : while : 			return rq; : 
str : 		raw_spin_unlock(&rq->lock);
strstr : INIT : 		raw_spin_unlock(&rq->lock); : 
strstr : if : 		raw_spin_unlock(&rq->lock); : 
strstr : for : 		raw_spin_unlock(&rq->lock); : 
strstr : while : 		raw_spin_unlock(&rq->lock); : 
str : 	}
strstr : INIT : 	} : 
strstr : if : 	} : 
strstr : for : 	} : 
strstr : while : 	} : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : /*
strstr : if : /* : 
strstr : for : /* : 
strstr : while : /* : 
str :  * task_rq_lock - lock p->pi_lock and lock the rq @p resides on.
strstr : INIT :  * task_rq_lock - lock p->pi_lock and lock the rq @p resides on. : 
strstr : if :  * task_rq_lock - lock p->pi_lock and lock the rq @p resides on. : 
strstr : for :  * task_rq_lock - lock p->pi_lock and lock the rq @p resides on. : 
strstr : while :  * task_rq_lock - lock p->pi_lock and lock the rq @p resides on. : 
str :  */
strstr : INIT :  */ : 
strstr : if :  */ : 
strstr : for :  */ : 
strstr : while :  */ : 
str : static struct rq *task_rq_lock(struct task_struct *p, unsigned long *flags)
strstr : INIT : static struct rq *task_rq_lock(struct task_struct *p, unsigned long *flags) : 
strstr : if : static struct rq *task_rq_lock(struct task_struct *p, unsigned long *flags) : 
strstr : for : static struct rq *task_rq_lock(struct task_struct *p, unsigned long *flags) : 
strstr : while : static struct rq *task_rq_lock(struct task_struct *p, unsigned long *flags) : 
str : 	__acquires(p->pi_lock)
strstr : INIT : 	__acquires(p->pi_lock) : 
strstr : if : 	__acquires(p->pi_lock) : 
strstr : for : 	__acquires(p->pi_lock) : 
strstr : while : 	__acquires(p->pi_lock) : 
str : 	__acquires(rq->lock)
strstr : INIT : 	__acquires(rq->lock) : 
strstr : if : 	__acquires(rq->lock) : 
strstr : for : 	__acquires(rq->lock) : 
strstr : while : 	__acquires(rq->lock) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	struct rq *rq;
strstr : INIT : 	struct rq *rq; : 
strstr : if : 	struct rq *rq; : 
strstr : for : 	struct rq *rq; : 
strstr : while : 	struct rq *rq; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	for (;;) {
strstr : if : 	for (;;) { : 
strstr : for : 	for (;;) { : 
strstr : while : 	for (;;) { : 
str : 		raw_spin_lock_irqsave(&p->pi_lock, *flags);
strstr : INIT : 		raw_spin_lock_irqsave(&p->pi_lock, *flags); : 
strstr : if : 		raw_spin_lock_irqsave(&p->pi_lock, *flags); : 
strstr : for : 		raw_spin_lock_irqsave(&p->pi_lock, *flags); : 
strstr : while : 		raw_spin_lock_irqsave(&p->pi_lock, *flags); : 
str : 		rq = task_rq(p);
strstr : INIT : 		rq = task_rq(p); : 
strstr : if : 		rq = task_rq(p); : 
strstr : for : 		rq = task_rq(p); : 
strstr : while : 		rq = task_rq(p); : 
str : 		raw_spin_lock(&rq->lock);
strstr : INIT : 		raw_spin_lock(&rq->lock); : 
strstr : if : 		raw_spin_lock(&rq->lock); : 
strstr : for : 		raw_spin_lock(&rq->lock); : 
strstr : while : 		raw_spin_lock(&rq->lock); : 
str : 		if (likely(rq == task_rq(p)))
strstr : INIT : 		if (likely(rq == task_rq(p))) : 
strstr : if : 		if (likely(rq == task_rq(p))) : 
strstr : for : 		if (likely(rq == task_rq(p))) : 
strstr : while : 		if (likely(rq == task_rq(p))) : 
str : 			return rq;
strstr : INIT : 			return rq; : 
strstr : if : 			return rq; : 
strstr : for : 			return rq; : 
strstr : while : 			return rq; : 
str : 		raw_spin_unlock(&rq->lock);
strstr : INIT : 		raw_spin_unlock(&rq->lock); : 
strstr : if : 		raw_spin_unlock(&rq->lock); : 
strstr : for : 		raw_spin_unlock(&rq->lock); : 
strstr : while : 		raw_spin_unlock(&rq->lock); : 
str : 		raw_spin_unlock_irqrestore(&p->pi_lock, *flags);
strstr : INIT : 		raw_spin_unlock_irqrestore(&p->pi_lock, *flags); : 
strstr : if : 		raw_spin_unlock_irqrestore(&p->pi_lock, *flags); : 
strstr : for : 		raw_spin_unlock_irqrestore(&p->pi_lock, *flags); : 
strstr : while : 		raw_spin_unlock_irqrestore(&p->pi_lock, *flags); : 
str : 	}
strstr : INIT : 	} : 
strstr : if : 	} : 
strstr : for : 	} : 
strstr : while : 	} : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : static void __task_rq_unlock(struct rq *rq)
strstr : if : static void __task_rq_unlock(struct rq *rq) : 
strstr : for : static void __task_rq_unlock(struct rq *rq) : 
strstr : while : static void __task_rq_unlock(struct rq *rq) : 
str : 	__releases(rq->lock)
strstr : INIT : 	__releases(rq->lock) : 
strstr : if : 	__releases(rq->lock) : 
strstr : for : 	__releases(rq->lock) : 
strstr : while : 	__releases(rq->lock) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	raw_spin_unlock(&rq->lock);
strstr : INIT : 	raw_spin_unlock(&rq->lock); : 
strstr : if : 	raw_spin_unlock(&rq->lock); : 
strstr : for : 	raw_spin_unlock(&rq->lock); : 
strstr : while : 	raw_spin_unlock(&rq->lock); : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : static inline void
strstr : if : static inline void : 
strstr : for : static inline void : 
strstr : while : static inline void : 
str : task_rq_unlock(struct rq *rq, struct task_struct *p, unsigned long *flags)
strstr : INIT : task_rq_unlock(struct rq *rq, struct task_struct *p, unsigned long *flags) : 
strstr : if : task_rq_unlock(struct rq *rq, struct task_struct *p, unsigned long *flags) : 
strstr : for : task_rq_unlock(struct rq *rq, struct task_struct *p, unsigned long *flags) : 
strstr : while : task_rq_unlock(struct rq *rq, struct task_struct *p, unsigned long *flags) : 
str : 	__releases(rq->lock)
strstr : INIT : 	__releases(rq->lock) : 
strstr : if : 	__releases(rq->lock) : 
strstr : for : 	__releases(rq->lock) : 
strstr : while : 	__releases(rq->lock) : 
str : 	__releases(p->pi_lock)
strstr : INIT : 	__releases(p->pi_lock) : 
strstr : if : 	__releases(p->pi_lock) : 
strstr : for : 	__releases(p->pi_lock) : 
strstr : while : 	__releases(p->pi_lock) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	raw_spin_unlock(&rq->lock);
strstr : INIT : 	raw_spin_unlock(&rq->lock); : 
strstr : if : 	raw_spin_unlock(&rq->lock); : 
strstr : for : 	raw_spin_unlock(&rq->lock); : 
strstr : while : 	raw_spin_unlock(&rq->lock); : 
str : 	raw_spin_unlock_irqrestore(&p->pi_lock, *flags);
strstr : INIT : 	raw_spin_unlock_irqrestore(&p->pi_lock, *flags); : 
strstr : if : 	raw_spin_unlock_irqrestore(&p->pi_lock, *flags); : 
strstr : for : 	raw_spin_unlock_irqrestore(&p->pi_lock, *flags); : 
strstr : while : 	raw_spin_unlock_irqrestore(&p->pi_lock, *flags); : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : /*
strstr : if : /* : 
strstr : for : /* : 
strstr : while : /* : 
str :  * this_rq_lock - lock this runqueue and disable interrupts.
strstr : INIT :  * this_rq_lock - lock this runqueue and disable interrupts. : 
strstr : if :  * this_rq_lock - lock this runqueue and disable interrupts. : 
strstr : for :  * this_rq_lock - lock this runqueue and disable interrupts. : 
strstr : while :  * this_rq_lock - lock this runqueue and disable interrupts. : 
str :  */
strstr : INIT :  */ : 
strstr : if :  */ : 
strstr : for :  */ : 
strstr : while :  */ : 
str : static struct rq *this_rq_lock(void)
strstr : INIT : static struct rq *this_rq_lock(void) : 
strstr : if : static struct rq *this_rq_lock(void) : 
strstr : for : static struct rq *this_rq_lock(void) : 
strstr : while : static struct rq *this_rq_lock(void) : 
str : 	__acquires(rq->lock)
strstr : INIT : 	__acquires(rq->lock) : 
strstr : if : 	__acquires(rq->lock) : 
strstr : for : 	__acquires(rq->lock) : 
strstr : while : 	__acquires(rq->lock) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	struct rq *rq;
strstr : INIT : 	struct rq *rq; : 
strstr : if : 	struct rq *rq; : 
strstr : for : 	struct rq *rq; : 
strstr : while : 	struct rq *rq; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	local_irq_disable();
strstr : if : 	local_irq_disable(); : 
strstr : for : 	local_irq_disable(); : 
strstr : while : 	local_irq_disable(); : 
str : 	rq = this_rq();
strstr : INIT : 	rq = this_rq(); : 
strstr : if : 	rq = this_rq(); : 
strstr : for : 	rq = this_rq(); : 
strstr : while : 	rq = this_rq(); : 
str : 	raw_spin_lock(&rq->lock);
strstr : INIT : 	raw_spin_lock(&rq->lock); : 
strstr : if : 	raw_spin_lock(&rq->lock); : 
strstr : for : 	raw_spin_lock(&rq->lock); : 
strstr : while : 	raw_spin_lock(&rq->lock); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	return rq;
strstr : if : 	return rq; : 
strstr : for : 	return rq; : 
strstr : while : 	return rq; : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : #ifdef CONFIG_SCHED_HRTICK
strstr : if : #ifdef CONFIG_SCHED_HRTICK : 
strstr : for : #ifdef CONFIG_SCHED_HRTICK : 
strstr : while : #ifdef CONFIG_SCHED_HRTICK : 
str : /*
strstr : INIT : /* : 
strstr : if : /* : 
strstr : for : /* : 
strstr : while : /* : 
str :  * Use HR-timers to deliver accurate preemption points.
strstr : INIT :  * Use HR-timers to deliver accurate preemption points. : 
strstr : if :  * Use HR-timers to deliver accurate preemption points. : 
strstr : for :  * Use HR-timers to deliver accurate preemption points. : 
strstr : while :  * Use HR-timers to deliver accurate preemption points. : 
str :  */
strstr : INIT :  */ : 
strstr : if :  */ : 
strstr : for :  */ : 
strstr : while :  */ : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : static void hrtick_clear(struct rq *rq)
strstr : if : static void hrtick_clear(struct rq *rq) : 
strstr : for : static void hrtick_clear(struct rq *rq) : 
strstr : while : static void hrtick_clear(struct rq *rq) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	if (hrtimer_active(&rq->hrtick_timer))
strstr : INIT : 	if (hrtimer_active(&rq->hrtick_timer)) : 
strstr : if : 	if (hrtimer_active(&rq->hrtick_timer)) : 
strstr : for : 	if (hrtimer_active(&rq->hrtick_timer)) : 
strstr : while : 	if (hrtimer_active(&rq->hrtick_timer)) : 
str : 		hrtimer_cancel(&rq->hrtick_timer);
strstr : INIT : 		hrtimer_cancel(&rq->hrtick_timer); : 
strstr : if : 		hrtimer_cancel(&rq->hrtick_timer); : 
strstr : for : 		hrtimer_cancel(&rq->hrtick_timer); : 
strstr : while : 		hrtimer_cancel(&rq->hrtick_timer); : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : /*
strstr : if : /* : 
strstr : for : /* : 
strstr : while : /* : 
str :  * High-resolution timer tick.
strstr : INIT :  * High-resolution timer tick. : 
strstr : if :  * High-resolution timer tick. : 
strstr : for :  * High-resolution timer tick. : 
strstr : while :  * High-resolution timer tick. : 
str :  * Runs from hardirq context with interrupts disabled.
strstr : INIT :  * Runs from hardirq context with interrupts disabled. : 
strstr : if :  * Runs from hardirq context with interrupts disabled. : 
strstr : for :  * Runs from hardirq context with interrupts disabled. : 
strstr : while :  * Runs from hardirq context with interrupts disabled. : 
str :  */
strstr : INIT :  */ : 
strstr : if :  */ : 
strstr : for :  */ : 
strstr : while :  */ : 
str : static enum hrtimer_restart hrtick(struct hrtimer *timer)
strstr : INIT : static enum hrtimer_restart hrtick(struct hrtimer *timer) : 
strstr : if : static enum hrtimer_restart hrtick(struct hrtimer *timer) : 
strstr : for : static enum hrtimer_restart hrtick(struct hrtimer *timer) : 
strstr : while : static enum hrtimer_restart hrtick(struct hrtimer *timer) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	struct rq *rq = container_of(timer, struct rq, hrtick_timer);
strstr : INIT : 	struct rq *rq = container_of(timer, struct rq, hrtick_timer); : 
strstr : if : 	struct rq *rq = container_of(timer, struct rq, hrtick_timer); : 
strstr : for : 	struct rq *rq = container_of(timer, struct rq, hrtick_timer); : 
strstr : while : 	struct rq *rq = container_of(timer, struct rq, hrtick_timer); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	WARN_ON_ONCE(cpu_of(rq) != smp_processor_id());
strstr : if : 	WARN_ON_ONCE(cpu_of(rq) != smp_processor_id()); : 
strstr : for : 	WARN_ON_ONCE(cpu_of(rq) != smp_processor_id()); : 
strstr : while : 	WARN_ON_ONCE(cpu_of(rq) != smp_processor_id()); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	raw_spin_lock(&rq->lock);
strstr : if : 	raw_spin_lock(&rq->lock); : 
strstr : for : 	raw_spin_lock(&rq->lock); : 
strstr : while : 	raw_spin_lock(&rq->lock); : 
str : 	update_rq_clock(rq);
strstr : INIT : 	update_rq_clock(rq); : 
strstr : if : 	update_rq_clock(rq); : 
strstr : for : 	update_rq_clock(rq); : 
strstr : while : 	update_rq_clock(rq); : 
str : 	rq->curr->sched_class->task_tick(rq, rq->curr, 1);
strstr : INIT : 	rq->curr->sched_class->task_tick(rq, rq->curr, 1); : 
strstr : if : 	rq->curr->sched_class->task_tick(rq, rq->curr, 1); : 
strstr : for : 	rq->curr->sched_class->task_tick(rq, rq->curr, 1); : 
strstr : while : 	rq->curr->sched_class->task_tick(rq, rq->curr, 1); : 
str : 	raw_spin_unlock(&rq->lock);
strstr : INIT : 	raw_spin_unlock(&rq->lock); : 
strstr : if : 	raw_spin_unlock(&rq->lock); : 
strstr : for : 	raw_spin_unlock(&rq->lock); : 
strstr : while : 	raw_spin_unlock(&rq->lock); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	return HRTIMER_NORESTART;
strstr : if : 	return HRTIMER_NORESTART; : 
strstr : for : 	return HRTIMER_NORESTART; : 
strstr : while : 	return HRTIMER_NORESTART; : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : #ifdef CONFIG_SMP
strstr : if : #ifdef CONFIG_SMP : 
strstr : for : #ifdef CONFIG_SMP : 
strstr : while : #ifdef CONFIG_SMP : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : static int __hrtick_restart(struct rq *rq)
strstr : if : static int __hrtick_restart(struct rq *rq) : 
strstr : for : static int __hrtick_restart(struct rq *rq) : 
strstr : while : static int __hrtick_restart(struct rq *rq) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	struct hrtimer *timer = &rq->hrtick_timer;
strstr : INIT : 	struct hrtimer *timer = &rq->hrtick_timer; : 
strstr : if : 	struct hrtimer *timer = &rq->hrtick_timer; : 
strstr : for : 	struct hrtimer *timer = &rq->hrtick_timer; : 
strstr : while : 	struct hrtimer *timer = &rq->hrtick_timer; : 
str : 	ktime_t time = hrtimer_get_softexpires(timer);
strstr : INIT : 	ktime_t time = hrtimer_get_softexpires(timer); : 
strstr : if : 	ktime_t time = hrtimer_get_softexpires(timer); : 
strstr : for : 	ktime_t time = hrtimer_get_softexpires(timer); : 
strstr : while : 	ktime_t time = hrtimer_get_softexpires(timer); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	return __hrtimer_start_range_ns(timer, time, 0, HRTIMER_MODE_ABS_PINNED, 0);
strstr : if : 	return __hrtimer_start_range_ns(timer, time, 0, HRTIMER_MODE_ABS_PINNED, 0); : 
strstr : for : 	return __hrtimer_start_range_ns(timer, time, 0, HRTIMER_MODE_ABS_PINNED, 0); : 
strstr : while : 	return __hrtimer_start_range_ns(timer, time, 0, HRTIMER_MODE_ABS_PINNED, 0); : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : /*
strstr : if : /* : 
strstr : for : /* : 
strstr : while : /* : 
str :  * called from hardirq (IPI) context
strstr : INIT :  * called from hardirq (IPI) context : 
strstr : if :  * called from hardirq (IPI) context : 
strstr : for :  * called from hardirq (IPI) context : 
strstr : while :  * called from hardirq (IPI) context : 
str :  */
strstr : INIT :  */ : 
strstr : if :  */ : 
strstr : for :  */ : 
strstr : while :  */ : 
str : static void __hrtick_start(void *arg)
strstr : INIT : static void __hrtick_start(void *arg) : 
strstr : if : static void __hrtick_start(void *arg) : 
strstr : for : static void __hrtick_start(void *arg) : 
strstr : while : static void __hrtick_start(void *arg) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	struct rq *rq = arg;
strstr : INIT : 	struct rq *rq = arg; : 
strstr : if : 	struct rq *rq = arg; : 
strstr : for : 	struct rq *rq = arg; : 
strstr : while : 	struct rq *rq = arg; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	raw_spin_lock(&rq->lock);
strstr : if : 	raw_spin_lock(&rq->lock); : 
strstr : for : 	raw_spin_lock(&rq->lock); : 
strstr : while : 	raw_spin_lock(&rq->lock); : 
str : 	__hrtick_restart(rq);
strstr : INIT : 	__hrtick_restart(rq); : 
strstr : if : 	__hrtick_restart(rq); : 
strstr : for : 	__hrtick_restart(rq); : 
strstr : while : 	__hrtick_restart(rq); : 
str : 	rq->hrtick_csd_pending = 0;
strstr : INIT : 	rq->hrtick_csd_pending = 0; : 
strstr : if : 	rq->hrtick_csd_pending = 0; : 
strstr : for : 	rq->hrtick_csd_pending = 0; : 
strstr : while : 	rq->hrtick_csd_pending = 0; : 
str : 	raw_spin_unlock(&rq->lock);
strstr : INIT : 	raw_spin_unlock(&rq->lock); : 
strstr : if : 	raw_spin_unlock(&rq->lock); : 
strstr : for : 	raw_spin_unlock(&rq->lock); : 
strstr : while : 	raw_spin_unlock(&rq->lock); : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : /*
strstr : if : /* : 
strstr : for : /* : 
strstr : while : /* : 
str :  * Called to set the hrtick timer state.
strstr : INIT :  * Called to set the hrtick timer state. : 
strstr : if :  * Called to set the hrtick timer state. : 
strstr : for :  * Called to set the hrtick timer state. : 
strstr : while :  * Called to set the hrtick timer state. : 
str :  *
strstr : INIT :  * : 
strstr : if :  * : 
strstr : for :  * : 
strstr : while :  * : 
str :  * called with rq->lock held and irqs disabled
strstr : INIT :  * called with rq->lock held and irqs disabled : 
strstr : if :  * called with rq->lock held and irqs disabled : 
strstr : for :  * called with rq->lock held and irqs disabled : 
strstr : while :  * called with rq->lock held and irqs disabled : 
str :  */
strstr : INIT :  */ : 
strstr : if :  */ : 
strstr : for :  */ : 
strstr : while :  */ : 
str : void hrtick_start(struct rq *rq, u64 delay)
strstr : INIT : void hrtick_start(struct rq *rq, u64 delay) : 
strstr : if : void hrtick_start(struct rq *rq, u64 delay) : 
strstr : for : void hrtick_start(struct rq *rq, u64 delay) : 
strstr : while : void hrtick_start(struct rq *rq, u64 delay) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	struct hrtimer *timer = &rq->hrtick_timer;
strstr : INIT : 	struct hrtimer *timer = &rq->hrtick_timer; : 
strstr : if : 	struct hrtimer *timer = &rq->hrtick_timer; : 
strstr : for : 	struct hrtimer *timer = &rq->hrtick_timer; : 
strstr : while : 	struct hrtimer *timer = &rq->hrtick_timer; : 
str : 	ktime_t time = ktime_add_ns(timer->base->get_time(), delay);
strstr : INIT : 	ktime_t time = ktime_add_ns(timer->base->get_time(), delay); : 
strstr : if : 	ktime_t time = ktime_add_ns(timer->base->get_time(), delay); : 
strstr : for : 	ktime_t time = ktime_add_ns(timer->base->get_time(), delay); : 
strstr : while : 	ktime_t time = ktime_add_ns(timer->base->get_time(), delay); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	hrtimer_set_expires(timer, time);
strstr : if : 	hrtimer_set_expires(timer, time); : 
strstr : for : 	hrtimer_set_expires(timer, time); : 
strstr : while : 	hrtimer_set_expires(timer, time); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	if (rq == this_rq()) {
strstr : if : 	if (rq == this_rq()) { : 
strstr : for : 	if (rq == this_rq()) { : 
strstr : while : 	if (rq == this_rq()) { : 
str : 		__hrtick_restart(rq);
strstr : INIT : 		__hrtick_restart(rq); : 
strstr : if : 		__hrtick_restart(rq); : 
strstr : for : 		__hrtick_restart(rq); : 
strstr : while : 		__hrtick_restart(rq); : 
str : 	} else if (!rq->hrtick_csd_pending) {
strstr : INIT : 	} else if (!rq->hrtick_csd_pending) { : 
strstr : if : 	} else if (!rq->hrtick_csd_pending) { : 
strstr : for : 	} else if (!rq->hrtick_csd_pending) { : 
strstr : while : 	} else if (!rq->hrtick_csd_pending) { : 
str : 		__smp_call_function_single(cpu_of(rq), &rq->hrtick_csd, 0);
strstr : INIT : 		__smp_call_function_single(cpu_of(rq), &rq->hrtick_csd, 0); : 
strstr : if : 		__smp_call_function_single(cpu_of(rq), &rq->hrtick_csd, 0); : 
strstr : for : 		__smp_call_function_single(cpu_of(rq), &rq->hrtick_csd, 0); : 
strstr : while : 		__smp_call_function_single(cpu_of(rq), &rq->hrtick_csd, 0); : 
str : 		rq->hrtick_csd_pending = 1;
strstr : INIT : 		rq->hrtick_csd_pending = 1; : 
strstr : if : 		rq->hrtick_csd_pending = 1; : 
strstr : for : 		rq->hrtick_csd_pending = 1; : 
strstr : while : 		rq->hrtick_csd_pending = 1; : 
str : 	}
strstr : INIT : 	} : 
strstr : if : 	} : 
strstr : for : 	} : 
strstr : while : 	} : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : static int
strstr : if : static int : 
strstr : for : static int : 
strstr : while : static int : 
str : hotplug_hrtick(struct notifier_block *nfb, unsigned long action, void *hcpu)
strstr : INIT : hotplug_hrtick(struct notifier_block *nfb, unsigned long action, void *hcpu) : 
strstr : if : hotplug_hrtick(struct notifier_block *nfb, unsigned long action, void *hcpu) : 
strstr : for : hotplug_hrtick(struct notifier_block *nfb, unsigned long action, void *hcpu) : 
strstr : while : hotplug_hrtick(struct notifier_block *nfb, unsigned long action, void *hcpu) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	int cpu = (int)(long)hcpu;
strstr : INIT : 	int cpu = (int)(long)hcpu; : 
strstr : if : 	int cpu = (int)(long)hcpu; : 
strstr : for : 	int cpu = (int)(long)hcpu; : 
strstr : while : 	int cpu = (int)(long)hcpu; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	switch (action) {
strstr : if : 	switch (action) { : 
strstr : for : 	switch (action) { : 
strstr : while : 	switch (action) { : 
str : 	case CPU_UP_CANCELED:
strstr : INIT : 	case CPU_UP_CANCELED: : 
strstr : if : 	case CPU_UP_CANCELED: : 
strstr : for : 	case CPU_UP_CANCELED: : 
strstr : while : 	case CPU_UP_CANCELED: : 
str : 	case CPU_UP_CANCELED_FROZEN:
strstr : INIT : 	case CPU_UP_CANCELED_FROZEN: : 
strstr : if : 	case CPU_UP_CANCELED_FROZEN: : 
strstr : for : 	case CPU_UP_CANCELED_FROZEN: : 
strstr : while : 	case CPU_UP_CANCELED_FROZEN: : 
str : 	case CPU_DOWN_PREPARE:
strstr : INIT : 	case CPU_DOWN_PREPARE: : 
strstr : if : 	case CPU_DOWN_PREPARE: : 
strstr : for : 	case CPU_DOWN_PREPARE: : 
strstr : while : 	case CPU_DOWN_PREPARE: : 
str : 	case CPU_DOWN_PREPARE_FROZEN:
strstr : INIT : 	case CPU_DOWN_PREPARE_FROZEN: : 
strstr : if : 	case CPU_DOWN_PREPARE_FROZEN: : 
strstr : for : 	case CPU_DOWN_PREPARE_FROZEN: : 
strstr : while : 	case CPU_DOWN_PREPARE_FROZEN: : 
str : 	case CPU_DEAD:
strstr : INIT : 	case CPU_DEAD: : 
strstr : if : 	case CPU_DEAD: : 
strstr : for : 	case CPU_DEAD: : 
strstr : while : 	case CPU_DEAD: : 
str : 	case CPU_DEAD_FROZEN:
strstr : INIT : 	case CPU_DEAD_FROZEN: : 
strstr : if : 	case CPU_DEAD_FROZEN: : 
strstr : for : 	case CPU_DEAD_FROZEN: : 
strstr : while : 	case CPU_DEAD_FROZEN: : 
str : 		hrtick_clear(cpu_rq(cpu));
strstr : INIT : 		hrtick_clear(cpu_rq(cpu)); : 
strstr : if : 		hrtick_clear(cpu_rq(cpu)); : 
strstr : for : 		hrtick_clear(cpu_rq(cpu)); : 
strstr : while : 		hrtick_clear(cpu_rq(cpu)); : 
str : 		return NOTIFY_OK;
strstr : INIT : 		return NOTIFY_OK; : 
strstr : if : 		return NOTIFY_OK; : 
strstr : for : 		return NOTIFY_OK; : 
strstr : while : 		return NOTIFY_OK; : 
str : 	}
strstr : INIT : 	} : 
strstr : if : 	} : 
strstr : for : 	} : 
strstr : while : 	} : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	return NOTIFY_DONE;
strstr : if : 	return NOTIFY_DONE; : 
strstr : for : 	return NOTIFY_DONE; : 
strstr : while : 	return NOTIFY_DONE; : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : static __init void init_hrtick(void)
strstr : if : static __init void init_hrtick(void) : 
strstr : for : static __init void init_hrtick(void) : 
strstr : while : static __init void init_hrtick(void) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	hotcpu_notifier(hotplug_hrtick, 0);
strstr : INIT : 	hotcpu_notifier(hotplug_hrtick, 0); : 
strstr : if : 	hotcpu_notifier(hotplug_hrtick, 0); : 
strstr : for : 	hotcpu_notifier(hotplug_hrtick, 0); : 
strstr : while : 	hotcpu_notifier(hotplug_hrtick, 0); : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : #else
strstr : INIT : #else : 
strstr : if : #else : 
strstr : for : #else : 
strstr : while : #else : 
str : /*
strstr : INIT : /* : 
strstr : if : /* : 
strstr : for : /* : 
strstr : while : /* : 
str :  * Called to set the hrtick timer state.
strstr : INIT :  * Called to set the hrtick timer state. : 
strstr : if :  * Called to set the hrtick timer state. : 
strstr : for :  * Called to set the hrtick timer state. : 
strstr : while :  * Called to set the hrtick timer state. : 
str :  *
strstr : INIT :  * : 
strstr : if :  * : 
strstr : for :  * : 
strstr : while :  * : 
str :  * called with rq->lock held and irqs disabled
strstr : INIT :  * called with rq->lock held and irqs disabled : 
strstr : if :  * called with rq->lock held and irqs disabled : 
strstr : for :  * called with rq->lock held and irqs disabled : 
strstr : while :  * called with rq->lock held and irqs disabled : 
str :  */
strstr : INIT :  */ : 
strstr : if :  */ : 
strstr : for :  */ : 
strstr : while :  */ : 
str : void hrtick_start(struct rq *rq, u64 delay)
strstr : INIT : void hrtick_start(struct rq *rq, u64 delay) : 
strstr : if : void hrtick_start(struct rq *rq, u64 delay) : 
strstr : for : void hrtick_start(struct rq *rq, u64 delay) : 
strstr : while : void hrtick_start(struct rq *rq, u64 delay) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	__hrtimer_start_range_ns(&rq->hrtick_timer, ns_to_ktime(delay), 0,
strstr : INIT : 	__hrtimer_start_range_ns(&rq->hrtick_timer, ns_to_ktime(delay), 0, : 
strstr : if : 	__hrtimer_start_range_ns(&rq->hrtick_timer, ns_to_ktime(delay), 0, : 
strstr : for : 	__hrtimer_start_range_ns(&rq->hrtick_timer, ns_to_ktime(delay), 0, : 
strstr : while : 	__hrtimer_start_range_ns(&rq->hrtick_timer, ns_to_ktime(delay), 0, : 
str : 			HRTIMER_MODE_REL_PINNED, 0);
strstr : INIT : 			HRTIMER_MODE_REL_PINNED, 0); : 
strstr : if : 			HRTIMER_MODE_REL_PINNED, 0); : 
strstr : for : 			HRTIMER_MODE_REL_PINNED, 0); : 
strstr : while : 			HRTIMER_MODE_REL_PINNED, 0); : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : static inline void init_hrtick(void)
strstr : if : static inline void init_hrtick(void) : 
strstr : for : static inline void init_hrtick(void) : 
strstr : while : static inline void init_hrtick(void) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : #endif /* CONFIG_SMP */
strstr : INIT : #endif /* CONFIG_SMP */ : 
strstr : if : #endif /* CONFIG_SMP */ : 
strstr : for : #endif /* CONFIG_SMP */ : 
strstr : while : #endif /* CONFIG_SMP */ : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : static void init_rq_hrtick(struct rq *rq)
strstr : if : static void init_rq_hrtick(struct rq *rq) : 
strstr : for : static void init_rq_hrtick(struct rq *rq) : 
strstr : while : static void init_rq_hrtick(struct rq *rq) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : #ifdef CONFIG_SMP
strstr : INIT : #ifdef CONFIG_SMP : 
strstr : if : #ifdef CONFIG_SMP : 
strstr : for : #ifdef CONFIG_SMP : 
strstr : while : #ifdef CONFIG_SMP : 
str : 	rq->hrtick_csd_pending = 0;
strstr : INIT : 	rq->hrtick_csd_pending = 0; : 
strstr : if : 	rq->hrtick_csd_pending = 0; : 
strstr : for : 	rq->hrtick_csd_pending = 0; : 
strstr : while : 	rq->hrtick_csd_pending = 0; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	rq->hrtick_csd.flags = 0;
strstr : if : 	rq->hrtick_csd.flags = 0; : 
strstr : for : 	rq->hrtick_csd.flags = 0; : 
strstr : while : 	rq->hrtick_csd.flags = 0; : 
str : 	rq->hrtick_csd.func = __hrtick_start;
strstr : INIT : 	rq->hrtick_csd.func = __hrtick_start; : 
strstr : if : 	rq->hrtick_csd.func = __hrtick_start; : 
strstr : for : 	rq->hrtick_csd.func = __hrtick_start; : 
strstr : while : 	rq->hrtick_csd.func = __hrtick_start; : 
str : 	rq->hrtick_csd.info = rq;
strstr : INIT : 	rq->hrtick_csd.info = rq; : 
strstr : if : 	rq->hrtick_csd.info = rq; : 
strstr : for : 	rq->hrtick_csd.info = rq; : 
strstr : while : 	rq->hrtick_csd.info = rq; : 
str : #endif
strstr : INIT : #endif : 
strstr : if : #endif : 
strstr : for : #endif : 
strstr : while : #endif : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	hrtimer_init(&rq->hrtick_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
strstr : if : 	hrtimer_init(&rq->hrtick_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL); : 
strstr : for : 	hrtimer_init(&rq->hrtick_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL); : 
strstr : while : 	hrtimer_init(&rq->hrtick_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL); : 
str : 	rq->hrtick_timer.function = hrtick;
strstr : INIT : 	rq->hrtick_timer.function = hrtick; : 
strstr : if : 	rq->hrtick_timer.function = hrtick; : 
strstr : for : 	rq->hrtick_timer.function = hrtick; : 
strstr : while : 	rq->hrtick_timer.function = hrtick; : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : #else	/* CONFIG_SCHED_HRTICK */
strstr : INIT : #else	/* CONFIG_SCHED_HRTICK */ : 
strstr : if : #else	/* CONFIG_SCHED_HRTICK */ : 
strstr : for : #else	/* CONFIG_SCHED_HRTICK */ : 
strstr : while : #else	/* CONFIG_SCHED_HRTICK */ : 
str : static inline void hrtick_clear(struct rq *rq)
strstr : INIT : static inline void hrtick_clear(struct rq *rq) : 
strstr : if : static inline void hrtick_clear(struct rq *rq) : 
strstr : for : static inline void hrtick_clear(struct rq *rq) : 
strstr : while : static inline void hrtick_clear(struct rq *rq) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : static inline void init_rq_hrtick(struct rq *rq)
strstr : if : static inline void init_rq_hrtick(struct rq *rq) : 
strstr : for : static inline void init_rq_hrtick(struct rq *rq) : 
strstr : while : static inline void init_rq_hrtick(struct rq *rq) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : static inline void init_hrtick(void)
strstr : if : static inline void init_hrtick(void) : 
strstr : for : static inline void init_hrtick(void) : 
strstr : while : static inline void init_hrtick(void) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : #endif	/* CONFIG_SCHED_HRTICK */
strstr : INIT : #endif	/* CONFIG_SCHED_HRTICK */ : 
strstr : if : #endif	/* CONFIG_SCHED_HRTICK */ : 
strstr : for : #endif	/* CONFIG_SCHED_HRTICK */ : 
strstr : while : #endif	/* CONFIG_SCHED_HRTICK */ : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : /*
strstr : if : /* : 
strstr : for : /* : 
strstr : while : /* : 
str :  * resched_task - mark a task 'to be rescheduled now'.
strstr : INIT :  * resched_task - mark a task 'to be rescheduled now'. : 
strstr : if :  * resched_task - mark a task 'to be rescheduled now'. : 
strstr : for :  * resched_task - mark a task 'to be rescheduled now'. : 
strstr : while :  * resched_task - mark a task 'to be rescheduled now'. : 
str :  *
strstr : INIT :  * : 
strstr : if :  * : 
strstr : for :  * : 
strstr : while :  * : 
str :  * On UP this means the setting of the need_resched flag, on SMP it
strstr : INIT :  * On UP this means the setting of the need_resched flag, on SMP it : 
strstr : if :  * On UP this means the setting of the need_resched flag, on SMP it : 
strstr : for :  * On UP this means the setting of the need_resched flag, on SMP it : 
strstr : while :  * On UP this means the setting of the need_resched flag, on SMP it : 
str :  * might also involve a cross-CPU call to trigger the scheduler on
strstr : INIT :  * might also involve a cross-CPU call to trigger the scheduler on : 
strstr : if :  * might also involve a cross-CPU call to trigger the scheduler on : 
strstr : for :  * might also involve a cross-CPU call to trigger the scheduler on : 
strstr : while :  * might also involve a cross-CPU call to trigger the scheduler on : 
str :  * the target CPU.
strstr : INIT :  * the target CPU. : 
strstr : if :  * the target CPU. : 
strstr : for :  * the target CPU. : 
strstr : while :  * the target CPU. : 
str :  */
strstr : INIT :  */ : 
strstr : if :  */ : 
strstr : for :  */ : 
strstr : while :  */ : 
str : void resched_task(struct task_struct *p)
strstr : INIT : void resched_task(struct task_struct *p) : 
strstr : if : void resched_task(struct task_struct *p) : 
strstr : for : void resched_task(struct task_struct *p) : 
strstr : while : void resched_task(struct task_struct *p) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	int cpu;
strstr : INIT : 	int cpu; : 
strstr : if : 	int cpu; : 
strstr : for : 	int cpu; : 
strstr : while : 	int cpu; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	lockdep_assert_held(&task_rq(p)->lock);
strstr : if : 	lockdep_assert_held(&task_rq(p)->lock); : 
strstr : for : 	lockdep_assert_held(&task_rq(p)->lock); : 
strstr : while : 	lockdep_assert_held(&task_rq(p)->lock); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	if (test_tsk_need_resched(p))
strstr : if : 	if (test_tsk_need_resched(p)) : 
strstr : for : 	if (test_tsk_need_resched(p)) : 
strstr : while : 	if (test_tsk_need_resched(p)) : 
str : 		return;
strstr : INIT : 		return; : 
strstr : if : 		return; : 
strstr : for : 		return; : 
strstr : while : 		return; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	set_tsk_need_resched(p);
strstr : if : 	set_tsk_need_resched(p); : 
strstr : for : 	set_tsk_need_resched(p); : 
strstr : while : 	set_tsk_need_resched(p); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	cpu = task_cpu(p);
strstr : if : 	cpu = task_cpu(p); : 
strstr : for : 	cpu = task_cpu(p); : 
strstr : while : 	cpu = task_cpu(p); : 
str : 	if (cpu == smp_processor_id()) {
strstr : INIT : 	if (cpu == smp_processor_id()) { : 
strstr : if : 	if (cpu == smp_processor_id()) { : 
strstr : for : 	if (cpu == smp_processor_id()) { : 
strstr : while : 	if (cpu == smp_processor_id()) { : 
str : 		set_preempt_need_resched();
strstr : INIT : 		set_preempt_need_resched(); : 
strstr : if : 		set_preempt_need_resched(); : 
strstr : for : 		set_preempt_need_resched(); : 
strstr : while : 		set_preempt_need_resched(); : 
str : 		return;
strstr : INIT : 		return; : 
strstr : if : 		return; : 
strstr : for : 		return; : 
strstr : while : 		return; : 
str : 	}
strstr : INIT : 	} : 
strstr : if : 	} : 
strstr : for : 	} : 
strstr : while : 	} : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	/* NEED_RESCHED must be visible before we test polling */
strstr : if : 	/* NEED_RESCHED must be visible before we test polling */ : 
strstr : for : 	/* NEED_RESCHED must be visible before we test polling */ : 
strstr : while : 	/* NEED_RESCHED must be visible before we test polling */ : 
str : 	smp_mb();
strstr : INIT : 	smp_mb(); : 
strstr : if : 	smp_mb(); : 
strstr : for : 	smp_mb(); : 
strstr : while : 	smp_mb(); : 
str : 	if (!tsk_is_polling(p))
strstr : INIT : 	if (!tsk_is_polling(p)) : 
strstr : if : 	if (!tsk_is_polling(p)) : 
strstr : for : 	if (!tsk_is_polling(p)) : 
strstr : while : 	if (!tsk_is_polling(p)) : 
str : 		smp_send_reschedule(cpu);
strstr : INIT : 		smp_send_reschedule(cpu); : 
strstr : if : 		smp_send_reschedule(cpu); : 
strstr : for : 		smp_send_reschedule(cpu); : 
strstr : while : 		smp_send_reschedule(cpu); : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : void resched_cpu(int cpu)
strstr : if : void resched_cpu(int cpu) : 
strstr : for : void resched_cpu(int cpu) : 
strstr : while : void resched_cpu(int cpu) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	struct rq *rq = cpu_rq(cpu);
strstr : INIT : 	struct rq *rq = cpu_rq(cpu); : 
strstr : if : 	struct rq *rq = cpu_rq(cpu); : 
strstr : for : 	struct rq *rq = cpu_rq(cpu); : 
strstr : while : 	struct rq *rq = cpu_rq(cpu); : 
str : 	unsigned long flags;
strstr : INIT : 	unsigned long flags; : 
strstr : if : 	unsigned long flags; : 
strstr : for : 	unsigned long flags; : 
strstr : while : 	unsigned long flags; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	if (!raw_spin_trylock_irqsave(&rq->lock, flags))
strstr : if : 	if (!raw_spin_trylock_irqsave(&rq->lock, flags)) : 
strstr : for : 	if (!raw_spin_trylock_irqsave(&rq->lock, flags)) : 
strstr : while : 	if (!raw_spin_trylock_irqsave(&rq->lock, flags)) : 
str : 		return;
strstr : INIT : 		return; : 
strstr : if : 		return; : 
strstr : for : 		return; : 
strstr : while : 		return; : 
str : 	resched_task(cpu_curr(cpu));
strstr : INIT : 	resched_task(cpu_curr(cpu)); : 
strstr : if : 	resched_task(cpu_curr(cpu)); : 
strstr : for : 	resched_task(cpu_curr(cpu)); : 
strstr : while : 	resched_task(cpu_curr(cpu)); : 
str : 	raw_spin_unlock_irqrestore(&rq->lock, flags);
strstr : INIT : 	raw_spin_unlock_irqrestore(&rq->lock, flags); : 
strstr : if : 	raw_spin_unlock_irqrestore(&rq->lock, flags); : 
strstr : for : 	raw_spin_unlock_irqrestore(&rq->lock, flags); : 
strstr : while : 	raw_spin_unlock_irqrestore(&rq->lock, flags); : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : #ifdef CONFIG_SMP
strstr : if : #ifdef CONFIG_SMP : 
strstr : for : #ifdef CONFIG_SMP : 
strstr : while : #ifdef CONFIG_SMP : 
str : #ifdef CONFIG_NO_HZ_COMMON
strstr : INIT : #ifdef CONFIG_NO_HZ_COMMON : 
strstr : if : #ifdef CONFIG_NO_HZ_COMMON : 
strstr : for : #ifdef CONFIG_NO_HZ_COMMON : 
strstr : while : #ifdef CONFIG_NO_HZ_COMMON : 
str : /*
strstr : INIT : /* : 
strstr : if : /* : 
strstr : for : /* : 
strstr : while : /* : 
str :  * In the semi idle case, use the nearest busy cpu for migrating timers
strstr : INIT :  * In the semi idle case, use the nearest busy cpu for migrating timers : 
strstr : if :  * In the semi idle case, use the nearest busy cpu for migrating timers : 
strstr : for :  * In the semi idle case, use the nearest busy cpu for migrating timers : 
strstr : while :  * In the semi idle case, use the nearest busy cpu for migrating timers : 
str :  * from an idle cpu.  This is good for power-savings.
strstr : INIT :  * from an idle cpu.  This is good for power-savings. : 
strstr : if :  * from an idle cpu.  This is good for power-savings. : 
strstr : for :  * from an idle cpu.  This is good for power-savings. : 
strstr : while :  * from an idle cpu.  This is good for power-savings. : 
str :  *
strstr : INIT :  * : 
strstr : if :  * : 
strstr : for :  * : 
strstr : while :  * : 
str :  * We don't do similar optimization for completely idle system, as
strstr : INIT :  * We don't do similar optimization for completely idle system, as : 
strstr : if :  * We don't do similar optimization for completely idle system, as : 
strstr : for :  * We don't do similar optimization for completely idle system, as : 
strstr : while :  * We don't do similar optimization for completely idle system, as : 
str :  * selecting an idle cpu will add more delays to the timers than intended
strstr : INIT :  * selecting an idle cpu will add more delays to the timers than intended : 
strstr : if :  * selecting an idle cpu will add more delays to the timers than intended : 
strstr : for :  * selecting an idle cpu will add more delays to the timers than intended : 
strstr : while :  * selecting an idle cpu will add more delays to the timers than intended : 
str :  * (as that cpu's timer base may not be uptodate wrt jiffies etc).
strstr : INIT :  * (as that cpu's timer base may not be uptodate wrt jiffies etc). : 
strstr : if :  * (as that cpu's timer base may not be uptodate wrt jiffies etc). : 
strstr : for :  * (as that cpu's timer base may not be uptodate wrt jiffies etc). : 
strstr : while :  * (as that cpu's timer base may not be uptodate wrt jiffies etc). : 
str :  */
strstr : INIT :  */ : 
strstr : if :  */ : 
strstr : for :  */ : 
strstr : while :  */ : 
str : int get_nohz_timer_target(void)
strstr : INIT : int get_nohz_timer_target(void) : 
strstr : if : int get_nohz_timer_target(void) : 
strstr : for : int get_nohz_timer_target(void) : 
strstr : while : int get_nohz_timer_target(void) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	int cpu = smp_processor_id();
strstr : INIT : 	int cpu = smp_processor_id(); : 
strstr : if : 	int cpu = smp_processor_id(); : 
strstr : for : 	int cpu = smp_processor_id(); : 
strstr : while : 	int cpu = smp_processor_id(); : 
str : 	int i;
strstr : INIT : 	int i; : 
strstr : if : 	int i; : 
strstr : for : 	int i; : 
strstr : while : 	int i; : 
str : 	struct sched_domain *sd;
strstr : INIT : 	struct sched_domain *sd; : 
strstr : if : 	struct sched_domain *sd; : 
strstr : for : 	struct sched_domain *sd; : 
strstr : while : 	struct sched_domain *sd; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	rcu_read_lock();
strstr : if : 	rcu_read_lock(); : 
strstr : for : 	rcu_read_lock(); : 
strstr : while : 	rcu_read_lock(); : 
str : 	for_each_domain(cpu, sd) {
strstr : INIT : 	for_each_domain(cpu, sd) { : 
strstr : if : 	for_each_domain(cpu, sd) { : 
strstr : for : 	for_each_domain(cpu, sd) { : 
strstr : while : 	for_each_domain(cpu, sd) { : 
str : 		for_each_cpu(i, sched_domain_span(sd)) {
strstr : INIT : 		for_each_cpu(i, sched_domain_span(sd)) { : 
strstr : if : 		for_each_cpu(i, sched_domain_span(sd)) { : 
strstr : for : 		for_each_cpu(i, sched_domain_span(sd)) { : 
strstr : while : 		for_each_cpu(i, sched_domain_span(sd)) { : 
str : 			if (!idle_cpu(i)) {
strstr : INIT : 			if (!idle_cpu(i)) { : 
strstr : if : 			if (!idle_cpu(i)) { : 
strstr : for : 			if (!idle_cpu(i)) { : 
strstr : while : 			if (!idle_cpu(i)) { : 
str : 				cpu = i;
strstr : INIT : 				cpu = i; : 
strstr : if : 				cpu = i; : 
strstr : for : 				cpu = i; : 
strstr : while : 				cpu = i; : 
str : 				goto unlock;
strstr : INIT : 				goto unlock; : 
strstr : if : 				goto unlock; : 
strstr : for : 				goto unlock; : 
strstr : while : 				goto unlock; : 
str : 			}
strstr : INIT : 			} : 
strstr : if : 			} : 
strstr : for : 			} : 
strstr : while : 			} : 
str : 		}
strstr : INIT : 		} : 
strstr : if : 		} : 
strstr : for : 		} : 
strstr : while : 		} : 
str : 	}
strstr : INIT : 	} : 
strstr : if : 	} : 
strstr : for : 	} : 
strstr : while : 	} : 
str : unlock:
strstr : INIT : unlock: : 
strstr : if : unlock: : 
strstr : for : unlock: : 
strstr : while : unlock: : 
str : 	rcu_read_unlock();
strstr : INIT : 	rcu_read_unlock(); : 
strstr : if : 	rcu_read_unlock(); : 
strstr : for : 	rcu_read_unlock(); : 
strstr : while : 	rcu_read_unlock(); : 
str : 	return cpu;
strstr : INIT : 	return cpu; : 
strstr : if : 	return cpu; : 
strstr : for : 	return cpu; : 
strstr : while : 	return cpu; : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : /*
strstr : INIT : /* : 
strstr : if : /* : 
strstr : for : /* : 
strstr : while : /* : 
str :  * When add_timer_on() enqueues a timer into the timer wheel of an
strstr : INIT :  * When add_timer_on() enqueues a timer into the timer wheel of an : 
strstr : if :  * When add_timer_on() enqueues a timer into the timer wheel of an : 
strstr : for :  * When add_timer_on() enqueues a timer into the timer wheel of an : 
strstr : while :  * When add_timer_on() enqueues a timer into the timer wheel of an : 
str :  * idle CPU then this timer might expire before the next timer event
strstr : INIT :  * idle CPU then this timer might expire before the next timer event : 
strstr : if :  * idle CPU then this timer might expire before the next timer event : 
strstr : for :  * idle CPU then this timer might expire before the next timer event : 
strstr : while :  * idle CPU then this timer might expire before the next timer event : 
str :  * which is scheduled to wake up that CPU. In case of a completely
strstr : INIT :  * which is scheduled to wake up that CPU. In case of a completely : 
strstr : if :  * which is scheduled to wake up that CPU. In case of a completely : 
strstr : for :  * which is scheduled to wake up that CPU. In case of a completely : 
strstr : while :  * which is scheduled to wake up that CPU. In case of a completely : 
str :  * idle system the next event might even be infinite time into the
strstr : INIT :  * idle system the next event might even be infinite time into the : 
strstr : if :  * idle system the next event might even be infinite time into the : 
strstr : for :  * idle system the next event might even be infinite time into the : 
strstr : while :  * idle system the next event might even be infinite time into the : 
str :  * future. wake_up_idle_cpu() ensures that the CPU is woken up and
strstr : INIT :  * future. wake_up_idle_cpu() ensures that the CPU is woken up and : 
strstr : if :  * future. wake_up_idle_cpu() ensures that the CPU is woken up and : 
strstr : for :  * future. wake_up_idle_cpu() ensures that the CPU is woken up and : 
strstr : while :  * future. wake_up_idle_cpu() ensures that the CPU is woken up and : 
str :  * leaves the inner idle loop so the newly added timer is taken into
strstr : INIT :  * leaves the inner idle loop so the newly added timer is taken into : 
strstr : if :  * leaves the inner idle loop so the newly added timer is taken into : 
strstr : for :  * leaves the inner idle loop so the newly added timer is taken into : 
strstr : while :  * leaves the inner idle loop so the newly added timer is taken into : 
str :  * account when the CPU goes back to idle and evaluates the timer
strstr : INIT :  * account when the CPU goes back to idle and evaluates the timer : 
strstr : if :  * account when the CPU goes back to idle and evaluates the timer : 
strstr : for :  * account when the CPU goes back to idle and evaluates the timer : 
strstr : while :  * account when the CPU goes back to idle and evaluates the timer : 
str :  * wheel for the next timer event.
strstr : INIT :  * wheel for the next timer event. : 
strstr : if :  * wheel for the next timer event. : 
strstr : for :  * wheel for the next timer event. : 
strstr : while :  * wheel for the next timer event. : 
str :  */
strstr : INIT :  */ : 
strstr : if :  */ : 
strstr : for :  */ : 
strstr : while :  */ : 
str : static void wake_up_idle_cpu(int cpu)
strstr : INIT : static void wake_up_idle_cpu(int cpu) : 
strstr : if : static void wake_up_idle_cpu(int cpu) : 
strstr : for : static void wake_up_idle_cpu(int cpu) : 
strstr : while : static void wake_up_idle_cpu(int cpu) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	struct rq *rq = cpu_rq(cpu);
strstr : INIT : 	struct rq *rq = cpu_rq(cpu); : 
strstr : if : 	struct rq *rq = cpu_rq(cpu); : 
strstr : for : 	struct rq *rq = cpu_rq(cpu); : 
strstr : while : 	struct rq *rq = cpu_rq(cpu); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	if (cpu == smp_processor_id())
strstr : if : 	if (cpu == smp_processor_id()) : 
strstr : for : 	if (cpu == smp_processor_id()) : 
strstr : while : 	if (cpu == smp_processor_id()) : 
str : 		return;
strstr : INIT : 		return; : 
strstr : if : 		return; : 
strstr : for : 		return; : 
strstr : while : 		return; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	/*
strstr : if : 	/* : 
strstr : for : 	/* : 
strstr : while : 	/* : 
str : 	 * This is safe, as this function is called with the timer
strstr : INIT : 	 * This is safe, as this function is called with the timer : 
strstr : if : 	 * This is safe, as this function is called with the timer : 
strstr : for : 	 * This is safe, as this function is called with the timer : 
strstr : while : 	 * This is safe, as this function is called with the timer : 
str : 	 * wheel base lock of (cpu) held. When the CPU is on the way
strstr : INIT : 	 * wheel base lock of (cpu) held. When the CPU is on the way : 
strstr : if : 	 * wheel base lock of (cpu) held. When the CPU is on the way : 
strstr : for : 	 * wheel base lock of (cpu) held. When the CPU is on the way : 
strstr : while : 	 * wheel base lock of (cpu) held. When the CPU is on the way : 
str : 	 * to idle and has not yet set rq->curr to idle then it will
strstr : INIT : 	 * to idle and has not yet set rq->curr to idle then it will : 
strstr : if : 	 * to idle and has not yet set rq->curr to idle then it will : 
strstr : for : 	 * to idle and has not yet set rq->curr to idle then it will : 
strstr : while : 	 * to idle and has not yet set rq->curr to idle then it will : 
str : 	 * be serialized on the timer wheel base lock and take the new
strstr : INIT : 	 * be serialized on the timer wheel base lock and take the new : 
strstr : if : 	 * be serialized on the timer wheel base lock and take the new : 
strstr : for : 	 * be serialized on the timer wheel base lock and take the new : 
strstr : while : 	 * be serialized on the timer wheel base lock and take the new : 
str : 	 * timer into account automatically.
strstr : INIT : 	 * timer into account automatically. : 
strstr : if : 	 * timer into account automatically. : 
strstr : for : 	 * timer into account automatically. : 
strstr : while : 	 * timer into account automatically. : 
str : 	 */
strstr : INIT : 	 */ : 
strstr : if : 	 */ : 
strstr : for : 	 */ : 
strstr : while : 	 */ : 
str : 	if (rq->curr != rq->idle)
strstr : INIT : 	if (rq->curr != rq->idle) : 
strstr : if : 	if (rq->curr != rq->idle) : 
strstr : for : 	if (rq->curr != rq->idle) : 
strstr : while : 	if (rq->curr != rq->idle) : 
str : 		return;
strstr : INIT : 		return; : 
strstr : if : 		return; : 
strstr : for : 		return; : 
strstr : while : 		return; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	/*
strstr : if : 	/* : 
strstr : for : 	/* : 
strstr : while : 	/* : 
str : 	 * We can set TIF_RESCHED on the idle task of the other CPU
strstr : INIT : 	 * We can set TIF_RESCHED on the idle task of the other CPU : 
strstr : if : 	 * We can set TIF_RESCHED on the idle task of the other CPU : 
strstr : for : 	 * We can set TIF_RESCHED on the idle task of the other CPU : 
strstr : while : 	 * We can set TIF_RESCHED on the idle task of the other CPU : 
str : 	 * lockless. The worst case is that the other CPU runs the
strstr : INIT : 	 * lockless. The worst case is that the other CPU runs the : 
strstr : if : 	 * lockless. The worst case is that the other CPU runs the : 
strstr : for : 	 * lockless. The worst case is that the other CPU runs the : 
strstr : while : 	 * lockless. The worst case is that the other CPU runs the : 
str : 	 * idle task through an additional NOOP schedule()
strstr : INIT : 	 * idle task through an additional NOOP schedule() : 
strstr : if : 	 * idle task through an additional NOOP schedule() : 
strstr : for : 	 * idle task through an additional NOOP schedule() : 
strstr : while : 	 * idle task through an additional NOOP schedule() : 
str : 	 */
strstr : INIT : 	 */ : 
strstr : if : 	 */ : 
strstr : for : 	 */ : 
strstr : while : 	 */ : 
str : 	set_tsk_need_resched(rq->idle);
strstr : INIT : 	set_tsk_need_resched(rq->idle); : 
strstr : if : 	set_tsk_need_resched(rq->idle); : 
strstr : for : 	set_tsk_need_resched(rq->idle); : 
strstr : while : 	set_tsk_need_resched(rq->idle); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	/* NEED_RESCHED must be visible before we test polling */
strstr : if : 	/* NEED_RESCHED must be visible before we test polling */ : 
strstr : for : 	/* NEED_RESCHED must be visible before we test polling */ : 
strstr : while : 	/* NEED_RESCHED must be visible before we test polling */ : 
str : 	smp_mb();
strstr : INIT : 	smp_mb(); : 
strstr : if : 	smp_mb(); : 
strstr : for : 	smp_mb(); : 
strstr : while : 	smp_mb(); : 
str : 	if (!tsk_is_polling(rq->idle))
strstr : INIT : 	if (!tsk_is_polling(rq->idle)) : 
strstr : if : 	if (!tsk_is_polling(rq->idle)) : 
strstr : for : 	if (!tsk_is_polling(rq->idle)) : 
strstr : while : 	if (!tsk_is_polling(rq->idle)) : 
str : 		smp_send_reschedule(cpu);
strstr : INIT : 		smp_send_reschedule(cpu); : 
strstr : if : 		smp_send_reschedule(cpu); : 
strstr : for : 		smp_send_reschedule(cpu); : 
strstr : while : 		smp_send_reschedule(cpu); : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : static bool wake_up_full_nohz_cpu(int cpu)
strstr : if : static bool wake_up_full_nohz_cpu(int cpu) : 
strstr : for : static bool wake_up_full_nohz_cpu(int cpu) : 
strstr : while : static bool wake_up_full_nohz_cpu(int cpu) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	if (tick_nohz_full_cpu(cpu)) {
strstr : INIT : 	if (tick_nohz_full_cpu(cpu)) { : 
strstr : if : 	if (tick_nohz_full_cpu(cpu)) { : 
strstr : for : 	if (tick_nohz_full_cpu(cpu)) { : 
strstr : while : 	if (tick_nohz_full_cpu(cpu)) { : 
str : 		if (cpu != smp_processor_id() ||
strstr : INIT : 		if (cpu != smp_processor_id() || : 
strstr : if : 		if (cpu != smp_processor_id() || : 
strstr : for : 		if (cpu != smp_processor_id() || : 
strstr : while : 		if (cpu != smp_processor_id() || : 
str : 		    tick_nohz_tick_stopped())
strstr : INIT : 		    tick_nohz_tick_stopped()) : 
strstr : if : 		    tick_nohz_tick_stopped()) : 
strstr : for : 		    tick_nohz_tick_stopped()) : 
strstr : while : 		    tick_nohz_tick_stopped()) : 
str : 			smp_send_reschedule(cpu);
strstr : INIT : 			smp_send_reschedule(cpu); : 
strstr : if : 			smp_send_reschedule(cpu); : 
strstr : for : 			smp_send_reschedule(cpu); : 
strstr : while : 			smp_send_reschedule(cpu); : 
str : 		return true;
strstr : INIT : 		return true; : 
strstr : if : 		return true; : 
strstr : for : 		return true; : 
strstr : while : 		return true; : 
str : 	}
strstr : INIT : 	} : 
strstr : if : 	} : 
strstr : for : 	} : 
strstr : while : 	} : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	return false;
strstr : if : 	return false; : 
strstr : for : 	return false; : 
strstr : while : 	return false; : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : void wake_up_nohz_cpu(int cpu)
strstr : if : void wake_up_nohz_cpu(int cpu) : 
strstr : for : void wake_up_nohz_cpu(int cpu) : 
strstr : while : void wake_up_nohz_cpu(int cpu) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	if (!wake_up_full_nohz_cpu(cpu))
strstr : INIT : 	if (!wake_up_full_nohz_cpu(cpu)) : 
strstr : if : 	if (!wake_up_full_nohz_cpu(cpu)) : 
strstr : for : 	if (!wake_up_full_nohz_cpu(cpu)) : 
strstr : while : 	if (!wake_up_full_nohz_cpu(cpu)) : 
str : 		wake_up_idle_cpu(cpu);
strstr : INIT : 		wake_up_idle_cpu(cpu); : 
strstr : if : 		wake_up_idle_cpu(cpu); : 
strstr : for : 		wake_up_idle_cpu(cpu); : 
strstr : while : 		wake_up_idle_cpu(cpu); : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : static inline bool got_nohz_idle_kick(void)
strstr : if : static inline bool got_nohz_idle_kick(void) : 
strstr : for : static inline bool got_nohz_idle_kick(void) : 
strstr : while : static inline bool got_nohz_idle_kick(void) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	int cpu = smp_processor_id();
strstr : INIT : 	int cpu = smp_processor_id(); : 
strstr : if : 	int cpu = smp_processor_id(); : 
strstr : for : 	int cpu = smp_processor_id(); : 
strstr : while : 	int cpu = smp_processor_id(); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	if (!test_bit(NOHZ_BALANCE_KICK, nohz_flags(cpu)))
strstr : if : 	if (!test_bit(NOHZ_BALANCE_KICK, nohz_flags(cpu))) : 
strstr : for : 	if (!test_bit(NOHZ_BALANCE_KICK, nohz_flags(cpu))) : 
strstr : while : 	if (!test_bit(NOHZ_BALANCE_KICK, nohz_flags(cpu))) : 
str : 		return false;
strstr : INIT : 		return false; : 
strstr : if : 		return false; : 
strstr : for : 		return false; : 
strstr : while : 		return false; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	if (idle_cpu(cpu) && !need_resched())
strstr : if : 	if (idle_cpu(cpu) && !need_resched()) : 
strstr : for : 	if (idle_cpu(cpu) && !need_resched()) : 
strstr : while : 	if (idle_cpu(cpu) && !need_resched()) : 
str : 		return true;
strstr : INIT : 		return true; : 
strstr : if : 		return true; : 
strstr : for : 		return true; : 
strstr : while : 		return true; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	/*
strstr : if : 	/* : 
strstr : for : 	/* : 
strstr : while : 	/* : 
str : 	 * We can't run Idle Load Balance on this CPU for this time so we
strstr : INIT : 	 * We can't run Idle Load Balance on this CPU for this time so we : 
strstr : if : 	 * We can't run Idle Load Balance on this CPU for this time so we : 
strstr : for : 	 * We can't run Idle Load Balance on this CPU for this time so we : 
strstr : while : 	 * We can't run Idle Load Balance on this CPU for this time so we : 
str : 	 * cancel it and clear NOHZ_BALANCE_KICK
strstr : INIT : 	 * cancel it and clear NOHZ_BALANCE_KICK : 
strstr : if : 	 * cancel it and clear NOHZ_BALANCE_KICK : 
strstr : for : 	 * cancel it and clear NOHZ_BALANCE_KICK : 
strstr : while : 	 * cancel it and clear NOHZ_BALANCE_KICK : 
str : 	 */
strstr : INIT : 	 */ : 
strstr : if : 	 */ : 
strstr : for : 	 */ : 
strstr : while : 	 */ : 
str : 	clear_bit(NOHZ_BALANCE_KICK, nohz_flags(cpu));
strstr : INIT : 	clear_bit(NOHZ_BALANCE_KICK, nohz_flags(cpu)); : 
strstr : if : 	clear_bit(NOHZ_BALANCE_KICK, nohz_flags(cpu)); : 
strstr : for : 	clear_bit(NOHZ_BALANCE_KICK, nohz_flags(cpu)); : 
strstr : while : 	clear_bit(NOHZ_BALANCE_KICK, nohz_flags(cpu)); : 
str : 	return false;
strstr : INIT : 	return false; : 
strstr : if : 	return false; : 
strstr : for : 	return false; : 
strstr : while : 	return false; : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : #else /* CONFIG_NO_HZ_COMMON */
strstr : if : #else /* CONFIG_NO_HZ_COMMON */ : 
strstr : for : #else /* CONFIG_NO_HZ_COMMON */ : 
strstr : while : #else /* CONFIG_NO_HZ_COMMON */ : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : static inline bool got_nohz_idle_kick(void)
strstr : if : static inline bool got_nohz_idle_kick(void) : 
strstr : for : static inline bool got_nohz_idle_kick(void) : 
strstr : while : static inline bool got_nohz_idle_kick(void) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	return false;
strstr : INIT : 	return false; : 
strstr : if : 	return false; : 
strstr : for : 	return false; : 
strstr : while : 	return false; : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : #endif /* CONFIG_NO_HZ_COMMON */
strstr : if : #endif /* CONFIG_NO_HZ_COMMON */ : 
strstr : for : #endif /* CONFIG_NO_HZ_COMMON */ : 
strstr : while : #endif /* CONFIG_NO_HZ_COMMON */ : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : #ifdef CONFIG_NO_HZ_FULL
strstr : if : #ifdef CONFIG_NO_HZ_FULL : 
strstr : for : #ifdef CONFIG_NO_HZ_FULL : 
strstr : while : #ifdef CONFIG_NO_HZ_FULL : 
str : bool sched_can_stop_tick(void)
strstr : INIT : bool sched_can_stop_tick(void) : 
strstr : if : bool sched_can_stop_tick(void) : 
strstr : for : bool sched_can_stop_tick(void) : 
strstr : while : bool sched_can_stop_tick(void) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str :        struct rq *rq;
strstr : INIT :        struct rq *rq; : 
strstr : if :        struct rq *rq; : 
strstr : for :        struct rq *rq; : 
strstr : while :        struct rq *rq; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str :        rq = this_rq();
strstr : if :        rq = this_rq(); : 
strstr : for :        rq = this_rq(); : 
strstr : while :        rq = this_rq(); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str :        /* Make sure rq->nr_running update is visible after the IPI */
strstr : if :        /* Make sure rq->nr_running update is visible after the IPI */ : 
strstr : for :        /* Make sure rq->nr_running update is visible after the IPI */ : 
strstr : while :        /* Make sure rq->nr_running update is visible after the IPI */ : 
str :        smp_rmb();
strstr : INIT :        smp_rmb(); : 
strstr : if :        smp_rmb(); : 
strstr : for :        smp_rmb(); : 
strstr : while :        smp_rmb(); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str :        /* More than one running task need preemption */
strstr : if :        /* More than one running task need preemption */ : 
strstr : for :        /* More than one running task need preemption */ : 
strstr : while :        /* More than one running task need preemption */ : 
str :        if (rq->nr_running > 1)
strstr : INIT :        if (rq->nr_running > 1) : 
strstr : if :        if (rq->nr_running > 1) : 
strstr : for :        if (rq->nr_running > 1) : 
strstr : while :        if (rq->nr_running > 1) : 
str :                return false;
strstr : INIT :                return false; : 
strstr : if :                return false; : 
strstr : for :                return false; : 
strstr : while :                return false; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str :        return true;
strstr : if :        return true; : 
strstr : for :        return true; : 
strstr : while :        return true; : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : #endif /* CONFIG_NO_HZ_FULL */
strstr : INIT : #endif /* CONFIG_NO_HZ_FULL */ : 
strstr : if : #endif /* CONFIG_NO_HZ_FULL */ : 
strstr : for : #endif /* CONFIG_NO_HZ_FULL */ : 
strstr : while : #endif /* CONFIG_NO_HZ_FULL */ : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : void sched_avg_update(struct rq *rq)
strstr : if : void sched_avg_update(struct rq *rq) : 
strstr : for : void sched_avg_update(struct rq *rq) : 
strstr : while : void sched_avg_update(struct rq *rq) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	s64 period = sched_avg_period();
strstr : INIT : 	s64 period = sched_avg_period(); : 
strstr : if : 	s64 period = sched_avg_period(); : 
strstr : for : 	s64 period = sched_avg_period(); : 
strstr : while : 	s64 period = sched_avg_period(); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	while ((s64)(rq_clock(rq) - rq->age_stamp) > period) {
strstr : if : 	while ((s64)(rq_clock(rq) - rq->age_stamp) > period) { : 
strstr : for : 	while ((s64)(rq_clock(rq) - rq->age_stamp) > period) { : 
strstr : while : 	while ((s64)(rq_clock(rq) - rq->age_stamp) > period) { : 
str : 		/*
strstr : INIT : 		/* : 
strstr : if : 		/* : 
strstr : for : 		/* : 
strstr : while : 		/* : 
str : 		 * Inline assembly required to prevent the compiler
strstr : INIT : 		 * Inline assembly required to prevent the compiler : 
strstr : if : 		 * Inline assembly required to prevent the compiler : 
strstr : for : 		 * Inline assembly required to prevent the compiler : 
strstr : while : 		 * Inline assembly required to prevent the compiler : 
str : 		 * optimising this loop into a divmod call.
strstr : INIT : 		 * optimising this loop into a divmod call. : 
strstr : if : 		 * optimising this loop into a divmod call. : 
strstr : for : 		 * optimising this loop into a divmod call. : 
strstr : while : 		 * optimising this loop into a divmod call. : 
str : 		 * See __iter_div_u64_rem() for another example of this.
strstr : INIT : 		 * See __iter_div_u64_rem() for another example of this. : 
strstr : if : 		 * See __iter_div_u64_rem() for another example of this. : 
strstr : for : 		 * See __iter_div_u64_rem() for another example of this. : 
strstr : while : 		 * See __iter_div_u64_rem() for another example of this. : 
str : 		 */
strstr : INIT : 		 */ : 
strstr : if : 		 */ : 
strstr : for : 		 */ : 
strstr : while : 		 */ : 
str : 		asm("" : "+rm" (rq->age_stamp));
strstr : INIT : 		asm("" : "+rm" (rq->age_stamp)); : 
strstr : if : 		asm("" : "+rm" (rq->age_stamp)); : 
strstr : for : 		asm("" : "+rm" (rq->age_stamp)); : 
strstr : while : 		asm("" : "+rm" (rq->age_stamp)); : 
str : 		rq->age_stamp += period;
strstr : INIT : 		rq->age_stamp += period; : 
strstr : if : 		rq->age_stamp += period; : 
strstr : for : 		rq->age_stamp += period; : 
strstr : while : 		rq->age_stamp += period; : 
str : 		rq->rt_avg /= 2;
strstr : INIT : 		rq->rt_avg /= 2; : 
strstr : if : 		rq->rt_avg /= 2; : 
strstr : for : 		rq->rt_avg /= 2; : 
strstr : while : 		rq->rt_avg /= 2; : 
str : 	}
strstr : INIT : 	} : 
strstr : if : 	} : 
strstr : for : 	} : 
strstr : while : 	} : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : #endif /* CONFIG_SMP */
strstr : if : #endif /* CONFIG_SMP */ : 
strstr : for : #endif /* CONFIG_SMP */ : 
strstr : while : #endif /* CONFIG_SMP */ : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : #if defined(CONFIG_RT_GROUP_SCHED) || (defined(CONFIG_FAIR_GROUP_SCHED) && \
strstr : if : #if defined(CONFIG_RT_GROUP_SCHED) || (defined(CONFIG_FAIR_GROUP_SCHED) && \ : 
strstr : for : #if defined(CONFIG_RT_GROUP_SCHED) || (defined(CONFIG_FAIR_GROUP_SCHED) && \ : 
strstr : while : #if defined(CONFIG_RT_GROUP_SCHED) || (defined(CONFIG_FAIR_GROUP_SCHED) && \ : 
str : 			(defined(CONFIG_SMP) || defined(CONFIG_CFS_BANDWIDTH)))
strstr : INIT : 			(defined(CONFIG_SMP) || defined(CONFIG_CFS_BANDWIDTH))) : 
strstr : if : 			(defined(CONFIG_SMP) || defined(CONFIG_CFS_BANDWIDTH))) : 
strstr : for : 			(defined(CONFIG_SMP) || defined(CONFIG_CFS_BANDWIDTH))) : 
strstr : while : 			(defined(CONFIG_SMP) || defined(CONFIG_CFS_BANDWIDTH))) : 
str : /*
strstr : INIT : /* : 
strstr : if : /* : 
strstr : for : /* : 
strstr : while : /* : 
str :  * Iterate task_group tree rooted at *from, calling @down when first entering a
strstr : INIT :  * Iterate task_group tree rooted at *from, calling @down when first entering a : 
strstr : if :  * Iterate task_group tree rooted at *from, calling @down when first entering a : 
strstr : for :  * Iterate task_group tree rooted at *from, calling @down when first entering a : 
strstr : while :  * Iterate task_group tree rooted at *from, calling @down when first entering a : 
str :  * node and @up when leaving it for the final time.
strstr : INIT :  * node and @up when leaving it for the final time. : 
strstr : if :  * node and @up when leaving it for the final time. : 
strstr : for :  * node and @up when leaving it for the final time. : 
strstr : while :  * node and @up when leaving it for the final time. : 
str :  *
strstr : INIT :  * : 
strstr : if :  * : 
strstr : for :  * : 
strstr : while :  * : 
str :  * Caller must hold rcu_lock or sufficient equivalent.
strstr : INIT :  * Caller must hold rcu_lock or sufficient equivalent. : 
strstr : if :  * Caller must hold rcu_lock or sufficient equivalent. : 
strstr : for :  * Caller must hold rcu_lock or sufficient equivalent. : 
strstr : while :  * Caller must hold rcu_lock or sufficient equivalent. : 
str :  */
strstr : INIT :  */ : 
strstr : if :  */ : 
strstr : for :  */ : 
strstr : while :  */ : 
str : int walk_tg_tree_from(struct task_group *from,
strstr : INIT : int walk_tg_tree_from(struct task_group *from, : 
strstr : if : int walk_tg_tree_from(struct task_group *from, : 
strstr : for : int walk_tg_tree_from(struct task_group *from, : 
strstr : while : int walk_tg_tree_from(struct task_group *from, : 
str : 			     tg_visitor down, tg_visitor up, void *data)
strstr : INIT : 			     tg_visitor down, tg_visitor up, void *data) : 
strstr : if : 			     tg_visitor down, tg_visitor up, void *data) : 
strstr : for : 			     tg_visitor down, tg_visitor up, void *data) : 
strstr : while : 			     tg_visitor down, tg_visitor up, void *data) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	struct task_group *parent, *child;
strstr : INIT : 	struct task_group *parent, *child; : 
strstr : if : 	struct task_group *parent, *child; : 
strstr : for : 	struct task_group *parent, *child; : 
strstr : while : 	struct task_group *parent, *child; : 
str : 	int ret;
strstr : INIT : 	int ret; : 
strstr : if : 	int ret; : 
strstr : for : 	int ret; : 
strstr : while : 	int ret; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	parent = from;
strstr : if : 	parent = from; : 
strstr : for : 	parent = from; : 
strstr : while : 	parent = from; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : down:
strstr : if : down: : 
strstr : for : down: : 
strstr : while : down: : 
str : 	ret = (*down)(parent, data);
strstr : INIT : 	ret = (*down)(parent, data); : 
strstr : if : 	ret = (*down)(parent, data); : 
strstr : for : 	ret = (*down)(parent, data); : 
strstr : while : 	ret = (*down)(parent, data); : 
str : 	if (ret)
strstr : INIT : 	if (ret) : 
strstr : if : 	if (ret) : 
strstr : for : 	if (ret) : 
strstr : while : 	if (ret) : 
str : 		goto out;
strstr : INIT : 		goto out; : 
strstr : if : 		goto out; : 
strstr : for : 		goto out; : 
strstr : while : 		goto out; : 
str : 	list_for_each_entry_rcu(child, &parent->children, siblings) {
strstr : INIT : 	list_for_each_entry_rcu(child, &parent->children, siblings) { : 
strstr : if : 	list_for_each_entry_rcu(child, &parent->children, siblings) { : 
strstr : for : 	list_for_each_entry_rcu(child, &parent->children, siblings) { : 
strstr : while : 	list_for_each_entry_rcu(child, &parent->children, siblings) { : 
str : 		parent = child;
strstr : INIT : 		parent = child; : 
strstr : if : 		parent = child; : 
strstr : for : 		parent = child; : 
strstr : while : 		parent = child; : 
str : 		goto down;
strstr : INIT : 		goto down; : 
strstr : if : 		goto down; : 
strstr : for : 		goto down; : 
strstr : while : 		goto down; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : up:
strstr : if : up: : 
strstr : for : up: : 
strstr : while : up: : 
str : 		continue;
strstr : INIT : 		continue; : 
strstr : if : 		continue; : 
strstr : for : 		continue; : 
strstr : while : 		continue; : 
str : 	}
strstr : INIT : 	} : 
strstr : if : 	} : 
strstr : for : 	} : 
strstr : while : 	} : 
str : 	ret = (*up)(parent, data);
strstr : INIT : 	ret = (*up)(parent, data); : 
strstr : if : 	ret = (*up)(parent, data); : 
strstr : for : 	ret = (*up)(parent, data); : 
strstr : while : 	ret = (*up)(parent, data); : 
str : 	if (ret || parent == from)
strstr : INIT : 	if (ret || parent == from) : 
strstr : if : 	if (ret || parent == from) : 
strstr : for : 	if (ret || parent == from) : 
strstr : while : 	if (ret || parent == from) : 
str : 		goto out;
strstr : INIT : 		goto out; : 
strstr : if : 		goto out; : 
strstr : for : 		goto out; : 
strstr : while : 		goto out; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	child = parent;
strstr : if : 	child = parent; : 
strstr : for : 	child = parent; : 
strstr : while : 	child = parent; : 
str : 	parent = parent->parent;
strstr : INIT : 	parent = parent->parent; : 
strstr : if : 	parent = parent->parent; : 
strstr : for : 	parent = parent->parent; : 
strstr : while : 	parent = parent->parent; : 
str : 	if (parent)
strstr : INIT : 	if (parent) : 
strstr : if : 	if (parent) : 
strstr : for : 	if (parent) : 
strstr : while : 	if (parent) : 
str : 		goto up;
strstr : INIT : 		goto up; : 
strstr : if : 		goto up; : 
strstr : for : 		goto up; : 
strstr : while : 		goto up; : 
str : out:
strstr : INIT : out: : 
strstr : if : out: : 
strstr : for : out: : 
strstr : while : out: : 
str : 	return ret;
strstr : INIT : 	return ret; : 
strstr : if : 	return ret; : 
strstr : for : 	return ret; : 
strstr : while : 	return ret; : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : int tg_nop(struct task_group *tg, void *data)
strstr : if : int tg_nop(struct task_group *tg, void *data) : 
strstr : for : int tg_nop(struct task_group *tg, void *data) : 
strstr : while : int tg_nop(struct task_group *tg, void *data) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	return 0;
strstr : INIT : 	return 0; : 
strstr : if : 	return 0; : 
strstr : for : 	return 0; : 
strstr : while : 	return 0; : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : #endif
strstr : INIT : #endif : 
strstr : if : #endif : 
strstr : for : #endif : 
strstr : while : #endif : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : static void set_load_weight(struct task_struct *p)
strstr : if : static void set_load_weight(struct task_struct *p) : 
strstr : for : static void set_load_weight(struct task_struct *p) : 
strstr : while : static void set_load_weight(struct task_struct *p) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	int prio = p->static_prio - MAX_RT_PRIO;
strstr : INIT : 	int prio = p->static_prio - MAX_RT_PRIO; : 
strstr : if : 	int prio = p->static_prio - MAX_RT_PRIO; : 
strstr : for : 	int prio = p->static_prio - MAX_RT_PRIO; : 
strstr : while : 	int prio = p->static_prio - MAX_RT_PRIO; : 
str : 	struct load_weight *load = &p->se.load;
strstr : INIT : 	struct load_weight *load = &p->se.load; : 
strstr : if : 	struct load_weight *load = &p->se.load; : 
strstr : for : 	struct load_weight *load = &p->se.load; : 
strstr : while : 	struct load_weight *load = &p->se.load; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	/*
strstr : if : 	/* : 
strstr : for : 	/* : 
strstr : while : 	/* : 
str : 	 * SCHED_IDLE tasks get minimal weight:
strstr : INIT : 	 * SCHED_IDLE tasks get minimal weight: : 
strstr : if : 	 * SCHED_IDLE tasks get minimal weight: : 
strstr : for : 	 * SCHED_IDLE tasks get minimal weight: : 
strstr : while : 	 * SCHED_IDLE tasks get minimal weight: : 
str : 	 */
strstr : INIT : 	 */ : 
strstr : if : 	 */ : 
strstr : for : 	 */ : 
strstr : while : 	 */ : 
str : 	if (p->policy == SCHED_IDLE) {
strstr : INIT : 	if (p->policy == SCHED_IDLE) { : 
strstr : if : 	if (p->policy == SCHED_IDLE) { : 
strstr : for : 	if (p->policy == SCHED_IDLE) { : 
strstr : while : 	if (p->policy == SCHED_IDLE) { : 
str : 		load->weight = scale_load(WEIGHT_IDLEPRIO);
strstr : INIT : 		load->weight = scale_load(WEIGHT_IDLEPRIO); : 
strstr : if : 		load->weight = scale_load(WEIGHT_IDLEPRIO); : 
strstr : for : 		load->weight = scale_load(WEIGHT_IDLEPRIO); : 
strstr : while : 		load->weight = scale_load(WEIGHT_IDLEPRIO); : 
str : 		load->inv_weight = WMULT_IDLEPRIO;
strstr : INIT : 		load->inv_weight = WMULT_IDLEPRIO; : 
strstr : if : 		load->inv_weight = WMULT_IDLEPRIO; : 
strstr : for : 		load->inv_weight = WMULT_IDLEPRIO; : 
strstr : while : 		load->inv_weight = WMULT_IDLEPRIO; : 
str : 		return;
strstr : INIT : 		return; : 
strstr : if : 		return; : 
strstr : for : 		return; : 
strstr : while : 		return; : 
str : 	}
strstr : INIT : 	} : 
strstr : if : 	} : 
strstr : for : 	} : 
strstr : while : 	} : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	load->weight = scale_load(prio_to_weight[prio]);
strstr : if : 	load->weight = scale_load(prio_to_weight[prio]); : 
strstr : for : 	load->weight = scale_load(prio_to_weight[prio]); : 
strstr : while : 	load->weight = scale_load(prio_to_weight[prio]); : 
str : 	load->inv_weight = prio_to_wmult[prio];
strstr : INIT : 	load->inv_weight = prio_to_wmult[prio]; : 
strstr : if : 	load->inv_weight = prio_to_wmult[prio]; : 
strstr : for : 	load->inv_weight = prio_to_wmult[prio]; : 
strstr : while : 	load->inv_weight = prio_to_wmult[prio]; : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : static void enqueue_task(struct rq *rq, struct task_struct *p, int flags)
strstr : if : static void enqueue_task(struct rq *rq, struct task_struct *p, int flags) : 
strstr : for : static void enqueue_task(struct rq *rq, struct task_struct *p, int flags) : 
strstr : while : static void enqueue_task(struct rq *rq, struct task_struct *p, int flags) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	update_rq_clock(rq);
strstr : INIT : 	update_rq_clock(rq); : 
strstr : if : 	update_rq_clock(rq); : 
strstr : for : 	update_rq_clock(rq); : 
strstr : while : 	update_rq_clock(rq); : 
str : 	sched_info_queued(rq, p);
strstr : INIT : 	sched_info_queued(rq, p); : 
strstr : if : 	sched_info_queued(rq, p); : 
strstr : for : 	sched_info_queued(rq, p); : 
strstr : while : 	sched_info_queued(rq, p); : 
str : 	p->sched_class->enqueue_task(rq, p, flags);
strstr : INIT : 	p->sched_class->enqueue_task(rq, p, flags); : 
strstr : if : 	p->sched_class->enqueue_task(rq, p, flags); : 
strstr : for : 	p->sched_class->enqueue_task(rq, p, flags); : 
strstr : while : 	p->sched_class->enqueue_task(rq, p, flags); : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : static void dequeue_task(struct rq *rq, struct task_struct *p, int flags)
strstr : if : static void dequeue_task(struct rq *rq, struct task_struct *p, int flags) : 
strstr : for : static void dequeue_task(struct rq *rq, struct task_struct *p, int flags) : 
strstr : while : static void dequeue_task(struct rq *rq, struct task_struct *p, int flags) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	update_rq_clock(rq);
strstr : INIT : 	update_rq_clock(rq); : 
strstr : if : 	update_rq_clock(rq); : 
strstr : for : 	update_rq_clock(rq); : 
strstr : while : 	update_rq_clock(rq); : 
str : 	sched_info_dequeued(rq, p);
strstr : INIT : 	sched_info_dequeued(rq, p); : 
strstr : if : 	sched_info_dequeued(rq, p); : 
strstr : for : 	sched_info_dequeued(rq, p); : 
strstr : while : 	sched_info_dequeued(rq, p); : 
str : 	p->sched_class->dequeue_task(rq, p, flags);
strstr : INIT : 	p->sched_class->dequeue_task(rq, p, flags); : 
strstr : if : 	p->sched_class->dequeue_task(rq, p, flags); : 
strstr : for : 	p->sched_class->dequeue_task(rq, p, flags); : 
strstr : while : 	p->sched_class->dequeue_task(rq, p, flags); : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : void activate_task(struct rq *rq, struct task_struct *p, int flags)
strstr : if : void activate_task(struct rq *rq, struct task_struct *p, int flags) : 
strstr : for : void activate_task(struct rq *rq, struct task_struct *p, int flags) : 
strstr : while : void activate_task(struct rq *rq, struct task_struct *p, int flags) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	if (task_contributes_to_load(p))
strstr : INIT : 	if (task_contributes_to_load(p)) : 
strstr : if : 	if (task_contributes_to_load(p)) : 
strstr : for : 	if (task_contributes_to_load(p)) : 
strstr : while : 	if (task_contributes_to_load(p)) : 
str : 		rq->nr_uninterruptible--;
strstr : INIT : 		rq->nr_uninterruptible--; : 
strstr : if : 		rq->nr_uninterruptible--; : 
strstr : for : 		rq->nr_uninterruptible--; : 
strstr : while : 		rq->nr_uninterruptible--; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	enqueue_task(rq, p, flags);
strstr : if : 	enqueue_task(rq, p, flags); : 
strstr : for : 	enqueue_task(rq, p, flags); : 
strstr : while : 	enqueue_task(rq, p, flags); : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : void deactivate_task(struct rq *rq, struct task_struct *p, int flags)
strstr : if : void deactivate_task(struct rq *rq, struct task_struct *p, int flags) : 
strstr : for : void deactivate_task(struct rq *rq, struct task_struct *p, int flags) : 
strstr : while : void deactivate_task(struct rq *rq, struct task_struct *p, int flags) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	if (task_contributes_to_load(p))
strstr : INIT : 	if (task_contributes_to_load(p)) : 
strstr : if : 	if (task_contributes_to_load(p)) : 
strstr : for : 	if (task_contributes_to_load(p)) : 
strstr : while : 	if (task_contributes_to_load(p)) : 
str : 		rq->nr_uninterruptible++;
strstr : INIT : 		rq->nr_uninterruptible++; : 
strstr : if : 		rq->nr_uninterruptible++; : 
strstr : for : 		rq->nr_uninterruptible++; : 
strstr : while : 		rq->nr_uninterruptible++; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	dequeue_task(rq, p, flags);
strstr : if : 	dequeue_task(rq, p, flags); : 
strstr : for : 	dequeue_task(rq, p, flags); : 
strstr : while : 	dequeue_task(rq, p, flags); : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : static void update_rq_clock_task(struct rq *rq, s64 delta)
strstr : if : static void update_rq_clock_task(struct rq *rq, s64 delta) : 
strstr : for : static void update_rq_clock_task(struct rq *rq, s64 delta) : 
strstr : while : static void update_rq_clock_task(struct rq *rq, s64 delta) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : /*
strstr : INIT : /* : 
strstr : if : /* : 
strstr : for : /* : 
strstr : while : /* : 
str :  * In theory, the compile should just see 0 here, and optimize out the call
strstr : INIT :  * In theory, the compile should just see 0 here, and optimize out the call : 
strstr : if :  * In theory, the compile should just see 0 here, and optimize out the call : 
strstr : for :  * In theory, the compile should just see 0 here, and optimize out the call : 
strstr : while :  * In theory, the compile should just see 0 here, and optimize out the call : 
str :  * to sched_rt_avg_update. But I don't trust it...
strstr : INIT :  * to sched_rt_avg_update. But I don't trust it... : 
strstr : if :  * to sched_rt_avg_update. But I don't trust it... : 
strstr : for :  * to sched_rt_avg_update. But I don't trust it... : 
strstr : while :  * to sched_rt_avg_update. But I don't trust it... : 
str :  */
strstr : INIT :  */ : 
strstr : if :  */ : 
strstr : for :  */ : 
strstr : while :  */ : 
str : #if defined(CONFIG_IRQ_TIME_ACCOUNTING) || defined(CONFIG_PARAVIRT_TIME_ACCOUNTING)
strstr : INIT : #if defined(CONFIG_IRQ_TIME_ACCOUNTING) || defined(CONFIG_PARAVIRT_TIME_ACCOUNTING) : 
strstr : if : #if defined(CONFIG_IRQ_TIME_ACCOUNTING) || defined(CONFIG_PARAVIRT_TIME_ACCOUNTING) : 
strstr : for : #if defined(CONFIG_IRQ_TIME_ACCOUNTING) || defined(CONFIG_PARAVIRT_TIME_ACCOUNTING) : 
strstr : while : #if defined(CONFIG_IRQ_TIME_ACCOUNTING) || defined(CONFIG_PARAVIRT_TIME_ACCOUNTING) : 
str : 	s64 steal = 0, irq_delta = 0;
strstr : INIT : 	s64 steal = 0, irq_delta = 0; : 
strstr : if : 	s64 steal = 0, irq_delta = 0; : 
strstr : for : 	s64 steal = 0, irq_delta = 0; : 
strstr : while : 	s64 steal = 0, irq_delta = 0; : 
str : #endif
strstr : INIT : #endif : 
strstr : if : #endif : 
strstr : for : #endif : 
strstr : while : #endif : 
str : #ifdef CONFIG_IRQ_TIME_ACCOUNTING
strstr : INIT : #ifdef CONFIG_IRQ_TIME_ACCOUNTING : 
strstr : if : #ifdef CONFIG_IRQ_TIME_ACCOUNTING : 
strstr : for : #ifdef CONFIG_IRQ_TIME_ACCOUNTING : 
strstr : while : #ifdef CONFIG_IRQ_TIME_ACCOUNTING : 
str : 	irq_delta = irq_time_read(cpu_of(rq)) - rq->prev_irq_time;
strstr : INIT : 	irq_delta = irq_time_read(cpu_of(rq)) - rq->prev_irq_time; : 
strstr : if : 	irq_delta = irq_time_read(cpu_of(rq)) - rq->prev_irq_time; : 
strstr : for : 	irq_delta = irq_time_read(cpu_of(rq)) - rq->prev_irq_time; : 
strstr : while : 	irq_delta = irq_time_read(cpu_of(rq)) - rq->prev_irq_time; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	/*
strstr : if : 	/* : 
strstr : for : 	/* : 
strstr : while : 	/* : 
str : 	 * Since irq_time is only updated on {soft,}irq_exit, we might run into
strstr : INIT : 	 * Since irq_time is only updated on {soft,}irq_exit, we might run into : 
strstr : if : 	 * Since irq_time is only updated on {soft,}irq_exit, we might run into : 
strstr : for : 	 * Since irq_time is only updated on {soft,}irq_exit, we might run into : 
strstr : while : 	 * Since irq_time is only updated on {soft,}irq_exit, we might run into : 
str : 	 * this case when a previous update_rq_clock() happened inside a
strstr : INIT : 	 * this case when a previous update_rq_clock() happened inside a : 
strstr : if : 	 * this case when a previous update_rq_clock() happened inside a : 
strstr : for : 	 * this case when a previous update_rq_clock() happened inside a : 
strstr : while : 	 * this case when a previous update_rq_clock() happened inside a : 
str : 	 * {soft,}irq region.
strstr : INIT : 	 * {soft,}irq region. : 
strstr : if : 	 * {soft,}irq region. : 
strstr : for : 	 * {soft,}irq region. : 
strstr : while : 	 * {soft,}irq region. : 
str : 	 *
strstr : INIT : 	 * : 
strstr : if : 	 * : 
strstr : for : 	 * : 
strstr : while : 	 * : 
str : 	 * When this happens, we stop ->clock_task and only update the
strstr : INIT : 	 * When this happens, we stop ->clock_task and only update the : 
strstr : if : 	 * When this happens, we stop ->clock_task and only update the : 
strstr : for : 	 * When this happens, we stop ->clock_task and only update the : 
strstr : while : 	 * When this happens, we stop ->clock_task and only update the : 
str : 	 * prev_irq_time stamp to account for the part that fit, so that a next
strstr : INIT : 	 * prev_irq_time stamp to account for the part that fit, so that a next : 
strstr : if : 	 * prev_irq_time stamp to account for the part that fit, so that a next : 
strstr : for : 	 * prev_irq_time stamp to account for the part that fit, so that a next : 
strstr : while : 	 * prev_irq_time stamp to account for the part that fit, so that a next : 
str : 	 * update will consume the rest. This ensures ->clock_task is
strstr : INIT : 	 * update will consume the rest. This ensures ->clock_task is : 
strstr : if : 	 * update will consume the rest. This ensures ->clock_task is : 
strstr : for : 	 * update will consume the rest. This ensures ->clock_task is : 
strstr : while : 	 * update will consume the rest. This ensures ->clock_task is : 
str : 	 * monotonic.
strstr : INIT : 	 * monotonic. : 
strstr : if : 	 * monotonic. : 
strstr : for : 	 * monotonic. : 
strstr : while : 	 * monotonic. : 
str : 	 *
strstr : INIT : 	 * : 
strstr : if : 	 * : 
strstr : for : 	 * : 
strstr : while : 	 * : 
str : 	 * It does however cause some slight miss-attribution of {soft,}irq
strstr : INIT : 	 * It does however cause some slight miss-attribution of {soft,}irq : 
strstr : if : 	 * It does however cause some slight miss-attribution of {soft,}irq : 
strstr : for : 	 * It does however cause some slight miss-attribution of {soft,}irq : 
strstr : while : 	 * It does however cause some slight miss-attribution of {soft,}irq : 
str : 	 * time, a more accurate solution would be to update the irq_time using
strstr : INIT : 	 * time, a more accurate solution would be to update the irq_time using : 
strstr : if : 	 * time, a more accurate solution would be to update the irq_time using : 
strstr : for : 	 * time, a more accurate solution would be to update the irq_time using : 
strstr : while : 	 * time, a more accurate solution would be to update the irq_time using : 
str : 	 * the current rq->clock timestamp, except that would require using
strstr : INIT : 	 * the current rq->clock timestamp, except that would require using : 
strstr : if : 	 * the current rq->clock timestamp, except that would require using : 
strstr : for : 	 * the current rq->clock timestamp, except that would require using : 
strstr : while : 	 * the current rq->clock timestamp, except that would require using : 
str : 	 * atomic ops.
strstr : INIT : 	 * atomic ops. : 
strstr : if : 	 * atomic ops. : 
strstr : for : 	 * atomic ops. : 
strstr : while : 	 * atomic ops. : 
str : 	 */
strstr : INIT : 	 */ : 
strstr : if : 	 */ : 
strstr : for : 	 */ : 
strstr : while : 	 */ : 
str : 	if (irq_delta > delta)
strstr : INIT : 	if (irq_delta > delta) : 
strstr : if : 	if (irq_delta > delta) : 
strstr : for : 	if (irq_delta > delta) : 
strstr : while : 	if (irq_delta > delta) : 
str : 		irq_delta = delta;
strstr : INIT : 		irq_delta = delta; : 
strstr : if : 		irq_delta = delta; : 
strstr : for : 		irq_delta = delta; : 
strstr : while : 		irq_delta = delta; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	rq->prev_irq_time += irq_delta;
strstr : if : 	rq->prev_irq_time += irq_delta; : 
strstr : for : 	rq->prev_irq_time += irq_delta; : 
strstr : while : 	rq->prev_irq_time += irq_delta; : 
str : 	delta -= irq_delta;
strstr : INIT : 	delta -= irq_delta; : 
strstr : if : 	delta -= irq_delta; : 
strstr : for : 	delta -= irq_delta; : 
strstr : while : 	delta -= irq_delta; : 
str : #endif
strstr : INIT : #endif : 
strstr : if : #endif : 
strstr : for : #endif : 
strstr : while : #endif : 
str : #ifdef CONFIG_PARAVIRT_TIME_ACCOUNTING
strstr : INIT : #ifdef CONFIG_PARAVIRT_TIME_ACCOUNTING : 
strstr : if : #ifdef CONFIG_PARAVIRT_TIME_ACCOUNTING : 
strstr : for : #ifdef CONFIG_PARAVIRT_TIME_ACCOUNTING : 
strstr : while : #ifdef CONFIG_PARAVIRT_TIME_ACCOUNTING : 
str : 	if (static_key_false((&paravirt_steal_rq_enabled))) {
strstr : INIT : 	if (static_key_false((&paravirt_steal_rq_enabled))) { : 
strstr : if : 	if (static_key_false((&paravirt_steal_rq_enabled))) { : 
strstr : for : 	if (static_key_false((&paravirt_steal_rq_enabled))) { : 
strstr : while : 	if (static_key_false((&paravirt_steal_rq_enabled))) { : 
str : 		u64 st;
strstr : INIT : 		u64 st; : 
strstr : if : 		u64 st; : 
strstr : for : 		u64 st; : 
strstr : while : 		u64 st; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 		steal = paravirt_steal_clock(cpu_of(rq));
strstr : if : 		steal = paravirt_steal_clock(cpu_of(rq)); : 
strstr : for : 		steal = paravirt_steal_clock(cpu_of(rq)); : 
strstr : while : 		steal = paravirt_steal_clock(cpu_of(rq)); : 
str : 		steal -= rq->prev_steal_time_rq;
strstr : INIT : 		steal -= rq->prev_steal_time_rq; : 
strstr : if : 		steal -= rq->prev_steal_time_rq; : 
strstr : for : 		steal -= rq->prev_steal_time_rq; : 
strstr : while : 		steal -= rq->prev_steal_time_rq; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 		if (unlikely(steal > delta))
strstr : if : 		if (unlikely(steal > delta)) : 
strstr : for : 		if (unlikely(steal > delta)) : 
strstr : while : 		if (unlikely(steal > delta)) : 
str : 			steal = delta;
strstr : INIT : 			steal = delta; : 
strstr : if : 			steal = delta; : 
strstr : for : 			steal = delta; : 
strstr : while : 			steal = delta; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 		st = steal_ticks(steal);
strstr : if : 		st = steal_ticks(steal); : 
strstr : for : 		st = steal_ticks(steal); : 
strstr : while : 		st = steal_ticks(steal); : 
str : 		steal = st * TICK_NSEC;
strstr : INIT : 		steal = st * TICK_NSEC; : 
strstr : if : 		steal = st * TICK_NSEC; : 
strstr : for : 		steal = st * TICK_NSEC; : 
strstr : while : 		steal = st * TICK_NSEC; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 		rq->prev_steal_time_rq += steal;
strstr : if : 		rq->prev_steal_time_rq += steal; : 
strstr : for : 		rq->prev_steal_time_rq += steal; : 
strstr : while : 		rq->prev_steal_time_rq += steal; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 		delta -= steal;
strstr : if : 		delta -= steal; : 
strstr : for : 		delta -= steal; : 
strstr : while : 		delta -= steal; : 
str : 	}
strstr : INIT : 	} : 
strstr : if : 	} : 
strstr : for : 	} : 
strstr : while : 	} : 
str : #endif
strstr : INIT : #endif : 
strstr : if : #endif : 
strstr : for : #endif : 
strstr : while : #endif : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	rq->clock_task += delta;
strstr : if : 	rq->clock_task += delta; : 
strstr : for : 	rq->clock_task += delta; : 
strstr : while : 	rq->clock_task += delta; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : #if defined(CONFIG_IRQ_TIME_ACCOUNTING) || defined(CONFIG_PARAVIRT_TIME_ACCOUNTING)
strstr : if : #if defined(CONFIG_IRQ_TIME_ACCOUNTING) || defined(CONFIG_PARAVIRT_TIME_ACCOUNTING) : 
strstr : for : #if defined(CONFIG_IRQ_TIME_ACCOUNTING) || defined(CONFIG_PARAVIRT_TIME_ACCOUNTING) : 
strstr : while : #if defined(CONFIG_IRQ_TIME_ACCOUNTING) || defined(CONFIG_PARAVIRT_TIME_ACCOUNTING) : 
str : 	if ((irq_delta + steal) && sched_feat(NONTASK_POWER))
strstr : INIT : 	if ((irq_delta + steal) && sched_feat(NONTASK_POWER)) : 
strstr : if : 	if ((irq_delta + steal) && sched_feat(NONTASK_POWER)) : 
strstr : for : 	if ((irq_delta + steal) && sched_feat(NONTASK_POWER)) : 
strstr : while : 	if ((irq_delta + steal) && sched_feat(NONTASK_POWER)) : 
str : 		sched_rt_avg_update(rq, irq_delta + steal);
strstr : INIT : 		sched_rt_avg_update(rq, irq_delta + steal); : 
strstr : if : 		sched_rt_avg_update(rq, irq_delta + steal); : 
strstr : for : 		sched_rt_avg_update(rq, irq_delta + steal); : 
strstr : while : 		sched_rt_avg_update(rq, irq_delta + steal); : 
str : #endif
strstr : INIT : #endif : 
strstr : if : #endif : 
strstr : for : #endif : 
strstr : while : #endif : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : void sched_set_stop_task(int cpu, struct task_struct *stop)
strstr : if : void sched_set_stop_task(int cpu, struct task_struct *stop) : 
strstr : for : void sched_set_stop_task(int cpu, struct task_struct *stop) : 
strstr : while : void sched_set_stop_task(int cpu, struct task_struct *stop) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	struct sched_param param = { .sched_priority = MAX_RT_PRIO - 1 };
strstr : INIT : 	struct sched_param param = { .sched_priority = MAX_RT_PRIO - 1 }; : 
strstr : if : 	struct sched_param param = { .sched_priority = MAX_RT_PRIO - 1 }; : 
strstr : for : 	struct sched_param param = { .sched_priority = MAX_RT_PRIO - 1 }; : 
strstr : while : 	struct sched_param param = { .sched_priority = MAX_RT_PRIO - 1 }; : 
str : 	struct task_struct *old_stop = cpu_rq(cpu)->stop;
strstr : INIT : 	struct task_struct *old_stop = cpu_rq(cpu)->stop; : 
strstr : if : 	struct task_struct *old_stop = cpu_rq(cpu)->stop; : 
strstr : for : 	struct task_struct *old_stop = cpu_rq(cpu)->stop; : 
strstr : while : 	struct task_struct *old_stop = cpu_rq(cpu)->stop; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	if (stop) {
strstr : if : 	if (stop) { : 
strstr : for : 	if (stop) { : 
strstr : while : 	if (stop) { : 
str : 		/*
strstr : INIT : 		/* : 
strstr : if : 		/* : 
strstr : for : 		/* : 
strstr : while : 		/* : 
str : 		 * Make it appear like a SCHED_FIFO task, its something
strstr : INIT : 		 * Make it appear like a SCHED_FIFO task, its something : 
strstr : if : 		 * Make it appear like a SCHED_FIFO task, its something : 
strstr : for : 		 * Make it appear like a SCHED_FIFO task, its something : 
strstr : while : 		 * Make it appear like a SCHED_FIFO task, its something : 
str : 		 * userspace knows about and won't get confused about.
strstr : INIT : 		 * userspace knows about and won't get confused about. : 
strstr : if : 		 * userspace knows about and won't get confused about. : 
strstr : for : 		 * userspace knows about and won't get confused about. : 
strstr : while : 		 * userspace knows about and won't get confused about. : 
str : 		 *
strstr : INIT : 		 * : 
strstr : if : 		 * : 
strstr : for : 		 * : 
strstr : while : 		 * : 
str : 		 * Also, it will make PI more or less work without too
strstr : INIT : 		 * Also, it will make PI more or less work without too : 
strstr : if : 		 * Also, it will make PI more or less work without too : 
strstr : for : 		 * Also, it will make PI more or less work without too : 
strstr : while : 		 * Also, it will make PI more or less work without too : 
str : 		 * much confusion -- but then, stop work should not
strstr : INIT : 		 * much confusion -- but then, stop work should not : 
strstr : if : 		 * much confusion -- but then, stop work should not : 
strstr : for : 		 * much confusion -- but then, stop work should not : 
strstr : while : 		 * much confusion -- but then, stop work should not : 
str : 		 * rely on PI working anyway.
strstr : INIT : 		 * rely on PI working anyway. : 
strstr : if : 		 * rely on PI working anyway. : 
strstr : for : 		 * rely on PI working anyway. : 
strstr : while : 		 * rely on PI working anyway. : 
str : 		 */
strstr : INIT : 		 */ : 
strstr : if : 		 */ : 
strstr : for : 		 */ : 
strstr : while : 		 */ : 
str : 		sched_setscheduler_nocheck(stop, SCHED_FIFO, &param);
strstr : INIT : 		sched_setscheduler_nocheck(stop, SCHED_FIFO, &param); : 
strstr : if : 		sched_setscheduler_nocheck(stop, SCHED_FIFO, &param); : 
strstr : for : 		sched_setscheduler_nocheck(stop, SCHED_FIFO, &param); : 
strstr : while : 		sched_setscheduler_nocheck(stop, SCHED_FIFO, &param); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 		stop->sched_class = &stop_sched_class;
strstr : if : 		stop->sched_class = &stop_sched_class; : 
strstr : for : 		stop->sched_class = &stop_sched_class; : 
strstr : while : 		stop->sched_class = &stop_sched_class; : 
str : 	}
strstr : INIT : 	} : 
strstr : if : 	} : 
strstr : for : 	} : 
strstr : while : 	} : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	cpu_rq(cpu)->stop = stop;
strstr : if : 	cpu_rq(cpu)->stop = stop; : 
strstr : for : 	cpu_rq(cpu)->stop = stop; : 
strstr : while : 	cpu_rq(cpu)->stop = stop; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	if (old_stop) {
strstr : if : 	if (old_stop) { : 
strstr : for : 	if (old_stop) { : 
strstr : while : 	if (old_stop) { : 
str : 		/*
strstr : INIT : 		/* : 
strstr : if : 		/* : 
strstr : for : 		/* : 
strstr : while : 		/* : 
str : 		 * Reset it back to a normal scheduling class so that
strstr : INIT : 		 * Reset it back to a normal scheduling class so that : 
strstr : if : 		 * Reset it back to a normal scheduling class so that : 
strstr : for : 		 * Reset it back to a normal scheduling class so that : 
strstr : while : 		 * Reset it back to a normal scheduling class so that : 
str : 		 * it can die in pieces.
strstr : INIT : 		 * it can die in pieces. : 
strstr : if : 		 * it can die in pieces. : 
strstr : for : 		 * it can die in pieces. : 
strstr : while : 		 * it can die in pieces. : 
str : 		 */
strstr : INIT : 		 */ : 
strstr : if : 		 */ : 
strstr : for : 		 */ : 
strstr : while : 		 */ : 
str : 		old_stop->sched_class = &rt_sched_class;
strstr : INIT : 		old_stop->sched_class = &rt_sched_class; : 
strstr : if : 		old_stop->sched_class = &rt_sched_class; : 
strstr : for : 		old_stop->sched_class = &rt_sched_class; : 
strstr : while : 		old_stop->sched_class = &rt_sched_class; : 
str : 	}
strstr : INIT : 	} : 
strstr : if : 	} : 
strstr : for : 	} : 
strstr : while : 	} : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : /*
strstr : if : /* : 
strstr : for : /* : 
strstr : while : /* : 
str :  * __normal_prio - return the priority that is based on the static prio
strstr : INIT :  * __normal_prio - return the priority that is based on the static prio : 
strstr : if :  * __normal_prio - return the priority that is based on the static prio : 
strstr : for :  * __normal_prio - return the priority that is based on the static prio : 
strstr : while :  * __normal_prio - return the priority that is based on the static prio : 
str :  */
strstr : INIT :  */ : 
strstr : if :  */ : 
strstr : for :  */ : 
strstr : while :  */ : 
str : static inline int __normal_prio(struct task_struct *p)
strstr : INIT : static inline int __normal_prio(struct task_struct *p) : 
strstr : if : static inline int __normal_prio(struct task_struct *p) : 
strstr : for : static inline int __normal_prio(struct task_struct *p) : 
strstr : while : static inline int __normal_prio(struct task_struct *p) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	return p->static_prio;
strstr : INIT : 	return p->static_prio; : 
strstr : if : 	return p->static_prio; : 
strstr : for : 	return p->static_prio; : 
strstr : while : 	return p->static_prio; : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : /*
strstr : if : /* : 
strstr : for : /* : 
strstr : while : /* : 
str :  * Calculate the expected normal priority: i.e. priority
strstr : INIT :  * Calculate the expected normal priority: i.e. priority : 
strstr : if :  * Calculate the expected normal priority: i.e. priority : 
strstr : for :  * Calculate the expected normal priority: i.e. priority : 
strstr : while :  * Calculate the expected normal priority: i.e. priority : 
str :  * without taking RT-inheritance into account. Might be
strstr : INIT :  * without taking RT-inheritance into account. Might be : 
strstr : if :  * without taking RT-inheritance into account. Might be : 
strstr : for :  * without taking RT-inheritance into account. Might be : 
strstr : while :  * without taking RT-inheritance into account. Might be : 
str :  * boosted by interactivity modifiers. Changes upon fork,
strstr : INIT :  * boosted by interactivity modifiers. Changes upon fork, : 
strstr : if :  * boosted by interactivity modifiers. Changes upon fork, : 
strstr : for :  * boosted by interactivity modifiers. Changes upon fork, : 
strstr : while :  * boosted by interactivity modifiers. Changes upon fork, : 
str :  * setprio syscalls, and whenever the interactivity
strstr : INIT :  * setprio syscalls, and whenever the interactivity : 
strstr : if :  * setprio syscalls, and whenever the interactivity : 
strstr : for :  * setprio syscalls, and whenever the interactivity : 
strstr : while :  * setprio syscalls, and whenever the interactivity : 
str :  * estimator recalculates.
strstr : INIT :  * estimator recalculates. : 
strstr : if :  * estimator recalculates. : 
strstr : for :  * estimator recalculates. : 
strstr : while :  * estimator recalculates. : 
str :  */
strstr : INIT :  */ : 
strstr : if :  */ : 
strstr : for :  */ : 
strstr : while :  */ : 
str : static inline int normal_prio(struct task_struct *p)
strstr : INIT : static inline int normal_prio(struct task_struct *p) : 
strstr : if : static inline int normal_prio(struct task_struct *p) : 
strstr : for : static inline int normal_prio(struct task_struct *p) : 
strstr : while : static inline int normal_prio(struct task_struct *p) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	int prio;
strstr : INIT : 	int prio; : 
strstr : if : 	int prio; : 
strstr : for : 	int prio; : 
strstr : while : 	int prio; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	if (task_has_dl_policy(p))
strstr : if : 	if (task_has_dl_policy(p)) : 
strstr : for : 	if (task_has_dl_policy(p)) : 
strstr : while : 	if (task_has_dl_policy(p)) : 
str : 		prio = MAX_DL_PRIO-1;
strstr : INIT : 		prio = MAX_DL_PRIO-1; : 
strstr : if : 		prio = MAX_DL_PRIO-1; : 
strstr : for : 		prio = MAX_DL_PRIO-1; : 
strstr : while : 		prio = MAX_DL_PRIO-1; : 
str : 	else if (task_has_rt_policy(p))
strstr : INIT : 	else if (task_has_rt_policy(p)) : 
strstr : if : 	else if (task_has_rt_policy(p)) : 
strstr : for : 	else if (task_has_rt_policy(p)) : 
strstr : while : 	else if (task_has_rt_policy(p)) : 
str : 		prio = MAX_RT_PRIO-1 - p->rt_priority;
strstr : INIT : 		prio = MAX_RT_PRIO-1 - p->rt_priority; : 
strstr : if : 		prio = MAX_RT_PRIO-1 - p->rt_priority; : 
strstr : for : 		prio = MAX_RT_PRIO-1 - p->rt_priority; : 
strstr : while : 		prio = MAX_RT_PRIO-1 - p->rt_priority; : 
str : 	else
strstr : INIT : 	else : 
strstr : if : 	else : 
strstr : for : 	else : 
strstr : while : 	else : 
str : 		prio = __normal_prio(p);
strstr : INIT : 		prio = __normal_prio(p); : 
strstr : if : 		prio = __normal_prio(p); : 
strstr : for : 		prio = __normal_prio(p); : 
strstr : while : 		prio = __normal_prio(p); : 
str : 	return prio;
strstr : INIT : 	return prio; : 
strstr : if : 	return prio; : 
strstr : for : 	return prio; : 
strstr : while : 	return prio; : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : /*
strstr : if : /* : 
strstr : for : /* : 
strstr : while : /* : 
str :  * Calculate the current priority, i.e. the priority
strstr : INIT :  * Calculate the current priority, i.e. the priority : 
strstr : if :  * Calculate the current priority, i.e. the priority : 
strstr : for :  * Calculate the current priority, i.e. the priority : 
strstr : while :  * Calculate the current priority, i.e. the priority : 
str :  * taken into account by the scheduler. This value might
strstr : INIT :  * taken into account by the scheduler. This value might : 
strstr : if :  * taken into account by the scheduler. This value might : 
strstr : for :  * taken into account by the scheduler. This value might : 
strstr : while :  * taken into account by the scheduler. This value might : 
str :  * be boosted by RT tasks, or might be boosted by
strstr : INIT :  * be boosted by RT tasks, or might be boosted by : 
strstr : if :  * be boosted by RT tasks, or might be boosted by : 
strstr : for :  * be boosted by RT tasks, or might be boosted by : 
strstr : while :  * be boosted by RT tasks, or might be boosted by : 
str :  * interactivity modifiers. Will be RT if the task got
strstr : INIT :  * interactivity modifiers. Will be RT if the task got : 
strstr : if :  * interactivity modifiers. Will be RT if the task got : 
strstr : for :  * interactivity modifiers. Will be RT if the task got : 
strstr : while :  * interactivity modifiers. Will be RT if the task got : 
str :  * RT-boosted. If not then it returns p->normal_prio.
strstr : INIT :  * RT-boosted. If not then it returns p->normal_prio. : 
strstr : if :  * RT-boosted. If not then it returns p->normal_prio. : 
strstr : for :  * RT-boosted. If not then it returns p->normal_prio. : 
strstr : while :  * RT-boosted. If not then it returns p->normal_prio. : 
str :  */
strstr : INIT :  */ : 
strstr : if :  */ : 
strstr : for :  */ : 
strstr : while :  */ : 
str : static int effective_prio(struct task_struct *p)
strstr : INIT : static int effective_prio(struct task_struct *p) : 
strstr : if : static int effective_prio(struct task_struct *p) : 
strstr : for : static int effective_prio(struct task_struct *p) : 
strstr : while : static int effective_prio(struct task_struct *p) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	p->normal_prio = normal_prio(p);
strstr : INIT : 	p->normal_prio = normal_prio(p); : 
strstr : if : 	p->normal_prio = normal_prio(p); : 
strstr : for : 	p->normal_prio = normal_prio(p); : 
strstr : while : 	p->normal_prio = normal_prio(p); : 
str : 	/*
strstr : INIT : 	/* : 
strstr : if : 	/* : 
strstr : for : 	/* : 
strstr : while : 	/* : 
str : 	 * If we are RT tasks or we were boosted to RT priority,
strstr : INIT : 	 * If we are RT tasks or we were boosted to RT priority, : 
strstr : if : 	 * If we are RT tasks or we were boosted to RT priority, : 
strstr : for : 	 * If we are RT tasks or we were boosted to RT priority, : 
strstr : while : 	 * If we are RT tasks or we were boosted to RT priority, : 
str : 	 * keep the priority unchanged. Otherwise, update priority
strstr : INIT : 	 * keep the priority unchanged. Otherwise, update priority : 
strstr : if : 	 * keep the priority unchanged. Otherwise, update priority : 
strstr : for : 	 * keep the priority unchanged. Otherwise, update priority : 
strstr : while : 	 * keep the priority unchanged. Otherwise, update priority : 
str : 	 * to the normal priority:
strstr : INIT : 	 * to the normal priority: : 
strstr : if : 	 * to the normal priority: : 
strstr : for : 	 * to the normal priority: : 
strstr : while : 	 * to the normal priority: : 
str : 	 */
strstr : INIT : 	 */ : 
strstr : if : 	 */ : 
strstr : for : 	 */ : 
strstr : while : 	 */ : 
str : 	if (!rt_prio(p->prio))
strstr : INIT : 	if (!rt_prio(p->prio)) : 
strstr : if : 	if (!rt_prio(p->prio)) : 
strstr : for : 	if (!rt_prio(p->prio)) : 
strstr : while : 	if (!rt_prio(p->prio)) : 
str : 		return p->normal_prio;
strstr : INIT : 		return p->normal_prio; : 
strstr : if : 		return p->normal_prio; : 
strstr : for : 		return p->normal_prio; : 
strstr : while : 		return p->normal_prio; : 
str : 	return p->prio;
strstr : INIT : 	return p->prio; : 
strstr : if : 	return p->prio; : 
strstr : for : 	return p->prio; : 
strstr : while : 	return p->prio; : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : /**
strstr : if : /** : 
strstr : for : /** : 
strstr : while : /** : 
str :  * task_curr - is this task currently executing on a CPU?
strstr : INIT :  * task_curr - is this task currently executing on a CPU? : 
strstr : if :  * task_curr - is this task currently executing on a CPU? : 
strstr : for :  * task_curr - is this task currently executing on a CPU? : 
strstr : while :  * task_curr - is this task currently executing on a CPU? : 
str :  * @p: the task in question.
strstr : INIT :  * @p: the task in question. : 
strstr : if :  * @p: the task in question. : 
strstr : for :  * @p: the task in question. : 
strstr : while :  * @p: the task in question. : 
str :  *
strstr : INIT :  * : 
strstr : if :  * : 
strstr : for :  * : 
strstr : while :  * : 
str :  * Return: 1 if the task is currently executing. 0 otherwise.
strstr : INIT :  * Return: 1 if the task is currently executing. 0 otherwise. : 
strstr : if :  * Return: 1 if the task is currently executing. 0 otherwise. : 
strstr : for :  * Return: 1 if the task is currently executing. 0 otherwise. : 
strstr : while :  * Return: 1 if the task is currently executing. 0 otherwise. : 
str :  */
strstr : INIT :  */ : 
strstr : if :  */ : 
strstr : for :  */ : 
strstr : while :  */ : 
str : inline int task_curr(const struct task_struct *p)
strstr : INIT : inline int task_curr(const struct task_struct *p) : 
strstr : if : inline int task_curr(const struct task_struct *p) : 
strstr : for : inline int task_curr(const struct task_struct *p) : 
strstr : while : inline int task_curr(const struct task_struct *p) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	return cpu_curr(task_cpu(p)) == p;
strstr : INIT : 	return cpu_curr(task_cpu(p)) == p; : 
strstr : if : 	return cpu_curr(task_cpu(p)) == p; : 
strstr : for : 	return cpu_curr(task_cpu(p)) == p; : 
strstr : while : 	return cpu_curr(task_cpu(p)) == p; : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : static inline void check_class_changed(struct rq *rq, struct task_struct *p,
strstr : if : static inline void check_class_changed(struct rq *rq, struct task_struct *p, : 
strstr : for : static inline void check_class_changed(struct rq *rq, struct task_struct *p, : 
strstr : while : static inline void check_class_changed(struct rq *rq, struct task_struct *p, : 
str : 				       const struct sched_class *prev_class,
strstr : INIT : 				       const struct sched_class *prev_class, : 
strstr : if : 				       const struct sched_class *prev_class, : 
strstr : for : 				       const struct sched_class *prev_class, : 
strstr : while : 				       const struct sched_class *prev_class, : 
str : 				       int oldprio)
strstr : INIT : 				       int oldprio) : 
strstr : if : 				       int oldprio) : 
strstr : for : 				       int oldprio) : 
strstr : while : 				       int oldprio) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	if (prev_class != p->sched_class) {
strstr : INIT : 	if (prev_class != p->sched_class) { : 
strstr : if : 	if (prev_class != p->sched_class) { : 
strstr : for : 	if (prev_class != p->sched_class) { : 
strstr : while : 	if (prev_class != p->sched_class) { : 
str : 		if (prev_class->switched_from)
strstr : INIT : 		if (prev_class->switched_from) : 
strstr : if : 		if (prev_class->switched_from) : 
strstr : for : 		if (prev_class->switched_from) : 
strstr : while : 		if (prev_class->switched_from) : 
str : 			prev_class->switched_from(rq, p);
strstr : INIT : 			prev_class->switched_from(rq, p); : 
strstr : if : 			prev_class->switched_from(rq, p); : 
strstr : for : 			prev_class->switched_from(rq, p); : 
strstr : while : 			prev_class->switched_from(rq, p); : 
str : 		p->sched_class->switched_to(rq, p);
strstr : INIT : 		p->sched_class->switched_to(rq, p); : 
strstr : if : 		p->sched_class->switched_to(rq, p); : 
strstr : for : 		p->sched_class->switched_to(rq, p); : 
strstr : while : 		p->sched_class->switched_to(rq, p); : 
str : 	} else if (oldprio != p->prio || dl_task(p))
strstr : INIT : 	} else if (oldprio != p->prio || dl_task(p)) : 
strstr : if : 	} else if (oldprio != p->prio || dl_task(p)) : 
strstr : for : 	} else if (oldprio != p->prio || dl_task(p)) : 
strstr : while : 	} else if (oldprio != p->prio || dl_task(p)) : 
str : 		p->sched_class->prio_changed(rq, p, oldprio);
strstr : INIT : 		p->sched_class->prio_changed(rq, p, oldprio); : 
strstr : if : 		p->sched_class->prio_changed(rq, p, oldprio); : 
strstr : for : 		p->sched_class->prio_changed(rq, p, oldprio); : 
strstr : while : 		p->sched_class->prio_changed(rq, p, oldprio); : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags)
strstr : if : void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags) : 
strstr : for : void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags) : 
strstr : while : void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	const struct sched_class *class;
strstr : INIT : 	const struct sched_class *class; : 
strstr : if : 	const struct sched_class *class; : 
strstr : for : 	const struct sched_class *class; : 
strstr : while : 	const struct sched_class *class; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	if (p->sched_class == rq->curr->sched_class) {
strstr : if : 	if (p->sched_class == rq->curr->sched_class) { : 
strstr : for : 	if (p->sched_class == rq->curr->sched_class) { : 
strstr : while : 	if (p->sched_class == rq->curr->sched_class) { : 
str : 		rq->curr->sched_class->check_preempt_curr(rq, p, flags);
strstr : INIT : 		rq->curr->sched_class->check_preempt_curr(rq, p, flags); : 
strstr : if : 		rq->curr->sched_class->check_preempt_curr(rq, p, flags); : 
strstr : for : 		rq->curr->sched_class->check_preempt_curr(rq, p, flags); : 
strstr : while : 		rq->curr->sched_class->check_preempt_curr(rq, p, flags); : 
str : 	} else {
strstr : INIT : 	} else { : 
strstr : if : 	} else { : 
strstr : for : 	} else { : 
strstr : while : 	} else { : 
str : 		for_each_class(class) {
strstr : INIT : 		for_each_class(class) { : 
strstr : if : 		for_each_class(class) { : 
strstr : for : 		for_each_class(class) { : 
strstr : while : 		for_each_class(class) { : 
str : 			if (class == rq->curr->sched_class)
strstr : INIT : 			if (class == rq->curr->sched_class) : 
strstr : if : 			if (class == rq->curr->sched_class) : 
strstr : for : 			if (class == rq->curr->sched_class) : 
strstr : while : 			if (class == rq->curr->sched_class) : 
str : 				break;
strstr : INIT : 				break; : 
strstr : if : 				break; : 
strstr : for : 				break; : 
strstr : while : 				break; : 
str : 			if (class == p->sched_class) {
strstr : INIT : 			if (class == p->sched_class) { : 
strstr : if : 			if (class == p->sched_class) { : 
strstr : for : 			if (class == p->sched_class) { : 
strstr : while : 			if (class == p->sched_class) { : 
str : 				resched_task(rq->curr);
strstr : INIT : 				resched_task(rq->curr); : 
strstr : if : 				resched_task(rq->curr); : 
strstr : for : 				resched_task(rq->curr); : 
strstr : while : 				resched_task(rq->curr); : 
str : 				break;
strstr : INIT : 				break; : 
strstr : if : 				break; : 
strstr : for : 				break; : 
strstr : while : 				break; : 
str : 			}
strstr : INIT : 			} : 
strstr : if : 			} : 
strstr : for : 			} : 
strstr : while : 			} : 
str : 		}
strstr : INIT : 		} : 
strstr : if : 		} : 
strstr : for : 		} : 
strstr : while : 		} : 
str : 	}
strstr : INIT : 	} : 
strstr : if : 	} : 
strstr : for : 	} : 
strstr : while : 	} : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	/*
strstr : if : 	/* : 
strstr : for : 	/* : 
strstr : while : 	/* : 
str : 	 * A queue event has occurred, and we're going to schedule.  In
strstr : INIT : 	 * A queue event has occurred, and we're going to schedule.  In : 
strstr : if : 	 * A queue event has occurred, and we're going to schedule.  In : 
strstr : for : 	 * A queue event has occurred, and we're going to schedule.  In : 
strstr : while : 	 * A queue event has occurred, and we're going to schedule.  In : 
str : 	 * this case, we can save a useless back to back clock update.
strstr : INIT : 	 * this case, we can save a useless back to back clock update. : 
strstr : if : 	 * this case, we can save a useless back to back clock update. : 
strstr : for : 	 * this case, we can save a useless back to back clock update. : 
strstr : while : 	 * this case, we can save a useless back to back clock update. : 
str : 	 */
strstr : INIT : 	 */ : 
strstr : if : 	 */ : 
strstr : for : 	 */ : 
strstr : while : 	 */ : 
str : 	if (rq->curr->on_rq && test_tsk_need_resched(rq->curr))
strstr : INIT : 	if (rq->curr->on_rq && test_tsk_need_resched(rq->curr)) : 
strstr : if : 	if (rq->curr->on_rq && test_tsk_need_resched(rq->curr)) : 
strstr : for : 	if (rq->curr->on_rq && test_tsk_need_resched(rq->curr)) : 
strstr : while : 	if (rq->curr->on_rq && test_tsk_need_resched(rq->curr)) : 
str : 		rq->skip_clock_update = 1;
strstr : INIT : 		rq->skip_clock_update = 1; : 
strstr : if : 		rq->skip_clock_update = 1; : 
strstr : for : 		rq->skip_clock_update = 1; : 
strstr : while : 		rq->skip_clock_update = 1; : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : #ifdef CONFIG_SMP
strstr : if : #ifdef CONFIG_SMP : 
strstr : for : #ifdef CONFIG_SMP : 
strstr : while : #ifdef CONFIG_SMP : 
str : void set_task_cpu(struct task_struct *p, unsigned int new_cpu)
strstr : INIT : void set_task_cpu(struct task_struct *p, unsigned int new_cpu) : 
strstr : if : void set_task_cpu(struct task_struct *p, unsigned int new_cpu) : 
strstr : for : void set_task_cpu(struct task_struct *p, unsigned int new_cpu) : 
strstr : while : void set_task_cpu(struct task_struct *p, unsigned int new_cpu) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : #ifdef CONFIG_SCHED_DEBUG
strstr : INIT : #ifdef CONFIG_SCHED_DEBUG : 
strstr : if : #ifdef CONFIG_SCHED_DEBUG : 
strstr : for : #ifdef CONFIG_SCHED_DEBUG : 
strstr : while : #ifdef CONFIG_SCHED_DEBUG : 
str : 	/*
strstr : INIT : 	/* : 
strstr : if : 	/* : 
strstr : for : 	/* : 
strstr : while : 	/* : 
str : 	 * We should never call set_task_cpu() on a blocked task,
strstr : INIT : 	 * We should never call set_task_cpu() on a blocked task, : 
strstr : if : 	 * We should never call set_task_cpu() on a blocked task, : 
strstr : for : 	 * We should never call set_task_cpu() on a blocked task, : 
strstr : while : 	 * We should never call set_task_cpu() on a blocked task, : 
str : 	 * ttwu() will sort out the placement.
strstr : INIT : 	 * ttwu() will sort out the placement. : 
strstr : if : 	 * ttwu() will sort out the placement. : 
strstr : for : 	 * ttwu() will sort out the placement. : 
strstr : while : 	 * ttwu() will sort out the placement. : 
str : 	 */
strstr : INIT : 	 */ : 
strstr : if : 	 */ : 
strstr : for : 	 */ : 
strstr : while : 	 */ : 
str : 	WARN_ON_ONCE(p->state != TASK_RUNNING && p->state != TASK_WAKING &&
strstr : INIT : 	WARN_ON_ONCE(p->state != TASK_RUNNING && p->state != TASK_WAKING && : 
strstr : if : 	WARN_ON_ONCE(p->state != TASK_RUNNING && p->state != TASK_WAKING && : 
strstr : for : 	WARN_ON_ONCE(p->state != TASK_RUNNING && p->state != TASK_WAKING && : 
strstr : while : 	WARN_ON_ONCE(p->state != TASK_RUNNING && p->state != TASK_WAKING && : 
str : 			!(task_preempt_count(p) & PREEMPT_ACTIVE));
strstr : INIT : 			!(task_preempt_count(p) & PREEMPT_ACTIVE)); : 
strstr : if : 			!(task_preempt_count(p) & PREEMPT_ACTIVE)); : 
strstr : for : 			!(task_preempt_count(p) & PREEMPT_ACTIVE)); : 
strstr : while : 			!(task_preempt_count(p) & PREEMPT_ACTIVE)); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : #ifdef CONFIG_LOCKDEP
strstr : if : #ifdef CONFIG_LOCKDEP : 
strstr : for : #ifdef CONFIG_LOCKDEP : 
strstr : while : #ifdef CONFIG_LOCKDEP : 
str : 	/*
strstr : INIT : 	/* : 
strstr : if : 	/* : 
strstr : for : 	/* : 
strstr : while : 	/* : 
str : 	 * The caller should hold either p->pi_lock or rq->lock, when changing
strstr : INIT : 	 * The caller should hold either p->pi_lock or rq->lock, when changing : 
strstr : if : 	 * The caller should hold either p->pi_lock or rq->lock, when changing : 
strstr : for : 	 * The caller should hold either p->pi_lock or rq->lock, when changing : 
strstr : while : 	 * The caller should hold either p->pi_lock or rq->lock, when changing : 
str : 	 * a task's CPU. ->pi_lock for waking tasks, rq->lock for runnable tasks.
strstr : INIT : 	 * a task's CPU. ->pi_lock for waking tasks, rq->lock for runnable tasks. : 
strstr : if : 	 * a task's CPU. ->pi_lock for waking tasks, rq->lock for runnable tasks. : 
strstr : for : 	 * a task's CPU. ->pi_lock for waking tasks, rq->lock for runnable tasks. : 
strstr : while : 	 * a task's CPU. ->pi_lock for waking tasks, rq->lock for runnable tasks. : 
str : 	 *
strstr : INIT : 	 * : 
strstr : if : 	 * : 
strstr : for : 	 * : 
strstr : while : 	 * : 
str : 	 * sched_move_task() holds both and thus holding either pins the cgroup,
strstr : INIT : 	 * sched_move_task() holds both and thus holding either pins the cgroup, : 
strstr : if : 	 * sched_move_task() holds both and thus holding either pins the cgroup, : 
strstr : for : 	 * sched_move_task() holds both and thus holding either pins the cgroup, : 
strstr : while : 	 * sched_move_task() holds both and thus holding either pins the cgroup, : 
str : 	 * see task_group().
strstr : INIT : 	 * see task_group(). : 
strstr : if : 	 * see task_group(). : 
strstr : for : 	 * see task_group(). : 
strstr : while : 	 * see task_group(). : 
str : 	 *
strstr : INIT : 	 * : 
strstr : if : 	 * : 
strstr : for : 	 * : 
strstr : while : 	 * : 
str : 	 * Furthermore, all task_rq users should acquire both locks, see
strstr : INIT : 	 * Furthermore, all task_rq users should acquire both locks, see : 
strstr : if : 	 * Furthermore, all task_rq users should acquire both locks, see : 
strstr : for : 	 * Furthermore, all task_rq users should acquire both locks, see : 
strstr : while : 	 * Furthermore, all task_rq users should acquire both locks, see : 
str : 	 * task_rq_lock().
strstr : INIT : 	 * task_rq_lock(). : 
strstr : if : 	 * task_rq_lock(). : 
strstr : for : 	 * task_rq_lock(). : 
strstr : while : 	 * task_rq_lock(). : 
str : 	 */
strstr : INIT : 	 */ : 
strstr : if : 	 */ : 
strstr : for : 	 */ : 
strstr : while : 	 */ : 
str : 	WARN_ON_ONCE(debug_locks && !(lockdep_is_held(&p->pi_lock) ||
strstr : INIT : 	WARN_ON_ONCE(debug_locks && !(lockdep_is_held(&p->pi_lock) || : 
strstr : if : 	WARN_ON_ONCE(debug_locks && !(lockdep_is_held(&p->pi_lock) || : 
strstr : for : 	WARN_ON_ONCE(debug_locks && !(lockdep_is_held(&p->pi_lock) || : 
strstr : while : 	WARN_ON_ONCE(debug_locks && !(lockdep_is_held(&p->pi_lock) || : 
str : 				      lockdep_is_held(&task_rq(p)->lock)));
strstr : INIT : 				      lockdep_is_held(&task_rq(p)->lock))); : 
strstr : if : 				      lockdep_is_held(&task_rq(p)->lock))); : 
strstr : for : 				      lockdep_is_held(&task_rq(p)->lock))); : 
strstr : while : 				      lockdep_is_held(&task_rq(p)->lock))); : 
str : #endif
strstr : INIT : #endif : 
strstr : if : #endif : 
strstr : for : #endif : 
strstr : while : #endif : 
str : #endif
strstr : INIT : #endif : 
strstr : if : #endif : 
strstr : for : #endif : 
strstr : while : #endif : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	trace_sched_migrate_task(p, new_cpu);
strstr : if : 	trace_sched_migrate_task(p, new_cpu); : 
strstr : for : 	trace_sched_migrate_task(p, new_cpu); : 
strstr : while : 	trace_sched_migrate_task(p, new_cpu); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	if (task_cpu(p) != new_cpu) {
strstr : if : 	if (task_cpu(p) != new_cpu) { : 
strstr : for : 	if (task_cpu(p) != new_cpu) { : 
strstr : while : 	if (task_cpu(p) != new_cpu) { : 
str : 		if (p->sched_class->migrate_task_rq)
strstr : INIT : 		if (p->sched_class->migrate_task_rq) : 
strstr : if : 		if (p->sched_class->migrate_task_rq) : 
strstr : for : 		if (p->sched_class->migrate_task_rq) : 
strstr : while : 		if (p->sched_class->migrate_task_rq) : 
str : 			p->sched_class->migrate_task_rq(p, new_cpu);
strstr : INIT : 			p->sched_class->migrate_task_rq(p, new_cpu); : 
strstr : if : 			p->sched_class->migrate_task_rq(p, new_cpu); : 
strstr : for : 			p->sched_class->migrate_task_rq(p, new_cpu); : 
strstr : while : 			p->sched_class->migrate_task_rq(p, new_cpu); : 
str : 		p->se.nr_migrations++;
strstr : INIT : 		p->se.nr_migrations++; : 
strstr : if : 		p->se.nr_migrations++; : 
strstr : for : 		p->se.nr_migrations++; : 
strstr : while : 		p->se.nr_migrations++; : 
str : 		perf_sw_event(PERF_COUNT_SW_CPU_MIGRATIONS, 1, NULL, 0);
strstr : INIT : 		perf_sw_event(PERF_COUNT_SW_CPU_MIGRATIONS, 1, NULL, 0); : 
strstr : if : 		perf_sw_event(PERF_COUNT_SW_CPU_MIGRATIONS, 1, NULL, 0); : 
strstr : for : 		perf_sw_event(PERF_COUNT_SW_CPU_MIGRATIONS, 1, NULL, 0); : 
strstr : while : 		perf_sw_event(PERF_COUNT_SW_CPU_MIGRATIONS, 1, NULL, 0); : 
str : 	}
strstr : INIT : 	} : 
strstr : if : 	} : 
strstr : for : 	} : 
strstr : while : 	} : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	__set_task_cpu(p, new_cpu);
strstr : if : 	__set_task_cpu(p, new_cpu); : 
strstr : for : 	__set_task_cpu(p, new_cpu); : 
strstr : while : 	__set_task_cpu(p, new_cpu); : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : static void __migrate_swap_task(struct task_struct *p, int cpu)
strstr : if : static void __migrate_swap_task(struct task_struct *p, int cpu) : 
strstr : for : static void __migrate_swap_task(struct task_struct *p, int cpu) : 
strstr : while : static void __migrate_swap_task(struct task_struct *p, int cpu) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	if (p->on_rq) {
strstr : INIT : 	if (p->on_rq) { : 
strstr : if : 	if (p->on_rq) { : 
strstr : for : 	if (p->on_rq) { : 
strstr : while : 	if (p->on_rq) { : 
str : 		struct rq *src_rq, *dst_rq;
strstr : INIT : 		struct rq *src_rq, *dst_rq; : 
strstr : if : 		struct rq *src_rq, *dst_rq; : 
strstr : for : 		struct rq *src_rq, *dst_rq; : 
strstr : while : 		struct rq *src_rq, *dst_rq; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 		src_rq = task_rq(p);
strstr : if : 		src_rq = task_rq(p); : 
strstr : for : 		src_rq = task_rq(p); : 
strstr : while : 		src_rq = task_rq(p); : 
str : 		dst_rq = cpu_rq(cpu);
strstr : INIT : 		dst_rq = cpu_rq(cpu); : 
strstr : if : 		dst_rq = cpu_rq(cpu); : 
strstr : for : 		dst_rq = cpu_rq(cpu); : 
strstr : while : 		dst_rq = cpu_rq(cpu); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 		deactivate_task(src_rq, p, 0);
strstr : if : 		deactivate_task(src_rq, p, 0); : 
strstr : for : 		deactivate_task(src_rq, p, 0); : 
strstr : while : 		deactivate_task(src_rq, p, 0); : 
str : 		set_task_cpu(p, cpu);
strstr : INIT : 		set_task_cpu(p, cpu); : 
strstr : if : 		set_task_cpu(p, cpu); : 
strstr : for : 		set_task_cpu(p, cpu); : 
strstr : while : 		set_task_cpu(p, cpu); : 
str : 		activate_task(dst_rq, p, 0);
strstr : INIT : 		activate_task(dst_rq, p, 0); : 
strstr : if : 		activate_task(dst_rq, p, 0); : 
strstr : for : 		activate_task(dst_rq, p, 0); : 
strstr : while : 		activate_task(dst_rq, p, 0); : 
str : 		check_preempt_curr(dst_rq, p, 0);
strstr : INIT : 		check_preempt_curr(dst_rq, p, 0); : 
strstr : if : 		check_preempt_curr(dst_rq, p, 0); : 
strstr : for : 		check_preempt_curr(dst_rq, p, 0); : 
strstr : while : 		check_preempt_curr(dst_rq, p, 0); : 
str : 	} else {
strstr : INIT : 	} else { : 
strstr : if : 	} else { : 
strstr : for : 	} else { : 
strstr : while : 	} else { : 
str : 		/*
strstr : INIT : 		/* : 
strstr : if : 		/* : 
strstr : for : 		/* : 
strstr : while : 		/* : 
str : 		 * Task isn't running anymore; make it appear like we migrated
strstr : INIT : 		 * Task isn't running anymore; make it appear like we migrated : 
strstr : if : 		 * Task isn't running anymore; make it appear like we migrated : 
strstr : for : 		 * Task isn't running anymore; make it appear like we migrated : 
strstr : while : 		 * Task isn't running anymore; make it appear like we migrated : 
str : 		 * it before it went to sleep. This means on wakeup we make the
strstr : INIT : 		 * it before it went to sleep. This means on wakeup we make the : 
strstr : if : 		 * it before it went to sleep. This means on wakeup we make the : 
strstr : for : 		 * it before it went to sleep. This means on wakeup we make the : 
strstr : while : 		 * it before it went to sleep. This means on wakeup we make the : 
str : 		 * previous cpu our targer instead of where it really is.
strstr : INIT : 		 * previous cpu our targer instead of where it really is. : 
strstr : if : 		 * previous cpu our targer instead of where it really is. : 
strstr : for : 		 * previous cpu our targer instead of where it really is. : 
strstr : while : 		 * previous cpu our targer instead of where it really is. : 
str : 		 */
strstr : INIT : 		 */ : 
strstr : if : 		 */ : 
strstr : for : 		 */ : 
strstr : while : 		 */ : 
str : 		p->wake_cpu = cpu;
strstr : INIT : 		p->wake_cpu = cpu; : 
strstr : if : 		p->wake_cpu = cpu; : 
strstr : for : 		p->wake_cpu = cpu; : 
strstr : while : 		p->wake_cpu = cpu; : 
str : 	}
strstr : INIT : 	} : 
strstr : if : 	} : 
strstr : for : 	} : 
strstr : while : 	} : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : struct migration_swap_arg {
strstr : if : struct migration_swap_arg { : 
strstr : for : struct migration_swap_arg { : 
strstr : while : struct migration_swap_arg { : 
str : 	struct task_struct *src_task, *dst_task;
strstr : INIT : 	struct task_struct *src_task, *dst_task; : 
strstr : if : 	struct task_struct *src_task, *dst_task; : 
strstr : for : 	struct task_struct *src_task, *dst_task; : 
strstr : while : 	struct task_struct *src_task, *dst_task; : 
str : 	int src_cpu, dst_cpu;
strstr : INIT : 	int src_cpu, dst_cpu; : 
strstr : if : 	int src_cpu, dst_cpu; : 
strstr : for : 	int src_cpu, dst_cpu; : 
strstr : while : 	int src_cpu, dst_cpu; : 
str : };
strstr : INIT : }; : 
strstr : if : }; : 
strstr : for : }; : 
strstr : while : }; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : static int migrate_swap_stop(void *data)
strstr : if : static int migrate_swap_stop(void *data) : 
strstr : for : static int migrate_swap_stop(void *data) : 
strstr : while : static int migrate_swap_stop(void *data) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	struct migration_swap_arg *arg = data;
strstr : INIT : 	struct migration_swap_arg *arg = data; : 
strstr : if : 	struct migration_swap_arg *arg = data; : 
strstr : for : 	struct migration_swap_arg *arg = data; : 
strstr : while : 	struct migration_swap_arg *arg = data; : 
str : 	struct rq *src_rq, *dst_rq;
strstr : INIT : 	struct rq *src_rq, *dst_rq; : 
strstr : if : 	struct rq *src_rq, *dst_rq; : 
strstr : for : 	struct rq *src_rq, *dst_rq; : 
strstr : while : 	struct rq *src_rq, *dst_rq; : 
str : 	int ret = -EAGAIN;
strstr : INIT : 	int ret = -EAGAIN; : 
strstr : if : 	int ret = -EAGAIN; : 
strstr : for : 	int ret = -EAGAIN; : 
strstr : while : 	int ret = -EAGAIN; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	src_rq = cpu_rq(arg->src_cpu);
strstr : if : 	src_rq = cpu_rq(arg->src_cpu); : 
strstr : for : 	src_rq = cpu_rq(arg->src_cpu); : 
strstr : while : 	src_rq = cpu_rq(arg->src_cpu); : 
str : 	dst_rq = cpu_rq(arg->dst_cpu);
strstr : INIT : 	dst_rq = cpu_rq(arg->dst_cpu); : 
strstr : if : 	dst_rq = cpu_rq(arg->dst_cpu); : 
strstr : for : 	dst_rq = cpu_rq(arg->dst_cpu); : 
strstr : while : 	dst_rq = cpu_rq(arg->dst_cpu); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	double_raw_lock(&arg->src_task->pi_lock,
strstr : if : 	double_raw_lock(&arg->src_task->pi_lock, : 
strstr : for : 	double_raw_lock(&arg->src_task->pi_lock, : 
strstr : while : 	double_raw_lock(&arg->src_task->pi_lock, : 
str : 			&arg->dst_task->pi_lock);
strstr : INIT : 			&arg->dst_task->pi_lock); : 
strstr : if : 			&arg->dst_task->pi_lock); : 
strstr : for : 			&arg->dst_task->pi_lock); : 
strstr : while : 			&arg->dst_task->pi_lock); : 
str : 	double_rq_lock(src_rq, dst_rq);
strstr : INIT : 	double_rq_lock(src_rq, dst_rq); : 
strstr : if : 	double_rq_lock(src_rq, dst_rq); : 
strstr : for : 	double_rq_lock(src_rq, dst_rq); : 
strstr : while : 	double_rq_lock(src_rq, dst_rq); : 
str : 	if (task_cpu(arg->dst_task) != arg->dst_cpu)
strstr : INIT : 	if (task_cpu(arg->dst_task) != arg->dst_cpu) : 
strstr : if : 	if (task_cpu(arg->dst_task) != arg->dst_cpu) : 
strstr : for : 	if (task_cpu(arg->dst_task) != arg->dst_cpu) : 
strstr : while : 	if (task_cpu(arg->dst_task) != arg->dst_cpu) : 
str : 		goto unlock;
strstr : INIT : 		goto unlock; : 
strstr : if : 		goto unlock; : 
strstr : for : 		goto unlock; : 
strstr : while : 		goto unlock; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	if (task_cpu(arg->src_task) != arg->src_cpu)
strstr : if : 	if (task_cpu(arg->src_task) != arg->src_cpu) : 
strstr : for : 	if (task_cpu(arg->src_task) != arg->src_cpu) : 
strstr : while : 	if (task_cpu(arg->src_task) != arg->src_cpu) : 
str : 		goto unlock;
strstr : INIT : 		goto unlock; : 
strstr : if : 		goto unlock; : 
strstr : for : 		goto unlock; : 
strstr : while : 		goto unlock; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	if (!cpumask_test_cpu(arg->dst_cpu, tsk_cpus_allowed(arg->src_task)))
strstr : if : 	if (!cpumask_test_cpu(arg->dst_cpu, tsk_cpus_allowed(arg->src_task))) : 
strstr : for : 	if (!cpumask_test_cpu(arg->dst_cpu, tsk_cpus_allowed(arg->src_task))) : 
strstr : while : 	if (!cpumask_test_cpu(arg->dst_cpu, tsk_cpus_allowed(arg->src_task))) : 
str : 		goto unlock;
strstr : INIT : 		goto unlock; : 
strstr : if : 		goto unlock; : 
strstr : for : 		goto unlock; : 
strstr : while : 		goto unlock; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	if (!cpumask_test_cpu(arg->src_cpu, tsk_cpus_allowed(arg->dst_task)))
strstr : if : 	if (!cpumask_test_cpu(arg->src_cpu, tsk_cpus_allowed(arg->dst_task))) : 
strstr : for : 	if (!cpumask_test_cpu(arg->src_cpu, tsk_cpus_allowed(arg->dst_task))) : 
strstr : while : 	if (!cpumask_test_cpu(arg->src_cpu, tsk_cpus_allowed(arg->dst_task))) : 
str : 		goto unlock;
strstr : INIT : 		goto unlock; : 
strstr : if : 		goto unlock; : 
strstr : for : 		goto unlock; : 
strstr : while : 		goto unlock; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	__migrate_swap_task(arg->src_task, arg->dst_cpu);
strstr : if : 	__migrate_swap_task(arg->src_task, arg->dst_cpu); : 
strstr : for : 	__migrate_swap_task(arg->src_task, arg->dst_cpu); : 
strstr : while : 	__migrate_swap_task(arg->src_task, arg->dst_cpu); : 
str : 	__migrate_swap_task(arg->dst_task, arg->src_cpu);
strstr : INIT : 	__migrate_swap_task(arg->dst_task, arg->src_cpu); : 
strstr : if : 	__migrate_swap_task(arg->dst_task, arg->src_cpu); : 
strstr : for : 	__migrate_swap_task(arg->dst_task, arg->src_cpu); : 
strstr : while : 	__migrate_swap_task(arg->dst_task, arg->src_cpu); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	ret = 0;
strstr : if : 	ret = 0; : 
strstr : for : 	ret = 0; : 
strstr : while : 	ret = 0; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : unlock:
strstr : if : unlock: : 
strstr : for : unlock: : 
strstr : while : unlock: : 
str : 	double_rq_unlock(src_rq, dst_rq);
strstr : INIT : 	double_rq_unlock(src_rq, dst_rq); : 
strstr : if : 	double_rq_unlock(src_rq, dst_rq); : 
strstr : for : 	double_rq_unlock(src_rq, dst_rq); : 
strstr : while : 	double_rq_unlock(src_rq, dst_rq); : 
str : 	raw_spin_unlock(&arg->dst_task->pi_lock);
strstr : INIT : 	raw_spin_unlock(&arg->dst_task->pi_lock); : 
strstr : if : 	raw_spin_unlock(&arg->dst_task->pi_lock); : 
strstr : for : 	raw_spin_unlock(&arg->dst_task->pi_lock); : 
strstr : while : 	raw_spin_unlock(&arg->dst_task->pi_lock); : 
str : 	raw_spin_unlock(&arg->src_task->pi_lock);
strstr : INIT : 	raw_spin_unlock(&arg->src_task->pi_lock); : 
strstr : if : 	raw_spin_unlock(&arg->src_task->pi_lock); : 
strstr : for : 	raw_spin_unlock(&arg->src_task->pi_lock); : 
strstr : while : 	raw_spin_unlock(&arg->src_task->pi_lock); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	return ret;
strstr : if : 	return ret; : 
strstr : for : 	return ret; : 
strstr : while : 	return ret; : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : /*
strstr : if : /* : 
strstr : for : /* : 
strstr : while : /* : 
str :  * Cross migrate two tasks
strstr : INIT :  * Cross migrate two tasks : 
strstr : if :  * Cross migrate two tasks : 
strstr : for :  * Cross migrate two tasks : 
strstr : while :  * Cross migrate two tasks : 
str :  */
strstr : INIT :  */ : 
strstr : if :  */ : 
strstr : for :  */ : 
strstr : while :  */ : 
str : int migrate_swap(struct task_struct *cur, struct task_struct *p)
strstr : INIT : int migrate_swap(struct task_struct *cur, struct task_struct *p) : 
strstr : if : int migrate_swap(struct task_struct *cur, struct task_struct *p) : 
strstr : for : int migrate_swap(struct task_struct *cur, struct task_struct *p) : 
strstr : while : int migrate_swap(struct task_struct *cur, struct task_struct *p) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	struct migration_swap_arg arg;
strstr : INIT : 	struct migration_swap_arg arg; : 
strstr : if : 	struct migration_swap_arg arg; : 
strstr : for : 	struct migration_swap_arg arg; : 
strstr : while : 	struct migration_swap_arg arg; : 
str : 	int ret = -EINVAL;
strstr : INIT : 	int ret = -EINVAL; : 
strstr : if : 	int ret = -EINVAL; : 
strstr : for : 	int ret = -EINVAL; : 
strstr : while : 	int ret = -EINVAL; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	arg = (struct migration_swap_arg){
strstr : if : 	arg = (struct migration_swap_arg){ : 
strstr : for : 	arg = (struct migration_swap_arg){ : 
strstr : while : 	arg = (struct migration_swap_arg){ : 
str : 		.src_task = cur,
strstr : INIT : 		.src_task = cur, : 
strstr : if : 		.src_task = cur, : 
strstr : for : 		.src_task = cur, : 
strstr : while : 		.src_task = cur, : 
str : 		.src_cpu = task_cpu(cur),
strstr : INIT : 		.src_cpu = task_cpu(cur), : 
strstr : if : 		.src_cpu = task_cpu(cur), : 
strstr : for : 		.src_cpu = task_cpu(cur), : 
strstr : while : 		.src_cpu = task_cpu(cur), : 
str : 		.dst_task = p,
strstr : INIT : 		.dst_task = p, : 
strstr : if : 		.dst_task = p, : 
strstr : for : 		.dst_task = p, : 
strstr : while : 		.dst_task = p, : 
str : 		.dst_cpu = task_cpu(p),
strstr : INIT : 		.dst_cpu = task_cpu(p), : 
strstr : if : 		.dst_cpu = task_cpu(p), : 
strstr : for : 		.dst_cpu = task_cpu(p), : 
strstr : while : 		.dst_cpu = task_cpu(p), : 
str : 	};
strstr : INIT : 	}; : 
strstr : if : 	}; : 
strstr : for : 	}; : 
strstr : while : 	}; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	if (arg.src_cpu == arg.dst_cpu)
strstr : if : 	if (arg.src_cpu == arg.dst_cpu) : 
strstr : for : 	if (arg.src_cpu == arg.dst_cpu) : 
strstr : while : 	if (arg.src_cpu == arg.dst_cpu) : 
str : 		goto out;
strstr : INIT : 		goto out; : 
strstr : if : 		goto out; : 
strstr : for : 		goto out; : 
strstr : while : 		goto out; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	/*
strstr : if : 	/* : 
strstr : for : 	/* : 
strstr : while : 	/* : 
str : 	 * These three tests are all lockless; this is OK since all of them
strstr : INIT : 	 * These three tests are all lockless; this is OK since all of them : 
strstr : if : 	 * These three tests are all lockless; this is OK since all of them : 
strstr : for : 	 * These three tests are all lockless; this is OK since all of them : 
strstr : while : 	 * These three tests are all lockless; this is OK since all of them : 
str : 	 * will be re-checked with proper locks held further down the line.
strstr : INIT : 	 * will be re-checked with proper locks held further down the line. : 
strstr : if : 	 * will be re-checked with proper locks held further down the line. : 
strstr : for : 	 * will be re-checked with proper locks held further down the line. : 
strstr : while : 	 * will be re-checked with proper locks held further down the line. : 
str : 	 */
strstr : INIT : 	 */ : 
strstr : if : 	 */ : 
strstr : for : 	 */ : 
strstr : while : 	 */ : 
str : 	if (!cpu_active(arg.src_cpu) || !cpu_active(arg.dst_cpu))
strstr : INIT : 	if (!cpu_active(arg.src_cpu) || !cpu_active(arg.dst_cpu)) : 
strstr : if : 	if (!cpu_active(arg.src_cpu) || !cpu_active(arg.dst_cpu)) : 
strstr : for : 	if (!cpu_active(arg.src_cpu) || !cpu_active(arg.dst_cpu)) : 
strstr : while : 	if (!cpu_active(arg.src_cpu) || !cpu_active(arg.dst_cpu)) : 
str : 		goto out;
strstr : INIT : 		goto out; : 
strstr : if : 		goto out; : 
strstr : for : 		goto out; : 
strstr : while : 		goto out; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	if (!cpumask_test_cpu(arg.dst_cpu, tsk_cpus_allowed(arg.src_task)))
strstr : if : 	if (!cpumask_test_cpu(arg.dst_cpu, tsk_cpus_allowed(arg.src_task))) : 
strstr : for : 	if (!cpumask_test_cpu(arg.dst_cpu, tsk_cpus_allowed(arg.src_task))) : 
strstr : while : 	if (!cpumask_test_cpu(arg.dst_cpu, tsk_cpus_allowed(arg.src_task))) : 
str : 		goto out;
strstr : INIT : 		goto out; : 
strstr : if : 		goto out; : 
strstr : for : 		goto out; : 
strstr : while : 		goto out; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	if (!cpumask_test_cpu(arg.src_cpu, tsk_cpus_allowed(arg.dst_task)))
strstr : if : 	if (!cpumask_test_cpu(arg.src_cpu, tsk_cpus_allowed(arg.dst_task))) : 
strstr : for : 	if (!cpumask_test_cpu(arg.src_cpu, tsk_cpus_allowed(arg.dst_task))) : 
strstr : while : 	if (!cpumask_test_cpu(arg.src_cpu, tsk_cpus_allowed(arg.dst_task))) : 
str : 		goto out;
strstr : INIT : 		goto out; : 
strstr : if : 		goto out; : 
strstr : for : 		goto out; : 
strstr : while : 		goto out; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	trace_sched_swap_numa(cur, arg.src_cpu, p, arg.dst_cpu);
strstr : if : 	trace_sched_swap_numa(cur, arg.src_cpu, p, arg.dst_cpu); : 
strstr : for : 	trace_sched_swap_numa(cur, arg.src_cpu, p, arg.dst_cpu); : 
strstr : while : 	trace_sched_swap_numa(cur, arg.src_cpu, p, arg.dst_cpu); : 
str : 	ret = stop_two_cpus(arg.dst_cpu, arg.src_cpu, migrate_swap_stop, &arg);
strstr : INIT : 	ret = stop_two_cpus(arg.dst_cpu, arg.src_cpu, migrate_swap_stop, &arg); : 
strstr : if : 	ret = stop_two_cpus(arg.dst_cpu, arg.src_cpu, migrate_swap_stop, &arg); : 
strstr : for : 	ret = stop_two_cpus(arg.dst_cpu, arg.src_cpu, migrate_swap_stop, &arg); : 
strstr : while : 	ret = stop_two_cpus(arg.dst_cpu, arg.src_cpu, migrate_swap_stop, &arg); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : out:
strstr : if : out: : 
strstr : for : out: : 
strstr : while : out: : 
str : 	return ret;
strstr : INIT : 	return ret; : 
strstr : if : 	return ret; : 
strstr : for : 	return ret; : 
strstr : while : 	return ret; : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : struct migration_arg {
strstr : if : struct migration_arg { : 
strstr : for : struct migration_arg { : 
strstr : while : struct migration_arg { : 
str : 	struct task_struct *task;
strstr : INIT : 	struct task_struct *task; : 
strstr : if : 	struct task_struct *task; : 
strstr : for : 	struct task_struct *task; : 
strstr : while : 	struct task_struct *task; : 
str : 	int dest_cpu;
strstr : INIT : 	int dest_cpu; : 
strstr : if : 	int dest_cpu; : 
strstr : for : 	int dest_cpu; : 
strstr : while : 	int dest_cpu; : 
str : };
strstr : INIT : }; : 
strstr : if : }; : 
strstr : for : }; : 
strstr : while : }; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : static int migration_cpu_stop(void *data);
strstr : if : static int migration_cpu_stop(void *data); : 
strstr : for : static int migration_cpu_stop(void *data); : 
strstr : while : static int migration_cpu_stop(void *data); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : /*
strstr : if : /* : 
strstr : for : /* : 
strstr : while : /* : 
str :  * wait_task_inactive - wait for a thread to unschedule.
strstr : INIT :  * wait_task_inactive - wait for a thread to unschedule. : 
strstr : if :  * wait_task_inactive - wait for a thread to unschedule. : 
strstr : for :  * wait_task_inactive - wait for a thread to unschedule. : 
strstr : while :  * wait_task_inactive - wait for a thread to unschedule. : 
str :  *
strstr : INIT :  * : 
strstr : if :  * : 
strstr : for :  * : 
strstr : while :  * : 
str :  * If @match_state is nonzero, it's the @p->state value just checked and
strstr : INIT :  * If @match_state is nonzero, it's the @p->state value just checked and : 
strstr : if :  * If @match_state is nonzero, it's the @p->state value just checked and : 
strstr : for :  * If @match_state is nonzero, it's the @p->state value just checked and : 
strstr : while :  * If @match_state is nonzero, it's the @p->state value just checked and : 
str :  * not expected to change.  If it changes, i.e. @p might have woken up,
strstr : INIT :  * not expected to change.  If it changes, i.e. @p might have woken up, : 
strstr : if :  * not expected to change.  If it changes, i.e. @p might have woken up, : 
strstr : for :  * not expected to change.  If it changes, i.e. @p might have woken up, : 
strstr : while :  * not expected to change.  If it changes, i.e. @p might have woken up, : 
str :  * then return zero.  When we succeed in waiting for @p to be off its CPU,
strstr : INIT :  * then return zero.  When we succeed in waiting for @p to be off its CPU, : 
strstr : if :  * then return zero.  When we succeed in waiting for @p to be off its CPU, : 
strstr : for :  * then return zero.  When we succeed in waiting for @p to be off its CPU, : 
strstr : while :  * then return zero.  When we succeed in waiting for @p to be off its CPU, : 
str :  * we return a positive number (its total switch count).  If a second call
strstr : INIT :  * we return a positive number (its total switch count).  If a second call : 
strstr : if :  * we return a positive number (its total switch count).  If a second call : 
strstr : for :  * we return a positive number (its total switch count).  If a second call : 
strstr : while :  * we return a positive number (its total switch count).  If a second call : 
str :  * a short while later returns the same number, the caller can be sure that
strstr : INIT :  * a short while later returns the same number, the caller can be sure that : 
strstr : if :  * a short while later returns the same number, the caller can be sure that : 
strstr : for :  * a short while later returns the same number, the caller can be sure that : 
strstr : while :  * a short while later returns the same number, the caller can be sure that : 
str :  * @p has remained unscheduled the whole time.
strstr : INIT :  * @p has remained unscheduled the whole time. : 
strstr : if :  * @p has remained unscheduled the whole time. : 
strstr : for :  * @p has remained unscheduled the whole time. : 
strstr : while :  * @p has remained unscheduled the whole time. : 
str :  *
strstr : INIT :  * : 
strstr : if :  * : 
strstr : for :  * : 
strstr : while :  * : 
str :  * The caller must ensure that the task *will* unschedule sometime soon,
strstr : INIT :  * The caller must ensure that the task *will* unschedule sometime soon, : 
strstr : if :  * The caller must ensure that the task *will* unschedule sometime soon, : 
strstr : for :  * The caller must ensure that the task *will* unschedule sometime soon, : 
strstr : while :  * The caller must ensure that the task *will* unschedule sometime soon, : 
str :  * else this function might spin for a *long* time. This function can't
strstr : INIT :  * else this function might spin for a *long* time. This function can't : 
strstr : if :  * else this function might spin for a *long* time. This function can't : 
strstr : for :  * else this function might spin for a *long* time. This function can't : 
strstr : while :  * else this function might spin for a *long* time. This function can't : 
str :  * be called with interrupts off, or it may introduce deadlock with
strstr : INIT :  * be called with interrupts off, or it may introduce deadlock with : 
strstr : if :  * be called with interrupts off, or it may introduce deadlock with : 
strstr : for :  * be called with interrupts off, or it may introduce deadlock with : 
strstr : while :  * be called with interrupts off, or it may introduce deadlock with : 
str :  * smp_call_function() if an IPI is sent by the same process we are
strstr : INIT :  * smp_call_function() if an IPI is sent by the same process we are : 
strstr : if :  * smp_call_function() if an IPI is sent by the same process we are : 
strstr : for :  * smp_call_function() if an IPI is sent by the same process we are : 
strstr : while :  * smp_call_function() if an IPI is sent by the same process we are : 
str :  * waiting to become inactive.
strstr : INIT :  * waiting to become inactive. : 
strstr : if :  * waiting to become inactive. : 
strstr : for :  * waiting to become inactive. : 
strstr : while :  * waiting to become inactive. : 
str :  */
strstr : INIT :  */ : 
strstr : if :  */ : 
strstr : for :  */ : 
strstr : while :  */ : 
str : unsigned long wait_task_inactive(struct task_struct *p, long match_state)
strstr : INIT : unsigned long wait_task_inactive(struct task_struct *p, long match_state) : 
strstr : if : unsigned long wait_task_inactive(struct task_struct *p, long match_state) : 
strstr : for : unsigned long wait_task_inactive(struct task_struct *p, long match_state) : 
strstr : while : unsigned long wait_task_inactive(struct task_struct *p, long match_state) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	unsigned long flags;
strstr : INIT : 	unsigned long flags; : 
strstr : if : 	unsigned long flags; : 
strstr : for : 	unsigned long flags; : 
strstr : while : 	unsigned long flags; : 
str : 	int running, on_rq;
strstr : INIT : 	int running, on_rq; : 
strstr : if : 	int running, on_rq; : 
strstr : for : 	int running, on_rq; : 
strstr : while : 	int running, on_rq; : 
str : 	unsigned long ncsw;
strstr : INIT : 	unsigned long ncsw; : 
strstr : if : 	unsigned long ncsw; : 
strstr : for : 	unsigned long ncsw; : 
strstr : while : 	unsigned long ncsw; : 
str : 	struct rq *rq;
strstr : INIT : 	struct rq *rq; : 
strstr : if : 	struct rq *rq; : 
strstr : for : 	struct rq *rq; : 
strstr : while : 	struct rq *rq; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	for (;;) {
strstr : if : 	for (;;) { : 
strstr : for : 	for (;;) { : 
strstr : while : 	for (;;) { : 
str : 		/*
strstr : INIT : 		/* : 
strstr : if : 		/* : 
strstr : for : 		/* : 
strstr : while : 		/* : 
str : 		 * We do the initial early heuristics without holding
strstr : INIT : 		 * We do the initial early heuristics without holding : 
strstr : if : 		 * We do the initial early heuristics without holding : 
strstr : for : 		 * We do the initial early heuristics without holding : 
strstr : while : 		 * We do the initial early heuristics without holding : 
str : 		 * any task-queue locks at all. We'll only try to get
strstr : INIT : 		 * any task-queue locks at all. We'll only try to get : 
strstr : if : 		 * any task-queue locks at all. We'll only try to get : 
strstr : for : 		 * any task-queue locks at all. We'll only try to get : 
strstr : while : 		 * any task-queue locks at all. We'll only try to get : 
str : 		 * the runqueue lock when things look like they will
strstr : INIT : 		 * the runqueue lock when things look like they will : 
strstr : if : 		 * the runqueue lock when things look like they will : 
strstr : for : 		 * the runqueue lock when things look like they will : 
strstr : while : 		 * the runqueue lock when things look like they will : 
str : 		 * work out!
strstr : INIT : 		 * work out! : 
strstr : if : 		 * work out! : 
strstr : for : 		 * work out! : 
strstr : while : 		 * work out! : 
str : 		 */
strstr : INIT : 		 */ : 
strstr : if : 		 */ : 
strstr : for : 		 */ : 
strstr : while : 		 */ : 
str : 		rq = task_rq(p);
strstr : INIT : 		rq = task_rq(p); : 
strstr : if : 		rq = task_rq(p); : 
strstr : for : 		rq = task_rq(p); : 
strstr : while : 		rq = task_rq(p); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 		/*
strstr : if : 		/* : 
strstr : for : 		/* : 
strstr : while : 		/* : 
str : 		 * If the task is actively running on another CPU
strstr : INIT : 		 * If the task is actively running on another CPU : 
strstr : if : 		 * If the task is actively running on another CPU : 
strstr : for : 		 * If the task is actively running on another CPU : 
strstr : while : 		 * If the task is actively running on another CPU : 
str : 		 * still, just relax and busy-wait without holding
strstr : INIT : 		 * still, just relax and busy-wait without holding : 
strstr : if : 		 * still, just relax and busy-wait without holding : 
strstr : for : 		 * still, just relax and busy-wait without holding : 
strstr : while : 		 * still, just relax and busy-wait without holding : 
str : 		 * any locks.
strstr : INIT : 		 * any locks. : 
strstr : if : 		 * any locks. : 
strstr : for : 		 * any locks. : 
strstr : while : 		 * any locks. : 
str : 		 *
strstr : INIT : 		 * : 
strstr : if : 		 * : 
strstr : for : 		 * : 
strstr : while : 		 * : 
str : 		 * NOTE! Since we don't hold any locks, it's not
strstr : INIT : 		 * NOTE! Since we don't hold any locks, it's not : 
strstr : if : 		 * NOTE! Since we don't hold any locks, it's not : 
strstr : for : 		 * NOTE! Since we don't hold any locks, it's not : 
strstr : while : 		 * NOTE! Since we don't hold any locks, it's not : 
str : 		 * even sure that "rq" stays as the right runqueue!
strstr : INIT : 		 * even sure that "rq" stays as the right runqueue! : 
strstr : if : 		 * even sure that "rq" stays as the right runqueue! : 
strstr : for : 		 * even sure that "rq" stays as the right runqueue! : 
strstr : while : 		 * even sure that "rq" stays as the right runqueue! : 
str : 		 * But we don't care, since "task_running()" will
strstr : INIT : 		 * But we don't care, since "task_running()" will : 
strstr : if : 		 * But we don't care, since "task_running()" will : 
strstr : for : 		 * But we don't care, since "task_running()" will : 
strstr : while : 		 * But we don't care, since "task_running()" will : 
str : 		 * return false if the runqueue has changed and p
strstr : INIT : 		 * return false if the runqueue has changed and p : 
strstr : if : 		 * return false if the runqueue has changed and p : 
strstr : for : 		 * return false if the runqueue has changed and p : 
strstr : while : 		 * return false if the runqueue has changed and p : 
str : 		 * is actually now running somewhere else!
strstr : INIT : 		 * is actually now running somewhere else! : 
strstr : if : 		 * is actually now running somewhere else! : 
strstr : for : 		 * is actually now running somewhere else! : 
strstr : while : 		 * is actually now running somewhere else! : 
str : 		 */
strstr : INIT : 		 */ : 
strstr : if : 		 */ : 
strstr : for : 		 */ : 
strstr : while : 		 */ : 
str : 		while (task_running(rq, p)) {
strstr : INIT : 		while (task_running(rq, p)) { : 
strstr : if : 		while (task_running(rq, p)) { : 
strstr : for : 		while (task_running(rq, p)) { : 
strstr : while : 		while (task_running(rq, p)) { : 
str : 			if (match_state && unlikely(p->state != match_state))
strstr : INIT : 			if (match_state && unlikely(p->state != match_state)) : 
strstr : if : 			if (match_state && unlikely(p->state != match_state)) : 
strstr : for : 			if (match_state && unlikely(p->state != match_state)) : 
strstr : while : 			if (match_state && unlikely(p->state != match_state)) : 
str : 				return 0;
strstr : INIT : 				return 0; : 
strstr : if : 				return 0; : 
strstr : for : 				return 0; : 
strstr : while : 				return 0; : 
str : 			cpu_relax();
strstr : INIT : 			cpu_relax(); : 
strstr : if : 			cpu_relax(); : 
strstr : for : 			cpu_relax(); : 
strstr : while : 			cpu_relax(); : 
str : 		}
strstr : INIT : 		} : 
strstr : if : 		} : 
strstr : for : 		} : 
strstr : while : 		} : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 		/*
strstr : if : 		/* : 
strstr : for : 		/* : 
strstr : while : 		/* : 
str : 		 * Ok, time to look more closely! We need the rq
strstr : INIT : 		 * Ok, time to look more closely! We need the rq : 
strstr : if : 		 * Ok, time to look more closely! We need the rq : 
strstr : for : 		 * Ok, time to look more closely! We need the rq : 
strstr : while : 		 * Ok, time to look more closely! We need the rq : 
str : 		 * lock now, to be *sure*. If we're wrong, we'll
strstr : INIT : 		 * lock now, to be *sure*. If we're wrong, we'll : 
strstr : if : 		 * lock now, to be *sure*. If we're wrong, we'll : 
strstr : for : 		 * lock now, to be *sure*. If we're wrong, we'll : 
strstr : while : 		 * lock now, to be *sure*. If we're wrong, we'll : 
str : 		 * just go back and repeat.
strstr : INIT : 		 * just go back and repeat. : 
strstr : if : 		 * just go back and repeat. : 
strstr : for : 		 * just go back and repeat. : 
strstr : while : 		 * just go back and repeat. : 
str : 		 */
strstr : INIT : 		 */ : 
strstr : if : 		 */ : 
strstr : for : 		 */ : 
strstr : while : 		 */ : 
str : 		rq = task_rq_lock(p, &flags);
strstr : INIT : 		rq = task_rq_lock(p, &flags); : 
strstr : if : 		rq = task_rq_lock(p, &flags); : 
strstr : for : 		rq = task_rq_lock(p, &flags); : 
strstr : while : 		rq = task_rq_lock(p, &flags); : 
str : 		trace_sched_wait_task(p);
strstr : INIT : 		trace_sched_wait_task(p); : 
strstr : if : 		trace_sched_wait_task(p); : 
strstr : for : 		trace_sched_wait_task(p); : 
strstr : while : 		trace_sched_wait_task(p); : 
str : 		running = task_running(rq, p);
strstr : INIT : 		running = task_running(rq, p); : 
strstr : if : 		running = task_running(rq, p); : 
strstr : for : 		running = task_running(rq, p); : 
strstr : while : 		running = task_running(rq, p); : 
str : 		on_rq = p->on_rq;
strstr : INIT : 		on_rq = p->on_rq; : 
strstr : if : 		on_rq = p->on_rq; : 
strstr : for : 		on_rq = p->on_rq; : 
strstr : while : 		on_rq = p->on_rq; : 
str : 		ncsw = 0;
strstr : INIT : 		ncsw = 0; : 
strstr : if : 		ncsw = 0; : 
strstr : for : 		ncsw = 0; : 
strstr : while : 		ncsw = 0; : 
str : 		if (!match_state || p->state == match_state)
strstr : INIT : 		if (!match_state || p->state == match_state) : 
strstr : if : 		if (!match_state || p->state == match_state) : 
strstr : for : 		if (!match_state || p->state == match_state) : 
strstr : while : 		if (!match_state || p->state == match_state) : 
str : 			ncsw = p->nvcsw | LONG_MIN; /* sets MSB */
strstr : INIT : 			ncsw = p->nvcsw | LONG_MIN; /* sets MSB */ : 
strstr : if : 			ncsw = p->nvcsw | LONG_MIN; /* sets MSB */ : 
strstr : for : 			ncsw = p->nvcsw | LONG_MIN; /* sets MSB */ : 
strstr : while : 			ncsw = p->nvcsw | LONG_MIN; /* sets MSB */ : 
str : 		task_rq_unlock(rq, p, &flags);
strstr : INIT : 		task_rq_unlock(rq, p, &flags); : 
strstr : if : 		task_rq_unlock(rq, p, &flags); : 
strstr : for : 		task_rq_unlock(rq, p, &flags); : 
strstr : while : 		task_rq_unlock(rq, p, &flags); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 		/*
strstr : if : 		/* : 
strstr : for : 		/* : 
strstr : while : 		/* : 
str : 		 * If it changed from the expected state, bail out now.
strstr : INIT : 		 * If it changed from the expected state, bail out now. : 
strstr : if : 		 * If it changed from the expected state, bail out now. : 
strstr : for : 		 * If it changed from the expected state, bail out now. : 
strstr : while : 		 * If it changed from the expected state, bail out now. : 
str : 		 */
strstr : INIT : 		 */ : 
strstr : if : 		 */ : 
strstr : for : 		 */ : 
strstr : while : 		 */ : 
str : 		if (unlikely(!ncsw))
strstr : INIT : 		if (unlikely(!ncsw)) : 
strstr : if : 		if (unlikely(!ncsw)) : 
strstr : for : 		if (unlikely(!ncsw)) : 
strstr : while : 		if (unlikely(!ncsw)) : 
str : 			break;
strstr : INIT : 			break; : 
strstr : if : 			break; : 
strstr : for : 			break; : 
strstr : while : 			break; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 		/*
strstr : if : 		/* : 
strstr : for : 		/* : 
strstr : while : 		/* : 
str : 		 * Was it really running after all now that we
strstr : INIT : 		 * Was it really running after all now that we : 
strstr : if : 		 * Was it really running after all now that we : 
strstr : for : 		 * Was it really running after all now that we : 
strstr : while : 		 * Was it really running after all now that we : 
str : 		 * checked with the proper locks actually held?
strstr : INIT : 		 * checked with the proper locks actually held? : 
strstr : if : 		 * checked with the proper locks actually held? : 
strstr : for : 		 * checked with the proper locks actually held? : 
strstr : while : 		 * checked with the proper locks actually held? : 
str : 		 *
strstr : INIT : 		 * : 
strstr : if : 		 * : 
strstr : for : 		 * : 
strstr : while : 		 * : 
str : 		 * Oops. Go back and try again..
strstr : INIT : 		 * Oops. Go back and try again.. : 
strstr : if : 		 * Oops. Go back and try again.. : 
strstr : for : 		 * Oops. Go back and try again.. : 
strstr : while : 		 * Oops. Go back and try again.. : 
str : 		 */
strstr : INIT : 		 */ : 
strstr : if : 		 */ : 
strstr : for : 		 */ : 
strstr : while : 		 */ : 
str : 		if (unlikely(running)) {
strstr : INIT : 		if (unlikely(running)) { : 
strstr : if : 		if (unlikely(running)) { : 
strstr : for : 		if (unlikely(running)) { : 
strstr : while : 		if (unlikely(running)) { : 
str : 			cpu_relax();
strstr : INIT : 			cpu_relax(); : 
strstr : if : 			cpu_relax(); : 
strstr : for : 			cpu_relax(); : 
strstr : while : 			cpu_relax(); : 
str : 			continue;
strstr : INIT : 			continue; : 
strstr : if : 			continue; : 
strstr : for : 			continue; : 
strstr : while : 			continue; : 
str : 		}
strstr : INIT : 		} : 
strstr : if : 		} : 
strstr : for : 		} : 
strstr : while : 		} : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 		/*
strstr : if : 		/* : 
strstr : for : 		/* : 
strstr : while : 		/* : 
str : 		 * It's not enough that it's not actively running,
strstr : INIT : 		 * It's not enough that it's not actively running, : 
strstr : if : 		 * It's not enough that it's not actively running, : 
strstr : for : 		 * It's not enough that it's not actively running, : 
strstr : while : 		 * It's not enough that it's not actively running, : 
str : 		 * it must be off the runqueue _entirely_, and not
strstr : INIT : 		 * it must be off the runqueue _entirely_, and not : 
strstr : if : 		 * it must be off the runqueue _entirely_, and not : 
strstr : for : 		 * it must be off the runqueue _entirely_, and not : 
strstr : while : 		 * it must be off the runqueue _entirely_, and not : 
str : 		 * preempted!
strstr : INIT : 		 * preempted! : 
strstr : if : 		 * preempted! : 
strstr : for : 		 * preempted! : 
strstr : while : 		 * preempted! : 
str : 		 *
strstr : INIT : 		 * : 
strstr : if : 		 * : 
strstr : for : 		 * : 
strstr : while : 		 * : 
str : 		 * So if it was still runnable (but just not actively
strstr : INIT : 		 * So if it was still runnable (but just not actively : 
strstr : if : 		 * So if it was still runnable (but just not actively : 
strstr : for : 		 * So if it was still runnable (but just not actively : 
strstr : while : 		 * So if it was still runnable (but just not actively : 
str : 		 * running right now), it's preempted, and we should
strstr : INIT : 		 * running right now), it's preempted, and we should : 
strstr : if : 		 * running right now), it's preempted, and we should : 
strstr : for : 		 * running right now), it's preempted, and we should : 
strstr : while : 		 * running right now), it's preempted, and we should : 
str : 		 * yield - it could be a while.
strstr : INIT : 		 * yield - it could be a while. : 
strstr : if : 		 * yield - it could be a while. : 
strstr : for : 		 * yield - it could be a while. : 
strstr : while : 		 * yield - it could be a while. : 
str : 		 */
strstr : INIT : 		 */ : 
strstr : if : 		 */ : 
strstr : for : 		 */ : 
strstr : while : 		 */ : 
str : 		if (unlikely(on_rq)) {
strstr : INIT : 		if (unlikely(on_rq)) { : 
strstr : if : 		if (unlikely(on_rq)) { : 
strstr : for : 		if (unlikely(on_rq)) { : 
strstr : while : 		if (unlikely(on_rq)) { : 
str : 			ktime_t to = ktime_set(0, NSEC_PER_SEC/HZ);
strstr : INIT : 			ktime_t to = ktime_set(0, NSEC_PER_SEC/HZ); : 
strstr : if : 			ktime_t to = ktime_set(0, NSEC_PER_SEC/HZ); : 
strstr : for : 			ktime_t to = ktime_set(0, NSEC_PER_SEC/HZ); : 
strstr : while : 			ktime_t to = ktime_set(0, NSEC_PER_SEC/HZ); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 			set_current_state(TASK_UNINTERRUPTIBLE);
strstr : if : 			set_current_state(TASK_UNINTERRUPTIBLE); : 
strstr : for : 			set_current_state(TASK_UNINTERRUPTIBLE); : 
strstr : while : 			set_current_state(TASK_UNINTERRUPTIBLE); : 
str : 			schedule_hrtimeout(&to, HRTIMER_MODE_REL);
strstr : INIT : 			schedule_hrtimeout(&to, HRTIMER_MODE_REL); : 
strstr : if : 			schedule_hrtimeout(&to, HRTIMER_MODE_REL); : 
strstr : for : 			schedule_hrtimeout(&to, HRTIMER_MODE_REL); : 
strstr : while : 			schedule_hrtimeout(&to, HRTIMER_MODE_REL); : 
str : 			continue;
strstr : INIT : 			continue; : 
strstr : if : 			continue; : 
strstr : for : 			continue; : 
strstr : while : 			continue; : 
str : 		}
strstr : INIT : 		} : 
strstr : if : 		} : 
strstr : for : 		} : 
strstr : while : 		} : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 		/*
strstr : if : 		/* : 
strstr : for : 		/* : 
strstr : while : 		/* : 
str : 		 * Ahh, all good. It wasn't running, and it wasn't
strstr : INIT : 		 * Ahh, all good. It wasn't running, and it wasn't : 
strstr : if : 		 * Ahh, all good. It wasn't running, and it wasn't : 
strstr : for : 		 * Ahh, all good. It wasn't running, and it wasn't : 
strstr : while : 		 * Ahh, all good. It wasn't running, and it wasn't : 
str : 		 * runnable, which means that it will never become
strstr : INIT : 		 * runnable, which means that it will never become : 
strstr : if : 		 * runnable, which means that it will never become : 
strstr : for : 		 * runnable, which means that it will never become : 
strstr : while : 		 * runnable, which means that it will never become : 
str : 		 * running in the future either. We're all done!
strstr : INIT : 		 * running in the future either. We're all done! : 
strstr : if : 		 * running in the future either. We're all done! : 
strstr : for : 		 * running in the future either. We're all done! : 
strstr : while : 		 * running in the future either. We're all done! : 
str : 		 */
strstr : INIT : 		 */ : 
strstr : if : 		 */ : 
strstr : for : 		 */ : 
strstr : while : 		 */ : 
str : 		break;
strstr : INIT : 		break; : 
strstr : if : 		break; : 
strstr : for : 		break; : 
strstr : while : 		break; : 
str : 	}
strstr : INIT : 	} : 
strstr : if : 	} : 
strstr : for : 	} : 
strstr : while : 	} : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	return ncsw;
strstr : if : 	return ncsw; : 
strstr : for : 	return ncsw; : 
strstr : while : 	return ncsw; : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : /***
strstr : if : /*** : 
strstr : for : /*** : 
strstr : while : /*** : 
str :  * kick_process - kick a running thread to enter/exit the kernel
strstr : INIT :  * kick_process - kick a running thread to enter/exit the kernel : 
strstr : if :  * kick_process - kick a running thread to enter/exit the kernel : 
strstr : for :  * kick_process - kick a running thread to enter/exit the kernel : 
strstr : while :  * kick_process - kick a running thread to enter/exit the kernel : 
str :  * @p: the to-be-kicked thread
strstr : INIT :  * @p: the to-be-kicked thread : 
strstr : if :  * @p: the to-be-kicked thread : 
strstr : for :  * @p: the to-be-kicked thread : 
strstr : while :  * @p: the to-be-kicked thread : 
str :  *
strstr : INIT :  * : 
strstr : if :  * : 
strstr : for :  * : 
strstr : while :  * : 
str :  * Cause a process which is running on another CPU to enter
strstr : INIT :  * Cause a process which is running on another CPU to enter : 
strstr : if :  * Cause a process which is running on another CPU to enter : 
strstr : for :  * Cause a process which is running on another CPU to enter : 
strstr : while :  * Cause a process which is running on another CPU to enter : 
str :  * kernel-mode, without any delay. (to get signals handled.)
strstr : INIT :  * kernel-mode, without any delay. (to get signals handled.) : 
strstr : if :  * kernel-mode, without any delay. (to get signals handled.) : 
strstr : for :  * kernel-mode, without any delay. (to get signals handled.) : 
strstr : while :  * kernel-mode, without any delay. (to get signals handled.) : 
str :  *
strstr : INIT :  * : 
strstr : if :  * : 
strstr : for :  * : 
strstr : while :  * : 
str :  * NOTE: this function doesn't have to take the runqueue lock,
strstr : INIT :  * NOTE: this function doesn't have to take the runqueue lock, : 
strstr : if :  * NOTE: this function doesn't have to take the runqueue lock, : 
strstr : for :  * NOTE: this function doesn't have to take the runqueue lock, : 
strstr : while :  * NOTE: this function doesn't have to take the runqueue lock, : 
str :  * because all it wants to ensure is that the remote task enters
strstr : INIT :  * because all it wants to ensure is that the remote task enters : 
strstr : if :  * because all it wants to ensure is that the remote task enters : 
strstr : for :  * because all it wants to ensure is that the remote task enters : 
strstr : while :  * because all it wants to ensure is that the remote task enters : 
str :  * the kernel. If the IPI races and the task has been migrated
strstr : INIT :  * the kernel. If the IPI races and the task has been migrated : 
strstr : if :  * the kernel. If the IPI races and the task has been migrated : 
strstr : for :  * the kernel. If the IPI races and the task has been migrated : 
strstr : while :  * the kernel. If the IPI races and the task has been migrated : 
str :  * to another CPU then no harm is done and the purpose has been
strstr : INIT :  * to another CPU then no harm is done and the purpose has been : 
strstr : if :  * to another CPU then no harm is done and the purpose has been : 
strstr : for :  * to another CPU then no harm is done and the purpose has been : 
strstr : while :  * to another CPU then no harm is done and the purpose has been : 
str :  * achieved as well.
strstr : INIT :  * achieved as well. : 
strstr : if :  * achieved as well. : 
strstr : for :  * achieved as well. : 
strstr : while :  * achieved as well. : 
str :  */
strstr : INIT :  */ : 
strstr : if :  */ : 
strstr : for :  */ : 
strstr : while :  */ : 
str : void kick_process(struct task_struct *p)
strstr : INIT : void kick_process(struct task_struct *p) : 
strstr : if : void kick_process(struct task_struct *p) : 
strstr : for : void kick_process(struct task_struct *p) : 
strstr : while : void kick_process(struct task_struct *p) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	int cpu;
strstr : INIT : 	int cpu; : 
strstr : if : 	int cpu; : 
strstr : for : 	int cpu; : 
strstr : while : 	int cpu; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	preempt_disable();
strstr : if : 	preempt_disable(); : 
strstr : for : 	preempt_disable(); : 
strstr : while : 	preempt_disable(); : 
str : 	cpu = task_cpu(p);
strstr : INIT : 	cpu = task_cpu(p); : 
strstr : if : 	cpu = task_cpu(p); : 
strstr : for : 	cpu = task_cpu(p); : 
strstr : while : 	cpu = task_cpu(p); : 
str : 	if ((cpu != smp_processor_id()) && task_curr(p))
strstr : INIT : 	if ((cpu != smp_processor_id()) && task_curr(p)) : 
strstr : if : 	if ((cpu != smp_processor_id()) && task_curr(p)) : 
strstr : for : 	if ((cpu != smp_processor_id()) && task_curr(p)) : 
strstr : while : 	if ((cpu != smp_processor_id()) && task_curr(p)) : 
str : 		smp_send_reschedule(cpu);
strstr : INIT : 		smp_send_reschedule(cpu); : 
strstr : if : 		smp_send_reschedule(cpu); : 
strstr : for : 		smp_send_reschedule(cpu); : 
strstr : while : 		smp_send_reschedule(cpu); : 
str : 	preempt_enable();
strstr : INIT : 	preempt_enable(); : 
strstr : if : 	preempt_enable(); : 
strstr : for : 	preempt_enable(); : 
strstr : while : 	preempt_enable(); : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : EXPORT_SYMBOL_GPL(kick_process);
strstr : INIT : EXPORT_SYMBOL_GPL(kick_process); : 
strstr : if : EXPORT_SYMBOL_GPL(kick_process); : 
strstr : for : EXPORT_SYMBOL_GPL(kick_process); : 
strstr : while : EXPORT_SYMBOL_GPL(kick_process); : 
str : #endif /* CONFIG_SMP */
strstr : INIT : #endif /* CONFIG_SMP */ : 
strstr : if : #endif /* CONFIG_SMP */ : 
strstr : for : #endif /* CONFIG_SMP */ : 
strstr : while : #endif /* CONFIG_SMP */ : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : #ifdef CONFIG_SMP
strstr : if : #ifdef CONFIG_SMP : 
strstr : for : #ifdef CONFIG_SMP : 
strstr : while : #ifdef CONFIG_SMP : 
str : /*
strstr : INIT : /* : 
strstr : if : /* : 
strstr : for : /* : 
strstr : while : /* : 
str :  * ->cpus_allowed is protected by both rq->lock and p->pi_lock
strstr : INIT :  * ->cpus_allowed is protected by both rq->lock and p->pi_lock : 
strstr : if :  * ->cpus_allowed is protected by both rq->lock and p->pi_lock : 
strstr : for :  * ->cpus_allowed is protected by both rq->lock and p->pi_lock : 
strstr : while :  * ->cpus_allowed is protected by both rq->lock and p->pi_lock : 
str :  */
strstr : INIT :  */ : 
strstr : if :  */ : 
strstr : for :  */ : 
strstr : while :  */ : 
str : static int select_fallback_rq(int cpu, struct task_struct *p)
strstr : INIT : static int select_fallback_rq(int cpu, struct task_struct *p) : 
strstr : if : static int select_fallback_rq(int cpu, struct task_struct *p) : 
strstr : for : static int select_fallback_rq(int cpu, struct task_struct *p) : 
strstr : while : static int select_fallback_rq(int cpu, struct task_struct *p) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	int nid = cpu_to_node(cpu);
strstr : INIT : 	int nid = cpu_to_node(cpu); : 
strstr : if : 	int nid = cpu_to_node(cpu); : 
strstr : for : 	int nid = cpu_to_node(cpu); : 
strstr : while : 	int nid = cpu_to_node(cpu); : 
str : 	const struct cpumask *nodemask = NULL;
strstr : INIT : 	const struct cpumask *nodemask = NULL; : 
strstr : if : 	const struct cpumask *nodemask = NULL; : 
strstr : for : 	const struct cpumask *nodemask = NULL; : 
strstr : while : 	const struct cpumask *nodemask = NULL; : 
str : 	enum { cpuset, possible, fail } state = cpuset;
strstr : INIT : 	enum { cpuset, possible, fail } state = cpuset; : 
strstr : if : 	enum { cpuset, possible, fail } state = cpuset; : 
strstr : for : 	enum { cpuset, possible, fail } state = cpuset; : 
strstr : while : 	enum { cpuset, possible, fail } state = cpuset; : 
str : 	int dest_cpu;
strstr : INIT : 	int dest_cpu; : 
strstr : if : 	int dest_cpu; : 
strstr : for : 	int dest_cpu; : 
strstr : while : 	int dest_cpu; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	/*
strstr : if : 	/* : 
strstr : for : 	/* : 
strstr : while : 	/* : 
str : 	 * If the node that the cpu is on has been offlined, cpu_to_node()
strstr : INIT : 	 * If the node that the cpu is on has been offlined, cpu_to_node() : 
strstr : if : 	 * If the node that the cpu is on has been offlined, cpu_to_node() : 
strstr : for : 	 * If the node that the cpu is on has been offlined, cpu_to_node() : 
strstr : while : 	 * If the node that the cpu is on has been offlined, cpu_to_node() : 
str : 	 * will return -1. There is no cpu on the node, and we should
strstr : INIT : 	 * will return -1. There is no cpu on the node, and we should : 
strstr : if : 	 * will return -1. There is no cpu on the node, and we should : 
strstr : for : 	 * will return -1. There is no cpu on the node, and we should : 
strstr : while : 	 * will return -1. There is no cpu on the node, and we should : 
str : 	 * select the cpu on the other node.
strstr : INIT : 	 * select the cpu on the other node. : 
strstr : if : 	 * select the cpu on the other node. : 
strstr : for : 	 * select the cpu on the other node. : 
strstr : while : 	 * select the cpu on the other node. : 
str : 	 */
strstr : INIT : 	 */ : 
strstr : if : 	 */ : 
strstr : for : 	 */ : 
strstr : while : 	 */ : 
str : 	if (nid != -1) {
strstr : INIT : 	if (nid != -1) { : 
strstr : if : 	if (nid != -1) { : 
strstr : for : 	if (nid != -1) { : 
strstr : while : 	if (nid != -1) { : 
str : 		nodemask = cpumask_of_node(nid);
strstr : INIT : 		nodemask = cpumask_of_node(nid); : 
strstr : if : 		nodemask = cpumask_of_node(nid); : 
strstr : for : 		nodemask = cpumask_of_node(nid); : 
strstr : while : 		nodemask = cpumask_of_node(nid); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 		/* Look for allowed, online CPU in same node. */
strstr : if : 		/* Look for allowed, online CPU in same node. */ : 
strstr : for : 		/* Look for allowed, online CPU in same node. */ : 
strstr : while : 		/* Look for allowed, online CPU in same node. */ : 
str : 		for_each_cpu(dest_cpu, nodemask) {
strstr : INIT : 		for_each_cpu(dest_cpu, nodemask) { : 
strstr : if : 		for_each_cpu(dest_cpu, nodemask) { : 
strstr : for : 		for_each_cpu(dest_cpu, nodemask) { : 
strstr : while : 		for_each_cpu(dest_cpu, nodemask) { : 
str : 			if (!cpu_online(dest_cpu))
strstr : INIT : 			if (!cpu_online(dest_cpu)) : 
strstr : if : 			if (!cpu_online(dest_cpu)) : 
strstr : for : 			if (!cpu_online(dest_cpu)) : 
strstr : while : 			if (!cpu_online(dest_cpu)) : 
str : 				continue;
strstr : INIT : 				continue; : 
strstr : if : 				continue; : 
strstr : for : 				continue; : 
strstr : while : 				continue; : 
str : 			if (!cpu_active(dest_cpu))
strstr : INIT : 			if (!cpu_active(dest_cpu)) : 
strstr : if : 			if (!cpu_active(dest_cpu)) : 
strstr : for : 			if (!cpu_active(dest_cpu)) : 
strstr : while : 			if (!cpu_active(dest_cpu)) : 
str : 				continue;
strstr : INIT : 				continue; : 
strstr : if : 				continue; : 
strstr : for : 				continue; : 
strstr : while : 				continue; : 
str : 			if (cpumask_test_cpu(dest_cpu, tsk_cpus_allowed(p)))
strstr : INIT : 			if (cpumask_test_cpu(dest_cpu, tsk_cpus_allowed(p))) : 
strstr : if : 			if (cpumask_test_cpu(dest_cpu, tsk_cpus_allowed(p))) : 
strstr : for : 			if (cpumask_test_cpu(dest_cpu, tsk_cpus_allowed(p))) : 
strstr : while : 			if (cpumask_test_cpu(dest_cpu, tsk_cpus_allowed(p))) : 
str : 				return dest_cpu;
strstr : INIT : 				return dest_cpu; : 
strstr : if : 				return dest_cpu; : 
strstr : for : 				return dest_cpu; : 
strstr : while : 				return dest_cpu; : 
str : 		}
strstr : INIT : 		} : 
strstr : if : 		} : 
strstr : for : 		} : 
strstr : while : 		} : 
str : 	}
strstr : INIT : 	} : 
strstr : if : 	} : 
strstr : for : 	} : 
strstr : while : 	} : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	for (;;) {
strstr : if : 	for (;;) { : 
strstr : for : 	for (;;) { : 
strstr : while : 	for (;;) { : 
str : 		/* Any allowed, online CPU? */
strstr : INIT : 		/* Any allowed, online CPU? */ : 
strstr : if : 		/* Any allowed, online CPU? */ : 
strstr : for : 		/* Any allowed, online CPU? */ : 
strstr : while : 		/* Any allowed, online CPU? */ : 
str : 		for_each_cpu(dest_cpu, tsk_cpus_allowed(p)) {
strstr : INIT : 		for_each_cpu(dest_cpu, tsk_cpus_allowed(p)) { : 
strstr : if : 		for_each_cpu(dest_cpu, tsk_cpus_allowed(p)) { : 
strstr : for : 		for_each_cpu(dest_cpu, tsk_cpus_allowed(p)) { : 
strstr : while : 		for_each_cpu(dest_cpu, tsk_cpus_allowed(p)) { : 
str : 			if (!cpu_online(dest_cpu))
strstr : INIT : 			if (!cpu_online(dest_cpu)) : 
strstr : if : 			if (!cpu_online(dest_cpu)) : 
strstr : for : 			if (!cpu_online(dest_cpu)) : 
strstr : while : 			if (!cpu_online(dest_cpu)) : 
str : 				continue;
strstr : INIT : 				continue; : 
strstr : if : 				continue; : 
strstr : for : 				continue; : 
strstr : while : 				continue; : 
str : 			if (!cpu_active(dest_cpu))
strstr : INIT : 			if (!cpu_active(dest_cpu)) : 
strstr : if : 			if (!cpu_active(dest_cpu)) : 
strstr : for : 			if (!cpu_active(dest_cpu)) : 
strstr : while : 			if (!cpu_active(dest_cpu)) : 
str : 				continue;
strstr : INIT : 				continue; : 
strstr : if : 				continue; : 
strstr : for : 				continue; : 
strstr : while : 				continue; : 
str : 			goto out;
strstr : INIT : 			goto out; : 
strstr : if : 			goto out; : 
strstr : for : 			goto out; : 
strstr : while : 			goto out; : 
str : 		}
strstr : INIT : 		} : 
strstr : if : 		} : 
strstr : for : 		} : 
strstr : while : 		} : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 		switch (state) {
strstr : if : 		switch (state) { : 
strstr : for : 		switch (state) { : 
strstr : while : 		switch (state) { : 
str : 		case cpuset:
strstr : INIT : 		case cpuset: : 
strstr : if : 		case cpuset: : 
strstr : for : 		case cpuset: : 
strstr : while : 		case cpuset: : 
str : 			/* No more Mr. Nice Guy. */
strstr : INIT : 			/* No more Mr. Nice Guy. */ : 
strstr : if : 			/* No more Mr. Nice Guy. */ : 
strstr : for : 			/* No more Mr. Nice Guy. */ : 
strstr : while : 			/* No more Mr. Nice Guy. */ : 
str : 			cpuset_cpus_allowed_fallback(p);
strstr : INIT : 			cpuset_cpus_allowed_fallback(p); : 
strstr : if : 			cpuset_cpus_allowed_fallback(p); : 
strstr : for : 			cpuset_cpus_allowed_fallback(p); : 
strstr : while : 			cpuset_cpus_allowed_fallback(p); : 
str : 			state = possible;
strstr : INIT : 			state = possible; : 
strstr : if : 			state = possible; : 
strstr : for : 			state = possible; : 
strstr : while : 			state = possible; : 
str : 			break;
strstr : INIT : 			break; : 
strstr : if : 			break; : 
strstr : for : 			break; : 
strstr : while : 			break; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 		case possible:
strstr : if : 		case possible: : 
strstr : for : 		case possible: : 
strstr : while : 		case possible: : 
str : 			do_set_cpus_allowed(p, cpu_possible_mask);
strstr : INIT : 			do_set_cpus_allowed(p, cpu_possible_mask); : 
strstr : if : 			do_set_cpus_allowed(p, cpu_possible_mask); : 
strstr : for : 			do_set_cpus_allowed(p, cpu_possible_mask); : 
strstr : while : 			do_set_cpus_allowed(p, cpu_possible_mask); : 
str : 			state = fail;
strstr : INIT : 			state = fail; : 
strstr : if : 			state = fail; : 
strstr : for : 			state = fail; : 
strstr : while : 			state = fail; : 
str : 			break;
strstr : INIT : 			break; : 
strstr : if : 			break; : 
strstr : for : 			break; : 
strstr : while : 			break; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 		case fail:
strstr : if : 		case fail: : 
strstr : for : 		case fail: : 
strstr : while : 		case fail: : 
str : 			BUG();
strstr : INIT : 			BUG(); : 
strstr : if : 			BUG(); : 
strstr : for : 			BUG(); : 
strstr : while : 			BUG(); : 
str : 			break;
strstr : INIT : 			break; : 
strstr : if : 			break; : 
strstr : for : 			break; : 
strstr : while : 			break; : 
str : 		}
strstr : INIT : 		} : 
strstr : if : 		} : 
strstr : for : 		} : 
strstr : while : 		} : 
str : 	}
strstr : INIT : 	} : 
strstr : if : 	} : 
strstr : for : 	} : 
strstr : while : 	} : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : out:
strstr : if : out: : 
strstr : for : out: : 
strstr : while : out: : 
str : 	if (state != cpuset) {
strstr : INIT : 	if (state != cpuset) { : 
strstr : if : 	if (state != cpuset) { : 
strstr : for : 	if (state != cpuset) { : 
strstr : while : 	if (state != cpuset) { : 
str : 		/*
strstr : INIT : 		/* : 
strstr : if : 		/* : 
strstr : for : 		/* : 
strstr : while : 		/* : 
str : 		 * Don't tell them about moving exiting tasks or
strstr : INIT : 		 * Don't tell them about moving exiting tasks or : 
strstr : if : 		 * Don't tell them about moving exiting tasks or : 
strstr : for : 		 * Don't tell them about moving exiting tasks or : 
strstr : while : 		 * Don't tell them about moving exiting tasks or : 
str : 		 * kernel threads (both mm NULL), since they never
strstr : INIT : 		 * kernel threads (both mm NULL), since they never : 
strstr : if : 		 * kernel threads (both mm NULL), since they never : 
strstr : for : 		 * kernel threads (both mm NULL), since they never : 
strstr : while : 		 * kernel threads (both mm NULL), since they never : 
str : 		 * leave kernel.
strstr : INIT : 		 * leave kernel. : 
strstr : if : 		 * leave kernel. : 
strstr : for : 		 * leave kernel. : 
strstr : while : 		 * leave kernel. : 
str : 		 */
strstr : INIT : 		 */ : 
strstr : if : 		 */ : 
strstr : for : 		 */ : 
strstr : while : 		 */ : 
str : 		if (p->mm && printk_ratelimit()) {
strstr : INIT : 		if (p->mm && printk_ratelimit()) { : 
strstr : if : 		if (p->mm && printk_ratelimit()) { : 
strstr : for : 		if (p->mm && printk_ratelimit()) { : 
strstr : while : 		if (p->mm && printk_ratelimit()) { : 
str : 			printk_sched("process %d (%s) no longer affine to cpu%d\n",
strstr : INIT : 			printk_sched("process %d (%s) no longer affine to cpu%d\n", : 
strstr : if : 			printk_sched("process %d (%s) no longer affine to cpu%d\n", : 
strstr : for : 			printk_sched("process %d (%s) no longer affine to cpu%d\n", : 
strstr : while : 			printk_sched("process %d (%s) no longer affine to cpu%d\n", : 
str : 					task_pid_nr(p), p->comm, cpu);
strstr : INIT : 					task_pid_nr(p), p->comm, cpu); : 
strstr : if : 					task_pid_nr(p), p->comm, cpu); : 
strstr : for : 					task_pid_nr(p), p->comm, cpu); : 
strstr : while : 					task_pid_nr(p), p->comm, cpu); : 
str : 		}
strstr : INIT : 		} : 
strstr : if : 		} : 
strstr : for : 		} : 
strstr : while : 		} : 
str : 	}
strstr : INIT : 	} : 
strstr : if : 	} : 
strstr : for : 	} : 
strstr : while : 	} : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	return dest_cpu;
strstr : if : 	return dest_cpu; : 
strstr : for : 	return dest_cpu; : 
strstr : while : 	return dest_cpu; : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : /*
strstr : if : /* : 
strstr : for : /* : 
strstr : while : /* : 
str :  * The caller (fork, wakeup) owns p->pi_lock, ->cpus_allowed is stable.
strstr : INIT :  * The caller (fork, wakeup) owns p->pi_lock, ->cpus_allowed is stable. : 
strstr : if :  * The caller (fork, wakeup) owns p->pi_lock, ->cpus_allowed is stable. : 
strstr : for :  * The caller (fork, wakeup) owns p->pi_lock, ->cpus_allowed is stable. : 
strstr : while :  * The caller (fork, wakeup) owns p->pi_lock, ->cpus_allowed is stable. : 
str :  */
strstr : INIT :  */ : 
strstr : if :  */ : 
strstr : for :  */ : 
strstr : while :  */ : 
str : static inline
strstr : INIT : static inline : 
strstr : if : static inline : 
strstr : for : static inline : 
strstr : while : static inline : 
str : int select_task_rq(struct task_struct *p, int cpu, int sd_flags, int wake_flags)
strstr : INIT : int select_task_rq(struct task_struct *p, int cpu, int sd_flags, int wake_flags) : 
strstr : if : int select_task_rq(struct task_struct *p, int cpu, int sd_flags, int wake_flags) : 
strstr : for : int select_task_rq(struct task_struct *p, int cpu, int sd_flags, int wake_flags) : 
strstr : while : int select_task_rq(struct task_struct *p, int cpu, int sd_flags, int wake_flags) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	cpu = p->sched_class->select_task_rq(p, cpu, sd_flags, wake_flags);
strstr : INIT : 	cpu = p->sched_class->select_task_rq(p, cpu, sd_flags, wake_flags); : 
strstr : if : 	cpu = p->sched_class->select_task_rq(p, cpu, sd_flags, wake_flags); : 
strstr : for : 	cpu = p->sched_class->select_task_rq(p, cpu, sd_flags, wake_flags); : 
strstr : while : 	cpu = p->sched_class->select_task_rq(p, cpu, sd_flags, wake_flags); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	/*
strstr : if : 	/* : 
strstr : for : 	/* : 
strstr : while : 	/* : 
str : 	 * In order not to call set_task_cpu() on a blocking task we need
strstr : INIT : 	 * In order not to call set_task_cpu() on a blocking task we need : 
strstr : if : 	 * In order not to call set_task_cpu() on a blocking task we need : 
strstr : for : 	 * In order not to call set_task_cpu() on a blocking task we need : 
strstr : while : 	 * In order not to call set_task_cpu() on a blocking task we need : 
str : 	 * to rely on ttwu() to place the task on a valid ->cpus_allowed
strstr : INIT : 	 * to rely on ttwu() to place the task on a valid ->cpus_allowed : 
strstr : if : 	 * to rely on ttwu() to place the task on a valid ->cpus_allowed : 
strstr : for : 	 * to rely on ttwu() to place the task on a valid ->cpus_allowed : 
strstr : while : 	 * to rely on ttwu() to place the task on a valid ->cpus_allowed : 
str : 	 * cpu.
strstr : INIT : 	 * cpu. : 
strstr : if : 	 * cpu. : 
strstr : for : 	 * cpu. : 
strstr : while : 	 * cpu. : 
str : 	 *
strstr : INIT : 	 * : 
strstr : if : 	 * : 
strstr : for : 	 * : 
strstr : while : 	 * : 
str : 	 * Since this is common to all placement strategies, this lives here.
strstr : INIT : 	 * Since this is common to all placement strategies, this lives here. : 
strstr : if : 	 * Since this is common to all placement strategies, this lives here. : 
strstr : for : 	 * Since this is common to all placement strategies, this lives here. : 
strstr : while : 	 * Since this is common to all placement strategies, this lives here. : 
str : 	 *
strstr : INIT : 	 * : 
strstr : if : 	 * : 
strstr : for : 	 * : 
strstr : while : 	 * : 
str : 	 * [ this allows ->select_task() to simply return task_cpu(p) and
strstr : INIT : 	 * [ this allows ->select_task() to simply return task_cpu(p) and : 
strstr : if : 	 * [ this allows ->select_task() to simply return task_cpu(p) and : 
strstr : for : 	 * [ this allows ->select_task() to simply return task_cpu(p) and : 
strstr : while : 	 * [ this allows ->select_task() to simply return task_cpu(p) and : 
str : 	 *   not worry about this generic constraint ]
strstr : INIT : 	 *   not worry about this generic constraint ] : 
strstr : if : 	 *   not worry about this generic constraint ] : 
strstr : for : 	 *   not worry about this generic constraint ] : 
strstr : while : 	 *   not worry about this generic constraint ] : 
str : 	 */
strstr : INIT : 	 */ : 
strstr : if : 	 */ : 
strstr : for : 	 */ : 
strstr : while : 	 */ : 
str : 	if (unlikely(!cpumask_test_cpu(cpu, tsk_cpus_allowed(p)) ||
strstr : INIT : 	if (unlikely(!cpumask_test_cpu(cpu, tsk_cpus_allowed(p)) || : 
strstr : if : 	if (unlikely(!cpumask_test_cpu(cpu, tsk_cpus_allowed(p)) || : 
strstr : for : 	if (unlikely(!cpumask_test_cpu(cpu, tsk_cpus_allowed(p)) || : 
strstr : while : 	if (unlikely(!cpumask_test_cpu(cpu, tsk_cpus_allowed(p)) || : 
str : 		     !cpu_online(cpu)))
strstr : INIT : 		     !cpu_online(cpu))) : 
strstr : if : 		     !cpu_online(cpu))) : 
strstr : for : 		     !cpu_online(cpu))) : 
strstr : while : 		     !cpu_online(cpu))) : 
str : 		cpu = select_fallback_rq(task_cpu(p), p);
strstr : INIT : 		cpu = select_fallback_rq(task_cpu(p), p); : 
strstr : if : 		cpu = select_fallback_rq(task_cpu(p), p); : 
strstr : for : 		cpu = select_fallback_rq(task_cpu(p), p); : 
strstr : while : 		cpu = select_fallback_rq(task_cpu(p), p); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	return cpu;
strstr : if : 	return cpu; : 
strstr : for : 	return cpu; : 
strstr : while : 	return cpu; : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : static void update_avg(u64 *avg, u64 sample)
strstr : if : static void update_avg(u64 *avg, u64 sample) : 
strstr : for : static void update_avg(u64 *avg, u64 sample) : 
strstr : while : static void update_avg(u64 *avg, u64 sample) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	s64 diff = sample - *avg;
strstr : INIT : 	s64 diff = sample - *avg; : 
strstr : if : 	s64 diff = sample - *avg; : 
strstr : for : 	s64 diff = sample - *avg; : 
strstr : while : 	s64 diff = sample - *avg; : 
str : 	*avg += diff >> 3;
strstr : INIT : 	*avg += diff >> 3; : 
strstr : if : 	*avg += diff >> 3; : 
strstr : for : 	*avg += diff >> 3; : 
strstr : while : 	*avg += diff >> 3; : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : #endif
strstr : INIT : #endif : 
strstr : if : #endif : 
strstr : for : #endif : 
strstr : while : #endif : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : static void
strstr : if : static void : 
strstr : for : static void : 
strstr : while : static void : 
str : ttwu_stat(struct task_struct *p, int cpu, int wake_flags)
strstr : INIT : ttwu_stat(struct task_struct *p, int cpu, int wake_flags) : 
strstr : if : ttwu_stat(struct task_struct *p, int cpu, int wake_flags) : 
strstr : for : ttwu_stat(struct task_struct *p, int cpu, int wake_flags) : 
strstr : while : ttwu_stat(struct task_struct *p, int cpu, int wake_flags) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : #ifdef CONFIG_SCHEDSTATS
strstr : INIT : #ifdef CONFIG_SCHEDSTATS : 
strstr : if : #ifdef CONFIG_SCHEDSTATS : 
strstr : for : #ifdef CONFIG_SCHEDSTATS : 
strstr : while : #ifdef CONFIG_SCHEDSTATS : 
str : 	struct rq *rq = this_rq();
strstr : INIT : 	struct rq *rq = this_rq(); : 
strstr : if : 	struct rq *rq = this_rq(); : 
strstr : for : 	struct rq *rq = this_rq(); : 
strstr : while : 	struct rq *rq = this_rq(); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : #ifdef CONFIG_SMP
strstr : if : #ifdef CONFIG_SMP : 
strstr : for : #ifdef CONFIG_SMP : 
strstr : while : #ifdef CONFIG_SMP : 
str : 	int this_cpu = smp_processor_id();
strstr : INIT : 	int this_cpu = smp_processor_id(); : 
strstr : if : 	int this_cpu = smp_processor_id(); : 
strstr : for : 	int this_cpu = smp_processor_id(); : 
strstr : while : 	int this_cpu = smp_processor_id(); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	if (cpu == this_cpu) {
strstr : if : 	if (cpu == this_cpu) { : 
strstr : for : 	if (cpu == this_cpu) { : 
strstr : while : 	if (cpu == this_cpu) { : 
str : 		schedstat_inc(rq, ttwu_local);
strstr : INIT : 		schedstat_inc(rq, ttwu_local); : 
strstr : if : 		schedstat_inc(rq, ttwu_local); : 
strstr : for : 		schedstat_inc(rq, ttwu_local); : 
strstr : while : 		schedstat_inc(rq, ttwu_local); : 
str : 		schedstat_inc(p, se.statistics.nr_wakeups_local);
strstr : INIT : 		schedstat_inc(p, se.statistics.nr_wakeups_local); : 
strstr : if : 		schedstat_inc(p, se.statistics.nr_wakeups_local); : 
strstr : for : 		schedstat_inc(p, se.statistics.nr_wakeups_local); : 
strstr : while : 		schedstat_inc(p, se.statistics.nr_wakeups_local); : 
str : 	} else {
strstr : INIT : 	} else { : 
strstr : if : 	} else { : 
strstr : for : 	} else { : 
strstr : while : 	} else { : 
str : 		struct sched_domain *sd;
strstr : INIT : 		struct sched_domain *sd; : 
strstr : if : 		struct sched_domain *sd; : 
strstr : for : 		struct sched_domain *sd; : 
strstr : while : 		struct sched_domain *sd; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 		schedstat_inc(p, se.statistics.nr_wakeups_remote);
strstr : if : 		schedstat_inc(p, se.statistics.nr_wakeups_remote); : 
strstr : for : 		schedstat_inc(p, se.statistics.nr_wakeups_remote); : 
strstr : while : 		schedstat_inc(p, se.statistics.nr_wakeups_remote); : 
str : 		rcu_read_lock();
strstr : INIT : 		rcu_read_lock(); : 
strstr : if : 		rcu_read_lock(); : 
strstr : for : 		rcu_read_lock(); : 
strstr : while : 		rcu_read_lock(); : 
str : 		for_each_domain(this_cpu, sd) {
strstr : INIT : 		for_each_domain(this_cpu, sd) { : 
strstr : if : 		for_each_domain(this_cpu, sd) { : 
strstr : for : 		for_each_domain(this_cpu, sd) { : 
strstr : while : 		for_each_domain(this_cpu, sd) { : 
str : 			if (cpumask_test_cpu(cpu, sched_domain_span(sd))) {
strstr : INIT : 			if (cpumask_test_cpu(cpu, sched_domain_span(sd))) { : 
strstr : if : 			if (cpumask_test_cpu(cpu, sched_domain_span(sd))) { : 
strstr : for : 			if (cpumask_test_cpu(cpu, sched_domain_span(sd))) { : 
strstr : while : 			if (cpumask_test_cpu(cpu, sched_domain_span(sd))) { : 
str : 				schedstat_inc(sd, ttwu_wake_remote);
strstr : INIT : 				schedstat_inc(sd, ttwu_wake_remote); : 
strstr : if : 				schedstat_inc(sd, ttwu_wake_remote); : 
strstr : for : 				schedstat_inc(sd, ttwu_wake_remote); : 
strstr : while : 				schedstat_inc(sd, ttwu_wake_remote); : 
str : 				break;
strstr : INIT : 				break; : 
strstr : if : 				break; : 
strstr : for : 				break; : 
strstr : while : 				break; : 
str : 			}
strstr : INIT : 			} : 
strstr : if : 			} : 
strstr : for : 			} : 
strstr : while : 			} : 
str : 		}
strstr : INIT : 		} : 
strstr : if : 		} : 
strstr : for : 		} : 
strstr : while : 		} : 
str : 		rcu_read_unlock();
strstr : INIT : 		rcu_read_unlock(); : 
strstr : if : 		rcu_read_unlock(); : 
strstr : for : 		rcu_read_unlock(); : 
strstr : while : 		rcu_read_unlock(); : 
str : 	}
strstr : INIT : 	} : 
strstr : if : 	} : 
strstr : for : 	} : 
strstr : while : 	} : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	if (wake_flags & WF_MIGRATED)
strstr : if : 	if (wake_flags & WF_MIGRATED) : 
strstr : for : 	if (wake_flags & WF_MIGRATED) : 
strstr : while : 	if (wake_flags & WF_MIGRATED) : 
str : 		schedstat_inc(p, se.statistics.nr_wakeups_migrate);
strstr : INIT : 		schedstat_inc(p, se.statistics.nr_wakeups_migrate); : 
strstr : if : 		schedstat_inc(p, se.statistics.nr_wakeups_migrate); : 
strstr : for : 		schedstat_inc(p, se.statistics.nr_wakeups_migrate); : 
strstr : while : 		schedstat_inc(p, se.statistics.nr_wakeups_migrate); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : #endif /* CONFIG_SMP */
strstr : if : #endif /* CONFIG_SMP */ : 
strstr : for : #endif /* CONFIG_SMP */ : 
strstr : while : #endif /* CONFIG_SMP */ : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	schedstat_inc(rq, ttwu_count);
strstr : if : 	schedstat_inc(rq, ttwu_count); : 
strstr : for : 	schedstat_inc(rq, ttwu_count); : 
strstr : while : 	schedstat_inc(rq, ttwu_count); : 
str : 	schedstat_inc(p, se.statistics.nr_wakeups);
strstr : INIT : 	schedstat_inc(p, se.statistics.nr_wakeups); : 
strstr : if : 	schedstat_inc(p, se.statistics.nr_wakeups); : 
strstr : for : 	schedstat_inc(p, se.statistics.nr_wakeups); : 
strstr : while : 	schedstat_inc(p, se.statistics.nr_wakeups); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	if (wake_flags & WF_SYNC)
strstr : if : 	if (wake_flags & WF_SYNC) : 
strstr : for : 	if (wake_flags & WF_SYNC) : 
strstr : while : 	if (wake_flags & WF_SYNC) : 
str : 		schedstat_inc(p, se.statistics.nr_wakeups_sync);
strstr : INIT : 		schedstat_inc(p, se.statistics.nr_wakeups_sync); : 
strstr : if : 		schedstat_inc(p, se.statistics.nr_wakeups_sync); : 
strstr : for : 		schedstat_inc(p, se.statistics.nr_wakeups_sync); : 
strstr : while : 		schedstat_inc(p, se.statistics.nr_wakeups_sync); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : #endif /* CONFIG_SCHEDSTATS */
strstr : if : #endif /* CONFIG_SCHEDSTATS */ : 
strstr : for : #endif /* CONFIG_SCHEDSTATS */ : 
strstr : while : #endif /* CONFIG_SCHEDSTATS */ : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : static void ttwu_activate(struct rq *rq, struct task_struct *p, int en_flags)
strstr : if : static void ttwu_activate(struct rq *rq, struct task_struct *p, int en_flags) : 
strstr : for : static void ttwu_activate(struct rq *rq, struct task_struct *p, int en_flags) : 
strstr : while : static void ttwu_activate(struct rq *rq, struct task_struct *p, int en_flags) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	activate_task(rq, p, en_flags);
strstr : INIT : 	activate_task(rq, p, en_flags); : 
strstr : if : 	activate_task(rq, p, en_flags); : 
strstr : for : 	activate_task(rq, p, en_flags); : 
strstr : while : 	activate_task(rq, p, en_flags); : 
str : 	p->on_rq = 1;
strstr : INIT : 	p->on_rq = 1; : 
strstr : if : 	p->on_rq = 1; : 
strstr : for : 	p->on_rq = 1; : 
strstr : while : 	p->on_rq = 1; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	/* if a worker is waking up, notify workqueue */
strstr : if : 	/* if a worker is waking up, notify workqueue */ : 
strstr : for : 	/* if a worker is waking up, notify workqueue */ : 
strstr : while : 	/* if a worker is waking up, notify workqueue */ : 
str : 	if (p->flags & PF_WQ_WORKER)
strstr : INIT : 	if (p->flags & PF_WQ_WORKER) : 
strstr : if : 	if (p->flags & PF_WQ_WORKER) : 
strstr : for : 	if (p->flags & PF_WQ_WORKER) : 
strstr : while : 	if (p->flags & PF_WQ_WORKER) : 
str : 		wq_worker_waking_up(p, cpu_of(rq));
strstr : INIT : 		wq_worker_waking_up(p, cpu_of(rq)); : 
strstr : if : 		wq_worker_waking_up(p, cpu_of(rq)); : 
strstr : for : 		wq_worker_waking_up(p, cpu_of(rq)); : 
strstr : while : 		wq_worker_waking_up(p, cpu_of(rq)); : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : /*
strstr : if : /* : 
strstr : for : /* : 
strstr : while : /* : 
str :  * Mark the task runnable and perform wakeup-preemption.
strstr : INIT :  * Mark the task runnable and perform wakeup-preemption. : 
strstr : if :  * Mark the task runnable and perform wakeup-preemption. : 
strstr : for :  * Mark the task runnable and perform wakeup-preemption. : 
strstr : while :  * Mark the task runnable and perform wakeup-preemption. : 
str :  */
strstr : INIT :  */ : 
strstr : if :  */ : 
strstr : for :  */ : 
strstr : while :  */ : 
str : static void
strstr : INIT : static void : 
strstr : if : static void : 
strstr : for : static void : 
strstr : while : static void : 
str : ttwu_do_wakeup(struct rq *rq, struct task_struct *p, int wake_flags)
strstr : INIT : ttwu_do_wakeup(struct rq *rq, struct task_struct *p, int wake_flags) : 
strstr : if : ttwu_do_wakeup(struct rq *rq, struct task_struct *p, int wake_flags) : 
strstr : for : ttwu_do_wakeup(struct rq *rq, struct task_struct *p, int wake_flags) : 
strstr : while : ttwu_do_wakeup(struct rq *rq, struct task_struct *p, int wake_flags) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	check_preempt_curr(rq, p, wake_flags);
strstr : INIT : 	check_preempt_curr(rq, p, wake_flags); : 
strstr : if : 	check_preempt_curr(rq, p, wake_flags); : 
strstr : for : 	check_preempt_curr(rq, p, wake_flags); : 
strstr : while : 	check_preempt_curr(rq, p, wake_flags); : 
str : 	trace_sched_wakeup(p, true);
strstr : INIT : 	trace_sched_wakeup(p, true); : 
strstr : if : 	trace_sched_wakeup(p, true); : 
strstr : for : 	trace_sched_wakeup(p, true); : 
strstr : while : 	trace_sched_wakeup(p, true); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	p->state = TASK_RUNNING;
strstr : if : 	p->state = TASK_RUNNING; : 
strstr : for : 	p->state = TASK_RUNNING; : 
strstr : while : 	p->state = TASK_RUNNING; : 
str : #ifdef CONFIG_SMP
strstr : INIT : #ifdef CONFIG_SMP : 
strstr : if : #ifdef CONFIG_SMP : 
strstr : for : #ifdef CONFIG_SMP : 
strstr : while : #ifdef CONFIG_SMP : 
str : 	if (p->sched_class->task_woken)
strstr : INIT : 	if (p->sched_class->task_woken) : 
strstr : if : 	if (p->sched_class->task_woken) : 
strstr : for : 	if (p->sched_class->task_woken) : 
strstr : while : 	if (p->sched_class->task_woken) : 
str : 		p->sched_class->task_woken(rq, p);
strstr : INIT : 		p->sched_class->task_woken(rq, p); : 
strstr : if : 		p->sched_class->task_woken(rq, p); : 
strstr : for : 		p->sched_class->task_woken(rq, p); : 
strstr : while : 		p->sched_class->task_woken(rq, p); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	if (rq->idle_stamp) {
strstr : if : 	if (rq->idle_stamp) { : 
strstr : for : 	if (rq->idle_stamp) { : 
strstr : while : 	if (rq->idle_stamp) { : 
str : 		u64 delta = rq_clock(rq) - rq->idle_stamp;
strstr : INIT : 		u64 delta = rq_clock(rq) - rq->idle_stamp; : 
strstr : if : 		u64 delta = rq_clock(rq) - rq->idle_stamp; : 
strstr : for : 		u64 delta = rq_clock(rq) - rq->idle_stamp; : 
strstr : while : 		u64 delta = rq_clock(rq) - rq->idle_stamp; : 
str : 		u64 max = 2*rq->max_idle_balance_cost;
strstr : INIT : 		u64 max = 2*rq->max_idle_balance_cost; : 
strstr : if : 		u64 max = 2*rq->max_idle_balance_cost; : 
strstr : for : 		u64 max = 2*rq->max_idle_balance_cost; : 
strstr : while : 		u64 max = 2*rq->max_idle_balance_cost; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 		update_avg(&rq->avg_idle, delta);
strstr : if : 		update_avg(&rq->avg_idle, delta); : 
strstr : for : 		update_avg(&rq->avg_idle, delta); : 
strstr : while : 		update_avg(&rq->avg_idle, delta); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 		if (rq->avg_idle > max)
strstr : if : 		if (rq->avg_idle > max) : 
strstr : for : 		if (rq->avg_idle > max) : 
strstr : while : 		if (rq->avg_idle > max) : 
str : 			rq->avg_idle = max;
strstr : INIT : 			rq->avg_idle = max; : 
strstr : if : 			rq->avg_idle = max; : 
strstr : for : 			rq->avg_idle = max; : 
strstr : while : 			rq->avg_idle = max; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 		rq->idle_stamp = 0;
strstr : if : 		rq->idle_stamp = 0; : 
strstr : for : 		rq->idle_stamp = 0; : 
strstr : while : 		rq->idle_stamp = 0; : 
str : 	}
strstr : INIT : 	} : 
strstr : if : 	} : 
strstr : for : 	} : 
strstr : while : 	} : 
str : #endif
strstr : INIT : #endif : 
strstr : if : #endif : 
strstr : for : #endif : 
strstr : while : #endif : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : static void
strstr : if : static void : 
strstr : for : static void : 
strstr : while : static void : 
str : ttwu_do_activate(struct rq *rq, struct task_struct *p, int wake_flags)
strstr : INIT : ttwu_do_activate(struct rq *rq, struct task_struct *p, int wake_flags) : 
strstr : if : ttwu_do_activate(struct rq *rq, struct task_struct *p, int wake_flags) : 
strstr : for : ttwu_do_activate(struct rq *rq, struct task_struct *p, int wake_flags) : 
strstr : while : ttwu_do_activate(struct rq *rq, struct task_struct *p, int wake_flags) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : #ifdef CONFIG_SMP
strstr : INIT : #ifdef CONFIG_SMP : 
strstr : if : #ifdef CONFIG_SMP : 
strstr : for : #ifdef CONFIG_SMP : 
strstr : while : #ifdef CONFIG_SMP : 
str : 	if (p->sched_contributes_to_load)
strstr : INIT : 	if (p->sched_contributes_to_load) : 
strstr : if : 	if (p->sched_contributes_to_load) : 
strstr : for : 	if (p->sched_contributes_to_load) : 
strstr : while : 	if (p->sched_contributes_to_load) : 
str : 		rq->nr_uninterruptible--;
strstr : INIT : 		rq->nr_uninterruptible--; : 
strstr : if : 		rq->nr_uninterruptible--; : 
strstr : for : 		rq->nr_uninterruptible--; : 
strstr : while : 		rq->nr_uninterruptible--; : 
str : #endif
strstr : INIT : #endif : 
strstr : if : #endif : 
strstr : for : #endif : 
strstr : while : #endif : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	ttwu_activate(rq, p, ENQUEUE_WAKEUP | ENQUEUE_WAKING);
strstr : if : 	ttwu_activate(rq, p, ENQUEUE_WAKEUP | ENQUEUE_WAKING); : 
strstr : for : 	ttwu_activate(rq, p, ENQUEUE_WAKEUP | ENQUEUE_WAKING); : 
strstr : while : 	ttwu_activate(rq, p, ENQUEUE_WAKEUP | ENQUEUE_WAKING); : 
str : 	ttwu_do_wakeup(rq, p, wake_flags);
strstr : INIT : 	ttwu_do_wakeup(rq, p, wake_flags); : 
strstr : if : 	ttwu_do_wakeup(rq, p, wake_flags); : 
strstr : for : 	ttwu_do_wakeup(rq, p, wake_flags); : 
strstr : while : 	ttwu_do_wakeup(rq, p, wake_flags); : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : /*
strstr : if : /* : 
strstr : for : /* : 
strstr : while : /* : 
str :  * Called in case the task @p isn't fully descheduled from its runqueue,
strstr : INIT :  * Called in case the task @p isn't fully descheduled from its runqueue, : 
strstr : if :  * Called in case the task @p isn't fully descheduled from its runqueue, : 
strstr : for :  * Called in case the task @p isn't fully descheduled from its runqueue, : 
strstr : while :  * Called in case the task @p isn't fully descheduled from its runqueue, : 
str :  * in this case we must do a remote wakeup. Its a 'light' wakeup though,
strstr : INIT :  * in this case we must do a remote wakeup. Its a 'light' wakeup though, : 
strstr : if :  * in this case we must do a remote wakeup. Its a 'light' wakeup though, : 
strstr : for :  * in this case we must do a remote wakeup. Its a 'light' wakeup though, : 
strstr : while :  * in this case we must do a remote wakeup. Its a 'light' wakeup though, : 
str :  * since all we need to do is flip p->state to TASK_RUNNING, since
strstr : INIT :  * since all we need to do is flip p->state to TASK_RUNNING, since : 
strstr : if :  * since all we need to do is flip p->state to TASK_RUNNING, since : 
strstr : for :  * since all we need to do is flip p->state to TASK_RUNNING, since : 
strstr : while :  * since all we need to do is flip p->state to TASK_RUNNING, since : 
str :  * the task is still ->on_rq.
strstr : INIT :  * the task is still ->on_rq. : 
strstr : if :  * the task is still ->on_rq. : 
strstr : for :  * the task is still ->on_rq. : 
strstr : while :  * the task is still ->on_rq. : 
str :  */
strstr : INIT :  */ : 
strstr : if :  */ : 
strstr : for :  */ : 
strstr : while :  */ : 
str : static int ttwu_remote(struct task_struct *p, int wake_flags)
strstr : INIT : static int ttwu_remote(struct task_struct *p, int wake_flags) : 
strstr : if : static int ttwu_remote(struct task_struct *p, int wake_flags) : 
strstr : for : static int ttwu_remote(struct task_struct *p, int wake_flags) : 
strstr : while : static int ttwu_remote(struct task_struct *p, int wake_flags) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	struct rq *rq;
strstr : INIT : 	struct rq *rq; : 
strstr : if : 	struct rq *rq; : 
strstr : for : 	struct rq *rq; : 
strstr : while : 	struct rq *rq; : 
str : 	int ret = 0;
strstr : INIT : 	int ret = 0; : 
strstr : if : 	int ret = 0; : 
strstr : for : 	int ret = 0; : 
strstr : while : 	int ret = 0; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	rq = __task_rq_lock(p);
strstr : if : 	rq = __task_rq_lock(p); : 
strstr : for : 	rq = __task_rq_lock(p); : 
strstr : while : 	rq = __task_rq_lock(p); : 
str : 	if (p->on_rq) {
strstr : INIT : 	if (p->on_rq) { : 
strstr : if : 	if (p->on_rq) { : 
strstr : for : 	if (p->on_rq) { : 
strstr : while : 	if (p->on_rq) { : 
str : 		/* check_preempt_curr() may use rq clock */
strstr : INIT : 		/* check_preempt_curr() may use rq clock */ : 
strstr : if : 		/* check_preempt_curr() may use rq clock */ : 
strstr : for : 		/* check_preempt_curr() may use rq clock */ : 
strstr : while : 		/* check_preempt_curr() may use rq clock */ : 
str : 		update_rq_clock(rq);
strstr : INIT : 		update_rq_clock(rq); : 
strstr : if : 		update_rq_clock(rq); : 
strstr : for : 		update_rq_clock(rq); : 
strstr : while : 		update_rq_clock(rq); : 
str : 		ttwu_do_wakeup(rq, p, wake_flags);
strstr : INIT : 		ttwu_do_wakeup(rq, p, wake_flags); : 
strstr : if : 		ttwu_do_wakeup(rq, p, wake_flags); : 
strstr : for : 		ttwu_do_wakeup(rq, p, wake_flags); : 
strstr : while : 		ttwu_do_wakeup(rq, p, wake_flags); : 
str : 		ret = 1;
strstr : INIT : 		ret = 1; : 
strstr : if : 		ret = 1; : 
strstr : for : 		ret = 1; : 
strstr : while : 		ret = 1; : 
str : 	}
strstr : INIT : 	} : 
strstr : if : 	} : 
strstr : for : 	} : 
strstr : while : 	} : 
str : 	__task_rq_unlock(rq);
strstr : INIT : 	__task_rq_unlock(rq); : 
strstr : if : 	__task_rq_unlock(rq); : 
strstr : for : 	__task_rq_unlock(rq); : 
strstr : while : 	__task_rq_unlock(rq); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	return ret;
strstr : if : 	return ret; : 
strstr : for : 	return ret; : 
strstr : while : 	return ret; : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : #ifdef CONFIG_SMP
strstr : if : #ifdef CONFIG_SMP : 
strstr : for : #ifdef CONFIG_SMP : 
strstr : while : #ifdef CONFIG_SMP : 
str : static void sched_ttwu_pending(void)
strstr : INIT : static void sched_ttwu_pending(void) : 
strstr : if : static void sched_ttwu_pending(void) : 
strstr : for : static void sched_ttwu_pending(void) : 
strstr : while : static void sched_ttwu_pending(void) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	struct rq *rq = this_rq();
strstr : INIT : 	struct rq *rq = this_rq(); : 
strstr : if : 	struct rq *rq = this_rq(); : 
strstr : for : 	struct rq *rq = this_rq(); : 
strstr : while : 	struct rq *rq = this_rq(); : 
str : 	struct llist_node *llist = llist_del_all(&rq->wake_list);
strstr : INIT : 	struct llist_node *llist = llist_del_all(&rq->wake_list); : 
strstr : if : 	struct llist_node *llist = llist_del_all(&rq->wake_list); : 
strstr : for : 	struct llist_node *llist = llist_del_all(&rq->wake_list); : 
strstr : while : 	struct llist_node *llist = llist_del_all(&rq->wake_list); : 
str : 	struct task_struct *p;
strstr : INIT : 	struct task_struct *p; : 
strstr : if : 	struct task_struct *p; : 
strstr : for : 	struct task_struct *p; : 
strstr : while : 	struct task_struct *p; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	raw_spin_lock(&rq->lock);
strstr : if : 	raw_spin_lock(&rq->lock); : 
strstr : for : 	raw_spin_lock(&rq->lock); : 
strstr : while : 	raw_spin_lock(&rq->lock); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	while (llist) {
strstr : if : 	while (llist) { : 
strstr : for : 	while (llist) { : 
strstr : while : 	while (llist) { : 
str : 		p = llist_entry(llist, struct task_struct, wake_entry);
strstr : INIT : 		p = llist_entry(llist, struct task_struct, wake_entry); : 
strstr : if : 		p = llist_entry(llist, struct task_struct, wake_entry); : 
strstr : for : 		p = llist_entry(llist, struct task_struct, wake_entry); : 
strstr : while : 		p = llist_entry(llist, struct task_struct, wake_entry); : 
str : 		llist = llist_next(llist);
strstr : INIT : 		llist = llist_next(llist); : 
strstr : if : 		llist = llist_next(llist); : 
strstr : for : 		llist = llist_next(llist); : 
strstr : while : 		llist = llist_next(llist); : 
str : 		ttwu_do_activate(rq, p, 0);
strstr : INIT : 		ttwu_do_activate(rq, p, 0); : 
strstr : if : 		ttwu_do_activate(rq, p, 0); : 
strstr : for : 		ttwu_do_activate(rq, p, 0); : 
strstr : while : 		ttwu_do_activate(rq, p, 0); : 
str : 	}
strstr : INIT : 	} : 
strstr : if : 	} : 
strstr : for : 	} : 
strstr : while : 	} : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	raw_spin_unlock(&rq->lock);
strstr : if : 	raw_spin_unlock(&rq->lock); : 
strstr : for : 	raw_spin_unlock(&rq->lock); : 
strstr : while : 	raw_spin_unlock(&rq->lock); : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : void scheduler_ipi(void)
strstr : if : void scheduler_ipi(void) : 
strstr : for : void scheduler_ipi(void) : 
strstr : while : void scheduler_ipi(void) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	/*
strstr : INIT : 	/* : 
strstr : if : 	/* : 
strstr : for : 	/* : 
strstr : while : 	/* : 
str : 	 * Fold TIF_NEED_RESCHED into the preempt_count; anybody setting
strstr : INIT : 	 * Fold TIF_NEED_RESCHED into the preempt_count; anybody setting : 
strstr : if : 	 * Fold TIF_NEED_RESCHED into the preempt_count; anybody setting : 
strstr : for : 	 * Fold TIF_NEED_RESCHED into the preempt_count; anybody setting : 
strstr : while : 	 * Fold TIF_NEED_RESCHED into the preempt_count; anybody setting : 
str : 	 * TIF_NEED_RESCHED remotely (for the first time) will also send
strstr : INIT : 	 * TIF_NEED_RESCHED remotely (for the first time) will also send : 
strstr : if : 	 * TIF_NEED_RESCHED remotely (for the first time) will also send : 
strstr : for : 	 * TIF_NEED_RESCHED remotely (for the first time) will also send : 
strstr : while : 	 * TIF_NEED_RESCHED remotely (for the first time) will also send : 
str : 	 * this IPI.
strstr : INIT : 	 * this IPI. : 
strstr : if : 	 * this IPI. : 
strstr : for : 	 * this IPI. : 
strstr : while : 	 * this IPI. : 
str : 	 */
strstr : INIT : 	 */ : 
strstr : if : 	 */ : 
strstr : for : 	 */ : 
strstr : while : 	 */ : 
str : 	preempt_fold_need_resched();
strstr : INIT : 	preempt_fold_need_resched(); : 
strstr : if : 	preempt_fold_need_resched(); : 
strstr : for : 	preempt_fold_need_resched(); : 
strstr : while : 	preempt_fold_need_resched(); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	if (llist_empty(&this_rq()->wake_list)
strstr : if : 	if (llist_empty(&this_rq()->wake_list) : 
strstr : for : 	if (llist_empty(&this_rq()->wake_list) : 
strstr : while : 	if (llist_empty(&this_rq()->wake_list) : 
str : 			&& !tick_nohz_full_cpu(smp_processor_id())
strstr : INIT : 			&& !tick_nohz_full_cpu(smp_processor_id()) : 
strstr : if : 			&& !tick_nohz_full_cpu(smp_processor_id()) : 
strstr : for : 			&& !tick_nohz_full_cpu(smp_processor_id()) : 
strstr : while : 			&& !tick_nohz_full_cpu(smp_processor_id()) : 
str : 			&& !got_nohz_idle_kick())
strstr : INIT : 			&& !got_nohz_idle_kick()) : 
strstr : if : 			&& !got_nohz_idle_kick()) : 
strstr : for : 			&& !got_nohz_idle_kick()) : 
strstr : while : 			&& !got_nohz_idle_kick()) : 
str : 		return;
strstr : INIT : 		return; : 
strstr : if : 		return; : 
strstr : for : 		return; : 
strstr : while : 		return; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	/*
strstr : if : 	/* : 
strstr : for : 	/* : 
strstr : while : 	/* : 
str : 	 * Not all reschedule IPI handlers call irq_enter/irq_exit, since
strstr : INIT : 	 * Not all reschedule IPI handlers call irq_enter/irq_exit, since : 
strstr : if : 	 * Not all reschedule IPI handlers call irq_enter/irq_exit, since : 
strstr : for : 	 * Not all reschedule IPI handlers call irq_enter/irq_exit, since : 
strstr : while : 	 * Not all reschedule IPI handlers call irq_enter/irq_exit, since : 
str : 	 * traditionally all their work was done from the interrupt return
strstr : INIT : 	 * traditionally all their work was done from the interrupt return : 
strstr : if : 	 * traditionally all their work was done from the interrupt return : 
strstr : for : 	 * traditionally all their work was done from the interrupt return : 
strstr : while : 	 * traditionally all their work was done from the interrupt return : 
str : 	 * path. Now that we actually do some work, we need to make sure
strstr : INIT : 	 * path. Now that we actually do some work, we need to make sure : 
strstr : if : 	 * path. Now that we actually do some work, we need to make sure : 
strstr : for : 	 * path. Now that we actually do some work, we need to make sure : 
strstr : while : 	 * path. Now that we actually do some work, we need to make sure : 
str : 	 * we do call them.
strstr : INIT : 	 * we do call them. : 
strstr : if : 	 * we do call them. : 
strstr : for : 	 * we do call them. : 
strstr : while : 	 * we do call them. : 
str : 	 *
strstr : INIT : 	 * : 
strstr : if : 	 * : 
strstr : for : 	 * : 
strstr : while : 	 * : 
str : 	 * Some archs already do call them, luckily irq_enter/exit nest
strstr : INIT : 	 * Some archs already do call them, luckily irq_enter/exit nest : 
strstr : if : 	 * Some archs already do call them, luckily irq_enter/exit nest : 
strstr : for : 	 * Some archs already do call them, luckily irq_enter/exit nest : 
strstr : while : 	 * Some archs already do call them, luckily irq_enter/exit nest : 
str : 	 * properly.
strstr : INIT : 	 * properly. : 
strstr : if : 	 * properly. : 
strstr : for : 	 * properly. : 
strstr : while : 	 * properly. : 
str : 	 *
strstr : INIT : 	 * : 
strstr : if : 	 * : 
strstr : for : 	 * : 
strstr : while : 	 * : 
str : 	 * Arguably we should visit all archs and update all handlers,
strstr : INIT : 	 * Arguably we should visit all archs and update all handlers, : 
strstr : if : 	 * Arguably we should visit all archs and update all handlers, : 
strstr : for : 	 * Arguably we should visit all archs and update all handlers, : 
strstr : while : 	 * Arguably we should visit all archs and update all handlers, : 
str : 	 * however a fair share of IPIs are still resched only so this would
strstr : INIT : 	 * however a fair share of IPIs are still resched only so this would : 
strstr : if : 	 * however a fair share of IPIs are still resched only so this would : 
strstr : for : 	 * however a fair share of IPIs are still resched only so this would : 
strstr : while : 	 * however a fair share of IPIs are still resched only so this would : 
str : 	 * somewhat pessimize the simple resched case.
strstr : INIT : 	 * somewhat pessimize the simple resched case. : 
strstr : if : 	 * somewhat pessimize the simple resched case. : 
strstr : for : 	 * somewhat pessimize the simple resched case. : 
strstr : while : 	 * somewhat pessimize the simple resched case. : 
str : 	 */
strstr : INIT : 	 */ : 
strstr : if : 	 */ : 
strstr : for : 	 */ : 
strstr : while : 	 */ : 
str : 	irq_enter();
strstr : INIT : 	irq_enter(); : 
strstr : if : 	irq_enter(); : 
strstr : for : 	irq_enter(); : 
strstr : while : 	irq_enter(); : 
str : 	tick_nohz_full_check();
strstr : INIT : 	tick_nohz_full_check(); : 
strstr : if : 	tick_nohz_full_check(); : 
strstr : for : 	tick_nohz_full_check(); : 
strstr : while : 	tick_nohz_full_check(); : 
str : 	sched_ttwu_pending();
strstr : INIT : 	sched_ttwu_pending(); : 
strstr : if : 	sched_ttwu_pending(); : 
strstr : for : 	sched_ttwu_pending(); : 
strstr : while : 	sched_ttwu_pending(); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	/*
strstr : if : 	/* : 
strstr : for : 	/* : 
strstr : while : 	/* : 
str : 	 * Check if someone kicked us for doing the nohz idle load balance.
strstr : INIT : 	 * Check if someone kicked us for doing the nohz idle load balance. : 
strstr : if : 	 * Check if someone kicked us for doing the nohz idle load balance. : 
strstr : for : 	 * Check if someone kicked us for doing the nohz idle load balance. : 
strstr : while : 	 * Check if someone kicked us for doing the nohz idle load balance. : 
str : 	 */
strstr : INIT : 	 */ : 
strstr : if : 	 */ : 
strstr : for : 	 */ : 
strstr : while : 	 */ : 
str : 	if (unlikely(got_nohz_idle_kick())) {
strstr : INIT : 	if (unlikely(got_nohz_idle_kick())) { : 
strstr : if : 	if (unlikely(got_nohz_idle_kick())) { : 
strstr : for : 	if (unlikely(got_nohz_idle_kick())) { : 
strstr : while : 	if (unlikely(got_nohz_idle_kick())) { : 
str : 		this_rq()->idle_balance = 1;
strstr : INIT : 		this_rq()->idle_balance = 1; : 
strstr : if : 		this_rq()->idle_balance = 1; : 
strstr : for : 		this_rq()->idle_balance = 1; : 
strstr : while : 		this_rq()->idle_balance = 1; : 
str : 		raise_softirq_irqoff(SCHED_SOFTIRQ);
strstr : INIT : 		raise_softirq_irqoff(SCHED_SOFTIRQ); : 
strstr : if : 		raise_softirq_irqoff(SCHED_SOFTIRQ); : 
strstr : for : 		raise_softirq_irqoff(SCHED_SOFTIRQ); : 
strstr : while : 		raise_softirq_irqoff(SCHED_SOFTIRQ); : 
str : 	}
strstr : INIT : 	} : 
strstr : if : 	} : 
strstr : for : 	} : 
strstr : while : 	} : 
str : 	irq_exit();
strstr : INIT : 	irq_exit(); : 
strstr : if : 	irq_exit(); : 
strstr : for : 	irq_exit(); : 
strstr : while : 	irq_exit(); : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : static void ttwu_queue_remote(struct task_struct *p, int cpu)
strstr : if : static void ttwu_queue_remote(struct task_struct *p, int cpu) : 
strstr : for : static void ttwu_queue_remote(struct task_struct *p, int cpu) : 
strstr : while : static void ttwu_queue_remote(struct task_struct *p, int cpu) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	if (llist_add(&p->wake_entry, &cpu_rq(cpu)->wake_list))
strstr : INIT : 	if (llist_add(&p->wake_entry, &cpu_rq(cpu)->wake_list)) : 
strstr : if : 	if (llist_add(&p->wake_entry, &cpu_rq(cpu)->wake_list)) : 
strstr : for : 	if (llist_add(&p->wake_entry, &cpu_rq(cpu)->wake_list)) : 
strstr : while : 	if (llist_add(&p->wake_entry, &cpu_rq(cpu)->wake_list)) : 
str : 		smp_send_reschedule(cpu);
strstr : INIT : 		smp_send_reschedule(cpu); : 
strstr : if : 		smp_send_reschedule(cpu); : 
strstr : for : 		smp_send_reschedule(cpu); : 
strstr : while : 		smp_send_reschedule(cpu); : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : bool cpus_share_cache(int this_cpu, int that_cpu)
strstr : if : bool cpus_share_cache(int this_cpu, int that_cpu) : 
strstr : for : bool cpus_share_cache(int this_cpu, int that_cpu) : 
strstr : while : bool cpus_share_cache(int this_cpu, int that_cpu) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	return per_cpu(sd_llc_id, this_cpu) == per_cpu(sd_llc_id, that_cpu);
strstr : INIT : 	return per_cpu(sd_llc_id, this_cpu) == per_cpu(sd_llc_id, that_cpu); : 
strstr : if : 	return per_cpu(sd_llc_id, this_cpu) == per_cpu(sd_llc_id, that_cpu); : 
strstr : for : 	return per_cpu(sd_llc_id, this_cpu) == per_cpu(sd_llc_id, that_cpu); : 
strstr : while : 	return per_cpu(sd_llc_id, this_cpu) == per_cpu(sd_llc_id, that_cpu); : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : #endif /* CONFIG_SMP */
strstr : INIT : #endif /* CONFIG_SMP */ : 
strstr : if : #endif /* CONFIG_SMP */ : 
strstr : for : #endif /* CONFIG_SMP */ : 
strstr : while : #endif /* CONFIG_SMP */ : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : static void ttwu_queue(struct task_struct *p, int cpu)
strstr : if : static void ttwu_queue(struct task_struct *p, int cpu) : 
strstr : for : static void ttwu_queue(struct task_struct *p, int cpu) : 
strstr : while : static void ttwu_queue(struct task_struct *p, int cpu) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	struct rq *rq = cpu_rq(cpu);
strstr : INIT : 	struct rq *rq = cpu_rq(cpu); : 
strstr : if : 	struct rq *rq = cpu_rq(cpu); : 
strstr : for : 	struct rq *rq = cpu_rq(cpu); : 
strstr : while : 	struct rq *rq = cpu_rq(cpu); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : #if defined(CONFIG_SMP)
strstr : if : #if defined(CONFIG_SMP) : 
strstr : for : #if defined(CONFIG_SMP) : 
strstr : while : #if defined(CONFIG_SMP) : 
str : 	if (sched_feat(TTWU_QUEUE) && !cpus_share_cache(smp_processor_id(), cpu)) {
strstr : INIT : 	if (sched_feat(TTWU_QUEUE) && !cpus_share_cache(smp_processor_id(), cpu)) { : 
strstr : if : 	if (sched_feat(TTWU_QUEUE) && !cpus_share_cache(smp_processor_id(), cpu)) { : 
strstr : for : 	if (sched_feat(TTWU_QUEUE) && !cpus_share_cache(smp_processor_id(), cpu)) { : 
strstr : while : 	if (sched_feat(TTWU_QUEUE) && !cpus_share_cache(smp_processor_id(), cpu)) { : 
str : 		sched_clock_cpu(cpu); /* sync clocks x-cpu */
strstr : INIT : 		sched_clock_cpu(cpu); /* sync clocks x-cpu */ : 
strstr : if : 		sched_clock_cpu(cpu); /* sync clocks x-cpu */ : 
strstr : for : 		sched_clock_cpu(cpu); /* sync clocks x-cpu */ : 
strstr : while : 		sched_clock_cpu(cpu); /* sync clocks x-cpu */ : 
str : 		ttwu_queue_remote(p, cpu);
strstr : INIT : 		ttwu_queue_remote(p, cpu); : 
strstr : if : 		ttwu_queue_remote(p, cpu); : 
strstr : for : 		ttwu_queue_remote(p, cpu); : 
strstr : while : 		ttwu_queue_remote(p, cpu); : 
str : 		return;
strstr : INIT : 		return; : 
strstr : if : 		return; : 
strstr : for : 		return; : 
strstr : while : 		return; : 
str : 	}
strstr : INIT : 	} : 
strstr : if : 	} : 
strstr : for : 	} : 
strstr : while : 	} : 
str : #endif
strstr : INIT : #endif : 
strstr : if : #endif : 
strstr : for : #endif : 
strstr : while : #endif : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	raw_spin_lock(&rq->lock);
strstr : if : 	raw_spin_lock(&rq->lock); : 
strstr : for : 	raw_spin_lock(&rq->lock); : 
strstr : while : 	raw_spin_lock(&rq->lock); : 
str : 	ttwu_do_activate(rq, p, 0);
strstr : INIT : 	ttwu_do_activate(rq, p, 0); : 
strstr : if : 	ttwu_do_activate(rq, p, 0); : 
strstr : for : 	ttwu_do_activate(rq, p, 0); : 
strstr : while : 	ttwu_do_activate(rq, p, 0); : 
str : 	raw_spin_unlock(&rq->lock);
strstr : INIT : 	raw_spin_unlock(&rq->lock); : 
strstr : if : 	raw_spin_unlock(&rq->lock); : 
strstr : for : 	raw_spin_unlock(&rq->lock); : 
strstr : while : 	raw_spin_unlock(&rq->lock); : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : /**
strstr : if : /** : 
strstr : for : /** : 
strstr : while : /** : 
str :  * try_to_wake_up - wake up a thread
strstr : INIT :  * try_to_wake_up - wake up a thread : 
strstr : if :  * try_to_wake_up - wake up a thread : 
strstr : for :  * try_to_wake_up - wake up a thread : 
strstr : while :  * try_to_wake_up - wake up a thread : 
str :  * @p: the thread to be awakened
strstr : INIT :  * @p: the thread to be awakened : 
strstr : if :  * @p: the thread to be awakened : 
strstr : for :  * @p: the thread to be awakened : 
strstr : while :  * @p: the thread to be awakened : 
str :  * @state: the mask of task states that can be woken
strstr : INIT :  * @state: the mask of task states that can be woken : 
strstr : if :  * @state: the mask of task states that can be woken : 
strstr : for :  * @state: the mask of task states that can be woken : 
strstr : while :  * @state: the mask of task states that can be woken : 
str :  * @wake_flags: wake modifier flags (WF_*)
strstr : INIT :  * @wake_flags: wake modifier flags (WF_*) : 
strstr : if :  * @wake_flags: wake modifier flags (WF_*) : 
strstr : for :  * @wake_flags: wake modifier flags (WF_*) : 
strstr : while :  * @wake_flags: wake modifier flags (WF_*) : 
str :  *
strstr : INIT :  * : 
strstr : if :  * : 
strstr : for :  * : 
strstr : while :  * : 
str :  * Put it on the run-queue if it's not already there. The "current"
strstr : INIT :  * Put it on the run-queue if it's not already there. The "current" : 
strstr : if :  * Put it on the run-queue if it's not already there. The "current" : 
strstr : for :  * Put it on the run-queue if it's not already there. The "current" : 
strstr : while :  * Put it on the run-queue if it's not already there. The "current" : 
str :  * thread is always on the run-queue (except when the actual
strstr : INIT :  * thread is always on the run-queue (except when the actual : 
strstr : if :  * thread is always on the run-queue (except when the actual : 
strstr : for :  * thread is always on the run-queue (except when the actual : 
strstr : while :  * thread is always on the run-queue (except when the actual : 
str :  * re-schedule is in progress), and as such you're allowed to do
strstr : INIT :  * re-schedule is in progress), and as such you're allowed to do : 
strstr : if :  * re-schedule is in progress), and as such you're allowed to do : 
strstr : for :  * re-schedule is in progress), and as such you're allowed to do : 
strstr : while :  * re-schedule is in progress), and as such you're allowed to do : 
str :  * the simpler "current->state = TASK_RUNNING" to mark yourself
strstr : INIT :  * the simpler "current->state = TASK_RUNNING" to mark yourself : 
strstr : if :  * the simpler "current->state = TASK_RUNNING" to mark yourself : 
strstr : for :  * the simpler "current->state = TASK_RUNNING" to mark yourself : 
strstr : while :  * the simpler "current->state = TASK_RUNNING" to mark yourself : 
str :  * runnable without the overhead of this.
strstr : INIT :  * runnable without the overhead of this. : 
strstr : if :  * runnable without the overhead of this. : 
strstr : for :  * runnable without the overhead of this. : 
strstr : while :  * runnable without the overhead of this. : 
str :  *
strstr : INIT :  * : 
strstr : if :  * : 
strstr : for :  * : 
strstr : while :  * : 
str :  * Return: %true if @p was woken up, %false if it was already running.
strstr : INIT :  * Return: %true if @p was woken up, %false if it was already running. : 
strstr : if :  * Return: %true if @p was woken up, %false if it was already running. : 
strstr : for :  * Return: %true if @p was woken up, %false if it was already running. : 
strstr : while :  * Return: %true if @p was woken up, %false if it was already running. : 
str :  * or @state didn't match @p's state.
strstr : INIT :  * or @state didn't match @p's state. : 
strstr : if :  * or @state didn't match @p's state. : 
strstr : for :  * or @state didn't match @p's state. : 
strstr : while :  * or @state didn't match @p's state. : 
str :  */
strstr : INIT :  */ : 
strstr : if :  */ : 
strstr : for :  */ : 
strstr : while :  */ : 
str : static int
strstr : INIT : static int : 
strstr : if : static int : 
strstr : for : static int : 
strstr : while : static int : 
str : try_to_wake_up(struct task_struct *p, unsigned int state, int wake_flags)
strstr : INIT : try_to_wake_up(struct task_struct *p, unsigned int state, int wake_flags) : 
strstr : if : try_to_wake_up(struct task_struct *p, unsigned int state, int wake_flags) : 
strstr : for : try_to_wake_up(struct task_struct *p, unsigned int state, int wake_flags) : 
strstr : while : try_to_wake_up(struct task_struct *p, unsigned int state, int wake_flags) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	unsigned long flags;
strstr : INIT : 	unsigned long flags; : 
strstr : if : 	unsigned long flags; : 
strstr : for : 	unsigned long flags; : 
strstr : while : 	unsigned long flags; : 
str : 	int cpu, success = 0;
strstr : INIT : 	int cpu, success = 0; : 
strstr : if : 	int cpu, success = 0; : 
strstr : for : 	int cpu, success = 0; : 
strstr : while : 	int cpu, success = 0; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	/*
strstr : if : 	/* : 
strstr : for : 	/* : 
strstr : while : 	/* : 
str : 	 * If we are going to wake up a thread waiting for CONDITION we
strstr : INIT : 	 * If we are going to wake up a thread waiting for CONDITION we : 
strstr : if : 	 * If we are going to wake up a thread waiting for CONDITION we : 
strstr : for : 	 * If we are going to wake up a thread waiting for CONDITION we : 
strstr : while : 	 * If we are going to wake up a thread waiting for CONDITION we : 
str : 	 * need to ensure that CONDITION=1 done by the caller can not be
strstr : INIT : 	 * need to ensure that CONDITION=1 done by the caller can not be : 
strstr : if : 	 * need to ensure that CONDITION=1 done by the caller can not be : 
strstr : for : 	 * need to ensure that CONDITION=1 done by the caller can not be : 
strstr : while : 	 * need to ensure that CONDITION=1 done by the caller can not be : 
str : 	 * reordered with p->state check below. This pairs with mb() in
strstr : INIT : 	 * reordered with p->state check below. This pairs with mb() in : 
strstr : if : 	 * reordered with p->state check below. This pairs with mb() in : 
strstr : for : 	 * reordered with p->state check below. This pairs with mb() in : 
strstr : while : 	 * reordered with p->state check below. This pairs with mb() in : 
str : 	 * set_current_state() the waiting thread does.
strstr : INIT : 	 * set_current_state() the waiting thread does. : 
strstr : if : 	 * set_current_state() the waiting thread does. : 
strstr : for : 	 * set_current_state() the waiting thread does. : 
strstr : while : 	 * set_current_state() the waiting thread does. : 
str : 	 */
strstr : INIT : 	 */ : 
strstr : if : 	 */ : 
strstr : for : 	 */ : 
strstr : while : 	 */ : 
str : 	smp_mb__before_spinlock();
strstr : INIT : 	smp_mb__before_spinlock(); : 
strstr : if : 	smp_mb__before_spinlock(); : 
strstr : for : 	smp_mb__before_spinlock(); : 
strstr : while : 	smp_mb__before_spinlock(); : 
str : 	raw_spin_lock_irqsave(&p->pi_lock, flags);
strstr : INIT : 	raw_spin_lock_irqsave(&p->pi_lock, flags); : 
strstr : if : 	raw_spin_lock_irqsave(&p->pi_lock, flags); : 
strstr : for : 	raw_spin_lock_irqsave(&p->pi_lock, flags); : 
strstr : while : 	raw_spin_lock_irqsave(&p->pi_lock, flags); : 
str : 	if (!(p->state & state))
strstr : INIT : 	if (!(p->state & state)) : 
strstr : if : 	if (!(p->state & state)) : 
strstr : for : 	if (!(p->state & state)) : 
strstr : while : 	if (!(p->state & state)) : 
str : 		goto out;
strstr : INIT : 		goto out; : 
strstr : if : 		goto out; : 
strstr : for : 		goto out; : 
strstr : while : 		goto out; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	success = 1; /* we're going to change ->state */
strstr : if : 	success = 1; /* we're going to change ->state */ : 
strstr : for : 	success = 1; /* we're going to change ->state */ : 
strstr : while : 	success = 1; /* we're going to change ->state */ : 
str : 	cpu = task_cpu(p);
strstr : INIT : 	cpu = task_cpu(p); : 
strstr : if : 	cpu = task_cpu(p); : 
strstr : for : 	cpu = task_cpu(p); : 
strstr : while : 	cpu = task_cpu(p); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	if (p->on_rq && ttwu_remote(p, wake_flags))
strstr : if : 	if (p->on_rq && ttwu_remote(p, wake_flags)) : 
strstr : for : 	if (p->on_rq && ttwu_remote(p, wake_flags)) : 
strstr : while : 	if (p->on_rq && ttwu_remote(p, wake_flags)) : 
str : 		goto stat;
strstr : INIT : 		goto stat; : 
strstr : if : 		goto stat; : 
strstr : for : 		goto stat; : 
strstr : while : 		goto stat; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : #ifdef CONFIG_SMP
strstr : if : #ifdef CONFIG_SMP : 
strstr : for : #ifdef CONFIG_SMP : 
strstr : while : #ifdef CONFIG_SMP : 
str : 	/*
strstr : INIT : 	/* : 
strstr : if : 	/* : 
strstr : for : 	/* : 
strstr : while : 	/* : 
str : 	 * If the owning (remote) cpu is still in the middle of schedule() with
strstr : INIT : 	 * If the owning (remote) cpu is still in the middle of schedule() with : 
strstr : if : 	 * If the owning (remote) cpu is still in the middle of schedule() with : 
strstr : for : 	 * If the owning (remote) cpu is still in the middle of schedule() with : 
strstr : while : 	 * If the owning (remote) cpu is still in the middle of schedule() with : 
str : 	 * this task as prev, wait until its done referencing the task.
strstr : INIT : 	 * this task as prev, wait until its done referencing the task. : 
strstr : if : 	 * this task as prev, wait until its done referencing the task. : 
strstr : for : 	 * this task as prev, wait until its done referencing the task. : 
strstr : while : 	 * this task as prev, wait until its done referencing the task. : 
str : 	 */
strstr : INIT : 	 */ : 
strstr : if : 	 */ : 
strstr : for : 	 */ : 
strstr : while : 	 */ : 
str : 	while (p->on_cpu)
strstr : INIT : 	while (p->on_cpu) : 
strstr : if : 	while (p->on_cpu) : 
strstr : for : 	while (p->on_cpu) : 
strstr : while : 	while (p->on_cpu) : 
str : 		cpu_relax();
strstr : INIT : 		cpu_relax(); : 
strstr : if : 		cpu_relax(); : 
strstr : for : 		cpu_relax(); : 
strstr : while : 		cpu_relax(); : 
str : 	/*
strstr : INIT : 	/* : 
strstr : if : 	/* : 
strstr : for : 	/* : 
strstr : while : 	/* : 
str : 	 * Pairs with the smp_wmb() in finish_lock_switch().
strstr : INIT : 	 * Pairs with the smp_wmb() in finish_lock_switch(). : 
strstr : if : 	 * Pairs with the smp_wmb() in finish_lock_switch(). : 
strstr : for : 	 * Pairs with the smp_wmb() in finish_lock_switch(). : 
strstr : while : 	 * Pairs with the smp_wmb() in finish_lock_switch(). : 
str : 	 */
strstr : INIT : 	 */ : 
strstr : if : 	 */ : 
strstr : for : 	 */ : 
strstr : while : 	 */ : 
str : 	smp_rmb();
strstr : INIT : 	smp_rmb(); : 
strstr : if : 	smp_rmb(); : 
strstr : for : 	smp_rmb(); : 
strstr : while : 	smp_rmb(); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	p->sched_contributes_to_load = !!task_contributes_to_load(p);
strstr : if : 	p->sched_contributes_to_load = !!task_contributes_to_load(p); : 
strstr : for : 	p->sched_contributes_to_load = !!task_contributes_to_load(p); : 
strstr : while : 	p->sched_contributes_to_load = !!task_contributes_to_load(p); : 
str : 	p->state = TASK_WAKING;
strstr : INIT : 	p->state = TASK_WAKING; : 
strstr : if : 	p->state = TASK_WAKING; : 
strstr : for : 	p->state = TASK_WAKING; : 
strstr : while : 	p->state = TASK_WAKING; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	if (p->sched_class->task_waking)
strstr : if : 	if (p->sched_class->task_waking) : 
strstr : for : 	if (p->sched_class->task_waking) : 
strstr : while : 	if (p->sched_class->task_waking) : 
str : 		p->sched_class->task_waking(p);
strstr : INIT : 		p->sched_class->task_waking(p); : 
strstr : if : 		p->sched_class->task_waking(p); : 
strstr : for : 		p->sched_class->task_waking(p); : 
strstr : while : 		p->sched_class->task_waking(p); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	cpu = select_task_rq(p, p->wake_cpu, SD_BALANCE_WAKE, wake_flags);
strstr : if : 	cpu = select_task_rq(p, p->wake_cpu, SD_BALANCE_WAKE, wake_flags); : 
strstr : for : 	cpu = select_task_rq(p, p->wake_cpu, SD_BALANCE_WAKE, wake_flags); : 
strstr : while : 	cpu = select_task_rq(p, p->wake_cpu, SD_BALANCE_WAKE, wake_flags); : 
str : 	if (task_cpu(p) != cpu) {
strstr : INIT : 	if (task_cpu(p) != cpu) { : 
strstr : if : 	if (task_cpu(p) != cpu) { : 
strstr : for : 	if (task_cpu(p) != cpu) { : 
strstr : while : 	if (task_cpu(p) != cpu) { : 
str : 		wake_flags |= WF_MIGRATED;
strstr : INIT : 		wake_flags |= WF_MIGRATED; : 
strstr : if : 		wake_flags |= WF_MIGRATED; : 
strstr : for : 		wake_flags |= WF_MIGRATED; : 
strstr : while : 		wake_flags |= WF_MIGRATED; : 
str : 		set_task_cpu(p, cpu);
strstr : INIT : 		set_task_cpu(p, cpu); : 
strstr : if : 		set_task_cpu(p, cpu); : 
strstr : for : 		set_task_cpu(p, cpu); : 
strstr : while : 		set_task_cpu(p, cpu); : 
str : 	}
strstr : INIT : 	} : 
strstr : if : 	} : 
strstr : for : 	} : 
strstr : while : 	} : 
str : #endif /* CONFIG_SMP */
strstr : INIT : #endif /* CONFIG_SMP */ : 
strstr : if : #endif /* CONFIG_SMP */ : 
strstr : for : #endif /* CONFIG_SMP */ : 
strstr : while : #endif /* CONFIG_SMP */ : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	ttwu_queue(p, cpu);
strstr : if : 	ttwu_queue(p, cpu); : 
strstr : for : 	ttwu_queue(p, cpu); : 
strstr : while : 	ttwu_queue(p, cpu); : 
str : stat:
strstr : INIT : stat: : 
strstr : if : stat: : 
strstr : for : stat: : 
strstr : while : stat: : 
str : 	ttwu_stat(p, cpu, wake_flags);
strstr : INIT : 	ttwu_stat(p, cpu, wake_flags); : 
strstr : if : 	ttwu_stat(p, cpu, wake_flags); : 
strstr : for : 	ttwu_stat(p, cpu, wake_flags); : 
strstr : while : 	ttwu_stat(p, cpu, wake_flags); : 
str : out:
strstr : INIT : out: : 
strstr : if : out: : 
strstr : for : out: : 
strstr : while : out: : 
str : 	raw_spin_unlock_irqrestore(&p->pi_lock, flags);
strstr : INIT : 	raw_spin_unlock_irqrestore(&p->pi_lock, flags); : 
strstr : if : 	raw_spin_unlock_irqrestore(&p->pi_lock, flags); : 
strstr : for : 	raw_spin_unlock_irqrestore(&p->pi_lock, flags); : 
strstr : while : 	raw_spin_unlock_irqrestore(&p->pi_lock, flags); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	return success;
strstr : if : 	return success; : 
strstr : for : 	return success; : 
strstr : while : 	return success; : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : /**
strstr : if : /** : 
strstr : for : /** : 
strstr : while : /** : 
str :  * try_to_wake_up_local - try to wake up a local task with rq lock held
strstr : INIT :  * try_to_wake_up_local - try to wake up a local task with rq lock held : 
strstr : if :  * try_to_wake_up_local - try to wake up a local task with rq lock held : 
strstr : for :  * try_to_wake_up_local - try to wake up a local task with rq lock held : 
strstr : while :  * try_to_wake_up_local - try to wake up a local task with rq lock held : 
str :  * @p: the thread to be awakened
strstr : INIT :  * @p: the thread to be awakened : 
strstr : if :  * @p: the thread to be awakened : 
strstr : for :  * @p: the thread to be awakened : 
strstr : while :  * @p: the thread to be awakened : 
str :  *
strstr : INIT :  * : 
strstr : if :  * : 
strstr : for :  * : 
strstr : while :  * : 
str :  * Put @p on the run-queue if it's not already there. The caller must
strstr : INIT :  * Put @p on the run-queue if it's not already there. The caller must : 
strstr : if :  * Put @p on the run-queue if it's not already there. The caller must : 
strstr : for :  * Put @p on the run-queue if it's not already there. The caller must : 
strstr : while :  * Put @p on the run-queue if it's not already there. The caller must : 
str :  * ensure that this_rq() is locked, @p is bound to this_rq() and not
strstr : INIT :  * ensure that this_rq() is locked, @p is bound to this_rq() and not : 
strstr : if :  * ensure that this_rq() is locked, @p is bound to this_rq() and not : 
strstr : for :  * ensure that this_rq() is locked, @p is bound to this_rq() and not : 
strstr : while :  * ensure that this_rq() is locked, @p is bound to this_rq() and not : 
str :  * the current task.
strstr : INIT :  * the current task. : 
strstr : if :  * the current task. : 
strstr : for :  * the current task. : 
strstr : while :  * the current task. : 
str :  */
strstr : INIT :  */ : 
strstr : if :  */ : 
strstr : for :  */ : 
strstr : while :  */ : 
str : static void try_to_wake_up_local(struct task_struct *p)
strstr : INIT : static void try_to_wake_up_local(struct task_struct *p) : 
strstr : if : static void try_to_wake_up_local(struct task_struct *p) : 
strstr : for : static void try_to_wake_up_local(struct task_struct *p) : 
strstr : while : static void try_to_wake_up_local(struct task_struct *p) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	struct rq *rq = task_rq(p);
strstr : INIT : 	struct rq *rq = task_rq(p); : 
strstr : if : 	struct rq *rq = task_rq(p); : 
strstr : for : 	struct rq *rq = task_rq(p); : 
strstr : while : 	struct rq *rq = task_rq(p); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	if (WARN_ON_ONCE(rq != this_rq()) ||
strstr : if : 	if (WARN_ON_ONCE(rq != this_rq()) || : 
strstr : for : 	if (WARN_ON_ONCE(rq != this_rq()) || : 
strstr : while : 	if (WARN_ON_ONCE(rq != this_rq()) || : 
str : 	    WARN_ON_ONCE(p == current))
strstr : INIT : 	    WARN_ON_ONCE(p == current)) : 
strstr : if : 	    WARN_ON_ONCE(p == current)) : 
strstr : for : 	    WARN_ON_ONCE(p == current)) : 
strstr : while : 	    WARN_ON_ONCE(p == current)) : 
str : 		return;
strstr : INIT : 		return; : 
strstr : if : 		return; : 
strstr : for : 		return; : 
strstr : while : 		return; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	lockdep_assert_held(&rq->lock);
strstr : if : 	lockdep_assert_held(&rq->lock); : 
strstr : for : 	lockdep_assert_held(&rq->lock); : 
strstr : while : 	lockdep_assert_held(&rq->lock); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	if (!raw_spin_trylock(&p->pi_lock)) {
strstr : if : 	if (!raw_spin_trylock(&p->pi_lock)) { : 
strstr : for : 	if (!raw_spin_trylock(&p->pi_lock)) { : 
strstr : while : 	if (!raw_spin_trylock(&p->pi_lock)) { : 
str : 		raw_spin_unlock(&rq->lock);
strstr : INIT : 		raw_spin_unlock(&rq->lock); : 
strstr : if : 		raw_spin_unlock(&rq->lock); : 
strstr : for : 		raw_spin_unlock(&rq->lock); : 
strstr : while : 		raw_spin_unlock(&rq->lock); : 
str : 		raw_spin_lock(&p->pi_lock);
strstr : INIT : 		raw_spin_lock(&p->pi_lock); : 
strstr : if : 		raw_spin_lock(&p->pi_lock); : 
strstr : for : 		raw_spin_lock(&p->pi_lock); : 
strstr : while : 		raw_spin_lock(&p->pi_lock); : 
str : 		raw_spin_lock(&rq->lock);
strstr : INIT : 		raw_spin_lock(&rq->lock); : 
strstr : if : 		raw_spin_lock(&rq->lock); : 
strstr : for : 		raw_spin_lock(&rq->lock); : 
strstr : while : 		raw_spin_lock(&rq->lock); : 
str : 	}
strstr : INIT : 	} : 
strstr : if : 	} : 
strstr : for : 	} : 
strstr : while : 	} : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	if (!(p->state & TASK_NORMAL))
strstr : if : 	if (!(p->state & TASK_NORMAL)) : 
strstr : for : 	if (!(p->state & TASK_NORMAL)) : 
strstr : while : 	if (!(p->state & TASK_NORMAL)) : 
str : 		goto out;
strstr : INIT : 		goto out; : 
strstr : if : 		goto out; : 
strstr : for : 		goto out; : 
strstr : while : 		goto out; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	if (!p->on_rq)
strstr : if : 	if (!p->on_rq) : 
strstr : for : 	if (!p->on_rq) : 
strstr : while : 	if (!p->on_rq) : 
str : 		ttwu_activate(rq, p, ENQUEUE_WAKEUP);
strstr : INIT : 		ttwu_activate(rq, p, ENQUEUE_WAKEUP); : 
strstr : if : 		ttwu_activate(rq, p, ENQUEUE_WAKEUP); : 
strstr : for : 		ttwu_activate(rq, p, ENQUEUE_WAKEUP); : 
strstr : while : 		ttwu_activate(rq, p, ENQUEUE_WAKEUP); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	ttwu_do_wakeup(rq, p, 0);
strstr : if : 	ttwu_do_wakeup(rq, p, 0); : 
strstr : for : 	ttwu_do_wakeup(rq, p, 0); : 
strstr : while : 	ttwu_do_wakeup(rq, p, 0); : 
str : 	ttwu_stat(p, smp_processor_id(), 0);
strstr : INIT : 	ttwu_stat(p, smp_processor_id(), 0); : 
strstr : if : 	ttwu_stat(p, smp_processor_id(), 0); : 
strstr : for : 	ttwu_stat(p, smp_processor_id(), 0); : 
strstr : while : 	ttwu_stat(p, smp_processor_id(), 0); : 
str : out:
strstr : INIT : out: : 
strstr : if : out: : 
strstr : for : out: : 
strstr : while : out: : 
str : 	raw_spin_unlock(&p->pi_lock);
strstr : INIT : 	raw_spin_unlock(&p->pi_lock); : 
strstr : if : 	raw_spin_unlock(&p->pi_lock); : 
strstr : for : 	raw_spin_unlock(&p->pi_lock); : 
strstr : while : 	raw_spin_unlock(&p->pi_lock); : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : /**
strstr : if : /** : 
strstr : for : /** : 
strstr : while : /** : 
str :  * wake_up_process - Wake up a specific process
strstr : INIT :  * wake_up_process - Wake up a specific process : 
strstr : if :  * wake_up_process - Wake up a specific process : 
strstr : for :  * wake_up_process - Wake up a specific process : 
strstr : while :  * wake_up_process - Wake up a specific process : 
str :  * @p: The process to be woken up.
strstr : INIT :  * @p: The process to be woken up. : 
strstr : if :  * @p: The process to be woken up. : 
strstr : for :  * @p: The process to be woken up. : 
strstr : while :  * @p: The process to be woken up. : 
str :  *
strstr : INIT :  * : 
strstr : if :  * : 
strstr : for :  * : 
strstr : while :  * : 
str :  * Attempt to wake up the nominated process and move it to the set of runnable
strstr : INIT :  * Attempt to wake up the nominated process and move it to the set of runnable : 
strstr : if :  * Attempt to wake up the nominated process and move it to the set of runnable : 
strstr : for :  * Attempt to wake up the nominated process and move it to the set of runnable : 
strstr : while :  * Attempt to wake up the nominated process and move it to the set of runnable : 
str :  * processes.
strstr : INIT :  * processes. : 
strstr : if :  * processes. : 
strstr : for :  * processes. : 
strstr : while :  * processes. : 
str :  *
strstr : INIT :  * : 
strstr : if :  * : 
strstr : for :  * : 
strstr : while :  * : 
str :  * Return: 1 if the process was woken up, 0 if it was already running.
strstr : INIT :  * Return: 1 if the process was woken up, 0 if it was already running. : 
strstr : if :  * Return: 1 if the process was woken up, 0 if it was already running. : 
strstr : for :  * Return: 1 if the process was woken up, 0 if it was already running. : 
strstr : while :  * Return: 1 if the process was woken up, 0 if it was already running. : 
str :  *
strstr : INIT :  * : 
strstr : if :  * : 
strstr : for :  * : 
strstr : while :  * : 
str :  * It may be assumed that this function implies a write memory barrier before
strstr : INIT :  * It may be assumed that this function implies a write memory barrier before : 
strstr : if :  * It may be assumed that this function implies a write memory barrier before : 
strstr : for :  * It may be assumed that this function implies a write memory barrier before : 
strstr : while :  * It may be assumed that this function implies a write memory barrier before : 
str :  * changing the task state if and only if any tasks are woken up.
strstr : INIT :  * changing the task state if and only if any tasks are woken up. : 
strstr : if :  * changing the task state if and only if any tasks are woken up. : 
strstr : for :  * changing the task state if and only if any tasks are woken up. : 
strstr : while :  * changing the task state if and only if any tasks are woken up. : 
str :  */
strstr : INIT :  */ : 
strstr : if :  */ : 
strstr : for :  */ : 
strstr : while :  */ : 
str : int wake_up_process(struct task_struct *p)
strstr : INIT : int wake_up_process(struct task_struct *p) : 
strstr : if : int wake_up_process(struct task_struct *p) : 
strstr : for : int wake_up_process(struct task_struct *p) : 
strstr : while : int wake_up_process(struct task_struct *p) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	WARN_ON(task_is_stopped_or_traced(p));
strstr : INIT : 	WARN_ON(task_is_stopped_or_traced(p)); : 
strstr : if : 	WARN_ON(task_is_stopped_or_traced(p)); : 
strstr : for : 	WARN_ON(task_is_stopped_or_traced(p)); : 
strstr : while : 	WARN_ON(task_is_stopped_or_traced(p)); : 
str : 	return try_to_wake_up(p, TASK_NORMAL, 0);
strstr : INIT : 	return try_to_wake_up(p, TASK_NORMAL, 0); : 
strstr : if : 	return try_to_wake_up(p, TASK_NORMAL, 0); : 
strstr : for : 	return try_to_wake_up(p, TASK_NORMAL, 0); : 
strstr : while : 	return try_to_wake_up(p, TASK_NORMAL, 0); : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : EXPORT_SYMBOL(wake_up_process);
strstr : INIT : EXPORT_SYMBOL(wake_up_process); : 
strstr : if : EXPORT_SYMBOL(wake_up_process); : 
strstr : for : EXPORT_SYMBOL(wake_up_process); : 
strstr : while : EXPORT_SYMBOL(wake_up_process); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : int wake_up_state(struct task_struct *p, unsigned int state)
strstr : if : int wake_up_state(struct task_struct *p, unsigned int state) : 
strstr : for : int wake_up_state(struct task_struct *p, unsigned int state) : 
strstr : while : int wake_up_state(struct task_struct *p, unsigned int state) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	return try_to_wake_up(p, state, 0);
strstr : INIT : 	return try_to_wake_up(p, state, 0); : 
strstr : if : 	return try_to_wake_up(p, state, 0); : 
strstr : for : 	return try_to_wake_up(p, state, 0); : 
strstr : while : 	return try_to_wake_up(p, state, 0); : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : /*
strstr : if : /* : 
strstr : for : /* : 
strstr : while : /* : 
str :  * Perform scheduler related setup for a newly forked process p.
strstr : INIT :  * Perform scheduler related setup for a newly forked process p. : 
strstr : if :  * Perform scheduler related setup for a newly forked process p. : 
strstr : for :  * Perform scheduler related setup for a newly forked process p. : 
strstr : while :  * Perform scheduler related setup for a newly forked process p. : 
str :  * p is forked by current.
strstr : INIT :  * p is forked by current. : 
strstr : if :  * p is forked by current. : 
strstr : for :  * p is forked by current. : 
strstr : while :  * p is forked by current. : 
str :  *
strstr : INIT :  * : 
strstr : if :  * : 
strstr : for :  * : 
strstr : while :  * : 
str :  * __sched_fork() is basic setup used by init_idle() too:
strstr : INIT :  * __sched_fork() is basic setup used by init_idle() too: : 
strstr : if :  * __sched_fork() is basic setup used by init_idle() too: : 
strstr : for :  * __sched_fork() is basic setup used by init_idle() too: : 
strstr : while :  * __sched_fork() is basic setup used by init_idle() too: : 
str :  */
strstr : INIT :  */ : 
strstr : if :  */ : 
strstr : for :  */ : 
strstr : while :  */ : 
str : static void __sched_fork(unsigned long clone_flags, struct task_struct *p)
strstr : INIT : static void __sched_fork(unsigned long clone_flags, struct task_struct *p) : 
strstr : if : static void __sched_fork(unsigned long clone_flags, struct task_struct *p) : 
strstr : for : static void __sched_fork(unsigned long clone_flags, struct task_struct *p) : 
strstr : while : static void __sched_fork(unsigned long clone_flags, struct task_struct *p) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	p->on_rq			= 0;
strstr : INIT : 	p->on_rq			= 0; : 
strstr : if : 	p->on_rq			= 0; : 
strstr : for : 	p->on_rq			= 0; : 
strstr : while : 	p->on_rq			= 0; : 
str : 	p->se.on_rq			= 0;
strstr : INIT : 	p->se.on_rq			= 0; : 
strstr : if : 	p->se.on_rq			= 0; : 
strstr : for : 	p->se.on_rq			= 0; : 
strstr : while : 	p->se.on_rq			= 0; : 
str : 	p->se.exec_start		= 0;
strstr : INIT : 	p->se.exec_start		= 0; : 
strstr : if : 	p->se.exec_start		= 0; : 
strstr : for : 	p->se.exec_start		= 0; : 
strstr : while : 	p->se.exec_start		= 0; : 
str : 	p->se.sum_exec_runtime		= 0;
strstr : INIT : 	p->se.sum_exec_runtime		= 0; : 
strstr : if : 	p->se.sum_exec_runtime		= 0; : 
strstr : for : 	p->se.sum_exec_runtime		= 0; : 
strstr : while : 	p->se.sum_exec_runtime		= 0; : 
str : 	p->se.prev_sum_exec_runtime	= 0;
strstr : INIT : 	p->se.prev_sum_exec_runtime	= 0; : 
strstr : if : 	p->se.prev_sum_exec_runtime	= 0; : 
strstr : for : 	p->se.prev_sum_exec_runtime	= 0; : 
strstr : while : 	p->se.prev_sum_exec_runtime	= 0; : 
str : 	p->se.nr_migrations		= 0;
strstr : INIT : 	p->se.nr_migrations		= 0; : 
strstr : if : 	p->se.nr_migrations		= 0; : 
strstr : for : 	p->se.nr_migrations		= 0; : 
strstr : while : 	p->se.nr_migrations		= 0; : 
str : 	p->se.vruntime			= 0;
strstr : INIT : 	p->se.vruntime			= 0; : 
strstr : if : 	p->se.vruntime			= 0; : 
strstr : for : 	p->se.vruntime			= 0; : 
strstr : while : 	p->se.vruntime			= 0; : 
str : 	INIT_LIST_HEAD(&p->se.group_node);
strstr : INIT : 	INIT_LIST_HEAD(&p->se.group_node); : 
strstr : if : 	INIT_LIST_HEAD(&p->se.group_node); : 
strstr : for : 	INIT_LIST_HEAD(&p->se.group_node); : 
strstr : while : 	INIT_LIST_HEAD(&p->se.group_node); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : #ifdef CONFIG_SCHEDSTATS
strstr : if : #ifdef CONFIG_SCHEDSTATS : 
strstr : for : #ifdef CONFIG_SCHEDSTATS : 
strstr : while : #ifdef CONFIG_SCHEDSTATS : 
str : 	memset(&p->se.statistics, 0, sizeof(p->se.statistics));
strstr : INIT : 	memset(&p->se.statistics, 0, sizeof(p->se.statistics)); : 
strstr : if : 	memset(&p->se.statistics, 0, sizeof(p->se.statistics)); : 
strstr : for : 	memset(&p->se.statistics, 0, sizeof(p->se.statistics)); : 
strstr : while : 	memset(&p->se.statistics, 0, sizeof(p->se.statistics)); : 
str : #endif
strstr : INIT : #endif : 
strstr : if : #endif : 
strstr : for : #endif : 
strstr : while : #endif : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	RB_CLEAR_NODE(&p->dl.rb_node);
strstr : if : 	RB_CLEAR_NODE(&p->dl.rb_node); : 
strstr : for : 	RB_CLEAR_NODE(&p->dl.rb_node); : 
strstr : while : 	RB_CLEAR_NODE(&p->dl.rb_node); : 
str : 	hrtimer_init(&p->dl.dl_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
strstr : INIT : 	hrtimer_init(&p->dl.dl_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL); : 
strstr : if : 	hrtimer_init(&p->dl.dl_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL); : 
strstr : for : 	hrtimer_init(&p->dl.dl_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL); : 
strstr : while : 	hrtimer_init(&p->dl.dl_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL); : 
str : 	p->dl.dl_runtime = p->dl.runtime = 0;
strstr : INIT : 	p->dl.dl_runtime = p->dl.runtime = 0; : 
strstr : if : 	p->dl.dl_runtime = p->dl.runtime = 0; : 
strstr : for : 	p->dl.dl_runtime = p->dl.runtime = 0; : 
strstr : while : 	p->dl.dl_runtime = p->dl.runtime = 0; : 
str : 	p->dl.dl_deadline = p->dl.deadline = 0;
strstr : INIT : 	p->dl.dl_deadline = p->dl.deadline = 0; : 
strstr : if : 	p->dl.dl_deadline = p->dl.deadline = 0; : 
strstr : for : 	p->dl.dl_deadline = p->dl.deadline = 0; : 
strstr : while : 	p->dl.dl_deadline = p->dl.deadline = 0; : 
str : 	p->dl.dl_period = 0;
strstr : INIT : 	p->dl.dl_period = 0; : 
strstr : if : 	p->dl.dl_period = 0; : 
strstr : for : 	p->dl.dl_period = 0; : 
strstr : while : 	p->dl.dl_period = 0; : 
str : 	p->dl.flags = 0;
strstr : INIT : 	p->dl.flags = 0; : 
strstr : if : 	p->dl.flags = 0; : 
strstr : for : 	p->dl.flags = 0; : 
strstr : while : 	p->dl.flags = 0; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	INIT_LIST_HEAD(&p->rt.run_list);
strstr : if : 	INIT_LIST_HEAD(&p->rt.run_list); : 
strstr : for : 	INIT_LIST_HEAD(&p->rt.run_list); : 
strstr : while : 	INIT_LIST_HEAD(&p->rt.run_list); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : #ifdef CONFIG_PREEMPT_NOTIFIERS
strstr : if : #ifdef CONFIG_PREEMPT_NOTIFIERS : 
strstr : for : #ifdef CONFIG_PREEMPT_NOTIFIERS : 
strstr : while : #ifdef CONFIG_PREEMPT_NOTIFIERS : 
str : 	INIT_HLIST_HEAD(&p->preempt_notifiers);
strstr : INIT : 	INIT_HLIST_HEAD(&p->preempt_notifiers); : 
strstr : if : 	INIT_HLIST_HEAD(&p->preempt_notifiers); : 
strstr : for : 	INIT_HLIST_HEAD(&p->preempt_notifiers); : 
strstr : while : 	INIT_HLIST_HEAD(&p->preempt_notifiers); : 
str : #endif
strstr : INIT : #endif : 
strstr : if : #endif : 
strstr : for : #endif : 
strstr : while : #endif : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : #ifdef CONFIG_NUMA_BALANCING
strstr : if : #ifdef CONFIG_NUMA_BALANCING : 
strstr : for : #ifdef CONFIG_NUMA_BALANCING : 
strstr : while : #ifdef CONFIG_NUMA_BALANCING : 
str : 	if (p->mm && atomic_read(&p->mm->mm_users) == 1) {
strstr : INIT : 	if (p->mm && atomic_read(&p->mm->mm_users) == 1) { : 
strstr : if : 	if (p->mm && atomic_read(&p->mm->mm_users) == 1) { : 
strstr : for : 	if (p->mm && atomic_read(&p->mm->mm_users) == 1) { : 
strstr : while : 	if (p->mm && atomic_read(&p->mm->mm_users) == 1) { : 
str : 		p->mm->numa_next_scan = jiffies + msecs_to_jiffies(sysctl_numa_balancing_scan_delay);
strstr : INIT : 		p->mm->numa_next_scan = jiffies + msecs_to_jiffies(sysctl_numa_balancing_scan_delay); : 
strstr : if : 		p->mm->numa_next_scan = jiffies + msecs_to_jiffies(sysctl_numa_balancing_scan_delay); : 
strstr : for : 		p->mm->numa_next_scan = jiffies + msecs_to_jiffies(sysctl_numa_balancing_scan_delay); : 
strstr : while : 		p->mm->numa_next_scan = jiffies + msecs_to_jiffies(sysctl_numa_balancing_scan_delay); : 
str : 		p->mm->numa_scan_seq = 0;
strstr : INIT : 		p->mm->numa_scan_seq = 0; : 
strstr : if : 		p->mm->numa_scan_seq = 0; : 
strstr : for : 		p->mm->numa_scan_seq = 0; : 
strstr : while : 		p->mm->numa_scan_seq = 0; : 
str : 	}
strstr : INIT : 	} : 
strstr : if : 	} : 
strstr : for : 	} : 
strstr : while : 	} : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	if (clone_flags & CLONE_VM)
strstr : if : 	if (clone_flags & CLONE_VM) : 
strstr : for : 	if (clone_flags & CLONE_VM) : 
strstr : while : 	if (clone_flags & CLONE_VM) : 
str : 		p->numa_preferred_nid = current->numa_preferred_nid;
strstr : INIT : 		p->numa_preferred_nid = current->numa_preferred_nid; : 
strstr : if : 		p->numa_preferred_nid = current->numa_preferred_nid; : 
strstr : for : 		p->numa_preferred_nid = current->numa_preferred_nid; : 
strstr : while : 		p->numa_preferred_nid = current->numa_preferred_nid; : 
str : 	else
strstr : INIT : 	else : 
strstr : if : 	else : 
strstr : for : 	else : 
strstr : while : 	else : 
str : 		p->numa_preferred_nid = -1;
strstr : INIT : 		p->numa_preferred_nid = -1; : 
strstr : if : 		p->numa_preferred_nid = -1; : 
strstr : for : 		p->numa_preferred_nid = -1; : 
strstr : while : 		p->numa_preferred_nid = -1; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	p->node_stamp = 0ULL;
strstr : if : 	p->node_stamp = 0ULL; : 
strstr : for : 	p->node_stamp = 0ULL; : 
strstr : while : 	p->node_stamp = 0ULL; : 
str : 	p->numa_scan_seq = p->mm ? p->mm->numa_scan_seq : 0;
strstr : INIT : 	p->numa_scan_seq = p->mm ? p->mm->numa_scan_seq : 0; : 
strstr : if : 	p->numa_scan_seq = p->mm ? p->mm->numa_scan_seq : 0; : 
strstr : for : 	p->numa_scan_seq = p->mm ? p->mm->numa_scan_seq : 0; : 
strstr : while : 	p->numa_scan_seq = p->mm ? p->mm->numa_scan_seq : 0; : 
str : 	p->numa_scan_period = sysctl_numa_balancing_scan_delay;
strstr : INIT : 	p->numa_scan_period = sysctl_numa_balancing_scan_delay; : 
strstr : if : 	p->numa_scan_period = sysctl_numa_balancing_scan_delay; : 
strstr : for : 	p->numa_scan_period = sysctl_numa_balancing_scan_delay; : 
strstr : while : 	p->numa_scan_period = sysctl_numa_balancing_scan_delay; : 
str : 	p->numa_work.next = &p->numa_work;
strstr : INIT : 	p->numa_work.next = &p->numa_work; : 
strstr : if : 	p->numa_work.next = &p->numa_work; : 
strstr : for : 	p->numa_work.next = &p->numa_work; : 
strstr : while : 	p->numa_work.next = &p->numa_work; : 
str : 	p->numa_faults = NULL;
strstr : INIT : 	p->numa_faults = NULL; : 
strstr : if : 	p->numa_faults = NULL; : 
strstr : for : 	p->numa_faults = NULL; : 
strstr : while : 	p->numa_faults = NULL; : 
str : 	p->numa_faults_buffer = NULL;
strstr : INIT : 	p->numa_faults_buffer = NULL; : 
strstr : if : 	p->numa_faults_buffer = NULL; : 
strstr : for : 	p->numa_faults_buffer = NULL; : 
strstr : while : 	p->numa_faults_buffer = NULL; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	INIT_LIST_HEAD(&p->numa_entry);
strstr : if : 	INIT_LIST_HEAD(&p->numa_entry); : 
strstr : for : 	INIT_LIST_HEAD(&p->numa_entry); : 
strstr : while : 	INIT_LIST_HEAD(&p->numa_entry); : 
str : 	p->numa_group = NULL;
strstr : INIT : 	p->numa_group = NULL; : 
strstr : if : 	p->numa_group = NULL; : 
strstr : for : 	p->numa_group = NULL; : 
strstr : while : 	p->numa_group = NULL; : 
str : #endif /* CONFIG_NUMA_BALANCING */
strstr : INIT : #endif /* CONFIG_NUMA_BALANCING */ : 
strstr : if : #endif /* CONFIG_NUMA_BALANCING */ : 
strstr : for : #endif /* CONFIG_NUMA_BALANCING */ : 
strstr : while : #endif /* CONFIG_NUMA_BALANCING */ : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : #ifdef CONFIG_NUMA_BALANCING
strstr : if : #ifdef CONFIG_NUMA_BALANCING : 
strstr : for : #ifdef CONFIG_NUMA_BALANCING : 
strstr : while : #ifdef CONFIG_NUMA_BALANCING : 
str : #ifdef CONFIG_SCHED_DEBUG
strstr : INIT : #ifdef CONFIG_SCHED_DEBUG : 
strstr : if : #ifdef CONFIG_SCHED_DEBUG : 
strstr : for : #ifdef CONFIG_SCHED_DEBUG : 
strstr : while : #ifdef CONFIG_SCHED_DEBUG : 
str : void set_numabalancing_state(bool enabled)
strstr : INIT : void set_numabalancing_state(bool enabled) : 
strstr : if : void set_numabalancing_state(bool enabled) : 
strstr : for : void set_numabalancing_state(bool enabled) : 
strstr : while : void set_numabalancing_state(bool enabled) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	if (enabled)
strstr : INIT : 	if (enabled) : 
strstr : if : 	if (enabled) : 
strstr : for : 	if (enabled) : 
strstr : while : 	if (enabled) : 
str : 		sched_feat_set("NUMA");
strstr : INIT : 		sched_feat_set("NUMA"); : 
strstr : if : 		sched_feat_set("NUMA"); : 
strstr : for : 		sched_feat_set("NUMA"); : 
strstr : while : 		sched_feat_set("NUMA"); : 
str : 	else
strstr : INIT : 	else : 
strstr : if : 	else : 
strstr : for : 	else : 
strstr : while : 	else : 
str : 		sched_feat_set("NO_NUMA");
strstr : INIT : 		sched_feat_set("NO_NUMA"); : 
strstr : if : 		sched_feat_set("NO_NUMA"); : 
strstr : for : 		sched_feat_set("NO_NUMA"); : 
strstr : while : 		sched_feat_set("NO_NUMA"); : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : #else
strstr : INIT : #else : 
strstr : if : #else : 
strstr : for : #else : 
strstr : while : #else : 
str : __read_mostly bool numabalancing_enabled;
strstr : INIT : __read_mostly bool numabalancing_enabled; : 
strstr : if : __read_mostly bool numabalancing_enabled; : 
strstr : for : __read_mostly bool numabalancing_enabled; : 
strstr : while : __read_mostly bool numabalancing_enabled; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : void set_numabalancing_state(bool enabled)
strstr : if : void set_numabalancing_state(bool enabled) : 
strstr : for : void set_numabalancing_state(bool enabled) : 
strstr : while : void set_numabalancing_state(bool enabled) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	numabalancing_enabled = enabled;
strstr : INIT : 	numabalancing_enabled = enabled; : 
strstr : if : 	numabalancing_enabled = enabled; : 
strstr : for : 	numabalancing_enabled = enabled; : 
strstr : while : 	numabalancing_enabled = enabled; : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : #endif /* CONFIG_SCHED_DEBUG */
strstr : INIT : #endif /* CONFIG_SCHED_DEBUG */ : 
strstr : if : #endif /* CONFIG_SCHED_DEBUG */ : 
strstr : for : #endif /* CONFIG_SCHED_DEBUG */ : 
strstr : while : #endif /* CONFIG_SCHED_DEBUG */ : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : #ifdef CONFIG_PROC_SYSCTL
strstr : if : #ifdef CONFIG_PROC_SYSCTL : 
strstr : for : #ifdef CONFIG_PROC_SYSCTL : 
strstr : while : #ifdef CONFIG_PROC_SYSCTL : 
str : int sysctl_numa_balancing(struct ctl_table *table, int write,
strstr : INIT : int sysctl_numa_balancing(struct ctl_table *table, int write, : 
strstr : if : int sysctl_numa_balancing(struct ctl_table *table, int write, : 
strstr : for : int sysctl_numa_balancing(struct ctl_table *table, int write, : 
strstr : while : int sysctl_numa_balancing(struct ctl_table *table, int write, : 
str : 			 void __user *buffer, size_t *lenp, loff_t *ppos)
strstr : INIT : 			 void __user *buffer, size_t *lenp, loff_t *ppos) : 
strstr : if : 			 void __user *buffer, size_t *lenp, loff_t *ppos) : 
strstr : for : 			 void __user *buffer, size_t *lenp, loff_t *ppos) : 
strstr : while : 			 void __user *buffer, size_t *lenp, loff_t *ppos) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	struct ctl_table t;
strstr : INIT : 	struct ctl_table t; : 
strstr : if : 	struct ctl_table t; : 
strstr : for : 	struct ctl_table t; : 
strstr : while : 	struct ctl_table t; : 
str : 	int err;
strstr : INIT : 	int err; : 
strstr : if : 	int err; : 
strstr : for : 	int err; : 
strstr : while : 	int err; : 
str : 	int state = numabalancing_enabled;
strstr : INIT : 	int state = numabalancing_enabled; : 
strstr : if : 	int state = numabalancing_enabled; : 
strstr : for : 	int state = numabalancing_enabled; : 
strstr : while : 	int state = numabalancing_enabled; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	if (write && !capable(CAP_SYS_ADMIN))
strstr : if : 	if (write && !capable(CAP_SYS_ADMIN)) : 
strstr : for : 	if (write && !capable(CAP_SYS_ADMIN)) : 
strstr : while : 	if (write && !capable(CAP_SYS_ADMIN)) : 
str : 		return -EPERM;
strstr : INIT : 		return -EPERM; : 
strstr : if : 		return -EPERM; : 
strstr : for : 		return -EPERM; : 
strstr : while : 		return -EPERM; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	t = *table;
strstr : if : 	t = *table; : 
strstr : for : 	t = *table; : 
strstr : while : 	t = *table; : 
str : 	t.data = &state;
strstr : INIT : 	t.data = &state; : 
strstr : if : 	t.data = &state; : 
strstr : for : 	t.data = &state; : 
strstr : while : 	t.data = &state; : 
str : 	err = proc_dointvec_minmax(&t, write, buffer, lenp, ppos);
strstr : INIT : 	err = proc_dointvec_minmax(&t, write, buffer, lenp, ppos); : 
strstr : if : 	err = proc_dointvec_minmax(&t, write, buffer, lenp, ppos); : 
strstr : for : 	err = proc_dointvec_minmax(&t, write, buffer, lenp, ppos); : 
strstr : while : 	err = proc_dointvec_minmax(&t, write, buffer, lenp, ppos); : 
str : 	if (err < 0)
strstr : INIT : 	if (err < 0) : 
strstr : if : 	if (err < 0) : 
strstr : for : 	if (err < 0) : 
strstr : while : 	if (err < 0) : 
str : 		return err;
strstr : INIT : 		return err; : 
strstr : if : 		return err; : 
strstr : for : 		return err; : 
strstr : while : 		return err; : 
str : 	if (write)
strstr : INIT : 	if (write) : 
strstr : if : 	if (write) : 
strstr : for : 	if (write) : 
strstr : while : 	if (write) : 
str : 		set_numabalancing_state(state);
strstr : INIT : 		set_numabalancing_state(state); : 
strstr : if : 		set_numabalancing_state(state); : 
strstr : for : 		set_numabalancing_state(state); : 
strstr : while : 		set_numabalancing_state(state); : 
str : 	return err;
strstr : INIT : 	return err; : 
strstr : if : 	return err; : 
strstr : for : 	return err; : 
strstr : while : 	return err; : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : #endif
strstr : INIT : #endif : 
strstr : if : #endif : 
strstr : for : #endif : 
strstr : while : #endif : 
str : #endif
strstr : INIT : #endif : 
strstr : if : #endif : 
strstr : for : #endif : 
strstr : while : #endif : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : /*
strstr : if : /* : 
strstr : for : /* : 
strstr : while : /* : 
str :  * fork()/clone()-time setup:
strstr : INIT :  * fork()/clone()-time setup: : 
strstr : if :  * fork()/clone()-time setup: : 
strstr : for :  * fork()/clone()-time setup: : 
strstr : while :  * fork()/clone()-time setup: : 
str :  */
strstr : INIT :  */ : 
strstr : if :  */ : 
strstr : for :  */ : 
strstr : while :  */ : 
str : int sched_fork(unsigned long clone_flags, struct task_struct *p)
strstr : INIT : int sched_fork(unsigned long clone_flags, struct task_struct *p) : 
strstr : if : int sched_fork(unsigned long clone_flags, struct task_struct *p) : 
strstr : for : int sched_fork(unsigned long clone_flags, struct task_struct *p) : 
strstr : while : int sched_fork(unsigned long clone_flags, struct task_struct *p) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	unsigned long flags;
strstr : INIT : 	unsigned long flags; : 
strstr : if : 	unsigned long flags; : 
strstr : for : 	unsigned long flags; : 
strstr : while : 	unsigned long flags; : 
str : 	int cpu = get_cpu();
strstr : INIT : 	int cpu = get_cpu(); : 
strstr : if : 	int cpu = get_cpu(); : 
strstr : for : 	int cpu = get_cpu(); : 
strstr : while : 	int cpu = get_cpu(); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	__sched_fork(clone_flags, p);
strstr : if : 	__sched_fork(clone_flags, p); : 
strstr : for : 	__sched_fork(clone_flags, p); : 
strstr : while : 	__sched_fork(clone_flags, p); : 
str : 	/*
strstr : INIT : 	/* : 
strstr : if : 	/* : 
strstr : for : 	/* : 
strstr : while : 	/* : 
str : 	 * We mark the process as running here. This guarantees that
strstr : INIT : 	 * We mark the process as running here. This guarantees that : 
strstr : if : 	 * We mark the process as running here. This guarantees that : 
strstr : for : 	 * We mark the process as running here. This guarantees that : 
strstr : while : 	 * We mark the process as running here. This guarantees that : 
str : 	 * nobody will actually run it, and a signal or other external
strstr : INIT : 	 * nobody will actually run it, and a signal or other external : 
strstr : if : 	 * nobody will actually run it, and a signal or other external : 
strstr : for : 	 * nobody will actually run it, and a signal or other external : 
strstr : while : 	 * nobody will actually run it, and a signal or other external : 
str : 	 * event cannot wake it up and insert it on the runqueue either.
strstr : INIT : 	 * event cannot wake it up and insert it on the runqueue either. : 
strstr : if : 	 * event cannot wake it up and insert it on the runqueue either. : 
strstr : for : 	 * event cannot wake it up and insert it on the runqueue either. : 
strstr : while : 	 * event cannot wake it up and insert it on the runqueue either. : 
str : 	 */
strstr : INIT : 	 */ : 
strstr : if : 	 */ : 
strstr : for : 	 */ : 
strstr : while : 	 */ : 
str : 	p->state = TASK_RUNNING;
strstr : INIT : 	p->state = TASK_RUNNING; : 
strstr : if : 	p->state = TASK_RUNNING; : 
strstr : for : 	p->state = TASK_RUNNING; : 
strstr : while : 	p->state = TASK_RUNNING; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	/*
strstr : if : 	/* : 
strstr : for : 	/* : 
strstr : while : 	/* : 
str : 	 * Make sure we do not leak PI boosting priority to the child.
strstr : INIT : 	 * Make sure we do not leak PI boosting priority to the child. : 
strstr : if : 	 * Make sure we do not leak PI boosting priority to the child. : 
strstr : for : 	 * Make sure we do not leak PI boosting priority to the child. : 
strstr : while : 	 * Make sure we do not leak PI boosting priority to the child. : 
str : 	 */
strstr : INIT : 	 */ : 
strstr : if : 	 */ : 
strstr : for : 	 */ : 
strstr : while : 	 */ : 
str : 	p->prio = current->normal_prio;
strstr : INIT : 	p->prio = current->normal_prio; : 
strstr : if : 	p->prio = current->normal_prio; : 
strstr : for : 	p->prio = current->normal_prio; : 
strstr : while : 	p->prio = current->normal_prio; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	/*
strstr : if : 	/* : 
strstr : for : 	/* : 
strstr : while : 	/* : 
str : 	 * Revert to default priority/policy on fork if requested.
strstr : INIT : 	 * Revert to default priority/policy on fork if requested. : 
strstr : if : 	 * Revert to default priority/policy on fork if requested. : 
strstr : for : 	 * Revert to default priority/policy on fork if requested. : 
strstr : while : 	 * Revert to default priority/policy on fork if requested. : 
str : 	 */
strstr : INIT : 	 */ : 
strstr : if : 	 */ : 
strstr : for : 	 */ : 
strstr : while : 	 */ : 
str : 	if (unlikely(p->sched_reset_on_fork)) {
strstr : INIT : 	if (unlikely(p->sched_reset_on_fork)) { : 
strstr : if : 	if (unlikely(p->sched_reset_on_fork)) { : 
strstr : for : 	if (unlikely(p->sched_reset_on_fork)) { : 
strstr : while : 	if (unlikely(p->sched_reset_on_fork)) { : 
str : 		if (task_has_dl_policy(p) || task_has_rt_policy(p)) {
strstr : INIT : 		if (task_has_dl_policy(p) || task_has_rt_policy(p)) { : 
strstr : if : 		if (task_has_dl_policy(p) || task_has_rt_policy(p)) { : 
strstr : for : 		if (task_has_dl_policy(p) || task_has_rt_policy(p)) { : 
strstr : while : 		if (task_has_dl_policy(p) || task_has_rt_policy(p)) { : 
str : 			p->policy = SCHED_NORMAL;
strstr : INIT : 			p->policy = SCHED_NORMAL; : 
strstr : if : 			p->policy = SCHED_NORMAL; : 
strstr : for : 			p->policy = SCHED_NORMAL; : 
strstr : while : 			p->policy = SCHED_NORMAL; : 
str : 			p->static_prio = NICE_TO_PRIO(0);
strstr : INIT : 			p->static_prio = NICE_TO_PRIO(0); : 
strstr : if : 			p->static_prio = NICE_TO_PRIO(0); : 
strstr : for : 			p->static_prio = NICE_TO_PRIO(0); : 
strstr : while : 			p->static_prio = NICE_TO_PRIO(0); : 
str : 			p->rt_priority = 0;
strstr : INIT : 			p->rt_priority = 0; : 
strstr : if : 			p->rt_priority = 0; : 
strstr : for : 			p->rt_priority = 0; : 
strstr : while : 			p->rt_priority = 0; : 
str : 		} else if (PRIO_TO_NICE(p->static_prio) < 0)
strstr : INIT : 		} else if (PRIO_TO_NICE(p->static_prio) < 0) : 
strstr : if : 		} else if (PRIO_TO_NICE(p->static_prio) < 0) : 
strstr : for : 		} else if (PRIO_TO_NICE(p->static_prio) < 0) : 
strstr : while : 		} else if (PRIO_TO_NICE(p->static_prio) < 0) : 
str : 			p->static_prio = NICE_TO_PRIO(0);
strstr : INIT : 			p->static_prio = NICE_TO_PRIO(0); : 
strstr : if : 			p->static_prio = NICE_TO_PRIO(0); : 
strstr : for : 			p->static_prio = NICE_TO_PRIO(0); : 
strstr : while : 			p->static_prio = NICE_TO_PRIO(0); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 		p->prio = p->normal_prio = __normal_prio(p);
strstr : if : 		p->prio = p->normal_prio = __normal_prio(p); : 
strstr : for : 		p->prio = p->normal_prio = __normal_prio(p); : 
strstr : while : 		p->prio = p->normal_prio = __normal_prio(p); : 
str : 		set_load_weight(p);
strstr : INIT : 		set_load_weight(p); : 
strstr : if : 		set_load_weight(p); : 
strstr : for : 		set_load_weight(p); : 
strstr : while : 		set_load_weight(p); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 		/*
strstr : if : 		/* : 
strstr : for : 		/* : 
strstr : while : 		/* : 
str : 		 * We don't need the reset flag anymore after the fork. It has
strstr : INIT : 		 * We don't need the reset flag anymore after the fork. It has : 
strstr : if : 		 * We don't need the reset flag anymore after the fork. It has : 
strstr : for : 		 * We don't need the reset flag anymore after the fork. It has : 
strstr : while : 		 * We don't need the reset flag anymore after the fork. It has : 
str : 		 * fulfilled its duty:
strstr : INIT : 		 * fulfilled its duty: : 
strstr : if : 		 * fulfilled its duty: : 
strstr : for : 		 * fulfilled its duty: : 
strstr : while : 		 * fulfilled its duty: : 
str : 		 */
strstr : INIT : 		 */ : 
strstr : if : 		 */ : 
strstr : for : 		 */ : 
strstr : while : 		 */ : 
str : 		p->sched_reset_on_fork = 0;
strstr : INIT : 		p->sched_reset_on_fork = 0; : 
strstr : if : 		p->sched_reset_on_fork = 0; : 
strstr : for : 		p->sched_reset_on_fork = 0; : 
strstr : while : 		p->sched_reset_on_fork = 0; : 
str : 	}
strstr : INIT : 	} : 
strstr : if : 	} : 
strstr : for : 	} : 
strstr : while : 	} : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	if (dl_prio(p->prio)) {
strstr : if : 	if (dl_prio(p->prio)) { : 
strstr : for : 	if (dl_prio(p->prio)) { : 
strstr : while : 	if (dl_prio(p->prio)) { : 
str : 		put_cpu();
strstr : INIT : 		put_cpu(); : 
strstr : if : 		put_cpu(); : 
strstr : for : 		put_cpu(); : 
strstr : while : 		put_cpu(); : 
str : 		return -EAGAIN;
strstr : INIT : 		return -EAGAIN; : 
strstr : if : 		return -EAGAIN; : 
strstr : for : 		return -EAGAIN; : 
strstr : while : 		return -EAGAIN; : 
str : 	} else if (rt_prio(p->prio)) {
strstr : INIT : 	} else if (rt_prio(p->prio)) { : 
strstr : if : 	} else if (rt_prio(p->prio)) { : 
strstr : for : 	} else if (rt_prio(p->prio)) { : 
strstr : while : 	} else if (rt_prio(p->prio)) { : 
str : 		p->sched_class = &rt_sched_class;
strstr : INIT : 		p->sched_class = &rt_sched_class; : 
strstr : if : 		p->sched_class = &rt_sched_class; : 
strstr : for : 		p->sched_class = &rt_sched_class; : 
strstr : while : 		p->sched_class = &rt_sched_class; : 
str : 	} else {
strstr : INIT : 	} else { : 
strstr : if : 	} else { : 
strstr : for : 	} else { : 
strstr : while : 	} else { : 
str : 		p->sched_class = &fair_sched_class;
strstr : INIT : 		p->sched_class = &fair_sched_class; : 
strstr : if : 		p->sched_class = &fair_sched_class; : 
strstr : for : 		p->sched_class = &fair_sched_class; : 
strstr : while : 		p->sched_class = &fair_sched_class; : 
str : 	}
strstr : INIT : 	} : 
strstr : if : 	} : 
strstr : for : 	} : 
strstr : while : 	} : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	if (p->sched_class->task_fork)
strstr : if : 	if (p->sched_class->task_fork) : 
strstr : for : 	if (p->sched_class->task_fork) : 
strstr : while : 	if (p->sched_class->task_fork) : 
str : 		p->sched_class->task_fork(p);
strstr : INIT : 		p->sched_class->task_fork(p); : 
strstr : if : 		p->sched_class->task_fork(p); : 
strstr : for : 		p->sched_class->task_fork(p); : 
strstr : while : 		p->sched_class->task_fork(p); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	/*
strstr : if : 	/* : 
strstr : for : 	/* : 
strstr : while : 	/* : 
str : 	 * The child is not yet in the pid-hash so no cgroup attach races,
strstr : INIT : 	 * The child is not yet in the pid-hash so no cgroup attach races, : 
strstr : if : 	 * The child is not yet in the pid-hash so no cgroup attach races, : 
strstr : for : 	 * The child is not yet in the pid-hash so no cgroup attach races, : 
strstr : while : 	 * The child is not yet in the pid-hash so no cgroup attach races, : 
str : 	 * and the cgroup is pinned to this child due to cgroup_fork()
strstr : INIT : 	 * and the cgroup is pinned to this child due to cgroup_fork() : 
strstr : if : 	 * and the cgroup is pinned to this child due to cgroup_fork() : 
strstr : for : 	 * and the cgroup is pinned to this child due to cgroup_fork() : 
strstr : while : 	 * and the cgroup is pinned to this child due to cgroup_fork() : 
str : 	 * is ran before sched_fork().
strstr : INIT : 	 * is ran before sched_fork(). : 
strstr : if : 	 * is ran before sched_fork(). : 
strstr : for : 	 * is ran before sched_fork(). : 
strstr : while : 	 * is ran before sched_fork(). : 
str : 	 *
strstr : INIT : 	 * : 
strstr : if : 	 * : 
strstr : for : 	 * : 
strstr : while : 	 * : 
str : 	 * Silence PROVE_RCU.
strstr : INIT : 	 * Silence PROVE_RCU. : 
strstr : if : 	 * Silence PROVE_RCU. : 
strstr : for : 	 * Silence PROVE_RCU. : 
strstr : while : 	 * Silence PROVE_RCU. : 
str : 	 */
strstr : INIT : 	 */ : 
strstr : if : 	 */ : 
strstr : for : 	 */ : 
strstr : while : 	 */ : 
str : 	raw_spin_lock_irqsave(&p->pi_lock, flags);
strstr : INIT : 	raw_spin_lock_irqsave(&p->pi_lock, flags); : 
strstr : if : 	raw_spin_lock_irqsave(&p->pi_lock, flags); : 
strstr : for : 	raw_spin_lock_irqsave(&p->pi_lock, flags); : 
strstr : while : 	raw_spin_lock_irqsave(&p->pi_lock, flags); : 
str : 	set_task_cpu(p, cpu);
strstr : INIT : 	set_task_cpu(p, cpu); : 
strstr : if : 	set_task_cpu(p, cpu); : 
strstr : for : 	set_task_cpu(p, cpu); : 
strstr : while : 	set_task_cpu(p, cpu); : 
str : 	raw_spin_unlock_irqrestore(&p->pi_lock, flags);
strstr : INIT : 	raw_spin_unlock_irqrestore(&p->pi_lock, flags); : 
strstr : if : 	raw_spin_unlock_irqrestore(&p->pi_lock, flags); : 
strstr : for : 	raw_spin_unlock_irqrestore(&p->pi_lock, flags); : 
strstr : while : 	raw_spin_unlock_irqrestore(&p->pi_lock, flags); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : #if defined(CONFIG_SCHEDSTATS) || defined(CONFIG_TASK_DELAY_ACCT)
strstr : if : #if defined(CONFIG_SCHEDSTATS) || defined(CONFIG_TASK_DELAY_ACCT) : 
strstr : for : #if defined(CONFIG_SCHEDSTATS) || defined(CONFIG_TASK_DELAY_ACCT) : 
strstr : while : #if defined(CONFIG_SCHEDSTATS) || defined(CONFIG_TASK_DELAY_ACCT) : 
str : 	if (likely(sched_info_on()))
strstr : INIT : 	if (likely(sched_info_on())) : 
strstr : if : 	if (likely(sched_info_on())) : 
strstr : for : 	if (likely(sched_info_on())) : 
strstr : while : 	if (likely(sched_info_on())) : 
str : 		memset(&p->sched_info, 0, sizeof(p->sched_info));
strstr : INIT : 		memset(&p->sched_info, 0, sizeof(p->sched_info)); : 
strstr : if : 		memset(&p->sched_info, 0, sizeof(p->sched_info)); : 
strstr : for : 		memset(&p->sched_info, 0, sizeof(p->sched_info)); : 
strstr : while : 		memset(&p->sched_info, 0, sizeof(p->sched_info)); : 
str : #endif
strstr : INIT : #endif : 
strstr : if : #endif : 
strstr : for : #endif : 
strstr : while : #endif : 
str : #if defined(CONFIG_SMP)
strstr : INIT : #if defined(CONFIG_SMP) : 
strstr : if : #if defined(CONFIG_SMP) : 
strstr : for : #if defined(CONFIG_SMP) : 
strstr : while : #if defined(CONFIG_SMP) : 
str : 	p->on_cpu = 0;
strstr : INIT : 	p->on_cpu = 0; : 
strstr : if : 	p->on_cpu = 0; : 
strstr : for : 	p->on_cpu = 0; : 
strstr : while : 	p->on_cpu = 0; : 
str : #endif
strstr : INIT : #endif : 
strstr : if : #endif : 
strstr : for : #endif : 
strstr : while : #endif : 
str : 	init_task_preempt_count(p);
strstr : INIT : 	init_task_preempt_count(p); : 
strstr : if : 	init_task_preempt_count(p); : 
strstr : for : 	init_task_preempt_count(p); : 
strstr : while : 	init_task_preempt_count(p); : 
str : #ifdef CONFIG_SMP
strstr : INIT : #ifdef CONFIG_SMP : 
strstr : if : #ifdef CONFIG_SMP : 
strstr : for : #ifdef CONFIG_SMP : 
strstr : while : #ifdef CONFIG_SMP : 
str : 	plist_node_init(&p->pushable_tasks, MAX_PRIO);
strstr : INIT : 	plist_node_init(&p->pushable_tasks, MAX_PRIO); : 
strstr : if : 	plist_node_init(&p->pushable_tasks, MAX_PRIO); : 
strstr : for : 	plist_node_init(&p->pushable_tasks, MAX_PRIO); : 
strstr : while : 	plist_node_init(&p->pushable_tasks, MAX_PRIO); : 
str : 	RB_CLEAR_NODE(&p->pushable_dl_tasks);
strstr : INIT : 	RB_CLEAR_NODE(&p->pushable_dl_tasks); : 
strstr : if : 	RB_CLEAR_NODE(&p->pushable_dl_tasks); : 
strstr : for : 	RB_CLEAR_NODE(&p->pushable_dl_tasks); : 
strstr : while : 	RB_CLEAR_NODE(&p->pushable_dl_tasks); : 
str : #endif
strstr : INIT : #endif : 
strstr : if : #endif : 
strstr : for : #endif : 
strstr : while : #endif : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	put_cpu();
strstr : if : 	put_cpu(); : 
strstr : for : 	put_cpu(); : 
strstr : while : 	put_cpu(); : 
str : 	return 0;
strstr : INIT : 	return 0; : 
strstr : if : 	return 0; : 
strstr : for : 	return 0; : 
strstr : while : 	return 0; : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : unsigned long to_ratio(u64 period, u64 runtime)
strstr : if : unsigned long to_ratio(u64 period, u64 runtime) : 
strstr : for : unsigned long to_ratio(u64 period, u64 runtime) : 
strstr : while : unsigned long to_ratio(u64 period, u64 runtime) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	if (runtime == RUNTIME_INF)
strstr : INIT : 	if (runtime == RUNTIME_INF) : 
strstr : if : 	if (runtime == RUNTIME_INF) : 
strstr : for : 	if (runtime == RUNTIME_INF) : 
strstr : while : 	if (runtime == RUNTIME_INF) : 
str : 		return 1ULL << 20;
strstr : INIT : 		return 1ULL << 20; : 
strstr : if : 		return 1ULL << 20; : 
strstr : for : 		return 1ULL << 20; : 
strstr : while : 		return 1ULL << 20; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	/*
strstr : if : 	/* : 
strstr : for : 	/* : 
strstr : while : 	/* : 
str : 	 * Doing this here saves a lot of checks in all
strstr : INIT : 	 * Doing this here saves a lot of checks in all : 
strstr : if : 	 * Doing this here saves a lot of checks in all : 
strstr : for : 	 * Doing this here saves a lot of checks in all : 
strstr : while : 	 * Doing this here saves a lot of checks in all : 
str : 	 * the calling paths, and returning zero seems
strstr : INIT : 	 * the calling paths, and returning zero seems : 
strstr : if : 	 * the calling paths, and returning zero seems : 
strstr : for : 	 * the calling paths, and returning zero seems : 
strstr : while : 	 * the calling paths, and returning zero seems : 
str : 	 * safe for them anyway.
strstr : INIT : 	 * safe for them anyway. : 
strstr : if : 	 * safe for them anyway. : 
strstr : for : 	 * safe for them anyway. : 
strstr : while : 	 * safe for them anyway. : 
str : 	 */
strstr : INIT : 	 */ : 
strstr : if : 	 */ : 
strstr : for : 	 */ : 
strstr : while : 	 */ : 
str : 	if (period == 0)
strstr : INIT : 	if (period == 0) : 
strstr : if : 	if (period == 0) : 
strstr : for : 	if (period == 0) : 
strstr : while : 	if (period == 0) : 
str : 		return 0;
strstr : INIT : 		return 0; : 
strstr : if : 		return 0; : 
strstr : for : 		return 0; : 
strstr : while : 		return 0; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	return div64_u64(runtime << 20, period);
strstr : if : 	return div64_u64(runtime << 20, period); : 
strstr : for : 	return div64_u64(runtime << 20, period); : 
strstr : while : 	return div64_u64(runtime << 20, period); : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : #ifdef CONFIG_SMP
strstr : if : #ifdef CONFIG_SMP : 
strstr : for : #ifdef CONFIG_SMP : 
strstr : while : #ifdef CONFIG_SMP : 
str : inline struct dl_bw *dl_bw_of(int i)
strstr : INIT : inline struct dl_bw *dl_bw_of(int i) : 
strstr : if : inline struct dl_bw *dl_bw_of(int i) : 
strstr : for : inline struct dl_bw *dl_bw_of(int i) : 
strstr : while : inline struct dl_bw *dl_bw_of(int i) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	return &cpu_rq(i)->rd->dl_bw;
strstr : INIT : 	return &cpu_rq(i)->rd->dl_bw; : 
strstr : if : 	return &cpu_rq(i)->rd->dl_bw; : 
strstr : for : 	return &cpu_rq(i)->rd->dl_bw; : 
strstr : while : 	return &cpu_rq(i)->rd->dl_bw; : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : static inline int dl_bw_cpus(int i)
strstr : if : static inline int dl_bw_cpus(int i) : 
strstr : for : static inline int dl_bw_cpus(int i) : 
strstr : while : static inline int dl_bw_cpus(int i) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	struct root_domain *rd = cpu_rq(i)->rd;
strstr : INIT : 	struct root_domain *rd = cpu_rq(i)->rd; : 
strstr : if : 	struct root_domain *rd = cpu_rq(i)->rd; : 
strstr : for : 	struct root_domain *rd = cpu_rq(i)->rd; : 
strstr : while : 	struct root_domain *rd = cpu_rq(i)->rd; : 
str : 	int cpus = 0;
strstr : INIT : 	int cpus = 0; : 
strstr : if : 	int cpus = 0; : 
strstr : for : 	int cpus = 0; : 
strstr : while : 	int cpus = 0; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	for_each_cpu_and(i, rd->span, cpu_active_mask)
strstr : if : 	for_each_cpu_and(i, rd->span, cpu_active_mask) : 
strstr : for : 	for_each_cpu_and(i, rd->span, cpu_active_mask) : 
strstr : while : 	for_each_cpu_and(i, rd->span, cpu_active_mask) : 
str : 		cpus++;
strstr : INIT : 		cpus++; : 
strstr : if : 		cpus++; : 
strstr : for : 		cpus++; : 
strstr : while : 		cpus++; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	return cpus;
strstr : if : 	return cpus; : 
strstr : for : 	return cpus; : 
strstr : while : 	return cpus; : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : #else
strstr : INIT : #else : 
strstr : if : #else : 
strstr : for : #else : 
strstr : while : #else : 
str : inline struct dl_bw *dl_bw_of(int i)
strstr : INIT : inline struct dl_bw *dl_bw_of(int i) : 
strstr : if : inline struct dl_bw *dl_bw_of(int i) : 
strstr : for : inline struct dl_bw *dl_bw_of(int i) : 
strstr : while : inline struct dl_bw *dl_bw_of(int i) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	return &cpu_rq(i)->dl.dl_bw;
strstr : INIT : 	return &cpu_rq(i)->dl.dl_bw; : 
strstr : if : 	return &cpu_rq(i)->dl.dl_bw; : 
strstr : for : 	return &cpu_rq(i)->dl.dl_bw; : 
strstr : while : 	return &cpu_rq(i)->dl.dl_bw; : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : static inline int dl_bw_cpus(int i)
strstr : if : static inline int dl_bw_cpus(int i) : 
strstr : for : static inline int dl_bw_cpus(int i) : 
strstr : while : static inline int dl_bw_cpus(int i) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	return 1;
strstr : INIT : 	return 1; : 
strstr : if : 	return 1; : 
strstr : for : 	return 1; : 
strstr : while : 	return 1; : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : #endif
strstr : INIT : #endif : 
strstr : if : #endif : 
strstr : for : #endif : 
strstr : while : #endif : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : static inline
strstr : if : static inline : 
strstr : for : static inline : 
strstr : while : static inline : 
str : void __dl_clear(struct dl_bw *dl_b, u64 tsk_bw)
strstr : INIT : void __dl_clear(struct dl_bw *dl_b, u64 tsk_bw) : 
strstr : if : void __dl_clear(struct dl_bw *dl_b, u64 tsk_bw) : 
strstr : for : void __dl_clear(struct dl_bw *dl_b, u64 tsk_bw) : 
strstr : while : void __dl_clear(struct dl_bw *dl_b, u64 tsk_bw) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	dl_b->total_bw -= tsk_bw;
strstr : INIT : 	dl_b->total_bw -= tsk_bw; : 
strstr : if : 	dl_b->total_bw -= tsk_bw; : 
strstr : for : 	dl_b->total_bw -= tsk_bw; : 
strstr : while : 	dl_b->total_bw -= tsk_bw; : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : static inline
strstr : if : static inline : 
strstr : for : static inline : 
strstr : while : static inline : 
str : void __dl_add(struct dl_bw *dl_b, u64 tsk_bw)
strstr : INIT : void __dl_add(struct dl_bw *dl_b, u64 tsk_bw) : 
strstr : if : void __dl_add(struct dl_bw *dl_b, u64 tsk_bw) : 
strstr : for : void __dl_add(struct dl_bw *dl_b, u64 tsk_bw) : 
strstr : while : void __dl_add(struct dl_bw *dl_b, u64 tsk_bw) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	dl_b->total_bw += tsk_bw;
strstr : INIT : 	dl_b->total_bw += tsk_bw; : 
strstr : if : 	dl_b->total_bw += tsk_bw; : 
strstr : for : 	dl_b->total_bw += tsk_bw; : 
strstr : while : 	dl_b->total_bw += tsk_bw; : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : static inline
strstr : if : static inline : 
strstr : for : static inline : 
strstr : while : static inline : 
str : bool __dl_overflow(struct dl_bw *dl_b, int cpus, u64 old_bw, u64 new_bw)
strstr : INIT : bool __dl_overflow(struct dl_bw *dl_b, int cpus, u64 old_bw, u64 new_bw) : 
strstr : if : bool __dl_overflow(struct dl_bw *dl_b, int cpus, u64 old_bw, u64 new_bw) : 
strstr : for : bool __dl_overflow(struct dl_bw *dl_b, int cpus, u64 old_bw, u64 new_bw) : 
strstr : while : bool __dl_overflow(struct dl_bw *dl_b, int cpus, u64 old_bw, u64 new_bw) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	return dl_b->bw != -1 &&
strstr : INIT : 	return dl_b->bw != -1 && : 
strstr : if : 	return dl_b->bw != -1 && : 
strstr : for : 	return dl_b->bw != -1 && : 
strstr : while : 	return dl_b->bw != -1 && : 
str : 	       dl_b->bw * cpus < dl_b->total_bw - old_bw + new_bw;
strstr : INIT : 	       dl_b->bw * cpus < dl_b->total_bw - old_bw + new_bw; : 
strstr : if : 	       dl_b->bw * cpus < dl_b->total_bw - old_bw + new_bw; : 
strstr : for : 	       dl_b->bw * cpus < dl_b->total_bw - old_bw + new_bw; : 
strstr : while : 	       dl_b->bw * cpus < dl_b->total_bw - old_bw + new_bw; : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : /*
strstr : if : /* : 
strstr : for : /* : 
strstr : while : /* : 
str :  * We must be sure that accepting a new task (or allowing changing the
strstr : INIT :  * We must be sure that accepting a new task (or allowing changing the : 
strstr : if :  * We must be sure that accepting a new task (or allowing changing the : 
strstr : for :  * We must be sure that accepting a new task (or allowing changing the : 
strstr : while :  * We must be sure that accepting a new task (or allowing changing the : 
str :  * parameters of an existing one) is consistent with the bandwidth
strstr : INIT :  * parameters of an existing one) is consistent with the bandwidth : 
strstr : if :  * parameters of an existing one) is consistent with the bandwidth : 
strstr : for :  * parameters of an existing one) is consistent with the bandwidth : 
strstr : while :  * parameters of an existing one) is consistent with the bandwidth : 
str :  * constraints. If yes, this function also accordingly updates the currently
strstr : INIT :  * constraints. If yes, this function also accordingly updates the currently : 
strstr : if :  * constraints. If yes, this function also accordingly updates the currently : 
strstr : for :  * constraints. If yes, this function also accordingly updates the currently : 
strstr : while :  * constraints. If yes, this function also accordingly updates the currently : 
str :  * allocated bandwidth to reflect the new situation.
strstr : INIT :  * allocated bandwidth to reflect the new situation. : 
strstr : if :  * allocated bandwidth to reflect the new situation. : 
strstr : for :  * allocated bandwidth to reflect the new situation. : 
strstr : while :  * allocated bandwidth to reflect the new situation. : 
str :  *
strstr : INIT :  * : 
strstr : if :  * : 
strstr : for :  * : 
strstr : while :  * : 
str :  * This function is called while holding p's rq->lock.
strstr : INIT :  * This function is called while holding p's rq->lock. : 
strstr : if :  * This function is called while holding p's rq->lock. : 
strstr : for :  * This function is called while holding p's rq->lock. : 
strstr : while :  * This function is called while holding p's rq->lock. : 
str :  */
strstr : INIT :  */ : 
strstr : if :  */ : 
strstr : for :  */ : 
strstr : while :  */ : 
str : static int dl_overflow(struct task_struct *p, int policy,
strstr : INIT : static int dl_overflow(struct task_struct *p, int policy, : 
strstr : if : static int dl_overflow(struct task_struct *p, int policy, : 
strstr : for : static int dl_overflow(struct task_struct *p, int policy, : 
strstr : while : static int dl_overflow(struct task_struct *p, int policy, : 
str : 		       const struct sched_attr *attr)
strstr : INIT : 		       const struct sched_attr *attr) : 
strstr : if : 		       const struct sched_attr *attr) : 
strstr : for : 		       const struct sched_attr *attr) : 
strstr : while : 		       const struct sched_attr *attr) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	struct dl_bw *dl_b = dl_bw_of(task_cpu(p));
strstr : if : 	struct dl_bw *dl_b = dl_bw_of(task_cpu(p)); : 
strstr : for : 	struct dl_bw *dl_b = dl_bw_of(task_cpu(p)); : 
strstr : while : 	struct dl_bw *dl_b = dl_bw_of(task_cpu(p)); : 
str : 	u64 period = attr->sched_period ?: attr->sched_deadline;
strstr : INIT : 	u64 period = attr->sched_period ?: attr->sched_deadline; : 
strstr : if : 	u64 period = attr->sched_period ?: attr->sched_deadline; : 
strstr : for : 	u64 period = attr->sched_period ?: attr->sched_deadline; : 
strstr : while : 	u64 period = attr->sched_period ?: attr->sched_deadline; : 
str : 	u64 runtime = attr->sched_runtime;
strstr : INIT : 	u64 runtime = attr->sched_runtime; : 
strstr : if : 	u64 runtime = attr->sched_runtime; : 
strstr : for : 	u64 runtime = attr->sched_runtime; : 
strstr : while : 	u64 runtime = attr->sched_runtime; : 
str : 	u64 new_bw = dl_policy(policy) ? to_ratio(period, runtime) : 0;
strstr : INIT : 	u64 new_bw = dl_policy(policy) ? to_ratio(period, runtime) : 0; : 
strstr : if : 	u64 new_bw = dl_policy(policy) ? to_ratio(period, runtime) : 0; : 
strstr : for : 	u64 new_bw = dl_policy(policy) ? to_ratio(period, runtime) : 0; : 
strstr : while : 	u64 new_bw = dl_policy(policy) ? to_ratio(period, runtime) : 0; : 
str : 	int cpus, err = -1;
strstr : INIT : 	int cpus, err = -1; : 
strstr : if : 	int cpus, err = -1; : 
strstr : for : 	int cpus, err = -1; : 
strstr : while : 	int cpus, err = -1; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	if (new_bw == p->dl.dl_bw)
strstr : if : 	if (new_bw == p->dl.dl_bw) : 
strstr : for : 	if (new_bw == p->dl.dl_bw) : 
strstr : while : 	if (new_bw == p->dl.dl_bw) : 
str : 		return 0;
strstr : INIT : 		return 0; : 
strstr : if : 		return 0; : 
strstr : for : 		return 0; : 
strstr : while : 		return 0; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	/*
strstr : if : 	/* : 
strstr : for : 	/* : 
strstr : while : 	/* : 
str : 	 * Either if a task, enters, leave, or stays -deadline but changes
strstr : INIT : 	 * Either if a task, enters, leave, or stays -deadline but changes : 
strstr : if : 	 * Either if a task, enters, leave, or stays -deadline but changes : 
strstr : for : 	 * Either if a task, enters, leave, or stays -deadline but changes : 
strstr : while : 	 * Either if a task, enters, leave, or stays -deadline but changes : 
str : 	 * its parameters, we may need to update accordingly the total
strstr : INIT : 	 * its parameters, we may need to update accordingly the total : 
strstr : if : 	 * its parameters, we may need to update accordingly the total : 
strstr : for : 	 * its parameters, we may need to update accordingly the total : 
strstr : while : 	 * its parameters, we may need to update accordingly the total : 
str : 	 * allocated bandwidth of the container.
strstr : INIT : 	 * allocated bandwidth of the container. : 
strstr : if : 	 * allocated bandwidth of the container. : 
strstr : for : 	 * allocated bandwidth of the container. : 
strstr : while : 	 * allocated bandwidth of the container. : 
str : 	 */
strstr : INIT : 	 */ : 
strstr : if : 	 */ : 
strstr : for : 	 */ : 
strstr : while : 	 */ : 
str : 	raw_spin_lock(&dl_b->lock);
strstr : INIT : 	raw_spin_lock(&dl_b->lock); : 
strstr : if : 	raw_spin_lock(&dl_b->lock); : 
strstr : for : 	raw_spin_lock(&dl_b->lock); : 
strstr : while : 	raw_spin_lock(&dl_b->lock); : 
str : 	cpus = dl_bw_cpus(task_cpu(p));
strstr : INIT : 	cpus = dl_bw_cpus(task_cpu(p)); : 
strstr : if : 	cpus = dl_bw_cpus(task_cpu(p)); : 
strstr : for : 	cpus = dl_bw_cpus(task_cpu(p)); : 
strstr : while : 	cpus = dl_bw_cpus(task_cpu(p)); : 
str : 	if (dl_policy(policy) && !task_has_dl_policy(p) &&
strstr : INIT : 	if (dl_policy(policy) && !task_has_dl_policy(p) && : 
strstr : if : 	if (dl_policy(policy) && !task_has_dl_policy(p) && : 
strstr : for : 	if (dl_policy(policy) && !task_has_dl_policy(p) && : 
strstr : while : 	if (dl_policy(policy) && !task_has_dl_policy(p) && : 
str : 	    !__dl_overflow(dl_b, cpus, 0, new_bw)) {
strstr : INIT : 	    !__dl_overflow(dl_b, cpus, 0, new_bw)) { : 
strstr : if : 	    !__dl_overflow(dl_b, cpus, 0, new_bw)) { : 
strstr : for : 	    !__dl_overflow(dl_b, cpus, 0, new_bw)) { : 
strstr : while : 	    !__dl_overflow(dl_b, cpus, 0, new_bw)) { : 
str : 		__dl_add(dl_b, new_bw);
strstr : INIT : 		__dl_add(dl_b, new_bw); : 
strstr : if : 		__dl_add(dl_b, new_bw); : 
strstr : for : 		__dl_add(dl_b, new_bw); : 
strstr : while : 		__dl_add(dl_b, new_bw); : 
str : 		err = 0;
strstr : INIT : 		err = 0; : 
strstr : if : 		err = 0; : 
strstr : for : 		err = 0; : 
strstr : while : 		err = 0; : 
str : 	} else if (dl_policy(policy) && task_has_dl_policy(p) &&
strstr : INIT : 	} else if (dl_policy(policy) && task_has_dl_policy(p) && : 
strstr : if : 	} else if (dl_policy(policy) && task_has_dl_policy(p) && : 
strstr : for : 	} else if (dl_policy(policy) && task_has_dl_policy(p) && : 
strstr : while : 	} else if (dl_policy(policy) && task_has_dl_policy(p) && : 
str : 		   !__dl_overflow(dl_b, cpus, p->dl.dl_bw, new_bw)) {
strstr : INIT : 		   !__dl_overflow(dl_b, cpus, p->dl.dl_bw, new_bw)) { : 
strstr : if : 		   !__dl_overflow(dl_b, cpus, p->dl.dl_bw, new_bw)) { : 
strstr : for : 		   !__dl_overflow(dl_b, cpus, p->dl.dl_bw, new_bw)) { : 
strstr : while : 		   !__dl_overflow(dl_b, cpus, p->dl.dl_bw, new_bw)) { : 
str : 		__dl_clear(dl_b, p->dl.dl_bw);
strstr : INIT : 		__dl_clear(dl_b, p->dl.dl_bw); : 
strstr : if : 		__dl_clear(dl_b, p->dl.dl_bw); : 
strstr : for : 		__dl_clear(dl_b, p->dl.dl_bw); : 
strstr : while : 		__dl_clear(dl_b, p->dl.dl_bw); : 
str : 		__dl_add(dl_b, new_bw);
strstr : INIT : 		__dl_add(dl_b, new_bw); : 
strstr : if : 		__dl_add(dl_b, new_bw); : 
strstr : for : 		__dl_add(dl_b, new_bw); : 
strstr : while : 		__dl_add(dl_b, new_bw); : 
str : 		err = 0;
strstr : INIT : 		err = 0; : 
strstr : if : 		err = 0; : 
strstr : for : 		err = 0; : 
strstr : while : 		err = 0; : 
str : 	} else if (!dl_policy(policy) && task_has_dl_policy(p)) {
strstr : INIT : 	} else if (!dl_policy(policy) && task_has_dl_policy(p)) { : 
strstr : if : 	} else if (!dl_policy(policy) && task_has_dl_policy(p)) { : 
strstr : for : 	} else if (!dl_policy(policy) && task_has_dl_policy(p)) { : 
strstr : while : 	} else if (!dl_policy(policy) && task_has_dl_policy(p)) { : 
str : 		__dl_clear(dl_b, p->dl.dl_bw);
strstr : INIT : 		__dl_clear(dl_b, p->dl.dl_bw); : 
strstr : if : 		__dl_clear(dl_b, p->dl.dl_bw); : 
strstr : for : 		__dl_clear(dl_b, p->dl.dl_bw); : 
strstr : while : 		__dl_clear(dl_b, p->dl.dl_bw); : 
str : 		err = 0;
strstr : INIT : 		err = 0; : 
strstr : if : 		err = 0; : 
strstr : for : 		err = 0; : 
strstr : while : 		err = 0; : 
str : 	}
strstr : INIT : 	} : 
strstr : if : 	} : 
strstr : for : 	} : 
strstr : while : 	} : 
str : 	raw_spin_unlock(&dl_b->lock);
strstr : INIT : 	raw_spin_unlock(&dl_b->lock); : 
strstr : if : 	raw_spin_unlock(&dl_b->lock); : 
strstr : for : 	raw_spin_unlock(&dl_b->lock); : 
strstr : while : 	raw_spin_unlock(&dl_b->lock); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	return err;
strstr : if : 	return err; : 
strstr : for : 	return err; : 
strstr : while : 	return err; : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : extern void init_dl_bw(struct dl_bw *dl_b);
strstr : if : extern void init_dl_bw(struct dl_bw *dl_b); : 
strstr : for : extern void init_dl_bw(struct dl_bw *dl_b); : 
strstr : while : extern void init_dl_bw(struct dl_bw *dl_b); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : /*
strstr : if : /* : 
strstr : for : /* : 
strstr : while : /* : 
str :  * wake_up_new_task - wake up a newly created task for the first time.
strstr : INIT :  * wake_up_new_task - wake up a newly created task for the first time. : 
strstr : if :  * wake_up_new_task - wake up a newly created task for the first time. : 
strstr : for :  * wake_up_new_task - wake up a newly created task for the first time. : 
strstr : while :  * wake_up_new_task - wake up a newly created task for the first time. : 
str :  *
strstr : INIT :  * : 
strstr : if :  * : 
strstr : for :  * : 
strstr : while :  * : 
str :  * This function will do some initial scheduler statistics housekeeping
strstr : INIT :  * This function will do some initial scheduler statistics housekeeping : 
strstr : if :  * This function will do some initial scheduler statistics housekeeping : 
strstr : for :  * This function will do some initial scheduler statistics housekeeping : 
strstr : while :  * This function will do some initial scheduler statistics housekeeping : 
str :  * that must be done for every newly created context, then puts the task
strstr : INIT :  * that must be done for every newly created context, then puts the task : 
strstr : if :  * that must be done for every newly created context, then puts the task : 
strstr : for :  * that must be done for every newly created context, then puts the task : 
strstr : while :  * that must be done for every newly created context, then puts the task : 
str :  * on the runqueue and wakes it.
strstr : INIT :  * on the runqueue and wakes it. : 
strstr : if :  * on the runqueue and wakes it. : 
strstr : for :  * on the runqueue and wakes it. : 
strstr : while :  * on the runqueue and wakes it. : 
str :  */
strstr : INIT :  */ : 
strstr : if :  */ : 
strstr : for :  */ : 
strstr : while :  */ : 
str : void wake_up_new_task(struct task_struct *p)
strstr : INIT : void wake_up_new_task(struct task_struct *p) : 
strstr : if : void wake_up_new_task(struct task_struct *p) : 
strstr : for : void wake_up_new_task(struct task_struct *p) : 
strstr : while : void wake_up_new_task(struct task_struct *p) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	unsigned long flags;
strstr : INIT : 	unsigned long flags; : 
strstr : if : 	unsigned long flags; : 
strstr : for : 	unsigned long flags; : 
strstr : while : 	unsigned long flags; : 
str : 	struct rq *rq;
strstr : INIT : 	struct rq *rq; : 
strstr : if : 	struct rq *rq; : 
strstr : for : 	struct rq *rq; : 
strstr : while : 	struct rq *rq; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	raw_spin_lock_irqsave(&p->pi_lock, flags);
strstr : if : 	raw_spin_lock_irqsave(&p->pi_lock, flags); : 
strstr : for : 	raw_spin_lock_irqsave(&p->pi_lock, flags); : 
strstr : while : 	raw_spin_lock_irqsave(&p->pi_lock, flags); : 
str : #ifdef CONFIG_SMP
strstr : INIT : #ifdef CONFIG_SMP : 
strstr : if : #ifdef CONFIG_SMP : 
strstr : for : #ifdef CONFIG_SMP : 
strstr : while : #ifdef CONFIG_SMP : 
str : 	/*
strstr : INIT : 	/* : 
strstr : if : 	/* : 
strstr : for : 	/* : 
strstr : while : 	/* : 
str : 	 * Fork balancing, do it here and not earlier because:
strstr : INIT : 	 * Fork balancing, do it here and not earlier because: : 
strstr : if : 	 * Fork balancing, do it here and not earlier because: : 
strstr : for : 	 * Fork balancing, do it here and not earlier because: : 
strstr : while : 	 * Fork balancing, do it here and not earlier because: : 
str : 	 *  - cpus_allowed can change in the fork path
strstr : INIT : 	 *  - cpus_allowed can change in the fork path : 
strstr : if : 	 *  - cpus_allowed can change in the fork path : 
strstr : for : 	 *  - cpus_allowed can change in the fork path : 
strstr : while : 	 *  - cpus_allowed can change in the fork path : 
str : 	 *  - any previously selected cpu might disappear through hotplug
strstr : INIT : 	 *  - any previously selected cpu might disappear through hotplug : 
strstr : if : 	 *  - any previously selected cpu might disappear through hotplug : 
strstr : for : 	 *  - any previously selected cpu might disappear through hotplug : 
strstr : while : 	 *  - any previously selected cpu might disappear through hotplug : 
str : 	 */
strstr : INIT : 	 */ : 
strstr : if : 	 */ : 
strstr : for : 	 */ : 
strstr : while : 	 */ : 
str : 	set_task_cpu(p, select_task_rq(p, task_cpu(p), SD_BALANCE_FORK, 0));
strstr : INIT : 	set_task_cpu(p, select_task_rq(p, task_cpu(p), SD_BALANCE_FORK, 0)); : 
strstr : if : 	set_task_cpu(p, select_task_rq(p, task_cpu(p), SD_BALANCE_FORK, 0)); : 
strstr : for : 	set_task_cpu(p, select_task_rq(p, task_cpu(p), SD_BALANCE_FORK, 0)); : 
strstr : while : 	set_task_cpu(p, select_task_rq(p, task_cpu(p), SD_BALANCE_FORK, 0)); : 
str : #endif
strstr : INIT : #endif : 
strstr : if : #endif : 
strstr : for : #endif : 
strstr : while : #endif : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	/* Initialize new task's runnable average */
strstr : if : 	/* Initialize new task's runnable average */ : 
strstr : for : 	/* Initialize new task's runnable average */ : 
strstr : while : 	/* Initialize new task's runnable average */ : 
str : 	init_task_runnable_average(p);
strstr : INIT : 	init_task_runnable_average(p); : 
strstr : if : 	init_task_runnable_average(p); : 
strstr : for : 	init_task_runnable_average(p); : 
strstr : while : 	init_task_runnable_average(p); : 
str : 	rq = __task_rq_lock(p);
strstr : INIT : 	rq = __task_rq_lock(p); : 
strstr : if : 	rq = __task_rq_lock(p); : 
strstr : for : 	rq = __task_rq_lock(p); : 
strstr : while : 	rq = __task_rq_lock(p); : 
str : 	activate_task(rq, p, 0);
strstr : INIT : 	activate_task(rq, p, 0); : 
strstr : if : 	activate_task(rq, p, 0); : 
strstr : for : 	activate_task(rq, p, 0); : 
strstr : while : 	activate_task(rq, p, 0); : 
str : 	p->on_rq = 1;
strstr : INIT : 	p->on_rq = 1; : 
strstr : if : 	p->on_rq = 1; : 
strstr : for : 	p->on_rq = 1; : 
strstr : while : 	p->on_rq = 1; : 
str : 	trace_sched_wakeup_new(p, true);
strstr : INIT : 	trace_sched_wakeup_new(p, true); : 
strstr : if : 	trace_sched_wakeup_new(p, true); : 
strstr : for : 	trace_sched_wakeup_new(p, true); : 
strstr : while : 	trace_sched_wakeup_new(p, true); : 
str : 	check_preempt_curr(rq, p, WF_FORK);
strstr : INIT : 	check_preempt_curr(rq, p, WF_FORK); : 
strstr : if : 	check_preempt_curr(rq, p, WF_FORK); : 
strstr : for : 	check_preempt_curr(rq, p, WF_FORK); : 
strstr : while : 	check_preempt_curr(rq, p, WF_FORK); : 
str : #ifdef CONFIG_SMP
strstr : INIT : #ifdef CONFIG_SMP : 
strstr : if : #ifdef CONFIG_SMP : 
strstr : for : #ifdef CONFIG_SMP : 
strstr : while : #ifdef CONFIG_SMP : 
str : 	if (p->sched_class->task_woken)
strstr : INIT : 	if (p->sched_class->task_woken) : 
strstr : if : 	if (p->sched_class->task_woken) : 
strstr : for : 	if (p->sched_class->task_woken) : 
strstr : while : 	if (p->sched_class->task_woken) : 
str : 		p->sched_class->task_woken(rq, p);
strstr : INIT : 		p->sched_class->task_woken(rq, p); : 
strstr : if : 		p->sched_class->task_woken(rq, p); : 
strstr : for : 		p->sched_class->task_woken(rq, p); : 
strstr : while : 		p->sched_class->task_woken(rq, p); : 
str : #endif
strstr : INIT : #endif : 
strstr : if : #endif : 
strstr : for : #endif : 
strstr : while : #endif : 
str : 	task_rq_unlock(rq, p, &flags);
strstr : INIT : 	task_rq_unlock(rq, p, &flags); : 
strstr : if : 	task_rq_unlock(rq, p, &flags); : 
strstr : for : 	task_rq_unlock(rq, p, &flags); : 
strstr : while : 	task_rq_unlock(rq, p, &flags); : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : #ifdef CONFIG_PREEMPT_NOTIFIERS
strstr : if : #ifdef CONFIG_PREEMPT_NOTIFIERS : 
strstr : for : #ifdef CONFIG_PREEMPT_NOTIFIERS : 
strstr : while : #ifdef CONFIG_PREEMPT_NOTIFIERS : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : /**
strstr : if : /** : 
strstr : for : /** : 
strstr : while : /** : 
str :  * preempt_notifier_register - tell me when current is being preempted & rescheduled
strstr : INIT :  * preempt_notifier_register - tell me when current is being preempted & rescheduled : 
strstr : if :  * preempt_notifier_register - tell me when current is being preempted & rescheduled : 
strstr : for :  * preempt_notifier_register - tell me when current is being preempted & rescheduled : 
strstr : while :  * preempt_notifier_register - tell me when current is being preempted & rescheduled : 
str :  * @notifier: notifier struct to register
strstr : INIT :  * @notifier: notifier struct to register : 
strstr : if :  * @notifier: notifier struct to register : 
strstr : for :  * @notifier: notifier struct to register : 
strstr : while :  * @notifier: notifier struct to register : 
str :  */
strstr : INIT :  */ : 
strstr : if :  */ : 
strstr : for :  */ : 
strstr : while :  */ : 
str : void preempt_notifier_register(struct preempt_notifier *notifier)
strstr : INIT : void preempt_notifier_register(struct preempt_notifier *notifier) : 
strstr : if : void preempt_notifier_register(struct preempt_notifier *notifier) : 
strstr : for : void preempt_notifier_register(struct preempt_notifier *notifier) : 
strstr : while : void preempt_notifier_register(struct preempt_notifier *notifier) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	hlist_add_head(&notifier->link, &current->preempt_notifiers);
strstr : INIT : 	hlist_add_head(&notifier->link, &current->preempt_notifiers); : 
strstr : if : 	hlist_add_head(&notifier->link, &current->preempt_notifiers); : 
strstr : for : 	hlist_add_head(&notifier->link, &current->preempt_notifiers); : 
strstr : while : 	hlist_add_head(&notifier->link, &current->preempt_notifiers); : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : EXPORT_SYMBOL_GPL(preempt_notifier_register);
strstr : INIT : EXPORT_SYMBOL_GPL(preempt_notifier_register); : 
strstr : if : EXPORT_SYMBOL_GPL(preempt_notifier_register); : 
strstr : for : EXPORT_SYMBOL_GPL(preempt_notifier_register); : 
strstr : while : EXPORT_SYMBOL_GPL(preempt_notifier_register); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : /**
strstr : if : /** : 
strstr : for : /** : 
strstr : while : /** : 
str :  * preempt_notifier_unregister - no longer interested in preemption notifications
strstr : INIT :  * preempt_notifier_unregister - no longer interested in preemption notifications : 
strstr : if :  * preempt_notifier_unregister - no longer interested in preemption notifications : 
strstr : for :  * preempt_notifier_unregister - no longer interested in preemption notifications : 
strstr : while :  * preempt_notifier_unregister - no longer interested in preemption notifications : 
str :  * @notifier: notifier struct to unregister
strstr : INIT :  * @notifier: notifier struct to unregister : 
strstr : if :  * @notifier: notifier struct to unregister : 
strstr : for :  * @notifier: notifier struct to unregister : 
strstr : while :  * @notifier: notifier struct to unregister : 
str :  *
strstr : INIT :  * : 
strstr : if :  * : 
strstr : for :  * : 
strstr : while :  * : 
str :  * This is safe to call from within a preemption notifier.
strstr : INIT :  * This is safe to call from within a preemption notifier. : 
strstr : if :  * This is safe to call from within a preemption notifier. : 
strstr : for :  * This is safe to call from within a preemption notifier. : 
strstr : while :  * This is safe to call from within a preemption notifier. : 
str :  */
strstr : INIT :  */ : 
strstr : if :  */ : 
strstr : for :  */ : 
strstr : while :  */ : 
str : void preempt_notifier_unregister(struct preempt_notifier *notifier)
strstr : INIT : void preempt_notifier_unregister(struct preempt_notifier *notifier) : 
strstr : if : void preempt_notifier_unregister(struct preempt_notifier *notifier) : 
strstr : for : void preempt_notifier_unregister(struct preempt_notifier *notifier) : 
strstr : while : void preempt_notifier_unregister(struct preempt_notifier *notifier) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	hlist_del(&notifier->link);
strstr : INIT : 	hlist_del(&notifier->link); : 
strstr : if : 	hlist_del(&notifier->link); : 
strstr : for : 	hlist_del(&notifier->link); : 
strstr : while : 	hlist_del(&notifier->link); : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : EXPORT_SYMBOL_GPL(preempt_notifier_unregister);
strstr : INIT : EXPORT_SYMBOL_GPL(preempt_notifier_unregister); : 
strstr : if : EXPORT_SYMBOL_GPL(preempt_notifier_unregister); : 
strstr : for : EXPORT_SYMBOL_GPL(preempt_notifier_unregister); : 
strstr : while : EXPORT_SYMBOL_GPL(preempt_notifier_unregister); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : static void fire_sched_in_preempt_notifiers(struct task_struct *curr)
strstr : if : static void fire_sched_in_preempt_notifiers(struct task_struct *curr) : 
strstr : for : static void fire_sched_in_preempt_notifiers(struct task_struct *curr) : 
strstr : while : static void fire_sched_in_preempt_notifiers(struct task_struct *curr) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	struct preempt_notifier *notifier;
strstr : INIT : 	struct preempt_notifier *notifier; : 
strstr : if : 	struct preempt_notifier *notifier; : 
strstr : for : 	struct preempt_notifier *notifier; : 
strstr : while : 	struct preempt_notifier *notifier; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	hlist_for_each_entry(notifier, &curr->preempt_notifiers, link)
strstr : if : 	hlist_for_each_entry(notifier, &curr->preempt_notifiers, link) : 
strstr : for : 	hlist_for_each_entry(notifier, &curr->preempt_notifiers, link) : 
strstr : while : 	hlist_for_each_entry(notifier, &curr->preempt_notifiers, link) : 
str : 		notifier->ops->sched_in(notifier, raw_smp_processor_id());
strstr : INIT : 		notifier->ops->sched_in(notifier, raw_smp_processor_id()); : 
strstr : if : 		notifier->ops->sched_in(notifier, raw_smp_processor_id()); : 
strstr : for : 		notifier->ops->sched_in(notifier, raw_smp_processor_id()); : 
strstr : while : 		notifier->ops->sched_in(notifier, raw_smp_processor_id()); : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : static void
strstr : if : static void : 
strstr : for : static void : 
strstr : while : static void : 
str : fire_sched_out_preempt_notifiers(struct task_struct *curr,
strstr : INIT : fire_sched_out_preempt_notifiers(struct task_struct *curr, : 
strstr : if : fire_sched_out_preempt_notifiers(struct task_struct *curr, : 
strstr : for : fire_sched_out_preempt_notifiers(struct task_struct *curr, : 
strstr : while : fire_sched_out_preempt_notifiers(struct task_struct *curr, : 
str : 				 struct task_struct *next)
strstr : INIT : 				 struct task_struct *next) : 
strstr : if : 				 struct task_struct *next) : 
strstr : for : 				 struct task_struct *next) : 
strstr : while : 				 struct task_struct *next) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	struct preempt_notifier *notifier;
strstr : INIT : 	struct preempt_notifier *notifier; : 
strstr : if : 	struct preempt_notifier *notifier; : 
strstr : for : 	struct preempt_notifier *notifier; : 
strstr : while : 	struct preempt_notifier *notifier; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	hlist_for_each_entry(notifier, &curr->preempt_notifiers, link)
strstr : if : 	hlist_for_each_entry(notifier, &curr->preempt_notifiers, link) : 
strstr : for : 	hlist_for_each_entry(notifier, &curr->preempt_notifiers, link) : 
strstr : while : 	hlist_for_each_entry(notifier, &curr->preempt_notifiers, link) : 
str : 		notifier->ops->sched_out(notifier, next);
strstr : INIT : 		notifier->ops->sched_out(notifier, next); : 
strstr : if : 		notifier->ops->sched_out(notifier, next); : 
strstr : for : 		notifier->ops->sched_out(notifier, next); : 
strstr : while : 		notifier->ops->sched_out(notifier, next); : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : #else /* !CONFIG_PREEMPT_NOTIFIERS */
strstr : if : #else /* !CONFIG_PREEMPT_NOTIFIERS */ : 
strstr : for : #else /* !CONFIG_PREEMPT_NOTIFIERS */ : 
strstr : while : #else /* !CONFIG_PREEMPT_NOTIFIERS */ : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : static void fire_sched_in_preempt_notifiers(struct task_struct *curr)
strstr : if : static void fire_sched_in_preempt_notifiers(struct task_struct *curr) : 
strstr : for : static void fire_sched_in_preempt_notifiers(struct task_struct *curr) : 
strstr : while : static void fire_sched_in_preempt_notifiers(struct task_struct *curr) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : static void
strstr : if : static void : 
strstr : for : static void : 
strstr : while : static void : 
str : fire_sched_out_preempt_notifiers(struct task_struct *curr,
strstr : INIT : fire_sched_out_preempt_notifiers(struct task_struct *curr, : 
strstr : if : fire_sched_out_preempt_notifiers(struct task_struct *curr, : 
strstr : for : fire_sched_out_preempt_notifiers(struct task_struct *curr, : 
strstr : while : fire_sched_out_preempt_notifiers(struct task_struct *curr, : 
str : 				 struct task_struct *next)
strstr : INIT : 				 struct task_struct *next) : 
strstr : if : 				 struct task_struct *next) : 
strstr : for : 				 struct task_struct *next) : 
strstr : while : 				 struct task_struct *next) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : #endif /* CONFIG_PREEMPT_NOTIFIERS */
strstr : if : #endif /* CONFIG_PREEMPT_NOTIFIERS */ : 
strstr : for : #endif /* CONFIG_PREEMPT_NOTIFIERS */ : 
strstr : while : #endif /* CONFIG_PREEMPT_NOTIFIERS */ : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : /**
strstr : if : /** : 
strstr : for : /** : 
strstr : while : /** : 
str :  * prepare_task_switch - prepare to switch tasks
strstr : INIT :  * prepare_task_switch - prepare to switch tasks : 
strstr : if :  * prepare_task_switch - prepare to switch tasks : 
strstr : for :  * prepare_task_switch - prepare to switch tasks : 
strstr : while :  * prepare_task_switch - prepare to switch tasks : 
str :  * @rq: the runqueue preparing to switch
strstr : INIT :  * @rq: the runqueue preparing to switch : 
strstr : if :  * @rq: the runqueue preparing to switch : 
strstr : for :  * @rq: the runqueue preparing to switch : 
strstr : while :  * @rq: the runqueue preparing to switch : 
str :  * @prev: the current task that is being switched out
strstr : INIT :  * @prev: the current task that is being switched out : 
strstr : if :  * @prev: the current task that is being switched out : 
strstr : for :  * @prev: the current task that is being switched out : 
strstr : while :  * @prev: the current task that is being switched out : 
str :  * @next: the task we are going to switch to.
strstr : INIT :  * @next: the task we are going to switch to. : 
strstr : if :  * @next: the task we are going to switch to. : 
strstr : for :  * @next: the task we are going to switch to. : 
strstr : while :  * @next: the task we are going to switch to. : 
str :  *
strstr : INIT :  * : 
strstr : if :  * : 
strstr : for :  * : 
strstr : while :  * : 
str :  * This is called with the rq lock held and interrupts off. It must
strstr : INIT :  * This is called with the rq lock held and interrupts off. It must : 
strstr : if :  * This is called with the rq lock held and interrupts off. It must : 
strstr : for :  * This is called with the rq lock held and interrupts off. It must : 
strstr : while :  * This is called with the rq lock held and interrupts off. It must : 
str :  * be paired with a subsequent finish_task_switch after the context
strstr : INIT :  * be paired with a subsequent finish_task_switch after the context : 
strstr : if :  * be paired with a subsequent finish_task_switch after the context : 
strstr : for :  * be paired with a subsequent finish_task_switch after the context : 
strstr : while :  * be paired with a subsequent finish_task_switch after the context : 
str :  * switch.
strstr : INIT :  * switch. : 
strstr : if :  * switch. : 
strstr : for :  * switch. : 
strstr : while :  * switch. : 
str :  *
strstr : INIT :  * : 
strstr : if :  * : 
strstr : for :  * : 
strstr : while :  * : 
str :  * prepare_task_switch sets up locking and calls architecture specific
strstr : INIT :  * prepare_task_switch sets up locking and calls architecture specific : 
strstr : if :  * prepare_task_switch sets up locking and calls architecture specific : 
strstr : for :  * prepare_task_switch sets up locking and calls architecture specific : 
strstr : while :  * prepare_task_switch sets up locking and calls architecture specific : 
str :  * hooks.
strstr : INIT :  * hooks. : 
strstr : if :  * hooks. : 
strstr : for :  * hooks. : 
strstr : while :  * hooks. : 
str :  */
strstr : INIT :  */ : 
strstr : if :  */ : 
strstr : for :  */ : 
strstr : while :  */ : 
str : static inline void
strstr : INIT : static inline void : 
strstr : if : static inline void : 
strstr : for : static inline void : 
strstr : while : static inline void : 
str : prepare_task_switch(struct rq *rq, struct task_struct *prev,
strstr : INIT : prepare_task_switch(struct rq *rq, struct task_struct *prev, : 
strstr : if : prepare_task_switch(struct rq *rq, struct task_struct *prev, : 
strstr : for : prepare_task_switch(struct rq *rq, struct task_struct *prev, : 
strstr : while : prepare_task_switch(struct rq *rq, struct task_struct *prev, : 
str : 		    struct task_struct *next)
strstr : INIT : 		    struct task_struct *next) : 
strstr : if : 		    struct task_struct *next) : 
strstr : for : 		    struct task_struct *next) : 
strstr : while : 		    struct task_struct *next) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	trace_sched_switch(prev, next);
strstr : INIT : 	trace_sched_switch(prev, next); : 
strstr : if : 	trace_sched_switch(prev, next); : 
strstr : for : 	trace_sched_switch(prev, next); : 
strstr : while : 	trace_sched_switch(prev, next); : 
str : 	sched_info_switch(rq, prev, next);
strstr : INIT : 	sched_info_switch(rq, prev, next); : 
strstr : if : 	sched_info_switch(rq, prev, next); : 
strstr : for : 	sched_info_switch(rq, prev, next); : 
strstr : while : 	sched_info_switch(rq, prev, next); : 
str : 	perf_event_task_sched_out(prev, next);
strstr : INIT : 	perf_event_task_sched_out(prev, next); : 
strstr : if : 	perf_event_task_sched_out(prev, next); : 
strstr : for : 	perf_event_task_sched_out(prev, next); : 
strstr : while : 	perf_event_task_sched_out(prev, next); : 
str : 	fire_sched_out_preempt_notifiers(prev, next);
strstr : INIT : 	fire_sched_out_preempt_notifiers(prev, next); : 
strstr : if : 	fire_sched_out_preempt_notifiers(prev, next); : 
strstr : for : 	fire_sched_out_preempt_notifiers(prev, next); : 
strstr : while : 	fire_sched_out_preempt_notifiers(prev, next); : 
str : 	prepare_lock_switch(rq, next);
strstr : INIT : 	prepare_lock_switch(rq, next); : 
strstr : if : 	prepare_lock_switch(rq, next); : 
strstr : for : 	prepare_lock_switch(rq, next); : 
strstr : while : 	prepare_lock_switch(rq, next); : 
str : 	prepare_arch_switch(next);
strstr : INIT : 	prepare_arch_switch(next); : 
strstr : if : 	prepare_arch_switch(next); : 
strstr : for : 	prepare_arch_switch(next); : 
strstr : while : 	prepare_arch_switch(next); : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : /**
strstr : if : /** : 
strstr : for : /** : 
strstr : while : /** : 
str :  * finish_task_switch - clean up after a task-switch
strstr : INIT :  * finish_task_switch - clean up after a task-switch : 
strstr : if :  * finish_task_switch - clean up after a task-switch : 
strstr : for :  * finish_task_switch - clean up after a task-switch : 
strstr : while :  * finish_task_switch - clean up after a task-switch : 
str :  * @rq: runqueue associated with task-switch
strstr : INIT :  * @rq: runqueue associated with task-switch : 
strstr : if :  * @rq: runqueue associated with task-switch : 
strstr : for :  * @rq: runqueue associated with task-switch : 
strstr : while :  * @rq: runqueue associated with task-switch : 
str :  * @prev: the thread we just switched away from.
strstr : INIT :  * @prev: the thread we just switched away from. : 
strstr : if :  * @prev: the thread we just switched away from. : 
strstr : for :  * @prev: the thread we just switched away from. : 
strstr : while :  * @prev: the thread we just switched away from. : 
str :  *
strstr : INIT :  * : 
strstr : if :  * : 
strstr : for :  * : 
strstr : while :  * : 
str :  * finish_task_switch must be called after the context switch, paired
strstr : INIT :  * finish_task_switch must be called after the context switch, paired : 
strstr : if :  * finish_task_switch must be called after the context switch, paired : 
strstr : for :  * finish_task_switch must be called after the context switch, paired : 
strstr : while :  * finish_task_switch must be called after the context switch, paired : 
str :  * with a prepare_task_switch call before the context switch.
strstr : INIT :  * with a prepare_task_switch call before the context switch. : 
strstr : if :  * with a prepare_task_switch call before the context switch. : 
strstr : for :  * with a prepare_task_switch call before the context switch. : 
strstr : while :  * with a prepare_task_switch call before the context switch. : 
str :  * finish_task_switch will reconcile locking set up by prepare_task_switch,
strstr : INIT :  * finish_task_switch will reconcile locking set up by prepare_task_switch, : 
strstr : if :  * finish_task_switch will reconcile locking set up by prepare_task_switch, : 
strstr : for :  * finish_task_switch will reconcile locking set up by prepare_task_switch, : 
strstr : while :  * finish_task_switch will reconcile locking set up by prepare_task_switch, : 
str :  * and do any other architecture-specific cleanup actions.
strstr : INIT :  * and do any other architecture-specific cleanup actions. : 
strstr : if :  * and do any other architecture-specific cleanup actions. : 
strstr : for :  * and do any other architecture-specific cleanup actions. : 
strstr : while :  * and do any other architecture-specific cleanup actions. : 
str :  *
strstr : INIT :  * : 
strstr : if :  * : 
strstr : for :  * : 
strstr : while :  * : 
str :  * Note that we may have delayed dropping an mm in context_switch(). If
strstr : INIT :  * Note that we may have delayed dropping an mm in context_switch(). If : 
strstr : if :  * Note that we may have delayed dropping an mm in context_switch(). If : 
strstr : for :  * Note that we may have delayed dropping an mm in context_switch(). If : 
strstr : while :  * Note that we may have delayed dropping an mm in context_switch(). If : 
str :  * so, we finish that here outside of the runqueue lock. (Doing it
strstr : INIT :  * so, we finish that here outside of the runqueue lock. (Doing it : 
strstr : if :  * so, we finish that here outside of the runqueue lock. (Doing it : 
strstr : for :  * so, we finish that here outside of the runqueue lock. (Doing it : 
strstr : while :  * so, we finish that here outside of the runqueue lock. (Doing it : 
str :  * with the lock held can cause deadlocks; see schedule() for
strstr : INIT :  * with the lock held can cause deadlocks; see schedule() for : 
strstr : if :  * with the lock held can cause deadlocks; see schedule() for : 
strstr : for :  * with the lock held can cause deadlocks; see schedule() for : 
strstr : while :  * with the lock held can cause deadlocks; see schedule() for : 
str :  * details.)
strstr : INIT :  * details.) : 
strstr : if :  * details.) : 
strstr : for :  * details.) : 
strstr : while :  * details.) : 
str :  */
strstr : INIT :  */ : 
strstr : if :  */ : 
strstr : for :  */ : 
strstr : while :  */ : 
str : static void finish_task_switch(struct rq *rq, struct task_struct *prev)
strstr : INIT : static void finish_task_switch(struct rq *rq, struct task_struct *prev) : 
strstr : if : static void finish_task_switch(struct rq *rq, struct task_struct *prev) : 
strstr : for : static void finish_task_switch(struct rq *rq, struct task_struct *prev) : 
strstr : while : static void finish_task_switch(struct rq *rq, struct task_struct *prev) : 
str : 	__releases(rq->lock)
strstr : INIT : 	__releases(rq->lock) : 
strstr : if : 	__releases(rq->lock) : 
strstr : for : 	__releases(rq->lock) : 
strstr : while : 	__releases(rq->lock) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	struct mm_struct *mm = rq->prev_mm;
strstr : INIT : 	struct mm_struct *mm = rq->prev_mm; : 
strstr : if : 	struct mm_struct *mm = rq->prev_mm; : 
strstr : for : 	struct mm_struct *mm = rq->prev_mm; : 
strstr : while : 	struct mm_struct *mm = rq->prev_mm; : 
str : 	long prev_state;
strstr : INIT : 	long prev_state; : 
strstr : if : 	long prev_state; : 
strstr : for : 	long prev_state; : 
strstr : while : 	long prev_state; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	rq->prev_mm = NULL;
strstr : if : 	rq->prev_mm = NULL; : 
strstr : for : 	rq->prev_mm = NULL; : 
strstr : while : 	rq->prev_mm = NULL; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	/*
strstr : if : 	/* : 
strstr : for : 	/* : 
strstr : while : 	/* : 
str : 	 * A task struct has one reference for the use as "current".
strstr : INIT : 	 * A task struct has one reference for the use as "current". : 
strstr : if : 	 * A task struct has one reference for the use as "current". : 
strstr : for : 	 * A task struct has one reference for the use as "current". : 
strstr : while : 	 * A task struct has one reference for the use as "current". : 
str : 	 * If a task dies, then it sets TASK_DEAD in tsk->state and calls
strstr : INIT : 	 * If a task dies, then it sets TASK_DEAD in tsk->state and calls : 
strstr : if : 	 * If a task dies, then it sets TASK_DEAD in tsk->state and calls : 
strstr : for : 	 * If a task dies, then it sets TASK_DEAD in tsk->state and calls : 
strstr : while : 	 * If a task dies, then it sets TASK_DEAD in tsk->state and calls : 
str : 	 * schedule one last time. The schedule call will never return, and
strstr : INIT : 	 * schedule one last time. The schedule call will never return, and : 
strstr : if : 	 * schedule one last time. The schedule call will never return, and : 
strstr : for : 	 * schedule one last time. The schedule call will never return, and : 
strstr : while : 	 * schedule one last time. The schedule call will never return, and : 
str : 	 * the scheduled task must drop that reference.
strstr : INIT : 	 * the scheduled task must drop that reference. : 
strstr : if : 	 * the scheduled task must drop that reference. : 
strstr : for : 	 * the scheduled task must drop that reference. : 
strstr : while : 	 * the scheduled task must drop that reference. : 
str : 	 * The test for TASK_DEAD must occur while the runqueue locks are
strstr : INIT : 	 * The test for TASK_DEAD must occur while the runqueue locks are : 
strstr : if : 	 * The test for TASK_DEAD must occur while the runqueue locks are : 
strstr : for : 	 * The test for TASK_DEAD must occur while the runqueue locks are : 
strstr : while : 	 * The test for TASK_DEAD must occur while the runqueue locks are : 
str : 	 * still held, otherwise prev could be scheduled on another cpu, die
strstr : INIT : 	 * still held, otherwise prev could be scheduled on another cpu, die : 
strstr : if : 	 * still held, otherwise prev could be scheduled on another cpu, die : 
strstr : for : 	 * still held, otherwise prev could be scheduled on another cpu, die : 
strstr : while : 	 * still held, otherwise prev could be scheduled on another cpu, die : 
str : 	 * there before we look at prev->state, and then the reference would
strstr : INIT : 	 * there before we look at prev->state, and then the reference would : 
strstr : if : 	 * there before we look at prev->state, and then the reference would : 
strstr : for : 	 * there before we look at prev->state, and then the reference would : 
strstr : while : 	 * there before we look at prev->state, and then the reference would : 
str : 	 * be dropped twice.
strstr : INIT : 	 * be dropped twice. : 
strstr : if : 	 * be dropped twice. : 
strstr : for : 	 * be dropped twice. : 
strstr : while : 	 * be dropped twice. : 
str : 	 *		Manfred Spraul <manfred@colorfullife.com>
strstr : INIT : 	 *		Manfred Spraul <manfred@colorfullife.com> : 
strstr : if : 	 *		Manfred Spraul <manfred@colorfullife.com> : 
strstr : for : 	 *		Manfred Spraul <manfred@colorfullife.com> : 
strstr : while : 	 *		Manfred Spraul <manfred@colorfullife.com> : 
str : 	 */
strstr : INIT : 	 */ : 
strstr : if : 	 */ : 
strstr : for : 	 */ : 
strstr : while : 	 */ : 
str : 	prev_state = prev->state;
strstr : INIT : 	prev_state = prev->state; : 
strstr : if : 	prev_state = prev->state; : 
strstr : for : 	prev_state = prev->state; : 
strstr : while : 	prev_state = prev->state; : 
str : 	vtime_task_switch(prev);
strstr : INIT : 	vtime_task_switch(prev); : 
strstr : if : 	vtime_task_switch(prev); : 
strstr : for : 	vtime_task_switch(prev); : 
strstr : while : 	vtime_task_switch(prev); : 
str : 	finish_arch_switch(prev);
strstr : INIT : 	finish_arch_switch(prev); : 
strstr : if : 	finish_arch_switch(prev); : 
strstr : for : 	finish_arch_switch(prev); : 
strstr : while : 	finish_arch_switch(prev); : 
str : 	perf_event_task_sched_in(prev, current);
strstr : INIT : 	perf_event_task_sched_in(prev, current); : 
strstr : if : 	perf_event_task_sched_in(prev, current); : 
strstr : for : 	perf_event_task_sched_in(prev, current); : 
strstr : while : 	perf_event_task_sched_in(prev, current); : 
str : 	finish_lock_switch(rq, prev);
strstr : INIT : 	finish_lock_switch(rq, prev); : 
strstr : if : 	finish_lock_switch(rq, prev); : 
strstr : for : 	finish_lock_switch(rq, prev); : 
strstr : while : 	finish_lock_switch(rq, prev); : 
str : 	finish_arch_post_lock_switch();
strstr : INIT : 	finish_arch_post_lock_switch(); : 
strstr : if : 	finish_arch_post_lock_switch(); : 
strstr : for : 	finish_arch_post_lock_switch(); : 
strstr : while : 	finish_arch_post_lock_switch(); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	fire_sched_in_preempt_notifiers(current);
strstr : if : 	fire_sched_in_preempt_notifiers(current); : 
strstr : for : 	fire_sched_in_preempt_notifiers(current); : 
strstr : while : 	fire_sched_in_preempt_notifiers(current); : 
str : 	if (mm)
strstr : INIT : 	if (mm) : 
strstr : if : 	if (mm) : 
strstr : for : 	if (mm) : 
strstr : while : 	if (mm) : 
str : 		mmdrop(mm);
strstr : INIT : 		mmdrop(mm); : 
strstr : if : 		mmdrop(mm); : 
strstr : for : 		mmdrop(mm); : 
strstr : while : 		mmdrop(mm); : 
str : 	if (unlikely(prev_state == TASK_DEAD)) {
strstr : INIT : 	if (unlikely(prev_state == TASK_DEAD)) { : 
strstr : if : 	if (unlikely(prev_state == TASK_DEAD)) { : 
strstr : for : 	if (unlikely(prev_state == TASK_DEAD)) { : 
strstr : while : 	if (unlikely(prev_state == TASK_DEAD)) { : 
str : 		task_numa_free(prev);
strstr : INIT : 		task_numa_free(prev); : 
strstr : if : 		task_numa_free(prev); : 
strstr : for : 		task_numa_free(prev); : 
strstr : while : 		task_numa_free(prev); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 		if (prev->sched_class->task_dead)
strstr : if : 		if (prev->sched_class->task_dead) : 
strstr : for : 		if (prev->sched_class->task_dead) : 
strstr : while : 		if (prev->sched_class->task_dead) : 
str : 			prev->sched_class->task_dead(prev);
strstr : INIT : 			prev->sched_class->task_dead(prev); : 
strstr : if : 			prev->sched_class->task_dead(prev); : 
strstr : for : 			prev->sched_class->task_dead(prev); : 
strstr : while : 			prev->sched_class->task_dead(prev); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 		/*
strstr : if : 		/* : 
strstr : for : 		/* : 
strstr : while : 		/* : 
str : 		 * Remove function-return probe instances associated with this
strstr : INIT : 		 * Remove function-return probe instances associated with this : 
strstr : if : 		 * Remove function-return probe instances associated with this : 
strstr : for : 		 * Remove function-return probe instances associated with this : 
strstr : while : 		 * Remove function-return probe instances associated with this : 
str : 		 * task and put them back on the free list.
strstr : INIT : 		 * task and put them back on the free list. : 
strstr : if : 		 * task and put them back on the free list. : 
strstr : for : 		 * task and put them back on the free list. : 
strstr : while : 		 * task and put them back on the free list. : 
str : 		 */
strstr : INIT : 		 */ : 
strstr : if : 		 */ : 
strstr : for : 		 */ : 
strstr : while : 		 */ : 
str : 		kprobe_flush_task(prev);
strstr : INIT : 		kprobe_flush_task(prev); : 
strstr : if : 		kprobe_flush_task(prev); : 
strstr : for : 		kprobe_flush_task(prev); : 
strstr : while : 		kprobe_flush_task(prev); : 
str : 		put_task_struct(prev);
strstr : INIT : 		put_task_struct(prev); : 
strstr : if : 		put_task_struct(prev); : 
strstr : for : 		put_task_struct(prev); : 
strstr : while : 		put_task_struct(prev); : 
str : 	}
strstr : INIT : 	} : 
strstr : if : 	} : 
strstr : for : 	} : 
strstr : while : 	} : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	tick_nohz_task_switch(current);
strstr : if : 	tick_nohz_task_switch(current); : 
strstr : for : 	tick_nohz_task_switch(current); : 
strstr : while : 	tick_nohz_task_switch(current); : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : #ifdef CONFIG_SMP
strstr : if : #ifdef CONFIG_SMP : 
strstr : for : #ifdef CONFIG_SMP : 
strstr : while : #ifdef CONFIG_SMP : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : /* assumes rq->lock is held */
strstr : if : /* assumes rq->lock is held */ : 
strstr : for : /* assumes rq->lock is held */ : 
strstr : while : /* assumes rq->lock is held */ : 
str : static inline void pre_schedule(struct rq *rq, struct task_struct *prev)
strstr : INIT : static inline void pre_schedule(struct rq *rq, struct task_struct *prev) : 
strstr : if : static inline void pre_schedule(struct rq *rq, struct task_struct *prev) : 
strstr : for : static inline void pre_schedule(struct rq *rq, struct task_struct *prev) : 
strstr : while : static inline void pre_schedule(struct rq *rq, struct task_struct *prev) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	if (prev->sched_class->pre_schedule)
strstr : INIT : 	if (prev->sched_class->pre_schedule) : 
strstr : if : 	if (prev->sched_class->pre_schedule) : 
strstr : for : 	if (prev->sched_class->pre_schedule) : 
strstr : while : 	if (prev->sched_class->pre_schedule) : 
str : 		prev->sched_class->pre_schedule(rq, prev);
strstr : INIT : 		prev->sched_class->pre_schedule(rq, prev); : 
strstr : if : 		prev->sched_class->pre_schedule(rq, prev); : 
strstr : for : 		prev->sched_class->pre_schedule(rq, prev); : 
strstr : while : 		prev->sched_class->pre_schedule(rq, prev); : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : /* rq->lock is NOT held, but preemption is disabled */
strstr : if : /* rq->lock is NOT held, but preemption is disabled */ : 
strstr : for : /* rq->lock is NOT held, but preemption is disabled */ : 
strstr : while : /* rq->lock is NOT held, but preemption is disabled */ : 
str : static inline void post_schedule(struct rq *rq)
strstr : INIT : static inline void post_schedule(struct rq *rq) : 
strstr : if : static inline void post_schedule(struct rq *rq) : 
strstr : for : static inline void post_schedule(struct rq *rq) : 
strstr : while : static inline void post_schedule(struct rq *rq) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	if (rq->post_schedule) {
strstr : INIT : 	if (rq->post_schedule) { : 
strstr : if : 	if (rq->post_schedule) { : 
strstr : for : 	if (rq->post_schedule) { : 
strstr : while : 	if (rq->post_schedule) { : 
str : 		unsigned long flags;
strstr : INIT : 		unsigned long flags; : 
strstr : if : 		unsigned long flags; : 
strstr : for : 		unsigned long flags; : 
strstr : while : 		unsigned long flags; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 		raw_spin_lock_irqsave(&rq->lock, flags);
strstr : if : 		raw_spin_lock_irqsave(&rq->lock, flags); : 
strstr : for : 		raw_spin_lock_irqsave(&rq->lock, flags); : 
strstr : while : 		raw_spin_lock_irqsave(&rq->lock, flags); : 
str : 		if (rq->curr->sched_class->post_schedule)
strstr : INIT : 		if (rq->curr->sched_class->post_schedule) : 
strstr : if : 		if (rq->curr->sched_class->post_schedule) : 
strstr : for : 		if (rq->curr->sched_class->post_schedule) : 
strstr : while : 		if (rq->curr->sched_class->post_schedule) : 
str : 			rq->curr->sched_class->post_schedule(rq);
strstr : INIT : 			rq->curr->sched_class->post_schedule(rq); : 
strstr : if : 			rq->curr->sched_class->post_schedule(rq); : 
strstr : for : 			rq->curr->sched_class->post_schedule(rq); : 
strstr : while : 			rq->curr->sched_class->post_schedule(rq); : 
str : 		raw_spin_unlock_irqrestore(&rq->lock, flags);
strstr : INIT : 		raw_spin_unlock_irqrestore(&rq->lock, flags); : 
strstr : if : 		raw_spin_unlock_irqrestore(&rq->lock, flags); : 
strstr : for : 		raw_spin_unlock_irqrestore(&rq->lock, flags); : 
strstr : while : 		raw_spin_unlock_irqrestore(&rq->lock, flags); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 		rq->post_schedule = 0;
strstr : if : 		rq->post_schedule = 0; : 
strstr : for : 		rq->post_schedule = 0; : 
strstr : while : 		rq->post_schedule = 0; : 
str : 	}
strstr : INIT : 	} : 
strstr : if : 	} : 
strstr : for : 	} : 
strstr : while : 	} : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : #else
strstr : if : #else : 
strstr : for : #else : 
strstr : while : #else : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : static inline void pre_schedule(struct rq *rq, struct task_struct *p)
strstr : if : static inline void pre_schedule(struct rq *rq, struct task_struct *p) : 
strstr : for : static inline void pre_schedule(struct rq *rq, struct task_struct *p) : 
strstr : while : static inline void pre_schedule(struct rq *rq, struct task_struct *p) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : static inline void post_schedule(struct rq *rq)
strstr : if : static inline void post_schedule(struct rq *rq) : 
strstr : for : static inline void post_schedule(struct rq *rq) : 
strstr : while : static inline void post_schedule(struct rq *rq) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : #endif
strstr : if : #endif : 
strstr : for : #endif : 
strstr : while : #endif : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : /**
strstr : if : /** : 
strstr : for : /** : 
strstr : while : /** : 
str :  * schedule_tail - first thing a freshly forked thread must call.
strstr : INIT :  * schedule_tail - first thing a freshly forked thread must call. : 
strstr : if :  * schedule_tail - first thing a freshly forked thread must call. : 
strstr : for :  * schedule_tail - first thing a freshly forked thread must call. : 
strstr : while :  * schedule_tail - first thing a freshly forked thread must call. : 
str :  * @prev: the thread we just switched away from.
strstr : INIT :  * @prev: the thread we just switched away from. : 
strstr : if :  * @prev: the thread we just switched away from. : 
strstr : for :  * @prev: the thread we just switched away from. : 
strstr : while :  * @prev: the thread we just switched away from. : 
str :  */
strstr : INIT :  */ : 
strstr : if :  */ : 
strstr : for :  */ : 
strstr : while :  */ : 
str : asmlinkage void schedule_tail(struct task_struct *prev)
strstr : INIT : asmlinkage void schedule_tail(struct task_struct *prev) : 
strstr : if : asmlinkage void schedule_tail(struct task_struct *prev) : 
strstr : for : asmlinkage void schedule_tail(struct task_struct *prev) : 
strstr : while : asmlinkage void schedule_tail(struct task_struct *prev) : 
str : 	__releases(rq->lock)
strstr : INIT : 	__releases(rq->lock) : 
strstr : if : 	__releases(rq->lock) : 
strstr : for : 	__releases(rq->lock) : 
strstr : while : 	__releases(rq->lock) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	struct rq *rq = this_rq();
strstr : INIT : 	struct rq *rq = this_rq(); : 
strstr : if : 	struct rq *rq = this_rq(); : 
strstr : for : 	struct rq *rq = this_rq(); : 
strstr : while : 	struct rq *rq = this_rq(); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	finish_task_switch(rq, prev);
strstr : if : 	finish_task_switch(rq, prev); : 
strstr : for : 	finish_task_switch(rq, prev); : 
strstr : while : 	finish_task_switch(rq, prev); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	/*
strstr : if : 	/* : 
strstr : for : 	/* : 
strstr : while : 	/* : 
str : 	 * FIXME: do we need to worry about rq being invalidated by the
strstr : INIT : 	 * FIXME: do we need to worry about rq being invalidated by the : 
strstr : if : 	 * FIXME: do we need to worry about rq being invalidated by the : 
strstr : for : 	 * FIXME: do we need to worry about rq being invalidated by the : 
strstr : while : 	 * FIXME: do we need to worry about rq being invalidated by the : 
str : 	 * task_switch?
strstr : INIT : 	 * task_switch? : 
strstr : if : 	 * task_switch? : 
strstr : for : 	 * task_switch? : 
strstr : while : 	 * task_switch? : 
str : 	 */
strstr : INIT : 	 */ : 
strstr : if : 	 */ : 
strstr : for : 	 */ : 
strstr : while : 	 */ : 
str : 	post_schedule(rq);
strstr : INIT : 	post_schedule(rq); : 
strstr : if : 	post_schedule(rq); : 
strstr : for : 	post_schedule(rq); : 
strstr : while : 	post_schedule(rq); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : #ifdef __ARCH_WANT_UNLOCKED_CTXSW
strstr : if : #ifdef __ARCH_WANT_UNLOCKED_CTXSW : 
strstr : for : #ifdef __ARCH_WANT_UNLOCKED_CTXSW : 
strstr : while : #ifdef __ARCH_WANT_UNLOCKED_CTXSW : 
str : 	/* In this case, finish_task_switch does not reenable preemption */
strstr : INIT : 	/* In this case, finish_task_switch does not reenable preemption */ : 
strstr : if : 	/* In this case, finish_task_switch does not reenable preemption */ : 
strstr : for : 	/* In this case, finish_task_switch does not reenable preemption */ : 
strstr : while : 	/* In this case, finish_task_switch does not reenable preemption */ : 
str : 	preempt_enable();
strstr : INIT : 	preempt_enable(); : 
strstr : if : 	preempt_enable(); : 
strstr : for : 	preempt_enable(); : 
strstr : while : 	preempt_enable(); : 
str : #endif
strstr : INIT : #endif : 
strstr : if : #endif : 
strstr : for : #endif : 
strstr : while : #endif : 
str : 	if (current->set_child_tid)
strstr : INIT : 	if (current->set_child_tid) : 
strstr : if : 	if (current->set_child_tid) : 
strstr : for : 	if (current->set_child_tid) : 
strstr : while : 	if (current->set_child_tid) : 
str : 		put_user(task_pid_vnr(current), current->set_child_tid);
strstr : INIT : 		put_user(task_pid_vnr(current), current->set_child_tid); : 
strstr : if : 		put_user(task_pid_vnr(current), current->set_child_tid); : 
strstr : for : 		put_user(task_pid_vnr(current), current->set_child_tid); : 
strstr : while : 		put_user(task_pid_vnr(current), current->set_child_tid); : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : /*
strstr : if : /* : 
strstr : for : /* : 
strstr : while : /* : 
str :  * context_switch - switch to the new MM and the new
strstr : INIT :  * context_switch - switch to the new MM and the new : 
strstr : if :  * context_switch - switch to the new MM and the new : 
strstr : for :  * context_switch - switch to the new MM and the new : 
strstr : while :  * context_switch - switch to the new MM and the new : 
str :  * thread's register state.
strstr : INIT :  * thread's register state. : 
strstr : if :  * thread's register state. : 
strstr : for :  * thread's register state. : 
strstr : while :  * thread's register state. : 
str :  */
strstr : INIT :  */ : 
strstr : if :  */ : 
strstr : for :  */ : 
strstr : while :  */ : 
str : static inline void
strstr : INIT : static inline void : 
strstr : if : static inline void : 
strstr : for : static inline void : 
strstr : while : static inline void : 
str : context_switch(struct rq *rq, struct task_struct *prev,
strstr : INIT : context_switch(struct rq *rq, struct task_struct *prev, : 
strstr : if : context_switch(struct rq *rq, struct task_struct *prev, : 
strstr : for : context_switch(struct rq *rq, struct task_struct *prev, : 
strstr : while : context_switch(struct rq *rq, struct task_struct *prev, : 
str : 	       struct task_struct *next)
strstr : INIT : 	       struct task_struct *next) : 
strstr : if : 	       struct task_struct *next) : 
strstr : for : 	       struct task_struct *next) : 
strstr : while : 	       struct task_struct *next) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	struct mm_struct *mm, *oldmm;
strstr : INIT : 	struct mm_struct *mm, *oldmm; : 
strstr : if : 	struct mm_struct *mm, *oldmm; : 
strstr : for : 	struct mm_struct *mm, *oldmm; : 
strstr : while : 	struct mm_struct *mm, *oldmm; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	prepare_task_switch(rq, prev, next);
strstr : if : 	prepare_task_switch(rq, prev, next); : 
strstr : for : 	prepare_task_switch(rq, prev, next); : 
strstr : while : 	prepare_task_switch(rq, prev, next); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	mm = next->mm;
strstr : if : 	mm = next->mm; : 
strstr : for : 	mm = next->mm; : 
strstr : while : 	mm = next->mm; : 
str : 	oldmm = prev->active_mm;
strstr : INIT : 	oldmm = prev->active_mm; : 
strstr : if : 	oldmm = prev->active_mm; : 
strstr : for : 	oldmm = prev->active_mm; : 
strstr : while : 	oldmm = prev->active_mm; : 
str : 	/*
strstr : INIT : 	/* : 
strstr : if : 	/* : 
strstr : for : 	/* : 
strstr : while : 	/* : 
str : 	 * For paravirt, this is coupled with an exit in switch_to to
strstr : INIT : 	 * For paravirt, this is coupled with an exit in switch_to to : 
strstr : if : 	 * For paravirt, this is coupled with an exit in switch_to to : 
strstr : for : 	 * For paravirt, this is coupled with an exit in switch_to to : 
strstr : while : 	 * For paravirt, this is coupled with an exit in switch_to to : 
str : 	 * combine the page table reload and the switch backend into
strstr : INIT : 	 * combine the page table reload and the switch backend into : 
strstr : if : 	 * combine the page table reload and the switch backend into : 
strstr : for : 	 * combine the page table reload and the switch backend into : 
strstr : while : 	 * combine the page table reload and the switch backend into : 
str : 	 * one hypercall.
strstr : INIT : 	 * one hypercall. : 
strstr : if : 	 * one hypercall. : 
strstr : for : 	 * one hypercall. : 
strstr : while : 	 * one hypercall. : 
str : 	 */
strstr : INIT : 	 */ : 
strstr : if : 	 */ : 
strstr : for : 	 */ : 
strstr : while : 	 */ : 
str : 	arch_start_context_switch(prev);
strstr : INIT : 	arch_start_context_switch(prev); : 
strstr : if : 	arch_start_context_switch(prev); : 
strstr : for : 	arch_start_context_switch(prev); : 
strstr : while : 	arch_start_context_switch(prev); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	if (!mm) {
strstr : if : 	if (!mm) { : 
strstr : for : 	if (!mm) { : 
strstr : while : 	if (!mm) { : 
str : 		next->active_mm = oldmm;
strstr : INIT : 		next->active_mm = oldmm; : 
strstr : if : 		next->active_mm = oldmm; : 
strstr : for : 		next->active_mm = oldmm; : 
strstr : while : 		next->active_mm = oldmm; : 
str : 		atomic_inc(&oldmm->mm_count);
strstr : INIT : 		atomic_inc(&oldmm->mm_count); : 
strstr : if : 		atomic_inc(&oldmm->mm_count); : 
strstr : for : 		atomic_inc(&oldmm->mm_count); : 
strstr : while : 		atomic_inc(&oldmm->mm_count); : 
str : 		enter_lazy_tlb(oldmm, next);
strstr : INIT : 		enter_lazy_tlb(oldmm, next); : 
strstr : if : 		enter_lazy_tlb(oldmm, next); : 
strstr : for : 		enter_lazy_tlb(oldmm, next); : 
strstr : while : 		enter_lazy_tlb(oldmm, next); : 
str : 	} else
strstr : INIT : 	} else : 
strstr : if : 	} else : 
strstr : for : 	} else : 
strstr : while : 	} else : 
str : 		switch_mm(oldmm, mm, next);
strstr : INIT : 		switch_mm(oldmm, mm, next); : 
strstr : if : 		switch_mm(oldmm, mm, next); : 
strstr : for : 		switch_mm(oldmm, mm, next); : 
strstr : while : 		switch_mm(oldmm, mm, next); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	if (!prev->mm) {
strstr : if : 	if (!prev->mm) { : 
strstr : for : 	if (!prev->mm) { : 
strstr : while : 	if (!prev->mm) { : 
str : 		prev->active_mm = NULL;
strstr : INIT : 		prev->active_mm = NULL; : 
strstr : if : 		prev->active_mm = NULL; : 
strstr : for : 		prev->active_mm = NULL; : 
strstr : while : 		prev->active_mm = NULL; : 
str : 		rq->prev_mm = oldmm;
strstr : INIT : 		rq->prev_mm = oldmm; : 
strstr : if : 		rq->prev_mm = oldmm; : 
strstr : for : 		rq->prev_mm = oldmm; : 
strstr : while : 		rq->prev_mm = oldmm; : 
str : 	}
strstr : INIT : 	} : 
strstr : if : 	} : 
strstr : for : 	} : 
strstr : while : 	} : 
str : 	/*
strstr : INIT : 	/* : 
strstr : if : 	/* : 
strstr : for : 	/* : 
strstr : while : 	/* : 
str : 	 * Since the runqueue lock will be released by the next
strstr : INIT : 	 * Since the runqueue lock will be released by the next : 
strstr : if : 	 * Since the runqueue lock will be released by the next : 
strstr : for : 	 * Since the runqueue lock will be released by the next : 
strstr : while : 	 * Since the runqueue lock will be released by the next : 
str : 	 * task (which is an invalid locking op but in the case
strstr : INIT : 	 * task (which is an invalid locking op but in the case : 
strstr : if : 	 * task (which is an invalid locking op but in the case : 
strstr : for : 	 * task (which is an invalid locking op but in the case : 
strstr : while : 	 * task (which is an invalid locking op but in the case : 
str : 	 * of the scheduler it's an obvious special-case), so we
strstr : INIT : 	 * of the scheduler it's an obvious special-case), so we : 
strstr : if : 	 * of the scheduler it's an obvious special-case), so we : 
strstr : for : 	 * of the scheduler it's an obvious special-case), so we : 
strstr : while : 	 * of the scheduler it's an obvious special-case), so we : 
str : 	 * do an early lockdep release here:
strstr : INIT : 	 * do an early lockdep release here: : 
strstr : if : 	 * do an early lockdep release here: : 
strstr : for : 	 * do an early lockdep release here: : 
strstr : while : 	 * do an early lockdep release here: : 
str : 	 */
strstr : INIT : 	 */ : 
strstr : if : 	 */ : 
strstr : for : 	 */ : 
strstr : while : 	 */ : 
str : #ifndef __ARCH_WANT_UNLOCKED_CTXSW
strstr : INIT : #ifndef __ARCH_WANT_UNLOCKED_CTXSW : 
strstr : if : #ifndef __ARCH_WANT_UNLOCKED_CTXSW : 
strstr : for : #ifndef __ARCH_WANT_UNLOCKED_CTXSW : 
strstr : while : #ifndef __ARCH_WANT_UNLOCKED_CTXSW : 
str : 	spin_release(&rq->lock.dep_map, 1, _THIS_IP_);
strstr : INIT : 	spin_release(&rq->lock.dep_map, 1, _THIS_IP_); : 
strstr : if : 	spin_release(&rq->lock.dep_map, 1, _THIS_IP_); : 
strstr : for : 	spin_release(&rq->lock.dep_map, 1, _THIS_IP_); : 
strstr : while : 	spin_release(&rq->lock.dep_map, 1, _THIS_IP_); : 
str : #endif
strstr : INIT : #endif : 
strstr : if : #endif : 
strstr : for : #endif : 
strstr : while : #endif : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	context_tracking_task_switch(prev, next);
strstr : if : 	context_tracking_task_switch(prev, next); : 
strstr : for : 	context_tracking_task_switch(prev, next); : 
strstr : while : 	context_tracking_task_switch(prev, next); : 
str : 	/* Here we just switch the register state and the stack. */
strstr : INIT : 	/* Here we just switch the register state and the stack. */ : 
strstr : if : 	/* Here we just switch the register state and the stack. */ : 
strstr : for : 	/* Here we just switch the register state and the stack. */ : 
strstr : while : 	/* Here we just switch the register state and the stack. */ : 
str : 	switch_to(prev, next, prev);
strstr : INIT : 	switch_to(prev, next, prev); : 
strstr : if : 	switch_to(prev, next, prev); : 
strstr : for : 	switch_to(prev, next, prev); : 
strstr : while : 	switch_to(prev, next, prev); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	barrier();
strstr : if : 	barrier(); : 
strstr : for : 	barrier(); : 
strstr : while : 	barrier(); : 
str : 	/*
strstr : INIT : 	/* : 
strstr : if : 	/* : 
strstr : for : 	/* : 
strstr : while : 	/* : 
str : 	 * this_rq must be evaluated again because prev may have moved
strstr : INIT : 	 * this_rq must be evaluated again because prev may have moved : 
strstr : if : 	 * this_rq must be evaluated again because prev may have moved : 
strstr : for : 	 * this_rq must be evaluated again because prev may have moved : 
strstr : while : 	 * this_rq must be evaluated again because prev may have moved : 
str : 	 * CPUs since it called schedule(), thus the 'rq' on its stack
strstr : INIT : 	 * CPUs since it called schedule(), thus the 'rq' on its stack : 
strstr : if : 	 * CPUs since it called schedule(), thus the 'rq' on its stack : 
strstr : for : 	 * CPUs since it called schedule(), thus the 'rq' on its stack : 
strstr : while : 	 * CPUs since it called schedule(), thus the 'rq' on its stack : 
str : 	 * frame will be invalid.
strstr : INIT : 	 * frame will be invalid. : 
strstr : if : 	 * frame will be invalid. : 
strstr : for : 	 * frame will be invalid. : 
strstr : while : 	 * frame will be invalid. : 
str : 	 */
strstr : INIT : 	 */ : 
strstr : if : 	 */ : 
strstr : for : 	 */ : 
strstr : while : 	 */ : 
str : 	finish_task_switch(this_rq(), prev);
strstr : INIT : 	finish_task_switch(this_rq(), prev); : 
strstr : if : 	finish_task_switch(this_rq(), prev); : 
strstr : for : 	finish_task_switch(this_rq(), prev); : 
strstr : while : 	finish_task_switch(this_rq(), prev); : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : /*
strstr : if : /* : 
strstr : for : /* : 
strstr : while : /* : 
str :  * nr_running and nr_context_switches:
strstr : INIT :  * nr_running and nr_context_switches: : 
strstr : if :  * nr_running and nr_context_switches: : 
strstr : for :  * nr_running and nr_context_switches: : 
strstr : while :  * nr_running and nr_context_switches: : 
str :  *
strstr : INIT :  * : 
strstr : if :  * : 
strstr : for :  * : 
strstr : while :  * : 
str :  * externally visible scheduler statistics: current number of runnable
strstr : INIT :  * externally visible scheduler statistics: current number of runnable : 
strstr : if :  * externally visible scheduler statistics: current number of runnable : 
strstr : for :  * externally visible scheduler statistics: current number of runnable : 
strstr : while :  * externally visible scheduler statistics: current number of runnable : 
str :  * threads, total number of context switches performed since bootup.
strstr : INIT :  * threads, total number of context switches performed since bootup. : 
strstr : if :  * threads, total number of context switches performed since bootup. : 
strstr : for :  * threads, total number of context switches performed since bootup. : 
strstr : while :  * threads, total number of context switches performed since bootup. : 
str :  */
strstr : INIT :  */ : 
strstr : if :  */ : 
strstr : for :  */ : 
strstr : while :  */ : 
str : unsigned long nr_running(void)
strstr : INIT : unsigned long nr_running(void) : 
strstr : if : unsigned long nr_running(void) : 
strstr : for : unsigned long nr_running(void) : 
strstr : while : unsigned long nr_running(void) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	unsigned long i, sum = 0;
strstr : INIT : 	unsigned long i, sum = 0; : 
strstr : if : 	unsigned long i, sum = 0; : 
strstr : for : 	unsigned long i, sum = 0; : 
strstr : while : 	unsigned long i, sum = 0; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	for_each_online_cpu(i)
strstr : if : 	for_each_online_cpu(i) : 
strstr : for : 	for_each_online_cpu(i) : 
strstr : while : 	for_each_online_cpu(i) : 
str : 		sum += cpu_rq(i)->nr_running;
strstr : INIT : 		sum += cpu_rq(i)->nr_running; : 
strstr : if : 		sum += cpu_rq(i)->nr_running; : 
strstr : for : 		sum += cpu_rq(i)->nr_running; : 
strstr : while : 		sum += cpu_rq(i)->nr_running; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	return sum;
strstr : if : 	return sum; : 
strstr : for : 	return sum; : 
strstr : while : 	return sum; : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : unsigned long long nr_context_switches(void)
strstr : if : unsigned long long nr_context_switches(void) : 
strstr : for : unsigned long long nr_context_switches(void) : 
strstr : while : unsigned long long nr_context_switches(void) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	int i;
strstr : INIT : 	int i; : 
strstr : if : 	int i; : 
strstr : for : 	int i; : 
strstr : while : 	int i; : 
str : 	unsigned long long sum = 0;
strstr : INIT : 	unsigned long long sum = 0; : 
strstr : if : 	unsigned long long sum = 0; : 
strstr : for : 	unsigned long long sum = 0; : 
strstr : while : 	unsigned long long sum = 0; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	for_each_possible_cpu(i)
strstr : if : 	for_each_possible_cpu(i) : 
strstr : for : 	for_each_possible_cpu(i) : 
strstr : while : 	for_each_possible_cpu(i) : 
str : 		sum += cpu_rq(i)->nr_switches;
strstr : INIT : 		sum += cpu_rq(i)->nr_switches; : 
strstr : if : 		sum += cpu_rq(i)->nr_switches; : 
strstr : for : 		sum += cpu_rq(i)->nr_switches; : 
strstr : while : 		sum += cpu_rq(i)->nr_switches; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	return sum;
strstr : if : 	return sum; : 
strstr : for : 	return sum; : 
strstr : while : 	return sum; : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : unsigned long nr_iowait(void)
strstr : if : unsigned long nr_iowait(void) : 
strstr : for : unsigned long nr_iowait(void) : 
strstr : while : unsigned long nr_iowait(void) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	unsigned long i, sum = 0;
strstr : INIT : 	unsigned long i, sum = 0; : 
strstr : if : 	unsigned long i, sum = 0; : 
strstr : for : 	unsigned long i, sum = 0; : 
strstr : while : 	unsigned long i, sum = 0; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	for_each_possible_cpu(i)
strstr : if : 	for_each_possible_cpu(i) : 
strstr : for : 	for_each_possible_cpu(i) : 
strstr : while : 	for_each_possible_cpu(i) : 
str : 		sum += atomic_read(&cpu_rq(i)->nr_iowait);
strstr : INIT : 		sum += atomic_read(&cpu_rq(i)->nr_iowait); : 
strstr : if : 		sum += atomic_read(&cpu_rq(i)->nr_iowait); : 
strstr : for : 		sum += atomic_read(&cpu_rq(i)->nr_iowait); : 
strstr : while : 		sum += atomic_read(&cpu_rq(i)->nr_iowait); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	return sum;
strstr : if : 	return sum; : 
strstr : for : 	return sum; : 
strstr : while : 	return sum; : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : unsigned long nr_iowait_cpu(int cpu)
strstr : if : unsigned long nr_iowait_cpu(int cpu) : 
strstr : for : unsigned long nr_iowait_cpu(int cpu) : 
strstr : while : unsigned long nr_iowait_cpu(int cpu) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	struct rq *this = cpu_rq(cpu);
strstr : INIT : 	struct rq *this = cpu_rq(cpu); : 
strstr : if : 	struct rq *this = cpu_rq(cpu); : 
strstr : for : 	struct rq *this = cpu_rq(cpu); : 
strstr : while : 	struct rq *this = cpu_rq(cpu); : 
str : 	return atomic_read(&this->nr_iowait);
strstr : INIT : 	return atomic_read(&this->nr_iowait); : 
strstr : if : 	return atomic_read(&this->nr_iowait); : 
strstr : for : 	return atomic_read(&this->nr_iowait); : 
strstr : while : 	return atomic_read(&this->nr_iowait); : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : #ifdef CONFIG_SMP
strstr : if : #ifdef CONFIG_SMP : 
strstr : for : #ifdef CONFIG_SMP : 
strstr : while : #ifdef CONFIG_SMP : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : /*
strstr : if : /* : 
strstr : for : /* : 
strstr : while : /* : 
str :  * sched_exec - execve() is a valuable balancing opportunity, because at
strstr : INIT :  * sched_exec - execve() is a valuable balancing opportunity, because at : 
strstr : if :  * sched_exec - execve() is a valuable balancing opportunity, because at : 
strstr : for :  * sched_exec - execve() is a valuable balancing opportunity, because at : 
strstr : while :  * sched_exec - execve() is a valuable balancing opportunity, because at : 
str :  * this point the task has the smallest effective memory and cache footprint.
strstr : INIT :  * this point the task has the smallest effective memory and cache footprint. : 
strstr : if :  * this point the task has the smallest effective memory and cache footprint. : 
strstr : for :  * this point the task has the smallest effective memory and cache footprint. : 
strstr : while :  * this point the task has the smallest effective memory and cache footprint. : 
str :  */
strstr : INIT :  */ : 
strstr : if :  */ : 
strstr : for :  */ : 
strstr : while :  */ : 
str : void sched_exec(void)
strstr : INIT : void sched_exec(void) : 
strstr : if : void sched_exec(void) : 
strstr : for : void sched_exec(void) : 
strstr : while : void sched_exec(void) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	struct task_struct *p = current;
strstr : INIT : 	struct task_struct *p = current; : 
strstr : if : 	struct task_struct *p = current; : 
strstr : for : 	struct task_struct *p = current; : 
strstr : while : 	struct task_struct *p = current; : 
str : 	unsigned long flags;
strstr : INIT : 	unsigned long flags; : 
strstr : if : 	unsigned long flags; : 
strstr : for : 	unsigned long flags; : 
strstr : while : 	unsigned long flags; : 
str : 	int dest_cpu;
strstr : INIT : 	int dest_cpu; : 
strstr : if : 	int dest_cpu; : 
strstr : for : 	int dest_cpu; : 
strstr : while : 	int dest_cpu; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	raw_spin_lock_irqsave(&p->pi_lock, flags);
strstr : if : 	raw_spin_lock_irqsave(&p->pi_lock, flags); : 
strstr : for : 	raw_spin_lock_irqsave(&p->pi_lock, flags); : 
strstr : while : 	raw_spin_lock_irqsave(&p->pi_lock, flags); : 
str : 	dest_cpu = p->sched_class->select_task_rq(p, task_cpu(p), SD_BALANCE_EXEC, 0);
strstr : INIT : 	dest_cpu = p->sched_class->select_task_rq(p, task_cpu(p), SD_BALANCE_EXEC, 0); : 
strstr : if : 	dest_cpu = p->sched_class->select_task_rq(p, task_cpu(p), SD_BALANCE_EXEC, 0); : 
strstr : for : 	dest_cpu = p->sched_class->select_task_rq(p, task_cpu(p), SD_BALANCE_EXEC, 0); : 
strstr : while : 	dest_cpu = p->sched_class->select_task_rq(p, task_cpu(p), SD_BALANCE_EXEC, 0); : 
str : 	if (dest_cpu == smp_processor_id())
strstr : INIT : 	if (dest_cpu == smp_processor_id()) : 
strstr : if : 	if (dest_cpu == smp_processor_id()) : 
strstr : for : 	if (dest_cpu == smp_processor_id()) : 
strstr : while : 	if (dest_cpu == smp_processor_id()) : 
str : 		goto unlock;
strstr : INIT : 		goto unlock; : 
strstr : if : 		goto unlock; : 
strstr : for : 		goto unlock; : 
strstr : while : 		goto unlock; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	if (likely(cpu_active(dest_cpu))) {
strstr : if : 	if (likely(cpu_active(dest_cpu))) { : 
strstr : for : 	if (likely(cpu_active(dest_cpu))) { : 
strstr : while : 	if (likely(cpu_active(dest_cpu))) { : 
str : 		struct migration_arg arg = { p, dest_cpu };
strstr : INIT : 		struct migration_arg arg = { p, dest_cpu }; : 
strstr : if : 		struct migration_arg arg = { p, dest_cpu }; : 
strstr : for : 		struct migration_arg arg = { p, dest_cpu }; : 
strstr : while : 		struct migration_arg arg = { p, dest_cpu }; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 		raw_spin_unlock_irqrestore(&p->pi_lock, flags);
strstr : if : 		raw_spin_unlock_irqrestore(&p->pi_lock, flags); : 
strstr : for : 		raw_spin_unlock_irqrestore(&p->pi_lock, flags); : 
strstr : while : 		raw_spin_unlock_irqrestore(&p->pi_lock, flags); : 
str : 		stop_one_cpu(task_cpu(p), migration_cpu_stop, &arg);
strstr : INIT : 		stop_one_cpu(task_cpu(p), migration_cpu_stop, &arg); : 
strstr : if : 		stop_one_cpu(task_cpu(p), migration_cpu_stop, &arg); : 
strstr : for : 		stop_one_cpu(task_cpu(p), migration_cpu_stop, &arg); : 
strstr : while : 		stop_one_cpu(task_cpu(p), migration_cpu_stop, &arg); : 
str : 		return;
strstr : INIT : 		return; : 
strstr : if : 		return; : 
strstr : for : 		return; : 
strstr : while : 		return; : 
str : 	}
strstr : INIT : 	} : 
strstr : if : 	} : 
strstr : for : 	} : 
strstr : while : 	} : 
str : unlock:
strstr : INIT : unlock: : 
strstr : if : unlock: : 
strstr : for : unlock: : 
strstr : while : unlock: : 
str : 	raw_spin_unlock_irqrestore(&p->pi_lock, flags);
strstr : INIT : 	raw_spin_unlock_irqrestore(&p->pi_lock, flags); : 
strstr : if : 	raw_spin_unlock_irqrestore(&p->pi_lock, flags); : 
strstr : for : 	raw_spin_unlock_irqrestore(&p->pi_lock, flags); : 
strstr : while : 	raw_spin_unlock_irqrestore(&p->pi_lock, flags); : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : #endif
strstr : if : #endif : 
strstr : for : #endif : 
strstr : while : #endif : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : DEFINE_PER_CPU(struct kernel_stat, kstat);
strstr : if : DEFINE_PER_CPU(struct kernel_stat, kstat); : 
strstr : for : DEFINE_PER_CPU(struct kernel_stat, kstat); : 
strstr : while : DEFINE_PER_CPU(struct kernel_stat, kstat); : 
str : DEFINE_PER_CPU(struct kernel_cpustat, kernel_cpustat);
strstr : INIT : DEFINE_PER_CPU(struct kernel_cpustat, kernel_cpustat); : 
strstr : if : DEFINE_PER_CPU(struct kernel_cpustat, kernel_cpustat); : 
strstr : for : DEFINE_PER_CPU(struct kernel_cpustat, kernel_cpustat); : 
strstr : while : DEFINE_PER_CPU(struct kernel_cpustat, kernel_cpustat); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : EXPORT_PER_CPU_SYMBOL(kstat);
strstr : if : EXPORT_PER_CPU_SYMBOL(kstat); : 
strstr : for : EXPORT_PER_CPU_SYMBOL(kstat); : 
strstr : while : EXPORT_PER_CPU_SYMBOL(kstat); : 
str : EXPORT_PER_CPU_SYMBOL(kernel_cpustat);
strstr : INIT : EXPORT_PER_CPU_SYMBOL(kernel_cpustat); : 
strstr : if : EXPORT_PER_CPU_SYMBOL(kernel_cpustat); : 
strstr : for : EXPORT_PER_CPU_SYMBOL(kernel_cpustat); : 
strstr : while : EXPORT_PER_CPU_SYMBOL(kernel_cpustat); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : /*
strstr : if : /* : 
strstr : for : /* : 
strstr : while : /* : 
str :  * Return any ns on the sched_clock that have not yet been accounted in
strstr : INIT :  * Return any ns on the sched_clock that have not yet been accounted in : 
strstr : if :  * Return any ns on the sched_clock that have not yet been accounted in : 
strstr : for :  * Return any ns on the sched_clock that have not yet been accounted in : 
strstr : while :  * Return any ns on the sched_clock that have not yet been accounted in : 
str :  * @p in case that task is currently running.
strstr : INIT :  * @p in case that task is currently running. : 
strstr : if :  * @p in case that task is currently running. : 
strstr : for :  * @p in case that task is currently running. : 
strstr : while :  * @p in case that task is currently running. : 
str :  *
strstr : INIT :  * : 
strstr : if :  * : 
strstr : for :  * : 
strstr : while :  * : 
str :  * Called with task_rq_lock() held on @rq.
strstr : INIT :  * Called with task_rq_lock() held on @rq. : 
strstr : if :  * Called with task_rq_lock() held on @rq. : 
strstr : for :  * Called with task_rq_lock() held on @rq. : 
strstr : while :  * Called with task_rq_lock() held on @rq. : 
str :  */
strstr : INIT :  */ : 
strstr : if :  */ : 
strstr : for :  */ : 
strstr : while :  */ : 
str : static u64 do_task_delta_exec(struct task_struct *p, struct rq *rq)
strstr : INIT : static u64 do_task_delta_exec(struct task_struct *p, struct rq *rq) : 
strstr : if : static u64 do_task_delta_exec(struct task_struct *p, struct rq *rq) : 
strstr : for : static u64 do_task_delta_exec(struct task_struct *p, struct rq *rq) : 
strstr : while : static u64 do_task_delta_exec(struct task_struct *p, struct rq *rq) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	u64 ns = 0;
strstr : INIT : 	u64 ns = 0; : 
strstr : if : 	u64 ns = 0; : 
strstr : for : 	u64 ns = 0; : 
strstr : while : 	u64 ns = 0; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	if (task_current(rq, p)) {
strstr : if : 	if (task_current(rq, p)) { : 
strstr : for : 	if (task_current(rq, p)) { : 
strstr : while : 	if (task_current(rq, p)) { : 
str : 		update_rq_clock(rq);
strstr : INIT : 		update_rq_clock(rq); : 
strstr : if : 		update_rq_clock(rq); : 
strstr : for : 		update_rq_clock(rq); : 
strstr : while : 		update_rq_clock(rq); : 
str : 		ns = rq_clock_task(rq) - p->se.exec_start;
strstr : INIT : 		ns = rq_clock_task(rq) - p->se.exec_start; : 
strstr : if : 		ns = rq_clock_task(rq) - p->se.exec_start; : 
strstr : for : 		ns = rq_clock_task(rq) - p->se.exec_start; : 
strstr : while : 		ns = rq_clock_task(rq) - p->se.exec_start; : 
str : 		if ((s64)ns < 0)
strstr : INIT : 		if ((s64)ns < 0) : 
strstr : if : 		if ((s64)ns < 0) : 
strstr : for : 		if ((s64)ns < 0) : 
strstr : while : 		if ((s64)ns < 0) : 
str : 			ns = 0;
strstr : INIT : 			ns = 0; : 
strstr : if : 			ns = 0; : 
strstr : for : 			ns = 0; : 
strstr : while : 			ns = 0; : 
str : 	}
strstr : INIT : 	} : 
strstr : if : 	} : 
strstr : for : 	} : 
strstr : while : 	} : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	return ns;
strstr : if : 	return ns; : 
strstr : for : 	return ns; : 
strstr : while : 	return ns; : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : unsigned long long task_delta_exec(struct task_struct *p)
strstr : if : unsigned long long task_delta_exec(struct task_struct *p) : 
strstr : for : unsigned long long task_delta_exec(struct task_struct *p) : 
strstr : while : unsigned long long task_delta_exec(struct task_struct *p) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	unsigned long flags;
strstr : INIT : 	unsigned long flags; : 
strstr : if : 	unsigned long flags; : 
strstr : for : 	unsigned long flags; : 
strstr : while : 	unsigned long flags; : 
str : 	struct rq *rq;
strstr : INIT : 	struct rq *rq; : 
strstr : if : 	struct rq *rq; : 
strstr : for : 	struct rq *rq; : 
strstr : while : 	struct rq *rq; : 
str : 	u64 ns = 0;
strstr : INIT : 	u64 ns = 0; : 
strstr : if : 	u64 ns = 0; : 
strstr : for : 	u64 ns = 0; : 
strstr : while : 	u64 ns = 0; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	rq = task_rq_lock(p, &flags);
strstr : if : 	rq = task_rq_lock(p, &flags); : 
strstr : for : 	rq = task_rq_lock(p, &flags); : 
strstr : while : 	rq = task_rq_lock(p, &flags); : 
str : 	ns = do_task_delta_exec(p, rq);
strstr : INIT : 	ns = do_task_delta_exec(p, rq); : 
strstr : if : 	ns = do_task_delta_exec(p, rq); : 
strstr : for : 	ns = do_task_delta_exec(p, rq); : 
strstr : while : 	ns = do_task_delta_exec(p, rq); : 
str : 	task_rq_unlock(rq, p, &flags);
strstr : INIT : 	task_rq_unlock(rq, p, &flags); : 
strstr : if : 	task_rq_unlock(rq, p, &flags); : 
strstr : for : 	task_rq_unlock(rq, p, &flags); : 
strstr : while : 	task_rq_unlock(rq, p, &flags); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	return ns;
strstr : if : 	return ns; : 
strstr : for : 	return ns; : 
strstr : while : 	return ns; : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : /*
strstr : if : /* : 
strstr : for : /* : 
strstr : while : /* : 
str :  * Return accounted runtime for the task.
strstr : INIT :  * Return accounted runtime for the task. : 
strstr : if :  * Return accounted runtime for the task. : 
strstr : for :  * Return accounted runtime for the task. : 
strstr : while :  * Return accounted runtime for the task. : 
str :  * In case the task is currently running, return the runtime plus current's
strstr : INIT :  * In case the task is currently running, return the runtime plus current's : 
strstr : if :  * In case the task is currently running, return the runtime plus current's : 
strstr : for :  * In case the task is currently running, return the runtime plus current's : 
strstr : while :  * In case the task is currently running, return the runtime plus current's : 
str :  * pending runtime that have not been accounted yet.
strstr : INIT :  * pending runtime that have not been accounted yet. : 
strstr : if :  * pending runtime that have not been accounted yet. : 
strstr : for :  * pending runtime that have not been accounted yet. : 
strstr : while :  * pending runtime that have not been accounted yet. : 
str :  */
strstr : INIT :  */ : 
strstr : if :  */ : 
strstr : for :  */ : 
strstr : while :  */ : 
str : unsigned long long task_sched_runtime(struct task_struct *p)
strstr : INIT : unsigned long long task_sched_runtime(struct task_struct *p) : 
strstr : if : unsigned long long task_sched_runtime(struct task_struct *p) : 
strstr : for : unsigned long long task_sched_runtime(struct task_struct *p) : 
strstr : while : unsigned long long task_sched_runtime(struct task_struct *p) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	unsigned long flags;
strstr : INIT : 	unsigned long flags; : 
strstr : if : 	unsigned long flags; : 
strstr : for : 	unsigned long flags; : 
strstr : while : 	unsigned long flags; : 
str : 	struct rq *rq;
strstr : INIT : 	struct rq *rq; : 
strstr : if : 	struct rq *rq; : 
strstr : for : 	struct rq *rq; : 
strstr : while : 	struct rq *rq; : 
str : 	u64 ns = 0;
strstr : INIT : 	u64 ns = 0; : 
strstr : if : 	u64 ns = 0; : 
strstr : for : 	u64 ns = 0; : 
strstr : while : 	u64 ns = 0; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : #if defined(CONFIG_64BIT) && defined(CONFIG_SMP)
strstr : if : #if defined(CONFIG_64BIT) && defined(CONFIG_SMP) : 
strstr : for : #if defined(CONFIG_64BIT) && defined(CONFIG_SMP) : 
strstr : while : #if defined(CONFIG_64BIT) && defined(CONFIG_SMP) : 
str : 	/*
strstr : INIT : 	/* : 
strstr : if : 	/* : 
strstr : for : 	/* : 
strstr : while : 	/* : 
str : 	 * 64-bit doesn't need locks to atomically read a 64bit value.
strstr : INIT : 	 * 64-bit doesn't need locks to atomically read a 64bit value. : 
strstr : if : 	 * 64-bit doesn't need locks to atomically read a 64bit value. : 
strstr : for : 	 * 64-bit doesn't need locks to atomically read a 64bit value. : 
strstr : while : 	 * 64-bit doesn't need locks to atomically read a 64bit value. : 
str : 	 * So we have a optimization chance when the task's delta_exec is 0.
strstr : INIT : 	 * So we have a optimization chance when the task's delta_exec is 0. : 
strstr : if : 	 * So we have a optimization chance when the task's delta_exec is 0. : 
strstr : for : 	 * So we have a optimization chance when the task's delta_exec is 0. : 
strstr : while : 	 * So we have a optimization chance when the task's delta_exec is 0. : 
str : 	 * Reading ->on_cpu is racy, but this is ok.
strstr : INIT : 	 * Reading ->on_cpu is racy, but this is ok. : 
strstr : if : 	 * Reading ->on_cpu is racy, but this is ok. : 
strstr : for : 	 * Reading ->on_cpu is racy, but this is ok. : 
strstr : while : 	 * Reading ->on_cpu is racy, but this is ok. : 
str : 	 *
strstr : INIT : 	 * : 
strstr : if : 	 * : 
strstr : for : 	 * : 
strstr : while : 	 * : 
str : 	 * If we race with it leaving cpu, we'll take a lock. So we're correct.
strstr : INIT : 	 * If we race with it leaving cpu, we'll take a lock. So we're correct. : 
strstr : if : 	 * If we race with it leaving cpu, we'll take a lock. So we're correct. : 
strstr : for : 	 * If we race with it leaving cpu, we'll take a lock. So we're correct. : 
strstr : while : 	 * If we race with it leaving cpu, we'll take a lock. So we're correct. : 
str : 	 * If we race with it entering cpu, unaccounted time is 0. This is
strstr : INIT : 	 * If we race with it entering cpu, unaccounted time is 0. This is : 
strstr : if : 	 * If we race with it entering cpu, unaccounted time is 0. This is : 
strstr : for : 	 * If we race with it entering cpu, unaccounted time is 0. This is : 
strstr : while : 	 * If we race with it entering cpu, unaccounted time is 0. This is : 
str : 	 * indistinguishable from the read occurring a few cycles earlier.
strstr : INIT : 	 * indistinguishable from the read occurring a few cycles earlier. : 
strstr : if : 	 * indistinguishable from the read occurring a few cycles earlier. : 
strstr : for : 	 * indistinguishable from the read occurring a few cycles earlier. : 
strstr : while : 	 * indistinguishable from the read occurring a few cycles earlier. : 
str : 	 */
strstr : INIT : 	 */ : 
strstr : if : 	 */ : 
strstr : for : 	 */ : 
strstr : while : 	 */ : 
str : 	if (!p->on_cpu)
strstr : INIT : 	if (!p->on_cpu) : 
strstr : if : 	if (!p->on_cpu) : 
strstr : for : 	if (!p->on_cpu) : 
strstr : while : 	if (!p->on_cpu) : 
str : 		return p->se.sum_exec_runtime;
strstr : INIT : 		return p->se.sum_exec_runtime; : 
strstr : if : 		return p->se.sum_exec_runtime; : 
strstr : for : 		return p->se.sum_exec_runtime; : 
strstr : while : 		return p->se.sum_exec_runtime; : 
str : #endif
strstr : INIT : #endif : 
strstr : if : #endif : 
strstr : for : #endif : 
strstr : while : #endif : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	rq = task_rq_lock(p, &flags);
strstr : if : 	rq = task_rq_lock(p, &flags); : 
strstr : for : 	rq = task_rq_lock(p, &flags); : 
strstr : while : 	rq = task_rq_lock(p, &flags); : 
str : 	ns = p->se.sum_exec_runtime + do_task_delta_exec(p, rq);
strstr : INIT : 	ns = p->se.sum_exec_runtime + do_task_delta_exec(p, rq); : 
strstr : if : 	ns = p->se.sum_exec_runtime + do_task_delta_exec(p, rq); : 
strstr : for : 	ns = p->se.sum_exec_runtime + do_task_delta_exec(p, rq); : 
strstr : while : 	ns = p->se.sum_exec_runtime + do_task_delta_exec(p, rq); : 
str : 	task_rq_unlock(rq, p, &flags);
strstr : INIT : 	task_rq_unlock(rq, p, &flags); : 
strstr : if : 	task_rq_unlock(rq, p, &flags); : 
strstr : for : 	task_rq_unlock(rq, p, &flags); : 
strstr : while : 	task_rq_unlock(rq, p, &flags); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	return ns;
strstr : if : 	return ns; : 
strstr : for : 	return ns; : 
strstr : while : 	return ns; : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : /*
strstr : if : /* : 
strstr : for : /* : 
strstr : while : /* : 
str :  * This function gets called by the timer code, with HZ frequency.
strstr : INIT :  * This function gets called by the timer code, with HZ frequency. : 
strstr : if :  * This function gets called by the timer code, with HZ frequency. : 
strstr : for :  * This function gets called by the timer code, with HZ frequency. : 
strstr : while :  * This function gets called by the timer code, with HZ frequency. : 
str :  * We call it with interrupts disabled.
strstr : INIT :  * We call it with interrupts disabled. : 
strstr : if :  * We call it with interrupts disabled. : 
strstr : for :  * We call it with interrupts disabled. : 
strstr : while :  * We call it with interrupts disabled. : 
str :  */
strstr : INIT :  */ : 
strstr : if :  */ : 
strstr : for :  */ : 
strstr : while :  */ : 
str : void scheduler_tick(void)
strstr : INIT : void scheduler_tick(void) : 
strstr : if : void scheduler_tick(void) : 
strstr : for : void scheduler_tick(void) : 
strstr : while : void scheduler_tick(void) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	int cpu = smp_processor_id();
strstr : INIT : 	int cpu = smp_processor_id(); : 
strstr : if : 	int cpu = smp_processor_id(); : 
strstr : for : 	int cpu = smp_processor_id(); : 
strstr : while : 	int cpu = smp_processor_id(); : 
str : 	struct rq *rq = cpu_rq(cpu);
strstr : INIT : 	struct rq *rq = cpu_rq(cpu); : 
strstr : if : 	struct rq *rq = cpu_rq(cpu); : 
strstr : for : 	struct rq *rq = cpu_rq(cpu); : 
strstr : while : 	struct rq *rq = cpu_rq(cpu); : 
str : 	struct task_struct *curr = rq->curr;
strstr : INIT : 	struct task_struct *curr = rq->curr; : 
strstr : if : 	struct task_struct *curr = rq->curr; : 
strstr : for : 	struct task_struct *curr = rq->curr; : 
strstr : while : 	struct task_struct *curr = rq->curr; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	sched_clock_tick();
strstr : if : 	sched_clock_tick(); : 
strstr : for : 	sched_clock_tick(); : 
strstr : while : 	sched_clock_tick(); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	raw_spin_lock(&rq->lock);
strstr : if : 	raw_spin_lock(&rq->lock); : 
strstr : for : 	raw_spin_lock(&rq->lock); : 
strstr : while : 	raw_spin_lock(&rq->lock); : 
str : 	update_rq_clock(rq);
strstr : INIT : 	update_rq_clock(rq); : 
strstr : if : 	update_rq_clock(rq); : 
strstr : for : 	update_rq_clock(rq); : 
strstr : while : 	update_rq_clock(rq); : 
str : 	curr->sched_class->task_tick(rq, curr, 0);
strstr : INIT : 	curr->sched_class->task_tick(rq, curr, 0); : 
strstr : if : 	curr->sched_class->task_tick(rq, curr, 0); : 
strstr : for : 	curr->sched_class->task_tick(rq, curr, 0); : 
strstr : while : 	curr->sched_class->task_tick(rq, curr, 0); : 
str : 	update_cpu_load_active(rq);
strstr : INIT : 	update_cpu_load_active(rq); : 
strstr : if : 	update_cpu_load_active(rq); : 
strstr : for : 	update_cpu_load_active(rq); : 
strstr : while : 	update_cpu_load_active(rq); : 
str : 	raw_spin_unlock(&rq->lock);
strstr : INIT : 	raw_spin_unlock(&rq->lock); : 
strstr : if : 	raw_spin_unlock(&rq->lock); : 
strstr : for : 	raw_spin_unlock(&rq->lock); : 
strstr : while : 	raw_spin_unlock(&rq->lock); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	perf_event_task_tick();
strstr : if : 	perf_event_task_tick(); : 
strstr : for : 	perf_event_task_tick(); : 
strstr : while : 	perf_event_task_tick(); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : #ifdef CONFIG_SMP
strstr : if : #ifdef CONFIG_SMP : 
strstr : for : #ifdef CONFIG_SMP : 
strstr : while : #ifdef CONFIG_SMP : 
str : 	rq->idle_balance = idle_cpu(cpu);
strstr : INIT : 	rq->idle_balance = idle_cpu(cpu); : 
strstr : if : 	rq->idle_balance = idle_cpu(cpu); : 
strstr : for : 	rq->idle_balance = idle_cpu(cpu); : 
strstr : while : 	rq->idle_balance = idle_cpu(cpu); : 
str : 	trigger_load_balance(rq);
strstr : INIT : 	trigger_load_balance(rq); : 
strstr : if : 	trigger_load_balance(rq); : 
strstr : for : 	trigger_load_balance(rq); : 
strstr : while : 	trigger_load_balance(rq); : 
str : #endif
strstr : INIT : #endif : 
strstr : if : #endif : 
strstr : for : #endif : 
strstr : while : #endif : 
str : 	rq_last_tick_reset(rq);
strstr : INIT : 	rq_last_tick_reset(rq); : 
strstr : if : 	rq_last_tick_reset(rq); : 
strstr : for : 	rq_last_tick_reset(rq); : 
strstr : while : 	rq_last_tick_reset(rq); : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : #ifdef CONFIG_NO_HZ_FULL
strstr : if : #ifdef CONFIG_NO_HZ_FULL : 
strstr : for : #ifdef CONFIG_NO_HZ_FULL : 
strstr : while : #ifdef CONFIG_NO_HZ_FULL : 
str : /**
strstr : INIT : /** : 
strstr : if : /** : 
strstr : for : /** : 
strstr : while : /** : 
str :  * scheduler_tick_max_deferment
strstr : INIT :  * scheduler_tick_max_deferment : 
strstr : if :  * scheduler_tick_max_deferment : 
strstr : for :  * scheduler_tick_max_deferment : 
strstr : while :  * scheduler_tick_max_deferment : 
str :  *
strstr : INIT :  * : 
strstr : if :  * : 
strstr : for :  * : 
strstr : while :  * : 
str :  * Keep at least one tick per second when a single
strstr : INIT :  * Keep at least one tick per second when a single : 
strstr : if :  * Keep at least one tick per second when a single : 
strstr : for :  * Keep at least one tick per second when a single : 
strstr : while :  * Keep at least one tick per second when a single : 
str :  * active task is running because the scheduler doesn't
strstr : INIT :  * active task is running because the scheduler doesn't : 
strstr : if :  * active task is running because the scheduler doesn't : 
strstr : for :  * active task is running because the scheduler doesn't : 
strstr : while :  * active task is running because the scheduler doesn't : 
str :  * yet completely support full dynticks environment.
strstr : INIT :  * yet completely support full dynticks environment. : 
strstr : if :  * yet completely support full dynticks environment. : 
strstr : for :  * yet completely support full dynticks environment. : 
strstr : while :  * yet completely support full dynticks environment. : 
str :  *
strstr : INIT :  * : 
strstr : if :  * : 
strstr : for :  * : 
strstr : while :  * : 
str :  * This makes sure that uptime, CFS vruntime, load
strstr : INIT :  * This makes sure that uptime, CFS vruntime, load : 
strstr : if :  * This makes sure that uptime, CFS vruntime, load : 
strstr : for :  * This makes sure that uptime, CFS vruntime, load : 
strstr : while :  * This makes sure that uptime, CFS vruntime, load : 
str :  * balancing, etc... continue to move forward, even
strstr : INIT :  * balancing, etc... continue to move forward, even : 
strstr : if :  * balancing, etc... continue to move forward, even : 
strstr : for :  * balancing, etc... continue to move forward, even : 
strstr : while :  * balancing, etc... continue to move forward, even : 
str :  * with a very low granularity.
strstr : INIT :  * with a very low granularity. : 
strstr : if :  * with a very low granularity. : 
strstr : for :  * with a very low granularity. : 
strstr : while :  * with a very low granularity. : 
str :  *
strstr : INIT :  * : 
strstr : if :  * : 
strstr : for :  * : 
strstr : while :  * : 
str :  * Return: Maximum deferment in nanoseconds.
strstr : INIT :  * Return: Maximum deferment in nanoseconds. : 
strstr : if :  * Return: Maximum deferment in nanoseconds. : 
strstr : for :  * Return: Maximum deferment in nanoseconds. : 
strstr : while :  * Return: Maximum deferment in nanoseconds. : 
str :  */
strstr : INIT :  */ : 
strstr : if :  */ : 
strstr : for :  */ : 
strstr : while :  */ : 
str : u64 scheduler_tick_max_deferment(void)
strstr : INIT : u64 scheduler_tick_max_deferment(void) : 
strstr : if : u64 scheduler_tick_max_deferment(void) : 
strstr : for : u64 scheduler_tick_max_deferment(void) : 
strstr : while : u64 scheduler_tick_max_deferment(void) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	struct rq *rq = this_rq();
strstr : INIT : 	struct rq *rq = this_rq(); : 
strstr : if : 	struct rq *rq = this_rq(); : 
strstr : for : 	struct rq *rq = this_rq(); : 
strstr : while : 	struct rq *rq = this_rq(); : 
str : 	unsigned long next, now = ACCESS_ONCE(jiffies);
strstr : INIT : 	unsigned long next, now = ACCESS_ONCE(jiffies); : 
strstr : if : 	unsigned long next, now = ACCESS_ONCE(jiffies); : 
strstr : for : 	unsigned long next, now = ACCESS_ONCE(jiffies); : 
strstr : while : 	unsigned long next, now = ACCESS_ONCE(jiffies); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	next = rq->last_sched_tick + HZ;
strstr : if : 	next = rq->last_sched_tick + HZ; : 
strstr : for : 	next = rq->last_sched_tick + HZ; : 
strstr : while : 	next = rq->last_sched_tick + HZ; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	if (time_before_eq(next, now))
strstr : if : 	if (time_before_eq(next, now)) : 
strstr : for : 	if (time_before_eq(next, now)) : 
strstr : while : 	if (time_before_eq(next, now)) : 
str : 		return 0;
strstr : INIT : 		return 0; : 
strstr : if : 		return 0; : 
strstr : for : 		return 0; : 
strstr : while : 		return 0; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	return jiffies_to_nsecs(next - now);
strstr : if : 	return jiffies_to_nsecs(next - now); : 
strstr : for : 	return jiffies_to_nsecs(next - now); : 
strstr : while : 	return jiffies_to_nsecs(next - now); : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : #endif
strstr : INIT : #endif : 
strstr : if : #endif : 
strstr : for : #endif : 
strstr : while : #endif : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : notrace unsigned long get_parent_ip(unsigned long addr)
strstr : if : notrace unsigned long get_parent_ip(unsigned long addr) : 
strstr : for : notrace unsigned long get_parent_ip(unsigned long addr) : 
strstr : while : notrace unsigned long get_parent_ip(unsigned long addr) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	if (in_lock_functions(addr)) {
strstr : INIT : 	if (in_lock_functions(addr)) { : 
strstr : if : 	if (in_lock_functions(addr)) { : 
strstr : for : 	if (in_lock_functions(addr)) { : 
strstr : while : 	if (in_lock_functions(addr)) { : 
str : 		addr = CALLER_ADDR2;
strstr : INIT : 		addr = CALLER_ADDR2; : 
strstr : if : 		addr = CALLER_ADDR2; : 
strstr : for : 		addr = CALLER_ADDR2; : 
strstr : while : 		addr = CALLER_ADDR2; : 
str : 		if (in_lock_functions(addr))
strstr : INIT : 		if (in_lock_functions(addr)) : 
strstr : if : 		if (in_lock_functions(addr)) : 
strstr : for : 		if (in_lock_functions(addr)) : 
strstr : while : 		if (in_lock_functions(addr)) : 
str : 			addr = CALLER_ADDR3;
strstr : INIT : 			addr = CALLER_ADDR3; : 
strstr : if : 			addr = CALLER_ADDR3; : 
strstr : for : 			addr = CALLER_ADDR3; : 
strstr : while : 			addr = CALLER_ADDR3; : 
str : 	}
strstr : INIT : 	} : 
strstr : if : 	} : 
strstr : for : 	} : 
strstr : while : 	} : 
str : 	return addr;
strstr : INIT : 	return addr; : 
strstr : if : 	return addr; : 
strstr : for : 	return addr; : 
strstr : while : 	return addr; : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : #if defined(CONFIG_PREEMPT) && (defined(CONFIG_DEBUG_PREEMPT) || \
strstr : if : #if defined(CONFIG_PREEMPT) && (defined(CONFIG_DEBUG_PREEMPT) || \ : 
strstr : for : #if defined(CONFIG_PREEMPT) && (defined(CONFIG_DEBUG_PREEMPT) || \ : 
strstr : while : #if defined(CONFIG_PREEMPT) && (defined(CONFIG_DEBUG_PREEMPT) || \ : 
str : 				defined(CONFIG_PREEMPT_TRACER))
strstr : INIT : 				defined(CONFIG_PREEMPT_TRACER)) : 
strstr : if : 				defined(CONFIG_PREEMPT_TRACER)) : 
strstr : for : 				defined(CONFIG_PREEMPT_TRACER)) : 
strstr : while : 				defined(CONFIG_PREEMPT_TRACER)) : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : void __kprobes preempt_count_add(int val)
strstr : if : void __kprobes preempt_count_add(int val) : 
strstr : for : void __kprobes preempt_count_add(int val) : 
strstr : while : void __kprobes preempt_count_add(int val) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : #ifdef CONFIG_DEBUG_PREEMPT
strstr : INIT : #ifdef CONFIG_DEBUG_PREEMPT : 
strstr : if : #ifdef CONFIG_DEBUG_PREEMPT : 
strstr : for : #ifdef CONFIG_DEBUG_PREEMPT : 
strstr : while : #ifdef CONFIG_DEBUG_PREEMPT : 
str : 	/*
strstr : INIT : 	/* : 
strstr : if : 	/* : 
strstr : for : 	/* : 
strstr : while : 	/* : 
str : 	 * Underflow?
strstr : INIT : 	 * Underflow? : 
strstr : if : 	 * Underflow? : 
strstr : for : 	 * Underflow? : 
strstr : while : 	 * Underflow? : 
str : 	 */
strstr : INIT : 	 */ : 
strstr : if : 	 */ : 
strstr : for : 	 */ : 
strstr : while : 	 */ : 
str : 	if (DEBUG_LOCKS_WARN_ON((preempt_count() < 0)))
strstr : INIT : 	if (DEBUG_LOCKS_WARN_ON((preempt_count() < 0))) : 
strstr : if : 	if (DEBUG_LOCKS_WARN_ON((preempt_count() < 0))) : 
strstr : for : 	if (DEBUG_LOCKS_WARN_ON((preempt_count() < 0))) : 
strstr : while : 	if (DEBUG_LOCKS_WARN_ON((preempt_count() < 0))) : 
str : 		return;
strstr : INIT : 		return; : 
strstr : if : 		return; : 
strstr : for : 		return; : 
strstr : while : 		return; : 
str : #endif
strstr : INIT : #endif : 
strstr : if : #endif : 
strstr : for : #endif : 
strstr : while : #endif : 
str : 	__preempt_count_add(val);
strstr : INIT : 	__preempt_count_add(val); : 
strstr : if : 	__preempt_count_add(val); : 
strstr : for : 	__preempt_count_add(val); : 
strstr : while : 	__preempt_count_add(val); : 
str : #ifdef CONFIG_DEBUG_PREEMPT
strstr : INIT : #ifdef CONFIG_DEBUG_PREEMPT : 
strstr : if : #ifdef CONFIG_DEBUG_PREEMPT : 
strstr : for : #ifdef CONFIG_DEBUG_PREEMPT : 
strstr : while : #ifdef CONFIG_DEBUG_PREEMPT : 
str : 	/*
strstr : INIT : 	/* : 
strstr : if : 	/* : 
strstr : for : 	/* : 
strstr : while : 	/* : 
str : 	 * Spinlock count overflowing soon?
strstr : INIT : 	 * Spinlock count overflowing soon? : 
strstr : if : 	 * Spinlock count overflowing soon? : 
strstr : for : 	 * Spinlock count overflowing soon? : 
strstr : while : 	 * Spinlock count overflowing soon? : 
str : 	 */
strstr : INIT : 	 */ : 
strstr : if : 	 */ : 
strstr : for : 	 */ : 
strstr : while : 	 */ : 
str : 	DEBUG_LOCKS_WARN_ON((preempt_count() & PREEMPT_MASK) >=
strstr : INIT : 	DEBUG_LOCKS_WARN_ON((preempt_count() & PREEMPT_MASK) >= : 
strstr : if : 	DEBUG_LOCKS_WARN_ON((preempt_count() & PREEMPT_MASK) >= : 
strstr : for : 	DEBUG_LOCKS_WARN_ON((preempt_count() & PREEMPT_MASK) >= : 
strstr : while : 	DEBUG_LOCKS_WARN_ON((preempt_count() & PREEMPT_MASK) >= : 
str : 				PREEMPT_MASK - 10);
strstr : INIT : 				PREEMPT_MASK - 10); : 
strstr : if : 				PREEMPT_MASK - 10); : 
strstr : for : 				PREEMPT_MASK - 10); : 
strstr : while : 				PREEMPT_MASK - 10); : 
str : #endif
strstr : INIT : #endif : 
strstr : if : #endif : 
strstr : for : #endif : 
strstr : while : #endif : 
str : 	if (preempt_count() == val)
strstr : INIT : 	if (preempt_count() == val) : 
strstr : if : 	if (preempt_count() == val) : 
strstr : for : 	if (preempt_count() == val) : 
strstr : while : 	if (preempt_count() == val) : 
str : 		trace_preempt_off(CALLER_ADDR0, get_parent_ip(CALLER_ADDR1));
strstr : INIT : 		trace_preempt_off(CALLER_ADDR0, get_parent_ip(CALLER_ADDR1)); : 
strstr : if : 		trace_preempt_off(CALLER_ADDR0, get_parent_ip(CALLER_ADDR1)); : 
strstr : for : 		trace_preempt_off(CALLER_ADDR0, get_parent_ip(CALLER_ADDR1)); : 
strstr : while : 		trace_preempt_off(CALLER_ADDR0, get_parent_ip(CALLER_ADDR1)); : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : EXPORT_SYMBOL(preempt_count_add);
strstr : INIT : EXPORT_SYMBOL(preempt_count_add); : 
strstr : if : EXPORT_SYMBOL(preempt_count_add); : 
strstr : for : EXPORT_SYMBOL(preempt_count_add); : 
strstr : while : EXPORT_SYMBOL(preempt_count_add); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : void __kprobes preempt_count_sub(int val)
strstr : if : void __kprobes preempt_count_sub(int val) : 
strstr : for : void __kprobes preempt_count_sub(int val) : 
strstr : while : void __kprobes preempt_count_sub(int val) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : #ifdef CONFIG_DEBUG_PREEMPT
strstr : INIT : #ifdef CONFIG_DEBUG_PREEMPT : 
strstr : if : #ifdef CONFIG_DEBUG_PREEMPT : 
strstr : for : #ifdef CONFIG_DEBUG_PREEMPT : 
strstr : while : #ifdef CONFIG_DEBUG_PREEMPT : 
str : 	/*
strstr : INIT : 	/* : 
strstr : if : 	/* : 
strstr : for : 	/* : 
strstr : while : 	/* : 
str : 	 * Underflow?
strstr : INIT : 	 * Underflow? : 
strstr : if : 	 * Underflow? : 
strstr : for : 	 * Underflow? : 
strstr : while : 	 * Underflow? : 
str : 	 */
strstr : INIT : 	 */ : 
strstr : if : 	 */ : 
strstr : for : 	 */ : 
strstr : while : 	 */ : 
str : 	if (DEBUG_LOCKS_WARN_ON(val > preempt_count()))
strstr : INIT : 	if (DEBUG_LOCKS_WARN_ON(val > preempt_count())) : 
strstr : if : 	if (DEBUG_LOCKS_WARN_ON(val > preempt_count())) : 
strstr : for : 	if (DEBUG_LOCKS_WARN_ON(val > preempt_count())) : 
strstr : while : 	if (DEBUG_LOCKS_WARN_ON(val > preempt_count())) : 
str : 		return;
strstr : INIT : 		return; : 
strstr : if : 		return; : 
strstr : for : 		return; : 
strstr : while : 		return; : 
str : 	/*
strstr : INIT : 	/* : 
strstr : if : 	/* : 
strstr : for : 	/* : 
strstr : while : 	/* : 
str : 	 * Is the spinlock portion underflowing?
strstr : INIT : 	 * Is the spinlock portion underflowing? : 
strstr : if : 	 * Is the spinlock portion underflowing? : 
strstr : for : 	 * Is the spinlock portion underflowing? : 
strstr : while : 	 * Is the spinlock portion underflowing? : 
str : 	 */
strstr : INIT : 	 */ : 
strstr : if : 	 */ : 
strstr : for : 	 */ : 
strstr : while : 	 */ : 
str : 	if (DEBUG_LOCKS_WARN_ON((val < PREEMPT_MASK) &&
strstr : INIT : 	if (DEBUG_LOCKS_WARN_ON((val < PREEMPT_MASK) && : 
strstr : if : 	if (DEBUG_LOCKS_WARN_ON((val < PREEMPT_MASK) && : 
strstr : for : 	if (DEBUG_LOCKS_WARN_ON((val < PREEMPT_MASK) && : 
strstr : while : 	if (DEBUG_LOCKS_WARN_ON((val < PREEMPT_MASK) && : 
str : 			!(preempt_count() & PREEMPT_MASK)))
strstr : INIT : 			!(preempt_count() & PREEMPT_MASK))) : 
strstr : if : 			!(preempt_count() & PREEMPT_MASK))) : 
strstr : for : 			!(preempt_count() & PREEMPT_MASK))) : 
strstr : while : 			!(preempt_count() & PREEMPT_MASK))) : 
str : 		return;
strstr : INIT : 		return; : 
strstr : if : 		return; : 
strstr : for : 		return; : 
strstr : while : 		return; : 
str : #endif
strstr : INIT : #endif : 
strstr : if : #endif : 
strstr : for : #endif : 
strstr : while : #endif : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	if (preempt_count() == val)
strstr : if : 	if (preempt_count() == val) : 
strstr : for : 	if (preempt_count() == val) : 
strstr : while : 	if (preempt_count() == val) : 
str : 		trace_preempt_on(CALLER_ADDR0, get_parent_ip(CALLER_ADDR1));
strstr : INIT : 		trace_preempt_on(CALLER_ADDR0, get_parent_ip(CALLER_ADDR1)); : 
strstr : if : 		trace_preempt_on(CALLER_ADDR0, get_parent_ip(CALLER_ADDR1)); : 
strstr : for : 		trace_preempt_on(CALLER_ADDR0, get_parent_ip(CALLER_ADDR1)); : 
strstr : while : 		trace_preempt_on(CALLER_ADDR0, get_parent_ip(CALLER_ADDR1)); : 
str : 	__preempt_count_sub(val);
strstr : INIT : 	__preempt_count_sub(val); : 
strstr : if : 	__preempt_count_sub(val); : 
strstr : for : 	__preempt_count_sub(val); : 
strstr : while : 	__preempt_count_sub(val); : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : EXPORT_SYMBOL(preempt_count_sub);
strstr : INIT : EXPORT_SYMBOL(preempt_count_sub); : 
strstr : if : EXPORT_SYMBOL(preempt_count_sub); : 
strstr : for : EXPORT_SYMBOL(preempt_count_sub); : 
strstr : while : EXPORT_SYMBOL(preempt_count_sub); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : #endif
strstr : if : #endif : 
strstr : for : #endif : 
strstr : while : #endif : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : /*
strstr : if : /* : 
strstr : for : /* : 
strstr : while : /* : 
str :  * Print scheduling while atomic bug:
strstr : INIT :  * Print scheduling while atomic bug: : 
strstr : if :  * Print scheduling while atomic bug: : 
strstr : for :  * Print scheduling while atomic bug: : 
strstr : while :  * Print scheduling while atomic bug: : 
str :  */
strstr : INIT :  */ : 
strstr : if :  */ : 
strstr : for :  */ : 
strstr : while :  */ : 
str : static noinline void __schedule_bug(struct task_struct *prev)
strstr : INIT : static noinline void __schedule_bug(struct task_struct *prev) : 
strstr : if : static noinline void __schedule_bug(struct task_struct *prev) : 
strstr : for : static noinline void __schedule_bug(struct task_struct *prev) : 
strstr : while : static noinline void __schedule_bug(struct task_struct *prev) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	if (oops_in_progress)
strstr : INIT : 	if (oops_in_progress) : 
strstr : if : 	if (oops_in_progress) : 
strstr : for : 	if (oops_in_progress) : 
strstr : while : 	if (oops_in_progress) : 
str : 		return;
strstr : INIT : 		return; : 
strstr : if : 		return; : 
strstr : for : 		return; : 
strstr : while : 		return; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	printk(KERN_ERR "BUG: scheduling while atomic: %s/%d/0x%08x\n",
strstr : if : 	printk(KERN_ERR "BUG: scheduling while atomic: %s/%d/0x%08x\n", : 
strstr : for : 	printk(KERN_ERR "BUG: scheduling while atomic: %s/%d/0x%08x\n", : 
strstr : while : 	printk(KERN_ERR "BUG: scheduling while atomic: %s/%d/0x%08x\n", : 
str : 		prev->comm, prev->pid, preempt_count());
strstr : INIT : 		prev->comm, prev->pid, preempt_count()); : 
strstr : if : 		prev->comm, prev->pid, preempt_count()); : 
strstr : for : 		prev->comm, prev->pid, preempt_count()); : 
strstr : while : 		prev->comm, prev->pid, preempt_count()); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	debug_show_held_locks(prev);
strstr : if : 	debug_show_held_locks(prev); : 
strstr : for : 	debug_show_held_locks(prev); : 
strstr : while : 	debug_show_held_locks(prev); : 
str : 	print_modules();
strstr : INIT : 	print_modules(); : 
strstr : if : 	print_modules(); : 
strstr : for : 	print_modules(); : 
strstr : while : 	print_modules(); : 
str : 	if (irqs_disabled())
strstr : INIT : 	if (irqs_disabled()) : 
strstr : if : 	if (irqs_disabled()) : 
strstr : for : 	if (irqs_disabled()) : 
strstr : while : 	if (irqs_disabled()) : 
str : 		print_irqtrace_events(prev);
strstr : INIT : 		print_irqtrace_events(prev); : 
strstr : if : 		print_irqtrace_events(prev); : 
strstr : for : 		print_irqtrace_events(prev); : 
strstr : while : 		print_irqtrace_events(prev); : 
str : 	dump_stack();
strstr : INIT : 	dump_stack(); : 
strstr : if : 	dump_stack(); : 
strstr : for : 	dump_stack(); : 
strstr : while : 	dump_stack(); : 
str : 	add_taint(TAINT_WARN, LOCKDEP_STILL_OK);
strstr : INIT : 	add_taint(TAINT_WARN, LOCKDEP_STILL_OK); : 
strstr : if : 	add_taint(TAINT_WARN, LOCKDEP_STILL_OK); : 
strstr : for : 	add_taint(TAINT_WARN, LOCKDEP_STILL_OK); : 
strstr : while : 	add_taint(TAINT_WARN, LOCKDEP_STILL_OK); : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : /*
strstr : if : /* : 
strstr : for : /* : 
strstr : while : /* : 
str :  * Various schedule()-time debugging checks and statistics:
strstr : INIT :  * Various schedule()-time debugging checks and statistics: : 
strstr : if :  * Various schedule()-time debugging checks and statistics: : 
strstr : for :  * Various schedule()-time debugging checks and statistics: : 
strstr : while :  * Various schedule()-time debugging checks and statistics: : 
str :  */
strstr : INIT :  */ : 
strstr : if :  */ : 
strstr : for :  */ : 
strstr : while :  */ : 
str : static inline void schedule_debug(struct task_struct *prev)
strstr : INIT : static inline void schedule_debug(struct task_struct *prev) : 
strstr : if : static inline void schedule_debug(struct task_struct *prev) : 
strstr : for : static inline void schedule_debug(struct task_struct *prev) : 
strstr : while : static inline void schedule_debug(struct task_struct *prev) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	/*
strstr : INIT : 	/* : 
strstr : if : 	/* : 
strstr : for : 	/* : 
strstr : while : 	/* : 
str : 	 * Test if we are atomic. Since do_exit() needs to call into
strstr : INIT : 	 * Test if we are atomic. Since do_exit() needs to call into : 
strstr : if : 	 * Test if we are atomic. Since do_exit() needs to call into : 
strstr : for : 	 * Test if we are atomic. Since do_exit() needs to call into : 
strstr : while : 	 * Test if we are atomic. Since do_exit() needs to call into : 
str : 	 * schedule() atomically, we ignore that path. Otherwise whine
strstr : INIT : 	 * schedule() atomically, we ignore that path. Otherwise whine : 
strstr : if : 	 * schedule() atomically, we ignore that path. Otherwise whine : 
strstr : for : 	 * schedule() atomically, we ignore that path. Otherwise whine : 
strstr : while : 	 * schedule() atomically, we ignore that path. Otherwise whine : 
str : 	 * if we are scheduling when we should not.
strstr : INIT : 	 * if we are scheduling when we should not. : 
strstr : if : 	 * if we are scheduling when we should not. : 
strstr : for : 	 * if we are scheduling when we should not. : 
strstr : while : 	 * if we are scheduling when we should not. : 
str : 	 */
strstr : INIT : 	 */ : 
strstr : if : 	 */ : 
strstr : for : 	 */ : 
strstr : while : 	 */ : 
str : 	if (unlikely(in_atomic_preempt_off() && prev->state != TASK_DEAD))
strstr : INIT : 	if (unlikely(in_atomic_preempt_off() && prev->state != TASK_DEAD)) : 
strstr : if : 	if (unlikely(in_atomic_preempt_off() && prev->state != TASK_DEAD)) : 
strstr : for : 	if (unlikely(in_atomic_preempt_off() && prev->state != TASK_DEAD)) : 
strstr : while : 	if (unlikely(in_atomic_preempt_off() && prev->state != TASK_DEAD)) : 
str : 		__schedule_bug(prev);
strstr : INIT : 		__schedule_bug(prev); : 
strstr : if : 		__schedule_bug(prev); : 
strstr : for : 		__schedule_bug(prev); : 
strstr : while : 		__schedule_bug(prev); : 
str : 	rcu_sleep_check();
strstr : INIT : 	rcu_sleep_check(); : 
strstr : if : 	rcu_sleep_check(); : 
strstr : for : 	rcu_sleep_check(); : 
strstr : while : 	rcu_sleep_check(); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	profile_hit(SCHED_PROFILING, __builtin_return_address(0));
strstr : if : 	profile_hit(SCHED_PROFILING, __builtin_return_address(0)); : 
strstr : for : 	profile_hit(SCHED_PROFILING, __builtin_return_address(0)); : 
strstr : while : 	profile_hit(SCHED_PROFILING, __builtin_return_address(0)); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	schedstat_inc(this_rq(), sched_count);
strstr : if : 	schedstat_inc(this_rq(), sched_count); : 
strstr : for : 	schedstat_inc(this_rq(), sched_count); : 
strstr : while : 	schedstat_inc(this_rq(), sched_count); : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : static void put_prev_task(struct rq *rq, struct task_struct *prev)
strstr : if : static void put_prev_task(struct rq *rq, struct task_struct *prev) : 
strstr : for : static void put_prev_task(struct rq *rq, struct task_struct *prev) : 
strstr : while : static void put_prev_task(struct rq *rq, struct task_struct *prev) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	if (prev->on_rq || rq->skip_clock_update < 0)
strstr : INIT : 	if (prev->on_rq || rq->skip_clock_update < 0) : 
strstr : if : 	if (prev->on_rq || rq->skip_clock_update < 0) : 
strstr : for : 	if (prev->on_rq || rq->skip_clock_update < 0) : 
strstr : while : 	if (prev->on_rq || rq->skip_clock_update < 0) : 
str : 		update_rq_clock(rq);
strstr : INIT : 		update_rq_clock(rq); : 
strstr : if : 		update_rq_clock(rq); : 
strstr : for : 		update_rq_clock(rq); : 
strstr : while : 		update_rq_clock(rq); : 
str : 	prev->sched_class->put_prev_task(rq, prev);
strstr : INIT : 	prev->sched_class->put_prev_task(rq, prev); : 
strstr : if : 	prev->sched_class->put_prev_task(rq, prev); : 
strstr : for : 	prev->sched_class->put_prev_task(rq, prev); : 
strstr : while : 	prev->sched_class->put_prev_task(rq, prev); : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : /*
strstr : if : /* : 
strstr : for : /* : 
strstr : while : /* : 
str :  * Pick up the highest-prio task:
strstr : INIT :  * Pick up the highest-prio task: : 
strstr : if :  * Pick up the highest-prio task: : 
strstr : for :  * Pick up the highest-prio task: : 
strstr : while :  * Pick up the highest-prio task: : 
str :  */
strstr : INIT :  */ : 
strstr : if :  */ : 
strstr : for :  */ : 
strstr : while :  */ : 
str : static inline struct task_struct *
strstr : INIT : static inline struct task_struct * : 
strstr : if : static inline struct task_struct * : 
strstr : for : static inline struct task_struct * : 
strstr : while : static inline struct task_struct * : 
str : pick_next_task(struct rq *rq)
strstr : INIT : pick_next_task(struct rq *rq) : 
strstr : if : pick_next_task(struct rq *rq) : 
strstr : for : pick_next_task(struct rq *rq) : 
strstr : while : pick_next_task(struct rq *rq) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	const struct sched_class *class;
strstr : INIT : 	const struct sched_class *class; : 
strstr : if : 	const struct sched_class *class; : 
strstr : for : 	const struct sched_class *class; : 
strstr : while : 	const struct sched_class *class; : 
str : 	struct task_struct *p;
strstr : INIT : 	struct task_struct *p; : 
strstr : if : 	struct task_struct *p; : 
strstr : for : 	struct task_struct *p; : 
strstr : while : 	struct task_struct *p; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	/*
strstr : if : 	/* : 
strstr : for : 	/* : 
strstr : while : 	/* : 
str : 	 * Optimization: we know that if all tasks are in
strstr : INIT : 	 * Optimization: we know that if all tasks are in : 
strstr : if : 	 * Optimization: we know that if all tasks are in : 
strstr : for : 	 * Optimization: we know that if all tasks are in : 
strstr : while : 	 * Optimization: we know that if all tasks are in : 
str : 	 * the fair class we can call that function directly:
strstr : INIT : 	 * the fair class we can call that function directly: : 
strstr : if : 	 * the fair class we can call that function directly: : 
strstr : for : 	 * the fair class we can call that function directly: : 
strstr : while : 	 * the fair class we can call that function directly: : 
str : 	 */
strstr : INIT : 	 */ : 
strstr : if : 	 */ : 
strstr : for : 	 */ : 
strstr : while : 	 */ : 
str : 	if (likely(rq->nr_running == rq->cfs.h_nr_running)) {
strstr : INIT : 	if (likely(rq->nr_running == rq->cfs.h_nr_running)) { : 
strstr : if : 	if (likely(rq->nr_running == rq->cfs.h_nr_running)) { : 
strstr : for : 	if (likely(rq->nr_running == rq->cfs.h_nr_running)) { : 
strstr : while : 	if (likely(rq->nr_running == rq->cfs.h_nr_running)) { : 
str : 		p = fair_sched_class.pick_next_task(rq);
strstr : INIT : 		p = fair_sched_class.pick_next_task(rq); : 
strstr : if : 		p = fair_sched_class.pick_next_task(rq); : 
strstr : for : 		p = fair_sched_class.pick_next_task(rq); : 
strstr : while : 		p = fair_sched_class.pick_next_task(rq); : 
str : 		if (likely(p))
strstr : INIT : 		if (likely(p)) : 
strstr : if : 		if (likely(p)) : 
strstr : for : 		if (likely(p)) : 
strstr : while : 		if (likely(p)) : 
str : 			return p;
strstr : INIT : 			return p; : 
strstr : if : 			return p; : 
strstr : for : 			return p; : 
strstr : while : 			return p; : 
str : 	}
strstr : INIT : 	} : 
strstr : if : 	} : 
strstr : for : 	} : 
strstr : while : 	} : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	for_each_class(class) {
strstr : if : 	for_each_class(class) { : 
strstr : for : 	for_each_class(class) { : 
strstr : while : 	for_each_class(class) { : 
str : 		p = class->pick_next_task(rq);
strstr : INIT : 		p = class->pick_next_task(rq); : 
strstr : if : 		p = class->pick_next_task(rq); : 
strstr : for : 		p = class->pick_next_task(rq); : 
strstr : while : 		p = class->pick_next_task(rq); : 
str : 		if (p)
strstr : INIT : 		if (p) : 
strstr : if : 		if (p) : 
strstr : for : 		if (p) : 
strstr : while : 		if (p) : 
str : 			return p;
strstr : INIT : 			return p; : 
strstr : if : 			return p; : 
strstr : for : 			return p; : 
strstr : while : 			return p; : 
str : 	}
strstr : INIT : 	} : 
strstr : if : 	} : 
strstr : for : 	} : 
strstr : while : 	} : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	BUG(); /* the idle class will always have a runnable task */
strstr : if : 	BUG(); /* the idle class will always have a runnable task */ : 
strstr : for : 	BUG(); /* the idle class will always have a runnable task */ : 
strstr : while : 	BUG(); /* the idle class will always have a runnable task */ : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : /*
strstr : if : /* : 
strstr : for : /* : 
strstr : while : /* : 
str :  * __schedule() is the main scheduler function.
strstr : INIT :  * __schedule() is the main scheduler function. : 
strstr : if :  * __schedule() is the main scheduler function. : 
strstr : for :  * __schedule() is the main scheduler function. : 
strstr : while :  * __schedule() is the main scheduler function. : 
str :  *
strstr : INIT :  * : 
strstr : if :  * : 
strstr : for :  * : 
strstr : while :  * : 
str :  * The main means of driving the scheduler and thus entering this function are:
strstr : INIT :  * The main means of driving the scheduler and thus entering this function are: : 
strstr : if :  * The main means of driving the scheduler and thus entering this function are: : 
strstr : for :  * The main means of driving the scheduler and thus entering this function are: : 
strstr : while :  * The main means of driving the scheduler and thus entering this function are: : 
str :  *
strstr : INIT :  * : 
strstr : if :  * : 
strstr : for :  * : 
strstr : while :  * : 
str :  *   1. Explicit blocking: mutex, semaphore, waitqueue, etc.
strstr : INIT :  *   1. Explicit blocking: mutex, semaphore, waitqueue, etc. : 
strstr : if :  *   1. Explicit blocking: mutex, semaphore, waitqueue, etc. : 
strstr : for :  *   1. Explicit blocking: mutex, semaphore, waitqueue, etc. : 
strstr : while :  *   1. Explicit blocking: mutex, semaphore, waitqueue, etc. : 
str :  *
strstr : INIT :  * : 
strstr : if :  * : 
strstr : for :  * : 
strstr : while :  * : 
str :  *   2. TIF_NEED_RESCHED flag is checked on interrupt and userspace return
strstr : INIT :  *   2. TIF_NEED_RESCHED flag is checked on interrupt and userspace return : 
strstr : if :  *   2. TIF_NEED_RESCHED flag is checked on interrupt and userspace return : 
strstr : for :  *   2. TIF_NEED_RESCHED flag is checked on interrupt and userspace return : 
strstr : while :  *   2. TIF_NEED_RESCHED flag is checked on interrupt and userspace return : 
str :  *      paths. For example, see arch/x86/entry_64.S.
strstr : INIT :  *      paths. For example, see arch/x86/entry_64.S. : 
strstr : if :  *      paths. For example, see arch/x86/entry_64.S. : 
strstr : for :  *      paths. For example, see arch/x86/entry_64.S. : 
strstr : while :  *      paths. For example, see arch/x86/entry_64.S. : 
str :  *
strstr : INIT :  * : 
strstr : if :  * : 
strstr : for :  * : 
strstr : while :  * : 
str :  *      To drive preemption between tasks, the scheduler sets the flag in timer
strstr : INIT :  *      To drive preemption between tasks, the scheduler sets the flag in timer : 
strstr : if :  *      To drive preemption between tasks, the scheduler sets the flag in timer : 
strstr : for :  *      To drive preemption between tasks, the scheduler sets the flag in timer : 
strstr : while :  *      To drive preemption between tasks, the scheduler sets the flag in timer : 
str :  *      interrupt handler scheduler_tick().
strstr : INIT :  *      interrupt handler scheduler_tick(). : 
strstr : if :  *      interrupt handler scheduler_tick(). : 
strstr : for :  *      interrupt handler scheduler_tick(). : 
strstr : while :  *      interrupt handler scheduler_tick(). : 
str :  *
strstr : INIT :  * : 
strstr : if :  * : 
strstr : for :  * : 
strstr : while :  * : 
str :  *   3. Wakeups don't really cause entry into schedule(). They add a
strstr : INIT :  *   3. Wakeups don't really cause entry into schedule(). They add a : 
strstr : if :  *   3. Wakeups don't really cause entry into schedule(). They add a : 
strstr : for :  *   3. Wakeups don't really cause entry into schedule(). They add a : 
strstr : while :  *   3. Wakeups don't really cause entry into schedule(). They add a : 
str :  *      task to the run-queue and that's it.
strstr : INIT :  *      task to the run-queue and that's it. : 
strstr : if :  *      task to the run-queue and that's it. : 
strstr : for :  *      task to the run-queue and that's it. : 
strstr : while :  *      task to the run-queue and that's it. : 
str :  *
strstr : INIT :  * : 
strstr : if :  * : 
strstr : for :  * : 
strstr : while :  * : 
str :  *      Now, if the new task added to the run-queue preempts the current
strstr : INIT :  *      Now, if the new task added to the run-queue preempts the current : 
strstr : if :  *      Now, if the new task added to the run-queue preempts the current : 
strstr : for :  *      Now, if the new task added to the run-queue preempts the current : 
strstr : while :  *      Now, if the new task added to the run-queue preempts the current : 
str :  *      task, then the wakeup sets TIF_NEED_RESCHED and schedule() gets
strstr : INIT :  *      task, then the wakeup sets TIF_NEED_RESCHED and schedule() gets : 
strstr : if :  *      task, then the wakeup sets TIF_NEED_RESCHED and schedule() gets : 
strstr : for :  *      task, then the wakeup sets TIF_NEED_RESCHED and schedule() gets : 
strstr : while :  *      task, then the wakeup sets TIF_NEED_RESCHED and schedule() gets : 
str :  *      called on the nearest possible occasion:
strstr : INIT :  *      called on the nearest possible occasion: : 
strstr : if :  *      called on the nearest possible occasion: : 
strstr : for :  *      called on the nearest possible occasion: : 
strstr : while :  *      called on the nearest possible occasion: : 
str :  *
strstr : INIT :  * : 
strstr : if :  * : 
strstr : for :  * : 
strstr : while :  * : 
str :  *       - If the kernel is preemptible (CONFIG_PREEMPT=y):
strstr : INIT :  *       - If the kernel is preemptible (CONFIG_PREEMPT=y): : 
strstr : if :  *       - If the kernel is preemptible (CONFIG_PREEMPT=y): : 
strstr : for :  *       - If the kernel is preemptible (CONFIG_PREEMPT=y): : 
strstr : while :  *       - If the kernel is preemptible (CONFIG_PREEMPT=y): : 
str :  *
strstr : INIT :  * : 
strstr : if :  * : 
strstr : for :  * : 
strstr : while :  * : 
str :  *         - in syscall or exception context, at the next outmost
strstr : INIT :  *         - in syscall or exception context, at the next outmost : 
strstr : if :  *         - in syscall or exception context, at the next outmost : 
strstr : for :  *         - in syscall or exception context, at the next outmost : 
strstr : while :  *         - in syscall or exception context, at the next outmost : 
str :  *           preempt_enable(). (this might be as soon as the wake_up()'s
strstr : INIT :  *           preempt_enable(). (this might be as soon as the wake_up()'s : 
strstr : if :  *           preempt_enable(). (this might be as soon as the wake_up()'s : 
strstr : for :  *           preempt_enable(). (this might be as soon as the wake_up()'s : 
strstr : while :  *           preempt_enable(). (this might be as soon as the wake_up()'s : 
str :  *           spin_unlock()!)
strstr : INIT :  *           spin_unlock()!) : 
strstr : if :  *           spin_unlock()!) : 
strstr : for :  *           spin_unlock()!) : 
strstr : while :  *           spin_unlock()!) : 
str :  *
strstr : INIT :  * : 
strstr : if :  * : 
strstr : for :  * : 
strstr : while :  * : 
str :  *         - in IRQ context, return from interrupt-handler to
strstr : INIT :  *         - in IRQ context, return from interrupt-handler to : 
strstr : if :  *         - in IRQ context, return from interrupt-handler to : 
strstr : for :  *         - in IRQ context, return from interrupt-handler to : 
strstr : while :  *         - in IRQ context, return from interrupt-handler to : 
str :  *           preemptible context
strstr : INIT :  *           preemptible context : 
strstr : if :  *           preemptible context : 
strstr : for :  *           preemptible context : 
strstr : while :  *           preemptible context : 
str :  *
strstr : INIT :  * : 
strstr : if :  * : 
strstr : for :  * : 
strstr : while :  * : 
str :  *       - If the kernel is not preemptible (CONFIG_PREEMPT is not set)
strstr : INIT :  *       - If the kernel is not preemptible (CONFIG_PREEMPT is not set) : 
strstr : if :  *       - If the kernel is not preemptible (CONFIG_PREEMPT is not set) : 
strstr : for :  *       - If the kernel is not preemptible (CONFIG_PREEMPT is not set) : 
strstr : while :  *       - If the kernel is not preemptible (CONFIG_PREEMPT is not set) : 
str :  *         then at the next:
strstr : INIT :  *         then at the next: : 
strstr : if :  *         then at the next: : 
strstr : for :  *         then at the next: : 
strstr : while :  *         then at the next: : 
str :  *
strstr : INIT :  * : 
strstr : if :  * : 
strstr : for :  * : 
strstr : while :  * : 
str :  *          - cond_resched() call
strstr : INIT :  *          - cond_resched() call : 
strstr : if :  *          - cond_resched() call : 
strstr : for :  *          - cond_resched() call : 
strstr : while :  *          - cond_resched() call : 
str :  *          - explicit schedule() call
strstr : INIT :  *          - explicit schedule() call : 
strstr : if :  *          - explicit schedule() call : 
strstr : for :  *          - explicit schedule() call : 
strstr : while :  *          - explicit schedule() call : 
str :  *          - return from syscall or exception to user-space
strstr : INIT :  *          - return from syscall or exception to user-space : 
strstr : if :  *          - return from syscall or exception to user-space : 
strstr : for :  *          - return from syscall or exception to user-space : 
strstr : while :  *          - return from syscall or exception to user-space : 
str :  *          - return from interrupt-handler to user-space
strstr : INIT :  *          - return from interrupt-handler to user-space : 
strstr : if :  *          - return from interrupt-handler to user-space : 
strstr : for :  *          - return from interrupt-handler to user-space : 
strstr : while :  *          - return from interrupt-handler to user-space : 
str :  */
strstr : INIT :  */ : 
strstr : if :  */ : 
strstr : for :  */ : 
strstr : while :  */ : 
str : static void __sched __schedule(void)
strstr : INIT : static void __sched __schedule(void) : 
strstr : if : static void __sched __schedule(void) : 
strstr : for : static void __sched __schedule(void) : 
strstr : while : static void __sched __schedule(void) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	struct task_struct *prev, *next;
strstr : INIT : 	struct task_struct *prev, *next; : 
strstr : if : 	struct task_struct *prev, *next; : 
strstr : for : 	struct task_struct *prev, *next; : 
strstr : while : 	struct task_struct *prev, *next; : 
str : 	unsigned long *switch_count;
strstr : INIT : 	unsigned long *switch_count; : 
strstr : if : 	unsigned long *switch_count; : 
strstr : for : 	unsigned long *switch_count; : 
strstr : while : 	unsigned long *switch_count; : 
str : 	struct rq *rq;
strstr : INIT : 	struct rq *rq; : 
strstr : if : 	struct rq *rq; : 
strstr : for : 	struct rq *rq; : 
strstr : while : 	struct rq *rq; : 
str : 	int cpu;
strstr : INIT : 	int cpu; : 
strstr : if : 	int cpu; : 
strstr : for : 	int cpu; : 
strstr : while : 	int cpu; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : need_resched:
strstr : if : need_resched: : 
strstr : for : need_resched: : 
strstr : while : need_resched: : 
str : 	preempt_disable();
strstr : INIT : 	preempt_disable(); : 
strstr : if : 	preempt_disable(); : 
strstr : for : 	preempt_disable(); : 
strstr : while : 	preempt_disable(); : 
str : 	cpu = smp_processor_id();
strstr : INIT : 	cpu = smp_processor_id(); : 
strstr : if : 	cpu = smp_processor_id(); : 
strstr : for : 	cpu = smp_processor_id(); : 
strstr : while : 	cpu = smp_processor_id(); : 
str : 	rq = cpu_rq(cpu);
strstr : INIT : 	rq = cpu_rq(cpu); : 
strstr : if : 	rq = cpu_rq(cpu); : 
strstr : for : 	rq = cpu_rq(cpu); : 
strstr : while : 	rq = cpu_rq(cpu); : 
str : 	rcu_note_context_switch(cpu);
strstr : INIT : 	rcu_note_context_switch(cpu); : 
strstr : if : 	rcu_note_context_switch(cpu); : 
strstr : for : 	rcu_note_context_switch(cpu); : 
strstr : while : 	rcu_note_context_switch(cpu); : 
str : 	prev = rq->curr;
strstr : INIT : 	prev = rq->curr; : 
strstr : if : 	prev = rq->curr; : 
strstr : for : 	prev = rq->curr; : 
strstr : while : 	prev = rq->curr; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	schedule_debug(prev);
strstr : if : 	schedule_debug(prev); : 
strstr : for : 	schedule_debug(prev); : 
strstr : while : 	schedule_debug(prev); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	if (sched_feat(HRTICK))
strstr : if : 	if (sched_feat(HRTICK)) : 
strstr : for : 	if (sched_feat(HRTICK)) : 
strstr : while : 	if (sched_feat(HRTICK)) : 
str : 		hrtick_clear(rq);
strstr : INIT : 		hrtick_clear(rq); : 
strstr : if : 		hrtick_clear(rq); : 
strstr : for : 		hrtick_clear(rq); : 
strstr : while : 		hrtick_clear(rq); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	/*
strstr : if : 	/* : 
strstr : for : 	/* : 
strstr : while : 	/* : 
str : 	 * Make sure that signal_pending_state()->signal_pending() below
strstr : INIT : 	 * Make sure that signal_pending_state()->signal_pending() below : 
strstr : if : 	 * Make sure that signal_pending_state()->signal_pending() below : 
strstr : for : 	 * Make sure that signal_pending_state()->signal_pending() below : 
strstr : while : 	 * Make sure that signal_pending_state()->signal_pending() below : 
str : 	 * can't be reordered with __set_current_state(TASK_INTERRUPTIBLE)
strstr : INIT : 	 * can't be reordered with __set_current_state(TASK_INTERRUPTIBLE) : 
strstr : if : 	 * can't be reordered with __set_current_state(TASK_INTERRUPTIBLE) : 
strstr : for : 	 * can't be reordered with __set_current_state(TASK_INTERRUPTIBLE) : 
strstr : while : 	 * can't be reordered with __set_current_state(TASK_INTERRUPTIBLE) : 
str : 	 * done by the caller to avoid the race with signal_wake_up().
strstr : INIT : 	 * done by the caller to avoid the race with signal_wake_up(). : 
strstr : if : 	 * done by the caller to avoid the race with signal_wake_up(). : 
strstr : for : 	 * done by the caller to avoid the race with signal_wake_up(). : 
strstr : while : 	 * done by the caller to avoid the race with signal_wake_up(). : 
str : 	 */
strstr : INIT : 	 */ : 
strstr : if : 	 */ : 
strstr : for : 	 */ : 
strstr : while : 	 */ : 
str : 	smp_mb__before_spinlock();
strstr : INIT : 	smp_mb__before_spinlock(); : 
strstr : if : 	smp_mb__before_spinlock(); : 
strstr : for : 	smp_mb__before_spinlock(); : 
strstr : while : 	smp_mb__before_spinlock(); : 
str : 	raw_spin_lock_irq(&rq->lock);
strstr : INIT : 	raw_spin_lock_irq(&rq->lock); : 
strstr : if : 	raw_spin_lock_irq(&rq->lock); : 
strstr : for : 	raw_spin_lock_irq(&rq->lock); : 
strstr : while : 	raw_spin_lock_irq(&rq->lock); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	switch_count = &prev->nivcsw;
strstr : if : 	switch_count = &prev->nivcsw; : 
strstr : for : 	switch_count = &prev->nivcsw; : 
strstr : while : 	switch_count = &prev->nivcsw; : 
str : 	if (prev->state && !(preempt_count() & PREEMPT_ACTIVE)) {
strstr : INIT : 	if (prev->state && !(preempt_count() & PREEMPT_ACTIVE)) { : 
strstr : if : 	if (prev->state && !(preempt_count() & PREEMPT_ACTIVE)) { : 
strstr : for : 	if (prev->state && !(preempt_count() & PREEMPT_ACTIVE)) { : 
strstr : while : 	if (prev->state && !(preempt_count() & PREEMPT_ACTIVE)) { : 
str : 		if (unlikely(signal_pending_state(prev->state, prev))) {
strstr : INIT : 		if (unlikely(signal_pending_state(prev->state, prev))) { : 
strstr : if : 		if (unlikely(signal_pending_state(prev->state, prev))) { : 
strstr : for : 		if (unlikely(signal_pending_state(prev->state, prev))) { : 
strstr : while : 		if (unlikely(signal_pending_state(prev->state, prev))) { : 
str : 			prev->state = TASK_RUNNING;
strstr : INIT : 			prev->state = TASK_RUNNING; : 
strstr : if : 			prev->state = TASK_RUNNING; : 
strstr : for : 			prev->state = TASK_RUNNING; : 
strstr : while : 			prev->state = TASK_RUNNING; : 
str : 		} else {
strstr : INIT : 		} else { : 
strstr : if : 		} else { : 
strstr : for : 		} else { : 
strstr : while : 		} else { : 
str : 			deactivate_task(rq, prev, DEQUEUE_SLEEP);
strstr : INIT : 			deactivate_task(rq, prev, DEQUEUE_SLEEP); : 
strstr : if : 			deactivate_task(rq, prev, DEQUEUE_SLEEP); : 
strstr : for : 			deactivate_task(rq, prev, DEQUEUE_SLEEP); : 
strstr : while : 			deactivate_task(rq, prev, DEQUEUE_SLEEP); : 
str : 			prev->on_rq = 0;
strstr : INIT : 			prev->on_rq = 0; : 
strstr : if : 			prev->on_rq = 0; : 
strstr : for : 			prev->on_rq = 0; : 
strstr : while : 			prev->on_rq = 0; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 			/*
strstr : if : 			/* : 
strstr : for : 			/* : 
strstr : while : 			/* : 
str : 			 * If a worker went to sleep, notify and ask workqueue
strstr : INIT : 			 * If a worker went to sleep, notify and ask workqueue : 
strstr : if : 			 * If a worker went to sleep, notify and ask workqueue : 
strstr : for : 			 * If a worker went to sleep, notify and ask workqueue : 
strstr : while : 			 * If a worker went to sleep, notify and ask workqueue : 
str : 			 * whether it wants to wake up a task to maintain
strstr : INIT : 			 * whether it wants to wake up a task to maintain : 
strstr : if : 			 * whether it wants to wake up a task to maintain : 
strstr : for : 			 * whether it wants to wake up a task to maintain : 
strstr : while : 			 * whether it wants to wake up a task to maintain : 
str : 			 * concurrency.
strstr : INIT : 			 * concurrency. : 
strstr : if : 			 * concurrency. : 
strstr : for : 			 * concurrency. : 
strstr : while : 			 * concurrency. : 
str : 			 */
strstr : INIT : 			 */ : 
strstr : if : 			 */ : 
strstr : for : 			 */ : 
strstr : while : 			 */ : 
str : 			if (prev->flags & PF_WQ_WORKER) {
strstr : INIT : 			if (prev->flags & PF_WQ_WORKER) { : 
strstr : if : 			if (prev->flags & PF_WQ_WORKER) { : 
strstr : for : 			if (prev->flags & PF_WQ_WORKER) { : 
strstr : while : 			if (prev->flags & PF_WQ_WORKER) { : 
str : 				struct task_struct *to_wakeup;
strstr : INIT : 				struct task_struct *to_wakeup; : 
strstr : if : 				struct task_struct *to_wakeup; : 
strstr : for : 				struct task_struct *to_wakeup; : 
strstr : while : 				struct task_struct *to_wakeup; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 				to_wakeup = wq_worker_sleeping(prev, cpu);
strstr : if : 				to_wakeup = wq_worker_sleeping(prev, cpu); : 
strstr : for : 				to_wakeup = wq_worker_sleeping(prev, cpu); : 
strstr : while : 				to_wakeup = wq_worker_sleeping(prev, cpu); : 
str : 				if (to_wakeup)
strstr : INIT : 				if (to_wakeup) : 
strstr : if : 				if (to_wakeup) : 
strstr : for : 				if (to_wakeup) : 
strstr : while : 				if (to_wakeup) : 
str : 					try_to_wake_up_local(to_wakeup);
strstr : INIT : 					try_to_wake_up_local(to_wakeup); : 
strstr : if : 					try_to_wake_up_local(to_wakeup); : 
strstr : for : 					try_to_wake_up_local(to_wakeup); : 
strstr : while : 					try_to_wake_up_local(to_wakeup); : 
str : 			}
strstr : INIT : 			} : 
strstr : if : 			} : 
strstr : for : 			} : 
strstr : while : 			} : 
str : 		}
strstr : INIT : 		} : 
strstr : if : 		} : 
strstr : for : 		} : 
strstr : while : 		} : 
str : 		switch_count = &prev->nvcsw;
strstr : INIT : 		switch_count = &prev->nvcsw; : 
strstr : if : 		switch_count = &prev->nvcsw; : 
strstr : for : 		switch_count = &prev->nvcsw; : 
strstr : while : 		switch_count = &prev->nvcsw; : 
str : 	}
strstr : INIT : 	} : 
strstr : if : 	} : 
strstr : for : 	} : 
strstr : while : 	} : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	pre_schedule(rq, prev);
strstr : if : 	pre_schedule(rq, prev); : 
strstr : for : 	pre_schedule(rq, prev); : 
strstr : while : 	pre_schedule(rq, prev); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	if (unlikely(!rq->nr_running))
strstr : if : 	if (unlikely(!rq->nr_running)) : 
strstr : for : 	if (unlikely(!rq->nr_running)) : 
strstr : while : 	if (unlikely(!rq->nr_running)) : 
str : 		idle_balance(cpu, rq);
strstr : INIT : 		idle_balance(cpu, rq); : 
strstr : if : 		idle_balance(cpu, rq); : 
strstr : for : 		idle_balance(cpu, rq); : 
strstr : while : 		idle_balance(cpu, rq); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	put_prev_task(rq, prev);
strstr : if : 	put_prev_task(rq, prev); : 
strstr : for : 	put_prev_task(rq, prev); : 
strstr : while : 	put_prev_task(rq, prev); : 
str : 	next = pick_next_task(rq);
strstr : INIT : 	next = pick_next_task(rq); : 
strstr : if : 	next = pick_next_task(rq); : 
strstr : for : 	next = pick_next_task(rq); : 
strstr : while : 	next = pick_next_task(rq); : 
str : 	clear_tsk_need_resched(prev);
strstr : INIT : 	clear_tsk_need_resched(prev); : 
strstr : if : 	clear_tsk_need_resched(prev); : 
strstr : for : 	clear_tsk_need_resched(prev); : 
strstr : while : 	clear_tsk_need_resched(prev); : 
str : 	clear_preempt_need_resched();
strstr : INIT : 	clear_preempt_need_resched(); : 
strstr : if : 	clear_preempt_need_resched(); : 
strstr : for : 	clear_preempt_need_resched(); : 
strstr : while : 	clear_preempt_need_resched(); : 
str : 	rq->skip_clock_update = 0;
strstr : INIT : 	rq->skip_clock_update = 0; : 
strstr : if : 	rq->skip_clock_update = 0; : 
strstr : for : 	rq->skip_clock_update = 0; : 
strstr : while : 	rq->skip_clock_update = 0; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	if (likely(prev != next)) {
strstr : if : 	if (likely(prev != next)) { : 
strstr : for : 	if (likely(prev != next)) { : 
strstr : while : 	if (likely(prev != next)) { : 
str : 		rq->nr_switches++;
strstr : INIT : 		rq->nr_switches++; : 
strstr : if : 		rq->nr_switches++; : 
strstr : for : 		rq->nr_switches++; : 
strstr : while : 		rq->nr_switches++; : 
str : 		rq->curr = next;
strstr : INIT : 		rq->curr = next; : 
strstr : if : 		rq->curr = next; : 
strstr : for : 		rq->curr = next; : 
strstr : while : 		rq->curr = next; : 
str : 		++*switch_count;
strstr : INIT : 		++*switch_count; : 
strstr : if : 		++*switch_count; : 
strstr : for : 		++*switch_count; : 
strstr : while : 		++*switch_count; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 		context_switch(rq, prev, next); /* unlocks the rq */
strstr : if : 		context_switch(rq, prev, next); /* unlocks the rq */ : 
strstr : for : 		context_switch(rq, prev, next); /* unlocks the rq */ : 
strstr : while : 		context_switch(rq, prev, next); /* unlocks the rq */ : 
str : 		/*
strstr : INIT : 		/* : 
strstr : if : 		/* : 
strstr : for : 		/* : 
strstr : while : 		/* : 
str : 		 * The context switch have flipped the stack from under us
strstr : INIT : 		 * The context switch have flipped the stack from under us : 
strstr : if : 		 * The context switch have flipped the stack from under us : 
strstr : for : 		 * The context switch have flipped the stack from under us : 
strstr : while : 		 * The context switch have flipped the stack from under us : 
str : 		 * and restored the local variables which were saved when
strstr : INIT : 		 * and restored the local variables which were saved when : 
strstr : if : 		 * and restored the local variables which were saved when : 
strstr : for : 		 * and restored the local variables which were saved when : 
strstr : while : 		 * and restored the local variables which were saved when : 
str : 		 * this task called schedule() in the past. prev == current
strstr : INIT : 		 * this task called schedule() in the past. prev == current : 
strstr : if : 		 * this task called schedule() in the past. prev == current : 
strstr : for : 		 * this task called schedule() in the past. prev == current : 
strstr : while : 		 * this task called schedule() in the past. prev == current : 
str : 		 * is still correct, but it can be moved to another cpu/rq.
strstr : INIT : 		 * is still correct, but it can be moved to another cpu/rq. : 
strstr : if : 		 * is still correct, but it can be moved to another cpu/rq. : 
strstr : for : 		 * is still correct, but it can be moved to another cpu/rq. : 
strstr : while : 		 * is still correct, but it can be moved to another cpu/rq. : 
str : 		 */
strstr : INIT : 		 */ : 
strstr : if : 		 */ : 
strstr : for : 		 */ : 
strstr : while : 		 */ : 
str : 		cpu = smp_processor_id();
strstr : INIT : 		cpu = smp_processor_id(); : 
strstr : if : 		cpu = smp_processor_id(); : 
strstr : for : 		cpu = smp_processor_id(); : 
strstr : while : 		cpu = smp_processor_id(); : 
str : 		rq = cpu_rq(cpu);
strstr : INIT : 		rq = cpu_rq(cpu); : 
strstr : if : 		rq = cpu_rq(cpu); : 
strstr : for : 		rq = cpu_rq(cpu); : 
strstr : while : 		rq = cpu_rq(cpu); : 
str : 	} else
strstr : INIT : 	} else : 
strstr : if : 	} else : 
strstr : for : 	} else : 
strstr : while : 	} else : 
str : 		raw_spin_unlock_irq(&rq->lock);
strstr : INIT : 		raw_spin_unlock_irq(&rq->lock); : 
strstr : if : 		raw_spin_unlock_irq(&rq->lock); : 
strstr : for : 		raw_spin_unlock_irq(&rq->lock); : 
strstr : while : 		raw_spin_unlock_irq(&rq->lock); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	post_schedule(rq);
strstr : if : 	post_schedule(rq); : 
strstr : for : 	post_schedule(rq); : 
strstr : while : 	post_schedule(rq); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	sched_preempt_enable_no_resched();
strstr : if : 	sched_preempt_enable_no_resched(); : 
strstr : for : 	sched_preempt_enable_no_resched(); : 
strstr : while : 	sched_preempt_enable_no_resched(); : 
str : 	if (need_resched())
strstr : INIT : 	if (need_resched()) : 
strstr : if : 	if (need_resched()) : 
strstr : for : 	if (need_resched()) : 
strstr : while : 	if (need_resched()) : 
str : 		goto need_resched;
strstr : INIT : 		goto need_resched; : 
strstr : if : 		goto need_resched; : 
strstr : for : 		goto need_resched; : 
strstr : while : 		goto need_resched; : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : static inline void sched_submit_work(struct task_struct *tsk)
strstr : if : static inline void sched_submit_work(struct task_struct *tsk) : 
strstr : for : static inline void sched_submit_work(struct task_struct *tsk) : 
strstr : while : static inline void sched_submit_work(struct task_struct *tsk) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	if (!tsk->state || tsk_is_pi_blocked(tsk))
strstr : INIT : 	if (!tsk->state || tsk_is_pi_blocked(tsk)) : 
strstr : if : 	if (!tsk->state || tsk_is_pi_blocked(tsk)) : 
strstr : for : 	if (!tsk->state || tsk_is_pi_blocked(tsk)) : 
strstr : while : 	if (!tsk->state || tsk_is_pi_blocked(tsk)) : 
str : 		return;
strstr : INIT : 		return; : 
strstr : if : 		return; : 
strstr : for : 		return; : 
strstr : while : 		return; : 
str : 	/*
strstr : INIT : 	/* : 
strstr : if : 	/* : 
strstr : for : 	/* : 
strstr : while : 	/* : 
str : 	 * If we are going to sleep and we have plugged IO queued,
strstr : INIT : 	 * If we are going to sleep and we have plugged IO queued, : 
strstr : if : 	 * If we are going to sleep and we have plugged IO queued, : 
strstr : for : 	 * If we are going to sleep and we have plugged IO queued, : 
strstr : while : 	 * If we are going to sleep and we have plugged IO queued, : 
str : 	 * make sure to submit it to avoid deadlocks.
strstr : INIT : 	 * make sure to submit it to avoid deadlocks. : 
strstr : if : 	 * make sure to submit it to avoid deadlocks. : 
strstr : for : 	 * make sure to submit it to avoid deadlocks. : 
strstr : while : 	 * make sure to submit it to avoid deadlocks. : 
str : 	 */
strstr : INIT : 	 */ : 
strstr : if : 	 */ : 
strstr : for : 	 */ : 
strstr : while : 	 */ : 
str : 	if (blk_needs_flush_plug(tsk))
strstr : INIT : 	if (blk_needs_flush_plug(tsk)) : 
strstr : if : 	if (blk_needs_flush_plug(tsk)) : 
strstr : for : 	if (blk_needs_flush_plug(tsk)) : 
strstr : while : 	if (blk_needs_flush_plug(tsk)) : 
str : 		blk_schedule_flush_plug(tsk);
strstr : INIT : 		blk_schedule_flush_plug(tsk); : 
strstr : if : 		blk_schedule_flush_plug(tsk); : 
strstr : for : 		blk_schedule_flush_plug(tsk); : 
strstr : while : 		blk_schedule_flush_plug(tsk); : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : asmlinkage void __sched schedule(void)
strstr : if : asmlinkage void __sched schedule(void) : 
strstr : for : asmlinkage void __sched schedule(void) : 
strstr : while : asmlinkage void __sched schedule(void) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	struct task_struct *tsk = current;
strstr : INIT : 	struct task_struct *tsk = current; : 
strstr : if : 	struct task_struct *tsk = current; : 
strstr : for : 	struct task_struct *tsk = current; : 
strstr : while : 	struct task_struct *tsk = current; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	sched_submit_work(tsk);
strstr : if : 	sched_submit_work(tsk); : 
strstr : for : 	sched_submit_work(tsk); : 
strstr : while : 	sched_submit_work(tsk); : 
str : 	__schedule();
strstr : INIT : 	__schedule(); : 
strstr : if : 	__schedule(); : 
strstr : for : 	__schedule(); : 
strstr : while : 	__schedule(); : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : EXPORT_SYMBOL(schedule);
strstr : INIT : EXPORT_SYMBOL(schedule); : 
strstr : if : EXPORT_SYMBOL(schedule); : 
strstr : for : EXPORT_SYMBOL(schedule); : 
strstr : while : EXPORT_SYMBOL(schedule); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : #ifdef CONFIG_CONTEXT_TRACKING
strstr : if : #ifdef CONFIG_CONTEXT_TRACKING : 
strstr : for : #ifdef CONFIG_CONTEXT_TRACKING : 
strstr : while : #ifdef CONFIG_CONTEXT_TRACKING : 
str : asmlinkage void __sched schedule_user(void)
strstr : INIT : asmlinkage void __sched schedule_user(void) : 
strstr : if : asmlinkage void __sched schedule_user(void) : 
strstr : for : asmlinkage void __sched schedule_user(void) : 
strstr : while : asmlinkage void __sched schedule_user(void) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	/*
strstr : INIT : 	/* : 
strstr : if : 	/* : 
strstr : for : 	/* : 
strstr : while : 	/* : 
str : 	 * If we come here after a random call to set_need_resched(),
strstr : INIT : 	 * If we come here after a random call to set_need_resched(), : 
strstr : if : 	 * If we come here after a random call to set_need_resched(), : 
strstr : for : 	 * If we come here after a random call to set_need_resched(), : 
strstr : while : 	 * If we come here after a random call to set_need_resched(), : 
str : 	 * or we have been woken up remotely but the IPI has not yet arrived,
strstr : INIT : 	 * or we have been woken up remotely but the IPI has not yet arrived, : 
strstr : if : 	 * or we have been woken up remotely but the IPI has not yet arrived, : 
strstr : for : 	 * or we have been woken up remotely but the IPI has not yet arrived, : 
strstr : while : 	 * or we have been woken up remotely but the IPI has not yet arrived, : 
str : 	 * we haven't yet exited the RCU idle mode. Do it here manually until
strstr : INIT : 	 * we haven't yet exited the RCU idle mode. Do it here manually until : 
strstr : if : 	 * we haven't yet exited the RCU idle mode. Do it here manually until : 
strstr : for : 	 * we haven't yet exited the RCU idle mode. Do it here manually until : 
strstr : while : 	 * we haven't yet exited the RCU idle mode. Do it here manually until : 
str : 	 * we find a better solution.
strstr : INIT : 	 * we find a better solution. : 
strstr : if : 	 * we find a better solution. : 
strstr : for : 	 * we find a better solution. : 
strstr : while : 	 * we find a better solution. : 
str : 	 */
strstr : INIT : 	 */ : 
strstr : if : 	 */ : 
strstr : for : 	 */ : 
strstr : while : 	 */ : 
str : 	user_exit();
strstr : INIT : 	user_exit(); : 
strstr : if : 	user_exit(); : 
strstr : for : 	user_exit(); : 
strstr : while : 	user_exit(); : 
str : 	schedule();
strstr : INIT : 	schedule(); : 
strstr : if : 	schedule(); : 
strstr : for : 	schedule(); : 
strstr : while : 	schedule(); : 
str : 	user_enter();
strstr : INIT : 	user_enter(); : 
strstr : if : 	user_enter(); : 
strstr : for : 	user_enter(); : 
strstr : while : 	user_enter(); : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : #endif
strstr : INIT : #endif : 
strstr : if : #endif : 
strstr : for : #endif : 
strstr : while : #endif : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : /**
strstr : if : /** : 
strstr : for : /** : 
strstr : while : /** : 
str :  * schedule_preempt_disabled - called with preemption disabled
strstr : INIT :  * schedule_preempt_disabled - called with preemption disabled : 
strstr : if :  * schedule_preempt_disabled - called with preemption disabled : 
strstr : for :  * schedule_preempt_disabled - called with preemption disabled : 
strstr : while :  * schedule_preempt_disabled - called with preemption disabled : 
str :  *
strstr : INIT :  * : 
strstr : if :  * : 
strstr : for :  * : 
strstr : while :  * : 
str :  * Returns with preemption disabled. Note: preempt_count must be 1
strstr : INIT :  * Returns with preemption disabled. Note: preempt_count must be 1 : 
strstr : if :  * Returns with preemption disabled. Note: preempt_count must be 1 : 
strstr : for :  * Returns with preemption disabled. Note: preempt_count must be 1 : 
strstr : while :  * Returns with preemption disabled. Note: preempt_count must be 1 : 
str :  */
strstr : INIT :  */ : 
strstr : if :  */ : 
strstr : for :  */ : 
strstr : while :  */ : 
str : void __sched schedule_preempt_disabled(void)
strstr : INIT : void __sched schedule_preempt_disabled(void) : 
strstr : if : void __sched schedule_preempt_disabled(void) : 
strstr : for : void __sched schedule_preempt_disabled(void) : 
strstr : while : void __sched schedule_preempt_disabled(void) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	sched_preempt_enable_no_resched();
strstr : INIT : 	sched_preempt_enable_no_resched(); : 
strstr : if : 	sched_preempt_enable_no_resched(); : 
strstr : for : 	sched_preempt_enable_no_resched(); : 
strstr : while : 	sched_preempt_enable_no_resched(); : 
str : 	schedule();
strstr : INIT : 	schedule(); : 
strstr : if : 	schedule(); : 
strstr : for : 	schedule(); : 
strstr : while : 	schedule(); : 
str : 	preempt_disable();
strstr : INIT : 	preempt_disable(); : 
strstr : if : 	preempt_disable(); : 
strstr : for : 	preempt_disable(); : 
strstr : while : 	preempt_disable(); : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : #ifdef CONFIG_PREEMPT
strstr : if : #ifdef CONFIG_PREEMPT : 
strstr : for : #ifdef CONFIG_PREEMPT : 
strstr : while : #ifdef CONFIG_PREEMPT : 
str : /*
strstr : INIT : /* : 
strstr : if : /* : 
strstr : for : /* : 
strstr : while : /* : 
str :  * this is the entry point to schedule() from in-kernel preemption
strstr : INIT :  * this is the entry point to schedule() from in-kernel preemption : 
strstr : if :  * this is the entry point to schedule() from in-kernel preemption : 
strstr : for :  * this is the entry point to schedule() from in-kernel preemption : 
strstr : while :  * this is the entry point to schedule() from in-kernel preemption : 
str :  * off of preempt_enable. Kernel preemptions off return from interrupt
strstr : INIT :  * off of preempt_enable. Kernel preemptions off return from interrupt : 
strstr : if :  * off of preempt_enable. Kernel preemptions off return from interrupt : 
strstr : for :  * off of preempt_enable. Kernel preemptions off return from interrupt : 
strstr : while :  * off of preempt_enable. Kernel preemptions off return from interrupt : 
str :  * occur there and call schedule directly.
strstr : INIT :  * occur there and call schedule directly. : 
strstr : if :  * occur there and call schedule directly. : 
strstr : for :  * occur there and call schedule directly. : 
strstr : while :  * occur there and call schedule directly. : 
str :  */
strstr : INIT :  */ : 
strstr : if :  */ : 
strstr : for :  */ : 
strstr : while :  */ : 
str : asmlinkage void __sched notrace preempt_schedule(void)
strstr : INIT : asmlinkage void __sched notrace preempt_schedule(void) : 
strstr : if : asmlinkage void __sched notrace preempt_schedule(void) : 
strstr : for : asmlinkage void __sched notrace preempt_schedule(void) : 
strstr : while : asmlinkage void __sched notrace preempt_schedule(void) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	/*
strstr : INIT : 	/* : 
strstr : if : 	/* : 
strstr : for : 	/* : 
strstr : while : 	/* : 
str : 	 * If there is a non-zero preempt_count or interrupts are disabled,
strstr : INIT : 	 * If there is a non-zero preempt_count or interrupts are disabled, : 
strstr : if : 	 * If there is a non-zero preempt_count or interrupts are disabled, : 
strstr : for : 	 * If there is a non-zero preempt_count or interrupts are disabled, : 
strstr : while : 	 * If there is a non-zero preempt_count or interrupts are disabled, : 
str : 	 * we do not want to preempt the current task. Just return..
strstr : INIT : 	 * we do not want to preempt the current task. Just return.. : 
strstr : if : 	 * we do not want to preempt the current task. Just return.. : 
strstr : for : 	 * we do not want to preempt the current task. Just return.. : 
strstr : while : 	 * we do not want to preempt the current task. Just return.. : 
str : 	 */
strstr : INIT : 	 */ : 
strstr : if : 	 */ : 
strstr : for : 	 */ : 
strstr : while : 	 */ : 
str : 	if (likely(!preemptible()))
strstr : INIT : 	if (likely(!preemptible())) : 
strstr : if : 	if (likely(!preemptible())) : 
strstr : for : 	if (likely(!preemptible())) : 
strstr : while : 	if (likely(!preemptible())) : 
str : 		return;
strstr : INIT : 		return; : 
strstr : if : 		return; : 
strstr : for : 		return; : 
strstr : while : 		return; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	do {
strstr : if : 	do { : 
strstr : for : 	do { : 
strstr : while : 	do { : 
str : 		__preempt_count_add(PREEMPT_ACTIVE);
strstr : INIT : 		__preempt_count_add(PREEMPT_ACTIVE); : 
strstr : if : 		__preempt_count_add(PREEMPT_ACTIVE); : 
strstr : for : 		__preempt_count_add(PREEMPT_ACTIVE); : 
strstr : while : 		__preempt_count_add(PREEMPT_ACTIVE); : 
str : 		__schedule();
strstr : INIT : 		__schedule(); : 
strstr : if : 		__schedule(); : 
strstr : for : 		__schedule(); : 
strstr : while : 		__schedule(); : 
str : 		__preempt_count_sub(PREEMPT_ACTIVE);
strstr : INIT : 		__preempt_count_sub(PREEMPT_ACTIVE); : 
strstr : if : 		__preempt_count_sub(PREEMPT_ACTIVE); : 
strstr : for : 		__preempt_count_sub(PREEMPT_ACTIVE); : 
strstr : while : 		__preempt_count_sub(PREEMPT_ACTIVE); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 		/*
strstr : if : 		/* : 
strstr : for : 		/* : 
strstr : while : 		/* : 
str : 		 * Check again in case we missed a preemption opportunity
strstr : INIT : 		 * Check again in case we missed a preemption opportunity : 
strstr : if : 		 * Check again in case we missed a preemption opportunity : 
strstr : for : 		 * Check again in case we missed a preemption opportunity : 
strstr : while : 		 * Check again in case we missed a preemption opportunity : 
str : 		 * between schedule and now.
strstr : INIT : 		 * between schedule and now. : 
strstr : if : 		 * between schedule and now. : 
strstr : for : 		 * between schedule and now. : 
strstr : while : 		 * between schedule and now. : 
str : 		 */
strstr : INIT : 		 */ : 
strstr : if : 		 */ : 
strstr : for : 		 */ : 
strstr : while : 		 */ : 
str : 		barrier();
strstr : INIT : 		barrier(); : 
strstr : if : 		barrier(); : 
strstr : for : 		barrier(); : 
strstr : while : 		barrier(); : 
str : 	} while (need_resched());
strstr : INIT : 	} while (need_resched()); : 
strstr : if : 	} while (need_resched()); : 
strstr : for : 	} while (need_resched()); : 
strstr : while : 	} while (need_resched()); : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : EXPORT_SYMBOL(preempt_schedule);
strstr : INIT : EXPORT_SYMBOL(preempt_schedule); : 
strstr : if : EXPORT_SYMBOL(preempt_schedule); : 
strstr : for : EXPORT_SYMBOL(preempt_schedule); : 
strstr : while : EXPORT_SYMBOL(preempt_schedule); : 
str : #endif /* CONFIG_PREEMPT */
strstr : INIT : #endif /* CONFIG_PREEMPT */ : 
strstr : if : #endif /* CONFIG_PREEMPT */ : 
strstr : for : #endif /* CONFIG_PREEMPT */ : 
strstr : while : #endif /* CONFIG_PREEMPT */ : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : /*
strstr : if : /* : 
strstr : for : /* : 
strstr : while : /* : 
str :  * this is the entry point to schedule() from kernel preemption
strstr : INIT :  * this is the entry point to schedule() from kernel preemption : 
strstr : if :  * this is the entry point to schedule() from kernel preemption : 
strstr : for :  * this is the entry point to schedule() from kernel preemption : 
strstr : while :  * this is the entry point to schedule() from kernel preemption : 
str :  * off of irq context.
strstr : INIT :  * off of irq context. : 
strstr : if :  * off of irq context. : 
strstr : for :  * off of irq context. : 
strstr : while :  * off of irq context. : 
str :  * Note, that this is called and return with irqs disabled. This will
strstr : INIT :  * Note, that this is called and return with irqs disabled. This will : 
strstr : if :  * Note, that this is called and return with irqs disabled. This will : 
strstr : for :  * Note, that this is called and return with irqs disabled. This will : 
strstr : while :  * Note, that this is called and return with irqs disabled. This will : 
str :  * protect us against recursive calling from irq.
strstr : INIT :  * protect us against recursive calling from irq. : 
strstr : if :  * protect us against recursive calling from irq. : 
strstr : for :  * protect us against recursive calling from irq. : 
strstr : while :  * protect us against recursive calling from irq. : 
str :  */
strstr : INIT :  */ : 
strstr : if :  */ : 
strstr : for :  */ : 
strstr : while :  */ : 
str : asmlinkage void __sched preempt_schedule_irq(void)
strstr : INIT : asmlinkage void __sched preempt_schedule_irq(void) : 
strstr : if : asmlinkage void __sched preempt_schedule_irq(void) : 
strstr : for : asmlinkage void __sched preempt_schedule_irq(void) : 
strstr : while : asmlinkage void __sched preempt_schedule_irq(void) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	enum ctx_state prev_state;
strstr : INIT : 	enum ctx_state prev_state; : 
strstr : if : 	enum ctx_state prev_state; : 
strstr : for : 	enum ctx_state prev_state; : 
strstr : while : 	enum ctx_state prev_state; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	/* Catch callers which need to be fixed */
strstr : if : 	/* Catch callers which need to be fixed */ : 
strstr : for : 	/* Catch callers which need to be fixed */ : 
strstr : while : 	/* Catch callers which need to be fixed */ : 
str : 	BUG_ON(preempt_count() || !irqs_disabled());
strstr : INIT : 	BUG_ON(preempt_count() || !irqs_disabled()); : 
strstr : if : 	BUG_ON(preempt_count() || !irqs_disabled()); : 
strstr : for : 	BUG_ON(preempt_count() || !irqs_disabled()); : 
strstr : while : 	BUG_ON(preempt_count() || !irqs_disabled()); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	prev_state = exception_enter();
strstr : if : 	prev_state = exception_enter(); : 
strstr : for : 	prev_state = exception_enter(); : 
strstr : while : 	prev_state = exception_enter(); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	do {
strstr : if : 	do { : 
strstr : for : 	do { : 
strstr : while : 	do { : 
str : 		__preempt_count_add(PREEMPT_ACTIVE);
strstr : INIT : 		__preempt_count_add(PREEMPT_ACTIVE); : 
strstr : if : 		__preempt_count_add(PREEMPT_ACTIVE); : 
strstr : for : 		__preempt_count_add(PREEMPT_ACTIVE); : 
strstr : while : 		__preempt_count_add(PREEMPT_ACTIVE); : 
str : 		local_irq_enable();
strstr : INIT : 		local_irq_enable(); : 
strstr : if : 		local_irq_enable(); : 
strstr : for : 		local_irq_enable(); : 
strstr : while : 		local_irq_enable(); : 
str : 		__schedule();
strstr : INIT : 		__schedule(); : 
strstr : if : 		__schedule(); : 
strstr : for : 		__schedule(); : 
strstr : while : 		__schedule(); : 
str : 		local_irq_disable();
strstr : INIT : 		local_irq_disable(); : 
strstr : if : 		local_irq_disable(); : 
strstr : for : 		local_irq_disable(); : 
strstr : while : 		local_irq_disable(); : 
str : 		__preempt_count_sub(PREEMPT_ACTIVE);
strstr : INIT : 		__preempt_count_sub(PREEMPT_ACTIVE); : 
strstr : if : 		__preempt_count_sub(PREEMPT_ACTIVE); : 
strstr : for : 		__preempt_count_sub(PREEMPT_ACTIVE); : 
strstr : while : 		__preempt_count_sub(PREEMPT_ACTIVE); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 		/*
strstr : if : 		/* : 
strstr : for : 		/* : 
strstr : while : 		/* : 
str : 		 * Check again in case we missed a preemption opportunity
strstr : INIT : 		 * Check again in case we missed a preemption opportunity : 
strstr : if : 		 * Check again in case we missed a preemption opportunity : 
strstr : for : 		 * Check again in case we missed a preemption opportunity : 
strstr : while : 		 * Check again in case we missed a preemption opportunity : 
str : 		 * between schedule and now.
strstr : INIT : 		 * between schedule and now. : 
strstr : if : 		 * between schedule and now. : 
strstr : for : 		 * between schedule and now. : 
strstr : while : 		 * between schedule and now. : 
str : 		 */
strstr : INIT : 		 */ : 
strstr : if : 		 */ : 
strstr : for : 		 */ : 
strstr : while : 		 */ : 
str : 		barrier();
strstr : INIT : 		barrier(); : 
strstr : if : 		barrier(); : 
strstr : for : 		barrier(); : 
strstr : while : 		barrier(); : 
str : 	} while (need_resched());
strstr : INIT : 	} while (need_resched()); : 
strstr : if : 	} while (need_resched()); : 
strstr : for : 	} while (need_resched()); : 
strstr : while : 	} while (need_resched()); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	exception_exit(prev_state);
strstr : if : 	exception_exit(prev_state); : 
strstr : for : 	exception_exit(prev_state); : 
strstr : while : 	exception_exit(prev_state); : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : int default_wake_function(wait_queue_t *curr, unsigned mode, int wake_flags,
strstr : if : int default_wake_function(wait_queue_t *curr, unsigned mode, int wake_flags, : 
strstr : for : int default_wake_function(wait_queue_t *curr, unsigned mode, int wake_flags, : 
strstr : while : int default_wake_function(wait_queue_t *curr, unsigned mode, int wake_flags, : 
str : 			  void *key)
strstr : INIT : 			  void *key) : 
strstr : if : 			  void *key) : 
strstr : for : 			  void *key) : 
strstr : while : 			  void *key) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	return try_to_wake_up(curr->private, mode, wake_flags);
strstr : INIT : 	return try_to_wake_up(curr->private, mode, wake_flags); : 
strstr : if : 	return try_to_wake_up(curr->private, mode, wake_flags); : 
strstr : for : 	return try_to_wake_up(curr->private, mode, wake_flags); : 
strstr : while : 	return try_to_wake_up(curr->private, mode, wake_flags); : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : EXPORT_SYMBOL(default_wake_function);
strstr : INIT : EXPORT_SYMBOL(default_wake_function); : 
strstr : if : EXPORT_SYMBOL(default_wake_function); : 
strstr : for : EXPORT_SYMBOL(default_wake_function); : 
strstr : while : EXPORT_SYMBOL(default_wake_function); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : static long __sched
strstr : if : static long __sched : 
strstr : for : static long __sched : 
strstr : while : static long __sched : 
str : sleep_on_common(wait_queue_head_t *q, int state, long timeout)
strstr : INIT : sleep_on_common(wait_queue_head_t *q, int state, long timeout) : 
strstr : if : sleep_on_common(wait_queue_head_t *q, int state, long timeout) : 
strstr : for : sleep_on_common(wait_queue_head_t *q, int state, long timeout) : 
strstr : while : sleep_on_common(wait_queue_head_t *q, int state, long timeout) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	unsigned long flags;
strstr : INIT : 	unsigned long flags; : 
strstr : if : 	unsigned long flags; : 
strstr : for : 	unsigned long flags; : 
strstr : while : 	unsigned long flags; : 
str : 	wait_queue_t wait;
strstr : INIT : 	wait_queue_t wait; : 
strstr : if : 	wait_queue_t wait; : 
strstr : for : 	wait_queue_t wait; : 
strstr : while : 	wait_queue_t wait; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	init_waitqueue_entry(&wait, current);
strstr : if : 	init_waitqueue_entry(&wait, current); : 
strstr : for : 	init_waitqueue_entry(&wait, current); : 
strstr : while : 	init_waitqueue_entry(&wait, current); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	__set_current_state(state);
strstr : if : 	__set_current_state(state); : 
strstr : for : 	__set_current_state(state); : 
strstr : while : 	__set_current_state(state); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	spin_lock_irqsave(&q->lock, flags);
strstr : if : 	spin_lock_irqsave(&q->lock, flags); : 
strstr : for : 	spin_lock_irqsave(&q->lock, flags); : 
strstr : while : 	spin_lock_irqsave(&q->lock, flags); : 
str : 	__add_wait_queue(q, &wait);
strstr : INIT : 	__add_wait_queue(q, &wait); : 
strstr : if : 	__add_wait_queue(q, &wait); : 
strstr : for : 	__add_wait_queue(q, &wait); : 
strstr : while : 	__add_wait_queue(q, &wait); : 
str : 	spin_unlock(&q->lock);
strstr : INIT : 	spin_unlock(&q->lock); : 
strstr : if : 	spin_unlock(&q->lock); : 
strstr : for : 	spin_unlock(&q->lock); : 
strstr : while : 	spin_unlock(&q->lock); : 
str : 	timeout = schedule_timeout(timeout);
strstr : INIT : 	timeout = schedule_timeout(timeout); : 
strstr : if : 	timeout = schedule_timeout(timeout); : 
strstr : for : 	timeout = schedule_timeout(timeout); : 
strstr : while : 	timeout = schedule_timeout(timeout); : 
str : 	spin_lock_irq(&q->lock);
strstr : INIT : 	spin_lock_irq(&q->lock); : 
strstr : if : 	spin_lock_irq(&q->lock); : 
strstr : for : 	spin_lock_irq(&q->lock); : 
strstr : while : 	spin_lock_irq(&q->lock); : 
str : 	__remove_wait_queue(q, &wait);
strstr : INIT : 	__remove_wait_queue(q, &wait); : 
strstr : if : 	__remove_wait_queue(q, &wait); : 
strstr : for : 	__remove_wait_queue(q, &wait); : 
strstr : while : 	__remove_wait_queue(q, &wait); : 
str : 	spin_unlock_irqrestore(&q->lock, flags);
strstr : INIT : 	spin_unlock_irqrestore(&q->lock, flags); : 
strstr : if : 	spin_unlock_irqrestore(&q->lock, flags); : 
strstr : for : 	spin_unlock_irqrestore(&q->lock, flags); : 
strstr : while : 	spin_unlock_irqrestore(&q->lock, flags); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	return timeout;
strstr : if : 	return timeout; : 
strstr : for : 	return timeout; : 
strstr : while : 	return timeout; : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : void __sched interruptible_sleep_on(wait_queue_head_t *q)
strstr : if : void __sched interruptible_sleep_on(wait_queue_head_t *q) : 
strstr : for : void __sched interruptible_sleep_on(wait_queue_head_t *q) : 
strstr : while : void __sched interruptible_sleep_on(wait_queue_head_t *q) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	sleep_on_common(q, TASK_INTERRUPTIBLE, MAX_SCHEDULE_TIMEOUT);
strstr : INIT : 	sleep_on_common(q, TASK_INTERRUPTIBLE, MAX_SCHEDULE_TIMEOUT); : 
strstr : if : 	sleep_on_common(q, TASK_INTERRUPTIBLE, MAX_SCHEDULE_TIMEOUT); : 
strstr : for : 	sleep_on_common(q, TASK_INTERRUPTIBLE, MAX_SCHEDULE_TIMEOUT); : 
strstr : while : 	sleep_on_common(q, TASK_INTERRUPTIBLE, MAX_SCHEDULE_TIMEOUT); : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : EXPORT_SYMBOL(interruptible_sleep_on);
strstr : INIT : EXPORT_SYMBOL(interruptible_sleep_on); : 
strstr : if : EXPORT_SYMBOL(interruptible_sleep_on); : 
strstr : for : EXPORT_SYMBOL(interruptible_sleep_on); : 
strstr : while : EXPORT_SYMBOL(interruptible_sleep_on); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : long __sched
strstr : if : long __sched : 
strstr : for : long __sched : 
strstr : while : long __sched : 
str : interruptible_sleep_on_timeout(wait_queue_head_t *q, long timeout)
strstr : INIT : interruptible_sleep_on_timeout(wait_queue_head_t *q, long timeout) : 
strstr : if : interruptible_sleep_on_timeout(wait_queue_head_t *q, long timeout) : 
strstr : for : interruptible_sleep_on_timeout(wait_queue_head_t *q, long timeout) : 
strstr : while : interruptible_sleep_on_timeout(wait_queue_head_t *q, long timeout) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	return sleep_on_common(q, TASK_INTERRUPTIBLE, timeout);
strstr : INIT : 	return sleep_on_common(q, TASK_INTERRUPTIBLE, timeout); : 
strstr : if : 	return sleep_on_common(q, TASK_INTERRUPTIBLE, timeout); : 
strstr : for : 	return sleep_on_common(q, TASK_INTERRUPTIBLE, timeout); : 
strstr : while : 	return sleep_on_common(q, TASK_INTERRUPTIBLE, timeout); : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : EXPORT_SYMBOL(interruptible_sleep_on_timeout);
strstr : INIT : EXPORT_SYMBOL(interruptible_sleep_on_timeout); : 
strstr : if : EXPORT_SYMBOL(interruptible_sleep_on_timeout); : 
strstr : for : EXPORT_SYMBOL(interruptible_sleep_on_timeout); : 
strstr : while : EXPORT_SYMBOL(interruptible_sleep_on_timeout); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : void __sched sleep_on(wait_queue_head_t *q)
strstr : if : void __sched sleep_on(wait_queue_head_t *q) : 
strstr : for : void __sched sleep_on(wait_queue_head_t *q) : 
strstr : while : void __sched sleep_on(wait_queue_head_t *q) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	sleep_on_common(q, TASK_UNINTERRUPTIBLE, MAX_SCHEDULE_TIMEOUT);
strstr : INIT : 	sleep_on_common(q, TASK_UNINTERRUPTIBLE, MAX_SCHEDULE_TIMEOUT); : 
strstr : if : 	sleep_on_common(q, TASK_UNINTERRUPTIBLE, MAX_SCHEDULE_TIMEOUT); : 
strstr : for : 	sleep_on_common(q, TASK_UNINTERRUPTIBLE, MAX_SCHEDULE_TIMEOUT); : 
strstr : while : 	sleep_on_common(q, TASK_UNINTERRUPTIBLE, MAX_SCHEDULE_TIMEOUT); : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : EXPORT_SYMBOL(sleep_on);
strstr : INIT : EXPORT_SYMBOL(sleep_on); : 
strstr : if : EXPORT_SYMBOL(sleep_on); : 
strstr : for : EXPORT_SYMBOL(sleep_on); : 
strstr : while : EXPORT_SYMBOL(sleep_on); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : long __sched sleep_on_timeout(wait_queue_head_t *q, long timeout)
strstr : if : long __sched sleep_on_timeout(wait_queue_head_t *q, long timeout) : 
strstr : for : long __sched sleep_on_timeout(wait_queue_head_t *q, long timeout) : 
strstr : while : long __sched sleep_on_timeout(wait_queue_head_t *q, long timeout) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	return sleep_on_common(q, TASK_UNINTERRUPTIBLE, timeout);
strstr : INIT : 	return sleep_on_common(q, TASK_UNINTERRUPTIBLE, timeout); : 
strstr : if : 	return sleep_on_common(q, TASK_UNINTERRUPTIBLE, timeout); : 
strstr : for : 	return sleep_on_common(q, TASK_UNINTERRUPTIBLE, timeout); : 
strstr : while : 	return sleep_on_common(q, TASK_UNINTERRUPTIBLE, timeout); : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : EXPORT_SYMBOL(sleep_on_timeout);
strstr : INIT : EXPORT_SYMBOL(sleep_on_timeout); : 
strstr : if : EXPORT_SYMBOL(sleep_on_timeout); : 
strstr : for : EXPORT_SYMBOL(sleep_on_timeout); : 
strstr : while : EXPORT_SYMBOL(sleep_on_timeout); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : #ifdef CONFIG_RT_MUTEXES
strstr : if : #ifdef CONFIG_RT_MUTEXES : 
strstr : for : #ifdef CONFIG_RT_MUTEXES : 
strstr : while : #ifdef CONFIG_RT_MUTEXES : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : /*
strstr : if : /* : 
strstr : for : /* : 
strstr : while : /* : 
str :  * rt_mutex_setprio - set the current priority of a task
strstr : INIT :  * rt_mutex_setprio - set the current priority of a task : 
strstr : if :  * rt_mutex_setprio - set the current priority of a task : 
strstr : for :  * rt_mutex_setprio - set the current priority of a task : 
strstr : while :  * rt_mutex_setprio - set the current priority of a task : 
str :  * @p: task
strstr : INIT :  * @p: task : 
strstr : if :  * @p: task : 
strstr : for :  * @p: task : 
strstr : while :  * @p: task : 
str :  * @prio: prio value (kernel-internal form)
strstr : INIT :  * @prio: prio value (kernel-internal form) : 
strstr : if :  * @prio: prio value (kernel-internal form) : 
strstr : for :  * @prio: prio value (kernel-internal form) : 
strstr : while :  * @prio: prio value (kernel-internal form) : 
str :  *
strstr : INIT :  * : 
strstr : if :  * : 
strstr : for :  * : 
strstr : while :  * : 
str :  * This function changes the 'effective' priority of a task. It does
strstr : INIT :  * This function changes the 'effective' priority of a task. It does : 
strstr : if :  * This function changes the 'effective' priority of a task. It does : 
strstr : for :  * This function changes the 'effective' priority of a task. It does : 
strstr : while :  * This function changes the 'effective' priority of a task. It does : 
str :  * not touch ->normal_prio like __setscheduler().
strstr : INIT :  * not touch ->normal_prio like __setscheduler(). : 
strstr : if :  * not touch ->normal_prio like __setscheduler(). : 
strstr : for :  * not touch ->normal_prio like __setscheduler(). : 
strstr : while :  * not touch ->normal_prio like __setscheduler(). : 
str :  *
strstr : INIT :  * : 
strstr : if :  * : 
strstr : for :  * : 
strstr : while :  * : 
str :  * Used by the rt_mutex code to implement priority inheritance logic.
strstr : INIT :  * Used by the rt_mutex code to implement priority inheritance logic. : 
strstr : if :  * Used by the rt_mutex code to implement priority inheritance logic. : 
strstr : for :  * Used by the rt_mutex code to implement priority inheritance logic. : 
strstr : while :  * Used by the rt_mutex code to implement priority inheritance logic. : 
str :  */
strstr : INIT :  */ : 
strstr : if :  */ : 
strstr : for :  */ : 
strstr : while :  */ : 
str : void rt_mutex_setprio(struct task_struct *p, int prio)
strstr : INIT : void rt_mutex_setprio(struct task_struct *p, int prio) : 
strstr : if : void rt_mutex_setprio(struct task_struct *p, int prio) : 
strstr : for : void rt_mutex_setprio(struct task_struct *p, int prio) : 
strstr : while : void rt_mutex_setprio(struct task_struct *p, int prio) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	int oldprio, on_rq, running, enqueue_flag = 0;
strstr : INIT : 	int oldprio, on_rq, running, enqueue_flag = 0; : 
strstr : if : 	int oldprio, on_rq, running, enqueue_flag = 0; : 
strstr : for : 	int oldprio, on_rq, running, enqueue_flag = 0; : 
strstr : while : 	int oldprio, on_rq, running, enqueue_flag = 0; : 
str : 	struct rq *rq;
strstr : INIT : 	struct rq *rq; : 
strstr : if : 	struct rq *rq; : 
strstr : for : 	struct rq *rq; : 
strstr : while : 	struct rq *rq; : 
str : 	const struct sched_class *prev_class;
strstr : INIT : 	const struct sched_class *prev_class; : 
strstr : if : 	const struct sched_class *prev_class; : 
strstr : for : 	const struct sched_class *prev_class; : 
strstr : while : 	const struct sched_class *prev_class; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	BUG_ON(prio > MAX_PRIO);
strstr : if : 	BUG_ON(prio > MAX_PRIO); : 
strstr : for : 	BUG_ON(prio > MAX_PRIO); : 
strstr : while : 	BUG_ON(prio > MAX_PRIO); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	rq = __task_rq_lock(p);
strstr : if : 	rq = __task_rq_lock(p); : 
strstr : for : 	rq = __task_rq_lock(p); : 
strstr : while : 	rq = __task_rq_lock(p); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	/*
strstr : if : 	/* : 
strstr : for : 	/* : 
strstr : while : 	/* : 
str : 	 * Idle task boosting is a nono in general. There is one
strstr : INIT : 	 * Idle task boosting is a nono in general. There is one : 
strstr : if : 	 * Idle task boosting is a nono in general. There is one : 
strstr : for : 	 * Idle task boosting is a nono in general. There is one : 
strstr : while : 	 * Idle task boosting is a nono in general. There is one : 
str : 	 * exception, when PREEMPT_RT and NOHZ is active:
strstr : INIT : 	 * exception, when PREEMPT_RT and NOHZ is active: : 
strstr : if : 	 * exception, when PREEMPT_RT and NOHZ is active: : 
strstr : for : 	 * exception, when PREEMPT_RT and NOHZ is active: : 
strstr : while : 	 * exception, when PREEMPT_RT and NOHZ is active: : 
str : 	 *
strstr : INIT : 	 * : 
strstr : if : 	 * : 
strstr : for : 	 * : 
strstr : while : 	 * : 
str : 	 * The idle task calls get_next_timer_interrupt() and holds
strstr : INIT : 	 * The idle task calls get_next_timer_interrupt() and holds : 
strstr : if : 	 * The idle task calls get_next_timer_interrupt() and holds : 
strstr : for : 	 * The idle task calls get_next_timer_interrupt() and holds : 
strstr : while : 	 * The idle task calls get_next_timer_interrupt() and holds : 
str : 	 * the timer wheel base->lock on the CPU and another CPU wants
strstr : INIT : 	 * the timer wheel base->lock on the CPU and another CPU wants : 
strstr : if : 	 * the timer wheel base->lock on the CPU and another CPU wants : 
strstr : for : 	 * the timer wheel base->lock on the CPU and another CPU wants : 
strstr : while : 	 * the timer wheel base->lock on the CPU and another CPU wants : 
str : 	 * to access the timer (probably to cancel it). We can safely
strstr : INIT : 	 * to access the timer (probably to cancel it). We can safely : 
strstr : if : 	 * to access the timer (probably to cancel it). We can safely : 
strstr : for : 	 * to access the timer (probably to cancel it). We can safely : 
strstr : while : 	 * to access the timer (probably to cancel it). We can safely : 
str : 	 * ignore the boosting request, as the idle CPU runs this code
strstr : INIT : 	 * ignore the boosting request, as the idle CPU runs this code : 
strstr : if : 	 * ignore the boosting request, as the idle CPU runs this code : 
strstr : for : 	 * ignore the boosting request, as the idle CPU runs this code : 
strstr : while : 	 * ignore the boosting request, as the idle CPU runs this code : 
str : 	 * with interrupts disabled and will complete the lock
strstr : INIT : 	 * with interrupts disabled and will complete the lock : 
strstr : if : 	 * with interrupts disabled and will complete the lock : 
strstr : for : 	 * with interrupts disabled and will complete the lock : 
strstr : while : 	 * with interrupts disabled and will complete the lock : 
str : 	 * protected section without being interrupted. So there is no
strstr : INIT : 	 * protected section without being interrupted. So there is no : 
strstr : if : 	 * protected section without being interrupted. So there is no : 
strstr : for : 	 * protected section without being interrupted. So there is no : 
strstr : while : 	 * protected section without being interrupted. So there is no : 
str : 	 * real need to boost.
strstr : INIT : 	 * real need to boost. : 
strstr : if : 	 * real need to boost. : 
strstr : for : 	 * real need to boost. : 
strstr : while : 	 * real need to boost. : 
str : 	 */
strstr : INIT : 	 */ : 
strstr : if : 	 */ : 
strstr : for : 	 */ : 
strstr : while : 	 */ : 
str : 	if (unlikely(p == rq->idle)) {
strstr : INIT : 	if (unlikely(p == rq->idle)) { : 
strstr : if : 	if (unlikely(p == rq->idle)) { : 
strstr : for : 	if (unlikely(p == rq->idle)) { : 
strstr : while : 	if (unlikely(p == rq->idle)) { : 
str : 		WARN_ON(p != rq->curr);
strstr : INIT : 		WARN_ON(p != rq->curr); : 
strstr : if : 		WARN_ON(p != rq->curr); : 
strstr : for : 		WARN_ON(p != rq->curr); : 
strstr : while : 		WARN_ON(p != rq->curr); : 
str : 		WARN_ON(p->pi_blocked_on);
strstr : INIT : 		WARN_ON(p->pi_blocked_on); : 
strstr : if : 		WARN_ON(p->pi_blocked_on); : 
strstr : for : 		WARN_ON(p->pi_blocked_on); : 
strstr : while : 		WARN_ON(p->pi_blocked_on); : 
str : 		goto out_unlock;
strstr : INIT : 		goto out_unlock; : 
strstr : if : 		goto out_unlock; : 
strstr : for : 		goto out_unlock; : 
strstr : while : 		goto out_unlock; : 
str : 	}
strstr : INIT : 	} : 
strstr : if : 	} : 
strstr : for : 	} : 
strstr : while : 	} : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	trace_sched_pi_setprio(p, prio);
strstr : if : 	trace_sched_pi_setprio(p, prio); : 
strstr : for : 	trace_sched_pi_setprio(p, prio); : 
strstr : while : 	trace_sched_pi_setprio(p, prio); : 
str : 	p->pi_top_task = rt_mutex_get_top_task(p);
strstr : INIT : 	p->pi_top_task = rt_mutex_get_top_task(p); : 
strstr : if : 	p->pi_top_task = rt_mutex_get_top_task(p); : 
strstr : for : 	p->pi_top_task = rt_mutex_get_top_task(p); : 
strstr : while : 	p->pi_top_task = rt_mutex_get_top_task(p); : 
str : 	oldprio = p->prio;
strstr : INIT : 	oldprio = p->prio; : 
strstr : if : 	oldprio = p->prio; : 
strstr : for : 	oldprio = p->prio; : 
strstr : while : 	oldprio = p->prio; : 
str : 	prev_class = p->sched_class;
strstr : INIT : 	prev_class = p->sched_class; : 
strstr : if : 	prev_class = p->sched_class; : 
strstr : for : 	prev_class = p->sched_class; : 
strstr : while : 	prev_class = p->sched_class; : 
str : 	on_rq = p->on_rq;
strstr : INIT : 	on_rq = p->on_rq; : 
strstr : if : 	on_rq = p->on_rq; : 
strstr : for : 	on_rq = p->on_rq; : 
strstr : while : 	on_rq = p->on_rq; : 
str : 	running = task_current(rq, p);
strstr : INIT : 	running = task_current(rq, p); : 
strstr : if : 	running = task_current(rq, p); : 
strstr : for : 	running = task_current(rq, p); : 
strstr : while : 	running = task_current(rq, p); : 
str : 	if (on_rq)
strstr : INIT : 	if (on_rq) : 
strstr : if : 	if (on_rq) : 
strstr : for : 	if (on_rq) : 
strstr : while : 	if (on_rq) : 
str : 		dequeue_task(rq, p, 0);
strstr : INIT : 		dequeue_task(rq, p, 0); : 
strstr : if : 		dequeue_task(rq, p, 0); : 
strstr : for : 		dequeue_task(rq, p, 0); : 
strstr : while : 		dequeue_task(rq, p, 0); : 
str : 	if (running)
strstr : INIT : 	if (running) : 
strstr : if : 	if (running) : 
strstr : for : 	if (running) : 
strstr : while : 	if (running) : 
str : 		p->sched_class->put_prev_task(rq, p);
strstr : INIT : 		p->sched_class->put_prev_task(rq, p); : 
strstr : if : 		p->sched_class->put_prev_task(rq, p); : 
strstr : for : 		p->sched_class->put_prev_task(rq, p); : 
strstr : while : 		p->sched_class->put_prev_task(rq, p); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	/*
strstr : if : 	/* : 
strstr : for : 	/* : 
strstr : while : 	/* : 
str : 	 * Boosting condition are:
strstr : INIT : 	 * Boosting condition are: : 
strstr : if : 	 * Boosting condition are: : 
strstr : for : 	 * Boosting condition are: : 
strstr : while : 	 * Boosting condition are: : 
str : 	 * 1. -rt task is running and holds mutex A
strstr : INIT : 	 * 1. -rt task is running and holds mutex A : 
strstr : if : 	 * 1. -rt task is running and holds mutex A : 
strstr : for : 	 * 1. -rt task is running and holds mutex A : 
strstr : while : 	 * 1. -rt task is running and holds mutex A : 
str : 	 *      --> -dl task blocks on mutex A
strstr : INIT : 	 *      --> -dl task blocks on mutex A : 
strstr : if : 	 *      --> -dl task blocks on mutex A : 
strstr : for : 	 *      --> -dl task blocks on mutex A : 
strstr : while : 	 *      --> -dl task blocks on mutex A : 
str : 	 *
strstr : INIT : 	 * : 
strstr : if : 	 * : 
strstr : for : 	 * : 
strstr : while : 	 * : 
str : 	 * 2. -dl task is running and holds mutex A
strstr : INIT : 	 * 2. -dl task is running and holds mutex A : 
strstr : if : 	 * 2. -dl task is running and holds mutex A : 
strstr : for : 	 * 2. -dl task is running and holds mutex A : 
strstr : while : 	 * 2. -dl task is running and holds mutex A : 
str : 	 *      --> -dl task blocks on mutex A and could preempt the
strstr : INIT : 	 *      --> -dl task blocks on mutex A and could preempt the : 
strstr : if : 	 *      --> -dl task blocks on mutex A and could preempt the : 
strstr : for : 	 *      --> -dl task blocks on mutex A and could preempt the : 
strstr : while : 	 *      --> -dl task blocks on mutex A and could preempt the : 
str : 	 *          running task
strstr : INIT : 	 *          running task : 
strstr : if : 	 *          running task : 
strstr : for : 	 *          running task : 
strstr : while : 	 *          running task : 
str : 	 */
strstr : INIT : 	 */ : 
strstr : if : 	 */ : 
strstr : for : 	 */ : 
strstr : while : 	 */ : 
str : 	if (dl_prio(prio)) {
strstr : INIT : 	if (dl_prio(prio)) { : 
strstr : if : 	if (dl_prio(prio)) { : 
strstr : for : 	if (dl_prio(prio)) { : 
strstr : while : 	if (dl_prio(prio)) { : 
str : 		if (!dl_prio(p->normal_prio) || (p->pi_top_task &&
strstr : INIT : 		if (!dl_prio(p->normal_prio) || (p->pi_top_task && : 
strstr : if : 		if (!dl_prio(p->normal_prio) || (p->pi_top_task && : 
strstr : for : 		if (!dl_prio(p->normal_prio) || (p->pi_top_task && : 
strstr : while : 		if (!dl_prio(p->normal_prio) || (p->pi_top_task && : 
str : 			dl_entity_preempt(&p->pi_top_task->dl, &p->dl))) {
strstr : INIT : 			dl_entity_preempt(&p->pi_top_task->dl, &p->dl))) { : 
strstr : if : 			dl_entity_preempt(&p->pi_top_task->dl, &p->dl))) { : 
strstr : for : 			dl_entity_preempt(&p->pi_top_task->dl, &p->dl))) { : 
strstr : while : 			dl_entity_preempt(&p->pi_top_task->dl, &p->dl))) { : 
str : 			p->dl.dl_boosted = 1;
strstr : INIT : 			p->dl.dl_boosted = 1; : 
strstr : if : 			p->dl.dl_boosted = 1; : 
strstr : for : 			p->dl.dl_boosted = 1; : 
strstr : while : 			p->dl.dl_boosted = 1; : 
str : 			p->dl.dl_throttled = 0;
strstr : INIT : 			p->dl.dl_throttled = 0; : 
strstr : if : 			p->dl.dl_throttled = 0; : 
strstr : for : 			p->dl.dl_throttled = 0; : 
strstr : while : 			p->dl.dl_throttled = 0; : 
str : 			enqueue_flag = ENQUEUE_REPLENISH;
strstr : INIT : 			enqueue_flag = ENQUEUE_REPLENISH; : 
strstr : if : 			enqueue_flag = ENQUEUE_REPLENISH; : 
strstr : for : 			enqueue_flag = ENQUEUE_REPLENISH; : 
strstr : while : 			enqueue_flag = ENQUEUE_REPLENISH; : 
str : 		} else
strstr : INIT : 		} else : 
strstr : if : 		} else : 
strstr : for : 		} else : 
strstr : while : 		} else : 
str : 			p->dl.dl_boosted = 0;
strstr : INIT : 			p->dl.dl_boosted = 0; : 
strstr : if : 			p->dl.dl_boosted = 0; : 
strstr : for : 			p->dl.dl_boosted = 0; : 
strstr : while : 			p->dl.dl_boosted = 0; : 
str : 		p->sched_class = &dl_sched_class;
strstr : INIT : 		p->sched_class = &dl_sched_class; : 
strstr : if : 		p->sched_class = &dl_sched_class; : 
strstr : for : 		p->sched_class = &dl_sched_class; : 
strstr : while : 		p->sched_class = &dl_sched_class; : 
str : 	} else if (rt_prio(prio)) {
strstr : INIT : 	} else if (rt_prio(prio)) { : 
strstr : if : 	} else if (rt_prio(prio)) { : 
strstr : for : 	} else if (rt_prio(prio)) { : 
strstr : while : 	} else if (rt_prio(prio)) { : 
str : 		if (dl_prio(oldprio))
strstr : INIT : 		if (dl_prio(oldprio)) : 
strstr : if : 		if (dl_prio(oldprio)) : 
strstr : for : 		if (dl_prio(oldprio)) : 
strstr : while : 		if (dl_prio(oldprio)) : 
str : 			p->dl.dl_boosted = 0;
strstr : INIT : 			p->dl.dl_boosted = 0; : 
strstr : if : 			p->dl.dl_boosted = 0; : 
strstr : for : 			p->dl.dl_boosted = 0; : 
strstr : while : 			p->dl.dl_boosted = 0; : 
str : 		if (oldprio < prio)
strstr : INIT : 		if (oldprio < prio) : 
strstr : if : 		if (oldprio < prio) : 
strstr : for : 		if (oldprio < prio) : 
strstr : while : 		if (oldprio < prio) : 
str : 			enqueue_flag = ENQUEUE_HEAD;
strstr : INIT : 			enqueue_flag = ENQUEUE_HEAD; : 
strstr : if : 			enqueue_flag = ENQUEUE_HEAD; : 
strstr : for : 			enqueue_flag = ENQUEUE_HEAD; : 
strstr : while : 			enqueue_flag = ENQUEUE_HEAD; : 
str : 		p->sched_class = &rt_sched_class;
strstr : INIT : 		p->sched_class = &rt_sched_class; : 
strstr : if : 		p->sched_class = &rt_sched_class; : 
strstr : for : 		p->sched_class = &rt_sched_class; : 
strstr : while : 		p->sched_class = &rt_sched_class; : 
str : 	} else {
strstr : INIT : 	} else { : 
strstr : if : 	} else { : 
strstr : for : 	} else { : 
strstr : while : 	} else { : 
str : 		if (dl_prio(oldprio))
strstr : INIT : 		if (dl_prio(oldprio)) : 
strstr : if : 		if (dl_prio(oldprio)) : 
strstr : for : 		if (dl_prio(oldprio)) : 
strstr : while : 		if (dl_prio(oldprio)) : 
str : 			p->dl.dl_boosted = 0;
strstr : INIT : 			p->dl.dl_boosted = 0; : 
strstr : if : 			p->dl.dl_boosted = 0; : 
strstr : for : 			p->dl.dl_boosted = 0; : 
strstr : while : 			p->dl.dl_boosted = 0; : 
str : 		p->sched_class = &fair_sched_class;
strstr : INIT : 		p->sched_class = &fair_sched_class; : 
strstr : if : 		p->sched_class = &fair_sched_class; : 
strstr : for : 		p->sched_class = &fair_sched_class; : 
strstr : while : 		p->sched_class = &fair_sched_class; : 
str : 	}
strstr : INIT : 	} : 
strstr : if : 	} : 
strstr : for : 	} : 
strstr : while : 	} : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	p->prio = prio;
strstr : if : 	p->prio = prio; : 
strstr : for : 	p->prio = prio; : 
strstr : while : 	p->prio = prio; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	if (running)
strstr : if : 	if (running) : 
strstr : for : 	if (running) : 
strstr : while : 	if (running) : 
str : 		p->sched_class->set_curr_task(rq);
strstr : INIT : 		p->sched_class->set_curr_task(rq); : 
strstr : if : 		p->sched_class->set_curr_task(rq); : 
strstr : for : 		p->sched_class->set_curr_task(rq); : 
strstr : while : 		p->sched_class->set_curr_task(rq); : 
str : 	if (on_rq)
strstr : INIT : 	if (on_rq) : 
strstr : if : 	if (on_rq) : 
strstr : for : 	if (on_rq) : 
strstr : while : 	if (on_rq) : 
str : 		enqueue_task(rq, p, enqueue_flag);
strstr : INIT : 		enqueue_task(rq, p, enqueue_flag); : 
strstr : if : 		enqueue_task(rq, p, enqueue_flag); : 
strstr : for : 		enqueue_task(rq, p, enqueue_flag); : 
strstr : while : 		enqueue_task(rq, p, enqueue_flag); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	check_class_changed(rq, p, prev_class, oldprio);
strstr : if : 	check_class_changed(rq, p, prev_class, oldprio); : 
strstr : for : 	check_class_changed(rq, p, prev_class, oldprio); : 
strstr : while : 	check_class_changed(rq, p, prev_class, oldprio); : 
str : out_unlock:
strstr : INIT : out_unlock: : 
strstr : if : out_unlock: : 
strstr : for : out_unlock: : 
strstr : while : out_unlock: : 
str : 	__task_rq_unlock(rq);
strstr : INIT : 	__task_rq_unlock(rq); : 
strstr : if : 	__task_rq_unlock(rq); : 
strstr : for : 	__task_rq_unlock(rq); : 
strstr : while : 	__task_rq_unlock(rq); : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : #endif
strstr : INIT : #endif : 
strstr : if : #endif : 
strstr : for : #endif : 
strstr : while : #endif : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : void set_user_nice(struct task_struct *p, long nice)
strstr : if : void set_user_nice(struct task_struct *p, long nice) : 
strstr : for : void set_user_nice(struct task_struct *p, long nice) : 
strstr : while : void set_user_nice(struct task_struct *p, long nice) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	int old_prio, delta, on_rq;
strstr : INIT : 	int old_prio, delta, on_rq; : 
strstr : if : 	int old_prio, delta, on_rq; : 
strstr : for : 	int old_prio, delta, on_rq; : 
strstr : while : 	int old_prio, delta, on_rq; : 
str : 	unsigned long flags;
strstr : INIT : 	unsigned long flags; : 
strstr : if : 	unsigned long flags; : 
strstr : for : 	unsigned long flags; : 
strstr : while : 	unsigned long flags; : 
str : 	struct rq *rq;
strstr : INIT : 	struct rq *rq; : 
strstr : if : 	struct rq *rq; : 
strstr : for : 	struct rq *rq; : 
strstr : while : 	struct rq *rq; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	if (TASK_NICE(p) == nice || nice < -20 || nice > 19)
strstr : if : 	if (TASK_NICE(p) == nice || nice < -20 || nice > 19) : 
strstr : for : 	if (TASK_NICE(p) == nice || nice < -20 || nice > 19) : 
strstr : while : 	if (TASK_NICE(p) == nice || nice < -20 || nice > 19) : 
str : 		return;
strstr : INIT : 		return; : 
strstr : if : 		return; : 
strstr : for : 		return; : 
strstr : while : 		return; : 
str : 	/*
strstr : INIT : 	/* : 
strstr : if : 	/* : 
strstr : for : 	/* : 
strstr : while : 	/* : 
str : 	 * We have to be careful, if called from sys_setpriority(),
strstr : INIT : 	 * We have to be careful, if called from sys_setpriority(), : 
strstr : if : 	 * We have to be careful, if called from sys_setpriority(), : 
strstr : for : 	 * We have to be careful, if called from sys_setpriority(), : 
strstr : while : 	 * We have to be careful, if called from sys_setpriority(), : 
str : 	 * the task might be in the middle of scheduling on another CPU.
strstr : INIT : 	 * the task might be in the middle of scheduling on another CPU. : 
strstr : if : 	 * the task might be in the middle of scheduling on another CPU. : 
strstr : for : 	 * the task might be in the middle of scheduling on another CPU. : 
strstr : while : 	 * the task might be in the middle of scheduling on another CPU. : 
str : 	 */
strstr : INIT : 	 */ : 
strstr : if : 	 */ : 
strstr : for : 	 */ : 
strstr : while : 	 */ : 
str : 	rq = task_rq_lock(p, &flags);
strstr : INIT : 	rq = task_rq_lock(p, &flags); : 
strstr : if : 	rq = task_rq_lock(p, &flags); : 
strstr : for : 	rq = task_rq_lock(p, &flags); : 
strstr : while : 	rq = task_rq_lock(p, &flags); : 
str : 	/*
strstr : INIT : 	/* : 
strstr : if : 	/* : 
strstr : for : 	/* : 
strstr : while : 	/* : 
str : 	 * The RT priorities are set via sched_setscheduler(), but we still
strstr : INIT : 	 * The RT priorities are set via sched_setscheduler(), but we still : 
strstr : if : 	 * The RT priorities are set via sched_setscheduler(), but we still : 
strstr : for : 	 * The RT priorities are set via sched_setscheduler(), but we still : 
strstr : while : 	 * The RT priorities are set via sched_setscheduler(), but we still : 
str : 	 * allow the 'normal' nice value to be set - but as expected
strstr : INIT : 	 * allow the 'normal' nice value to be set - but as expected : 
strstr : if : 	 * allow the 'normal' nice value to be set - but as expected : 
strstr : for : 	 * allow the 'normal' nice value to be set - but as expected : 
strstr : while : 	 * allow the 'normal' nice value to be set - but as expected : 
str : 	 * it wont have any effect on scheduling until the task is
strstr : INIT : 	 * it wont have any effect on scheduling until the task is : 
strstr : if : 	 * it wont have any effect on scheduling until the task is : 
strstr : for : 	 * it wont have any effect on scheduling until the task is : 
strstr : while : 	 * it wont have any effect on scheduling until the task is : 
str : 	 * SCHED_DEADLINE, SCHED_FIFO or SCHED_RR:
strstr : INIT : 	 * SCHED_DEADLINE, SCHED_FIFO or SCHED_RR: : 
strstr : if : 	 * SCHED_DEADLINE, SCHED_FIFO or SCHED_RR: : 
strstr : for : 	 * SCHED_DEADLINE, SCHED_FIFO or SCHED_RR: : 
strstr : while : 	 * SCHED_DEADLINE, SCHED_FIFO or SCHED_RR: : 
str : 	 */
strstr : INIT : 	 */ : 
strstr : if : 	 */ : 
strstr : for : 	 */ : 
strstr : while : 	 */ : 
str : 	if (task_has_dl_policy(p) || task_has_rt_policy(p)) {
strstr : INIT : 	if (task_has_dl_policy(p) || task_has_rt_policy(p)) { : 
strstr : if : 	if (task_has_dl_policy(p) || task_has_rt_policy(p)) { : 
strstr : for : 	if (task_has_dl_policy(p) || task_has_rt_policy(p)) { : 
strstr : while : 	if (task_has_dl_policy(p) || task_has_rt_policy(p)) { : 
str : 		p->static_prio = NICE_TO_PRIO(nice);
strstr : INIT : 		p->static_prio = NICE_TO_PRIO(nice); : 
strstr : if : 		p->static_prio = NICE_TO_PRIO(nice); : 
strstr : for : 		p->static_prio = NICE_TO_PRIO(nice); : 
strstr : while : 		p->static_prio = NICE_TO_PRIO(nice); : 
str : 		goto out_unlock;
strstr : INIT : 		goto out_unlock; : 
strstr : if : 		goto out_unlock; : 
strstr : for : 		goto out_unlock; : 
strstr : while : 		goto out_unlock; : 
str : 	}
strstr : INIT : 	} : 
strstr : if : 	} : 
strstr : for : 	} : 
strstr : while : 	} : 
str : 	on_rq = p->on_rq;
strstr : INIT : 	on_rq = p->on_rq; : 
strstr : if : 	on_rq = p->on_rq; : 
strstr : for : 	on_rq = p->on_rq; : 
strstr : while : 	on_rq = p->on_rq; : 
str : 	if (on_rq)
strstr : INIT : 	if (on_rq) : 
strstr : if : 	if (on_rq) : 
strstr : for : 	if (on_rq) : 
strstr : while : 	if (on_rq) : 
str : 		dequeue_task(rq, p, 0);
strstr : INIT : 		dequeue_task(rq, p, 0); : 
strstr : if : 		dequeue_task(rq, p, 0); : 
strstr : for : 		dequeue_task(rq, p, 0); : 
strstr : while : 		dequeue_task(rq, p, 0); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	p->static_prio = NICE_TO_PRIO(nice);
strstr : if : 	p->static_prio = NICE_TO_PRIO(nice); : 
strstr : for : 	p->static_prio = NICE_TO_PRIO(nice); : 
strstr : while : 	p->static_prio = NICE_TO_PRIO(nice); : 
str : 	set_load_weight(p);
strstr : INIT : 	set_load_weight(p); : 
strstr : if : 	set_load_weight(p); : 
strstr : for : 	set_load_weight(p); : 
strstr : while : 	set_load_weight(p); : 
str : 	old_prio = p->prio;
strstr : INIT : 	old_prio = p->prio; : 
strstr : if : 	old_prio = p->prio; : 
strstr : for : 	old_prio = p->prio; : 
strstr : while : 	old_prio = p->prio; : 
str : 	p->prio = effective_prio(p);
strstr : INIT : 	p->prio = effective_prio(p); : 
strstr : if : 	p->prio = effective_prio(p); : 
strstr : for : 	p->prio = effective_prio(p); : 
strstr : while : 	p->prio = effective_prio(p); : 
str : 	delta = p->prio - old_prio;
strstr : INIT : 	delta = p->prio - old_prio; : 
strstr : if : 	delta = p->prio - old_prio; : 
strstr : for : 	delta = p->prio - old_prio; : 
strstr : while : 	delta = p->prio - old_prio; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	if (on_rq) {
strstr : if : 	if (on_rq) { : 
strstr : for : 	if (on_rq) { : 
strstr : while : 	if (on_rq) { : 
str : 		enqueue_task(rq, p, 0);
strstr : INIT : 		enqueue_task(rq, p, 0); : 
strstr : if : 		enqueue_task(rq, p, 0); : 
strstr : for : 		enqueue_task(rq, p, 0); : 
strstr : while : 		enqueue_task(rq, p, 0); : 
str : 		/*
strstr : INIT : 		/* : 
strstr : if : 		/* : 
strstr : for : 		/* : 
strstr : while : 		/* : 
str : 		 * If the task increased its priority or is running and
strstr : INIT : 		 * If the task increased its priority or is running and : 
strstr : if : 		 * If the task increased its priority or is running and : 
strstr : for : 		 * If the task increased its priority or is running and : 
strstr : while : 		 * If the task increased its priority or is running and : 
str : 		 * lowered its priority, then reschedule its CPU:
strstr : INIT : 		 * lowered its priority, then reschedule its CPU: : 
strstr : if : 		 * lowered its priority, then reschedule its CPU: : 
strstr : for : 		 * lowered its priority, then reschedule its CPU: : 
strstr : while : 		 * lowered its priority, then reschedule its CPU: : 
str : 		 */
strstr : INIT : 		 */ : 
strstr : if : 		 */ : 
strstr : for : 		 */ : 
strstr : while : 		 */ : 
str : 		if (delta < 0 || (delta > 0 && task_running(rq, p)))
strstr : INIT : 		if (delta < 0 || (delta > 0 && task_running(rq, p))) : 
strstr : if : 		if (delta < 0 || (delta > 0 && task_running(rq, p))) : 
strstr : for : 		if (delta < 0 || (delta > 0 && task_running(rq, p))) : 
strstr : while : 		if (delta < 0 || (delta > 0 && task_running(rq, p))) : 
str : 			resched_task(rq->curr);
strstr : INIT : 			resched_task(rq->curr); : 
strstr : if : 			resched_task(rq->curr); : 
strstr : for : 			resched_task(rq->curr); : 
strstr : while : 			resched_task(rq->curr); : 
str : 	}
strstr : INIT : 	} : 
strstr : if : 	} : 
strstr : for : 	} : 
strstr : while : 	} : 
str : out_unlock:
strstr : INIT : out_unlock: : 
strstr : if : out_unlock: : 
strstr : for : out_unlock: : 
strstr : while : out_unlock: : 
str : 	task_rq_unlock(rq, p, &flags);
strstr : INIT : 	task_rq_unlock(rq, p, &flags); : 
strstr : if : 	task_rq_unlock(rq, p, &flags); : 
strstr : for : 	task_rq_unlock(rq, p, &flags); : 
strstr : while : 	task_rq_unlock(rq, p, &flags); : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : EXPORT_SYMBOL(set_user_nice);
strstr : INIT : EXPORT_SYMBOL(set_user_nice); : 
strstr : if : EXPORT_SYMBOL(set_user_nice); : 
strstr : for : EXPORT_SYMBOL(set_user_nice); : 
strstr : while : EXPORT_SYMBOL(set_user_nice); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : /*
strstr : if : /* : 
strstr : for : /* : 
strstr : while : /* : 
str :  * can_nice - check if a task can reduce its nice value
strstr : INIT :  * can_nice - check if a task can reduce its nice value : 
strstr : if :  * can_nice - check if a task can reduce its nice value : 
strstr : for :  * can_nice - check if a task can reduce its nice value : 
strstr : while :  * can_nice - check if a task can reduce its nice value : 
str :  * @p: task
strstr : INIT :  * @p: task : 
strstr : if :  * @p: task : 
strstr : for :  * @p: task : 
strstr : while :  * @p: task : 
str :  * @nice: nice value
strstr : INIT :  * @nice: nice value : 
strstr : if :  * @nice: nice value : 
strstr : for :  * @nice: nice value : 
strstr : while :  * @nice: nice value : 
str :  */
strstr : INIT :  */ : 
strstr : if :  */ : 
strstr : for :  */ : 
strstr : while :  */ : 
str : int can_nice(const struct task_struct *p, const int nice)
strstr : INIT : int can_nice(const struct task_struct *p, const int nice) : 
strstr : if : int can_nice(const struct task_struct *p, const int nice) : 
strstr : for : int can_nice(const struct task_struct *p, const int nice) : 
strstr : while : int can_nice(const struct task_struct *p, const int nice) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	/* convert nice value [19,-20] to rlimit style value [1,40] */
strstr : INIT : 	/* convert nice value [19,-20] to rlimit style value [1,40] */ : 
strstr : if : 	/* convert nice value [19,-20] to rlimit style value [1,40] */ : 
strstr : for : 	/* convert nice value [19,-20] to rlimit style value [1,40] */ : 
strstr : while : 	/* convert nice value [19,-20] to rlimit style value [1,40] */ : 
str : 	int nice_rlim = 20 - nice;
strstr : INIT : 	int nice_rlim = 20 - nice; : 
strstr : if : 	int nice_rlim = 20 - nice; : 
strstr : for : 	int nice_rlim = 20 - nice; : 
strstr : while : 	int nice_rlim = 20 - nice; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	return (nice_rlim <= task_rlimit(p, RLIMIT_NICE) ||
strstr : if : 	return (nice_rlim <= task_rlimit(p, RLIMIT_NICE) || : 
strstr : for : 	return (nice_rlim <= task_rlimit(p, RLIMIT_NICE) || : 
strstr : while : 	return (nice_rlim <= task_rlimit(p, RLIMIT_NICE) || : 
str : 		capable(CAP_SYS_NICE));
strstr : INIT : 		capable(CAP_SYS_NICE)); : 
strstr : if : 		capable(CAP_SYS_NICE)); : 
strstr : for : 		capable(CAP_SYS_NICE)); : 
strstr : while : 		capable(CAP_SYS_NICE)); : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : #ifdef __ARCH_WANT_SYS_NICE
strstr : if : #ifdef __ARCH_WANT_SYS_NICE : 
strstr : for : #ifdef __ARCH_WANT_SYS_NICE : 
strstr : while : #ifdef __ARCH_WANT_SYS_NICE : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : /*
strstr : if : /* : 
strstr : for : /* : 
strstr : while : /* : 
str :  * sys_nice - change the priority of the current process.
strstr : INIT :  * sys_nice - change the priority of the current process. : 
strstr : if :  * sys_nice - change the priority of the current process. : 
strstr : for :  * sys_nice - change the priority of the current process. : 
strstr : while :  * sys_nice - change the priority of the current process. : 
str :  * @increment: priority increment
strstr : INIT :  * @increment: priority increment : 
strstr : if :  * @increment: priority increment : 
strstr : for :  * @increment: priority increment : 
strstr : while :  * @increment: priority increment : 
str :  *
strstr : INIT :  * : 
strstr : if :  * : 
strstr : for :  * : 
strstr : while :  * : 
str :  * sys_setpriority is a more generic, but much slower function that
strstr : INIT :  * sys_setpriority is a more generic, but much slower function that : 
strstr : if :  * sys_setpriority is a more generic, but much slower function that : 
strstr : for :  * sys_setpriority is a more generic, but much slower function that : 
strstr : while :  * sys_setpriority is a more generic, but much slower function that : 
str :  * does similar things.
strstr : INIT :  * does similar things. : 
strstr : if :  * does similar things. : 
strstr : for :  * does similar things. : 
strstr : while :  * does similar things. : 
str :  */
strstr : INIT :  */ : 
strstr : if :  */ : 
strstr : for :  */ : 
strstr : while :  */ : 
str : SYSCALL_DEFINE1(nice, int, increment)
strstr : INIT : SYSCALL_DEFINE1(nice, int, increment) : 
strstr : if : SYSCALL_DEFINE1(nice, int, increment) : 
strstr : for : SYSCALL_DEFINE1(nice, int, increment) : 
strstr : while : SYSCALL_DEFINE1(nice, int, increment) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	long nice, retval;
strstr : INIT : 	long nice, retval; : 
strstr : if : 	long nice, retval; : 
strstr : for : 	long nice, retval; : 
strstr : while : 	long nice, retval; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	/*
strstr : if : 	/* : 
strstr : for : 	/* : 
strstr : while : 	/* : 
str : 	 * Setpriority might change our priority at the same moment.
strstr : INIT : 	 * Setpriority might change our priority at the same moment. : 
strstr : if : 	 * Setpriority might change our priority at the same moment. : 
strstr : for : 	 * Setpriority might change our priority at the same moment. : 
strstr : while : 	 * Setpriority might change our priority at the same moment. : 
str : 	 * We don't have to worry. Conceptually one call occurs first
strstr : INIT : 	 * We don't have to worry. Conceptually one call occurs first : 
strstr : if : 	 * We don't have to worry. Conceptually one call occurs first : 
strstr : for : 	 * We don't have to worry. Conceptually one call occurs first : 
strstr : while : 	 * We don't have to worry. Conceptually one call occurs first : 
str : 	 * and we have a single winner.
strstr : INIT : 	 * and we have a single winner. : 
strstr : if : 	 * and we have a single winner. : 
strstr : for : 	 * and we have a single winner. : 
strstr : while : 	 * and we have a single winner. : 
str : 	 */
strstr : INIT : 	 */ : 
strstr : if : 	 */ : 
strstr : for : 	 */ : 
strstr : while : 	 */ : 
str : 	if (increment < -40)
strstr : INIT : 	if (increment < -40) : 
strstr : if : 	if (increment < -40) : 
strstr : for : 	if (increment < -40) : 
strstr : while : 	if (increment < -40) : 
str : 		increment = -40;
strstr : INIT : 		increment = -40; : 
strstr : if : 		increment = -40; : 
strstr : for : 		increment = -40; : 
strstr : while : 		increment = -40; : 
str : 	if (increment > 40)
strstr : INIT : 	if (increment > 40) : 
strstr : if : 	if (increment > 40) : 
strstr : for : 	if (increment > 40) : 
strstr : while : 	if (increment > 40) : 
str : 		increment = 40;
strstr : INIT : 		increment = 40; : 
strstr : if : 		increment = 40; : 
strstr : for : 		increment = 40; : 
strstr : while : 		increment = 40; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	nice = TASK_NICE(current) + increment;
strstr : if : 	nice = TASK_NICE(current) + increment; : 
strstr : for : 	nice = TASK_NICE(current) + increment; : 
strstr : while : 	nice = TASK_NICE(current) + increment; : 
str : 	if (nice < -20)
strstr : INIT : 	if (nice < -20) : 
strstr : if : 	if (nice < -20) : 
strstr : for : 	if (nice < -20) : 
strstr : while : 	if (nice < -20) : 
str : 		nice = -20;
strstr : INIT : 		nice = -20; : 
strstr : if : 		nice = -20; : 
strstr : for : 		nice = -20; : 
strstr : while : 		nice = -20; : 
str : 	if (nice > 19)
strstr : INIT : 	if (nice > 19) : 
strstr : if : 	if (nice > 19) : 
strstr : for : 	if (nice > 19) : 
strstr : while : 	if (nice > 19) : 
str : 		nice = 19;
strstr : INIT : 		nice = 19; : 
strstr : if : 		nice = 19; : 
strstr : for : 		nice = 19; : 
strstr : while : 		nice = 19; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	if (increment < 0 && !can_nice(current, nice))
strstr : if : 	if (increment < 0 && !can_nice(current, nice)) : 
strstr : for : 	if (increment < 0 && !can_nice(current, nice)) : 
strstr : while : 	if (increment < 0 && !can_nice(current, nice)) : 
str : 		return -EPERM;
strstr : INIT : 		return -EPERM; : 
strstr : if : 		return -EPERM; : 
strstr : for : 		return -EPERM; : 
strstr : while : 		return -EPERM; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	retval = security_task_setnice(current, nice);
strstr : if : 	retval = security_task_setnice(current, nice); : 
strstr : for : 	retval = security_task_setnice(current, nice); : 
strstr : while : 	retval = security_task_setnice(current, nice); : 
str : 	if (retval)
strstr : INIT : 	if (retval) : 
strstr : if : 	if (retval) : 
strstr : for : 	if (retval) : 
strstr : while : 	if (retval) : 
str : 		return retval;
strstr : INIT : 		return retval; : 
strstr : if : 		return retval; : 
strstr : for : 		return retval; : 
strstr : while : 		return retval; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	set_user_nice(current, nice);
strstr : if : 	set_user_nice(current, nice); : 
strstr : for : 	set_user_nice(current, nice); : 
strstr : while : 	set_user_nice(current, nice); : 
str : 	return 0;
strstr : INIT : 	return 0; : 
strstr : if : 	return 0; : 
strstr : for : 	return 0; : 
strstr : while : 	return 0; : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : #endif
strstr : if : #endif : 
strstr : for : #endif : 
strstr : while : #endif : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : /**
strstr : if : /** : 
strstr : for : /** : 
strstr : while : /** : 
str :  * task_prio - return the priority value of a given task.
strstr : INIT :  * task_prio - return the priority value of a given task. : 
strstr : if :  * task_prio - return the priority value of a given task. : 
strstr : for :  * task_prio - return the priority value of a given task. : 
strstr : while :  * task_prio - return the priority value of a given task. : 
str :  * @p: the task in question.
strstr : INIT :  * @p: the task in question. : 
strstr : if :  * @p: the task in question. : 
strstr : for :  * @p: the task in question. : 
strstr : while :  * @p: the task in question. : 
str :  *
strstr : INIT :  * : 
strstr : if :  * : 
strstr : for :  * : 
strstr : while :  * : 
str :  * Return: The priority value as seen by users in /proc.
strstr : INIT :  * Return: The priority value as seen by users in /proc. : 
strstr : if :  * Return: The priority value as seen by users in /proc. : 
strstr : for :  * Return: The priority value as seen by users in /proc. : 
strstr : while :  * Return: The priority value as seen by users in /proc. : 
str :  * RT tasks are offset by -200. Normal tasks are centered
strstr : INIT :  * RT tasks are offset by -200. Normal tasks are centered : 
strstr : if :  * RT tasks are offset by -200. Normal tasks are centered : 
strstr : for :  * RT tasks are offset by -200. Normal tasks are centered : 
strstr : while :  * RT tasks are offset by -200. Normal tasks are centered : 
str :  * around 0, value goes from -16 to +15.
strstr : INIT :  * around 0, value goes from -16 to +15. : 
strstr : if :  * around 0, value goes from -16 to +15. : 
strstr : for :  * around 0, value goes from -16 to +15. : 
strstr : while :  * around 0, value goes from -16 to +15. : 
str :  */
strstr : INIT :  */ : 
strstr : if :  */ : 
strstr : for :  */ : 
strstr : while :  */ : 
str : int task_prio(const struct task_struct *p)
strstr : INIT : int task_prio(const struct task_struct *p) : 
strstr : if : int task_prio(const struct task_struct *p) : 
strstr : for : int task_prio(const struct task_struct *p) : 
strstr : while : int task_prio(const struct task_struct *p) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	return p->prio - MAX_RT_PRIO;
strstr : INIT : 	return p->prio - MAX_RT_PRIO; : 
strstr : if : 	return p->prio - MAX_RT_PRIO; : 
strstr : for : 	return p->prio - MAX_RT_PRIO; : 
strstr : while : 	return p->prio - MAX_RT_PRIO; : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : /**
strstr : if : /** : 
strstr : for : /** : 
strstr : while : /** : 
str :  * task_nice - return the nice value of a given task.
strstr : INIT :  * task_nice - return the nice value of a given task. : 
strstr : if :  * task_nice - return the nice value of a given task. : 
strstr : for :  * task_nice - return the nice value of a given task. : 
strstr : while :  * task_nice - return the nice value of a given task. : 
str :  * @p: the task in question.
strstr : INIT :  * @p: the task in question. : 
strstr : if :  * @p: the task in question. : 
strstr : for :  * @p: the task in question. : 
strstr : while :  * @p: the task in question. : 
str :  *
strstr : INIT :  * : 
strstr : if :  * : 
strstr : for :  * : 
strstr : while :  * : 
str :  * Return: The nice value [ -20 ... 0 ... 19 ].
strstr : INIT :  * Return: The nice value [ -20 ... 0 ... 19 ]. : 
strstr : if :  * Return: The nice value [ -20 ... 0 ... 19 ]. : 
strstr : for :  * Return: The nice value [ -20 ... 0 ... 19 ]. : 
strstr : while :  * Return: The nice value [ -20 ... 0 ... 19 ]. : 
str :  */
strstr : INIT :  */ : 
strstr : if :  */ : 
strstr : for :  */ : 
strstr : while :  */ : 
str : int task_nice(const struct task_struct *p)
strstr : INIT : int task_nice(const struct task_struct *p) : 
strstr : if : int task_nice(const struct task_struct *p) : 
strstr : for : int task_nice(const struct task_struct *p) : 
strstr : while : int task_nice(const struct task_struct *p) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	return TASK_NICE(p);
strstr : INIT : 	return TASK_NICE(p); : 
strstr : if : 	return TASK_NICE(p); : 
strstr : for : 	return TASK_NICE(p); : 
strstr : while : 	return TASK_NICE(p); : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : EXPORT_SYMBOL(task_nice);
strstr : INIT : EXPORT_SYMBOL(task_nice); : 
strstr : if : EXPORT_SYMBOL(task_nice); : 
strstr : for : EXPORT_SYMBOL(task_nice); : 
strstr : while : EXPORT_SYMBOL(task_nice); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : /**
strstr : if : /** : 
strstr : for : /** : 
strstr : while : /** : 
str :  * idle_cpu - is a given cpu idle currently?
strstr : INIT :  * idle_cpu - is a given cpu idle currently? : 
strstr : if :  * idle_cpu - is a given cpu idle currently? : 
strstr : for :  * idle_cpu - is a given cpu idle currently? : 
strstr : while :  * idle_cpu - is a given cpu idle currently? : 
str :  * @cpu: the processor in question.
strstr : INIT :  * @cpu: the processor in question. : 
strstr : if :  * @cpu: the processor in question. : 
strstr : for :  * @cpu: the processor in question. : 
strstr : while :  * @cpu: the processor in question. : 
str :  *
strstr : INIT :  * : 
strstr : if :  * : 
strstr : for :  * : 
strstr : while :  * : 
str :  * Return: 1 if the CPU is currently idle. 0 otherwise.
strstr : INIT :  * Return: 1 if the CPU is currently idle. 0 otherwise. : 
strstr : if :  * Return: 1 if the CPU is currently idle. 0 otherwise. : 
strstr : for :  * Return: 1 if the CPU is currently idle. 0 otherwise. : 
strstr : while :  * Return: 1 if the CPU is currently idle. 0 otherwise. : 
str :  */
strstr : INIT :  */ : 
strstr : if :  */ : 
strstr : for :  */ : 
strstr : while :  */ : 
str : int idle_cpu(int cpu)
strstr : INIT : int idle_cpu(int cpu) : 
strstr : if : int idle_cpu(int cpu) : 
strstr : for : int idle_cpu(int cpu) : 
strstr : while : int idle_cpu(int cpu) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	struct rq *rq = cpu_rq(cpu);
strstr : INIT : 	struct rq *rq = cpu_rq(cpu); : 
strstr : if : 	struct rq *rq = cpu_rq(cpu); : 
strstr : for : 	struct rq *rq = cpu_rq(cpu); : 
strstr : while : 	struct rq *rq = cpu_rq(cpu); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	if (rq->curr != rq->idle)
strstr : if : 	if (rq->curr != rq->idle) : 
strstr : for : 	if (rq->curr != rq->idle) : 
strstr : while : 	if (rq->curr != rq->idle) : 
str : 		return 0;
strstr : INIT : 		return 0; : 
strstr : if : 		return 0; : 
strstr : for : 		return 0; : 
strstr : while : 		return 0; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	if (rq->nr_running)
strstr : if : 	if (rq->nr_running) : 
strstr : for : 	if (rq->nr_running) : 
strstr : while : 	if (rq->nr_running) : 
str : 		return 0;
strstr : INIT : 		return 0; : 
strstr : if : 		return 0; : 
strstr : for : 		return 0; : 
strstr : while : 		return 0; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : #ifdef CONFIG_SMP
strstr : if : #ifdef CONFIG_SMP : 
strstr : for : #ifdef CONFIG_SMP : 
strstr : while : #ifdef CONFIG_SMP : 
str : 	if (!llist_empty(&rq->wake_list))
strstr : INIT : 	if (!llist_empty(&rq->wake_list)) : 
strstr : if : 	if (!llist_empty(&rq->wake_list)) : 
strstr : for : 	if (!llist_empty(&rq->wake_list)) : 
strstr : while : 	if (!llist_empty(&rq->wake_list)) : 
str : 		return 0;
strstr : INIT : 		return 0; : 
strstr : if : 		return 0; : 
strstr : for : 		return 0; : 
strstr : while : 		return 0; : 
str : #endif
strstr : INIT : #endif : 
strstr : if : #endif : 
strstr : for : #endif : 
strstr : while : #endif : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	return 1;
strstr : if : 	return 1; : 
strstr : for : 	return 1; : 
strstr : while : 	return 1; : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : /**
strstr : if : /** : 
strstr : for : /** : 
strstr : while : /** : 
str :  * idle_task - return the idle task for a given cpu.
strstr : INIT :  * idle_task - return the idle task for a given cpu. : 
strstr : if :  * idle_task - return the idle task for a given cpu. : 
strstr : for :  * idle_task - return the idle task for a given cpu. : 
strstr : while :  * idle_task - return the idle task for a given cpu. : 
str :  * @cpu: the processor in question.
strstr : INIT :  * @cpu: the processor in question. : 
strstr : if :  * @cpu: the processor in question. : 
strstr : for :  * @cpu: the processor in question. : 
strstr : while :  * @cpu: the processor in question. : 
str :  *
strstr : INIT :  * : 
strstr : if :  * : 
strstr : for :  * : 
strstr : while :  * : 
str :  * Return: The idle task for the cpu @cpu.
strstr : INIT :  * Return: The idle task for the cpu @cpu. : 
strstr : if :  * Return: The idle task for the cpu @cpu. : 
strstr : for :  * Return: The idle task for the cpu @cpu. : 
strstr : while :  * Return: The idle task for the cpu @cpu. : 
str :  */
strstr : INIT :  */ : 
strstr : if :  */ : 
strstr : for :  */ : 
strstr : while :  */ : 
str : struct task_struct *idle_task(int cpu)
strstr : INIT : struct task_struct *idle_task(int cpu) : 
strstr : if : struct task_struct *idle_task(int cpu) : 
strstr : for : struct task_struct *idle_task(int cpu) : 
strstr : while : struct task_struct *idle_task(int cpu) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	return cpu_rq(cpu)->idle;
strstr : INIT : 	return cpu_rq(cpu)->idle; : 
strstr : if : 	return cpu_rq(cpu)->idle; : 
strstr : for : 	return cpu_rq(cpu)->idle; : 
strstr : while : 	return cpu_rq(cpu)->idle; : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : /**
strstr : if : /** : 
strstr : for : /** : 
strstr : while : /** : 
str :  * find_process_by_pid - find a process with a matching PID value.
strstr : INIT :  * find_process_by_pid - find a process with a matching PID value. : 
strstr : if :  * find_process_by_pid - find a process with a matching PID value. : 
strstr : for :  * find_process_by_pid - find a process with a matching PID value. : 
strstr : while :  * find_process_by_pid - find a process with a matching PID value. : 
str :  * @pid: the pid in question.
strstr : INIT :  * @pid: the pid in question. : 
strstr : if :  * @pid: the pid in question. : 
strstr : for :  * @pid: the pid in question. : 
strstr : while :  * @pid: the pid in question. : 
str :  *
strstr : INIT :  * : 
strstr : if :  * : 
strstr : for :  * : 
strstr : while :  * : 
str :  * The task of @pid, if found. %NULL otherwise.
strstr : INIT :  * The task of @pid, if found. %NULL otherwise. : 
strstr : if :  * The task of @pid, if found. %NULL otherwise. : 
strstr : for :  * The task of @pid, if found. %NULL otherwise. : 
strstr : while :  * The task of @pid, if found. %NULL otherwise. : 
str :  */
strstr : INIT :  */ : 
strstr : if :  */ : 
strstr : for :  */ : 
strstr : while :  */ : 
str : static struct task_struct *find_process_by_pid(pid_t pid)
strstr : INIT : static struct task_struct *find_process_by_pid(pid_t pid) : 
strstr : if : static struct task_struct *find_process_by_pid(pid_t pid) : 
strstr : for : static struct task_struct *find_process_by_pid(pid_t pid) : 
strstr : while : static struct task_struct *find_process_by_pid(pid_t pid) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	return pid ? find_task_by_vpid(pid) : current;
strstr : INIT : 	return pid ? find_task_by_vpid(pid) : current; : 
strstr : if : 	return pid ? find_task_by_vpid(pid) : current; : 
strstr : for : 	return pid ? find_task_by_vpid(pid) : current; : 
strstr : while : 	return pid ? find_task_by_vpid(pid) : current; : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : /*
strstr : if : /* : 
strstr : for : /* : 
strstr : while : /* : 
str :  * This function initializes the sched_dl_entity of a newly becoming
strstr : INIT :  * This function initializes the sched_dl_entity of a newly becoming : 
strstr : if :  * This function initializes the sched_dl_entity of a newly becoming : 
strstr : for :  * This function initializes the sched_dl_entity of a newly becoming : 
strstr : while :  * This function initializes the sched_dl_entity of a newly becoming : 
str :  * SCHED_DEADLINE task.
strstr : INIT :  * SCHED_DEADLINE task. : 
strstr : if :  * SCHED_DEADLINE task. : 
strstr : for :  * SCHED_DEADLINE task. : 
strstr : while :  * SCHED_DEADLINE task. : 
str :  *
strstr : INIT :  * : 
strstr : if :  * : 
strstr : for :  * : 
strstr : while :  * : 
str :  * Only the static values are considered here, the actual runtime and the
strstr : INIT :  * Only the static values are considered here, the actual runtime and the : 
strstr : if :  * Only the static values are considered here, the actual runtime and the : 
strstr : for :  * Only the static values are considered here, the actual runtime and the : 
strstr : while :  * Only the static values are considered here, the actual runtime and the : 
str :  * absolute deadline will be properly calculated when the task is enqueued
strstr : INIT :  * absolute deadline will be properly calculated when the task is enqueued : 
strstr : if :  * absolute deadline will be properly calculated when the task is enqueued : 
strstr : for :  * absolute deadline will be properly calculated when the task is enqueued : 
strstr : while :  * absolute deadline will be properly calculated when the task is enqueued : 
str :  * for the first time with its new policy.
strstr : INIT :  * for the first time with its new policy. : 
strstr : if :  * for the first time with its new policy. : 
strstr : for :  * for the first time with its new policy. : 
strstr : while :  * for the first time with its new policy. : 
str :  */
strstr : INIT :  */ : 
strstr : if :  */ : 
strstr : for :  */ : 
strstr : while :  */ : 
str : static void
strstr : INIT : static void : 
strstr : if : static void : 
strstr : for : static void : 
strstr : while : static void : 
str : __setparam_dl(struct task_struct *p, const struct sched_attr *attr)
strstr : INIT : __setparam_dl(struct task_struct *p, const struct sched_attr *attr) : 
strstr : if : __setparam_dl(struct task_struct *p, const struct sched_attr *attr) : 
strstr : for : __setparam_dl(struct task_struct *p, const struct sched_attr *attr) : 
strstr : while : __setparam_dl(struct task_struct *p, const struct sched_attr *attr) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	struct sched_dl_entity *dl_se = &p->dl;
strstr : INIT : 	struct sched_dl_entity *dl_se = &p->dl; : 
strstr : if : 	struct sched_dl_entity *dl_se = &p->dl; : 
strstr : for : 	struct sched_dl_entity *dl_se = &p->dl; : 
strstr : while : 	struct sched_dl_entity *dl_se = &p->dl; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	init_dl_task_timer(dl_se);
strstr : if : 	init_dl_task_timer(dl_se); : 
strstr : for : 	init_dl_task_timer(dl_se); : 
strstr : while : 	init_dl_task_timer(dl_se); : 
str : 	dl_se->dl_runtime = attr->sched_runtime;
strstr : INIT : 	dl_se->dl_runtime = attr->sched_runtime; : 
strstr : if : 	dl_se->dl_runtime = attr->sched_runtime; : 
strstr : for : 	dl_se->dl_runtime = attr->sched_runtime; : 
strstr : while : 	dl_se->dl_runtime = attr->sched_runtime; : 
str : 	dl_se->dl_deadline = attr->sched_deadline;
strstr : INIT : 	dl_se->dl_deadline = attr->sched_deadline; : 
strstr : if : 	dl_se->dl_deadline = attr->sched_deadline; : 
strstr : for : 	dl_se->dl_deadline = attr->sched_deadline; : 
strstr : while : 	dl_se->dl_deadline = attr->sched_deadline; : 
str : 	dl_se->dl_period = attr->sched_period ?: dl_se->dl_deadline;
strstr : INIT : 	dl_se->dl_period = attr->sched_period ?: dl_se->dl_deadline; : 
strstr : if : 	dl_se->dl_period = attr->sched_period ?: dl_se->dl_deadline; : 
strstr : for : 	dl_se->dl_period = attr->sched_period ?: dl_se->dl_deadline; : 
strstr : while : 	dl_se->dl_period = attr->sched_period ?: dl_se->dl_deadline; : 
str : 	dl_se->flags = attr->sched_flags;
strstr : INIT : 	dl_se->flags = attr->sched_flags; : 
strstr : if : 	dl_se->flags = attr->sched_flags; : 
strstr : for : 	dl_se->flags = attr->sched_flags; : 
strstr : while : 	dl_se->flags = attr->sched_flags; : 
str : 	dl_se->dl_bw = to_ratio(dl_se->dl_period, dl_se->dl_runtime);
strstr : INIT : 	dl_se->dl_bw = to_ratio(dl_se->dl_period, dl_se->dl_runtime); : 
strstr : if : 	dl_se->dl_bw = to_ratio(dl_se->dl_period, dl_se->dl_runtime); : 
strstr : for : 	dl_se->dl_bw = to_ratio(dl_se->dl_period, dl_se->dl_runtime); : 
strstr : while : 	dl_se->dl_bw = to_ratio(dl_se->dl_period, dl_se->dl_runtime); : 
str : 	dl_se->dl_throttled = 0;
strstr : INIT : 	dl_se->dl_throttled = 0; : 
strstr : if : 	dl_se->dl_throttled = 0; : 
strstr : for : 	dl_se->dl_throttled = 0; : 
strstr : while : 	dl_se->dl_throttled = 0; : 
str : 	dl_se->dl_new = 1;
strstr : INIT : 	dl_se->dl_new = 1; : 
strstr : if : 	dl_se->dl_new = 1; : 
strstr : for : 	dl_se->dl_new = 1; : 
strstr : while : 	dl_se->dl_new = 1; : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : /* Actually do priority change: must hold pi & rq lock. */
strstr : if : /* Actually do priority change: must hold pi & rq lock. */ : 
strstr : for : /* Actually do priority change: must hold pi & rq lock. */ : 
strstr : while : /* Actually do priority change: must hold pi & rq lock. */ : 
str : static void __setscheduler(struct rq *rq, struct task_struct *p,
strstr : INIT : static void __setscheduler(struct rq *rq, struct task_struct *p, : 
strstr : if : static void __setscheduler(struct rq *rq, struct task_struct *p, : 
strstr : for : static void __setscheduler(struct rq *rq, struct task_struct *p, : 
strstr : while : static void __setscheduler(struct rq *rq, struct task_struct *p, : 
str : 			   const struct sched_attr *attr)
strstr : INIT : 			   const struct sched_attr *attr) : 
strstr : if : 			   const struct sched_attr *attr) : 
strstr : for : 			   const struct sched_attr *attr) : 
strstr : while : 			   const struct sched_attr *attr) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	int policy = attr->sched_policy;
strstr : INIT : 	int policy = attr->sched_policy; : 
strstr : if : 	int policy = attr->sched_policy; : 
strstr : for : 	int policy = attr->sched_policy; : 
strstr : while : 	int policy = attr->sched_policy; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	if (policy == -1) /* setparam */
strstr : if : 	if (policy == -1) /* setparam */ : 
strstr : for : 	if (policy == -1) /* setparam */ : 
strstr : while : 	if (policy == -1) /* setparam */ : 
str : 		policy = p->policy;
strstr : INIT : 		policy = p->policy; : 
strstr : if : 		policy = p->policy; : 
strstr : for : 		policy = p->policy; : 
strstr : while : 		policy = p->policy; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	p->policy = policy;
strstr : if : 	p->policy = policy; : 
strstr : for : 	p->policy = policy; : 
strstr : while : 	p->policy = policy; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	if (dl_policy(policy))
strstr : if : 	if (dl_policy(policy)) : 
strstr : for : 	if (dl_policy(policy)) : 
strstr : while : 	if (dl_policy(policy)) : 
str : 		__setparam_dl(p, attr);
strstr : INIT : 		__setparam_dl(p, attr); : 
strstr : if : 		__setparam_dl(p, attr); : 
strstr : for : 		__setparam_dl(p, attr); : 
strstr : while : 		__setparam_dl(p, attr); : 
str : 	else if (fair_policy(policy))
strstr : INIT : 	else if (fair_policy(policy)) : 
strstr : if : 	else if (fair_policy(policy)) : 
strstr : for : 	else if (fair_policy(policy)) : 
strstr : while : 	else if (fair_policy(policy)) : 
str : 		p->static_prio = NICE_TO_PRIO(attr->sched_nice);
strstr : INIT : 		p->static_prio = NICE_TO_PRIO(attr->sched_nice); : 
strstr : if : 		p->static_prio = NICE_TO_PRIO(attr->sched_nice); : 
strstr : for : 		p->static_prio = NICE_TO_PRIO(attr->sched_nice); : 
strstr : while : 		p->static_prio = NICE_TO_PRIO(attr->sched_nice); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	/*
strstr : if : 	/* : 
strstr : for : 	/* : 
strstr : while : 	/* : 
str : 	 * __sched_setscheduler() ensures attr->sched_priority == 0 when
strstr : INIT : 	 * __sched_setscheduler() ensures attr->sched_priority == 0 when : 
strstr : if : 	 * __sched_setscheduler() ensures attr->sched_priority == 0 when : 
strstr : for : 	 * __sched_setscheduler() ensures attr->sched_priority == 0 when : 
strstr : while : 	 * __sched_setscheduler() ensures attr->sched_priority == 0 when : 
str : 	 * !rt_policy. Always setting this ensures that things like
strstr : INIT : 	 * !rt_policy. Always setting this ensures that things like : 
strstr : if : 	 * !rt_policy. Always setting this ensures that things like : 
strstr : for : 	 * !rt_policy. Always setting this ensures that things like : 
strstr : while : 	 * !rt_policy. Always setting this ensures that things like : 
str : 	 * getparam()/getattr() don't report silly values for !rt tasks.
strstr : INIT : 	 * getparam()/getattr() don't report silly values for !rt tasks. : 
strstr : if : 	 * getparam()/getattr() don't report silly values for !rt tasks. : 
strstr : for : 	 * getparam()/getattr() don't report silly values for !rt tasks. : 
strstr : while : 	 * getparam()/getattr() don't report silly values for !rt tasks. : 
str : 	 */
strstr : INIT : 	 */ : 
strstr : if : 	 */ : 
strstr : for : 	 */ : 
strstr : while : 	 */ : 
str : 	p->rt_priority = attr->sched_priority;
strstr : INIT : 	p->rt_priority = attr->sched_priority; : 
strstr : if : 	p->rt_priority = attr->sched_priority; : 
strstr : for : 	p->rt_priority = attr->sched_priority; : 
strstr : while : 	p->rt_priority = attr->sched_priority; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	p->normal_prio = normal_prio(p);
strstr : if : 	p->normal_prio = normal_prio(p); : 
strstr : for : 	p->normal_prio = normal_prio(p); : 
strstr : while : 	p->normal_prio = normal_prio(p); : 
str : 	p->prio = rt_mutex_getprio(p);
strstr : INIT : 	p->prio = rt_mutex_getprio(p); : 
strstr : if : 	p->prio = rt_mutex_getprio(p); : 
strstr : for : 	p->prio = rt_mutex_getprio(p); : 
strstr : while : 	p->prio = rt_mutex_getprio(p); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	if (dl_prio(p->prio))
strstr : if : 	if (dl_prio(p->prio)) : 
strstr : for : 	if (dl_prio(p->prio)) : 
strstr : while : 	if (dl_prio(p->prio)) : 
str : 		p->sched_class = &dl_sched_class;
strstr : INIT : 		p->sched_class = &dl_sched_class; : 
strstr : if : 		p->sched_class = &dl_sched_class; : 
strstr : for : 		p->sched_class = &dl_sched_class; : 
strstr : while : 		p->sched_class = &dl_sched_class; : 
str : 	else if (rt_prio(p->prio))
strstr : INIT : 	else if (rt_prio(p->prio)) : 
strstr : if : 	else if (rt_prio(p->prio)) : 
strstr : for : 	else if (rt_prio(p->prio)) : 
strstr : while : 	else if (rt_prio(p->prio)) : 
str : 		p->sched_class = &rt_sched_class;
strstr : INIT : 		p->sched_class = &rt_sched_class; : 
strstr : if : 		p->sched_class = &rt_sched_class; : 
strstr : for : 		p->sched_class = &rt_sched_class; : 
strstr : while : 		p->sched_class = &rt_sched_class; : 
str : 	else
strstr : INIT : 	else : 
strstr : if : 	else : 
strstr : for : 	else : 
strstr : while : 	else : 
str : 		p->sched_class = &fair_sched_class;
strstr : INIT : 		p->sched_class = &fair_sched_class; : 
strstr : if : 		p->sched_class = &fair_sched_class; : 
strstr : for : 		p->sched_class = &fair_sched_class; : 
strstr : while : 		p->sched_class = &fair_sched_class; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	set_load_weight(p);
strstr : if : 	set_load_weight(p); : 
strstr : for : 	set_load_weight(p); : 
strstr : while : 	set_load_weight(p); : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : static void
strstr : if : static void : 
strstr : for : static void : 
strstr : while : static void : 
str : __getparam_dl(struct task_struct *p, struct sched_attr *attr)
strstr : INIT : __getparam_dl(struct task_struct *p, struct sched_attr *attr) : 
strstr : if : __getparam_dl(struct task_struct *p, struct sched_attr *attr) : 
strstr : for : __getparam_dl(struct task_struct *p, struct sched_attr *attr) : 
strstr : while : __getparam_dl(struct task_struct *p, struct sched_attr *attr) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	struct sched_dl_entity *dl_se = &p->dl;
strstr : INIT : 	struct sched_dl_entity *dl_se = &p->dl; : 
strstr : if : 	struct sched_dl_entity *dl_se = &p->dl; : 
strstr : for : 	struct sched_dl_entity *dl_se = &p->dl; : 
strstr : while : 	struct sched_dl_entity *dl_se = &p->dl; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	attr->sched_priority = p->rt_priority;
strstr : if : 	attr->sched_priority = p->rt_priority; : 
strstr : for : 	attr->sched_priority = p->rt_priority; : 
strstr : while : 	attr->sched_priority = p->rt_priority; : 
str : 	attr->sched_runtime = dl_se->dl_runtime;
strstr : INIT : 	attr->sched_runtime = dl_se->dl_runtime; : 
strstr : if : 	attr->sched_runtime = dl_se->dl_runtime; : 
strstr : for : 	attr->sched_runtime = dl_se->dl_runtime; : 
strstr : while : 	attr->sched_runtime = dl_se->dl_runtime; : 
str : 	attr->sched_deadline = dl_se->dl_deadline;
strstr : INIT : 	attr->sched_deadline = dl_se->dl_deadline; : 
strstr : if : 	attr->sched_deadline = dl_se->dl_deadline; : 
strstr : for : 	attr->sched_deadline = dl_se->dl_deadline; : 
strstr : while : 	attr->sched_deadline = dl_se->dl_deadline; : 
str : 	attr->sched_period = dl_se->dl_period;
strstr : INIT : 	attr->sched_period = dl_se->dl_period; : 
strstr : if : 	attr->sched_period = dl_se->dl_period; : 
strstr : for : 	attr->sched_period = dl_se->dl_period; : 
strstr : while : 	attr->sched_period = dl_se->dl_period; : 
str : 	attr->sched_flags = dl_se->flags;
strstr : INIT : 	attr->sched_flags = dl_se->flags; : 
strstr : if : 	attr->sched_flags = dl_se->flags; : 
strstr : for : 	attr->sched_flags = dl_se->flags; : 
strstr : while : 	attr->sched_flags = dl_se->flags; : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : /*
strstr : if : /* : 
strstr : for : /* : 
strstr : while : /* : 
str :  * This function validates the new parameters of a -deadline task.
strstr : INIT :  * This function validates the new parameters of a -deadline task. : 
strstr : if :  * This function validates the new parameters of a -deadline task. : 
strstr : for :  * This function validates the new parameters of a -deadline task. : 
strstr : while :  * This function validates the new parameters of a -deadline task. : 
str :  * We ask for the deadline not being zero, and greater or equal
strstr : INIT :  * We ask for the deadline not being zero, and greater or equal : 
strstr : if :  * We ask for the deadline not being zero, and greater or equal : 
strstr : for :  * We ask for the deadline not being zero, and greater or equal : 
strstr : while :  * We ask for the deadline not being zero, and greater or equal : 
str :  * than the runtime, as well as the period of being zero or
strstr : INIT :  * than the runtime, as well as the period of being zero or : 
strstr : if :  * than the runtime, as well as the period of being zero or : 
strstr : for :  * than the runtime, as well as the period of being zero or : 
strstr : while :  * than the runtime, as well as the period of being zero or : 
str :  * greater than deadline. Furthermore, we have to be sure that
strstr : INIT :  * greater than deadline. Furthermore, we have to be sure that : 
strstr : if :  * greater than deadline. Furthermore, we have to be sure that : 
strstr : for :  * greater than deadline. Furthermore, we have to be sure that : 
strstr : while :  * greater than deadline. Furthermore, we have to be sure that : 
str :  * user parameters are above the internal resolution of 1us (we
strstr : INIT :  * user parameters are above the internal resolution of 1us (we : 
strstr : if :  * user parameters are above the internal resolution of 1us (we : 
strstr : for :  * user parameters are above the internal resolution of 1us (we : 
strstr : while :  * user parameters are above the internal resolution of 1us (we : 
str :  * check sched_runtime only since it is always the smaller one) and
strstr : INIT :  * check sched_runtime only since it is always the smaller one) and : 
strstr : if :  * check sched_runtime only since it is always the smaller one) and : 
strstr : for :  * check sched_runtime only since it is always the smaller one) and : 
strstr : while :  * check sched_runtime only since it is always the smaller one) and : 
str :  * below 2^63 ns (we have to check both sched_deadline and
strstr : INIT :  * below 2^63 ns (we have to check both sched_deadline and : 
strstr : if :  * below 2^63 ns (we have to check both sched_deadline and : 
strstr : for :  * below 2^63 ns (we have to check both sched_deadline and : 
strstr : while :  * below 2^63 ns (we have to check both sched_deadline and : 
str :  * sched_period, as the latter can be zero).
strstr : INIT :  * sched_period, as the latter can be zero). : 
strstr : if :  * sched_period, as the latter can be zero). : 
strstr : for :  * sched_period, as the latter can be zero). : 
strstr : while :  * sched_period, as the latter can be zero). : 
str :  */
strstr : INIT :  */ : 
strstr : if :  */ : 
strstr : for :  */ : 
strstr : while :  */ : 
str : static bool
strstr : INIT : static bool : 
strstr : if : static bool : 
strstr : for : static bool : 
strstr : while : static bool : 
str : __checkparam_dl(const struct sched_attr *attr)
strstr : INIT : __checkparam_dl(const struct sched_attr *attr) : 
strstr : if : __checkparam_dl(const struct sched_attr *attr) : 
strstr : for : __checkparam_dl(const struct sched_attr *attr) : 
strstr : while : __checkparam_dl(const struct sched_attr *attr) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	/* deadline != 0 */
strstr : INIT : 	/* deadline != 0 */ : 
strstr : if : 	/* deadline != 0 */ : 
strstr : for : 	/* deadline != 0 */ : 
strstr : while : 	/* deadline != 0 */ : 
str : 	if (attr->sched_deadline == 0)
strstr : INIT : 	if (attr->sched_deadline == 0) : 
strstr : if : 	if (attr->sched_deadline == 0) : 
strstr : for : 	if (attr->sched_deadline == 0) : 
strstr : while : 	if (attr->sched_deadline == 0) : 
str : 		return false;
strstr : INIT : 		return false; : 
strstr : if : 		return false; : 
strstr : for : 		return false; : 
strstr : while : 		return false; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	/*
strstr : if : 	/* : 
strstr : for : 	/* : 
strstr : while : 	/* : 
str : 	 * Since we truncate DL_SCALE bits, make sure we're at least
strstr : INIT : 	 * Since we truncate DL_SCALE bits, make sure we're at least : 
strstr : if : 	 * Since we truncate DL_SCALE bits, make sure we're at least : 
strstr : for : 	 * Since we truncate DL_SCALE bits, make sure we're at least : 
strstr : while : 	 * Since we truncate DL_SCALE bits, make sure we're at least : 
str : 	 * that big.
strstr : INIT : 	 * that big. : 
strstr : if : 	 * that big. : 
strstr : for : 	 * that big. : 
strstr : while : 	 * that big. : 
str : 	 */
strstr : INIT : 	 */ : 
strstr : if : 	 */ : 
strstr : for : 	 */ : 
strstr : while : 	 */ : 
str : 	if (attr->sched_runtime < (1ULL << DL_SCALE))
strstr : INIT : 	if (attr->sched_runtime < (1ULL << DL_SCALE)) : 
strstr : if : 	if (attr->sched_runtime < (1ULL << DL_SCALE)) : 
strstr : for : 	if (attr->sched_runtime < (1ULL << DL_SCALE)) : 
strstr : while : 	if (attr->sched_runtime < (1ULL << DL_SCALE)) : 
str : 		return false;
strstr : INIT : 		return false; : 
strstr : if : 		return false; : 
strstr : for : 		return false; : 
strstr : while : 		return false; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	/*
strstr : if : 	/* : 
strstr : for : 	/* : 
strstr : while : 	/* : 
str : 	 * Since we use the MSB for wrap-around and sign issues, make
strstr : INIT : 	 * Since we use the MSB for wrap-around and sign issues, make : 
strstr : if : 	 * Since we use the MSB for wrap-around and sign issues, make : 
strstr : for : 	 * Since we use the MSB for wrap-around and sign issues, make : 
strstr : while : 	 * Since we use the MSB for wrap-around and sign issues, make : 
str : 	 * sure it's not set (mind that period can be equal to zero).
strstr : INIT : 	 * sure it's not set (mind that period can be equal to zero). : 
strstr : if : 	 * sure it's not set (mind that period can be equal to zero). : 
strstr : for : 	 * sure it's not set (mind that period can be equal to zero). : 
strstr : while : 	 * sure it's not set (mind that period can be equal to zero). : 
str : 	 */
strstr : INIT : 	 */ : 
strstr : if : 	 */ : 
strstr : for : 	 */ : 
strstr : while : 	 */ : 
str : 	if (attr->sched_deadline & (1ULL << 63) ||
strstr : INIT : 	if (attr->sched_deadline & (1ULL << 63) || : 
strstr : if : 	if (attr->sched_deadline & (1ULL << 63) || : 
strstr : for : 	if (attr->sched_deadline & (1ULL << 63) || : 
strstr : while : 	if (attr->sched_deadline & (1ULL << 63) || : 
str : 	    attr->sched_period & (1ULL << 63))
strstr : INIT : 	    attr->sched_period & (1ULL << 63)) : 
strstr : if : 	    attr->sched_period & (1ULL << 63)) : 
strstr : for : 	    attr->sched_period & (1ULL << 63)) : 
strstr : while : 	    attr->sched_period & (1ULL << 63)) : 
str : 		return false;
strstr : INIT : 		return false; : 
strstr : if : 		return false; : 
strstr : for : 		return false; : 
strstr : while : 		return false; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	/* runtime <= deadline <= period (if period != 0) */
strstr : if : 	/* runtime <= deadline <= period (if period != 0) */ : 
strstr : for : 	/* runtime <= deadline <= period (if period != 0) */ : 
strstr : while : 	/* runtime <= deadline <= period (if period != 0) */ : 
str : 	if ((attr->sched_period != 0 &&
strstr : INIT : 	if ((attr->sched_period != 0 && : 
strstr : if : 	if ((attr->sched_period != 0 && : 
strstr : for : 	if ((attr->sched_period != 0 && : 
strstr : while : 	if ((attr->sched_period != 0 && : 
str : 	     attr->sched_period < attr->sched_deadline) ||
strstr : INIT : 	     attr->sched_period < attr->sched_deadline) || : 
strstr : if : 	     attr->sched_period < attr->sched_deadline) || : 
strstr : for : 	     attr->sched_period < attr->sched_deadline) || : 
strstr : while : 	     attr->sched_period < attr->sched_deadline) || : 
str : 	    attr->sched_deadline < attr->sched_runtime)
strstr : INIT : 	    attr->sched_deadline < attr->sched_runtime) : 
strstr : if : 	    attr->sched_deadline < attr->sched_runtime) : 
strstr : for : 	    attr->sched_deadline < attr->sched_runtime) : 
strstr : while : 	    attr->sched_deadline < attr->sched_runtime) : 
str : 		return false;
strstr : INIT : 		return false; : 
strstr : if : 		return false; : 
strstr : for : 		return false; : 
strstr : while : 		return false; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	return true;
strstr : if : 	return true; : 
strstr : for : 	return true; : 
strstr : while : 	return true; : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : /*
strstr : if : /* : 
strstr : for : /* : 
strstr : while : /* : 
str :  * check the target process has a UID that matches the current process's
strstr : INIT :  * check the target process has a UID that matches the current process's : 
strstr : if :  * check the target process has a UID that matches the current process's : 
strstr : for :  * check the target process has a UID that matches the current process's : 
strstr : while :  * check the target process has a UID that matches the current process's : 
str :  */
strstr : INIT :  */ : 
strstr : if :  */ : 
strstr : for :  */ : 
strstr : while :  */ : 
str : static bool check_same_owner(struct task_struct *p)
strstr : INIT : static bool check_same_owner(struct task_struct *p) : 
strstr : if : static bool check_same_owner(struct task_struct *p) : 
strstr : for : static bool check_same_owner(struct task_struct *p) : 
strstr : while : static bool check_same_owner(struct task_struct *p) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	const struct cred *cred = current_cred(), *pcred;
strstr : INIT : 	const struct cred *cred = current_cred(), *pcred; : 
strstr : if : 	const struct cred *cred = current_cred(), *pcred; : 
strstr : for : 	const struct cred *cred = current_cred(), *pcred; : 
strstr : while : 	const struct cred *cred = current_cred(), *pcred; : 
str : 	bool match;
strstr : INIT : 	bool match; : 
strstr : if : 	bool match; : 
strstr : for : 	bool match; : 
strstr : while : 	bool match; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	rcu_read_lock();
strstr : if : 	rcu_read_lock(); : 
strstr : for : 	rcu_read_lock(); : 
strstr : while : 	rcu_read_lock(); : 
str : 	pcred = __task_cred(p);
strstr : INIT : 	pcred = __task_cred(p); : 
strstr : if : 	pcred = __task_cred(p); : 
strstr : for : 	pcred = __task_cred(p); : 
strstr : while : 	pcred = __task_cred(p); : 
str : 	match = (uid_eq(cred->euid, pcred->euid) ||
strstr : INIT : 	match = (uid_eq(cred->euid, pcred->euid) || : 
strstr : if : 	match = (uid_eq(cred->euid, pcred->euid) || : 
strstr : for : 	match = (uid_eq(cred->euid, pcred->euid) || : 
strstr : while : 	match = (uid_eq(cred->euid, pcred->euid) || : 
str : 		 uid_eq(cred->euid, pcred->uid));
strstr : INIT : 		 uid_eq(cred->euid, pcred->uid)); : 
strstr : if : 		 uid_eq(cred->euid, pcred->uid)); : 
strstr : for : 		 uid_eq(cred->euid, pcred->uid)); : 
strstr : while : 		 uid_eq(cred->euid, pcred->uid)); : 
str : 	rcu_read_unlock();
strstr : INIT : 	rcu_read_unlock(); : 
strstr : if : 	rcu_read_unlock(); : 
strstr : for : 	rcu_read_unlock(); : 
strstr : while : 	rcu_read_unlock(); : 
str : 	return match;
strstr : INIT : 	return match; : 
strstr : if : 	return match; : 
strstr : for : 	return match; : 
strstr : while : 	return match; : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : static int __sched_setscheduler(struct task_struct *p,
strstr : if : static int __sched_setscheduler(struct task_struct *p, : 
strstr : for : static int __sched_setscheduler(struct task_struct *p, : 
strstr : while : static int __sched_setscheduler(struct task_struct *p, : 
str : 				const struct sched_attr *attr,
strstr : INIT : 				const struct sched_attr *attr, : 
strstr : if : 				const struct sched_attr *attr, : 
strstr : for : 				const struct sched_attr *attr, : 
strstr : while : 				const struct sched_attr *attr, : 
str : 				bool user)
strstr : INIT : 				bool user) : 
strstr : if : 				bool user) : 
strstr : for : 				bool user) : 
strstr : while : 				bool user) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	int retval, oldprio, oldpolicy = -1, on_rq, running;
strstr : INIT : 	int retval, oldprio, oldpolicy = -1, on_rq, running; : 
strstr : if : 	int retval, oldprio, oldpolicy = -1, on_rq, running; : 
strstr : for : 	int retval, oldprio, oldpolicy = -1, on_rq, running; : 
strstr : while : 	int retval, oldprio, oldpolicy = -1, on_rq, running; : 
str : 	int policy = attr->sched_policy;
strstr : INIT : 	int policy = attr->sched_policy; : 
strstr : if : 	int policy = attr->sched_policy; : 
strstr : for : 	int policy = attr->sched_policy; : 
strstr : while : 	int policy = attr->sched_policy; : 
str : 	unsigned long flags;
strstr : INIT : 	unsigned long flags; : 
strstr : if : 	unsigned long flags; : 
strstr : for : 	unsigned long flags; : 
strstr : while : 	unsigned long flags; : 
str : 	const struct sched_class *prev_class;
strstr : INIT : 	const struct sched_class *prev_class; : 
strstr : if : 	const struct sched_class *prev_class; : 
strstr : for : 	const struct sched_class *prev_class; : 
strstr : while : 	const struct sched_class *prev_class; : 
str : 	struct rq *rq;
strstr : INIT : 	struct rq *rq; : 
strstr : if : 	struct rq *rq; : 
strstr : for : 	struct rq *rq; : 
strstr : while : 	struct rq *rq; : 
str : 	int reset_on_fork;
strstr : INIT : 	int reset_on_fork; : 
strstr : if : 	int reset_on_fork; : 
strstr : for : 	int reset_on_fork; : 
strstr : while : 	int reset_on_fork; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	/* may grab non-irq protected spin_locks */
strstr : if : 	/* may grab non-irq protected spin_locks */ : 
strstr : for : 	/* may grab non-irq protected spin_locks */ : 
strstr : while : 	/* may grab non-irq protected spin_locks */ : 
str : 	BUG_ON(in_interrupt());
strstr : INIT : 	BUG_ON(in_interrupt()); : 
strstr : if : 	BUG_ON(in_interrupt()); : 
strstr : for : 	BUG_ON(in_interrupt()); : 
strstr : while : 	BUG_ON(in_interrupt()); : 
str : recheck:
strstr : INIT : recheck: : 
strstr : if : recheck: : 
strstr : for : recheck: : 
strstr : while : recheck: : 
str : 	/* double check policy once rq lock held */
strstr : INIT : 	/* double check policy once rq lock held */ : 
strstr : if : 	/* double check policy once rq lock held */ : 
strstr : for : 	/* double check policy once rq lock held */ : 
strstr : while : 	/* double check policy once rq lock held */ : 
str : 	if (policy < 0) {
strstr : INIT : 	if (policy < 0) { : 
strstr : if : 	if (policy < 0) { : 
strstr : for : 	if (policy < 0) { : 
strstr : while : 	if (policy < 0) { : 
str : 		reset_on_fork = p->sched_reset_on_fork;
strstr : INIT : 		reset_on_fork = p->sched_reset_on_fork; : 
strstr : if : 		reset_on_fork = p->sched_reset_on_fork; : 
strstr : for : 		reset_on_fork = p->sched_reset_on_fork; : 
strstr : while : 		reset_on_fork = p->sched_reset_on_fork; : 
str : 		policy = oldpolicy = p->policy;
strstr : INIT : 		policy = oldpolicy = p->policy; : 
strstr : if : 		policy = oldpolicy = p->policy; : 
strstr : for : 		policy = oldpolicy = p->policy; : 
strstr : while : 		policy = oldpolicy = p->policy; : 
str : 	} else {
strstr : INIT : 	} else { : 
strstr : if : 	} else { : 
strstr : for : 	} else { : 
strstr : while : 	} else { : 
str : 		reset_on_fork = !!(attr->sched_flags & SCHED_FLAG_RESET_ON_FORK);
strstr : INIT : 		reset_on_fork = !!(attr->sched_flags & SCHED_FLAG_RESET_ON_FORK); : 
strstr : if : 		reset_on_fork = !!(attr->sched_flags & SCHED_FLAG_RESET_ON_FORK); : 
strstr : for : 		reset_on_fork = !!(attr->sched_flags & SCHED_FLAG_RESET_ON_FORK); : 
strstr : while : 		reset_on_fork = !!(attr->sched_flags & SCHED_FLAG_RESET_ON_FORK); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 		if (policy != SCHED_DEADLINE &&
strstr : if : 		if (policy != SCHED_DEADLINE && : 
strstr : for : 		if (policy != SCHED_DEADLINE && : 
strstr : while : 		if (policy != SCHED_DEADLINE && : 
str : 				policy != SCHED_FIFO && policy != SCHED_RR &&
strstr : INIT : 				policy != SCHED_FIFO && policy != SCHED_RR && : 
strstr : if : 				policy != SCHED_FIFO && policy != SCHED_RR && : 
strstr : for : 				policy != SCHED_FIFO && policy != SCHED_RR && : 
strstr : while : 				policy != SCHED_FIFO && policy != SCHED_RR && : 
str : 				policy != SCHED_NORMAL && policy != SCHED_BATCH &&
strstr : INIT : 				policy != SCHED_NORMAL && policy != SCHED_BATCH && : 
strstr : if : 				policy != SCHED_NORMAL && policy != SCHED_BATCH && : 
strstr : for : 				policy != SCHED_NORMAL && policy != SCHED_BATCH && : 
strstr : while : 				policy != SCHED_NORMAL && policy != SCHED_BATCH && : 
str : 				policy != SCHED_IDLE)
strstr : INIT : 				policy != SCHED_IDLE) : 
strstr : if : 				policy != SCHED_IDLE) : 
strstr : for : 				policy != SCHED_IDLE) : 
strstr : while : 				policy != SCHED_IDLE) : 
str : 			return -EINVAL;
strstr : INIT : 			return -EINVAL; : 
strstr : if : 			return -EINVAL; : 
strstr : for : 			return -EINVAL; : 
strstr : while : 			return -EINVAL; : 
str : 	}
strstr : INIT : 	} : 
strstr : if : 	} : 
strstr : for : 	} : 
strstr : while : 	} : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	if (attr->sched_flags & ~(SCHED_FLAG_RESET_ON_FORK))
strstr : if : 	if (attr->sched_flags & ~(SCHED_FLAG_RESET_ON_FORK)) : 
strstr : for : 	if (attr->sched_flags & ~(SCHED_FLAG_RESET_ON_FORK)) : 
strstr : while : 	if (attr->sched_flags & ~(SCHED_FLAG_RESET_ON_FORK)) : 
str : 		return -EINVAL;
strstr : INIT : 		return -EINVAL; : 
strstr : if : 		return -EINVAL; : 
strstr : for : 		return -EINVAL; : 
strstr : while : 		return -EINVAL; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	/*
strstr : if : 	/* : 
strstr : for : 	/* : 
strstr : while : 	/* : 
str : 	 * Valid priorities for SCHED_FIFO and SCHED_RR are
strstr : INIT : 	 * Valid priorities for SCHED_FIFO and SCHED_RR are : 
strstr : if : 	 * Valid priorities for SCHED_FIFO and SCHED_RR are : 
strstr : for : 	 * Valid priorities for SCHED_FIFO and SCHED_RR are : 
strstr : while : 	 * Valid priorities for SCHED_FIFO and SCHED_RR are : 
str : 	 * 1..MAX_USER_RT_PRIO-1, valid priority for SCHED_NORMAL,
strstr : INIT : 	 * 1..MAX_USER_RT_PRIO-1, valid priority for SCHED_NORMAL, : 
strstr : if : 	 * 1..MAX_USER_RT_PRIO-1, valid priority for SCHED_NORMAL, : 
strstr : for : 	 * 1..MAX_USER_RT_PRIO-1, valid priority for SCHED_NORMAL, : 
strstr : while : 	 * 1..MAX_USER_RT_PRIO-1, valid priority for SCHED_NORMAL, : 
str : 	 * SCHED_BATCH and SCHED_IDLE is 0.
strstr : INIT : 	 * SCHED_BATCH and SCHED_IDLE is 0. : 
strstr : if : 	 * SCHED_BATCH and SCHED_IDLE is 0. : 
strstr : for : 	 * SCHED_BATCH and SCHED_IDLE is 0. : 
strstr : while : 	 * SCHED_BATCH and SCHED_IDLE is 0. : 
str : 	 */
strstr : INIT : 	 */ : 
strstr : if : 	 */ : 
strstr : for : 	 */ : 
strstr : while : 	 */ : 
str : 	if ((p->mm && attr->sched_priority > MAX_USER_RT_PRIO-1) ||
strstr : INIT : 	if ((p->mm && attr->sched_priority > MAX_USER_RT_PRIO-1) || : 
strstr : if : 	if ((p->mm && attr->sched_priority > MAX_USER_RT_PRIO-1) || : 
strstr : for : 	if ((p->mm && attr->sched_priority > MAX_USER_RT_PRIO-1) || : 
strstr : while : 	if ((p->mm && attr->sched_priority > MAX_USER_RT_PRIO-1) || : 
str : 	    (!p->mm && attr->sched_priority > MAX_RT_PRIO-1))
strstr : INIT : 	    (!p->mm && attr->sched_priority > MAX_RT_PRIO-1)) : 
strstr : if : 	    (!p->mm && attr->sched_priority > MAX_RT_PRIO-1)) : 
strstr : for : 	    (!p->mm && attr->sched_priority > MAX_RT_PRIO-1)) : 
strstr : while : 	    (!p->mm && attr->sched_priority > MAX_RT_PRIO-1)) : 
str : 		return -EINVAL;
strstr : INIT : 		return -EINVAL; : 
strstr : if : 		return -EINVAL; : 
strstr : for : 		return -EINVAL; : 
strstr : while : 		return -EINVAL; : 
str : 	if ((dl_policy(policy) && !__checkparam_dl(attr)) ||
strstr : INIT : 	if ((dl_policy(policy) && !__checkparam_dl(attr)) || : 
strstr : if : 	if ((dl_policy(policy) && !__checkparam_dl(attr)) || : 
strstr : for : 	if ((dl_policy(policy) && !__checkparam_dl(attr)) || : 
strstr : while : 	if ((dl_policy(policy) && !__checkparam_dl(attr)) || : 
str : 	    (rt_policy(policy) != (attr->sched_priority != 0)))
strstr : INIT : 	    (rt_policy(policy) != (attr->sched_priority != 0))) : 
strstr : if : 	    (rt_policy(policy) != (attr->sched_priority != 0))) : 
strstr : for : 	    (rt_policy(policy) != (attr->sched_priority != 0))) : 
strstr : while : 	    (rt_policy(policy) != (attr->sched_priority != 0))) : 
str : 		return -EINVAL;
strstr : INIT : 		return -EINVAL; : 
strstr : if : 		return -EINVAL; : 
strstr : for : 		return -EINVAL; : 
strstr : while : 		return -EINVAL; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	/*
strstr : if : 	/* : 
strstr : for : 	/* : 
strstr : while : 	/* : 
str : 	 * Allow unprivileged RT tasks to decrease priority:
strstr : INIT : 	 * Allow unprivileged RT tasks to decrease priority: : 
strstr : if : 	 * Allow unprivileged RT tasks to decrease priority: : 
strstr : for : 	 * Allow unprivileged RT tasks to decrease priority: : 
strstr : while : 	 * Allow unprivileged RT tasks to decrease priority: : 
str : 	 */
strstr : INIT : 	 */ : 
strstr : if : 	 */ : 
strstr : for : 	 */ : 
strstr : while : 	 */ : 
str : 	if (user && !capable(CAP_SYS_NICE)) {
strstr : INIT : 	if (user && !capable(CAP_SYS_NICE)) { : 
strstr : if : 	if (user && !capable(CAP_SYS_NICE)) { : 
strstr : for : 	if (user && !capable(CAP_SYS_NICE)) { : 
strstr : while : 	if (user && !capable(CAP_SYS_NICE)) { : 
str : 		if (fair_policy(policy)) {
strstr : INIT : 		if (fair_policy(policy)) { : 
strstr : if : 		if (fair_policy(policy)) { : 
strstr : for : 		if (fair_policy(policy)) { : 
strstr : while : 		if (fair_policy(policy)) { : 
str : 			if (attr->sched_nice < TASK_NICE(p) &&
strstr : INIT : 			if (attr->sched_nice < TASK_NICE(p) && : 
strstr : if : 			if (attr->sched_nice < TASK_NICE(p) && : 
strstr : for : 			if (attr->sched_nice < TASK_NICE(p) && : 
strstr : while : 			if (attr->sched_nice < TASK_NICE(p) && : 
str : 			    !can_nice(p, attr->sched_nice))
strstr : INIT : 			    !can_nice(p, attr->sched_nice)) : 
strstr : if : 			    !can_nice(p, attr->sched_nice)) : 
strstr : for : 			    !can_nice(p, attr->sched_nice)) : 
strstr : while : 			    !can_nice(p, attr->sched_nice)) : 
str : 				return -EPERM;
strstr : INIT : 				return -EPERM; : 
strstr : if : 				return -EPERM; : 
strstr : for : 				return -EPERM; : 
strstr : while : 				return -EPERM; : 
str : 		}
strstr : INIT : 		} : 
strstr : if : 		} : 
strstr : for : 		} : 
strstr : while : 		} : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 		if (rt_policy(policy)) {
strstr : if : 		if (rt_policy(policy)) { : 
strstr : for : 		if (rt_policy(policy)) { : 
strstr : while : 		if (rt_policy(policy)) { : 
str : 			unsigned long rlim_rtprio =
strstr : INIT : 			unsigned long rlim_rtprio = : 
strstr : if : 			unsigned long rlim_rtprio = : 
strstr : for : 			unsigned long rlim_rtprio = : 
strstr : while : 			unsigned long rlim_rtprio = : 
str : 					task_rlimit(p, RLIMIT_RTPRIO);
strstr : INIT : 					task_rlimit(p, RLIMIT_RTPRIO); : 
strstr : if : 					task_rlimit(p, RLIMIT_RTPRIO); : 
strstr : for : 					task_rlimit(p, RLIMIT_RTPRIO); : 
strstr : while : 					task_rlimit(p, RLIMIT_RTPRIO); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 			/* can't set/change the rt policy */
strstr : if : 			/* can't set/change the rt policy */ : 
strstr : for : 			/* can't set/change the rt policy */ : 
strstr : while : 			/* can't set/change the rt policy */ : 
str : 			if (policy != p->policy && !rlim_rtprio)
strstr : INIT : 			if (policy != p->policy && !rlim_rtprio) : 
strstr : if : 			if (policy != p->policy && !rlim_rtprio) : 
strstr : for : 			if (policy != p->policy && !rlim_rtprio) : 
strstr : while : 			if (policy != p->policy && !rlim_rtprio) : 
str : 				return -EPERM;
strstr : INIT : 				return -EPERM; : 
strstr : if : 				return -EPERM; : 
strstr : for : 				return -EPERM; : 
strstr : while : 				return -EPERM; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 			/* can't increase priority */
strstr : if : 			/* can't increase priority */ : 
strstr : for : 			/* can't increase priority */ : 
strstr : while : 			/* can't increase priority */ : 
str : 			if (attr->sched_priority > p->rt_priority &&
strstr : INIT : 			if (attr->sched_priority > p->rt_priority && : 
strstr : if : 			if (attr->sched_priority > p->rt_priority && : 
strstr : for : 			if (attr->sched_priority > p->rt_priority && : 
strstr : while : 			if (attr->sched_priority > p->rt_priority && : 
str : 			    attr->sched_priority > rlim_rtprio)
strstr : INIT : 			    attr->sched_priority > rlim_rtprio) : 
strstr : if : 			    attr->sched_priority > rlim_rtprio) : 
strstr : for : 			    attr->sched_priority > rlim_rtprio) : 
strstr : while : 			    attr->sched_priority > rlim_rtprio) : 
str : 				return -EPERM;
strstr : INIT : 				return -EPERM; : 
strstr : if : 				return -EPERM; : 
strstr : for : 				return -EPERM; : 
strstr : while : 				return -EPERM; : 
str : 		}
strstr : INIT : 		} : 
strstr : if : 		} : 
strstr : for : 		} : 
strstr : while : 		} : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 		 /*
strstr : if : 		 /* : 
strstr : for : 		 /* : 
strstr : while : 		 /* : 
str : 		  * Can't set/change SCHED_DEADLINE policy at all for now
strstr : INIT : 		  * Can't set/change SCHED_DEADLINE policy at all for now : 
strstr : if : 		  * Can't set/change SCHED_DEADLINE policy at all for now : 
strstr : for : 		  * Can't set/change SCHED_DEADLINE policy at all for now : 
strstr : while : 		  * Can't set/change SCHED_DEADLINE policy at all for now : 
str : 		  * (safest behavior); in the future we would like to allow
strstr : INIT : 		  * (safest behavior); in the future we would like to allow : 
strstr : if : 		  * (safest behavior); in the future we would like to allow : 
strstr : for : 		  * (safest behavior); in the future we would like to allow : 
strstr : while : 		  * (safest behavior); in the future we would like to allow : 
str : 		  * unprivileged DL tasks to increase their relative deadline
strstr : INIT : 		  * unprivileged DL tasks to increase their relative deadline : 
strstr : if : 		  * unprivileged DL tasks to increase their relative deadline : 
strstr : for : 		  * unprivileged DL tasks to increase their relative deadline : 
strstr : while : 		  * unprivileged DL tasks to increase their relative deadline : 
str : 		  * or reduce their runtime (both ways reducing utilization)
strstr : INIT : 		  * or reduce their runtime (both ways reducing utilization) : 
strstr : if : 		  * or reduce their runtime (both ways reducing utilization) : 
strstr : for : 		  * or reduce their runtime (both ways reducing utilization) : 
strstr : while : 		  * or reduce their runtime (both ways reducing utilization) : 
str : 		  */
strstr : INIT : 		  */ : 
strstr : if : 		  */ : 
strstr : for : 		  */ : 
strstr : while : 		  */ : 
str : 		if (dl_policy(policy))
strstr : INIT : 		if (dl_policy(policy)) : 
strstr : if : 		if (dl_policy(policy)) : 
strstr : for : 		if (dl_policy(policy)) : 
strstr : while : 		if (dl_policy(policy)) : 
str : 			return -EPERM;
strstr : INIT : 			return -EPERM; : 
strstr : if : 			return -EPERM; : 
strstr : for : 			return -EPERM; : 
strstr : while : 			return -EPERM; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 		/*
strstr : if : 		/* : 
strstr : for : 		/* : 
strstr : while : 		/* : 
str : 		 * Treat SCHED_IDLE as nice 20. Only allow a switch to
strstr : INIT : 		 * Treat SCHED_IDLE as nice 20. Only allow a switch to : 
strstr : if : 		 * Treat SCHED_IDLE as nice 20. Only allow a switch to : 
strstr : for : 		 * Treat SCHED_IDLE as nice 20. Only allow a switch to : 
strstr : while : 		 * Treat SCHED_IDLE as nice 20. Only allow a switch to : 
str : 		 * SCHED_NORMAL if the RLIMIT_NICE would normally permit it.
strstr : INIT : 		 * SCHED_NORMAL if the RLIMIT_NICE would normally permit it. : 
strstr : if : 		 * SCHED_NORMAL if the RLIMIT_NICE would normally permit it. : 
strstr : for : 		 * SCHED_NORMAL if the RLIMIT_NICE would normally permit it. : 
strstr : while : 		 * SCHED_NORMAL if the RLIMIT_NICE would normally permit it. : 
str : 		 */
strstr : INIT : 		 */ : 
strstr : if : 		 */ : 
strstr : for : 		 */ : 
strstr : while : 		 */ : 
str : 		if (p->policy == SCHED_IDLE && policy != SCHED_IDLE) {
strstr : INIT : 		if (p->policy == SCHED_IDLE && policy != SCHED_IDLE) { : 
strstr : if : 		if (p->policy == SCHED_IDLE && policy != SCHED_IDLE) { : 
strstr : for : 		if (p->policy == SCHED_IDLE && policy != SCHED_IDLE) { : 
strstr : while : 		if (p->policy == SCHED_IDLE && policy != SCHED_IDLE) { : 
str : 			if (!can_nice(p, TASK_NICE(p)))
strstr : INIT : 			if (!can_nice(p, TASK_NICE(p))) : 
strstr : if : 			if (!can_nice(p, TASK_NICE(p))) : 
strstr : for : 			if (!can_nice(p, TASK_NICE(p))) : 
strstr : while : 			if (!can_nice(p, TASK_NICE(p))) : 
str : 				return -EPERM;
strstr : INIT : 				return -EPERM; : 
strstr : if : 				return -EPERM; : 
strstr : for : 				return -EPERM; : 
strstr : while : 				return -EPERM; : 
str : 		}
strstr : INIT : 		} : 
strstr : if : 		} : 
strstr : for : 		} : 
strstr : while : 		} : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 		/* can't change other user's priorities */
strstr : if : 		/* can't change other user's priorities */ : 
strstr : for : 		/* can't change other user's priorities */ : 
strstr : while : 		/* can't change other user's priorities */ : 
str : 		if (!check_same_owner(p))
strstr : INIT : 		if (!check_same_owner(p)) : 
strstr : if : 		if (!check_same_owner(p)) : 
strstr : for : 		if (!check_same_owner(p)) : 
strstr : while : 		if (!check_same_owner(p)) : 
str : 			return -EPERM;
strstr : INIT : 			return -EPERM; : 
strstr : if : 			return -EPERM; : 
strstr : for : 			return -EPERM; : 
strstr : while : 			return -EPERM; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 		/* Normal users shall not reset the sched_reset_on_fork flag */
strstr : if : 		/* Normal users shall not reset the sched_reset_on_fork flag */ : 
strstr : for : 		/* Normal users shall not reset the sched_reset_on_fork flag */ : 
strstr : while : 		/* Normal users shall not reset the sched_reset_on_fork flag */ : 
str : 		if (p->sched_reset_on_fork && !reset_on_fork)
strstr : INIT : 		if (p->sched_reset_on_fork && !reset_on_fork) : 
strstr : if : 		if (p->sched_reset_on_fork && !reset_on_fork) : 
strstr : for : 		if (p->sched_reset_on_fork && !reset_on_fork) : 
strstr : while : 		if (p->sched_reset_on_fork && !reset_on_fork) : 
str : 			return -EPERM;
strstr : INIT : 			return -EPERM; : 
strstr : if : 			return -EPERM; : 
strstr : for : 			return -EPERM; : 
strstr : while : 			return -EPERM; : 
str : 	}
strstr : INIT : 	} : 
strstr : if : 	} : 
strstr : for : 	} : 
strstr : while : 	} : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	if (user) {
strstr : if : 	if (user) { : 
strstr : for : 	if (user) { : 
strstr : while : 	if (user) { : 
str : 		retval = security_task_setscheduler(p);
strstr : INIT : 		retval = security_task_setscheduler(p); : 
strstr : if : 		retval = security_task_setscheduler(p); : 
strstr : for : 		retval = security_task_setscheduler(p); : 
strstr : while : 		retval = security_task_setscheduler(p); : 
str : 		if (retval)
strstr : INIT : 		if (retval) : 
strstr : if : 		if (retval) : 
strstr : for : 		if (retval) : 
strstr : while : 		if (retval) : 
str : 			return retval;
strstr : INIT : 			return retval; : 
strstr : if : 			return retval; : 
strstr : for : 			return retval; : 
strstr : while : 			return retval; : 
str : 	}
strstr : INIT : 	} : 
strstr : if : 	} : 
strstr : for : 	} : 
strstr : while : 	} : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	/*
strstr : if : 	/* : 
strstr : for : 	/* : 
strstr : while : 	/* : 
str : 	 * make sure no PI-waiters arrive (or leave) while we are
strstr : INIT : 	 * make sure no PI-waiters arrive (or leave) while we are : 
strstr : if : 	 * make sure no PI-waiters arrive (or leave) while we are : 
strstr : for : 	 * make sure no PI-waiters arrive (or leave) while we are : 
strstr : while : 	 * make sure no PI-waiters arrive (or leave) while we are : 
str : 	 * changing the priority of the task:
strstr : INIT : 	 * changing the priority of the task: : 
strstr : if : 	 * changing the priority of the task: : 
strstr : for : 	 * changing the priority of the task: : 
strstr : while : 	 * changing the priority of the task: : 
str : 	 *
strstr : INIT : 	 * : 
strstr : if : 	 * : 
strstr : for : 	 * : 
strstr : while : 	 * : 
str : 	 * To be able to change p->policy safely, the appropriate
strstr : INIT : 	 * To be able to change p->policy safely, the appropriate : 
strstr : if : 	 * To be able to change p->policy safely, the appropriate : 
strstr : for : 	 * To be able to change p->policy safely, the appropriate : 
strstr : while : 	 * To be able to change p->policy safely, the appropriate : 
str : 	 * runqueue lock must be held.
strstr : INIT : 	 * runqueue lock must be held. : 
strstr : if : 	 * runqueue lock must be held. : 
strstr : for : 	 * runqueue lock must be held. : 
strstr : while : 	 * runqueue lock must be held. : 
str : 	 */
strstr : INIT : 	 */ : 
strstr : if : 	 */ : 
strstr : for : 	 */ : 
strstr : while : 	 */ : 
str : 	rq = task_rq_lock(p, &flags);
strstr : INIT : 	rq = task_rq_lock(p, &flags); : 
strstr : if : 	rq = task_rq_lock(p, &flags); : 
strstr : for : 	rq = task_rq_lock(p, &flags); : 
strstr : while : 	rq = task_rq_lock(p, &flags); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	/*
strstr : if : 	/* : 
strstr : for : 	/* : 
strstr : while : 	/* : 
str : 	 * Changing the policy of the stop threads its a very bad idea
strstr : INIT : 	 * Changing the policy of the stop threads its a very bad idea : 
strstr : if : 	 * Changing the policy of the stop threads its a very bad idea : 
strstr : for : 	 * Changing the policy of the stop threads its a very bad idea : 
strstr : while : 	 * Changing the policy of the stop threads its a very bad idea : 
str : 	 */
strstr : INIT : 	 */ : 
strstr : if : 	 */ : 
strstr : for : 	 */ : 
strstr : while : 	 */ : 
str : 	if (p == rq->stop) {
strstr : INIT : 	if (p == rq->stop) { : 
strstr : if : 	if (p == rq->stop) { : 
strstr : for : 	if (p == rq->stop) { : 
strstr : while : 	if (p == rq->stop) { : 
str : 		task_rq_unlock(rq, p, &flags);
strstr : INIT : 		task_rq_unlock(rq, p, &flags); : 
strstr : if : 		task_rq_unlock(rq, p, &flags); : 
strstr : for : 		task_rq_unlock(rq, p, &flags); : 
strstr : while : 		task_rq_unlock(rq, p, &flags); : 
str : 		return -EINVAL;
strstr : INIT : 		return -EINVAL; : 
strstr : if : 		return -EINVAL; : 
strstr : for : 		return -EINVAL; : 
strstr : while : 		return -EINVAL; : 
str : 	}
strstr : INIT : 	} : 
strstr : if : 	} : 
strstr : for : 	} : 
strstr : while : 	} : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	/*
strstr : if : 	/* : 
strstr : for : 	/* : 
strstr : while : 	/* : 
str : 	 * If not changing anything there's no need to proceed further:
strstr : INIT : 	 * If not changing anything there's no need to proceed further: : 
strstr : if : 	 * If not changing anything there's no need to proceed further: : 
strstr : for : 	 * If not changing anything there's no need to proceed further: : 
strstr : while : 	 * If not changing anything there's no need to proceed further: : 
str : 	 */
strstr : INIT : 	 */ : 
strstr : if : 	 */ : 
strstr : for : 	 */ : 
strstr : while : 	 */ : 
str : 	if (unlikely(policy == p->policy)) {
strstr : INIT : 	if (unlikely(policy == p->policy)) { : 
strstr : if : 	if (unlikely(policy == p->policy)) { : 
strstr : for : 	if (unlikely(policy == p->policy)) { : 
strstr : while : 	if (unlikely(policy == p->policy)) { : 
str : 		if (fair_policy(policy) && attr->sched_nice != TASK_NICE(p))
strstr : INIT : 		if (fair_policy(policy) && attr->sched_nice != TASK_NICE(p)) : 
strstr : if : 		if (fair_policy(policy) && attr->sched_nice != TASK_NICE(p)) : 
strstr : for : 		if (fair_policy(policy) && attr->sched_nice != TASK_NICE(p)) : 
strstr : while : 		if (fair_policy(policy) && attr->sched_nice != TASK_NICE(p)) : 
str : 			goto change;
strstr : INIT : 			goto change; : 
strstr : if : 			goto change; : 
strstr : for : 			goto change; : 
strstr : while : 			goto change; : 
str : 		if (rt_policy(policy) && attr->sched_priority != p->rt_priority)
strstr : INIT : 		if (rt_policy(policy) && attr->sched_priority != p->rt_priority) : 
strstr : if : 		if (rt_policy(policy) && attr->sched_priority != p->rt_priority) : 
strstr : for : 		if (rt_policy(policy) && attr->sched_priority != p->rt_priority) : 
strstr : while : 		if (rt_policy(policy) && attr->sched_priority != p->rt_priority) : 
str : 			goto change;
strstr : INIT : 			goto change; : 
strstr : if : 			goto change; : 
strstr : for : 			goto change; : 
strstr : while : 			goto change; : 
str : 		if (dl_policy(policy))
strstr : INIT : 		if (dl_policy(policy)) : 
strstr : if : 		if (dl_policy(policy)) : 
strstr : for : 		if (dl_policy(policy)) : 
strstr : while : 		if (dl_policy(policy)) : 
str : 			goto change;
strstr : INIT : 			goto change; : 
strstr : if : 			goto change; : 
strstr : for : 			goto change; : 
strstr : while : 			goto change; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 		task_rq_unlock(rq, p, &flags);
strstr : if : 		task_rq_unlock(rq, p, &flags); : 
strstr : for : 		task_rq_unlock(rq, p, &flags); : 
strstr : while : 		task_rq_unlock(rq, p, &flags); : 
str : 		return 0;
strstr : INIT : 		return 0; : 
strstr : if : 		return 0; : 
strstr : for : 		return 0; : 
strstr : while : 		return 0; : 
str : 	}
strstr : INIT : 	} : 
strstr : if : 	} : 
strstr : for : 	} : 
strstr : while : 	} : 
str : change:
strstr : INIT : change: : 
strstr : if : change: : 
strstr : for : change: : 
strstr : while : change: : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	if (user) {
strstr : if : 	if (user) { : 
strstr : for : 	if (user) { : 
strstr : while : 	if (user) { : 
str : #ifdef CONFIG_RT_GROUP_SCHED
strstr : INIT : #ifdef CONFIG_RT_GROUP_SCHED : 
strstr : if : #ifdef CONFIG_RT_GROUP_SCHED : 
strstr : for : #ifdef CONFIG_RT_GROUP_SCHED : 
strstr : while : #ifdef CONFIG_RT_GROUP_SCHED : 
str : 		/*
strstr : INIT : 		/* : 
strstr : if : 		/* : 
strstr : for : 		/* : 
strstr : while : 		/* : 
str : 		 * Do not allow realtime tasks into groups that have no runtime
strstr : INIT : 		 * Do not allow realtime tasks into groups that have no runtime : 
strstr : if : 		 * Do not allow realtime tasks into groups that have no runtime : 
strstr : for : 		 * Do not allow realtime tasks into groups that have no runtime : 
strstr : while : 		 * Do not allow realtime tasks into groups that have no runtime : 
str : 		 * assigned.
strstr : INIT : 		 * assigned. : 
strstr : if : 		 * assigned. : 
strstr : for : 		 * assigned. : 
strstr : while : 		 * assigned. : 
str : 		 */
strstr : INIT : 		 */ : 
strstr : if : 		 */ : 
strstr : for : 		 */ : 
strstr : while : 		 */ : 
str : 		if (rt_bandwidth_enabled() && rt_policy(policy) &&
strstr : INIT : 		if (rt_bandwidth_enabled() && rt_policy(policy) && : 
strstr : if : 		if (rt_bandwidth_enabled() && rt_policy(policy) && : 
strstr : for : 		if (rt_bandwidth_enabled() && rt_policy(policy) && : 
strstr : while : 		if (rt_bandwidth_enabled() && rt_policy(policy) && : 
str : 				task_group(p)->rt_bandwidth.rt_runtime == 0 &&
strstr : INIT : 				task_group(p)->rt_bandwidth.rt_runtime == 0 && : 
strstr : if : 				task_group(p)->rt_bandwidth.rt_runtime == 0 && : 
strstr : for : 				task_group(p)->rt_bandwidth.rt_runtime == 0 && : 
strstr : while : 				task_group(p)->rt_bandwidth.rt_runtime == 0 && : 
str : 				!task_group_is_autogroup(task_group(p))) {
strstr : INIT : 				!task_group_is_autogroup(task_group(p))) { : 
strstr : if : 				!task_group_is_autogroup(task_group(p))) { : 
strstr : for : 				!task_group_is_autogroup(task_group(p))) { : 
strstr : while : 				!task_group_is_autogroup(task_group(p))) { : 
str : 			task_rq_unlock(rq, p, &flags);
strstr : INIT : 			task_rq_unlock(rq, p, &flags); : 
strstr : if : 			task_rq_unlock(rq, p, &flags); : 
strstr : for : 			task_rq_unlock(rq, p, &flags); : 
strstr : while : 			task_rq_unlock(rq, p, &flags); : 
str : 			return -EPERM;
strstr : INIT : 			return -EPERM; : 
strstr : if : 			return -EPERM; : 
strstr : for : 			return -EPERM; : 
strstr : while : 			return -EPERM; : 
str : 		}
strstr : INIT : 		} : 
strstr : if : 		} : 
strstr : for : 		} : 
strstr : while : 		} : 
str : #endif
strstr : INIT : #endif : 
strstr : if : #endif : 
strstr : for : #endif : 
strstr : while : #endif : 
str : #ifdef CONFIG_SMP
strstr : INIT : #ifdef CONFIG_SMP : 
strstr : if : #ifdef CONFIG_SMP : 
strstr : for : #ifdef CONFIG_SMP : 
strstr : while : #ifdef CONFIG_SMP : 
str : 		if (dl_bandwidth_enabled() && dl_policy(policy)) {
strstr : INIT : 		if (dl_bandwidth_enabled() && dl_policy(policy)) { : 
strstr : if : 		if (dl_bandwidth_enabled() && dl_policy(policy)) { : 
strstr : for : 		if (dl_bandwidth_enabled() && dl_policy(policy)) { : 
strstr : while : 		if (dl_bandwidth_enabled() && dl_policy(policy)) { : 
str : 			cpumask_t *span = rq->rd->span;
strstr : INIT : 			cpumask_t *span = rq->rd->span; : 
strstr : if : 			cpumask_t *span = rq->rd->span; : 
strstr : for : 			cpumask_t *span = rq->rd->span; : 
strstr : while : 			cpumask_t *span = rq->rd->span; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 			/*
strstr : if : 			/* : 
strstr : for : 			/* : 
strstr : while : 			/* : 
str : 			 * Don't allow tasks with an affinity mask smaller than
strstr : INIT : 			 * Don't allow tasks with an affinity mask smaller than : 
strstr : if : 			 * Don't allow tasks with an affinity mask smaller than : 
strstr : for : 			 * Don't allow tasks with an affinity mask smaller than : 
strstr : while : 			 * Don't allow tasks with an affinity mask smaller than : 
str : 			 * the entire root_domain to become SCHED_DEADLINE. We
strstr : INIT : 			 * the entire root_domain to become SCHED_DEADLINE. We : 
strstr : if : 			 * the entire root_domain to become SCHED_DEADLINE. We : 
strstr : for : 			 * the entire root_domain to become SCHED_DEADLINE. We : 
strstr : while : 			 * the entire root_domain to become SCHED_DEADLINE. We : 
str : 			 * will also fail if there's no bandwidth available.
strstr : INIT : 			 * will also fail if there's no bandwidth available. : 
strstr : if : 			 * will also fail if there's no bandwidth available. : 
strstr : for : 			 * will also fail if there's no bandwidth available. : 
strstr : while : 			 * will also fail if there's no bandwidth available. : 
str : 			 */
strstr : INIT : 			 */ : 
strstr : if : 			 */ : 
strstr : for : 			 */ : 
strstr : while : 			 */ : 
str : 			if (!cpumask_subset(span, &p->cpus_allowed) ||
strstr : INIT : 			if (!cpumask_subset(span, &p->cpus_allowed) || : 
strstr : if : 			if (!cpumask_subset(span, &p->cpus_allowed) || : 
strstr : for : 			if (!cpumask_subset(span, &p->cpus_allowed) || : 
strstr : while : 			if (!cpumask_subset(span, &p->cpus_allowed) || : 
str : 			    rq->rd->dl_bw.bw == 0) {
strstr : INIT : 			    rq->rd->dl_bw.bw == 0) { : 
strstr : if : 			    rq->rd->dl_bw.bw == 0) { : 
strstr : for : 			    rq->rd->dl_bw.bw == 0) { : 
strstr : while : 			    rq->rd->dl_bw.bw == 0) { : 
str : 				task_rq_unlock(rq, p, &flags);
strstr : INIT : 				task_rq_unlock(rq, p, &flags); : 
strstr : if : 				task_rq_unlock(rq, p, &flags); : 
strstr : for : 				task_rq_unlock(rq, p, &flags); : 
strstr : while : 				task_rq_unlock(rq, p, &flags); : 
str : 				return -EPERM;
strstr : INIT : 				return -EPERM; : 
strstr : if : 				return -EPERM; : 
strstr : for : 				return -EPERM; : 
strstr : while : 				return -EPERM; : 
str : 			}
strstr : INIT : 			} : 
strstr : if : 			} : 
strstr : for : 			} : 
strstr : while : 			} : 
str : 		}
strstr : INIT : 		} : 
strstr : if : 		} : 
strstr : for : 		} : 
strstr : while : 		} : 
str : #endif
strstr : INIT : #endif : 
strstr : if : #endif : 
strstr : for : #endif : 
strstr : while : #endif : 
str : 	}
strstr : INIT : 	} : 
strstr : if : 	} : 
strstr : for : 	} : 
strstr : while : 	} : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	/* recheck policy now with rq lock held */
strstr : if : 	/* recheck policy now with rq lock held */ : 
strstr : for : 	/* recheck policy now with rq lock held */ : 
strstr : while : 	/* recheck policy now with rq lock held */ : 
str : 	if (unlikely(oldpolicy != -1 && oldpolicy != p->policy)) {
strstr : INIT : 	if (unlikely(oldpolicy != -1 && oldpolicy != p->policy)) { : 
strstr : if : 	if (unlikely(oldpolicy != -1 && oldpolicy != p->policy)) { : 
strstr : for : 	if (unlikely(oldpolicy != -1 && oldpolicy != p->policy)) { : 
strstr : while : 	if (unlikely(oldpolicy != -1 && oldpolicy != p->policy)) { : 
str : 		policy = oldpolicy = -1;
strstr : INIT : 		policy = oldpolicy = -1; : 
strstr : if : 		policy = oldpolicy = -1; : 
strstr : for : 		policy = oldpolicy = -1; : 
strstr : while : 		policy = oldpolicy = -1; : 
str : 		task_rq_unlock(rq, p, &flags);
strstr : INIT : 		task_rq_unlock(rq, p, &flags); : 
strstr : if : 		task_rq_unlock(rq, p, &flags); : 
strstr : for : 		task_rq_unlock(rq, p, &flags); : 
strstr : while : 		task_rq_unlock(rq, p, &flags); : 
str : 		goto recheck;
strstr : INIT : 		goto recheck; : 
strstr : if : 		goto recheck; : 
strstr : for : 		goto recheck; : 
strstr : while : 		goto recheck; : 
str : 	}
strstr : INIT : 	} : 
strstr : if : 	} : 
strstr : for : 	} : 
strstr : while : 	} : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	/*
strstr : if : 	/* : 
strstr : for : 	/* : 
strstr : while : 	/* : 
str : 	 * If setscheduling to SCHED_DEADLINE (or changing the parameters
strstr : INIT : 	 * If setscheduling to SCHED_DEADLINE (or changing the parameters : 
strstr : if : 	 * If setscheduling to SCHED_DEADLINE (or changing the parameters : 
strstr : for : 	 * If setscheduling to SCHED_DEADLINE (or changing the parameters : 
strstr : while : 	 * If setscheduling to SCHED_DEADLINE (or changing the parameters : 
str : 	 * of a SCHED_DEADLINE task) we need to check if enough bandwidth
strstr : INIT : 	 * of a SCHED_DEADLINE task) we need to check if enough bandwidth : 
strstr : if : 	 * of a SCHED_DEADLINE task) we need to check if enough bandwidth : 
strstr : for : 	 * of a SCHED_DEADLINE task) we need to check if enough bandwidth : 
strstr : while : 	 * of a SCHED_DEADLINE task) we need to check if enough bandwidth : 
str : 	 * is available.
strstr : INIT : 	 * is available. : 
strstr : if : 	 * is available. : 
strstr : for : 	 * is available. : 
strstr : while : 	 * is available. : 
str : 	 */
strstr : INIT : 	 */ : 
strstr : if : 	 */ : 
strstr : for : 	 */ : 
strstr : while : 	 */ : 
str : 	if ((dl_policy(policy) || dl_task(p)) && dl_overflow(p, policy, attr)) {
strstr : INIT : 	if ((dl_policy(policy) || dl_task(p)) && dl_overflow(p, policy, attr)) { : 
strstr : if : 	if ((dl_policy(policy) || dl_task(p)) && dl_overflow(p, policy, attr)) { : 
strstr : for : 	if ((dl_policy(policy) || dl_task(p)) && dl_overflow(p, policy, attr)) { : 
strstr : while : 	if ((dl_policy(policy) || dl_task(p)) && dl_overflow(p, policy, attr)) { : 
str : 		task_rq_unlock(rq, p, &flags);
strstr : INIT : 		task_rq_unlock(rq, p, &flags); : 
strstr : if : 		task_rq_unlock(rq, p, &flags); : 
strstr : for : 		task_rq_unlock(rq, p, &flags); : 
strstr : while : 		task_rq_unlock(rq, p, &flags); : 
str : 		return -EBUSY;
strstr : INIT : 		return -EBUSY; : 
strstr : if : 		return -EBUSY; : 
strstr : for : 		return -EBUSY; : 
strstr : while : 		return -EBUSY; : 
str : 	}
strstr : INIT : 	} : 
strstr : if : 	} : 
strstr : for : 	} : 
strstr : while : 	} : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	on_rq = p->on_rq;
strstr : if : 	on_rq = p->on_rq; : 
strstr : for : 	on_rq = p->on_rq; : 
strstr : while : 	on_rq = p->on_rq; : 
str : 	running = task_current(rq, p);
strstr : INIT : 	running = task_current(rq, p); : 
strstr : if : 	running = task_current(rq, p); : 
strstr : for : 	running = task_current(rq, p); : 
strstr : while : 	running = task_current(rq, p); : 
str : 	if (on_rq)
strstr : INIT : 	if (on_rq) : 
strstr : if : 	if (on_rq) : 
strstr : for : 	if (on_rq) : 
strstr : while : 	if (on_rq) : 
str : 		dequeue_task(rq, p, 0);
strstr : INIT : 		dequeue_task(rq, p, 0); : 
strstr : if : 		dequeue_task(rq, p, 0); : 
strstr : for : 		dequeue_task(rq, p, 0); : 
strstr : while : 		dequeue_task(rq, p, 0); : 
str : 	if (running)
strstr : INIT : 	if (running) : 
strstr : if : 	if (running) : 
strstr : for : 	if (running) : 
strstr : while : 	if (running) : 
str : 		p->sched_class->put_prev_task(rq, p);
strstr : INIT : 		p->sched_class->put_prev_task(rq, p); : 
strstr : if : 		p->sched_class->put_prev_task(rq, p); : 
strstr : for : 		p->sched_class->put_prev_task(rq, p); : 
strstr : while : 		p->sched_class->put_prev_task(rq, p); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	p->sched_reset_on_fork = reset_on_fork;
strstr : if : 	p->sched_reset_on_fork = reset_on_fork; : 
strstr : for : 	p->sched_reset_on_fork = reset_on_fork; : 
strstr : while : 	p->sched_reset_on_fork = reset_on_fork; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	oldprio = p->prio;
strstr : if : 	oldprio = p->prio; : 
strstr : for : 	oldprio = p->prio; : 
strstr : while : 	oldprio = p->prio; : 
str : 	prev_class = p->sched_class;
strstr : INIT : 	prev_class = p->sched_class; : 
strstr : if : 	prev_class = p->sched_class; : 
strstr : for : 	prev_class = p->sched_class; : 
strstr : while : 	prev_class = p->sched_class; : 
str : 	__setscheduler(rq, p, attr);
strstr : INIT : 	__setscheduler(rq, p, attr); : 
strstr : if : 	__setscheduler(rq, p, attr); : 
strstr : for : 	__setscheduler(rq, p, attr); : 
strstr : while : 	__setscheduler(rq, p, attr); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	if (running)
strstr : if : 	if (running) : 
strstr : for : 	if (running) : 
strstr : while : 	if (running) : 
str : 		p->sched_class->set_curr_task(rq);
strstr : INIT : 		p->sched_class->set_curr_task(rq); : 
strstr : if : 		p->sched_class->set_curr_task(rq); : 
strstr : for : 		p->sched_class->set_curr_task(rq); : 
strstr : while : 		p->sched_class->set_curr_task(rq); : 
str : 	if (on_rq)
strstr : INIT : 	if (on_rq) : 
strstr : if : 	if (on_rq) : 
strstr : for : 	if (on_rq) : 
strstr : while : 	if (on_rq) : 
str : 		enqueue_task(rq, p, 0);
strstr : INIT : 		enqueue_task(rq, p, 0); : 
strstr : if : 		enqueue_task(rq, p, 0); : 
strstr : for : 		enqueue_task(rq, p, 0); : 
strstr : while : 		enqueue_task(rq, p, 0); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	check_class_changed(rq, p, prev_class, oldprio);
strstr : if : 	check_class_changed(rq, p, prev_class, oldprio); : 
strstr : for : 	check_class_changed(rq, p, prev_class, oldprio); : 
strstr : while : 	check_class_changed(rq, p, prev_class, oldprio); : 
str : 	task_rq_unlock(rq, p, &flags);
strstr : INIT : 	task_rq_unlock(rq, p, &flags); : 
strstr : if : 	task_rq_unlock(rq, p, &flags); : 
strstr : for : 	task_rq_unlock(rq, p, &flags); : 
strstr : while : 	task_rq_unlock(rq, p, &flags); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	rt_mutex_adjust_pi(p);
strstr : if : 	rt_mutex_adjust_pi(p); : 
strstr : for : 	rt_mutex_adjust_pi(p); : 
strstr : while : 	rt_mutex_adjust_pi(p); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	return 0;
strstr : if : 	return 0; : 
strstr : for : 	return 0; : 
strstr : while : 	return 0; : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : static int _sched_setscheduler(struct task_struct *p, int policy,
strstr : if : static int _sched_setscheduler(struct task_struct *p, int policy, : 
strstr : for : static int _sched_setscheduler(struct task_struct *p, int policy, : 
strstr : while : static int _sched_setscheduler(struct task_struct *p, int policy, : 
str : 			       const struct sched_param *param, bool check)
strstr : INIT : 			       const struct sched_param *param, bool check) : 
strstr : if : 			       const struct sched_param *param, bool check) : 
strstr : for : 			       const struct sched_param *param, bool check) : 
strstr : while : 			       const struct sched_param *param, bool check) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	struct sched_attr attr = {
strstr : INIT : 	struct sched_attr attr = { : 
strstr : if : 	struct sched_attr attr = { : 
strstr : for : 	struct sched_attr attr = { : 
strstr : while : 	struct sched_attr attr = { : 
str : 		.sched_policy   = policy,
strstr : INIT : 		.sched_policy   = policy, : 
strstr : if : 		.sched_policy   = policy, : 
strstr : for : 		.sched_policy   = policy, : 
strstr : while : 		.sched_policy   = policy, : 
str : 		.sched_priority = param->sched_priority,
strstr : INIT : 		.sched_priority = param->sched_priority, : 
strstr : if : 		.sched_priority = param->sched_priority, : 
strstr : for : 		.sched_priority = param->sched_priority, : 
strstr : while : 		.sched_priority = param->sched_priority, : 
str : 		.sched_nice	= PRIO_TO_NICE(p->static_prio),
strstr : INIT : 		.sched_nice	= PRIO_TO_NICE(p->static_prio), : 
strstr : if : 		.sched_nice	= PRIO_TO_NICE(p->static_prio), : 
strstr : for : 		.sched_nice	= PRIO_TO_NICE(p->static_prio), : 
strstr : while : 		.sched_nice	= PRIO_TO_NICE(p->static_prio), : 
str : 	};
strstr : INIT : 	}; : 
strstr : if : 	}; : 
strstr : for : 	}; : 
strstr : while : 	}; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	/*
strstr : if : 	/* : 
strstr : for : 	/* : 
strstr : while : 	/* : 
str : 	 * Fixup the legacy SCHED_RESET_ON_FORK hack
strstr : INIT : 	 * Fixup the legacy SCHED_RESET_ON_FORK hack : 
strstr : if : 	 * Fixup the legacy SCHED_RESET_ON_FORK hack : 
strstr : for : 	 * Fixup the legacy SCHED_RESET_ON_FORK hack : 
strstr : while : 	 * Fixup the legacy SCHED_RESET_ON_FORK hack : 
str : 	 */
strstr : INIT : 	 */ : 
strstr : if : 	 */ : 
strstr : for : 	 */ : 
strstr : while : 	 */ : 
str : 	if (policy & SCHED_RESET_ON_FORK) {
strstr : INIT : 	if (policy & SCHED_RESET_ON_FORK) { : 
strstr : if : 	if (policy & SCHED_RESET_ON_FORK) { : 
strstr : for : 	if (policy & SCHED_RESET_ON_FORK) { : 
strstr : while : 	if (policy & SCHED_RESET_ON_FORK) { : 
str : 		attr.sched_flags |= SCHED_FLAG_RESET_ON_FORK;
strstr : INIT : 		attr.sched_flags |= SCHED_FLAG_RESET_ON_FORK; : 
strstr : if : 		attr.sched_flags |= SCHED_FLAG_RESET_ON_FORK; : 
strstr : for : 		attr.sched_flags |= SCHED_FLAG_RESET_ON_FORK; : 
strstr : while : 		attr.sched_flags |= SCHED_FLAG_RESET_ON_FORK; : 
str : 		policy &= ~SCHED_RESET_ON_FORK;
strstr : INIT : 		policy &= ~SCHED_RESET_ON_FORK; : 
strstr : if : 		policy &= ~SCHED_RESET_ON_FORK; : 
strstr : for : 		policy &= ~SCHED_RESET_ON_FORK; : 
strstr : while : 		policy &= ~SCHED_RESET_ON_FORK; : 
str : 		attr.sched_policy = policy;
strstr : INIT : 		attr.sched_policy = policy; : 
strstr : if : 		attr.sched_policy = policy; : 
strstr : for : 		attr.sched_policy = policy; : 
strstr : while : 		attr.sched_policy = policy; : 
str : 	}
strstr : INIT : 	} : 
strstr : if : 	} : 
strstr : for : 	} : 
strstr : while : 	} : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	return __sched_setscheduler(p, &attr, check);
strstr : if : 	return __sched_setscheduler(p, &attr, check); : 
strstr : for : 	return __sched_setscheduler(p, &attr, check); : 
strstr : while : 	return __sched_setscheduler(p, &attr, check); : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : /**
strstr : INIT : /** : 
strstr : if : /** : 
strstr : for : /** : 
strstr : while : /** : 
str :  * sched_setscheduler - change the scheduling policy and/or RT priority of a thread.
strstr : INIT :  * sched_setscheduler - change the scheduling policy and/or RT priority of a thread. : 
strstr : if :  * sched_setscheduler - change the scheduling policy and/or RT priority of a thread. : 
strstr : for :  * sched_setscheduler - change the scheduling policy and/or RT priority of a thread. : 
strstr : while :  * sched_setscheduler - change the scheduling policy and/or RT priority of a thread. : 
str :  * @p: the task in question.
strstr : INIT :  * @p: the task in question. : 
strstr : if :  * @p: the task in question. : 
strstr : for :  * @p: the task in question. : 
strstr : while :  * @p: the task in question. : 
str :  * @policy: new policy.
strstr : INIT :  * @policy: new policy. : 
strstr : if :  * @policy: new policy. : 
strstr : for :  * @policy: new policy. : 
strstr : while :  * @policy: new policy. : 
str :  * @param: structure containing the new RT priority.
strstr : INIT :  * @param: structure containing the new RT priority. : 
strstr : if :  * @param: structure containing the new RT priority. : 
strstr : for :  * @param: structure containing the new RT priority. : 
strstr : while :  * @param: structure containing the new RT priority. : 
str :  *
strstr : INIT :  * : 
strstr : if :  * : 
strstr : for :  * : 
strstr : while :  * : 
str :  * Return: 0 on success. An error code otherwise.
strstr : INIT :  * Return: 0 on success. An error code otherwise. : 
strstr : if :  * Return: 0 on success. An error code otherwise. : 
strstr : for :  * Return: 0 on success. An error code otherwise. : 
strstr : while :  * Return: 0 on success. An error code otherwise. : 
str :  *
strstr : INIT :  * : 
strstr : if :  * : 
strstr : for :  * : 
strstr : while :  * : 
str :  * NOTE that the task may be already dead.
strstr : INIT :  * NOTE that the task may be already dead. : 
strstr : if :  * NOTE that the task may be already dead. : 
strstr : for :  * NOTE that the task may be already dead. : 
strstr : while :  * NOTE that the task may be already dead. : 
str :  */
strstr : INIT :  */ : 
strstr : if :  */ : 
strstr : for :  */ : 
strstr : while :  */ : 
str : int sched_setscheduler(struct task_struct *p, int policy,
strstr : INIT : int sched_setscheduler(struct task_struct *p, int policy, : 
strstr : if : int sched_setscheduler(struct task_struct *p, int policy, : 
strstr : for : int sched_setscheduler(struct task_struct *p, int policy, : 
strstr : while : int sched_setscheduler(struct task_struct *p, int policy, : 
str : 		       const struct sched_param *param)
strstr : INIT : 		       const struct sched_param *param) : 
strstr : if : 		       const struct sched_param *param) : 
strstr : for : 		       const struct sched_param *param) : 
strstr : while : 		       const struct sched_param *param) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	return _sched_setscheduler(p, policy, param, true);
strstr : INIT : 	return _sched_setscheduler(p, policy, param, true); : 
strstr : if : 	return _sched_setscheduler(p, policy, param, true); : 
strstr : for : 	return _sched_setscheduler(p, policy, param, true); : 
strstr : while : 	return _sched_setscheduler(p, policy, param, true); : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : EXPORT_SYMBOL_GPL(sched_setscheduler);
strstr : INIT : EXPORT_SYMBOL_GPL(sched_setscheduler); : 
strstr : if : EXPORT_SYMBOL_GPL(sched_setscheduler); : 
strstr : for : EXPORT_SYMBOL_GPL(sched_setscheduler); : 
strstr : while : EXPORT_SYMBOL_GPL(sched_setscheduler); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : int sched_setattr(struct task_struct *p, const struct sched_attr *attr)
strstr : if : int sched_setattr(struct task_struct *p, const struct sched_attr *attr) : 
strstr : for : int sched_setattr(struct task_struct *p, const struct sched_attr *attr) : 
strstr : while : int sched_setattr(struct task_struct *p, const struct sched_attr *attr) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	return __sched_setscheduler(p, attr, true);
strstr : INIT : 	return __sched_setscheduler(p, attr, true); : 
strstr : if : 	return __sched_setscheduler(p, attr, true); : 
strstr : for : 	return __sched_setscheduler(p, attr, true); : 
strstr : while : 	return __sched_setscheduler(p, attr, true); : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : EXPORT_SYMBOL_GPL(sched_setattr);
strstr : INIT : EXPORT_SYMBOL_GPL(sched_setattr); : 
strstr : if : EXPORT_SYMBOL_GPL(sched_setattr); : 
strstr : for : EXPORT_SYMBOL_GPL(sched_setattr); : 
strstr : while : EXPORT_SYMBOL_GPL(sched_setattr); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : /**
strstr : if : /** : 
strstr : for : /** : 
strstr : while : /** : 
str :  * sched_setscheduler_nocheck - change the scheduling policy and/or RT priority of a thread from kernelspace.
strstr : INIT :  * sched_setscheduler_nocheck - change the scheduling policy and/or RT priority of a thread from kernelspace. : 
strstr : if :  * sched_setscheduler_nocheck - change the scheduling policy and/or RT priority of a thread from kernelspace. : 
strstr : for :  * sched_setscheduler_nocheck - change the scheduling policy and/or RT priority of a thread from kernelspace. : 
strstr : while :  * sched_setscheduler_nocheck - change the scheduling policy and/or RT priority of a thread from kernelspace. : 
str :  * @p: the task in question.
strstr : INIT :  * @p: the task in question. : 
strstr : if :  * @p: the task in question. : 
strstr : for :  * @p: the task in question. : 
strstr : while :  * @p: the task in question. : 
str :  * @policy: new policy.
strstr : INIT :  * @policy: new policy. : 
strstr : if :  * @policy: new policy. : 
strstr : for :  * @policy: new policy. : 
strstr : while :  * @policy: new policy. : 
str :  * @param: structure containing the new RT priority.
strstr : INIT :  * @param: structure containing the new RT priority. : 
strstr : if :  * @param: structure containing the new RT priority. : 
strstr : for :  * @param: structure containing the new RT priority. : 
strstr : while :  * @param: structure containing the new RT priority. : 
str :  *
strstr : INIT :  * : 
strstr : if :  * : 
strstr : for :  * : 
strstr : while :  * : 
str :  * Just like sched_setscheduler, only don't bother checking if the
strstr : INIT :  * Just like sched_setscheduler, only don't bother checking if the : 
strstr : if :  * Just like sched_setscheduler, only don't bother checking if the : 
strstr : for :  * Just like sched_setscheduler, only don't bother checking if the : 
strstr : while :  * Just like sched_setscheduler, only don't bother checking if the : 
str :  * current context has permission.  For example, this is needed in
strstr : INIT :  * current context has permission.  For example, this is needed in : 
strstr : if :  * current context has permission.  For example, this is needed in : 
strstr : for :  * current context has permission.  For example, this is needed in : 
strstr : while :  * current context has permission.  For example, this is needed in : 
str :  * stop_machine(): we create temporary high priority worker threads,
strstr : INIT :  * stop_machine(): we create temporary high priority worker threads, : 
strstr : if :  * stop_machine(): we create temporary high priority worker threads, : 
strstr : for :  * stop_machine(): we create temporary high priority worker threads, : 
strstr : while :  * stop_machine(): we create temporary high priority worker threads, : 
str :  * but our caller might not have that capability.
strstr : INIT :  * but our caller might not have that capability. : 
strstr : if :  * but our caller might not have that capability. : 
strstr : for :  * but our caller might not have that capability. : 
strstr : while :  * but our caller might not have that capability. : 
str :  *
strstr : INIT :  * : 
strstr : if :  * : 
strstr : for :  * : 
strstr : while :  * : 
str :  * Return: 0 on success. An error code otherwise.
strstr : INIT :  * Return: 0 on success. An error code otherwise. : 
strstr : if :  * Return: 0 on success. An error code otherwise. : 
strstr : for :  * Return: 0 on success. An error code otherwise. : 
strstr : while :  * Return: 0 on success. An error code otherwise. : 
str :  */
strstr : INIT :  */ : 
strstr : if :  */ : 
strstr : for :  */ : 
strstr : while :  */ : 
str : int sched_setscheduler_nocheck(struct task_struct *p, int policy,
strstr : INIT : int sched_setscheduler_nocheck(struct task_struct *p, int policy, : 
strstr : if : int sched_setscheduler_nocheck(struct task_struct *p, int policy, : 
strstr : for : int sched_setscheduler_nocheck(struct task_struct *p, int policy, : 
strstr : while : int sched_setscheduler_nocheck(struct task_struct *p, int policy, : 
str : 			       const struct sched_param *param)
strstr : INIT : 			       const struct sched_param *param) : 
strstr : if : 			       const struct sched_param *param) : 
strstr : for : 			       const struct sched_param *param) : 
strstr : while : 			       const struct sched_param *param) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	return _sched_setscheduler(p, policy, param, false);
strstr : INIT : 	return _sched_setscheduler(p, policy, param, false); : 
strstr : if : 	return _sched_setscheduler(p, policy, param, false); : 
strstr : for : 	return _sched_setscheduler(p, policy, param, false); : 
strstr : while : 	return _sched_setscheduler(p, policy, param, false); : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : static int
strstr : if : static int : 
strstr : for : static int : 
strstr : while : static int : 
str : do_sched_setscheduler(pid_t pid, int policy, struct sched_param __user *param)
strstr : INIT : do_sched_setscheduler(pid_t pid, int policy, struct sched_param __user *param) : 
strstr : if : do_sched_setscheduler(pid_t pid, int policy, struct sched_param __user *param) : 
strstr : for : do_sched_setscheduler(pid_t pid, int policy, struct sched_param __user *param) : 
strstr : while : do_sched_setscheduler(pid_t pid, int policy, struct sched_param __user *param) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	struct sched_param lparam;
strstr : INIT : 	struct sched_param lparam; : 
strstr : if : 	struct sched_param lparam; : 
strstr : for : 	struct sched_param lparam; : 
strstr : while : 	struct sched_param lparam; : 
str : 	struct task_struct *p;
strstr : INIT : 	struct task_struct *p; : 
strstr : if : 	struct task_struct *p; : 
strstr : for : 	struct task_struct *p; : 
strstr : while : 	struct task_struct *p; : 
str : 	int retval;
strstr : INIT : 	int retval; : 
strstr : if : 	int retval; : 
strstr : for : 	int retval; : 
strstr : while : 	int retval; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	if (!param || pid < 0)
strstr : if : 	if (!param || pid < 0) : 
strstr : for : 	if (!param || pid < 0) : 
strstr : while : 	if (!param || pid < 0) : 
str : 		return -EINVAL;
strstr : INIT : 		return -EINVAL; : 
strstr : if : 		return -EINVAL; : 
strstr : for : 		return -EINVAL; : 
strstr : while : 		return -EINVAL; : 
str : 	if (copy_from_user(&lparam, param, sizeof(struct sched_param)))
strstr : INIT : 	if (copy_from_user(&lparam, param, sizeof(struct sched_param))) : 
strstr : if : 	if (copy_from_user(&lparam, param, sizeof(struct sched_param))) : 
strstr : for : 	if (copy_from_user(&lparam, param, sizeof(struct sched_param))) : 
strstr : while : 	if (copy_from_user(&lparam, param, sizeof(struct sched_param))) : 
str : 		return -EFAULT;
strstr : INIT : 		return -EFAULT; : 
strstr : if : 		return -EFAULT; : 
strstr : for : 		return -EFAULT; : 
strstr : while : 		return -EFAULT; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	rcu_read_lock();
strstr : if : 	rcu_read_lock(); : 
strstr : for : 	rcu_read_lock(); : 
strstr : while : 	rcu_read_lock(); : 
str : 	retval = -ESRCH;
strstr : INIT : 	retval = -ESRCH; : 
strstr : if : 	retval = -ESRCH; : 
strstr : for : 	retval = -ESRCH; : 
strstr : while : 	retval = -ESRCH; : 
str : 	p = find_process_by_pid(pid);
strstr : INIT : 	p = find_process_by_pid(pid); : 
strstr : if : 	p = find_process_by_pid(pid); : 
strstr : for : 	p = find_process_by_pid(pid); : 
strstr : while : 	p = find_process_by_pid(pid); : 
str : 	if (p != NULL)
strstr : INIT : 	if (p != NULL) : 
strstr : if : 	if (p != NULL) : 
strstr : for : 	if (p != NULL) : 
strstr : while : 	if (p != NULL) : 
str : 		retval = sched_setscheduler(p, policy, &lparam);
strstr : INIT : 		retval = sched_setscheduler(p, policy, &lparam); : 
strstr : if : 		retval = sched_setscheduler(p, policy, &lparam); : 
strstr : for : 		retval = sched_setscheduler(p, policy, &lparam); : 
strstr : while : 		retval = sched_setscheduler(p, policy, &lparam); : 
str : 	rcu_read_unlock();
strstr : INIT : 	rcu_read_unlock(); : 
strstr : if : 	rcu_read_unlock(); : 
strstr : for : 	rcu_read_unlock(); : 
strstr : while : 	rcu_read_unlock(); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	return retval;
strstr : if : 	return retval; : 
strstr : for : 	return retval; : 
strstr : while : 	return retval; : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : /*
strstr : if : /* : 
strstr : for : /* : 
strstr : while : /* : 
str :  * Mimics kernel/events/core.c perf_copy_attr().
strstr : INIT :  * Mimics kernel/events/core.c perf_copy_attr(). : 
strstr : if :  * Mimics kernel/events/core.c perf_copy_attr(). : 
strstr : for :  * Mimics kernel/events/core.c perf_copy_attr(). : 
strstr : while :  * Mimics kernel/events/core.c perf_copy_attr(). : 
str :  */
strstr : INIT :  */ : 
strstr : if :  */ : 
strstr : for :  */ : 
strstr : while :  */ : 
str : static int sched_copy_attr(struct sched_attr __user *uattr,
strstr : INIT : static int sched_copy_attr(struct sched_attr __user *uattr, : 
strstr : if : static int sched_copy_attr(struct sched_attr __user *uattr, : 
strstr : for : static int sched_copy_attr(struct sched_attr __user *uattr, : 
strstr : while : static int sched_copy_attr(struct sched_attr __user *uattr, : 
str : 			   struct sched_attr *attr)
strstr : INIT : 			   struct sched_attr *attr) : 
strstr : if : 			   struct sched_attr *attr) : 
strstr : for : 			   struct sched_attr *attr) : 
strstr : while : 			   struct sched_attr *attr) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	u32 size;
strstr : INIT : 	u32 size; : 
strstr : if : 	u32 size; : 
strstr : for : 	u32 size; : 
strstr : while : 	u32 size; : 
str : 	int ret;
strstr : INIT : 	int ret; : 
strstr : if : 	int ret; : 
strstr : for : 	int ret; : 
strstr : while : 	int ret; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	if (!access_ok(VERIFY_WRITE, uattr, SCHED_ATTR_SIZE_VER0))
strstr : if : 	if (!access_ok(VERIFY_WRITE, uattr, SCHED_ATTR_SIZE_VER0)) : 
strstr : for : 	if (!access_ok(VERIFY_WRITE, uattr, SCHED_ATTR_SIZE_VER0)) : 
strstr : while : 	if (!access_ok(VERIFY_WRITE, uattr, SCHED_ATTR_SIZE_VER0)) : 
str : 		return -EFAULT;
strstr : INIT : 		return -EFAULT; : 
strstr : if : 		return -EFAULT; : 
strstr : for : 		return -EFAULT; : 
strstr : while : 		return -EFAULT; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	/*
strstr : if : 	/* : 
strstr : for : 	/* : 
strstr : while : 	/* : 
str : 	 * zero the full structure, so that a short copy will be nice.
strstr : INIT : 	 * zero the full structure, so that a short copy will be nice. : 
strstr : if : 	 * zero the full structure, so that a short copy will be nice. : 
strstr : for : 	 * zero the full structure, so that a short copy will be nice. : 
strstr : while : 	 * zero the full structure, so that a short copy will be nice. : 
str : 	 */
strstr : INIT : 	 */ : 
strstr : if : 	 */ : 
strstr : for : 	 */ : 
strstr : while : 	 */ : 
str : 	memset(attr, 0, sizeof(*attr));
strstr : INIT : 	memset(attr, 0, sizeof(*attr)); : 
strstr : if : 	memset(attr, 0, sizeof(*attr)); : 
strstr : for : 	memset(attr, 0, sizeof(*attr)); : 
strstr : while : 	memset(attr, 0, sizeof(*attr)); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	ret = get_user(size, &uattr->size);
strstr : if : 	ret = get_user(size, &uattr->size); : 
strstr : for : 	ret = get_user(size, &uattr->size); : 
strstr : while : 	ret = get_user(size, &uattr->size); : 
str : 	if (ret)
strstr : INIT : 	if (ret) : 
strstr : if : 	if (ret) : 
strstr : for : 	if (ret) : 
strstr : while : 	if (ret) : 
str : 		return ret;
strstr : INIT : 		return ret; : 
strstr : if : 		return ret; : 
strstr : for : 		return ret; : 
strstr : while : 		return ret; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	if (size > PAGE_SIZE)	/* silly large */
strstr : if : 	if (size > PAGE_SIZE)	/* silly large */ : 
strstr : for : 	if (size > PAGE_SIZE)	/* silly large */ : 
strstr : while : 	if (size > PAGE_SIZE)	/* silly large */ : 
str : 		goto err_size;
strstr : INIT : 		goto err_size; : 
strstr : if : 		goto err_size; : 
strstr : for : 		goto err_size; : 
strstr : while : 		goto err_size; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	if (!size)		/* abi compat */
strstr : if : 	if (!size)		/* abi compat */ : 
strstr : for : 	if (!size)		/* abi compat */ : 
strstr : while : 	if (!size)		/* abi compat */ : 
str : 		size = SCHED_ATTR_SIZE_VER0;
strstr : INIT : 		size = SCHED_ATTR_SIZE_VER0; : 
strstr : if : 		size = SCHED_ATTR_SIZE_VER0; : 
strstr : for : 		size = SCHED_ATTR_SIZE_VER0; : 
strstr : while : 		size = SCHED_ATTR_SIZE_VER0; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	if (size < SCHED_ATTR_SIZE_VER0)
strstr : if : 	if (size < SCHED_ATTR_SIZE_VER0) : 
strstr : for : 	if (size < SCHED_ATTR_SIZE_VER0) : 
strstr : while : 	if (size < SCHED_ATTR_SIZE_VER0) : 
str : 		goto err_size;
strstr : INIT : 		goto err_size; : 
strstr : if : 		goto err_size; : 
strstr : for : 		goto err_size; : 
strstr : while : 		goto err_size; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	/*
strstr : if : 	/* : 
strstr : for : 	/* : 
strstr : while : 	/* : 
str : 	 * If we're handed a bigger struct than we know of,
strstr : INIT : 	 * If we're handed a bigger struct than we know of, : 
strstr : if : 	 * If we're handed a bigger struct than we know of, : 
strstr : for : 	 * If we're handed a bigger struct than we know of, : 
strstr : while : 	 * If we're handed a bigger struct than we know of, : 
str : 	 * ensure all the unknown bits are 0 - i.e. new
strstr : INIT : 	 * ensure all the unknown bits are 0 - i.e. new : 
strstr : if : 	 * ensure all the unknown bits are 0 - i.e. new : 
strstr : for : 	 * ensure all the unknown bits are 0 - i.e. new : 
strstr : while : 	 * ensure all the unknown bits are 0 - i.e. new : 
str : 	 * user-space does not rely on any kernel feature
strstr : INIT : 	 * user-space does not rely on any kernel feature : 
strstr : if : 	 * user-space does not rely on any kernel feature : 
strstr : for : 	 * user-space does not rely on any kernel feature : 
strstr : while : 	 * user-space does not rely on any kernel feature : 
str : 	 * extensions we dont know about yet.
strstr : INIT : 	 * extensions we dont know about yet. : 
strstr : if : 	 * extensions we dont know about yet. : 
strstr : for : 	 * extensions we dont know about yet. : 
strstr : while : 	 * extensions we dont know about yet. : 
str : 	 */
strstr : INIT : 	 */ : 
strstr : if : 	 */ : 
strstr : for : 	 */ : 
strstr : while : 	 */ : 
str : 	if (size > sizeof(*attr)) {
strstr : INIT : 	if (size > sizeof(*attr)) { : 
strstr : if : 	if (size > sizeof(*attr)) { : 
strstr : for : 	if (size > sizeof(*attr)) { : 
strstr : while : 	if (size > sizeof(*attr)) { : 
str : 		unsigned char __user *addr;
strstr : INIT : 		unsigned char __user *addr; : 
strstr : if : 		unsigned char __user *addr; : 
strstr : for : 		unsigned char __user *addr; : 
strstr : while : 		unsigned char __user *addr; : 
str : 		unsigned char __user *end;
strstr : INIT : 		unsigned char __user *end; : 
strstr : if : 		unsigned char __user *end; : 
strstr : for : 		unsigned char __user *end; : 
strstr : while : 		unsigned char __user *end; : 
str : 		unsigned char val;
strstr : INIT : 		unsigned char val; : 
strstr : if : 		unsigned char val; : 
strstr : for : 		unsigned char val; : 
strstr : while : 		unsigned char val; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 		addr = (void __user *)uattr + sizeof(*attr);
strstr : if : 		addr = (void __user *)uattr + sizeof(*attr); : 
strstr : for : 		addr = (void __user *)uattr + sizeof(*attr); : 
strstr : while : 		addr = (void __user *)uattr + sizeof(*attr); : 
str : 		end  = (void __user *)uattr + size;
strstr : INIT : 		end  = (void __user *)uattr + size; : 
strstr : if : 		end  = (void __user *)uattr + size; : 
strstr : for : 		end  = (void __user *)uattr + size; : 
strstr : while : 		end  = (void __user *)uattr + size; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 		for (; addr < end; addr++) {
strstr : if : 		for (; addr < end; addr++) { : 
strstr : for : 		for (; addr < end; addr++) { : 
strstr : while : 		for (; addr < end; addr++) { : 
str : 			ret = get_user(val, addr);
strstr : INIT : 			ret = get_user(val, addr); : 
strstr : if : 			ret = get_user(val, addr); : 
strstr : for : 			ret = get_user(val, addr); : 
strstr : while : 			ret = get_user(val, addr); : 
str : 			if (ret)
strstr : INIT : 			if (ret) : 
strstr : if : 			if (ret) : 
strstr : for : 			if (ret) : 
strstr : while : 			if (ret) : 
str : 				return ret;
strstr : INIT : 				return ret; : 
strstr : if : 				return ret; : 
strstr : for : 				return ret; : 
strstr : while : 				return ret; : 
str : 			if (val)
strstr : INIT : 			if (val) : 
strstr : if : 			if (val) : 
strstr : for : 			if (val) : 
strstr : while : 			if (val) : 
str : 				goto err_size;
strstr : INIT : 				goto err_size; : 
strstr : if : 				goto err_size; : 
strstr : for : 				goto err_size; : 
strstr : while : 				goto err_size; : 
str : 		}
strstr : INIT : 		} : 
strstr : if : 		} : 
strstr : for : 		} : 
strstr : while : 		} : 
str : 		size = sizeof(*attr);
strstr : INIT : 		size = sizeof(*attr); : 
strstr : if : 		size = sizeof(*attr); : 
strstr : for : 		size = sizeof(*attr); : 
strstr : while : 		size = sizeof(*attr); : 
str : 	}
strstr : INIT : 	} : 
strstr : if : 	} : 
strstr : for : 	} : 
strstr : while : 	} : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	ret = copy_from_user(attr, uattr, size);
strstr : if : 	ret = copy_from_user(attr, uattr, size); : 
strstr : for : 	ret = copy_from_user(attr, uattr, size); : 
strstr : while : 	ret = copy_from_user(attr, uattr, size); : 
str : 	if (ret)
strstr : INIT : 	if (ret) : 
strstr : if : 	if (ret) : 
strstr : for : 	if (ret) : 
strstr : while : 	if (ret) : 
str : 		return -EFAULT;
strstr : INIT : 		return -EFAULT; : 
strstr : if : 		return -EFAULT; : 
strstr : for : 		return -EFAULT; : 
strstr : while : 		return -EFAULT; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	/*
strstr : if : 	/* : 
strstr : for : 	/* : 
strstr : while : 	/* : 
str : 	 * XXX: do we want to be lenient like existing syscalls; or do we want
strstr : INIT : 	 * XXX: do we want to be lenient like existing syscalls; or do we want : 
strstr : if : 	 * XXX: do we want to be lenient like existing syscalls; or do we want : 
strstr : for : 	 * XXX: do we want to be lenient like existing syscalls; or do we want : 
strstr : while : 	 * XXX: do we want to be lenient like existing syscalls; or do we want : 
str : 	 * to be strict and return an error on out-of-bounds values?
strstr : INIT : 	 * to be strict and return an error on out-of-bounds values? : 
strstr : if : 	 * to be strict and return an error on out-of-bounds values? : 
strstr : for : 	 * to be strict and return an error on out-of-bounds values? : 
strstr : while : 	 * to be strict and return an error on out-of-bounds values? : 
str : 	 */
strstr : INIT : 	 */ : 
strstr : if : 	 */ : 
strstr : for : 	 */ : 
strstr : while : 	 */ : 
str : 	attr->sched_nice = clamp(attr->sched_nice, -20, 19);
strstr : INIT : 	attr->sched_nice = clamp(attr->sched_nice, -20, 19); : 
strstr : if : 	attr->sched_nice = clamp(attr->sched_nice, -20, 19); : 
strstr : for : 	attr->sched_nice = clamp(attr->sched_nice, -20, 19); : 
strstr : while : 	attr->sched_nice = clamp(attr->sched_nice, -20, 19); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : out:
strstr : if : out: : 
strstr : for : out: : 
strstr : while : out: : 
str : 	return ret;
strstr : INIT : 	return ret; : 
strstr : if : 	return ret; : 
strstr : for : 	return ret; : 
strstr : while : 	return ret; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : err_size:
strstr : if : err_size: : 
strstr : for : err_size: : 
strstr : while : err_size: : 
str : 	put_user(sizeof(*attr), &uattr->size);
strstr : INIT : 	put_user(sizeof(*attr), &uattr->size); : 
strstr : if : 	put_user(sizeof(*attr), &uattr->size); : 
strstr : for : 	put_user(sizeof(*attr), &uattr->size); : 
strstr : while : 	put_user(sizeof(*attr), &uattr->size); : 
str : 	ret = -E2BIG;
strstr : INIT : 	ret = -E2BIG; : 
strstr : if : 	ret = -E2BIG; : 
strstr : for : 	ret = -E2BIG; : 
strstr : while : 	ret = -E2BIG; : 
str : 	goto out;
strstr : INIT : 	goto out; : 
strstr : if : 	goto out; : 
strstr : for : 	goto out; : 
strstr : while : 	goto out; : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : /**
strstr : if : /** : 
strstr : for : /** : 
strstr : while : /** : 
str :  * sys_sched_setscheduler - set/change the scheduler policy and RT priority
strstr : INIT :  * sys_sched_setscheduler - set/change the scheduler policy and RT priority : 
strstr : if :  * sys_sched_setscheduler - set/change the scheduler policy and RT priority : 
strstr : for :  * sys_sched_setscheduler - set/change the scheduler policy and RT priority : 
strstr : while :  * sys_sched_setscheduler - set/change the scheduler policy and RT priority : 
str :  * @pid: the pid in question.
strstr : INIT :  * @pid: the pid in question. : 
strstr : if :  * @pid: the pid in question. : 
strstr : for :  * @pid: the pid in question. : 
strstr : while :  * @pid: the pid in question. : 
str :  * @policy: new policy.
strstr : INIT :  * @policy: new policy. : 
strstr : if :  * @policy: new policy. : 
strstr : for :  * @policy: new policy. : 
strstr : while :  * @policy: new policy. : 
str :  * @param: structure containing the new RT priority.
strstr : INIT :  * @param: structure containing the new RT priority. : 
strstr : if :  * @param: structure containing the new RT priority. : 
strstr : for :  * @param: structure containing the new RT priority. : 
strstr : while :  * @param: structure containing the new RT priority. : 
str :  *
strstr : INIT :  * : 
strstr : if :  * : 
strstr : for :  * : 
strstr : while :  * : 
str :  * Return: 0 on success. An error code otherwise.
strstr : INIT :  * Return: 0 on success. An error code otherwise. : 
strstr : if :  * Return: 0 on success. An error code otherwise. : 
strstr : for :  * Return: 0 on success. An error code otherwise. : 
strstr : while :  * Return: 0 on success. An error code otherwise. : 
str :  */
strstr : INIT :  */ : 
strstr : if :  */ : 
strstr : for :  */ : 
strstr : while :  */ : 
str : SYSCALL_DEFINE3(sched_setscheduler, pid_t, pid, int, policy,
strstr : INIT : SYSCALL_DEFINE3(sched_setscheduler, pid_t, pid, int, policy, : 
strstr : if : SYSCALL_DEFINE3(sched_setscheduler, pid_t, pid, int, policy, : 
strstr : for : SYSCALL_DEFINE3(sched_setscheduler, pid_t, pid, int, policy, : 
strstr : while : SYSCALL_DEFINE3(sched_setscheduler, pid_t, pid, int, policy, : 
str : 		struct sched_param __user *, param)
strstr : INIT : 		struct sched_param __user *, param) : 
strstr : if : 		struct sched_param __user *, param) : 
strstr : for : 		struct sched_param __user *, param) : 
strstr : while : 		struct sched_param __user *, param) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	/* negative values for policy are not valid */
strstr : INIT : 	/* negative values for policy are not valid */ : 
strstr : if : 	/* negative values for policy are not valid */ : 
strstr : for : 	/* negative values for policy are not valid */ : 
strstr : while : 	/* negative values for policy are not valid */ : 
str : 	if (policy < 0)
strstr : INIT : 	if (policy < 0) : 
strstr : if : 	if (policy < 0) : 
strstr : for : 	if (policy < 0) : 
strstr : while : 	if (policy < 0) : 
str : 		return -EINVAL;
strstr : INIT : 		return -EINVAL; : 
strstr : if : 		return -EINVAL; : 
strstr : for : 		return -EINVAL; : 
strstr : while : 		return -EINVAL; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	return do_sched_setscheduler(pid, policy, param);
strstr : if : 	return do_sched_setscheduler(pid, policy, param); : 
strstr : for : 	return do_sched_setscheduler(pid, policy, param); : 
strstr : while : 	return do_sched_setscheduler(pid, policy, param); : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : /**
strstr : if : /** : 
strstr : for : /** : 
strstr : while : /** : 
str :  * sys_sched_setparam - set/change the RT priority of a thread
strstr : INIT :  * sys_sched_setparam - set/change the RT priority of a thread : 
strstr : if :  * sys_sched_setparam - set/change the RT priority of a thread : 
strstr : for :  * sys_sched_setparam - set/change the RT priority of a thread : 
strstr : while :  * sys_sched_setparam - set/change the RT priority of a thread : 
str :  * @pid: the pid in question.
strstr : INIT :  * @pid: the pid in question. : 
strstr : if :  * @pid: the pid in question. : 
strstr : for :  * @pid: the pid in question. : 
strstr : while :  * @pid: the pid in question. : 
str :  * @param: structure containing the new RT priority.
strstr : INIT :  * @param: structure containing the new RT priority. : 
strstr : if :  * @param: structure containing the new RT priority. : 
strstr : for :  * @param: structure containing the new RT priority. : 
strstr : while :  * @param: structure containing the new RT priority. : 
str :  *
strstr : INIT :  * : 
strstr : if :  * : 
strstr : for :  * : 
strstr : while :  * : 
str :  * Return: 0 on success. An error code otherwise.
strstr : INIT :  * Return: 0 on success. An error code otherwise. : 
strstr : if :  * Return: 0 on success. An error code otherwise. : 
strstr : for :  * Return: 0 on success. An error code otherwise. : 
strstr : while :  * Return: 0 on success. An error code otherwise. : 
str :  */
strstr : INIT :  */ : 
strstr : if :  */ : 
strstr : for :  */ : 
strstr : while :  */ : 
str : SYSCALL_DEFINE2(sched_setparam, pid_t, pid, struct sched_param __user *, param)
strstr : INIT : SYSCALL_DEFINE2(sched_setparam, pid_t, pid, struct sched_param __user *, param) : 
strstr : if : SYSCALL_DEFINE2(sched_setparam, pid_t, pid, struct sched_param __user *, param) : 
strstr : for : SYSCALL_DEFINE2(sched_setparam, pid_t, pid, struct sched_param __user *, param) : 
strstr : while : SYSCALL_DEFINE2(sched_setparam, pid_t, pid, struct sched_param __user *, param) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	return do_sched_setscheduler(pid, -1, param);
strstr : INIT : 	return do_sched_setscheduler(pid, -1, param); : 
strstr : if : 	return do_sched_setscheduler(pid, -1, param); : 
strstr : for : 	return do_sched_setscheduler(pid, -1, param); : 
strstr : while : 	return do_sched_setscheduler(pid, -1, param); : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : /**
strstr : if : /** : 
strstr : for : /** : 
strstr : while : /** : 
str :  * sys_sched_setattr - same as above, but with extended sched_attr
strstr : INIT :  * sys_sched_setattr - same as above, but with extended sched_attr : 
strstr : if :  * sys_sched_setattr - same as above, but with extended sched_attr : 
strstr : for :  * sys_sched_setattr - same as above, but with extended sched_attr : 
strstr : while :  * sys_sched_setattr - same as above, but with extended sched_attr : 
str :  * @pid: the pid in question.
strstr : INIT :  * @pid: the pid in question. : 
strstr : if :  * @pid: the pid in question. : 
strstr : for :  * @pid: the pid in question. : 
strstr : while :  * @pid: the pid in question. : 
str :  * @uattr: structure containing the extended parameters.
strstr : INIT :  * @uattr: structure containing the extended parameters. : 
strstr : if :  * @uattr: structure containing the extended parameters. : 
strstr : for :  * @uattr: structure containing the extended parameters. : 
strstr : while :  * @uattr: structure containing the extended parameters. : 
str :  */
strstr : INIT :  */ : 
strstr : if :  */ : 
strstr : for :  */ : 
strstr : while :  */ : 
str : SYSCALL_DEFINE3(sched_setattr, pid_t, pid, struct sched_attr __user *, uattr,
strstr : INIT : SYSCALL_DEFINE3(sched_setattr, pid_t, pid, struct sched_attr __user *, uattr, : 
strstr : if : SYSCALL_DEFINE3(sched_setattr, pid_t, pid, struct sched_attr __user *, uattr, : 
strstr : for : SYSCALL_DEFINE3(sched_setattr, pid_t, pid, struct sched_attr __user *, uattr, : 
strstr : while : SYSCALL_DEFINE3(sched_setattr, pid_t, pid, struct sched_attr __user *, uattr, : 
str : 			       unsigned int, flags)
strstr : INIT : 			       unsigned int, flags) : 
strstr : if : 			       unsigned int, flags) : 
strstr : for : 			       unsigned int, flags) : 
strstr : while : 			       unsigned int, flags) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	struct sched_attr attr;
strstr : INIT : 	struct sched_attr attr; : 
strstr : if : 	struct sched_attr attr; : 
strstr : for : 	struct sched_attr attr; : 
strstr : while : 	struct sched_attr attr; : 
str : 	struct task_struct *p;
strstr : INIT : 	struct task_struct *p; : 
strstr : if : 	struct task_struct *p; : 
strstr : for : 	struct task_struct *p; : 
strstr : while : 	struct task_struct *p; : 
str : 	int retval;
strstr : INIT : 	int retval; : 
strstr : if : 	int retval; : 
strstr : for : 	int retval; : 
strstr : while : 	int retval; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	if (!uattr || pid < 0 || flags)
strstr : if : 	if (!uattr || pid < 0 || flags) : 
strstr : for : 	if (!uattr || pid < 0 || flags) : 
strstr : while : 	if (!uattr || pid < 0 || flags) : 
str : 		return -EINVAL;
strstr : INIT : 		return -EINVAL; : 
strstr : if : 		return -EINVAL; : 
strstr : for : 		return -EINVAL; : 
strstr : while : 		return -EINVAL; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	retval = sched_copy_attr(uattr, &attr);
strstr : if : 	retval = sched_copy_attr(uattr, &attr); : 
strstr : for : 	retval = sched_copy_attr(uattr, &attr); : 
strstr : while : 	retval = sched_copy_attr(uattr, &attr); : 
str : 	if (retval)
strstr : INIT : 	if (retval) : 
strstr : if : 	if (retval) : 
strstr : for : 	if (retval) : 
strstr : while : 	if (retval) : 
str : 		return retval;
strstr : INIT : 		return retval; : 
strstr : if : 		return retval; : 
strstr : for : 		return retval; : 
strstr : while : 		return retval; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	if ((int)attr.sched_policy < 0)
strstr : if : 	if ((int)attr.sched_policy < 0) : 
strstr : for : 	if ((int)attr.sched_policy < 0) : 
strstr : while : 	if ((int)attr.sched_policy < 0) : 
str : 		return -EINVAL;
strstr : INIT : 		return -EINVAL; : 
strstr : if : 		return -EINVAL; : 
strstr : for : 		return -EINVAL; : 
strstr : while : 		return -EINVAL; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	rcu_read_lock();
strstr : if : 	rcu_read_lock(); : 
strstr : for : 	rcu_read_lock(); : 
strstr : while : 	rcu_read_lock(); : 
str : 	retval = -ESRCH;
strstr : INIT : 	retval = -ESRCH; : 
strstr : if : 	retval = -ESRCH; : 
strstr : for : 	retval = -ESRCH; : 
strstr : while : 	retval = -ESRCH; : 
str : 	p = find_process_by_pid(pid);
strstr : INIT : 	p = find_process_by_pid(pid); : 
strstr : if : 	p = find_process_by_pid(pid); : 
strstr : for : 	p = find_process_by_pid(pid); : 
strstr : while : 	p = find_process_by_pid(pid); : 
str : 	if (p != NULL)
strstr : INIT : 	if (p != NULL) : 
strstr : if : 	if (p != NULL) : 
strstr : for : 	if (p != NULL) : 
strstr : while : 	if (p != NULL) : 
str : 		retval = sched_setattr(p, &attr);
strstr : INIT : 		retval = sched_setattr(p, &attr); : 
strstr : if : 		retval = sched_setattr(p, &attr); : 
strstr : for : 		retval = sched_setattr(p, &attr); : 
strstr : while : 		retval = sched_setattr(p, &attr); : 
str : 	rcu_read_unlock();
strstr : INIT : 	rcu_read_unlock(); : 
strstr : if : 	rcu_read_unlock(); : 
strstr : for : 	rcu_read_unlock(); : 
strstr : while : 	rcu_read_unlock(); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	return retval;
strstr : if : 	return retval; : 
strstr : for : 	return retval; : 
strstr : while : 	return retval; : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : /**
strstr : if : /** : 
strstr : for : /** : 
strstr : while : /** : 
str :  * sys_sched_getscheduler - get the policy (scheduling class) of a thread
strstr : INIT :  * sys_sched_getscheduler - get the policy (scheduling class) of a thread : 
strstr : if :  * sys_sched_getscheduler - get the policy (scheduling class) of a thread : 
strstr : for :  * sys_sched_getscheduler - get the policy (scheduling class) of a thread : 
strstr : while :  * sys_sched_getscheduler - get the policy (scheduling class) of a thread : 
str :  * @pid: the pid in question.
strstr : INIT :  * @pid: the pid in question. : 
strstr : if :  * @pid: the pid in question. : 
strstr : for :  * @pid: the pid in question. : 
strstr : while :  * @pid: the pid in question. : 
str :  *
strstr : INIT :  * : 
strstr : if :  * : 
strstr : for :  * : 
strstr : while :  * : 
str :  * Return: On success, the policy of the thread. Otherwise, a negative error
strstr : INIT :  * Return: On success, the policy of the thread. Otherwise, a negative error : 
strstr : if :  * Return: On success, the policy of the thread. Otherwise, a negative error : 
strstr : for :  * Return: On success, the policy of the thread. Otherwise, a negative error : 
strstr : while :  * Return: On success, the policy of the thread. Otherwise, a negative error : 
str :  * code.
strstr : INIT :  * code. : 
strstr : if :  * code. : 
strstr : for :  * code. : 
strstr : while :  * code. : 
str :  */
strstr : INIT :  */ : 
strstr : if :  */ : 
strstr : for :  */ : 
strstr : while :  */ : 
str : SYSCALL_DEFINE1(sched_getscheduler, pid_t, pid)
strstr : INIT : SYSCALL_DEFINE1(sched_getscheduler, pid_t, pid) : 
strstr : if : SYSCALL_DEFINE1(sched_getscheduler, pid_t, pid) : 
strstr : for : SYSCALL_DEFINE1(sched_getscheduler, pid_t, pid) : 
strstr : while : SYSCALL_DEFINE1(sched_getscheduler, pid_t, pid) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	struct task_struct *p;
strstr : INIT : 	struct task_struct *p; : 
strstr : if : 	struct task_struct *p; : 
strstr : for : 	struct task_struct *p; : 
strstr : while : 	struct task_struct *p; : 
str : 	int retval;
strstr : INIT : 	int retval; : 
strstr : if : 	int retval; : 
strstr : for : 	int retval; : 
strstr : while : 	int retval; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	if (pid < 0)
strstr : if : 	if (pid < 0) : 
strstr : for : 	if (pid < 0) : 
strstr : while : 	if (pid < 0) : 
str : 		return -EINVAL;
strstr : INIT : 		return -EINVAL; : 
strstr : if : 		return -EINVAL; : 
strstr : for : 		return -EINVAL; : 
strstr : while : 		return -EINVAL; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	retval = -ESRCH;
strstr : if : 	retval = -ESRCH; : 
strstr : for : 	retval = -ESRCH; : 
strstr : while : 	retval = -ESRCH; : 
str : 	rcu_read_lock();
strstr : INIT : 	rcu_read_lock(); : 
strstr : if : 	rcu_read_lock(); : 
strstr : for : 	rcu_read_lock(); : 
strstr : while : 	rcu_read_lock(); : 
str : 	p = find_process_by_pid(pid);
strstr : INIT : 	p = find_process_by_pid(pid); : 
strstr : if : 	p = find_process_by_pid(pid); : 
strstr : for : 	p = find_process_by_pid(pid); : 
strstr : while : 	p = find_process_by_pid(pid); : 
str : 	if (p) {
strstr : INIT : 	if (p) { : 
strstr : if : 	if (p) { : 
strstr : for : 	if (p) { : 
strstr : while : 	if (p) { : 
str : 		retval = security_task_getscheduler(p);
strstr : INIT : 		retval = security_task_getscheduler(p); : 
strstr : if : 		retval = security_task_getscheduler(p); : 
strstr : for : 		retval = security_task_getscheduler(p); : 
strstr : while : 		retval = security_task_getscheduler(p); : 
str : 		if (!retval)
strstr : INIT : 		if (!retval) : 
strstr : if : 		if (!retval) : 
strstr : for : 		if (!retval) : 
strstr : while : 		if (!retval) : 
str : 			retval = p->policy
strstr : INIT : 			retval = p->policy : 
strstr : if : 			retval = p->policy : 
strstr : for : 			retval = p->policy : 
strstr : while : 			retval = p->policy : 
str : 				| (p->sched_reset_on_fork ? SCHED_RESET_ON_FORK : 0);
strstr : INIT : 				| (p->sched_reset_on_fork ? SCHED_RESET_ON_FORK : 0); : 
strstr : if : 				| (p->sched_reset_on_fork ? SCHED_RESET_ON_FORK : 0); : 
strstr : for : 				| (p->sched_reset_on_fork ? SCHED_RESET_ON_FORK : 0); : 
strstr : while : 				| (p->sched_reset_on_fork ? SCHED_RESET_ON_FORK : 0); : 
str : 	}
strstr : INIT : 	} : 
strstr : if : 	} : 
strstr : for : 	} : 
strstr : while : 	} : 
str : 	rcu_read_unlock();
strstr : INIT : 	rcu_read_unlock(); : 
strstr : if : 	rcu_read_unlock(); : 
strstr : for : 	rcu_read_unlock(); : 
strstr : while : 	rcu_read_unlock(); : 
str : 	return retval;
strstr : INIT : 	return retval; : 
strstr : if : 	return retval; : 
strstr : for : 	return retval; : 
strstr : while : 	return retval; : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : /**
strstr : if : /** : 
strstr : for : /** : 
strstr : while : /** : 
str :  * sys_sched_getparam - get the RT priority of a thread
strstr : INIT :  * sys_sched_getparam - get the RT priority of a thread : 
strstr : if :  * sys_sched_getparam - get the RT priority of a thread : 
strstr : for :  * sys_sched_getparam - get the RT priority of a thread : 
strstr : while :  * sys_sched_getparam - get the RT priority of a thread : 
str :  * @pid: the pid in question.
strstr : INIT :  * @pid: the pid in question. : 
strstr : if :  * @pid: the pid in question. : 
strstr : for :  * @pid: the pid in question. : 
strstr : while :  * @pid: the pid in question. : 
str :  * @param: structure containing the RT priority.
strstr : INIT :  * @param: structure containing the RT priority. : 
strstr : if :  * @param: structure containing the RT priority. : 
strstr : for :  * @param: structure containing the RT priority. : 
strstr : while :  * @param: structure containing the RT priority. : 
str :  *
strstr : INIT :  * : 
strstr : if :  * : 
strstr : for :  * : 
strstr : while :  * : 
str :  * Return: On success, 0 and the RT priority is in @param. Otherwise, an error
strstr : INIT :  * Return: On success, 0 and the RT priority is in @param. Otherwise, an error : 
strstr : if :  * Return: On success, 0 and the RT priority is in @param. Otherwise, an error : 
strstr : for :  * Return: On success, 0 and the RT priority is in @param. Otherwise, an error : 
strstr : while :  * Return: On success, 0 and the RT priority is in @param. Otherwise, an error : 
str :  * code.
strstr : INIT :  * code. : 
strstr : if :  * code. : 
strstr : for :  * code. : 
strstr : while :  * code. : 
str :  */
strstr : INIT :  */ : 
strstr : if :  */ : 
strstr : for :  */ : 
strstr : while :  */ : 
str : SYSCALL_DEFINE2(sched_getparam, pid_t, pid, struct sched_param __user *, param)
strstr : INIT : SYSCALL_DEFINE2(sched_getparam, pid_t, pid, struct sched_param __user *, param) : 
strstr : if : SYSCALL_DEFINE2(sched_getparam, pid_t, pid, struct sched_param __user *, param) : 
strstr : for : SYSCALL_DEFINE2(sched_getparam, pid_t, pid, struct sched_param __user *, param) : 
strstr : while : SYSCALL_DEFINE2(sched_getparam, pid_t, pid, struct sched_param __user *, param) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	struct sched_param lp = { .sched_priority = 0 };
strstr : INIT : 	struct sched_param lp = { .sched_priority = 0 }; : 
strstr : if : 	struct sched_param lp = { .sched_priority = 0 }; : 
strstr : for : 	struct sched_param lp = { .sched_priority = 0 }; : 
strstr : while : 	struct sched_param lp = { .sched_priority = 0 }; : 
str : 	struct task_struct *p;
strstr : INIT : 	struct task_struct *p; : 
strstr : if : 	struct task_struct *p; : 
strstr : for : 	struct task_struct *p; : 
strstr : while : 	struct task_struct *p; : 
str : 	int retval;
strstr : INIT : 	int retval; : 
strstr : if : 	int retval; : 
strstr : for : 	int retval; : 
strstr : while : 	int retval; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	if (!param || pid < 0)
strstr : if : 	if (!param || pid < 0) : 
strstr : for : 	if (!param || pid < 0) : 
strstr : while : 	if (!param || pid < 0) : 
str : 		return -EINVAL;
strstr : INIT : 		return -EINVAL; : 
strstr : if : 		return -EINVAL; : 
strstr : for : 		return -EINVAL; : 
strstr : while : 		return -EINVAL; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	rcu_read_lock();
strstr : if : 	rcu_read_lock(); : 
strstr : for : 	rcu_read_lock(); : 
strstr : while : 	rcu_read_lock(); : 
str : 	p = find_process_by_pid(pid);
strstr : INIT : 	p = find_process_by_pid(pid); : 
strstr : if : 	p = find_process_by_pid(pid); : 
strstr : for : 	p = find_process_by_pid(pid); : 
strstr : while : 	p = find_process_by_pid(pid); : 
str : 	retval = -ESRCH;
strstr : INIT : 	retval = -ESRCH; : 
strstr : if : 	retval = -ESRCH; : 
strstr : for : 	retval = -ESRCH; : 
strstr : while : 	retval = -ESRCH; : 
str : 	if (!p)
strstr : INIT : 	if (!p) : 
strstr : if : 	if (!p) : 
strstr : for : 	if (!p) : 
strstr : while : 	if (!p) : 
str : 		goto out_unlock;
strstr : INIT : 		goto out_unlock; : 
strstr : if : 		goto out_unlock; : 
strstr : for : 		goto out_unlock; : 
strstr : while : 		goto out_unlock; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	retval = security_task_getscheduler(p);
strstr : if : 	retval = security_task_getscheduler(p); : 
strstr : for : 	retval = security_task_getscheduler(p); : 
strstr : while : 	retval = security_task_getscheduler(p); : 
str : 	if (retval)
strstr : INIT : 	if (retval) : 
strstr : if : 	if (retval) : 
strstr : for : 	if (retval) : 
strstr : while : 	if (retval) : 
str : 		goto out_unlock;
strstr : INIT : 		goto out_unlock; : 
strstr : if : 		goto out_unlock; : 
strstr : for : 		goto out_unlock; : 
strstr : while : 		goto out_unlock; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	if (task_has_rt_policy(p))
strstr : if : 	if (task_has_rt_policy(p)) : 
strstr : for : 	if (task_has_rt_policy(p)) : 
strstr : while : 	if (task_has_rt_policy(p)) : 
str : 		lp.sched_priority = p->rt_priority;
strstr : INIT : 		lp.sched_priority = p->rt_priority; : 
strstr : if : 		lp.sched_priority = p->rt_priority; : 
strstr : for : 		lp.sched_priority = p->rt_priority; : 
strstr : while : 		lp.sched_priority = p->rt_priority; : 
str : 	rcu_read_unlock();
strstr : INIT : 	rcu_read_unlock(); : 
strstr : if : 	rcu_read_unlock(); : 
strstr : for : 	rcu_read_unlock(); : 
strstr : while : 	rcu_read_unlock(); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	/*
strstr : if : 	/* : 
strstr : for : 	/* : 
strstr : while : 	/* : 
str : 	 * This one might sleep, we cannot do it with a spinlock held ...
strstr : INIT : 	 * This one might sleep, we cannot do it with a spinlock held ... : 
strstr : if : 	 * This one might sleep, we cannot do it with a spinlock held ... : 
strstr : for : 	 * This one might sleep, we cannot do it with a spinlock held ... : 
strstr : while : 	 * This one might sleep, we cannot do it with a spinlock held ... : 
str : 	 */
strstr : INIT : 	 */ : 
strstr : if : 	 */ : 
strstr : for : 	 */ : 
strstr : while : 	 */ : 
str : 	retval = copy_to_user(param, &lp, sizeof(*param)) ? -EFAULT : 0;
strstr : INIT : 	retval = copy_to_user(param, &lp, sizeof(*param)) ? -EFAULT : 0; : 
strstr : if : 	retval = copy_to_user(param, &lp, sizeof(*param)) ? -EFAULT : 0; : 
strstr : for : 	retval = copy_to_user(param, &lp, sizeof(*param)) ? -EFAULT : 0; : 
strstr : while : 	retval = copy_to_user(param, &lp, sizeof(*param)) ? -EFAULT : 0; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	return retval;
strstr : if : 	return retval; : 
strstr : for : 	return retval; : 
strstr : while : 	return retval; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : out_unlock:
strstr : if : out_unlock: : 
strstr : for : out_unlock: : 
strstr : while : out_unlock: : 
str : 	rcu_read_unlock();
strstr : INIT : 	rcu_read_unlock(); : 
strstr : if : 	rcu_read_unlock(); : 
strstr : for : 	rcu_read_unlock(); : 
strstr : while : 	rcu_read_unlock(); : 
str : 	return retval;
strstr : INIT : 	return retval; : 
strstr : if : 	return retval; : 
strstr : for : 	return retval; : 
strstr : while : 	return retval; : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : static int sched_read_attr(struct sched_attr __user *uattr,
strstr : if : static int sched_read_attr(struct sched_attr __user *uattr, : 
strstr : for : static int sched_read_attr(struct sched_attr __user *uattr, : 
strstr : while : static int sched_read_attr(struct sched_attr __user *uattr, : 
str : 			   struct sched_attr *attr,
strstr : INIT : 			   struct sched_attr *attr, : 
strstr : if : 			   struct sched_attr *attr, : 
strstr : for : 			   struct sched_attr *attr, : 
strstr : while : 			   struct sched_attr *attr, : 
str : 			   unsigned int usize)
strstr : INIT : 			   unsigned int usize) : 
strstr : if : 			   unsigned int usize) : 
strstr : for : 			   unsigned int usize) : 
strstr : while : 			   unsigned int usize) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	int ret;
strstr : INIT : 	int ret; : 
strstr : if : 	int ret; : 
strstr : for : 	int ret; : 
strstr : while : 	int ret; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	if (!access_ok(VERIFY_WRITE, uattr, usize))
strstr : if : 	if (!access_ok(VERIFY_WRITE, uattr, usize)) : 
strstr : for : 	if (!access_ok(VERIFY_WRITE, uattr, usize)) : 
strstr : while : 	if (!access_ok(VERIFY_WRITE, uattr, usize)) : 
str : 		return -EFAULT;
strstr : INIT : 		return -EFAULT; : 
strstr : if : 		return -EFAULT; : 
strstr : for : 		return -EFAULT; : 
strstr : while : 		return -EFAULT; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	/*
strstr : if : 	/* : 
strstr : for : 	/* : 
strstr : while : 	/* : 
str : 	 * If we're handed a smaller struct than we know of,
strstr : INIT : 	 * If we're handed a smaller struct than we know of, : 
strstr : if : 	 * If we're handed a smaller struct than we know of, : 
strstr : for : 	 * If we're handed a smaller struct than we know of, : 
strstr : while : 	 * If we're handed a smaller struct than we know of, : 
str : 	 * ensure all the unknown bits are 0 - i.e. old
strstr : INIT : 	 * ensure all the unknown bits are 0 - i.e. old : 
strstr : if : 	 * ensure all the unknown bits are 0 - i.e. old : 
strstr : for : 	 * ensure all the unknown bits are 0 - i.e. old : 
strstr : while : 	 * ensure all the unknown bits are 0 - i.e. old : 
str : 	 * user-space does not get uncomplete information.
strstr : INIT : 	 * user-space does not get uncomplete information. : 
strstr : if : 	 * user-space does not get uncomplete information. : 
strstr : for : 	 * user-space does not get uncomplete information. : 
strstr : while : 	 * user-space does not get uncomplete information. : 
str : 	 */
strstr : INIT : 	 */ : 
strstr : if : 	 */ : 
strstr : for : 	 */ : 
strstr : while : 	 */ : 
str : 	if (usize < sizeof(*attr)) {
strstr : INIT : 	if (usize < sizeof(*attr)) { : 
strstr : if : 	if (usize < sizeof(*attr)) { : 
strstr : for : 	if (usize < sizeof(*attr)) { : 
strstr : while : 	if (usize < sizeof(*attr)) { : 
str : 		unsigned char *addr;
strstr : INIT : 		unsigned char *addr; : 
strstr : if : 		unsigned char *addr; : 
strstr : for : 		unsigned char *addr; : 
strstr : while : 		unsigned char *addr; : 
str : 		unsigned char *end;
strstr : INIT : 		unsigned char *end; : 
strstr : if : 		unsigned char *end; : 
strstr : for : 		unsigned char *end; : 
strstr : while : 		unsigned char *end; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 		addr = (void *)attr + usize;
strstr : if : 		addr = (void *)attr + usize; : 
strstr : for : 		addr = (void *)attr + usize; : 
strstr : while : 		addr = (void *)attr + usize; : 
str : 		end  = (void *)attr + sizeof(*attr);
strstr : INIT : 		end  = (void *)attr + sizeof(*attr); : 
strstr : if : 		end  = (void *)attr + sizeof(*attr); : 
strstr : for : 		end  = (void *)attr + sizeof(*attr); : 
strstr : while : 		end  = (void *)attr + sizeof(*attr); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 		for (; addr < end; addr++) {
strstr : if : 		for (; addr < end; addr++) { : 
strstr : for : 		for (; addr < end; addr++) { : 
strstr : while : 		for (; addr < end; addr++) { : 
str : 			if (*addr)
strstr : INIT : 			if (*addr) : 
strstr : if : 			if (*addr) : 
strstr : for : 			if (*addr) : 
strstr : while : 			if (*addr) : 
str : 				goto err_size;
strstr : INIT : 				goto err_size; : 
strstr : if : 				goto err_size; : 
strstr : for : 				goto err_size; : 
strstr : while : 				goto err_size; : 
str : 		}
strstr : INIT : 		} : 
strstr : if : 		} : 
strstr : for : 		} : 
strstr : while : 		} : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 		attr->size = usize;
strstr : if : 		attr->size = usize; : 
strstr : for : 		attr->size = usize; : 
strstr : while : 		attr->size = usize; : 
str : 	}
strstr : INIT : 	} : 
strstr : if : 	} : 
strstr : for : 	} : 
strstr : while : 	} : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	ret = copy_to_user(uattr, attr, attr->size);
strstr : if : 	ret = copy_to_user(uattr, attr, attr->size); : 
strstr : for : 	ret = copy_to_user(uattr, attr, attr->size); : 
strstr : while : 	ret = copy_to_user(uattr, attr, attr->size); : 
str : 	if (ret)
strstr : INIT : 	if (ret) : 
strstr : if : 	if (ret) : 
strstr : for : 	if (ret) : 
strstr : while : 	if (ret) : 
str : 		return -EFAULT;
strstr : INIT : 		return -EFAULT; : 
strstr : if : 		return -EFAULT; : 
strstr : for : 		return -EFAULT; : 
strstr : while : 		return -EFAULT; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : out:
strstr : if : out: : 
strstr : for : out: : 
strstr : while : out: : 
str : 	return ret;
strstr : INIT : 	return ret; : 
strstr : if : 	return ret; : 
strstr : for : 	return ret; : 
strstr : while : 	return ret; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : err_size:
strstr : if : err_size: : 
strstr : for : err_size: : 
strstr : while : err_size: : 
str : 	ret = -E2BIG;
strstr : INIT : 	ret = -E2BIG; : 
strstr : if : 	ret = -E2BIG; : 
strstr : for : 	ret = -E2BIG; : 
strstr : while : 	ret = -E2BIG; : 
str : 	goto out;
strstr : INIT : 	goto out; : 
strstr : if : 	goto out; : 
strstr : for : 	goto out; : 
strstr : while : 	goto out; : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : /**
strstr : if : /** : 
strstr : for : /** : 
strstr : while : /** : 
str :  * sys_sched_getattr - similar to sched_getparam, but with sched_attr
strstr : INIT :  * sys_sched_getattr - similar to sched_getparam, but with sched_attr : 
strstr : if :  * sys_sched_getattr - similar to sched_getparam, but with sched_attr : 
strstr : for :  * sys_sched_getattr - similar to sched_getparam, but with sched_attr : 
strstr : while :  * sys_sched_getattr - similar to sched_getparam, but with sched_attr : 
str :  * @pid: the pid in question.
strstr : INIT :  * @pid: the pid in question. : 
strstr : if :  * @pid: the pid in question. : 
strstr : for :  * @pid: the pid in question. : 
strstr : while :  * @pid: the pid in question. : 
str :  * @uattr: structure containing the extended parameters.
strstr : INIT :  * @uattr: structure containing the extended parameters. : 
strstr : if :  * @uattr: structure containing the extended parameters. : 
strstr : for :  * @uattr: structure containing the extended parameters. : 
strstr : while :  * @uattr: structure containing the extended parameters. : 
str :  * @size: sizeof(attr) for fwd/bwd comp.
strstr : INIT :  * @size: sizeof(attr) for fwd/bwd comp. : 
strstr : if :  * @size: sizeof(attr) for fwd/bwd comp. : 
strstr : for :  * @size: sizeof(attr) for fwd/bwd comp. : 
strstr : while :  * @size: sizeof(attr) for fwd/bwd comp. : 
str :  */
strstr : INIT :  */ : 
strstr : if :  */ : 
strstr : for :  */ : 
strstr : while :  */ : 
str : SYSCALL_DEFINE4(sched_getattr, pid_t, pid, struct sched_attr __user *, uattr,
strstr : INIT : SYSCALL_DEFINE4(sched_getattr, pid_t, pid, struct sched_attr __user *, uattr, : 
strstr : if : SYSCALL_DEFINE4(sched_getattr, pid_t, pid, struct sched_attr __user *, uattr, : 
strstr : for : SYSCALL_DEFINE4(sched_getattr, pid_t, pid, struct sched_attr __user *, uattr, : 
strstr : while : SYSCALL_DEFINE4(sched_getattr, pid_t, pid, struct sched_attr __user *, uattr, : 
str : 		unsigned int, size, unsigned int, flags)
strstr : INIT : 		unsigned int, size, unsigned int, flags) : 
strstr : if : 		unsigned int, size, unsigned int, flags) : 
strstr : for : 		unsigned int, size, unsigned int, flags) : 
strstr : while : 		unsigned int, size, unsigned int, flags) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	struct sched_attr attr = {
strstr : INIT : 	struct sched_attr attr = { : 
strstr : if : 	struct sched_attr attr = { : 
strstr : for : 	struct sched_attr attr = { : 
strstr : while : 	struct sched_attr attr = { : 
str : 		.size = sizeof(struct sched_attr),
strstr : INIT : 		.size = sizeof(struct sched_attr), : 
strstr : if : 		.size = sizeof(struct sched_attr), : 
strstr : for : 		.size = sizeof(struct sched_attr), : 
strstr : while : 		.size = sizeof(struct sched_attr), : 
str : 	};
strstr : INIT : 	}; : 
strstr : if : 	}; : 
strstr : for : 	}; : 
strstr : while : 	}; : 
str : 	struct task_struct *p;
strstr : INIT : 	struct task_struct *p; : 
strstr : if : 	struct task_struct *p; : 
strstr : for : 	struct task_struct *p; : 
strstr : while : 	struct task_struct *p; : 
str : 	int retval;
strstr : INIT : 	int retval; : 
strstr : if : 	int retval; : 
strstr : for : 	int retval; : 
strstr : while : 	int retval; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	if (!uattr || pid < 0 || size > PAGE_SIZE ||
strstr : if : 	if (!uattr || pid < 0 || size > PAGE_SIZE || : 
strstr : for : 	if (!uattr || pid < 0 || size > PAGE_SIZE || : 
strstr : while : 	if (!uattr || pid < 0 || size > PAGE_SIZE || : 
str : 	    size < SCHED_ATTR_SIZE_VER0 || flags)
strstr : INIT : 	    size < SCHED_ATTR_SIZE_VER0 || flags) : 
strstr : if : 	    size < SCHED_ATTR_SIZE_VER0 || flags) : 
strstr : for : 	    size < SCHED_ATTR_SIZE_VER0 || flags) : 
strstr : while : 	    size < SCHED_ATTR_SIZE_VER0 || flags) : 
str : 		return -EINVAL;
strstr : INIT : 		return -EINVAL; : 
strstr : if : 		return -EINVAL; : 
strstr : for : 		return -EINVAL; : 
strstr : while : 		return -EINVAL; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	rcu_read_lock();
strstr : if : 	rcu_read_lock(); : 
strstr : for : 	rcu_read_lock(); : 
strstr : while : 	rcu_read_lock(); : 
str : 	p = find_process_by_pid(pid);
strstr : INIT : 	p = find_process_by_pid(pid); : 
strstr : if : 	p = find_process_by_pid(pid); : 
strstr : for : 	p = find_process_by_pid(pid); : 
strstr : while : 	p = find_process_by_pid(pid); : 
str : 	retval = -ESRCH;
strstr : INIT : 	retval = -ESRCH; : 
strstr : if : 	retval = -ESRCH; : 
strstr : for : 	retval = -ESRCH; : 
strstr : while : 	retval = -ESRCH; : 
str : 	if (!p)
strstr : INIT : 	if (!p) : 
strstr : if : 	if (!p) : 
strstr : for : 	if (!p) : 
strstr : while : 	if (!p) : 
str : 		goto out_unlock;
strstr : INIT : 		goto out_unlock; : 
strstr : if : 		goto out_unlock; : 
strstr : for : 		goto out_unlock; : 
strstr : while : 		goto out_unlock; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	retval = security_task_getscheduler(p);
strstr : if : 	retval = security_task_getscheduler(p); : 
strstr : for : 	retval = security_task_getscheduler(p); : 
strstr : while : 	retval = security_task_getscheduler(p); : 
str : 	if (retval)
strstr : INIT : 	if (retval) : 
strstr : if : 	if (retval) : 
strstr : for : 	if (retval) : 
strstr : while : 	if (retval) : 
str : 		goto out_unlock;
strstr : INIT : 		goto out_unlock; : 
strstr : if : 		goto out_unlock; : 
strstr : for : 		goto out_unlock; : 
strstr : while : 		goto out_unlock; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	attr.sched_policy = p->policy;
strstr : if : 	attr.sched_policy = p->policy; : 
strstr : for : 	attr.sched_policy = p->policy; : 
strstr : while : 	attr.sched_policy = p->policy; : 
str : 	if (p->sched_reset_on_fork)
strstr : INIT : 	if (p->sched_reset_on_fork) : 
strstr : if : 	if (p->sched_reset_on_fork) : 
strstr : for : 	if (p->sched_reset_on_fork) : 
strstr : while : 	if (p->sched_reset_on_fork) : 
str : 		attr.sched_flags |= SCHED_FLAG_RESET_ON_FORK;
strstr : INIT : 		attr.sched_flags |= SCHED_FLAG_RESET_ON_FORK; : 
strstr : if : 		attr.sched_flags |= SCHED_FLAG_RESET_ON_FORK; : 
strstr : for : 		attr.sched_flags |= SCHED_FLAG_RESET_ON_FORK; : 
strstr : while : 		attr.sched_flags |= SCHED_FLAG_RESET_ON_FORK; : 
str : 	if (task_has_dl_policy(p))
strstr : INIT : 	if (task_has_dl_policy(p)) : 
strstr : if : 	if (task_has_dl_policy(p)) : 
strstr : for : 	if (task_has_dl_policy(p)) : 
strstr : while : 	if (task_has_dl_policy(p)) : 
str : 		__getparam_dl(p, &attr);
strstr : INIT : 		__getparam_dl(p, &attr); : 
strstr : if : 		__getparam_dl(p, &attr); : 
strstr : for : 		__getparam_dl(p, &attr); : 
strstr : while : 		__getparam_dl(p, &attr); : 
str : 	else if (task_has_rt_policy(p))
strstr : INIT : 	else if (task_has_rt_policy(p)) : 
strstr : if : 	else if (task_has_rt_policy(p)) : 
strstr : for : 	else if (task_has_rt_policy(p)) : 
strstr : while : 	else if (task_has_rt_policy(p)) : 
str : 		attr.sched_priority = p->rt_priority;
strstr : INIT : 		attr.sched_priority = p->rt_priority; : 
strstr : if : 		attr.sched_priority = p->rt_priority; : 
strstr : for : 		attr.sched_priority = p->rt_priority; : 
strstr : while : 		attr.sched_priority = p->rt_priority; : 
str : 	else
strstr : INIT : 	else : 
strstr : if : 	else : 
strstr : for : 	else : 
strstr : while : 	else : 
str : 		attr.sched_nice = TASK_NICE(p);
strstr : INIT : 		attr.sched_nice = TASK_NICE(p); : 
strstr : if : 		attr.sched_nice = TASK_NICE(p); : 
strstr : for : 		attr.sched_nice = TASK_NICE(p); : 
strstr : while : 		attr.sched_nice = TASK_NICE(p); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	rcu_read_unlock();
strstr : if : 	rcu_read_unlock(); : 
strstr : for : 	rcu_read_unlock(); : 
strstr : while : 	rcu_read_unlock(); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	retval = sched_read_attr(uattr, &attr, size);
strstr : if : 	retval = sched_read_attr(uattr, &attr, size); : 
strstr : for : 	retval = sched_read_attr(uattr, &attr, size); : 
strstr : while : 	retval = sched_read_attr(uattr, &attr, size); : 
str : 	return retval;
strstr : INIT : 	return retval; : 
strstr : if : 	return retval; : 
strstr : for : 	return retval; : 
strstr : while : 	return retval; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : out_unlock:
strstr : if : out_unlock: : 
strstr : for : out_unlock: : 
strstr : while : out_unlock: : 
str : 	rcu_read_unlock();
strstr : INIT : 	rcu_read_unlock(); : 
strstr : if : 	rcu_read_unlock(); : 
strstr : for : 	rcu_read_unlock(); : 
strstr : while : 	rcu_read_unlock(); : 
str : 	return retval;
strstr : INIT : 	return retval; : 
strstr : if : 	return retval; : 
strstr : for : 	return retval; : 
strstr : while : 	return retval; : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : long sched_setaffinity(pid_t pid, const struct cpumask *in_mask)
strstr : if : long sched_setaffinity(pid_t pid, const struct cpumask *in_mask) : 
strstr : for : long sched_setaffinity(pid_t pid, const struct cpumask *in_mask) : 
strstr : while : long sched_setaffinity(pid_t pid, const struct cpumask *in_mask) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	cpumask_var_t cpus_allowed, new_mask;
strstr : INIT : 	cpumask_var_t cpus_allowed, new_mask; : 
strstr : if : 	cpumask_var_t cpus_allowed, new_mask; : 
strstr : for : 	cpumask_var_t cpus_allowed, new_mask; : 
strstr : while : 	cpumask_var_t cpus_allowed, new_mask; : 
str : 	struct task_struct *p;
strstr : INIT : 	struct task_struct *p; : 
strstr : if : 	struct task_struct *p; : 
strstr : for : 	struct task_struct *p; : 
strstr : while : 	struct task_struct *p; : 
str : 	int retval;
strstr : INIT : 	int retval; : 
strstr : if : 	int retval; : 
strstr : for : 	int retval; : 
strstr : while : 	int retval; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	rcu_read_lock();
strstr : if : 	rcu_read_lock(); : 
strstr : for : 	rcu_read_lock(); : 
strstr : while : 	rcu_read_lock(); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	p = find_process_by_pid(pid);
strstr : if : 	p = find_process_by_pid(pid); : 
strstr : for : 	p = find_process_by_pid(pid); : 
strstr : while : 	p = find_process_by_pid(pid); : 
str : 	if (!p) {
strstr : INIT : 	if (!p) { : 
strstr : if : 	if (!p) { : 
strstr : for : 	if (!p) { : 
strstr : while : 	if (!p) { : 
str : 		rcu_read_unlock();
strstr : INIT : 		rcu_read_unlock(); : 
strstr : if : 		rcu_read_unlock(); : 
strstr : for : 		rcu_read_unlock(); : 
strstr : while : 		rcu_read_unlock(); : 
str : 		return -ESRCH;
strstr : INIT : 		return -ESRCH; : 
strstr : if : 		return -ESRCH; : 
strstr : for : 		return -ESRCH; : 
strstr : while : 		return -ESRCH; : 
str : 	}
strstr : INIT : 	} : 
strstr : if : 	} : 
strstr : for : 	} : 
strstr : while : 	} : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	/* Prevent p going away */
strstr : if : 	/* Prevent p going away */ : 
strstr : for : 	/* Prevent p going away */ : 
strstr : while : 	/* Prevent p going away */ : 
str : 	get_task_struct(p);
strstr : INIT : 	get_task_struct(p); : 
strstr : if : 	get_task_struct(p); : 
strstr : for : 	get_task_struct(p); : 
strstr : while : 	get_task_struct(p); : 
str : 	rcu_read_unlock();
strstr : INIT : 	rcu_read_unlock(); : 
strstr : if : 	rcu_read_unlock(); : 
strstr : for : 	rcu_read_unlock(); : 
strstr : while : 	rcu_read_unlock(); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	if (p->flags & PF_NO_SETAFFINITY) {
strstr : if : 	if (p->flags & PF_NO_SETAFFINITY) { : 
strstr : for : 	if (p->flags & PF_NO_SETAFFINITY) { : 
strstr : while : 	if (p->flags & PF_NO_SETAFFINITY) { : 
str : 		retval = -EINVAL;
strstr : INIT : 		retval = -EINVAL; : 
strstr : if : 		retval = -EINVAL; : 
strstr : for : 		retval = -EINVAL; : 
strstr : while : 		retval = -EINVAL; : 
str : 		goto out_put_task;
strstr : INIT : 		goto out_put_task; : 
strstr : if : 		goto out_put_task; : 
strstr : for : 		goto out_put_task; : 
strstr : while : 		goto out_put_task; : 
str : 	}
strstr : INIT : 	} : 
strstr : if : 	} : 
strstr : for : 	} : 
strstr : while : 	} : 
str : 	if (!alloc_cpumask_var(&cpus_allowed, GFP_KERNEL)) {
strstr : INIT : 	if (!alloc_cpumask_var(&cpus_allowed, GFP_KERNEL)) { : 
strstr : if : 	if (!alloc_cpumask_var(&cpus_allowed, GFP_KERNEL)) { : 
strstr : for : 	if (!alloc_cpumask_var(&cpus_allowed, GFP_KERNEL)) { : 
strstr : while : 	if (!alloc_cpumask_var(&cpus_allowed, GFP_KERNEL)) { : 
str : 		retval = -ENOMEM;
strstr : INIT : 		retval = -ENOMEM; : 
strstr : if : 		retval = -ENOMEM; : 
strstr : for : 		retval = -ENOMEM; : 
strstr : while : 		retval = -ENOMEM; : 
str : 		goto out_put_task;
strstr : INIT : 		goto out_put_task; : 
strstr : if : 		goto out_put_task; : 
strstr : for : 		goto out_put_task; : 
strstr : while : 		goto out_put_task; : 
str : 	}
strstr : INIT : 	} : 
strstr : if : 	} : 
strstr : for : 	} : 
strstr : while : 	} : 
str : 	if (!alloc_cpumask_var(&new_mask, GFP_KERNEL)) {
strstr : INIT : 	if (!alloc_cpumask_var(&new_mask, GFP_KERNEL)) { : 
strstr : if : 	if (!alloc_cpumask_var(&new_mask, GFP_KERNEL)) { : 
strstr : for : 	if (!alloc_cpumask_var(&new_mask, GFP_KERNEL)) { : 
strstr : while : 	if (!alloc_cpumask_var(&new_mask, GFP_KERNEL)) { : 
str : 		retval = -ENOMEM;
strstr : INIT : 		retval = -ENOMEM; : 
strstr : if : 		retval = -ENOMEM; : 
strstr : for : 		retval = -ENOMEM; : 
strstr : while : 		retval = -ENOMEM; : 
str : 		goto out_free_cpus_allowed;
strstr : INIT : 		goto out_free_cpus_allowed; : 
strstr : if : 		goto out_free_cpus_allowed; : 
strstr : for : 		goto out_free_cpus_allowed; : 
strstr : while : 		goto out_free_cpus_allowed; : 
str : 	}
strstr : INIT : 	} : 
strstr : if : 	} : 
strstr : for : 	} : 
strstr : while : 	} : 
str : 	retval = -EPERM;
strstr : INIT : 	retval = -EPERM; : 
strstr : if : 	retval = -EPERM; : 
strstr : for : 	retval = -EPERM; : 
strstr : while : 	retval = -EPERM; : 
str : 	if (!check_same_owner(p)) {
strstr : INIT : 	if (!check_same_owner(p)) { : 
strstr : if : 	if (!check_same_owner(p)) { : 
strstr : for : 	if (!check_same_owner(p)) { : 
strstr : while : 	if (!check_same_owner(p)) { : 
str : 		rcu_read_lock();
strstr : INIT : 		rcu_read_lock(); : 
strstr : if : 		rcu_read_lock(); : 
strstr : for : 		rcu_read_lock(); : 
strstr : while : 		rcu_read_lock(); : 
str : 		if (!ns_capable(__task_cred(p)->user_ns, CAP_SYS_NICE)) {
strstr : INIT : 		if (!ns_capable(__task_cred(p)->user_ns, CAP_SYS_NICE)) { : 
strstr : if : 		if (!ns_capable(__task_cred(p)->user_ns, CAP_SYS_NICE)) { : 
strstr : for : 		if (!ns_capable(__task_cred(p)->user_ns, CAP_SYS_NICE)) { : 
strstr : while : 		if (!ns_capable(__task_cred(p)->user_ns, CAP_SYS_NICE)) { : 
str : 			rcu_read_unlock();
strstr : INIT : 			rcu_read_unlock(); : 
strstr : if : 			rcu_read_unlock(); : 
strstr : for : 			rcu_read_unlock(); : 
strstr : while : 			rcu_read_unlock(); : 
str : 			goto out_unlock;
strstr : INIT : 			goto out_unlock; : 
strstr : if : 			goto out_unlock; : 
strstr : for : 			goto out_unlock; : 
strstr : while : 			goto out_unlock; : 
str : 		}
strstr : INIT : 		} : 
strstr : if : 		} : 
strstr : for : 		} : 
strstr : while : 		} : 
str : 		rcu_read_unlock();
strstr : INIT : 		rcu_read_unlock(); : 
strstr : if : 		rcu_read_unlock(); : 
strstr : for : 		rcu_read_unlock(); : 
strstr : while : 		rcu_read_unlock(); : 
str : 	}
strstr : INIT : 	} : 
strstr : if : 	} : 
strstr : for : 	} : 
strstr : while : 	} : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	retval = security_task_setscheduler(p);
strstr : if : 	retval = security_task_setscheduler(p); : 
strstr : for : 	retval = security_task_setscheduler(p); : 
strstr : while : 	retval = security_task_setscheduler(p); : 
str : 	if (retval)
strstr : INIT : 	if (retval) : 
strstr : if : 	if (retval) : 
strstr : for : 	if (retval) : 
strstr : while : 	if (retval) : 
str : 		goto out_unlock;
strstr : INIT : 		goto out_unlock; : 
strstr : if : 		goto out_unlock; : 
strstr : for : 		goto out_unlock; : 
strstr : while : 		goto out_unlock; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 
strstr : if :  : 
list str ok : if :  : 
str : 	cpuset_cpus_allowed(p, cpus_allowed);
strstr : for : 	cpuset_cpus_allowed(p, cpus_allowed); : 
strstr : while : 	cpuset_cpus_allowed(p, cpus_allowed); : 
str : 	cpumask_and(new_mask, in_mask, cpus_allowed);
strstr : INIT : 	cpumask_and(new_mask, in_mask, cpus_allowed); : 
strstr : if : 	cpumask_and(new_mask, in_mask, cpus_allowed); : 
strstr : for : 	cpumask_and(new_mask, in_mask, cpus_allowed); : 
strstr : while : 	cpumask_and(new_mask, in_mask, cpus_allowed); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	/*
strstr : if : 	/* : 
strstr : for : 	/* : 
strstr : while : 	/* : 
str : 	 * Since bandwidth control happens on root_domain basis,
strstr : INIT : 	 * Since bandwidth control happens on root_domain basis, : 
strstr : if : 	 * Since bandwidth control happens on root_domain basis, : 
strstr : for : 	 * Since bandwidth control happens on root_domain basis, : 
strstr : while : 	 * Since bandwidth control happens on root_domain basis, : 
str : 	 * if admission test is enabled, we only admit -deadline
strstr : INIT : 	 * if admission test is enabled, we only admit -deadline : 
strstr : if : 	 * if admission test is enabled, we only admit -deadline : 
strstr : for : 	 * if admission test is enabled, we only admit -deadline : 
strstr : while : 	 * if admission test is enabled, we only admit -deadline : 
str : 	 * tasks allowed to run on all the CPUs in the task's
strstr : INIT : 	 * tasks allowed to run on all the CPUs in the task's : 
strstr : if : 	 * tasks allowed to run on all the CPUs in the task's : 
strstr : for : 	 * tasks allowed to run on all the CPUs in the task's : 
strstr : while : 	 * tasks allowed to run on all the CPUs in the task's : 
str : 	 * root_domain.
strstr : INIT : 	 * root_domain. : 
strstr : if : 	 * root_domain. : 
strstr : for : 	 * root_domain. : 
strstr : while : 	 * root_domain. : 
str : 	 */
strstr : INIT : 	 */ : 
strstr : if : 	 */ : 
strstr : for : 	 */ : 
strstr : while : 	 */ : 
str : #ifdef CONFIG_SMP
strstr : INIT : #ifdef CONFIG_SMP : 
strstr : if : #ifdef CONFIG_SMP : 
strstr : for : #ifdef CONFIG_SMP : 
strstr : while : #ifdef CONFIG_SMP : 
str : 	if (task_has_dl_policy(p)) {
strstr : INIT : 	if (task_has_dl_policy(p)) { : 
strstr : if : 	if (task_has_dl_policy(p)) { : 
strstr : for : 	if (task_has_dl_policy(p)) { : 
strstr : while : 	if (task_has_dl_policy(p)) { : 
str : 		const struct cpumask *span = task_rq(p)->rd->span;
strstr : INIT : 		const struct cpumask *span = task_rq(p)->rd->span; : 
strstr : if : 		const struct cpumask *span = task_rq(p)->rd->span; : 
strstr : for : 		const struct cpumask *span = task_rq(p)->rd->span; : 
strstr : while : 		const struct cpumask *span = task_rq(p)->rd->span; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 		if (dl_bandwidth_enabled() && !cpumask_subset(span, new_mask)) {
strstr : if : 		if (dl_bandwidth_enabled() && !cpumask_subset(span, new_mask)) { : 
strstr : for : 		if (dl_bandwidth_enabled() && !cpumask_subset(span, new_mask)) { : 
strstr : while : 		if (dl_bandwidth_enabled() && !cpumask_subset(span, new_mask)) { : 
str : 			retval = -EBUSY;
strstr : INIT : 			retval = -EBUSY; : 
strstr : if : 			retval = -EBUSY; : 
strstr : for : 			retval = -EBUSY; : 
strstr : while : 			retval = -EBUSY; : 
str : 			goto out_unlock;
strstr : INIT : 			goto out_unlock; : 
strstr : if : 			goto out_unlock; : 
strstr : for : 			goto out_unlock; : 
strstr : while : 			goto out_unlock; : 
str : 		}
strstr : INIT : 		} : 
strstr : if : 		} : 
strstr : for : 		} : 
strstr : while : 		} : 
str : 	}
strstr : INIT : 	} : 
strstr : if : 	} : 
strstr : for : 	} : 
strstr : while : 	} : 
str : #endif
strstr : INIT : #endif : 
strstr : if : #endif : 
strstr : for : #endif : 
strstr : while : #endif : 
str : again:
strstr : INIT : again: : 
strstr : if : again: : 
strstr : for : again: : 
strstr : while : again: : 
str : 	retval = set_cpus_allowed_ptr(p, new_mask);
strstr : INIT : 	retval = set_cpus_allowed_ptr(p, new_mask); : 
strstr : if : 	retval = set_cpus_allowed_ptr(p, new_mask); : 
strstr : for : 	retval = set_cpus_allowed_ptr(p, new_mask); : 
strstr : while : 	retval = set_cpus_allowed_ptr(p, new_mask); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	if (!retval) {
strstr : if : 	if (!retval) { : 
strstr : for : 	if (!retval) { : 
strstr : while : 	if (!retval) { : 
str : 		cpuset_cpus_allowed(p, cpus_allowed);
strstr : INIT : 		cpuset_cpus_allowed(p, cpus_allowed); : 
strstr : if : 		cpuset_cpus_allowed(p, cpus_allowed); : 
strstr : for : 		cpuset_cpus_allowed(p, cpus_allowed); : 
strstr : while : 		cpuset_cpus_allowed(p, cpus_allowed); : 
str : 		if (!cpumask_subset(new_mask, cpus_allowed)) {
strstr : INIT : 		if (!cpumask_subset(new_mask, cpus_allowed)) { : 
strstr : if : 		if (!cpumask_subset(new_mask, cpus_allowed)) { : 
strstr : for : 		if (!cpumask_subset(new_mask, cpus_allowed)) { : 
strstr : while : 		if (!cpumask_subset(new_mask, cpus_allowed)) { : 
str : 			/*
strstr : INIT : 			/* : 
strstr : if : 			/* : 
strstr : for : 			/* : 
strstr : while : 			/* : 
str : 			 * We must have raced with a concurrent cpuset
strstr : INIT : 			 * We must have raced with a concurrent cpuset : 
strstr : if : 			 * We must have raced with a concurrent cpuset : 
strstr : for : 			 * We must have raced with a concurrent cpuset : 
strstr : while : 			 * We must have raced with a concurrent cpuset : 
str : 			 * update. Just reset the cpus_allowed to the
strstr : INIT : 			 * update. Just reset the cpus_allowed to the : 
strstr : if : 			 * update. Just reset the cpus_allowed to the : 
strstr : for : 			 * update. Just reset the cpus_allowed to the : 
strstr : while : 			 * update. Just reset the cpus_allowed to the : 
str : 			 * cpuset's cpus_allowed
strstr : INIT : 			 * cpuset's cpus_allowed : 
strstr : if : 			 * cpuset's cpus_allowed : 
strstr : for : 			 * cpuset's cpus_allowed : 
strstr : while : 			 * cpuset's cpus_allowed : 
str : 			 */
strstr : INIT : 			 */ : 
strstr : if : 			 */ : 
strstr : for : 			 */ : 
strstr : while : 			 */ : 
str : 			cpumask_copy(new_mask, cpus_allowed);
strstr : INIT : 			cpumask_copy(new_mask, cpus_allowed); : 
strstr : if : 			cpumask_copy(new_mask, cpus_allowed); : 
strstr : for : 			cpumask_copy(new_mask, cpus_allowed); : 
strstr : while : 			cpumask_copy(new_mask, cpus_allowed); : 
str : 			goto again;
strstr : INIT : 			goto again; : 
strstr : if : 			goto again; : 
strstr : for : 			goto again; : 
strstr : while : 			goto again; : 
str : 		}
strstr : INIT : 		} : 
strstr : if : 		} : 
strstr : for : 		} : 
strstr : while : 		} : 
str : 	}
strstr : INIT : 	} : 
strstr : if : 	} : 
strstr : for : 	} : 
strstr : while : 	} : 
str : out_unlock:
strstr : INIT : out_unlock: : 
strstr : if : out_unlock: : 
strstr : for : out_unlock: : 
strstr : while : out_unlock: : 
str : 	free_cpumask_var(new_mask);
strstr : INIT : 	free_cpumask_var(new_mask); : 
strstr : if : 	free_cpumask_var(new_mask); : 
strstr : for : 	free_cpumask_var(new_mask); : 
strstr : while : 	free_cpumask_var(new_mask); : 
str : out_free_cpus_allowed:
strstr : INIT : out_free_cpus_allowed: : 
strstr : if : out_free_cpus_allowed: : 
strstr : for : out_free_cpus_allowed: : 
strstr : while : out_free_cpus_allowed: : 
str : 	free_cpumask_var(cpus_allowed);
strstr : INIT : 	free_cpumask_var(cpus_allowed); : 
strstr : if : 	free_cpumask_var(cpus_allowed); : 
strstr : for : 	free_cpumask_var(cpus_allowed); : 
strstr : while : 	free_cpumask_var(cpus_allowed); : 
str : out_put_task:
strstr : INIT : out_put_task: : 
strstr : if : out_put_task: : 
strstr : for : out_put_task: : 
strstr : while : out_put_task: : 
str : 	put_task_struct(p);
strstr : INIT : 	put_task_struct(p); : 
strstr : if : 	put_task_struct(p); : 
strstr : for : 	put_task_struct(p); : 
strstr : while : 	put_task_struct(p); : 
str : 	return retval;
strstr : INIT : 	return retval; : 
strstr : if : 	return retval; : 
strstr : for : 	return retval; : 
strstr : while : 	return retval; : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : static int get_user_cpu_mask(unsigned long __user *user_mask_ptr, unsigned len,
strstr : if : static int get_user_cpu_mask(unsigned long __user *user_mask_ptr, unsigned len, : 
strstr : for : static int get_user_cpu_mask(unsigned long __user *user_mask_ptr, unsigned len, : 
strstr : while : static int get_user_cpu_mask(unsigned long __user *user_mask_ptr, unsigned len, : 
str : 			     struct cpumask *new_mask)
strstr : INIT : 			     struct cpumask *new_mask) : 
strstr : if : 			     struct cpumask *new_mask) : 
strstr : for : 			     struct cpumask *new_mask) : 
strstr : while : 			     struct cpumask *new_mask) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	if (len < cpumask_size())
strstr : INIT : 	if (len < cpumask_size()) : 
strstr : if : 	if (len < cpumask_size()) : 
strstr : for : 	if (len < cpumask_size()) : 
strstr : while : 	if (len < cpumask_size()) : 
str : 		cpumask_clear(new_mask);
strstr : INIT : 		cpumask_clear(new_mask); : 
strstr : if : 		cpumask_clear(new_mask); : 
strstr : for : 		cpumask_clear(new_mask); : 
strstr : while : 		cpumask_clear(new_mask); : 
str : 	else if (len > cpumask_size())
strstr : INIT : 	else if (len > cpumask_size()) : 
strstr : if : 	else if (len > cpumask_size()) : 
strstr : for : 	else if (len > cpumask_size()) : 
strstr : while : 	else if (len > cpumask_size()) : 
str : 		len = cpumask_size();
strstr : INIT : 		len = cpumask_size(); : 
strstr : if : 		len = cpumask_size(); : 
strstr : for : 		len = cpumask_size(); : 
strstr : while : 		len = cpumask_size(); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	return copy_from_user(new_mask, user_mask_ptr, len) ? -EFAULT : 0;
strstr : if : 	return copy_from_user(new_mask, user_mask_ptr, len) ? -EFAULT : 0; : 
strstr : for : 	return copy_from_user(new_mask, user_mask_ptr, len) ? -EFAULT : 0; : 
strstr : while : 	return copy_from_user(new_mask, user_mask_ptr, len) ? -EFAULT : 0; : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : /**
strstr : if : /** : 
strstr : for : /** : 
strstr : while : /** : 
str :  * sys_sched_setaffinity - set the cpu affinity of a process
strstr : INIT :  * sys_sched_setaffinity - set the cpu affinity of a process : 
strstr : if :  * sys_sched_setaffinity - set the cpu affinity of a process : 
strstr : for :  * sys_sched_setaffinity - set the cpu affinity of a process : 
strstr : while :  * sys_sched_setaffinity - set the cpu affinity of a process : 
str :  * @pid: pid of the process
strstr : INIT :  * @pid: pid of the process : 
strstr : if :  * @pid: pid of the process : 
strstr : for :  * @pid: pid of the process : 
strstr : while :  * @pid: pid of the process : 
str :  * @len: length in bytes of the bitmask pointed to by user_mask_ptr
strstr : INIT :  * @len: length in bytes of the bitmask pointed to by user_mask_ptr : 
strstr : if :  * @len: length in bytes of the bitmask pointed to by user_mask_ptr : 
strstr : for :  * @len: length in bytes of the bitmask pointed to by user_mask_ptr : 
strstr : while :  * @len: length in bytes of the bitmask pointed to by user_mask_ptr : 
str :  * @user_mask_ptr: user-space pointer to the new cpu mask
strstr : INIT :  * @user_mask_ptr: user-space pointer to the new cpu mask : 
strstr : if :  * @user_mask_ptr: user-space pointer to the new cpu mask : 
strstr : for :  * @user_mask_ptr: user-space pointer to the new cpu mask : 
strstr : while :  * @user_mask_ptr: user-space pointer to the new cpu mask : 
str :  *
strstr : INIT :  * : 
strstr : if :  * : 
strstr : for :  * : 
strstr : while :  * : 
str :  * Return: 0 on success. An error code otherwise.
strstr : INIT :  * Return: 0 on success. An error code otherwise. : 
strstr : if :  * Return: 0 on success. An error code otherwise. : 
strstr : for :  * Return: 0 on success. An error code otherwise. : 
strstr : while :  * Return: 0 on success. An error code otherwise. : 
str :  */
strstr : INIT :  */ : 
strstr : if :  */ : 
strstr : for :  */ : 
strstr : while :  */ : 
str : SYSCALL_DEFINE3(sched_setaffinity, pid_t, pid, unsigned int, len,
strstr : INIT : SYSCALL_DEFINE3(sched_setaffinity, pid_t, pid, unsigned int, len, : 
strstr : if : SYSCALL_DEFINE3(sched_setaffinity, pid_t, pid, unsigned int, len, : 
strstr : for : SYSCALL_DEFINE3(sched_setaffinity, pid_t, pid, unsigned int, len, : 
strstr : while : SYSCALL_DEFINE3(sched_setaffinity, pid_t, pid, unsigned int, len, : 
str : 		unsigned long __user *, user_mask_ptr)
strstr : INIT : 		unsigned long __user *, user_mask_ptr) : 
strstr : if : 		unsigned long __user *, user_mask_ptr) : 
strstr : for : 		unsigned long __user *, user_mask_ptr) : 
strstr : while : 		unsigned long __user *, user_mask_ptr) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	cpumask_var_t new_mask;
strstr : INIT : 	cpumask_var_t new_mask; : 
strstr : if : 	cpumask_var_t new_mask; : 
strstr : for : 	cpumask_var_t new_mask; : 
strstr : while : 	cpumask_var_t new_mask; : 
str : 	int retval;
strstr : INIT : 	int retval; : 
strstr : if : 	int retval; : 
strstr : for : 	int retval; : 
strstr : while : 	int retval; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	if (!alloc_cpumask_var(&new_mask, GFP_KERNEL))
strstr : if : 	if (!alloc_cpumask_var(&new_mask, GFP_KERNEL)) : 
strstr : for : 	if (!alloc_cpumask_var(&new_mask, GFP_KERNEL)) : 
strstr : while : 	if (!alloc_cpumask_var(&new_mask, GFP_KERNEL)) : 
str : 		return -ENOMEM;
strstr : INIT : 		return -ENOMEM; : 
strstr : if : 		return -ENOMEM; : 
strstr : for : 		return -ENOMEM; : 
strstr : while : 		return -ENOMEM; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	retval = get_user_cpu_mask(user_mask_ptr, len, new_mask);
strstr : if : 	retval = get_user_cpu_mask(user_mask_ptr, len, new_mask); : 
strstr : for : 	retval = get_user_cpu_mask(user_mask_ptr, len, new_mask); : 
strstr : while : 	retval = get_user_cpu_mask(user_mask_ptr, len, new_mask); : 
str : 	if (retval == 0)
strstr : INIT : 	if (retval == 0) : 
strstr : if : 	if (retval == 0) : 
strstr : for : 	if (retval == 0) : 
strstr : while : 	if (retval == 0) : 
str : 		retval = sched_setaffinity(pid, new_mask);
strstr : INIT : 		retval = sched_setaffinity(pid, new_mask); : 
strstr : if : 		retval = sched_setaffinity(pid, new_mask); : 
strstr : for : 		retval = sched_setaffinity(pid, new_mask); : 
strstr : while : 		retval = sched_setaffinity(pid, new_mask); : 
str : 	free_cpumask_var(new_mask);
strstr : INIT : 	free_cpumask_var(new_mask); : 
strstr : if : 	free_cpumask_var(new_mask); : 
strstr : for : 	free_cpumask_var(new_mask); : 
strstr : while : 	free_cpumask_var(new_mask); : 
str : 	return retval;
strstr : INIT : 	return retval; : 
strstr : if : 	return retval; : 
strstr : for : 	return retval; : 
strstr : while : 	return retval; : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : long sched_getaffinity(pid_t pid, struct cpumask *mask)
strstr : if : long sched_getaffinity(pid_t pid, struct cpumask *mask) : 
strstr : for : long sched_getaffinity(pid_t pid, struct cpumask *mask) : 
strstr : while : long sched_getaffinity(pid_t pid, struct cpumask *mask) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	struct task_struct *p;
strstr : INIT : 	struct task_struct *p; : 
strstr : if : 	struct task_struct *p; : 
strstr : for : 	struct task_struct *p; : 
strstr : while : 	struct task_struct *p; : 
str : 	unsigned long flags;
strstr : INIT : 	unsigned long flags; : 
strstr : if : 	unsigned long flags; : 
strstr : for : 	unsigned long flags; : 
strstr : while : 	unsigned long flags; : 
str : 	int retval;
strstr : INIT : 	int retval; : 
strstr : if : 	int retval; : 
strstr : for : 	int retval; : 
strstr : while : 	int retval; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	rcu_read_lock();
strstr : if : 	rcu_read_lock(); : 
strstr : for : 	rcu_read_lock(); : 
strstr : while : 	rcu_read_lock(); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	retval = -ESRCH;
strstr : if : 	retval = -ESRCH; : 
strstr : for : 	retval = -ESRCH; : 
strstr : while : 	retval = -ESRCH; : 
str : 	p = find_process_by_pid(pid);
strstr : INIT : 	p = find_process_by_pid(pid); : 
strstr : if : 	p = find_process_by_pid(pid); : 
strstr : for : 	p = find_process_by_pid(pid); : 
strstr : while : 	p = find_process_by_pid(pid); : 
str : 	if (!p)
strstr : INIT : 	if (!p) : 
strstr : if : 	if (!p) : 
strstr : for : 	if (!p) : 
strstr : while : 	if (!p) : 
str : 		goto out_unlock;
strstr : INIT : 		goto out_unlock; : 
strstr : if : 		goto out_unlock; : 
strstr : for : 		goto out_unlock; : 
strstr : while : 		goto out_unlock; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	retval = security_task_getscheduler(p);
strstr : if : 	retval = security_task_getscheduler(p); : 
strstr : for : 	retval = security_task_getscheduler(p); : 
strstr : while : 	retval = security_task_getscheduler(p); : 
str : 	if (retval)
strstr : INIT : 	if (retval) : 
strstr : if : 	if (retval) : 
strstr : for : 	if (retval) : 
strstr : while : 	if (retval) : 
str : 		goto out_unlock;
strstr : INIT : 		goto out_unlock; : 
strstr : if : 		goto out_unlock; : 
strstr : for : 		goto out_unlock; : 
strstr : while : 		goto out_unlock; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	raw_spin_lock_irqsave(&p->pi_lock, flags);
strstr : if : 	raw_spin_lock_irqsave(&p->pi_lock, flags); : 
strstr : for : 	raw_spin_lock_irqsave(&p->pi_lock, flags); : 
strstr : while : 	raw_spin_lock_irqsave(&p->pi_lock, flags); : 
str : 	cpumask_and(mask, &p->cpus_allowed, cpu_active_mask);
strstr : INIT : 	cpumask_and(mask, &p->cpus_allowed, cpu_active_mask); : 
strstr : if : 	cpumask_and(mask, &p->cpus_allowed, cpu_active_mask); : 
strstr : for : 	cpumask_and(mask, &p->cpus_allowed, cpu_active_mask); : 
strstr : while : 	cpumask_and(mask, &p->cpus_allowed, cpu_active_mask); : 
str : 	raw_spin_unlock_irqrestore(&p->pi_lock, flags);
strstr : INIT : 	raw_spin_unlock_irqrestore(&p->pi_lock, flags); : 
strstr : if : 	raw_spin_unlock_irqrestore(&p->pi_lock, flags); : 
strstr : for : 	raw_spin_unlock_irqrestore(&p->pi_lock, flags); : 
strstr : while : 	raw_spin_unlock_irqrestore(&p->pi_lock, flags); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : out_unlock:
strstr : if : out_unlock: : 
strstr : for : out_unlock: : 
strstr : while : out_unlock: : 
str : 	rcu_read_unlock();
strstr : INIT : 	rcu_read_unlock(); : 
strstr : if : 	rcu_read_unlock(); : 
strstr : for : 	rcu_read_unlock(); : 
strstr : while : 	rcu_read_unlock(); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	return retval;
strstr : if : 	return retval; : 
strstr : for : 	return retval; : 
strstr : while : 	return retval; : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : /**
strstr : if : /** : 
strstr : for : /** : 
strstr : while : /** : 
str :  * sys_sched_getaffinity - get the cpu affinity of a process
strstr : INIT :  * sys_sched_getaffinity - get the cpu affinity of a process : 
strstr : if :  * sys_sched_getaffinity - get the cpu affinity of a process : 
strstr : for :  * sys_sched_getaffinity - get the cpu affinity of a process : 
strstr : while :  * sys_sched_getaffinity - get the cpu affinity of a process : 
str :  * @pid: pid of the process
strstr : INIT :  * @pid: pid of the process : 
strstr : if :  * @pid: pid of the process : 
strstr : for :  * @pid: pid of the process : 
strstr : while :  * @pid: pid of the process : 
str :  * @len: length in bytes of the bitmask pointed to by user_mask_ptr
strstr : INIT :  * @len: length in bytes of the bitmask pointed to by user_mask_ptr : 
strstr : if :  * @len: length in bytes of the bitmask pointed to by user_mask_ptr : 
strstr : for :  * @len: length in bytes of the bitmask pointed to by user_mask_ptr : 
strstr : while :  * @len: length in bytes of the bitmask pointed to by user_mask_ptr : 
str :  * @user_mask_ptr: user-space pointer to hold the current cpu mask
strstr : INIT :  * @user_mask_ptr: user-space pointer to hold the current cpu mask : 
strstr : if :  * @user_mask_ptr: user-space pointer to hold the current cpu mask : 
strstr : for :  * @user_mask_ptr: user-space pointer to hold the current cpu mask : 
strstr : while :  * @user_mask_ptr: user-space pointer to hold the current cpu mask : 
str :  *
strstr : INIT :  * : 
strstr : if :  * : 
strstr : for :  * : 
strstr : while :  * : 
str :  * Return: 0 on success. An error code otherwise.
strstr : INIT :  * Return: 0 on success. An error code otherwise. : 
strstr : if :  * Return: 0 on success. An error code otherwise. : 
strstr : for :  * Return: 0 on success. An error code otherwise. : 
strstr : while :  * Return: 0 on success. An error code otherwise. : 
str :  */
strstr : INIT :  */ : 
strstr : if :  */ : 
strstr : for :  */ : 
strstr : while :  */ : 
str : SYSCALL_DEFINE3(sched_getaffinity, pid_t, pid, unsigned int, len,
strstr : INIT : SYSCALL_DEFINE3(sched_getaffinity, pid_t, pid, unsigned int, len, : 
strstr : if : SYSCALL_DEFINE3(sched_getaffinity, pid_t, pid, unsigned int, len, : 
strstr : for : SYSCALL_DEFINE3(sched_getaffinity, pid_t, pid, unsigned int, len, : 
strstr : while : SYSCALL_DEFINE3(sched_getaffinity, pid_t, pid, unsigned int, len, : 
str : 		unsigned long __user *, user_mask_ptr)
strstr : INIT : 		unsigned long __user *, user_mask_ptr) : 
strstr : if : 		unsigned long __user *, user_mask_ptr) : 
strstr : for : 		unsigned long __user *, user_mask_ptr) : 
strstr : while : 		unsigned long __user *, user_mask_ptr) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	int ret;
strstr : INIT : 	int ret; : 
strstr : if : 	int ret; : 
strstr : for : 	int ret; : 
strstr : while : 	int ret; : 
str : 	cpumask_var_t mask;
strstr : INIT : 	cpumask_var_t mask; : 
strstr : if : 	cpumask_var_t mask; : 
strstr : for : 	cpumask_var_t mask; : 
strstr : while : 	cpumask_var_t mask; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	if ((len * BITS_PER_BYTE) < nr_cpu_ids)
strstr : if : 	if ((len * BITS_PER_BYTE) < nr_cpu_ids) : 
strstr : for : 	if ((len * BITS_PER_BYTE) < nr_cpu_ids) : 
strstr : while : 	if ((len * BITS_PER_BYTE) < nr_cpu_ids) : 
str : 		return -EINVAL;
strstr : INIT : 		return -EINVAL; : 
strstr : if : 		return -EINVAL; : 
strstr : for : 		return -EINVAL; : 
strstr : while : 		return -EINVAL; : 
str : 	if (len & (sizeof(unsigned long)-1))
strstr : INIT : 	if (len & (sizeof(unsigned long)-1)) : 
strstr : if : 	if (len & (sizeof(unsigned long)-1)) : 
strstr : for : 	if (len & (sizeof(unsigned long)-1)) : 
strstr : while : 	if (len & (sizeof(unsigned long)-1)) : 
str : 		return -EINVAL;
strstr : INIT : 		return -EINVAL; : 
strstr : if : 		return -EINVAL; : 
strstr : for : 		return -EINVAL; : 
strstr : while : 		return -EINVAL; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	if (!alloc_cpumask_var(&mask, GFP_KERNEL))
strstr : if : 	if (!alloc_cpumask_var(&mask, GFP_KERNEL)) : 
strstr : for : 	if (!alloc_cpumask_var(&mask, GFP_KERNEL)) : 
strstr : while : 	if (!alloc_cpumask_var(&mask, GFP_KERNEL)) : 
str : 		return -ENOMEM;
strstr : INIT : 		return -ENOMEM; : 
strstr : if : 		return -ENOMEM; : 
strstr : for : 		return -ENOMEM; : 
strstr : while : 		return -ENOMEM; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	ret = sched_getaffinity(pid, mask);
strstr : if : 	ret = sched_getaffinity(pid, mask); : 
strstr : for : 	ret = sched_getaffinity(pid, mask); : 
strstr : while : 	ret = sched_getaffinity(pid, mask); : 
str : 	if (ret == 0) {
strstr : INIT : 	if (ret == 0) { : 
strstr : if : 	if (ret == 0) { : 
strstr : for : 	if (ret == 0) { : 
strstr : while : 	if (ret == 0) { : 
str : 		size_t retlen = min_t(size_t, len, cpumask_size());
strstr : INIT : 		size_t retlen = min_t(size_t, len, cpumask_size()); : 
strstr : if : 		size_t retlen = min_t(size_t, len, cpumask_size()); : 
strstr : for : 		size_t retlen = min_t(size_t, len, cpumask_size()); : 
strstr : while : 		size_t retlen = min_t(size_t, len, cpumask_size()); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 		if (copy_to_user(user_mask_ptr, mask, retlen))
strstr : if : 		if (copy_to_user(user_mask_ptr, mask, retlen)) : 
strstr : for : 		if (copy_to_user(user_mask_ptr, mask, retlen)) : 
strstr : while : 		if (copy_to_user(user_mask_ptr, mask, retlen)) : 
str : 			ret = -EFAULT;
strstr : INIT : 			ret = -EFAULT; : 
strstr : if : 			ret = -EFAULT; : 
strstr : for : 			ret = -EFAULT; : 
strstr : while : 			ret = -EFAULT; : 
str : 		else
strstr : INIT : 		else : 
strstr : if : 		else : 
strstr : for : 		else : 
strstr : while : 		else : 
str : 			ret = retlen;
strstr : INIT : 			ret = retlen; : 
strstr : if : 			ret = retlen; : 
strstr : for : 			ret = retlen; : 
strstr : while : 			ret = retlen; : 
str : 	}
strstr : INIT : 	} : 
strstr : if : 	} : 
strstr : for : 	} : 
strstr : while : 	} : 
str : 	free_cpumask_var(mask);
strstr : INIT : 	free_cpumask_var(mask); : 
strstr : if : 	free_cpumask_var(mask); : 
strstr : for : 	free_cpumask_var(mask); : 
strstr : while : 	free_cpumask_var(mask); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	return ret;
strstr : if : 	return ret; : 
strstr : for : 	return ret; : 
strstr : while : 	return ret; : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : /**
strstr : if : /** : 
strstr : for : /** : 
strstr : while : /** : 
str :  * sys_sched_yield - yield the current processor to other threads.
strstr : INIT :  * sys_sched_yield - yield the current processor to other threads. : 
strstr : if :  * sys_sched_yield - yield the current processor to other threads. : 
strstr : for :  * sys_sched_yield - yield the current processor to other threads. : 
strstr : while :  * sys_sched_yield - yield the current processor to other threads. : 
str :  *
strstr : INIT :  * : 
strstr : if :  * : 
strstr : for :  * : 
strstr : while :  * : 
str :  * This function yields the current CPU to other tasks. If there are no
strstr : INIT :  * This function yields the current CPU to other tasks. If there are no : 
strstr : if :  * This function yields the current CPU to other tasks. If there are no : 
strstr : for :  * This function yields the current CPU to other tasks. If there are no : 
strstr : while :  * This function yields the current CPU to other tasks. If there are no : 
str :  * other threads running on this CPU then this function will return.
strstr : INIT :  * other threads running on this CPU then this function will return. : 
strstr : if :  * other threads running on this CPU then this function will return. : 
strstr : for :  * other threads running on this CPU then this function will return. : 
strstr : while :  * other threads running on this CPU then this function will return. : 
str :  *
strstr : INIT :  * : 
strstr : if :  * : 
strstr : for :  * : 
strstr : while :  * : 
str :  * Return: 0.
strstr : INIT :  * Return: 0. : 
strstr : if :  * Return: 0. : 
strstr : for :  * Return: 0. : 
strstr : while :  * Return: 0. : 
str :  */
strstr : INIT :  */ : 
strstr : if :  */ : 
strstr : for :  */ : 
strstr : while :  */ : 
str : SYSCALL_DEFINE0(sched_yield)
strstr : INIT : SYSCALL_DEFINE0(sched_yield) : 
strstr : if : SYSCALL_DEFINE0(sched_yield) : 
strstr : for : SYSCALL_DEFINE0(sched_yield) : 
strstr : while : SYSCALL_DEFINE0(sched_yield) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	struct rq *rq = this_rq_lock();
strstr : INIT : 	struct rq *rq = this_rq_lock(); : 
strstr : if : 	struct rq *rq = this_rq_lock(); : 
strstr : for : 	struct rq *rq = this_rq_lock(); : 
strstr : while : 	struct rq *rq = this_rq_lock(); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	schedstat_inc(rq, yld_count);
strstr : if : 	schedstat_inc(rq, yld_count); : 
strstr : for : 	schedstat_inc(rq, yld_count); : 
strstr : while : 	schedstat_inc(rq, yld_count); : 
str : 	current->sched_class->yield_task(rq);
strstr : INIT : 	current->sched_class->yield_task(rq); : 
strstr : if : 	current->sched_class->yield_task(rq); : 
strstr : for : 	current->sched_class->yield_task(rq); : 
strstr : while : 	current->sched_class->yield_task(rq); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	/*
strstr : if : 	/* : 
strstr : for : 	/* : 
strstr : while : 	/* : 
str : 	 * Since we are going to call schedule() anyway, there's
strstr : INIT : 	 * Since we are going to call schedule() anyway, there's : 
strstr : if : 	 * Since we are going to call schedule() anyway, there's : 
strstr : for : 	 * Since we are going to call schedule() anyway, there's : 
strstr : while : 	 * Since we are going to call schedule() anyway, there's : 
str : 	 * no need to preempt or enable interrupts:
strstr : INIT : 	 * no need to preempt or enable interrupts: : 
strstr : if : 	 * no need to preempt or enable interrupts: : 
strstr : for : 	 * no need to preempt or enable interrupts: : 
strstr : while : 	 * no need to preempt or enable interrupts: : 
str : 	 */
strstr : INIT : 	 */ : 
strstr : if : 	 */ : 
strstr : for : 	 */ : 
strstr : while : 	 */ : 
str : 	__release(rq->lock);
strstr : INIT : 	__release(rq->lock); : 
strstr : if : 	__release(rq->lock); : 
strstr : for : 	__release(rq->lock); : 
strstr : while : 	__release(rq->lock); : 
str : 	spin_release(&rq->lock.dep_map, 1, _THIS_IP_);
strstr : INIT : 	spin_release(&rq->lock.dep_map, 1, _THIS_IP_); : 
strstr : if : 	spin_release(&rq->lock.dep_map, 1, _THIS_IP_); : 
strstr : for : 	spin_release(&rq->lock.dep_map, 1, _THIS_IP_); : 
strstr : while : 	spin_release(&rq->lock.dep_map, 1, _THIS_IP_); : 
str : 	do_raw_spin_unlock(&rq->lock);
strstr : INIT : 	do_raw_spin_unlock(&rq->lock); : 
strstr : if : 	do_raw_spin_unlock(&rq->lock); : 
strstr : for : 	do_raw_spin_unlock(&rq->lock); : 
strstr : while : 	do_raw_spin_unlock(&rq->lock); : 
str : 	sched_preempt_enable_no_resched();
strstr : INIT : 	sched_preempt_enable_no_resched(); : 
strstr : if : 	sched_preempt_enable_no_resched(); : 
strstr : for : 	sched_preempt_enable_no_resched(); : 
strstr : while : 	sched_preempt_enable_no_resched(); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	schedule();
strstr : if : 	schedule(); : 
strstr : for : 	schedule(); : 
strstr : while : 	schedule(); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	return 0;
strstr : if : 	return 0; : 
strstr : for : 	return 0; : 
strstr : while : 	return 0; : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : static void __cond_resched(void)
strstr : if : static void __cond_resched(void) : 
strstr : for : static void __cond_resched(void) : 
strstr : while : static void __cond_resched(void) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	__preempt_count_add(PREEMPT_ACTIVE);
strstr : INIT : 	__preempt_count_add(PREEMPT_ACTIVE); : 
strstr : if : 	__preempt_count_add(PREEMPT_ACTIVE); : 
strstr : for : 	__preempt_count_add(PREEMPT_ACTIVE); : 
strstr : while : 	__preempt_count_add(PREEMPT_ACTIVE); : 
str : 	__schedule();
strstr : INIT : 	__schedule(); : 
strstr : if : 	__schedule(); : 
strstr : for : 	__schedule(); : 
strstr : while : 	__schedule(); : 
str : 	__preempt_count_sub(PREEMPT_ACTIVE);
strstr : INIT : 	__preempt_count_sub(PREEMPT_ACTIVE); : 
strstr : if : 	__preempt_count_sub(PREEMPT_ACTIVE); : 
strstr : for : 	__preempt_count_sub(PREEMPT_ACTIVE); : 
strstr : while : 	__preempt_count_sub(PREEMPT_ACTIVE); : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : int __sched _cond_resched(void)
strstr : if : int __sched _cond_resched(void) : 
strstr : for : int __sched _cond_resched(void) : 
strstr : while : int __sched _cond_resched(void) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	if (should_resched()) {
strstr : INIT : 	if (should_resched()) { : 
strstr : if : 	if (should_resched()) { : 
strstr : for : 	if (should_resched()) { : 
strstr : while : 	if (should_resched()) { : 
str : 		__cond_resched();
strstr : INIT : 		__cond_resched(); : 
strstr : if : 		__cond_resched(); : 
strstr : for : 		__cond_resched(); : 
strstr : while : 		__cond_resched(); : 
str : 		return 1;
strstr : INIT : 		return 1; : 
strstr : if : 		return 1; : 
strstr : for : 		return 1; : 
strstr : while : 		return 1; : 
str : 	}
strstr : INIT : 	} : 
strstr : if : 	} : 
strstr : for : 	} : 
strstr : while : 	} : 
str : 	return 0;
strstr : INIT : 	return 0; : 
strstr : if : 	return 0; : 
strstr : for : 	return 0; : 
strstr : while : 	return 0; : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : EXPORT_SYMBOL(_cond_resched);
strstr : INIT : EXPORT_SYMBOL(_cond_resched); : 
strstr : if : EXPORT_SYMBOL(_cond_resched); : 
strstr : for : EXPORT_SYMBOL(_cond_resched); : 
strstr : while : EXPORT_SYMBOL(_cond_resched); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : /*
strstr : if : /* : 
strstr : for : /* : 
strstr : while : /* : 
str :  * __cond_resched_lock() - if a reschedule is pending, drop the given lock,
strstr : INIT :  * __cond_resched_lock() - if a reschedule is pending, drop the given lock, : 
strstr : if :  * __cond_resched_lock() - if a reschedule is pending, drop the given lock, : 
strstr : for :  * __cond_resched_lock() - if a reschedule is pending, drop the given lock, : 
strstr : while :  * __cond_resched_lock() - if a reschedule is pending, drop the given lock, : 
str :  * call schedule, and on return reacquire the lock.
strstr : INIT :  * call schedule, and on return reacquire the lock. : 
strstr : if :  * call schedule, and on return reacquire the lock. : 
strstr : for :  * call schedule, and on return reacquire the lock. : 
strstr : while :  * call schedule, and on return reacquire the lock. : 
str :  *
strstr : INIT :  * : 
strstr : if :  * : 
strstr : for :  * : 
strstr : while :  * : 
str :  * This works OK both with and without CONFIG_PREEMPT. We do strange low-level
strstr : INIT :  * This works OK both with and without CONFIG_PREEMPT. We do strange low-level : 
strstr : if :  * This works OK both with and without CONFIG_PREEMPT. We do strange low-level : 
strstr : for :  * This works OK both with and without CONFIG_PREEMPT. We do strange low-level : 
strstr : while :  * This works OK both with and without CONFIG_PREEMPT. We do strange low-level : 
str :  * operations here to prevent schedule() from being called twice (once via
strstr : INIT :  * operations here to prevent schedule() from being called twice (once via : 
strstr : if :  * operations here to prevent schedule() from being called twice (once via : 
strstr : for :  * operations here to prevent schedule() from being called twice (once via : 
strstr : while :  * operations here to prevent schedule() from being called twice (once via : 
str :  * spin_unlock(), once by hand).
strstr : INIT :  * spin_unlock(), once by hand). : 
strstr : if :  * spin_unlock(), once by hand). : 
strstr : for :  * spin_unlock(), once by hand). : 
strstr : while :  * spin_unlock(), once by hand). : 
str :  */
strstr : INIT :  */ : 
strstr : if :  */ : 
strstr : for :  */ : 
strstr : while :  */ : 
str : int __cond_resched_lock(spinlock_t *lock)
strstr : INIT : int __cond_resched_lock(spinlock_t *lock) : 
strstr : if : int __cond_resched_lock(spinlock_t *lock) : 
strstr : for : int __cond_resched_lock(spinlock_t *lock) : 
strstr : while : int __cond_resched_lock(spinlock_t *lock) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	int resched = should_resched();
strstr : INIT : 	int resched = should_resched(); : 
strstr : if : 	int resched = should_resched(); : 
strstr : for : 	int resched = should_resched(); : 
strstr : while : 	int resched = should_resched(); : 
str : 	int ret = 0;
strstr : INIT : 	int ret = 0; : 
strstr : if : 	int ret = 0; : 
strstr : for : 	int ret = 0; : 
strstr : while : 	int ret = 0; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	lockdep_assert_held(lock);
strstr : if : 	lockdep_assert_held(lock); : 
strstr : for : 	lockdep_assert_held(lock); : 
strstr : while : 	lockdep_assert_held(lock); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	if (spin_needbreak(lock) || resched) {
strstr : if : 	if (spin_needbreak(lock) || resched) { : 
strstr : for : 	if (spin_needbreak(lock) || resched) { : 
strstr : while : 	if (spin_needbreak(lock) || resched) { : 
str : 		spin_unlock(lock);
strstr : INIT : 		spin_unlock(lock); : 
strstr : if : 		spin_unlock(lock); : 
strstr : for : 		spin_unlock(lock); : 
strstr : while : 		spin_unlock(lock); : 
str : 		if (resched)
strstr : INIT : 		if (resched) : 
strstr : if : 		if (resched) : 
strstr : for : 		if (resched) : 
strstr : while : 		if (resched) : 
str : 			__cond_resched();
strstr : INIT : 			__cond_resched(); : 
strstr : if : 			__cond_resched(); : 
strstr : for : 			__cond_resched(); : 
strstr : while : 			__cond_resched(); : 
str : 		else
strstr : INIT : 		else : 
strstr : if : 		else : 
strstr : for : 		else : 
strstr : while : 		else : 
str : 			cpu_relax();
strstr : INIT : 			cpu_relax(); : 
strstr : if : 			cpu_relax(); : 
strstr : for : 			cpu_relax(); : 
strstr : while : 			cpu_relax(); : 
str : 		ret = 1;
strstr : INIT : 		ret = 1; : 
strstr : if : 		ret = 1; : 
strstr : for : 		ret = 1; : 
strstr : while : 		ret = 1; : 
str : 		spin_lock(lock);
strstr : INIT : 		spin_lock(lock); : 
strstr : if : 		spin_lock(lock); : 
strstr : for : 		spin_lock(lock); : 
strstr : while : 		spin_lock(lock); : 
str : 	}
strstr : INIT : 	} : 
strstr : if : 	} : 
strstr : for : 	} : 
strstr : while : 	} : 
str : 	return ret;
strstr : INIT : 	return ret; : 
strstr : if : 	return ret; : 
strstr : for : 	return ret; : 
strstr : while : 	return ret; : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : EXPORT_SYMBOL(__cond_resched_lock);
strstr : INIT : EXPORT_SYMBOL(__cond_resched_lock); : 
strstr : if : EXPORT_SYMBOL(__cond_resched_lock); : 
strstr : for : EXPORT_SYMBOL(__cond_resched_lock); : 
strstr : while : EXPORT_SYMBOL(__cond_resched_lock); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : int __sched __cond_resched_softirq(void)
strstr : if : int __sched __cond_resched_softirq(void) : 
strstr : for : int __sched __cond_resched_softirq(void) : 
strstr : while : int __sched __cond_resched_softirq(void) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	BUG_ON(!in_softirq());
strstr : INIT : 	BUG_ON(!in_softirq()); : 
strstr : if : 	BUG_ON(!in_softirq()); : 
strstr : for : 	BUG_ON(!in_softirq()); : 
strstr : while : 	BUG_ON(!in_softirq()); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	if (should_resched()) {
strstr : if : 	if (should_resched()) { : 
strstr : for : 	if (should_resched()) { : 
strstr : while : 	if (should_resched()) { : 
str : 		local_bh_enable();
strstr : INIT : 		local_bh_enable(); : 
strstr : if : 		local_bh_enable(); : 
strstr : for : 		local_bh_enable(); : 
strstr : while : 		local_bh_enable(); : 
str : 		__cond_resched();
strstr : INIT : 		__cond_resched(); : 
strstr : if : 		__cond_resched(); : 
strstr : for : 		__cond_resched(); : 
strstr : while : 		__cond_resched(); : 
str : 		local_bh_disable();
strstr : INIT : 		local_bh_disable(); : 
strstr : if : 		local_bh_disable(); : 
strstr : for : 		local_bh_disable(); : 
strstr : while : 		local_bh_disable(); : 
str : 		return 1;
strstr : INIT : 		return 1; : 
strstr : if : 		return 1; : 
strstr : for : 		return 1; : 
strstr : while : 		return 1; : 
str : 	}
strstr : INIT : 	} : 
strstr : if : 	} : 
strstr : for : 	} : 
strstr : while : 	} : 
str : 	return 0;
strstr : INIT : 	return 0; : 
strstr : if : 	return 0; : 
strstr : for : 	return 0; : 
strstr : while : 	return 0; : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : EXPORT_SYMBOL(__cond_resched_softirq);
strstr : INIT : EXPORT_SYMBOL(__cond_resched_softirq); : 
strstr : if : EXPORT_SYMBOL(__cond_resched_softirq); : 
strstr : for : EXPORT_SYMBOL(__cond_resched_softirq); : 
strstr : while : EXPORT_SYMBOL(__cond_resched_softirq); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : /**
strstr : if : /** : 
strstr : for : /** : 
strstr : while : /** : 
str :  * yield - yield the current processor to other threads.
strstr : INIT :  * yield - yield the current processor to other threads. : 
strstr : if :  * yield - yield the current processor to other threads. : 
strstr : for :  * yield - yield the current processor to other threads. : 
strstr : while :  * yield - yield the current processor to other threads. : 
str :  *
strstr : INIT :  * : 
strstr : if :  * : 
strstr : for :  * : 
strstr : while :  * : 
str :  * Do not ever use this function, there's a 99% chance you're doing it wrong.
strstr : INIT :  * Do not ever use this function, there's a 99% chance you're doing it wrong. : 
strstr : if :  * Do not ever use this function, there's a 99% chance you're doing it wrong. : 
strstr : for :  * Do not ever use this function, there's a 99% chance you're doing it wrong. : 
strstr : while :  * Do not ever use this function, there's a 99% chance you're doing it wrong. : 
str :  *
strstr : INIT :  * : 
strstr : if :  * : 
strstr : for :  * : 
strstr : while :  * : 
str :  * The scheduler is at all times free to pick the calling task as the most
strstr : INIT :  * The scheduler is at all times free to pick the calling task as the most : 
strstr : if :  * The scheduler is at all times free to pick the calling task as the most : 
strstr : for :  * The scheduler is at all times free to pick the calling task as the most : 
strstr : while :  * The scheduler is at all times free to pick the calling task as the most : 
str :  * eligible task to run, if removing the yield() call from your code breaks
strstr : INIT :  * eligible task to run, if removing the yield() call from your code breaks : 
strstr : if :  * eligible task to run, if removing the yield() call from your code breaks : 
strstr : for :  * eligible task to run, if removing the yield() call from your code breaks : 
strstr : while :  * eligible task to run, if removing the yield() call from your code breaks : 
str :  * it, its already broken.
strstr : INIT :  * it, its already broken. : 
strstr : if :  * it, its already broken. : 
strstr : for :  * it, its already broken. : 
strstr : while :  * it, its already broken. : 
str :  *
strstr : INIT :  * : 
strstr : if :  * : 
strstr : for :  * : 
strstr : while :  * : 
str :  * Typical broken usage is:
strstr : INIT :  * Typical broken usage is: : 
strstr : if :  * Typical broken usage is: : 
strstr : for :  * Typical broken usage is: : 
strstr : while :  * Typical broken usage is: : 
str :  *
strstr : INIT :  * : 
strstr : if :  * : 
strstr : for :  * : 
strstr : while :  * : 
str :  * while (!event)
strstr : INIT :  * while (!event) : 
strstr : if :  * while (!event) : 
strstr : for :  * while (!event) : 
strstr : while :  * while (!event) : 
str :  * 	yield();
strstr : INIT :  * 	yield(); : 
strstr : if :  * 	yield(); : 
strstr : for :  * 	yield(); : 
strstr : while :  * 	yield(); : 
str :  *
strstr : INIT :  * : 
strstr : if :  * : 
strstr : for :  * : 
strstr : while :  * : 
str :  * where one assumes that yield() will let 'the other' process run that will
strstr : INIT :  * where one assumes that yield() will let 'the other' process run that will : 
strstr : if :  * where one assumes that yield() will let 'the other' process run that will : 
strstr : for :  * where one assumes that yield() will let 'the other' process run that will : 
strstr : while :  * where one assumes that yield() will let 'the other' process run that will : 
str :  * make event true. If the current task is a SCHED_FIFO task that will never
strstr : INIT :  * make event true. If the current task is a SCHED_FIFO task that will never : 
strstr : if :  * make event true. If the current task is a SCHED_FIFO task that will never : 
strstr : for :  * make event true. If the current task is a SCHED_FIFO task that will never : 
strstr : while :  * make event true. If the current task is a SCHED_FIFO task that will never : 
str :  * happen. Never use yield() as a progress guarantee!!
strstr : INIT :  * happen. Never use yield() as a progress guarantee!! : 
strstr : if :  * happen. Never use yield() as a progress guarantee!! : 
strstr : for :  * happen. Never use yield() as a progress guarantee!! : 
strstr : while :  * happen. Never use yield() as a progress guarantee!! : 
str :  *
strstr : INIT :  * : 
strstr : if :  * : 
strstr : for :  * : 
strstr : while :  * : 
str :  * If you want to use yield() to wait for something, use wait_event().
strstr : INIT :  * If you want to use yield() to wait for something, use wait_event(). : 
strstr : if :  * If you want to use yield() to wait for something, use wait_event(). : 
strstr : for :  * If you want to use yield() to wait for something, use wait_event(). : 
strstr : while :  * If you want to use yield() to wait for something, use wait_event(). : 
str :  * If you want to use yield() to be 'nice' for others, use cond_resched().
strstr : INIT :  * If you want to use yield() to be 'nice' for others, use cond_resched(). : 
strstr : if :  * If you want to use yield() to be 'nice' for others, use cond_resched(). : 
strstr : for :  * If you want to use yield() to be 'nice' for others, use cond_resched(). : 
strstr : while :  * If you want to use yield() to be 'nice' for others, use cond_resched(). : 
str :  * If you still want to use yield(), do not!
strstr : INIT :  * If you still want to use yield(), do not! : 
strstr : if :  * If you still want to use yield(), do not! : 
strstr : for :  * If you still want to use yield(), do not! : 
strstr : while :  * If you still want to use yield(), do not! : 
str :  */
strstr : INIT :  */ : 
strstr : if :  */ : 
strstr : for :  */ : 
strstr : while :  */ : 
str : void __sched yield(void)
strstr : INIT : void __sched yield(void) : 
strstr : if : void __sched yield(void) : 
strstr : for : void __sched yield(void) : 
strstr : while : void __sched yield(void) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	set_current_state(TASK_RUNNING);
strstr : INIT : 	set_current_state(TASK_RUNNING); : 
strstr : if : 	set_current_state(TASK_RUNNING); : 
strstr : for : 	set_current_state(TASK_RUNNING); : 
strstr : while : 	set_current_state(TASK_RUNNING); : 
str : 	sys_sched_yield();
strstr : INIT : 	sys_sched_yield(); : 
strstr : if : 	sys_sched_yield(); : 
strstr : for : 	sys_sched_yield(); : 
strstr : while : 	sys_sched_yield(); : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : EXPORT_SYMBOL(yield);
strstr : INIT : EXPORT_SYMBOL(yield); : 
strstr : if : EXPORT_SYMBOL(yield); : 
strstr : for : EXPORT_SYMBOL(yield); : 
strstr : while : EXPORT_SYMBOL(yield); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : /**
strstr : if : /** : 
strstr : for : /** : 
strstr : while : /** : 
str :  * yield_to - yield the current processor to another thread in
strstr : INIT :  * yield_to - yield the current processor to another thread in : 
strstr : if :  * yield_to - yield the current processor to another thread in : 
strstr : for :  * yield_to - yield the current processor to another thread in : 
strstr : while :  * yield_to - yield the current processor to another thread in : 
str :  * your thread group, or accelerate that thread toward the
strstr : INIT :  * your thread group, or accelerate that thread toward the : 
strstr : if :  * your thread group, or accelerate that thread toward the : 
strstr : for :  * your thread group, or accelerate that thread toward the : 
strstr : while :  * your thread group, or accelerate that thread toward the : 
str :  * processor it's on.
strstr : INIT :  * processor it's on. : 
strstr : if :  * processor it's on. : 
strstr : for :  * processor it's on. : 
strstr : while :  * processor it's on. : 
str :  * @p: target task
strstr : INIT :  * @p: target task : 
strstr : if :  * @p: target task : 
strstr : for :  * @p: target task : 
strstr : while :  * @p: target task : 
str :  * @preempt: whether task preemption is allowed or not
strstr : INIT :  * @preempt: whether task preemption is allowed or not : 
strstr : if :  * @preempt: whether task preemption is allowed or not : 
strstr : for :  * @preempt: whether task preemption is allowed or not : 
strstr : while :  * @preempt: whether task preemption is allowed or not : 
str :  *
strstr : INIT :  * : 
strstr : if :  * : 
strstr : for :  * : 
strstr : while :  * : 
str :  * It's the caller's job to ensure that the target task struct
strstr : INIT :  * It's the caller's job to ensure that the target task struct : 
strstr : if :  * It's the caller's job to ensure that the target task struct : 
strstr : for :  * It's the caller's job to ensure that the target task struct : 
strstr : while :  * It's the caller's job to ensure that the target task struct : 
str :  * can't go away on us before we can do any checks.
strstr : INIT :  * can't go away on us before we can do any checks. : 
strstr : if :  * can't go away on us before we can do any checks. : 
strstr : for :  * can't go away on us before we can do any checks. : 
strstr : while :  * can't go away on us before we can do any checks. : 
str :  *
strstr : INIT :  * : 
strstr : if :  * : 
strstr : for :  * : 
strstr : while :  * : 
str :  * Return:
strstr : INIT :  * Return: : 
strstr : if :  * Return: : 
strstr : for :  * Return: : 
strstr : while :  * Return: : 
str :  *	true (>0) if we indeed boosted the target task.
strstr : INIT :  *	true (>0) if we indeed boosted the target task. : 
strstr : if :  *	true (>0) if we indeed boosted the target task. : 
strstr : for :  *	true (>0) if we indeed boosted the target task. : 
strstr : while :  *	true (>0) if we indeed boosted the target task. : 
str :  *	false (0) if we failed to boost the target.
strstr : INIT :  *	false (0) if we failed to boost the target. : 
strstr : if :  *	false (0) if we failed to boost the target. : 
strstr : for :  *	false (0) if we failed to boost the target. : 
strstr : while :  *	false (0) if we failed to boost the target. : 
str :  *	-ESRCH if there's no task to yield to.
strstr : INIT :  *	-ESRCH if there's no task to yield to. : 
strstr : if :  *	-ESRCH if there's no task to yield to. : 
strstr : for :  *	-ESRCH if there's no task to yield to. : 
strstr : while :  *	-ESRCH if there's no task to yield to. : 
str :  */
strstr : INIT :  */ : 
strstr : if :  */ : 
strstr : for :  */ : 
strstr : while :  */ : 
str : bool __sched yield_to(struct task_struct *p, bool preempt)
strstr : INIT : bool __sched yield_to(struct task_struct *p, bool preempt) : 
strstr : if : bool __sched yield_to(struct task_struct *p, bool preempt) : 
strstr : for : bool __sched yield_to(struct task_struct *p, bool preempt) : 
strstr : while : bool __sched yield_to(struct task_struct *p, bool preempt) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	struct task_struct *curr = current;
strstr : INIT : 	struct task_struct *curr = current; : 
strstr : if : 	struct task_struct *curr = current; : 
strstr : for : 	struct task_struct *curr = current; : 
strstr : while : 	struct task_struct *curr = current; : 
str : 	struct rq *rq, *p_rq;
strstr : INIT : 	struct rq *rq, *p_rq; : 
strstr : if : 	struct rq *rq, *p_rq; : 
strstr : for : 	struct rq *rq, *p_rq; : 
strstr : while : 	struct rq *rq, *p_rq; : 
str : 	unsigned long flags;
strstr : INIT : 	unsigned long flags; : 
strstr : if : 	unsigned long flags; : 
strstr : for : 	unsigned long flags; : 
strstr : while : 	unsigned long flags; : 
str : 	int yielded = 0;
strstr : INIT : 	int yielded = 0; : 
strstr : if : 	int yielded = 0; : 
strstr : for : 	int yielded = 0; : 
strstr : while : 	int yielded = 0; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	local_irq_save(flags);
strstr : if : 	local_irq_save(flags); : 
strstr : for : 	local_irq_save(flags); : 
strstr : while : 	local_irq_save(flags); : 
str : 	rq = this_rq();
strstr : INIT : 	rq = this_rq(); : 
strstr : if : 	rq = this_rq(); : 
strstr : for : 	rq = this_rq(); : 
strstr : while : 	rq = this_rq(); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : again:
strstr : if : again: : 
strstr : for : again: : 
strstr : while : again: : 
str : 	p_rq = task_rq(p);
strstr : INIT : 	p_rq = task_rq(p); : 
strstr : if : 	p_rq = task_rq(p); : 
strstr : for : 	p_rq = task_rq(p); : 
strstr : while : 	p_rq = task_rq(p); : 
str : 	/*
strstr : INIT : 	/* : 
strstr : if : 	/* : 
strstr : for : 	/* : 
strstr : while : 	/* : 
str : 	 * If we're the only runnable task on the rq and target rq also
strstr : INIT : 	 * If we're the only runnable task on the rq and target rq also : 
strstr : if : 	 * If we're the only runnable task on the rq and target rq also : 
strstr : for : 	 * If we're the only runnable task on the rq and target rq also : 
strstr : while : 	 * If we're the only runnable task on the rq and target rq also : 
str : 	 * has only one task, there's absolutely no point in yielding.
strstr : INIT : 	 * has only one task, there's absolutely no point in yielding. : 
strstr : if : 	 * has only one task, there's absolutely no point in yielding. : 
strstr : for : 	 * has only one task, there's absolutely no point in yielding. : 
strstr : while : 	 * has only one task, there's absolutely no point in yielding. : 
str : 	 */
strstr : INIT : 	 */ : 
strstr : if : 	 */ : 
strstr : for : 	 */ : 
strstr : while : 	 */ : 
str : 	if (rq->nr_running == 1 && p_rq->nr_running == 1) {
strstr : INIT : 	if (rq->nr_running == 1 && p_rq->nr_running == 1) { : 
strstr : if : 	if (rq->nr_running == 1 && p_rq->nr_running == 1) { : 
strstr : for : 	if (rq->nr_running == 1 && p_rq->nr_running == 1) { : 
strstr : while : 	if (rq->nr_running == 1 && p_rq->nr_running == 1) { : 
str : 		yielded = -ESRCH;
strstr : INIT : 		yielded = -ESRCH; : 
strstr : if : 		yielded = -ESRCH; : 
strstr : for : 		yielded = -ESRCH; : 
strstr : while : 		yielded = -ESRCH; : 
str : 		goto out_irq;
strstr : INIT : 		goto out_irq; : 
strstr : if : 		goto out_irq; : 
strstr : for : 		goto out_irq; : 
strstr : while : 		goto out_irq; : 
str : 	}
strstr : INIT : 	} : 
strstr : if : 	} : 
strstr : for : 	} : 
strstr : while : 	} : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	double_rq_lock(rq, p_rq);
strstr : if : 	double_rq_lock(rq, p_rq); : 
strstr : for : 	double_rq_lock(rq, p_rq); : 
strstr : while : 	double_rq_lock(rq, p_rq); : 
str : 	if (task_rq(p) != p_rq) {
strstr : INIT : 	if (task_rq(p) != p_rq) { : 
strstr : if : 	if (task_rq(p) != p_rq) { : 
strstr : for : 	if (task_rq(p) != p_rq) { : 
strstr : while : 	if (task_rq(p) != p_rq) { : 
str : 		double_rq_unlock(rq, p_rq);
strstr : INIT : 		double_rq_unlock(rq, p_rq); : 
strstr : if : 		double_rq_unlock(rq, p_rq); : 
strstr : for : 		double_rq_unlock(rq, p_rq); : 
strstr : while : 		double_rq_unlock(rq, p_rq); : 
str : 		goto again;
strstr : INIT : 		goto again; : 
strstr : if : 		goto again; : 
strstr : for : 		goto again; : 
strstr : while : 		goto again; : 
str : 	}
strstr : INIT : 	} : 
strstr : if : 	} : 
strstr : for : 	} : 
strstr : while : 	} : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	if (!curr->sched_class->yield_to_task)
strstr : if : 	if (!curr->sched_class->yield_to_task) : 
strstr : for : 	if (!curr->sched_class->yield_to_task) : 
strstr : while : 	if (!curr->sched_class->yield_to_task) : 
str : 		goto out_unlock;
strstr : INIT : 		goto out_unlock; : 
strstr : if : 		goto out_unlock; : 
strstr : for : 		goto out_unlock; : 
strstr : while : 		goto out_unlock; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	if (curr->sched_class != p->sched_class)
strstr : if : 	if (curr->sched_class != p->sched_class) : 
strstr : for : 	if (curr->sched_class != p->sched_class) : 
strstr : while : 	if (curr->sched_class != p->sched_class) : 
str : 		goto out_unlock;
strstr : INIT : 		goto out_unlock; : 
strstr : if : 		goto out_unlock; : 
strstr : for : 		goto out_unlock; : 
strstr : while : 		goto out_unlock; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	if (task_running(p_rq, p) || p->state)
strstr : if : 	if (task_running(p_rq, p) || p->state) : 
strstr : for : 	if (task_running(p_rq, p) || p->state) : 
strstr : while : 	if (task_running(p_rq, p) || p->state) : 
str : 		goto out_unlock;
strstr : INIT : 		goto out_unlock; : 
strstr : if : 		goto out_unlock; : 
strstr : for : 		goto out_unlock; : 
strstr : while : 		goto out_unlock; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	yielded = curr->sched_class->yield_to_task(rq, p, preempt);
strstr : if : 	yielded = curr->sched_class->yield_to_task(rq, p, preempt); : 
strstr : for : 	yielded = curr->sched_class->yield_to_task(rq, p, preempt); : 
strstr : while : 	yielded = curr->sched_class->yield_to_task(rq, p, preempt); : 
str : 	if (yielded) {
strstr : INIT : 	if (yielded) { : 
strstr : if : 	if (yielded) { : 
strstr : for : 	if (yielded) { : 
strstr : while : 	if (yielded) { : 
str : 		schedstat_inc(rq, yld_count);
strstr : INIT : 		schedstat_inc(rq, yld_count); : 
strstr : if : 		schedstat_inc(rq, yld_count); : 
strstr : for : 		schedstat_inc(rq, yld_count); : 
strstr : while : 		schedstat_inc(rq, yld_count); : 
str : 		/*
strstr : INIT : 		/* : 
strstr : if : 		/* : 
strstr : for : 		/* : 
strstr : while : 		/* : 
str : 		 * Make p's CPU reschedule; pick_next_entity takes care of
strstr : INIT : 		 * Make p's CPU reschedule; pick_next_entity takes care of : 
strstr : if : 		 * Make p's CPU reschedule; pick_next_entity takes care of : 
strstr : for : 		 * Make p's CPU reschedule; pick_next_entity takes care of : 
strstr : while : 		 * Make p's CPU reschedule; pick_next_entity takes care of : 
str : 		 * fairness.
strstr : INIT : 		 * fairness. : 
strstr : if : 		 * fairness. : 
strstr : for : 		 * fairness. : 
strstr : while : 		 * fairness. : 
str : 		 */
strstr : INIT : 		 */ : 
strstr : if : 		 */ : 
strstr : for : 		 */ : 
strstr : while : 		 */ : 
str : 		if (preempt && rq != p_rq)
strstr : INIT : 		if (preempt && rq != p_rq) : 
strstr : if : 		if (preempt && rq != p_rq) : 
strstr : for : 		if (preempt && rq != p_rq) : 
strstr : while : 		if (preempt && rq != p_rq) : 
str : 			resched_task(p_rq->curr);
strstr : INIT : 			resched_task(p_rq->curr); : 
strstr : if : 			resched_task(p_rq->curr); : 
strstr : for : 			resched_task(p_rq->curr); : 
strstr : while : 			resched_task(p_rq->curr); : 
str : 	}
strstr : INIT : 	} : 
strstr : if : 	} : 
strstr : for : 	} : 
strstr : while : 	} : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : out_unlock:
strstr : if : out_unlock: : 
strstr : for : out_unlock: : 
strstr : while : out_unlock: : 
str : 	double_rq_unlock(rq, p_rq);
strstr : INIT : 	double_rq_unlock(rq, p_rq); : 
strstr : if : 	double_rq_unlock(rq, p_rq); : 
strstr : for : 	double_rq_unlock(rq, p_rq); : 
strstr : while : 	double_rq_unlock(rq, p_rq); : 
str : out_irq:
strstr : INIT : out_irq: : 
strstr : if : out_irq: : 
strstr : for : out_irq: : 
strstr : while : out_irq: : 
str : 	local_irq_restore(flags);
strstr : INIT : 	local_irq_restore(flags); : 
strstr : if : 	local_irq_restore(flags); : 
strstr : for : 	local_irq_restore(flags); : 
strstr : while : 	local_irq_restore(flags); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	if (yielded > 0)
strstr : if : 	if (yielded > 0) : 
strstr : for : 	if (yielded > 0) : 
strstr : while : 	if (yielded > 0) : 
str : 		schedule();
strstr : INIT : 		schedule(); : 
strstr : if : 		schedule(); : 
strstr : for : 		schedule(); : 
strstr : while : 		schedule(); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	return yielded;
strstr : if : 	return yielded; : 
strstr : for : 	return yielded; : 
strstr : while : 	return yielded; : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : EXPORT_SYMBOL_GPL(yield_to);
strstr : INIT : EXPORT_SYMBOL_GPL(yield_to); : 
strstr : if : EXPORT_SYMBOL_GPL(yield_to); : 
strstr : for : EXPORT_SYMBOL_GPL(yield_to); : 
strstr : while : EXPORT_SYMBOL_GPL(yield_to); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : /*
strstr : if : /* : 
strstr : for : /* : 
strstr : while : /* : 
str :  * This task is about to go to sleep on IO. Increment rq->nr_iowait so
strstr : INIT :  * This task is about to go to sleep on IO. Increment rq->nr_iowait so : 
strstr : if :  * This task is about to go to sleep on IO. Increment rq->nr_iowait so : 
strstr : for :  * This task is about to go to sleep on IO. Increment rq->nr_iowait so : 
strstr : while :  * This task is about to go to sleep on IO. Increment rq->nr_iowait so : 
str :  * that process accounting knows that this is a task in IO wait state.
strstr : INIT :  * that process accounting knows that this is a task in IO wait state. : 
strstr : if :  * that process accounting knows that this is a task in IO wait state. : 
strstr : for :  * that process accounting knows that this is a task in IO wait state. : 
strstr : while :  * that process accounting knows that this is a task in IO wait state. : 
str :  */
strstr : INIT :  */ : 
strstr : if :  */ : 
strstr : for :  */ : 
strstr : while :  */ : 
str : void __sched io_schedule(void)
strstr : INIT : void __sched io_schedule(void) : 
strstr : if : void __sched io_schedule(void) : 
strstr : for : void __sched io_schedule(void) : 
strstr : while : void __sched io_schedule(void) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	struct rq *rq = raw_rq();
strstr : INIT : 	struct rq *rq = raw_rq(); : 
strstr : if : 	struct rq *rq = raw_rq(); : 
strstr : for : 	struct rq *rq = raw_rq(); : 
strstr : while : 	struct rq *rq = raw_rq(); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	delayacct_blkio_start();
strstr : if : 	delayacct_blkio_start(); : 
strstr : for : 	delayacct_blkio_start(); : 
strstr : while : 	delayacct_blkio_start(); : 
str : 	atomic_inc(&rq->nr_iowait);
strstr : INIT : 	atomic_inc(&rq->nr_iowait); : 
strstr : if : 	atomic_inc(&rq->nr_iowait); : 
strstr : for : 	atomic_inc(&rq->nr_iowait); : 
strstr : while : 	atomic_inc(&rq->nr_iowait); : 
str : 	blk_flush_plug(current);
strstr : INIT : 	blk_flush_plug(current); : 
strstr : if : 	blk_flush_plug(current); : 
strstr : for : 	blk_flush_plug(current); : 
strstr : while : 	blk_flush_plug(current); : 
str : 	current->in_iowait = 1;
strstr : INIT : 	current->in_iowait = 1; : 
strstr : if : 	current->in_iowait = 1; : 
strstr : for : 	current->in_iowait = 1; : 
strstr : while : 	current->in_iowait = 1; : 
str : 	schedule();
strstr : INIT : 	schedule(); : 
strstr : if : 	schedule(); : 
strstr : for : 	schedule(); : 
strstr : while : 	schedule(); : 
str : 	current->in_iowait = 0;
strstr : INIT : 	current->in_iowait = 0; : 
strstr : if : 	current->in_iowait = 0; : 
strstr : for : 	current->in_iowait = 0; : 
strstr : while : 	current->in_iowait = 0; : 
str : 	atomic_dec(&rq->nr_iowait);
strstr : INIT : 	atomic_dec(&rq->nr_iowait); : 
strstr : if : 	atomic_dec(&rq->nr_iowait); : 
strstr : for : 	atomic_dec(&rq->nr_iowait); : 
strstr : while : 	atomic_dec(&rq->nr_iowait); : 
str : 	delayacct_blkio_end();
strstr : INIT : 	delayacct_blkio_end(); : 
strstr : if : 	delayacct_blkio_end(); : 
strstr : for : 	delayacct_blkio_end(); : 
strstr : while : 	delayacct_blkio_end(); : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : EXPORT_SYMBOL(io_schedule);
strstr : INIT : EXPORT_SYMBOL(io_schedule); : 
strstr : if : EXPORT_SYMBOL(io_schedule); : 
strstr : for : EXPORT_SYMBOL(io_schedule); : 
strstr : while : EXPORT_SYMBOL(io_schedule); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : long __sched io_schedule_timeout(long timeout)
strstr : if : long __sched io_schedule_timeout(long timeout) : 
strstr : for : long __sched io_schedule_timeout(long timeout) : 
strstr : while : long __sched io_schedule_timeout(long timeout) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	struct rq *rq = raw_rq();
strstr : INIT : 	struct rq *rq = raw_rq(); : 
strstr : if : 	struct rq *rq = raw_rq(); : 
strstr : for : 	struct rq *rq = raw_rq(); : 
strstr : while : 	struct rq *rq = raw_rq(); : 
str : 	long ret;
strstr : INIT : 	long ret; : 
strstr : if : 	long ret; : 
strstr : for : 	long ret; : 
strstr : while : 	long ret; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	delayacct_blkio_start();
strstr : if : 	delayacct_blkio_start(); : 
strstr : for : 	delayacct_blkio_start(); : 
strstr : while : 	delayacct_blkio_start(); : 
str : 	atomic_inc(&rq->nr_iowait);
strstr : INIT : 	atomic_inc(&rq->nr_iowait); : 
strstr : if : 	atomic_inc(&rq->nr_iowait); : 
strstr : for : 	atomic_inc(&rq->nr_iowait); : 
strstr : while : 	atomic_inc(&rq->nr_iowait); : 
str : 	blk_flush_plug(current);
strstr : INIT : 	blk_flush_plug(current); : 
strstr : if : 	blk_flush_plug(current); : 
strstr : for : 	blk_flush_plug(current); : 
strstr : while : 	blk_flush_plug(current); : 
str : 	current->in_iowait = 1;
strstr : INIT : 	current->in_iowait = 1; : 
strstr : if : 	current->in_iowait = 1; : 
strstr : for : 	current->in_iowait = 1; : 
strstr : while : 	current->in_iowait = 1; : 
str : 	ret = schedule_timeout(timeout);
strstr : INIT : 	ret = schedule_timeout(timeout); : 
strstr : if : 	ret = schedule_timeout(timeout); : 
strstr : for : 	ret = schedule_timeout(timeout); : 
strstr : while : 	ret = schedule_timeout(timeout); : 
str : 	current->in_iowait = 0;
strstr : INIT : 	current->in_iowait = 0; : 
strstr : if : 	current->in_iowait = 0; : 
strstr : for : 	current->in_iowait = 0; : 
strstr : while : 	current->in_iowait = 0; : 
str : 	atomic_dec(&rq->nr_iowait);
strstr : INIT : 	atomic_dec(&rq->nr_iowait); : 
strstr : if : 	atomic_dec(&rq->nr_iowait); : 
strstr : for : 	atomic_dec(&rq->nr_iowait); : 
strstr : while : 	atomic_dec(&rq->nr_iowait); : 
str : 	delayacct_blkio_end();
strstr : INIT : 	delayacct_blkio_end(); : 
strstr : if : 	delayacct_blkio_end(); : 
strstr : for : 	delayacct_blkio_end(); : 
strstr : while : 	delayacct_blkio_end(); : 
str : 	return ret;
strstr : INIT : 	return ret; : 
strstr : if : 	return ret; : 
strstr : for : 	return ret; : 
strstr : while : 	return ret; : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : /**
strstr : if : /** : 
strstr : for : /** : 
strstr : while : /** : 
str :  * sys_sched_get_priority_max - return maximum RT priority.
strstr : INIT :  * sys_sched_get_priority_max - return maximum RT priority. : 
strstr : if :  * sys_sched_get_priority_max - return maximum RT priority. : 
strstr : for :  * sys_sched_get_priority_max - return maximum RT priority. : 
strstr : while :  * sys_sched_get_priority_max - return maximum RT priority. : 
str :  * @policy: scheduling class.
strstr : INIT :  * @policy: scheduling class. : 
strstr : if :  * @policy: scheduling class. : 
strstr : for :  * @policy: scheduling class. : 
strstr : while :  * @policy: scheduling class. : 
str :  *
strstr : INIT :  * : 
strstr : if :  * : 
strstr : for :  * : 
strstr : while :  * : 
str :  * Return: On success, this syscall returns the maximum
strstr : INIT :  * Return: On success, this syscall returns the maximum : 
strstr : if :  * Return: On success, this syscall returns the maximum : 
strstr : for :  * Return: On success, this syscall returns the maximum : 
strstr : while :  * Return: On success, this syscall returns the maximum : 
str :  * rt_priority that can be used by a given scheduling class.
strstr : INIT :  * rt_priority that can be used by a given scheduling class. : 
strstr : if :  * rt_priority that can be used by a given scheduling class. : 
strstr : for :  * rt_priority that can be used by a given scheduling class. : 
strstr : while :  * rt_priority that can be used by a given scheduling class. : 
str :  * On failure, a negative error code is returned.
strstr : INIT :  * On failure, a negative error code is returned. : 
strstr : if :  * On failure, a negative error code is returned. : 
strstr : for :  * On failure, a negative error code is returned. : 
strstr : while :  * On failure, a negative error code is returned. : 
str :  */
strstr : INIT :  */ : 
strstr : if :  */ : 
strstr : for :  */ : 
strstr : while :  */ : 
str : SYSCALL_DEFINE1(sched_get_priority_max, int, policy)
strstr : INIT : SYSCALL_DEFINE1(sched_get_priority_max, int, policy) : 
strstr : if : SYSCALL_DEFINE1(sched_get_priority_max, int, policy) : 
strstr : for : SYSCALL_DEFINE1(sched_get_priority_max, int, policy) : 
strstr : while : SYSCALL_DEFINE1(sched_get_priority_max, int, policy) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	int ret = -EINVAL;
strstr : INIT : 	int ret = -EINVAL; : 
strstr : if : 	int ret = -EINVAL; : 
strstr : for : 	int ret = -EINVAL; : 
strstr : while : 	int ret = -EINVAL; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	switch (policy) {
strstr : if : 	switch (policy) { : 
strstr : for : 	switch (policy) { : 
strstr : while : 	switch (policy) { : 
str : 	case SCHED_FIFO:
strstr : INIT : 	case SCHED_FIFO: : 
strstr : if : 	case SCHED_FIFO: : 
strstr : for : 	case SCHED_FIFO: : 
strstr : while : 	case SCHED_FIFO: : 
str : 	case SCHED_RR:
strstr : INIT : 	case SCHED_RR: : 
strstr : if : 	case SCHED_RR: : 
strstr : for : 	case SCHED_RR: : 
strstr : while : 	case SCHED_RR: : 
str : 		ret = MAX_USER_RT_PRIO-1;
strstr : INIT : 		ret = MAX_USER_RT_PRIO-1; : 
strstr : if : 		ret = MAX_USER_RT_PRIO-1; : 
strstr : for : 		ret = MAX_USER_RT_PRIO-1; : 
strstr : while : 		ret = MAX_USER_RT_PRIO-1; : 
str : 		break;
strstr : INIT : 		break; : 
strstr : if : 		break; : 
strstr : for : 		break; : 
strstr : while : 		break; : 
str : 	case SCHED_DEADLINE:
strstr : INIT : 	case SCHED_DEADLINE: : 
strstr : if : 	case SCHED_DEADLINE: : 
strstr : for : 	case SCHED_DEADLINE: : 
strstr : while : 	case SCHED_DEADLINE: : 
str : 	case SCHED_NORMAL:
strstr : INIT : 	case SCHED_NORMAL: : 
strstr : if : 	case SCHED_NORMAL: : 
strstr : for : 	case SCHED_NORMAL: : 
strstr : while : 	case SCHED_NORMAL: : 
str : 	case SCHED_BATCH:
strstr : INIT : 	case SCHED_BATCH: : 
strstr : if : 	case SCHED_BATCH: : 
strstr : for : 	case SCHED_BATCH: : 
strstr : while : 	case SCHED_BATCH: : 
str : 	case SCHED_IDLE:
strstr : INIT : 	case SCHED_IDLE: : 
strstr : if : 	case SCHED_IDLE: : 
strstr : for : 	case SCHED_IDLE: : 
strstr : while : 	case SCHED_IDLE: : 
str : 		ret = 0;
strstr : INIT : 		ret = 0; : 
strstr : if : 		ret = 0; : 
strstr : for : 		ret = 0; : 
strstr : while : 		ret = 0; : 
str : 		break;
strstr : INIT : 		break; : 
strstr : if : 		break; : 
strstr : for : 		break; : 
strstr : while : 		break; : 
str : 	}
strstr : INIT : 	} : 
strstr : if : 	} : 
strstr : for : 	} : 
strstr : while : 	} : 
str : 	return ret;
strstr : INIT : 	return ret; : 
strstr : if : 	return ret; : 
strstr : for : 	return ret; : 
strstr : while : 	return ret; : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : /**
strstr : if : /** : 
strstr : for : /** : 
strstr : while : /** : 
str :  * sys_sched_get_priority_min - return minimum RT priority.
strstr : INIT :  * sys_sched_get_priority_min - return minimum RT priority. : 
strstr : if :  * sys_sched_get_priority_min - return minimum RT priority. : 
strstr : for :  * sys_sched_get_priority_min - return minimum RT priority. : 
strstr : while :  * sys_sched_get_priority_min - return minimum RT priority. : 
str :  * @policy: scheduling class.
strstr : INIT :  * @policy: scheduling class. : 
strstr : if :  * @policy: scheduling class. : 
strstr : for :  * @policy: scheduling class. : 
strstr : while :  * @policy: scheduling class. : 
str :  *
strstr : INIT :  * : 
strstr : if :  * : 
strstr : for :  * : 
strstr : while :  * : 
str :  * Return: On success, this syscall returns the minimum
strstr : INIT :  * Return: On success, this syscall returns the minimum : 
strstr : if :  * Return: On success, this syscall returns the minimum : 
strstr : for :  * Return: On success, this syscall returns the minimum : 
strstr : while :  * Return: On success, this syscall returns the minimum : 
str :  * rt_priority that can be used by a given scheduling class.
strstr : INIT :  * rt_priority that can be used by a given scheduling class. : 
strstr : if :  * rt_priority that can be used by a given scheduling class. : 
strstr : for :  * rt_priority that can be used by a given scheduling class. : 
strstr : while :  * rt_priority that can be used by a given scheduling class. : 
str :  * On failure, a negative error code is returned.
strstr : INIT :  * On failure, a negative error code is returned. : 
strstr : if :  * On failure, a negative error code is returned. : 
strstr : for :  * On failure, a negative error code is returned. : 
strstr : while :  * On failure, a negative error code is returned. : 
str :  */
strstr : INIT :  */ : 
strstr : if :  */ : 
strstr : for :  */ : 
strstr : while :  */ : 
str : SYSCALL_DEFINE1(sched_get_priority_min, int, policy)
strstr : INIT : SYSCALL_DEFINE1(sched_get_priority_min, int, policy) : 
strstr : if : SYSCALL_DEFINE1(sched_get_priority_min, int, policy) : 
strstr : for : SYSCALL_DEFINE1(sched_get_priority_min, int, policy) : 
strstr : while : SYSCALL_DEFINE1(sched_get_priority_min, int, policy) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	int ret = -EINVAL;
strstr : INIT : 	int ret = -EINVAL; : 
strstr : if : 	int ret = -EINVAL; : 
strstr : for : 	int ret = -EINVAL; : 
strstr : while : 	int ret = -EINVAL; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	switch (policy) {
strstr : if : 	switch (policy) { : 
strstr : for : 	switch (policy) { : 
strstr : while : 	switch (policy) { : 
str : 	case SCHED_FIFO:
strstr : INIT : 	case SCHED_FIFO: : 
strstr : if : 	case SCHED_FIFO: : 
strstr : for : 	case SCHED_FIFO: : 
strstr : while : 	case SCHED_FIFO: : 
str : 	case SCHED_RR:
strstr : INIT : 	case SCHED_RR: : 
strstr : if : 	case SCHED_RR: : 
strstr : for : 	case SCHED_RR: : 
strstr : while : 	case SCHED_RR: : 
str : 		ret = 1;
strstr : INIT : 		ret = 1; : 
strstr : if : 		ret = 1; : 
strstr : for : 		ret = 1; : 
strstr : while : 		ret = 1; : 
str : 		break;
strstr : INIT : 		break; : 
strstr : if : 		break; : 
strstr : for : 		break; : 
strstr : while : 		break; : 
str : 	case SCHED_DEADLINE:
strstr : INIT : 	case SCHED_DEADLINE: : 
strstr : if : 	case SCHED_DEADLINE: : 
strstr : for : 	case SCHED_DEADLINE: : 
strstr : while : 	case SCHED_DEADLINE: : 
str : 	case SCHED_NORMAL:
strstr : INIT : 	case SCHED_NORMAL: : 
strstr : if : 	case SCHED_NORMAL: : 
strstr : for : 	case SCHED_NORMAL: : 
strstr : while : 	case SCHED_NORMAL: : 
str : 	case SCHED_BATCH:
strstr : INIT : 	case SCHED_BATCH: : 
strstr : if : 	case SCHED_BATCH: : 
strstr : for : 	case SCHED_BATCH: : 
strstr : while : 	case SCHED_BATCH: : 
str : 	case SCHED_IDLE:
strstr : INIT : 	case SCHED_IDLE: : 
strstr : if : 	case SCHED_IDLE: : 
strstr : for : 	case SCHED_IDLE: : 
strstr : while : 	case SCHED_IDLE: : 
str : 		ret = 0;
strstr : INIT : 		ret = 0; : 
strstr : if : 		ret = 0; : 
strstr : for : 		ret = 0; : 
strstr : while : 		ret = 0; : 
str : 	}
strstr : INIT : 	} : 
strstr : if : 	} : 
strstr : for : 	} : 
strstr : while : 	} : 
str : 	return ret;
strstr : INIT : 	return ret; : 
strstr : if : 	return ret; : 
strstr : for : 	return ret; : 
strstr : while : 	return ret; : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : /**
strstr : if : /** : 
strstr : for : /** : 
strstr : while : /** : 
str :  * sys_sched_rr_get_interval - return the default timeslice of a process.
strstr : INIT :  * sys_sched_rr_get_interval - return the default timeslice of a process. : 
strstr : if :  * sys_sched_rr_get_interval - return the default timeslice of a process. : 
strstr : for :  * sys_sched_rr_get_interval - return the default timeslice of a process. : 
strstr : while :  * sys_sched_rr_get_interval - return the default timeslice of a process. : 
str :  * @pid: pid of the process.
strstr : INIT :  * @pid: pid of the process. : 
strstr : if :  * @pid: pid of the process. : 
strstr : for :  * @pid: pid of the process. : 
strstr : while :  * @pid: pid of the process. : 
str :  * @interval: userspace pointer to the timeslice value.
strstr : INIT :  * @interval: userspace pointer to the timeslice value. : 
strstr : if :  * @interval: userspace pointer to the timeslice value. : 
strstr : for :  * @interval: userspace pointer to the timeslice value. : 
strstr : while :  * @interval: userspace pointer to the timeslice value. : 
str :  *
strstr : INIT :  * : 
strstr : if :  * : 
strstr : for :  * : 
strstr : while :  * : 
str :  * this syscall writes the default timeslice value of a given process
strstr : INIT :  * this syscall writes the default timeslice value of a given process : 
strstr : if :  * this syscall writes the default timeslice value of a given process : 
strstr : for :  * this syscall writes the default timeslice value of a given process : 
strstr : while :  * this syscall writes the default timeslice value of a given process : 
str :  * into the user-space timespec buffer. A value of '0' means infinity.
strstr : INIT :  * into the user-space timespec buffer. A value of '0' means infinity. : 
strstr : if :  * into the user-space timespec buffer. A value of '0' means infinity. : 
strstr : for :  * into the user-space timespec buffer. A value of '0' means infinity. : 
strstr : while :  * into the user-space timespec buffer. A value of '0' means infinity. : 
str :  *
strstr : INIT :  * : 
strstr : if :  * : 
strstr : for :  * : 
strstr : while :  * : 
str :  * Return: On success, 0 and the timeslice is in @interval. Otherwise,
strstr : INIT :  * Return: On success, 0 and the timeslice is in @interval. Otherwise, : 
strstr : if :  * Return: On success, 0 and the timeslice is in @interval. Otherwise, : 
strstr : for :  * Return: On success, 0 and the timeslice is in @interval. Otherwise, : 
strstr : while :  * Return: On success, 0 and the timeslice is in @interval. Otherwise, : 
str :  * an error code.
strstr : INIT :  * an error code. : 
strstr : if :  * an error code. : 
strstr : for :  * an error code. : 
strstr : while :  * an error code. : 
str :  */
strstr : INIT :  */ : 
strstr : if :  */ : 
strstr : for :  */ : 
strstr : while :  */ : 
str : SYSCALL_DEFINE2(sched_rr_get_interval, pid_t, pid,
strstr : INIT : SYSCALL_DEFINE2(sched_rr_get_interval, pid_t, pid, : 
strstr : if : SYSCALL_DEFINE2(sched_rr_get_interval, pid_t, pid, : 
strstr : for : SYSCALL_DEFINE2(sched_rr_get_interval, pid_t, pid, : 
strstr : while : SYSCALL_DEFINE2(sched_rr_get_interval, pid_t, pid, : 
str : 		struct timespec __user *, interval)
strstr : INIT : 		struct timespec __user *, interval) : 
strstr : if : 		struct timespec __user *, interval) : 
strstr : for : 		struct timespec __user *, interval) : 
strstr : while : 		struct timespec __user *, interval) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	struct task_struct *p;
strstr : INIT : 	struct task_struct *p; : 
strstr : if : 	struct task_struct *p; : 
strstr : for : 	struct task_struct *p; : 
strstr : while : 	struct task_struct *p; : 
str : 	unsigned int time_slice;
strstr : INIT : 	unsigned int time_slice; : 
strstr : if : 	unsigned int time_slice; : 
strstr : for : 	unsigned int time_slice; : 
strstr : while : 	unsigned int time_slice; : 
str : 	unsigned long flags;
strstr : INIT : 	unsigned long flags; : 
strstr : if : 	unsigned long flags; : 
strstr : for : 	unsigned long flags; : 
strstr : while : 	unsigned long flags; : 
str : 	struct rq *rq;
strstr : INIT : 	struct rq *rq; : 
strstr : if : 	struct rq *rq; : 
strstr : for : 	struct rq *rq; : 
strstr : while : 	struct rq *rq; : 
str : 	int retval;
strstr : INIT : 	int retval; : 
strstr : if : 	int retval; : 
strstr : for : 	int retval; : 
strstr : while : 	int retval; : 
str : 	struct timespec t;
strstr : INIT : 	struct timespec t; : 
strstr : if : 	struct timespec t; : 
strstr : for : 	struct timespec t; : 
strstr : while : 	struct timespec t; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	if (pid < 0)
strstr : if : 	if (pid < 0) : 
strstr : for : 	if (pid < 0) : 
strstr : while : 	if (pid < 0) : 
str : 		return -EINVAL;
strstr : INIT : 		return -EINVAL; : 
strstr : if : 		return -EINVAL; : 
strstr : for : 		return -EINVAL; : 
strstr : while : 		return -EINVAL; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	retval = -ESRCH;
strstr : if : 	retval = -ESRCH; : 
strstr : for : 	retval = -ESRCH; : 
strstr : while : 	retval = -ESRCH; : 
str : 	rcu_read_lock();
strstr : INIT : 	rcu_read_lock(); : 
strstr : if : 	rcu_read_lock(); : 
strstr : for : 	rcu_read_lock(); : 
strstr : while : 	rcu_read_lock(); : 
str : 	p = find_process_by_pid(pid);
strstr : INIT : 	p = find_process_by_pid(pid); : 
strstr : if : 	p = find_process_by_pid(pid); : 
strstr : for : 	p = find_process_by_pid(pid); : 
strstr : while : 	p = find_process_by_pid(pid); : 
str : 	if (!p)
strstr : INIT : 	if (!p) : 
strstr : if : 	if (!p) : 
strstr : for : 	if (!p) : 
strstr : while : 	if (!p) : 
str : 		goto out_unlock;
strstr : INIT : 		goto out_unlock; : 
strstr : if : 		goto out_unlock; : 
strstr : for : 		goto out_unlock; : 
strstr : while : 		goto out_unlock; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	retval = security_task_getscheduler(p);
strstr : if : 	retval = security_task_getscheduler(p); : 
strstr : for : 	retval = security_task_getscheduler(p); : 
strstr : while : 	retval = security_task_getscheduler(p); : 
str : 	if (retval)
strstr : INIT : 	if (retval) : 
strstr : if : 	if (retval) : 
strstr : for : 	if (retval) : 
strstr : while : 	if (retval) : 
str : 		goto out_unlock;
strstr : INIT : 		goto out_unlock; : 
strstr : if : 		goto out_unlock; : 
strstr : for : 		goto out_unlock; : 
strstr : while : 		goto out_unlock; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	rq = task_rq_lock(p, &flags);
strstr : if : 	rq = task_rq_lock(p, &flags); : 
strstr : for : 	rq = task_rq_lock(p, &flags); : 
strstr : while : 	rq = task_rq_lock(p, &flags); : 
str : 	time_slice = 0;
strstr : INIT : 	time_slice = 0; : 
strstr : if : 	time_slice = 0; : 
strstr : for : 	time_slice = 0; : 
strstr : while : 	time_slice = 0; : 
str : 	if (p->sched_class->get_rr_interval)
strstr : INIT : 	if (p->sched_class->get_rr_interval) : 
strstr : if : 	if (p->sched_class->get_rr_interval) : 
strstr : for : 	if (p->sched_class->get_rr_interval) : 
strstr : while : 	if (p->sched_class->get_rr_interval) : 
str : 		time_slice = p->sched_class->get_rr_interval(rq, p);
strstr : INIT : 		time_slice = p->sched_class->get_rr_interval(rq, p); : 
strstr : if : 		time_slice = p->sched_class->get_rr_interval(rq, p); : 
strstr : for : 		time_slice = p->sched_class->get_rr_interval(rq, p); : 
strstr : while : 		time_slice = p->sched_class->get_rr_interval(rq, p); : 
str : 	task_rq_unlock(rq, p, &flags);
strstr : INIT : 	task_rq_unlock(rq, p, &flags); : 
strstr : if : 	task_rq_unlock(rq, p, &flags); : 
strstr : for : 	task_rq_unlock(rq, p, &flags); : 
strstr : while : 	task_rq_unlock(rq, p, &flags); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	rcu_read_unlock();
strstr : if : 	rcu_read_unlock(); : 
strstr : for : 	rcu_read_unlock(); : 
strstr : while : 	rcu_read_unlock(); : 
str : 	jiffies_to_timespec(time_slice, &t);
strstr : INIT : 	jiffies_to_timespec(time_slice, &t); : 
strstr : if : 	jiffies_to_timespec(time_slice, &t); : 
strstr : for : 	jiffies_to_timespec(time_slice, &t); : 
strstr : while : 	jiffies_to_timespec(time_slice, &t); : 
str : 	retval = copy_to_user(interval, &t, sizeof(t)) ? -EFAULT : 0;
strstr : INIT : 	retval = copy_to_user(interval, &t, sizeof(t)) ? -EFAULT : 0; : 
strstr : if : 	retval = copy_to_user(interval, &t, sizeof(t)) ? -EFAULT : 0; : 
strstr : for : 	retval = copy_to_user(interval, &t, sizeof(t)) ? -EFAULT : 0; : 
strstr : while : 	retval = copy_to_user(interval, &t, sizeof(t)) ? -EFAULT : 0; : 
str : 	return retval;
strstr : INIT : 	return retval; : 
strstr : if : 	return retval; : 
strstr : for : 	return retval; : 
strstr : while : 	return retval; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : out_unlock:
strstr : if : out_unlock: : 
strstr : for : out_unlock: : 
strstr : while : out_unlock: : 
str : 	rcu_read_unlock();
strstr : INIT : 	rcu_read_unlock(); : 
strstr : if : 	rcu_read_unlock(); : 
strstr : for : 	rcu_read_unlock(); : 
strstr : while : 	rcu_read_unlock(); : 
str : 	return retval;
strstr : INIT : 	return retval; : 
strstr : if : 	return retval; : 
strstr : for : 	return retval; : 
strstr : while : 	return retval; : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : static const char stat_nam[] = TASK_STATE_TO_CHAR_STR;
strstr : if : static const char stat_nam[] = TASK_STATE_TO_CHAR_STR; : 
strstr : for : static const char stat_nam[] = TASK_STATE_TO_CHAR_STR; : 
strstr : while : static const char stat_nam[] = TASK_STATE_TO_CHAR_STR; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : void sched_show_task(struct task_struct *p)
strstr : if : void sched_show_task(struct task_struct *p) : 
strstr : for : void sched_show_task(struct task_struct *p) : 
strstr : while : void sched_show_task(struct task_struct *p) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	unsigned long free = 0;
strstr : INIT : 	unsigned long free = 0; : 
strstr : if : 	unsigned long free = 0; : 
strstr : for : 	unsigned long free = 0; : 
strstr : while : 	unsigned long free = 0; : 
str : 	int ppid;
strstr : INIT : 	int ppid; : 
strstr : if : 	int ppid; : 
strstr : for : 	int ppid; : 
strstr : while : 	int ppid; : 
str : 	unsigned state;
strstr : INIT : 	unsigned state; : 
strstr : if : 	unsigned state; : 
strstr : for : 	unsigned state; : 
strstr : while : 	unsigned state; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	state = p->state ? __ffs(p->state) + 1 : 0;
strstr : if : 	state = p->state ? __ffs(p->state) + 1 : 0; : 
strstr : for : 	state = p->state ? __ffs(p->state) + 1 : 0; : 
strstr : while : 	state = p->state ? __ffs(p->state) + 1 : 0; : 
str : 	printk(KERN_INFO "%-15.15s %c", p->comm,
strstr : INIT : 	printk(KERN_INFO "%-15.15s %c", p->comm, : 
strstr : if : 	printk(KERN_INFO "%-15.15s %c", p->comm, : 
strstr : for : 	printk(KERN_INFO "%-15.15s %c", p->comm, : 
strstr : while : 	printk(KERN_INFO "%-15.15s %c", p->comm, : 
str : 		state < sizeof(stat_nam) - 1 ? stat_nam[state] : '?');
strstr : INIT : 		state < sizeof(stat_nam) - 1 ? stat_nam[state] : '?'); : 
strstr : if : 		state < sizeof(stat_nam) - 1 ? stat_nam[state] : '?'); : 
strstr : for : 		state < sizeof(stat_nam) - 1 ? stat_nam[state] : '?'); : 
strstr : while : 		state < sizeof(stat_nam) - 1 ? stat_nam[state] : '?'); : 
str : #if BITS_PER_LONG == 32
strstr : INIT : #if BITS_PER_LONG == 32 : 
strstr : if : #if BITS_PER_LONG == 32 : 
strstr : for : #if BITS_PER_LONG == 32 : 
strstr : while : #if BITS_PER_LONG == 32 : 
str : 	if (state == TASK_RUNNING)
strstr : INIT : 	if (state == TASK_RUNNING) : 
strstr : if : 	if (state == TASK_RUNNING) : 
strstr : for : 	if (state == TASK_RUNNING) : 
strstr : while : 	if (state == TASK_RUNNING) : 
str : 		printk(KERN_CONT " running  ");
strstr : INIT : 		printk(KERN_CONT " running  "); : 
strstr : if : 		printk(KERN_CONT " running  "); : 
strstr : for : 		printk(KERN_CONT " running  "); : 
strstr : while : 		printk(KERN_CONT " running  "); : 
str : 	else
strstr : INIT : 	else : 
strstr : if : 	else : 
strstr : for : 	else : 
strstr : while : 	else : 
str : 		printk(KERN_CONT " %08lx ", thread_saved_pc(p));
strstr : INIT : 		printk(KERN_CONT " %08lx ", thread_saved_pc(p)); : 
strstr : if : 		printk(KERN_CONT " %08lx ", thread_saved_pc(p)); : 
strstr : for : 		printk(KERN_CONT " %08lx ", thread_saved_pc(p)); : 
strstr : while : 		printk(KERN_CONT " %08lx ", thread_saved_pc(p)); : 
str : #else
strstr : INIT : #else : 
strstr : if : #else : 
strstr : for : #else : 
strstr : while : #else : 
str : 	if (state == TASK_RUNNING)
strstr : INIT : 	if (state == TASK_RUNNING) : 
strstr : if : 	if (state == TASK_RUNNING) : 
strstr : for : 	if (state == TASK_RUNNING) : 
strstr : while : 	if (state == TASK_RUNNING) : 
str : 		printk(KERN_CONT "  running task    ");
strstr : INIT : 		printk(KERN_CONT "  running task    "); : 
strstr : if : 		printk(KERN_CONT "  running task    "); : 
strstr : for : 		printk(KERN_CONT "  running task    "); : 
strstr : while : 		printk(KERN_CONT "  running task    "); : 
str : 	else
strstr : INIT : 	else : 
strstr : if : 	else : 
strstr : for : 	else : 
strstr : while : 	else : 
str : 		printk(KERN_CONT " %016lx ", thread_saved_pc(p));
strstr : INIT : 		printk(KERN_CONT " %016lx ", thread_saved_pc(p)); : 
strstr : if : 		printk(KERN_CONT " %016lx ", thread_saved_pc(p)); : 
strstr : for : 		printk(KERN_CONT " %016lx ", thread_saved_pc(p)); : 
strstr : while : 		printk(KERN_CONT " %016lx ", thread_saved_pc(p)); : 
str : #endif
strstr : INIT : #endif : 
strstr : if : #endif : 
strstr : for : #endif : 
strstr : while : #endif : 
str : #ifdef CONFIG_DEBUG_STACK_USAGE
strstr : INIT : #ifdef CONFIG_DEBUG_STACK_USAGE : 
strstr : if : #ifdef CONFIG_DEBUG_STACK_USAGE : 
strstr : for : #ifdef CONFIG_DEBUG_STACK_USAGE : 
strstr : while : #ifdef CONFIG_DEBUG_STACK_USAGE : 
str : 	free = stack_not_used(p);
strstr : INIT : 	free = stack_not_used(p); : 
strstr : if : 	free = stack_not_used(p); : 
strstr : for : 	free = stack_not_used(p); : 
strstr : while : 	free = stack_not_used(p); : 
str : #endif
strstr : INIT : #endif : 
strstr : if : #endif : 
strstr : for : #endif : 
strstr : while : #endif : 
str : 	rcu_read_lock();
strstr : INIT : 	rcu_read_lock(); : 
strstr : if : 	rcu_read_lock(); : 
strstr : for : 	rcu_read_lock(); : 
strstr : while : 	rcu_read_lock(); : 
str : 	ppid = task_pid_nr(rcu_dereference(p->real_parent));
strstr : INIT : 	ppid = task_pid_nr(rcu_dereference(p->real_parent)); : 
strstr : if : 	ppid = task_pid_nr(rcu_dereference(p->real_parent)); : 
strstr : for : 	ppid = task_pid_nr(rcu_dereference(p->real_parent)); : 
strstr : while : 	ppid = task_pid_nr(rcu_dereference(p->real_parent)); : 
str : 	rcu_read_unlock();
strstr : INIT : 	rcu_read_unlock(); : 
strstr : if : 	rcu_read_unlock(); : 
strstr : for : 	rcu_read_unlock(); : 
strstr : while : 	rcu_read_unlock(); : 
str : 	printk(KERN_CONT "%5lu %5d %6d 0x%08lx\n", free,
strstr : INIT : 	printk(KERN_CONT "%5lu %5d %6d 0x%08lx\n", free, : 
strstr : if : 	printk(KERN_CONT "%5lu %5d %6d 0x%08lx\n", free, : 
strstr : for : 	printk(KERN_CONT "%5lu %5d %6d 0x%08lx\n", free, : 
strstr : while : 	printk(KERN_CONT "%5lu %5d %6d 0x%08lx\n", free, : 
str : 		task_pid_nr(p), ppid,
strstr : INIT : 		task_pid_nr(p), ppid, : 
strstr : if : 		task_pid_nr(p), ppid, : 
strstr : for : 		task_pid_nr(p), ppid, : 
strstr : while : 		task_pid_nr(p), ppid, : 
str : 		(unsigned long)task_thread_info(p)->flags);
strstr : INIT : 		(unsigned long)task_thread_info(p)->flags); : 
strstr : if : 		(unsigned long)task_thread_info(p)->flags); : 
strstr : for : 		(unsigned long)task_thread_info(p)->flags); : 
strstr : while : 		(unsigned long)task_thread_info(p)->flags); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	print_worker_info(KERN_INFO, p);
strstr : if : 	print_worker_info(KERN_INFO, p); : 
strstr : for : 	print_worker_info(KERN_INFO, p); : 
strstr : while : 	print_worker_info(KERN_INFO, p); : 
str : 	show_stack(p, NULL);
strstr : INIT : 	show_stack(p, NULL); : 
strstr : if : 	show_stack(p, NULL); : 
strstr : for : 	show_stack(p, NULL); : 
strstr : while : 	show_stack(p, NULL); : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : void show_state_filter(unsigned long state_filter)
strstr : if : void show_state_filter(unsigned long state_filter) : 
strstr : for : void show_state_filter(unsigned long state_filter) : 
strstr : while : void show_state_filter(unsigned long state_filter) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	struct task_struct *g, *p;
strstr : INIT : 	struct task_struct *g, *p; : 
strstr : if : 	struct task_struct *g, *p; : 
strstr : for : 	struct task_struct *g, *p; : 
strstr : while : 	struct task_struct *g, *p; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : #if BITS_PER_LONG == 32
strstr : if : #if BITS_PER_LONG == 32 : 
strstr : for : #if BITS_PER_LONG == 32 : 
strstr : while : #if BITS_PER_LONG == 32 : 
str : 	printk(KERN_INFO
strstr : INIT : 	printk(KERN_INFO : 
strstr : if : 	printk(KERN_INFO : 
strstr : for : 	printk(KERN_INFO : 
strstr : while : 	printk(KERN_INFO : 
str : 		"  task                PC stack   pid father\n");
strstr : INIT : 		"  task                PC stack   pid father\n"); : 
strstr : if : 		"  task                PC stack   pid father\n"); : 
strstr : for : 		"  task                PC stack   pid father\n"); : 
strstr : while : 		"  task                PC stack   pid father\n"); : 
str : #else
strstr : INIT : #else : 
strstr : if : #else : 
strstr : for : #else : 
strstr : while : #else : 
str : 	printk(KERN_INFO
strstr : INIT : 	printk(KERN_INFO : 
strstr : if : 	printk(KERN_INFO : 
strstr : for : 	printk(KERN_INFO : 
strstr : while : 	printk(KERN_INFO : 
str : 		"  task                        PC stack   pid father\n");
strstr : INIT : 		"  task                        PC stack   pid father\n"); : 
strstr : if : 		"  task                        PC stack   pid father\n"); : 
strstr : for : 		"  task                        PC stack   pid father\n"); : 
strstr : while : 		"  task                        PC stack   pid father\n"); : 
str : #endif
strstr : INIT : #endif : 
strstr : if : #endif : 
strstr : for : #endif : 
strstr : while : #endif : 
str : 	rcu_read_lock();
strstr : INIT : 	rcu_read_lock(); : 
strstr : if : 	rcu_read_lock(); : 
strstr : for : 	rcu_read_lock(); : 
strstr : while : 	rcu_read_lock(); : 
str : 	do_each_thread(g, p) {
strstr : INIT : 	do_each_thread(g, p) { : 
strstr : if : 	do_each_thread(g, p) { : 
strstr : for : 	do_each_thread(g, p) { : 
strstr : while : 	do_each_thread(g, p) { : 
str : 		/*
strstr : INIT : 		/* : 
strstr : if : 		/* : 
strstr : for : 		/* : 
strstr : while : 		/* : 
str : 		 * reset the NMI-timeout, listing all files on a slow
strstr : INIT : 		 * reset the NMI-timeout, listing all files on a slow : 
strstr : if : 		 * reset the NMI-timeout, listing all files on a slow : 
strstr : for : 		 * reset the NMI-timeout, listing all files on a slow : 
strstr : while : 		 * reset the NMI-timeout, listing all files on a slow : 
str : 		 * console might take a lot of time:
strstr : INIT : 		 * console might take a lot of time: : 
strstr : if : 		 * console might take a lot of time: : 
strstr : for : 		 * console might take a lot of time: : 
strstr : while : 		 * console might take a lot of time: : 
str : 		 */
strstr : INIT : 		 */ : 
strstr : if : 		 */ : 
strstr : for : 		 */ : 
strstr : while : 		 */ : 
str : 		touch_nmi_watchdog();
strstr : INIT : 		touch_nmi_watchdog(); : 
strstr : if : 		touch_nmi_watchdog(); : 
strstr : for : 		touch_nmi_watchdog(); : 
strstr : while : 		touch_nmi_watchdog(); : 
str : 		if (!state_filter || (p->state & state_filter))
strstr : INIT : 		if (!state_filter || (p->state & state_filter)) : 
strstr : if : 		if (!state_filter || (p->state & state_filter)) : 
strstr : for : 		if (!state_filter || (p->state & state_filter)) : 
strstr : while : 		if (!state_filter || (p->state & state_filter)) : 
str : 			sched_show_task(p);
strstr : INIT : 			sched_show_task(p); : 
strstr : if : 			sched_show_task(p); : 
strstr : for : 			sched_show_task(p); : 
strstr : while : 			sched_show_task(p); : 
str : 	} while_each_thread(g, p);
strstr : INIT : 	} while_each_thread(g, p); : 
strstr : if : 	} while_each_thread(g, p); : 
strstr : for : 	} while_each_thread(g, p); : 
strstr : while : 	} while_each_thread(g, p); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	touch_all_softlockup_watchdogs();
strstr : if : 	touch_all_softlockup_watchdogs(); : 
strstr : for : 	touch_all_softlockup_watchdogs(); : 
strstr : while : 	touch_all_softlockup_watchdogs(); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : #ifdef CONFIG_SCHED_DEBUG
strstr : if : #ifdef CONFIG_SCHED_DEBUG : 
strstr : for : #ifdef CONFIG_SCHED_DEBUG : 
strstr : while : #ifdef CONFIG_SCHED_DEBUG : 
str : 	sysrq_sched_debug_show();
strstr : INIT : 	sysrq_sched_debug_show(); : 
strstr : if : 	sysrq_sched_debug_show(); : 
strstr : for : 	sysrq_sched_debug_show(); : 
strstr : while : 	sysrq_sched_debug_show(); : 
str : #endif
strstr : INIT : #endif : 
strstr : if : #endif : 
strstr : for : #endif : 
strstr : while : #endif : 
str : 	rcu_read_unlock();
strstr : INIT : 	rcu_read_unlock(); : 
strstr : if : 	rcu_read_unlock(); : 
strstr : for : 	rcu_read_unlock(); : 
strstr : while : 	rcu_read_unlock(); : 
str : 	/*
strstr : INIT : 	/* : 
strstr : if : 	/* : 
strstr : for : 	/* : 
strstr : while : 	/* : 
str : 	 * Only show locks if all tasks are dumped:
strstr : INIT : 	 * Only show locks if all tasks are dumped: : 
strstr : if : 	 * Only show locks if all tasks are dumped: : 
strstr : for : 	 * Only show locks if all tasks are dumped: : 
strstr : while : 	 * Only show locks if all tasks are dumped: : 
str : 	 */
strstr : INIT : 	 */ : 
strstr : if : 	 */ : 
strstr : for : 	 */ : 
strstr : while : 	 */ : 
str : 	if (!state_filter)
strstr : INIT : 	if (!state_filter) : 
strstr : if : 	if (!state_filter) : 
strstr : for : 	if (!state_filter) : 
strstr : while : 	if (!state_filter) : 
str : 		debug_show_all_locks();
strstr : INIT : 		debug_show_all_locks(); : 
strstr : if : 		debug_show_all_locks(); : 
strstr : for : 		debug_show_all_locks(); : 
strstr : while : 		debug_show_all_locks(); : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : void init_idle_bootup_task(struct task_struct *idle)
strstr : if : void init_idle_bootup_task(struct task_struct *idle) : 
strstr : for : void init_idle_bootup_task(struct task_struct *idle) : 
strstr : while : void init_idle_bootup_task(struct task_struct *idle) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	idle->sched_class = &idle_sched_class;
strstr : INIT : 	idle->sched_class = &idle_sched_class; : 
strstr : if : 	idle->sched_class = &idle_sched_class; : 
strstr : for : 	idle->sched_class = &idle_sched_class; : 
strstr : while : 	idle->sched_class = &idle_sched_class; : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : /**
strstr : if : /** : 
strstr : for : /** : 
strstr : while : /** : 
str :  * init_idle - set up an idle thread for a given CPU
strstr : INIT :  * init_idle - set up an idle thread for a given CPU : 
strstr : if :  * init_idle - set up an idle thread for a given CPU : 
strstr : for :  * init_idle - set up an idle thread for a given CPU : 
strstr : while :  * init_idle - set up an idle thread for a given CPU : 
str :  * @idle: task in question
strstr : INIT :  * @idle: task in question : 
strstr : if :  * @idle: task in question : 
strstr : for :  * @idle: task in question : 
strstr : while :  * @idle: task in question : 
str :  * @cpu: cpu the idle task belongs to
strstr : INIT :  * @cpu: cpu the idle task belongs to : 
strstr : if :  * @cpu: cpu the idle task belongs to : 
strstr : for :  * @cpu: cpu the idle task belongs to : 
strstr : while :  * @cpu: cpu the idle task belongs to : 
str :  *
strstr : INIT :  * : 
strstr : if :  * : 
strstr : for :  * : 
strstr : while :  * : 
str :  * NOTE: this function does not set the idle thread's NEED_RESCHED
strstr : INIT :  * NOTE: this function does not set the idle thread's NEED_RESCHED : 
strstr : if :  * NOTE: this function does not set the idle thread's NEED_RESCHED : 
strstr : for :  * NOTE: this function does not set the idle thread's NEED_RESCHED : 
strstr : while :  * NOTE: this function does not set the idle thread's NEED_RESCHED : 
str :  * flag, to make booting more robust.
strstr : INIT :  * flag, to make booting more robust. : 
strstr : if :  * flag, to make booting more robust. : 
strstr : for :  * flag, to make booting more robust. : 
strstr : while :  * flag, to make booting more robust. : 
str :  */
strstr : INIT :  */ : 
strstr : if :  */ : 
strstr : for :  */ : 
strstr : while :  */ : 
str : void init_idle(struct task_struct *idle, int cpu)
strstr : INIT : void init_idle(struct task_struct *idle, int cpu) : 
strstr : if : void init_idle(struct task_struct *idle, int cpu) : 
strstr : for : void init_idle(struct task_struct *idle, int cpu) : 
strstr : while : void init_idle(struct task_struct *idle, int cpu) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	struct rq *rq = cpu_rq(cpu);
strstr : INIT : 	struct rq *rq = cpu_rq(cpu); : 
strstr : if : 	struct rq *rq = cpu_rq(cpu); : 
strstr : for : 	struct rq *rq = cpu_rq(cpu); : 
strstr : while : 	struct rq *rq = cpu_rq(cpu); : 
str : 	unsigned long flags;
strstr : INIT : 	unsigned long flags; : 
strstr : if : 	unsigned long flags; : 
strstr : for : 	unsigned long flags; : 
strstr : while : 	unsigned long flags; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	raw_spin_lock_irqsave(&rq->lock, flags);
strstr : if : 	raw_spin_lock_irqsave(&rq->lock, flags); : 
strstr : for : 	raw_spin_lock_irqsave(&rq->lock, flags); : 
strstr : while : 	raw_spin_lock_irqsave(&rq->lock, flags); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	__sched_fork(0, idle);
strstr : if : 	__sched_fork(0, idle); : 
strstr : for : 	__sched_fork(0, idle); : 
strstr : while : 	__sched_fork(0, idle); : 
str : 	idle->state = TASK_RUNNING;
strstr : INIT : 	idle->state = TASK_RUNNING; : 
strstr : if : 	idle->state = TASK_RUNNING; : 
strstr : for : 	idle->state = TASK_RUNNING; : 
strstr : while : 	idle->state = TASK_RUNNING; : 
str : 	idle->se.exec_start = sched_clock();
strstr : INIT : 	idle->se.exec_start = sched_clock(); : 
strstr : if : 	idle->se.exec_start = sched_clock(); : 
strstr : for : 	idle->se.exec_start = sched_clock(); : 
strstr : while : 	idle->se.exec_start = sched_clock(); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	do_set_cpus_allowed(idle, cpumask_of(cpu));
strstr : if : 	do_set_cpus_allowed(idle, cpumask_of(cpu)); : 
strstr : for : 	do_set_cpus_allowed(idle, cpumask_of(cpu)); : 
strstr : while : 	do_set_cpus_allowed(idle, cpumask_of(cpu)); : 
str : 	/*
strstr : INIT : 	/* : 
strstr : if : 	/* : 
strstr : for : 	/* : 
strstr : while : 	/* : 
str : 	 * We're having a chicken and egg problem, even though we are
strstr : INIT : 	 * We're having a chicken and egg problem, even though we are : 
strstr : if : 	 * We're having a chicken and egg problem, even though we are : 
strstr : for : 	 * We're having a chicken and egg problem, even though we are : 
strstr : while : 	 * We're having a chicken and egg problem, even though we are : 
str : 	 * holding rq->lock, the cpu isn't yet set to this cpu so the
strstr : INIT : 	 * holding rq->lock, the cpu isn't yet set to this cpu so the : 
strstr : if : 	 * holding rq->lock, the cpu isn't yet set to this cpu so the : 
strstr : for : 	 * holding rq->lock, the cpu isn't yet set to this cpu so the : 
strstr : while : 	 * holding rq->lock, the cpu isn't yet set to this cpu so the : 
str : 	 * lockdep check in task_group() will fail.
strstr : INIT : 	 * lockdep check in task_group() will fail. : 
strstr : if : 	 * lockdep check in task_group() will fail. : 
strstr : for : 	 * lockdep check in task_group() will fail. : 
strstr : while : 	 * lockdep check in task_group() will fail. : 
str : 	 *
strstr : INIT : 	 * : 
strstr : if : 	 * : 
strstr : for : 	 * : 
strstr : while : 	 * : 
str : 	 * Similar case to sched_fork(). / Alternatively we could
strstr : INIT : 	 * Similar case to sched_fork(). / Alternatively we could : 
strstr : if : 	 * Similar case to sched_fork(). / Alternatively we could : 
strstr : for : 	 * Similar case to sched_fork(). / Alternatively we could : 
strstr : while : 	 * Similar case to sched_fork(). / Alternatively we could : 
str : 	 * use task_rq_lock() here and obtain the other rq->lock.
strstr : INIT : 	 * use task_rq_lock() here and obtain the other rq->lock. : 
strstr : if : 	 * use task_rq_lock() here and obtain the other rq->lock. : 
strstr : for : 	 * use task_rq_lock() here and obtain the other rq->lock. : 
strstr : while : 	 * use task_rq_lock() here and obtain the other rq->lock. : 
str : 	 *
strstr : INIT : 	 * : 
strstr : if : 	 * : 
strstr : for : 	 * : 
strstr : while : 	 * : 
str : 	 * Silence PROVE_RCU
strstr : INIT : 	 * Silence PROVE_RCU : 
strstr : if : 	 * Silence PROVE_RCU : 
strstr : for : 	 * Silence PROVE_RCU : 
strstr : while : 	 * Silence PROVE_RCU : 
str : 	 */
strstr : INIT : 	 */ : 
strstr : if : 	 */ : 
strstr : for : 	 */ : 
strstr : while : 	 */ : 
str : 	rcu_read_lock();
strstr : INIT : 	rcu_read_lock(); : 
strstr : if : 	rcu_read_lock(); : 
strstr : for : 	rcu_read_lock(); : 
strstr : while : 	rcu_read_lock(); : 
str : 	__set_task_cpu(idle, cpu);
strstr : INIT : 	__set_task_cpu(idle, cpu); : 
strstr : if : 	__set_task_cpu(idle, cpu); : 
strstr : for : 	__set_task_cpu(idle, cpu); : 
strstr : while : 	__set_task_cpu(idle, cpu); : 
str : 	rcu_read_unlock();
strstr : INIT : 	rcu_read_unlock(); : 
strstr : if : 	rcu_read_unlock(); : 
strstr : for : 	rcu_read_unlock(); : 
strstr : while : 	rcu_read_unlock(); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	rq->curr = rq->idle = idle;
strstr : if : 	rq->curr = rq->idle = idle; : 
strstr : for : 	rq->curr = rq->idle = idle; : 
strstr : while : 	rq->curr = rq->idle = idle; : 
str : #if defined(CONFIG_SMP)
strstr : INIT : #if defined(CONFIG_SMP) : 
strstr : if : #if defined(CONFIG_SMP) : 
strstr : for : #if defined(CONFIG_SMP) : 
strstr : while : #if defined(CONFIG_SMP) : 
str : 	idle->on_cpu = 1;
strstr : INIT : 	idle->on_cpu = 1; : 
strstr : if : 	idle->on_cpu = 1; : 
strstr : for : 	idle->on_cpu = 1; : 
strstr : while : 	idle->on_cpu = 1; : 
str : #endif
strstr : INIT : #endif : 
strstr : if : #endif : 
strstr : for : #endif : 
strstr : while : #endif : 
str : 	raw_spin_unlock_irqrestore(&rq->lock, flags);
strstr : INIT : 	raw_spin_unlock_irqrestore(&rq->lock, flags); : 
strstr : if : 	raw_spin_unlock_irqrestore(&rq->lock, flags); : 
strstr : for : 	raw_spin_unlock_irqrestore(&rq->lock, flags); : 
strstr : while : 	raw_spin_unlock_irqrestore(&rq->lock, flags); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	/* Set the preempt count _outside_ the spinlocks! */
strstr : if : 	/* Set the preempt count _outside_ the spinlocks! */ : 
strstr : for : 	/* Set the preempt count _outside_ the spinlocks! */ : 
strstr : while : 	/* Set the preempt count _outside_ the spinlocks! */ : 
str : 	init_idle_preempt_count(idle, cpu);
strstr : INIT : 	init_idle_preempt_count(idle, cpu); : 
strstr : if : 	init_idle_preempt_count(idle, cpu); : 
strstr : for : 	init_idle_preempt_count(idle, cpu); : 
strstr : while : 	init_idle_preempt_count(idle, cpu); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	/*
strstr : if : 	/* : 
strstr : for : 	/* : 
strstr : while : 	/* : 
str : 	 * The idle tasks have their own, simple scheduling class:
strstr : INIT : 	 * The idle tasks have their own, simple scheduling class: : 
strstr : if : 	 * The idle tasks have their own, simple scheduling class: : 
strstr : for : 	 * The idle tasks have their own, simple scheduling class: : 
strstr : while : 	 * The idle tasks have their own, simple scheduling class: : 
str : 	 */
strstr : INIT : 	 */ : 
strstr : if : 	 */ : 
strstr : for : 	 */ : 
strstr : while : 	 */ : 
str : 	idle->sched_class = &idle_sched_class;
strstr : INIT : 	idle->sched_class = &idle_sched_class; : 
strstr : if : 	idle->sched_class = &idle_sched_class; : 
strstr : for : 	idle->sched_class = &idle_sched_class; : 
strstr : while : 	idle->sched_class = &idle_sched_class; : 
str : 	ftrace_graph_init_idle_task(idle, cpu);
strstr : INIT : 	ftrace_graph_init_idle_task(idle, cpu); : 
strstr : if : 	ftrace_graph_init_idle_task(idle, cpu); : 
strstr : for : 	ftrace_graph_init_idle_task(idle, cpu); : 
strstr : while : 	ftrace_graph_init_idle_task(idle, cpu); : 
str : 	vtime_init_idle(idle, cpu);
strstr : INIT : 	vtime_init_idle(idle, cpu); : 
strstr : if : 	vtime_init_idle(idle, cpu); : 
strstr : for : 	vtime_init_idle(idle, cpu); : 
strstr : while : 	vtime_init_idle(idle, cpu); : 
str : #if defined(CONFIG_SMP)
strstr : INIT : #if defined(CONFIG_SMP) : 
strstr : if : #if defined(CONFIG_SMP) : 
strstr : for : #if defined(CONFIG_SMP) : 
strstr : while : #if defined(CONFIG_SMP) : 
str : 	sprintf(idle->comm, "%s/%d", INIT_TASK_COMM, cpu);
strstr : INIT : 	sprintf(idle->comm, "%s/%d", INIT_TASK_COMM, cpu); : 
strstr : if : 	sprintf(idle->comm, "%s/%d", INIT_TASK_COMM, cpu); : 
strstr : for : 	sprintf(idle->comm, "%s/%d", INIT_TASK_COMM, cpu); : 
strstr : while : 	sprintf(idle->comm, "%s/%d", INIT_TASK_COMM, cpu); : 
str : #endif
strstr : INIT : #endif : 
strstr : if : #endif : 
strstr : for : #endif : 
strstr : while : #endif : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : #ifdef CONFIG_SMP
strstr : if : #ifdef CONFIG_SMP : 
strstr : for : #ifdef CONFIG_SMP : 
strstr : while : #ifdef CONFIG_SMP : 
str : void do_set_cpus_allowed(struct task_struct *p, const struct cpumask *new_mask)
strstr : INIT : void do_set_cpus_allowed(struct task_struct *p, const struct cpumask *new_mask) : 
strstr : if : void do_set_cpus_allowed(struct task_struct *p, const struct cpumask *new_mask) : 
strstr : for : void do_set_cpus_allowed(struct task_struct *p, const struct cpumask *new_mask) : 
strstr : while : void do_set_cpus_allowed(struct task_struct *p, const struct cpumask *new_mask) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	if (p->sched_class && p->sched_class->set_cpus_allowed)
strstr : INIT : 	if (p->sched_class && p->sched_class->set_cpus_allowed) : 
strstr : if : 	if (p->sched_class && p->sched_class->set_cpus_allowed) : 
strstr : for : 	if (p->sched_class && p->sched_class->set_cpus_allowed) : 
strstr : while : 	if (p->sched_class && p->sched_class->set_cpus_allowed) : 
str : 		p->sched_class->set_cpus_allowed(p, new_mask);
strstr : INIT : 		p->sched_class->set_cpus_allowed(p, new_mask); : 
strstr : if : 		p->sched_class->set_cpus_allowed(p, new_mask); : 
strstr : for : 		p->sched_class->set_cpus_allowed(p, new_mask); : 
strstr : while : 		p->sched_class->set_cpus_allowed(p, new_mask); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	cpumask_copy(&p->cpus_allowed, new_mask);
strstr : if : 	cpumask_copy(&p->cpus_allowed, new_mask); : 
strstr : for : 	cpumask_copy(&p->cpus_allowed, new_mask); : 
strstr : while : 	cpumask_copy(&p->cpus_allowed, new_mask); : 
str : 	p->nr_cpus_allowed = cpumask_weight(new_mask);
strstr : INIT : 	p->nr_cpus_allowed = cpumask_weight(new_mask); : 
strstr : if : 	p->nr_cpus_allowed = cpumask_weight(new_mask); : 
strstr : for : 	p->nr_cpus_allowed = cpumask_weight(new_mask); : 
strstr : while : 	p->nr_cpus_allowed = cpumask_weight(new_mask); : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : /*
strstr : if : /* : 
strstr : for : /* : 
strstr : while : /* : 
str :  * This is how migration works:
strstr : INIT :  * This is how migration works: : 
strstr : if :  * This is how migration works: : 
strstr : for :  * This is how migration works: : 
strstr : while :  * This is how migration works: : 
str :  *
strstr : INIT :  * : 
strstr : if :  * : 
strstr : for :  * : 
strstr : while :  * : 
str :  * 1) we invoke migration_cpu_stop() on the target CPU using
strstr : INIT :  * 1) we invoke migration_cpu_stop() on the target CPU using : 
strstr : if :  * 1) we invoke migration_cpu_stop() on the target CPU using : 
strstr : for :  * 1) we invoke migration_cpu_stop() on the target CPU using : 
strstr : while :  * 1) we invoke migration_cpu_stop() on the target CPU using : 
str :  *    stop_one_cpu().
strstr : INIT :  *    stop_one_cpu(). : 
strstr : if :  *    stop_one_cpu(). : 
strstr : for :  *    stop_one_cpu(). : 
strstr : while :  *    stop_one_cpu(). : 
str :  * 2) stopper starts to run (implicitly forcing the migrated thread
strstr : INIT :  * 2) stopper starts to run (implicitly forcing the migrated thread : 
strstr : if :  * 2) stopper starts to run (implicitly forcing the migrated thread : 
strstr : for :  * 2) stopper starts to run (implicitly forcing the migrated thread : 
strstr : while :  * 2) stopper starts to run (implicitly forcing the migrated thread : 
str :  *    off the CPU)
strstr : INIT :  *    off the CPU) : 
strstr : if :  *    off the CPU) : 
strstr : for :  *    off the CPU) : 
strstr : while :  *    off the CPU) : 
str :  * 3) it checks whether the migrated task is still in the wrong runqueue.
strstr : INIT :  * 3) it checks whether the migrated task is still in the wrong runqueue. : 
strstr : if :  * 3) it checks whether the migrated task is still in the wrong runqueue. : 
strstr : for :  * 3) it checks whether the migrated task is still in the wrong runqueue. : 
strstr : while :  * 3) it checks whether the migrated task is still in the wrong runqueue. : 
str :  * 4) if it's in the wrong runqueue then the migration thread removes
strstr : INIT :  * 4) if it's in the wrong runqueue then the migration thread removes : 
strstr : if :  * 4) if it's in the wrong runqueue then the migration thread removes : 
strstr : for :  * 4) if it's in the wrong runqueue then the migration thread removes : 
strstr : while :  * 4) if it's in the wrong runqueue then the migration thread removes : 
str :  *    it and puts it into the right queue.
strstr : INIT :  *    it and puts it into the right queue. : 
strstr : if :  *    it and puts it into the right queue. : 
strstr : for :  *    it and puts it into the right queue. : 
strstr : while :  *    it and puts it into the right queue. : 
str :  * 5) stopper completes and stop_one_cpu() returns and the migration
strstr : INIT :  * 5) stopper completes and stop_one_cpu() returns and the migration : 
strstr : if :  * 5) stopper completes and stop_one_cpu() returns and the migration : 
strstr : for :  * 5) stopper completes and stop_one_cpu() returns and the migration : 
strstr : while :  * 5) stopper completes and stop_one_cpu() returns and the migration : 
str :  *    is done.
strstr : INIT :  *    is done. : 
strstr : if :  *    is done. : 
strstr : for :  *    is done. : 
strstr : while :  *    is done. : 
str :  */
strstr : INIT :  */ : 
strstr : if :  */ : 
strstr : for :  */ : 
strstr : while :  */ : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : /*
strstr : if : /* : 
strstr : for : /* : 
strstr : while : /* : 
str :  * Change a given task's CPU affinity. Migrate the thread to a
strstr : INIT :  * Change a given task's CPU affinity. Migrate the thread to a : 
strstr : if :  * Change a given task's CPU affinity. Migrate the thread to a : 
strstr : for :  * Change a given task's CPU affinity. Migrate the thread to a : 
strstr : while :  * Change a given task's CPU affinity. Migrate the thread to a : 
str :  * proper CPU and schedule it away if the CPU it's executing on
strstr : INIT :  * proper CPU and schedule it away if the CPU it's executing on : 
strstr : if :  * proper CPU and schedule it away if the CPU it's executing on : 
strstr : for :  * proper CPU and schedule it away if the CPU it's executing on : 
strstr : while :  * proper CPU and schedule it away if the CPU it's executing on : 
str :  * is removed from the allowed bitmask.
strstr : INIT :  * is removed from the allowed bitmask. : 
strstr : if :  * is removed from the allowed bitmask. : 
strstr : for :  * is removed from the allowed bitmask. : 
strstr : while :  * is removed from the allowed bitmask. : 
str :  *
strstr : INIT :  * : 
strstr : if :  * : 
strstr : for :  * : 
strstr : while :  * : 
str :  * NOTE: the caller must have a valid reference to the task, the
strstr : INIT :  * NOTE: the caller must have a valid reference to the task, the : 
strstr : if :  * NOTE: the caller must have a valid reference to the task, the : 
strstr : for :  * NOTE: the caller must have a valid reference to the task, the : 
strstr : while :  * NOTE: the caller must have a valid reference to the task, the : 
str :  * task must not exit() & deallocate itself prematurely. The
strstr : INIT :  * task must not exit() & deallocate itself prematurely. The : 
strstr : if :  * task must not exit() & deallocate itself prematurely. The : 
strstr : for :  * task must not exit() & deallocate itself prematurely. The : 
strstr : while :  * task must not exit() & deallocate itself prematurely. The : 
str :  * call is not atomic; no spinlocks may be held.
strstr : INIT :  * call is not atomic; no spinlocks may be held. : 
strstr : if :  * call is not atomic; no spinlocks may be held. : 
strstr : for :  * call is not atomic; no spinlocks may be held. : 
strstr : while :  * call is not atomic; no spinlocks may be held. : 
str :  */
strstr : INIT :  */ : 
strstr : if :  */ : 
strstr : for :  */ : 
strstr : while :  */ : 
str : int set_cpus_allowed_ptr(struct task_struct *p, const struct cpumask *new_mask)
strstr : INIT : int set_cpus_allowed_ptr(struct task_struct *p, const struct cpumask *new_mask) : 
strstr : if : int set_cpus_allowed_ptr(struct task_struct *p, const struct cpumask *new_mask) : 
strstr : for : int set_cpus_allowed_ptr(struct task_struct *p, const struct cpumask *new_mask) : 
strstr : while : int set_cpus_allowed_ptr(struct task_struct *p, const struct cpumask *new_mask) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	unsigned long flags;
strstr : INIT : 	unsigned long flags; : 
strstr : if : 	unsigned long flags; : 
strstr : for : 	unsigned long flags; : 
strstr : while : 	unsigned long flags; : 
str : 	struct rq *rq;
strstr : INIT : 	struct rq *rq; : 
strstr : if : 	struct rq *rq; : 
strstr : for : 	struct rq *rq; : 
strstr : while : 	struct rq *rq; : 
str : 	unsigned int dest_cpu;
strstr : INIT : 	unsigned int dest_cpu; : 
strstr : if : 	unsigned int dest_cpu; : 
strstr : for : 	unsigned int dest_cpu; : 
strstr : while : 	unsigned int dest_cpu; : 
str : 	int ret = 0;
strstr : INIT : 	int ret = 0; : 
strstr : if : 	int ret = 0; : 
strstr : for : 	int ret = 0; : 
strstr : while : 	int ret = 0; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	rq = task_rq_lock(p, &flags);
strstr : if : 	rq = task_rq_lock(p, &flags); : 
strstr : for : 	rq = task_rq_lock(p, &flags); : 
strstr : while : 	rq = task_rq_lock(p, &flags); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	if (cpumask_equal(&p->cpus_allowed, new_mask))
strstr : if : 	if (cpumask_equal(&p->cpus_allowed, new_mask)) : 
strstr : for : 	if (cpumask_equal(&p->cpus_allowed, new_mask)) : 
strstr : while : 	if (cpumask_equal(&p->cpus_allowed, new_mask)) : 
str : 		goto out;
strstr : INIT : 		goto out; : 
strstr : if : 		goto out; : 
strstr : for : 		goto out; : 
strstr : while : 		goto out; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	if (!cpumask_intersects(new_mask, cpu_active_mask)) {
strstr : if : 	if (!cpumask_intersects(new_mask, cpu_active_mask)) { : 
strstr : for : 	if (!cpumask_intersects(new_mask, cpu_active_mask)) { : 
strstr : while : 	if (!cpumask_intersects(new_mask, cpu_active_mask)) { : 
str : 		ret = -EINVAL;
strstr : INIT : 		ret = -EINVAL; : 
strstr : if : 		ret = -EINVAL; : 
strstr : for : 		ret = -EINVAL; : 
strstr : while : 		ret = -EINVAL; : 
str : 		goto out;
strstr : INIT : 		goto out; : 
strstr : if : 		goto out; : 
strstr : for : 		goto out; : 
strstr : while : 		goto out; : 
str : 	}
strstr : INIT : 	} : 
strstr : if : 	} : 
strstr : for : 	} : 
strstr : while : 	} : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	do_set_cpus_allowed(p, new_mask);
strstr : if : 	do_set_cpus_allowed(p, new_mask); : 
strstr : for : 	do_set_cpus_allowed(p, new_mask); : 
strstr : while : 	do_set_cpus_allowed(p, new_mask); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	/* Can the task run on the task's current CPU? If so, we're done */
strstr : if : 	/* Can the task run on the task's current CPU? If so, we're done */ : 
strstr : for : 	/* Can the task run on the task's current CPU? If so, we're done */ : 
strstr : while : 	/* Can the task run on the task's current CPU? If so, we're done */ : 
str : 	if (cpumask_test_cpu(task_cpu(p), new_mask))
strstr : INIT : 	if (cpumask_test_cpu(task_cpu(p), new_mask)) : 
strstr : if : 	if (cpumask_test_cpu(task_cpu(p), new_mask)) : 
strstr : for : 	if (cpumask_test_cpu(task_cpu(p), new_mask)) : 
strstr : while : 	if (cpumask_test_cpu(task_cpu(p), new_mask)) : 
str : 		goto out;
strstr : INIT : 		goto out; : 
strstr : if : 		goto out; : 
strstr : for : 		goto out; : 
strstr : while : 		goto out; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	dest_cpu = cpumask_any_and(cpu_active_mask, new_mask);
strstr : if : 	dest_cpu = cpumask_any_and(cpu_active_mask, new_mask); : 
strstr : for : 	dest_cpu = cpumask_any_and(cpu_active_mask, new_mask); : 
strstr : while : 	dest_cpu = cpumask_any_and(cpu_active_mask, new_mask); : 
str : 	if (p->on_rq) {
strstr : INIT : 	if (p->on_rq) { : 
strstr : if : 	if (p->on_rq) { : 
strstr : for : 	if (p->on_rq) { : 
strstr : while : 	if (p->on_rq) { : 
str : 		struct migration_arg arg = { p, dest_cpu };
strstr : INIT : 		struct migration_arg arg = { p, dest_cpu }; : 
strstr : if : 		struct migration_arg arg = { p, dest_cpu }; : 
strstr : for : 		struct migration_arg arg = { p, dest_cpu }; : 
strstr : while : 		struct migration_arg arg = { p, dest_cpu }; : 
str : 		/* Need help from migration thread: drop lock and wait. */
strstr : INIT : 		/* Need help from migration thread: drop lock and wait. */ : 
strstr : if : 		/* Need help from migration thread: drop lock and wait. */ : 
strstr : for : 		/* Need help from migration thread: drop lock and wait. */ : 
strstr : while : 		/* Need help from migration thread: drop lock and wait. */ : 
str : 		task_rq_unlock(rq, p, &flags);
strstr : INIT : 		task_rq_unlock(rq, p, &flags); : 
strstr : if : 		task_rq_unlock(rq, p, &flags); : 
strstr : for : 		task_rq_unlock(rq, p, &flags); : 
strstr : while : 		task_rq_unlock(rq, p, &flags); : 
str : 		stop_one_cpu(cpu_of(rq), migration_cpu_stop, &arg);
strstr : INIT : 		stop_one_cpu(cpu_of(rq), migration_cpu_stop, &arg); : 
strstr : if : 		stop_one_cpu(cpu_of(rq), migration_cpu_stop, &arg); : 
strstr : for : 		stop_one_cpu(cpu_of(rq), migration_cpu_stop, &arg); : 
strstr : while : 		stop_one_cpu(cpu_of(rq), migration_cpu_stop, &arg); : 
str : 		tlb_migrate_finish(p->mm);
strstr : INIT : 		tlb_migrate_finish(p->mm); : 
strstr : if : 		tlb_migrate_finish(p->mm); : 
strstr : for : 		tlb_migrate_finish(p->mm); : 
strstr : while : 		tlb_migrate_finish(p->mm); : 
str : 		return 0;
strstr : INIT : 		return 0; : 
strstr : if : 		return 0; : 
strstr : for : 		return 0; : 
strstr : while : 		return 0; : 
str : 	}
strstr : INIT : 	} : 
strstr : if : 	} : 
strstr : for : 	} : 
strstr : while : 	} : 
str : out:
strstr : INIT : out: : 
strstr : if : out: : 
strstr : for : out: : 
strstr : while : out: : 
str : 	task_rq_unlock(rq, p, &flags);
strstr : INIT : 	task_rq_unlock(rq, p, &flags); : 
strstr : if : 	task_rq_unlock(rq, p, &flags); : 
strstr : for : 	task_rq_unlock(rq, p, &flags); : 
strstr : while : 	task_rq_unlock(rq, p, &flags); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	return ret;
strstr : if : 	return ret; : 
strstr : for : 	return ret; : 
strstr : while : 	return ret; : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : EXPORT_SYMBOL_GPL(set_cpus_allowed_ptr);
strstr : INIT : EXPORT_SYMBOL_GPL(set_cpus_allowed_ptr); : 
strstr : if : EXPORT_SYMBOL_GPL(set_cpus_allowed_ptr); : 
strstr : for : EXPORT_SYMBOL_GPL(set_cpus_allowed_ptr); : 
strstr : while : EXPORT_SYMBOL_GPL(set_cpus_allowed_ptr); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : /*
strstr : if : /* : 
strstr : for : /* : 
strstr : while : /* : 
str :  * Move (not current) task off this cpu, onto dest cpu. We're doing
strstr : INIT :  * Move (not current) task off this cpu, onto dest cpu. We're doing : 
strstr : if :  * Move (not current) task off this cpu, onto dest cpu. We're doing : 
strstr : for :  * Move (not current) task off this cpu, onto dest cpu. We're doing : 
strstr : while :  * Move (not current) task off this cpu, onto dest cpu. We're doing : 
str :  * this because either it can't run here any more (set_cpus_allowed()
strstr : INIT :  * this because either it can't run here any more (set_cpus_allowed() : 
strstr : if :  * this because either it can't run here any more (set_cpus_allowed() : 
strstr : for :  * this because either it can't run here any more (set_cpus_allowed() : 
strstr : while :  * this because either it can't run here any more (set_cpus_allowed() : 
str :  * away from this CPU, or CPU going down), or because we're
strstr : INIT :  * away from this CPU, or CPU going down), or because we're : 
strstr : if :  * away from this CPU, or CPU going down), or because we're : 
strstr : for :  * away from this CPU, or CPU going down), or because we're : 
strstr : while :  * away from this CPU, or CPU going down), or because we're : 
str :  * attempting to rebalance this task on exec (sched_exec).
strstr : INIT :  * attempting to rebalance this task on exec (sched_exec). : 
strstr : if :  * attempting to rebalance this task on exec (sched_exec). : 
strstr : for :  * attempting to rebalance this task on exec (sched_exec). : 
strstr : while :  * attempting to rebalance this task on exec (sched_exec). : 
str :  *
strstr : INIT :  * : 
strstr : if :  * : 
strstr : for :  * : 
strstr : while :  * : 
str :  * So we race with normal scheduler movements, but that's OK, as long
strstr : INIT :  * So we race with normal scheduler movements, but that's OK, as long : 
strstr : if :  * So we race with normal scheduler movements, but that's OK, as long : 
strstr : for :  * So we race with normal scheduler movements, but that's OK, as long : 
strstr : while :  * So we race with normal scheduler movements, but that's OK, as long : 
str :  * as the task is no longer on this CPU.
strstr : INIT :  * as the task is no longer on this CPU. : 
strstr : if :  * as the task is no longer on this CPU. : 
strstr : for :  * as the task is no longer on this CPU. : 
strstr : while :  * as the task is no longer on this CPU. : 
str :  *
strstr : INIT :  * : 
strstr : if :  * : 
strstr : for :  * : 
strstr : while :  * : 
str :  * Returns non-zero if task was successfully migrated.
strstr : INIT :  * Returns non-zero if task was successfully migrated. : 
strstr : if :  * Returns non-zero if task was successfully migrated. : 
strstr : for :  * Returns non-zero if task was successfully migrated. : 
strstr : while :  * Returns non-zero if task was successfully migrated. : 
str :  */
strstr : INIT :  */ : 
strstr : if :  */ : 
strstr : for :  */ : 
strstr : while :  */ : 
str : static int __migrate_task(struct task_struct *p, int src_cpu, int dest_cpu)
strstr : INIT : static int __migrate_task(struct task_struct *p, int src_cpu, int dest_cpu) : 
strstr : if : static int __migrate_task(struct task_struct *p, int src_cpu, int dest_cpu) : 
strstr : for : static int __migrate_task(struct task_struct *p, int src_cpu, int dest_cpu) : 
strstr : while : static int __migrate_task(struct task_struct *p, int src_cpu, int dest_cpu) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	struct rq *rq_dest, *rq_src;
strstr : INIT : 	struct rq *rq_dest, *rq_src; : 
strstr : if : 	struct rq *rq_dest, *rq_src; : 
strstr : for : 	struct rq *rq_dest, *rq_src; : 
strstr : while : 	struct rq *rq_dest, *rq_src; : 
str : 	int ret = 0;
strstr : INIT : 	int ret = 0; : 
strstr : if : 	int ret = 0; : 
strstr : for : 	int ret = 0; : 
strstr : while : 	int ret = 0; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	if (unlikely(!cpu_active(dest_cpu)))
strstr : if : 	if (unlikely(!cpu_active(dest_cpu))) : 
strstr : for : 	if (unlikely(!cpu_active(dest_cpu))) : 
strstr : while : 	if (unlikely(!cpu_active(dest_cpu))) : 
str : 		return ret;
strstr : INIT : 		return ret; : 
strstr : if : 		return ret; : 
strstr : for : 		return ret; : 
strstr : while : 		return ret; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	rq_src = cpu_rq(src_cpu);
strstr : if : 	rq_src = cpu_rq(src_cpu); : 
strstr : for : 	rq_src = cpu_rq(src_cpu); : 
strstr : while : 	rq_src = cpu_rq(src_cpu); : 
str : 	rq_dest = cpu_rq(dest_cpu);
strstr : INIT : 	rq_dest = cpu_rq(dest_cpu); : 
strstr : if : 	rq_dest = cpu_rq(dest_cpu); : 
strstr : for : 	rq_dest = cpu_rq(dest_cpu); : 
strstr : while : 	rq_dest = cpu_rq(dest_cpu); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	raw_spin_lock(&p->pi_lock);
strstr : if : 	raw_spin_lock(&p->pi_lock); : 
strstr : for : 	raw_spin_lock(&p->pi_lock); : 
strstr : while : 	raw_spin_lock(&p->pi_lock); : 
str : 	double_rq_lock(rq_src, rq_dest);
strstr : INIT : 	double_rq_lock(rq_src, rq_dest); : 
strstr : if : 	double_rq_lock(rq_src, rq_dest); : 
strstr : for : 	double_rq_lock(rq_src, rq_dest); : 
strstr : while : 	double_rq_lock(rq_src, rq_dest); : 
str : 	/* Already moved. */
strstr : INIT : 	/* Already moved. */ : 
strstr : if : 	/* Already moved. */ : 
strstr : for : 	/* Already moved. */ : 
strstr : while : 	/* Already moved. */ : 
str : 	if (task_cpu(p) != src_cpu)
strstr : INIT : 	if (task_cpu(p) != src_cpu) : 
strstr : if : 	if (task_cpu(p) != src_cpu) : 
strstr : for : 	if (task_cpu(p) != src_cpu) : 
strstr : while : 	if (task_cpu(p) != src_cpu) : 
str : 		goto done;
strstr : INIT : 		goto done; : 
strstr : if : 		goto done; : 
strstr : for : 		goto done; : 
strstr : while : 		goto done; : 
str : 	/* Affinity changed (again). */
strstr : INIT : 	/* Affinity changed (again). */ : 
strstr : if : 	/* Affinity changed (again). */ : 
strstr : for : 	/* Affinity changed (again). */ : 
strstr : while : 	/* Affinity changed (again). */ : 
str : 	if (!cpumask_test_cpu(dest_cpu, tsk_cpus_allowed(p)))
strstr : INIT : 	if (!cpumask_test_cpu(dest_cpu, tsk_cpus_allowed(p))) : 
strstr : if : 	if (!cpumask_test_cpu(dest_cpu, tsk_cpus_allowed(p))) : 
strstr : for : 	if (!cpumask_test_cpu(dest_cpu, tsk_cpus_allowed(p))) : 
strstr : while : 	if (!cpumask_test_cpu(dest_cpu, tsk_cpus_allowed(p))) : 
str : 		goto fail;
strstr : INIT : 		goto fail; : 
strstr : if : 		goto fail; : 
strstr : for : 		goto fail; : 
strstr : while : 		goto fail; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	/*
strstr : if : 	/* : 
strstr : for : 	/* : 
strstr : while : 	/* : 
str : 	 * If we're not on a rq, the next wake-up will ensure we're
strstr : INIT : 	 * If we're not on a rq, the next wake-up will ensure we're : 
strstr : if : 	 * If we're not on a rq, the next wake-up will ensure we're : 
strstr : for : 	 * If we're not on a rq, the next wake-up will ensure we're : 
strstr : while : 	 * If we're not on a rq, the next wake-up will ensure we're : 
str : 	 * placed properly.
strstr : INIT : 	 * placed properly. : 
strstr : if : 	 * placed properly. : 
strstr : for : 	 * placed properly. : 
strstr : while : 	 * placed properly. : 
str : 	 */
strstr : INIT : 	 */ : 
strstr : if : 	 */ : 
strstr : for : 	 */ : 
strstr : while : 	 */ : 
str : 	if (p->on_rq) {
strstr : INIT : 	if (p->on_rq) { : 
strstr : if : 	if (p->on_rq) { : 
strstr : for : 	if (p->on_rq) { : 
strstr : while : 	if (p->on_rq) { : 
str : 		dequeue_task(rq_src, p, 0);
strstr : INIT : 		dequeue_task(rq_src, p, 0); : 
strstr : if : 		dequeue_task(rq_src, p, 0); : 
strstr : for : 		dequeue_task(rq_src, p, 0); : 
strstr : while : 		dequeue_task(rq_src, p, 0); : 
str : 		set_task_cpu(p, dest_cpu);
strstr : INIT : 		set_task_cpu(p, dest_cpu); : 
strstr : if : 		set_task_cpu(p, dest_cpu); : 
strstr : for : 		set_task_cpu(p, dest_cpu); : 
strstr : while : 		set_task_cpu(p, dest_cpu); : 
str : 		enqueue_task(rq_dest, p, 0);
strstr : INIT : 		enqueue_task(rq_dest, p, 0); : 
strstr : if : 		enqueue_task(rq_dest, p, 0); : 
strstr : for : 		enqueue_task(rq_dest, p, 0); : 
strstr : while : 		enqueue_task(rq_dest, p, 0); : 
str : 		check_preempt_curr(rq_dest, p, 0);
strstr : INIT : 		check_preempt_curr(rq_dest, p, 0); : 
strstr : if : 		check_preempt_curr(rq_dest, p, 0); : 
strstr : for : 		check_preempt_curr(rq_dest, p, 0); : 
strstr : while : 		check_preempt_curr(rq_dest, p, 0); : 
str : 	}
strstr : INIT : 	} : 
strstr : if : 	} : 
strstr : for : 	} : 
strstr : while : 	} : 
str : done:
strstr : INIT : done: : 
strstr : if : done: : 
strstr : for : done: : 
strstr : while : done: : 
str : 	ret = 1;
strstr : INIT : 	ret = 1; : 
strstr : if : 	ret = 1; : 
strstr : for : 	ret = 1; : 
strstr : while : 	ret = 1; : 
str : fail:
strstr : INIT : fail: : 
strstr : if : fail: : 
strstr : for : fail: : 
strstr : while : fail: : 
str : 	double_rq_unlock(rq_src, rq_dest);
strstr : INIT : 	double_rq_unlock(rq_src, rq_dest); : 
strstr : if : 	double_rq_unlock(rq_src, rq_dest); : 
strstr : for : 	double_rq_unlock(rq_src, rq_dest); : 
strstr : while : 	double_rq_unlock(rq_src, rq_dest); : 
str : 	raw_spin_unlock(&p->pi_lock);
strstr : INIT : 	raw_spin_unlock(&p->pi_lock); : 
strstr : if : 	raw_spin_unlock(&p->pi_lock); : 
strstr : for : 	raw_spin_unlock(&p->pi_lock); : 
strstr : while : 	raw_spin_unlock(&p->pi_lock); : 
str : 	return ret;
strstr : INIT : 	return ret; : 
strstr : if : 	return ret; : 
strstr : for : 	return ret; : 
strstr : while : 	return ret; : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : #ifdef CONFIG_NUMA_BALANCING
strstr : if : #ifdef CONFIG_NUMA_BALANCING : 
strstr : for : #ifdef CONFIG_NUMA_BALANCING : 
strstr : while : #ifdef CONFIG_NUMA_BALANCING : 
str : /* Migrate current task p to target_cpu */
strstr : INIT : /* Migrate current task p to target_cpu */ : 
strstr : if : /* Migrate current task p to target_cpu */ : 
strstr : for : /* Migrate current task p to target_cpu */ : 
strstr : while : /* Migrate current task p to target_cpu */ : 
str : int migrate_task_to(struct task_struct *p, int target_cpu)
strstr : INIT : int migrate_task_to(struct task_struct *p, int target_cpu) : 
strstr : if : int migrate_task_to(struct task_struct *p, int target_cpu) : 
strstr : for : int migrate_task_to(struct task_struct *p, int target_cpu) : 
strstr : while : int migrate_task_to(struct task_struct *p, int target_cpu) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	struct migration_arg arg = { p, target_cpu };
strstr : INIT : 	struct migration_arg arg = { p, target_cpu }; : 
strstr : if : 	struct migration_arg arg = { p, target_cpu }; : 
strstr : for : 	struct migration_arg arg = { p, target_cpu }; : 
strstr : while : 	struct migration_arg arg = { p, target_cpu }; : 
str : 	int curr_cpu = task_cpu(p);
strstr : INIT : 	int curr_cpu = task_cpu(p); : 
strstr : if : 	int curr_cpu = task_cpu(p); : 
strstr : for : 	int curr_cpu = task_cpu(p); : 
strstr : while : 	int curr_cpu = task_cpu(p); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	if (curr_cpu == target_cpu)
strstr : if : 	if (curr_cpu == target_cpu) : 
strstr : for : 	if (curr_cpu == target_cpu) : 
strstr : while : 	if (curr_cpu == target_cpu) : 
str : 		return 0;
strstr : INIT : 		return 0; : 
strstr : if : 		return 0; : 
strstr : for : 		return 0; : 
strstr : while : 		return 0; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	if (!cpumask_test_cpu(target_cpu, tsk_cpus_allowed(p)))
strstr : if : 	if (!cpumask_test_cpu(target_cpu, tsk_cpus_allowed(p))) : 
strstr : for : 	if (!cpumask_test_cpu(target_cpu, tsk_cpus_allowed(p))) : 
strstr : while : 	if (!cpumask_test_cpu(target_cpu, tsk_cpus_allowed(p))) : 
str : 		return -EINVAL;
strstr : INIT : 		return -EINVAL; : 
strstr : if : 		return -EINVAL; : 
strstr : for : 		return -EINVAL; : 
strstr : while : 		return -EINVAL; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	/* TODO: This is not properly updating schedstats */
strstr : if : 	/* TODO: This is not properly updating schedstats */ : 
strstr : for : 	/* TODO: This is not properly updating schedstats */ : 
strstr : while : 	/* TODO: This is not properly updating schedstats */ : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	trace_sched_move_numa(p, curr_cpu, target_cpu);
strstr : if : 	trace_sched_move_numa(p, curr_cpu, target_cpu); : 
strstr : for : 	trace_sched_move_numa(p, curr_cpu, target_cpu); : 
strstr : while : 	trace_sched_move_numa(p, curr_cpu, target_cpu); : 
str : 	return stop_one_cpu(curr_cpu, migration_cpu_stop, &arg);
strstr : INIT : 	return stop_one_cpu(curr_cpu, migration_cpu_stop, &arg); : 
strstr : if : 	return stop_one_cpu(curr_cpu, migration_cpu_stop, &arg); : 
strstr : for : 	return stop_one_cpu(curr_cpu, migration_cpu_stop, &arg); : 
strstr : while : 	return stop_one_cpu(curr_cpu, migration_cpu_stop, &arg); : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : /*
strstr : if : /* : 
strstr : for : /* : 
strstr : while : /* : 
str :  * Requeue a task on a given node and accurately track the number of NUMA
strstr : INIT :  * Requeue a task on a given node and accurately track the number of NUMA : 
strstr : if :  * Requeue a task on a given node and accurately track the number of NUMA : 
strstr : for :  * Requeue a task on a given node and accurately track the number of NUMA : 
strstr : while :  * Requeue a task on a given node and accurately track the number of NUMA : 
str :  * tasks on the runqueues
strstr : INIT :  * tasks on the runqueues : 
strstr : if :  * tasks on the runqueues : 
strstr : for :  * tasks on the runqueues : 
strstr : while :  * tasks on the runqueues : 
str :  */
strstr : INIT :  */ : 
strstr : if :  */ : 
strstr : for :  */ : 
strstr : while :  */ : 
str : void sched_setnuma(struct task_struct *p, int nid)
strstr : INIT : void sched_setnuma(struct task_struct *p, int nid) : 
strstr : if : void sched_setnuma(struct task_struct *p, int nid) : 
strstr : for : void sched_setnuma(struct task_struct *p, int nid) : 
strstr : while : void sched_setnuma(struct task_struct *p, int nid) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	struct rq *rq;
strstr : INIT : 	struct rq *rq; : 
strstr : if : 	struct rq *rq; : 
strstr : for : 	struct rq *rq; : 
strstr : while : 	struct rq *rq; : 
str : 	unsigned long flags;
strstr : INIT : 	unsigned long flags; : 
strstr : if : 	unsigned long flags; : 
strstr : for : 	unsigned long flags; : 
strstr : while : 	unsigned long flags; : 
str : 	bool on_rq, running;
strstr : INIT : 	bool on_rq, running; : 
strstr : if : 	bool on_rq, running; : 
strstr : for : 	bool on_rq, running; : 
strstr : while : 	bool on_rq, running; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	rq = task_rq_lock(p, &flags);
strstr : if : 	rq = task_rq_lock(p, &flags); : 
strstr : for : 	rq = task_rq_lock(p, &flags); : 
strstr : while : 	rq = task_rq_lock(p, &flags); : 
str : 	on_rq = p->on_rq;
strstr : INIT : 	on_rq = p->on_rq; : 
strstr : if : 	on_rq = p->on_rq; : 
strstr : for : 	on_rq = p->on_rq; : 
strstr : while : 	on_rq = p->on_rq; : 
str : 	running = task_current(rq, p);
strstr : INIT : 	running = task_current(rq, p); : 
strstr : if : 	running = task_current(rq, p); : 
strstr : for : 	running = task_current(rq, p); : 
strstr : while : 	running = task_current(rq, p); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	if (on_rq)
strstr : if : 	if (on_rq) : 
strstr : for : 	if (on_rq) : 
strstr : while : 	if (on_rq) : 
str : 		dequeue_task(rq, p, 0);
strstr : INIT : 		dequeue_task(rq, p, 0); : 
strstr : if : 		dequeue_task(rq, p, 0); : 
strstr : for : 		dequeue_task(rq, p, 0); : 
strstr : while : 		dequeue_task(rq, p, 0); : 
str : 	if (running)
strstr : INIT : 	if (running) : 
strstr : if : 	if (running) : 
strstr : for : 	if (running) : 
strstr : while : 	if (running) : 
str : 		p->sched_class->put_prev_task(rq, p);
strstr : INIT : 		p->sched_class->put_prev_task(rq, p); : 
strstr : if : 		p->sched_class->put_prev_task(rq, p); : 
strstr : for : 		p->sched_class->put_prev_task(rq, p); : 
strstr : while : 		p->sched_class->put_prev_task(rq, p); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	p->numa_preferred_nid = nid;
strstr : if : 	p->numa_preferred_nid = nid; : 
strstr : for : 	p->numa_preferred_nid = nid; : 
strstr : while : 	p->numa_preferred_nid = nid; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	if (running)
strstr : if : 	if (running) : 
strstr : for : 	if (running) : 
strstr : while : 	if (running) : 
str : 		p->sched_class->set_curr_task(rq);
strstr : INIT : 		p->sched_class->set_curr_task(rq); : 
strstr : if : 		p->sched_class->set_curr_task(rq); : 
strstr : for : 		p->sched_class->set_curr_task(rq); : 
strstr : while : 		p->sched_class->set_curr_task(rq); : 
str : 	if (on_rq)
strstr : INIT : 	if (on_rq) : 
strstr : if : 	if (on_rq) : 
strstr : for : 	if (on_rq) : 
strstr : while : 	if (on_rq) : 
str : 		enqueue_task(rq, p, 0);
strstr : INIT : 		enqueue_task(rq, p, 0); : 
strstr : if : 		enqueue_task(rq, p, 0); : 
strstr : for : 		enqueue_task(rq, p, 0); : 
strstr : while : 		enqueue_task(rq, p, 0); : 
str : 	task_rq_unlock(rq, p, &flags);
strstr : INIT : 	task_rq_unlock(rq, p, &flags); : 
strstr : if : 	task_rq_unlock(rq, p, &flags); : 
strstr : for : 	task_rq_unlock(rq, p, &flags); : 
strstr : while : 	task_rq_unlock(rq, p, &flags); : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : #endif
strstr : INIT : #endif : 
strstr : if : #endif : 
strstr : for : #endif : 
strstr : while : #endif : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : /*
strstr : if : /* : 
strstr : for : /* : 
strstr : while : /* : 
str :  * migration_cpu_stop - this will be executed by a highprio stopper thread
strstr : INIT :  * migration_cpu_stop - this will be executed by a highprio stopper thread : 
strstr : if :  * migration_cpu_stop - this will be executed by a highprio stopper thread : 
strstr : for :  * migration_cpu_stop - this will be executed by a highprio stopper thread : 
strstr : while :  * migration_cpu_stop - this will be executed by a highprio stopper thread : 
str :  * and performs thread migration by bumping thread off CPU then
strstr : INIT :  * and performs thread migration by bumping thread off CPU then : 
strstr : if :  * and performs thread migration by bumping thread off CPU then : 
strstr : for :  * and performs thread migration by bumping thread off CPU then : 
strstr : while :  * and performs thread migration by bumping thread off CPU then : 
str :  * 'pushing' onto another runqueue.
strstr : INIT :  * 'pushing' onto another runqueue. : 
strstr : if :  * 'pushing' onto another runqueue. : 
strstr : for :  * 'pushing' onto another runqueue. : 
strstr : while :  * 'pushing' onto another runqueue. : 
str :  */
strstr : INIT :  */ : 
strstr : if :  */ : 
strstr : for :  */ : 
strstr : while :  */ : 
str : static int migration_cpu_stop(void *data)
strstr : INIT : static int migration_cpu_stop(void *data) : 
strstr : if : static int migration_cpu_stop(void *data) : 
strstr : for : static int migration_cpu_stop(void *data) : 
strstr : while : static int migration_cpu_stop(void *data) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	struct migration_arg *arg = data;
strstr : INIT : 	struct migration_arg *arg = data; : 
strstr : if : 	struct migration_arg *arg = data; : 
strstr : for : 	struct migration_arg *arg = data; : 
strstr : while : 	struct migration_arg *arg = data; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	/*
strstr : if : 	/* : 
strstr : for : 	/* : 
strstr : while : 	/* : 
str : 	 * The original target cpu might have gone down and we might
strstr : INIT : 	 * The original target cpu might have gone down and we might : 
strstr : if : 	 * The original target cpu might have gone down and we might : 
strstr : for : 	 * The original target cpu might have gone down and we might : 
strstr : while : 	 * The original target cpu might have gone down and we might : 
str : 	 * be on another cpu but it doesn't matter.
strstr : INIT : 	 * be on another cpu but it doesn't matter. : 
strstr : if : 	 * be on another cpu but it doesn't matter. : 
strstr : for : 	 * be on another cpu but it doesn't matter. : 
strstr : while : 	 * be on another cpu but it doesn't matter. : 
str : 	 */
strstr : INIT : 	 */ : 
strstr : if : 	 */ : 
strstr : for : 	 */ : 
strstr : while : 	 */ : 
str : 	local_irq_disable();
strstr : INIT : 	local_irq_disable(); : 
strstr : if : 	local_irq_disable(); : 
strstr : for : 	local_irq_disable(); : 
strstr : while : 	local_irq_disable(); : 
str : 	__migrate_task(arg->task, raw_smp_processor_id(), arg->dest_cpu);
strstr : INIT : 	__migrate_task(arg->task, raw_smp_processor_id(), arg->dest_cpu); : 
strstr : if : 	__migrate_task(arg->task, raw_smp_processor_id(), arg->dest_cpu); : 
strstr : for : 	__migrate_task(arg->task, raw_smp_processor_id(), arg->dest_cpu); : 
strstr : while : 	__migrate_task(arg->task, raw_smp_processor_id(), arg->dest_cpu); : 
str : 	local_irq_enable();
strstr : INIT : 	local_irq_enable(); : 
strstr : if : 	local_irq_enable(); : 
strstr : for : 	local_irq_enable(); : 
strstr : while : 	local_irq_enable(); : 
str : 	return 0;
strstr : INIT : 	return 0; : 
strstr : if : 	return 0; : 
strstr : for : 	return 0; : 
strstr : while : 	return 0; : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : #ifdef CONFIG_HOTPLUG_CPU
strstr : if : #ifdef CONFIG_HOTPLUG_CPU : 
strstr : for : #ifdef CONFIG_HOTPLUG_CPU : 
strstr : while : #ifdef CONFIG_HOTPLUG_CPU : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : /*
strstr : if : /* : 
strstr : for : /* : 
strstr : while : /* : 
str :  * Ensures that the idle task is using init_mm right before its cpu goes
strstr : INIT :  * Ensures that the idle task is using init_mm right before its cpu goes : 
strstr : if :  * Ensures that the idle task is using init_mm right before its cpu goes : 
strstr : for :  * Ensures that the idle task is using init_mm right before its cpu goes : 
strstr : while :  * Ensures that the idle task is using init_mm right before its cpu goes : 
str :  * offline.
strstr : INIT :  * offline. : 
strstr : if :  * offline. : 
strstr : for :  * offline. : 
strstr : while :  * offline. : 
str :  */
strstr : INIT :  */ : 
strstr : if :  */ : 
strstr : for :  */ : 
strstr : while :  */ : 
str : void idle_task_exit(void)
strstr : INIT : void idle_task_exit(void) : 
strstr : if : void idle_task_exit(void) : 
strstr : for : void idle_task_exit(void) : 
strstr : while : void idle_task_exit(void) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	struct mm_struct *mm = current->active_mm;
strstr : INIT : 	struct mm_struct *mm = current->active_mm; : 
strstr : if : 	struct mm_struct *mm = current->active_mm; : 
strstr : for : 	struct mm_struct *mm = current->active_mm; : 
strstr : while : 	struct mm_struct *mm = current->active_mm; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	BUG_ON(cpu_online(smp_processor_id()));
strstr : if : 	BUG_ON(cpu_online(smp_processor_id())); : 
strstr : for : 	BUG_ON(cpu_online(smp_processor_id())); : 
strstr : while : 	BUG_ON(cpu_online(smp_processor_id())); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	if (mm != &init_mm)
strstr : if : 	if (mm != &init_mm) : 
strstr : for : 	if (mm != &init_mm) : 
strstr : while : 	if (mm != &init_mm) : 
str : 		switch_mm(mm, &init_mm, current);
strstr : INIT : 		switch_mm(mm, &init_mm, current); : 
strstr : if : 		switch_mm(mm, &init_mm, current); : 
strstr : for : 		switch_mm(mm, &init_mm, current); : 
strstr : while : 		switch_mm(mm, &init_mm, current); : 
str : 	mmdrop(mm);
strstr : INIT : 	mmdrop(mm); : 
strstr : if : 	mmdrop(mm); : 
strstr : for : 	mmdrop(mm); : 
strstr : while : 	mmdrop(mm); : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : /*
strstr : if : /* : 
strstr : for : /* : 
strstr : while : /* : 
str :  * Since this CPU is going 'away' for a while, fold any nr_active delta
strstr : INIT :  * Since this CPU is going 'away' for a while, fold any nr_active delta : 
strstr : if :  * Since this CPU is going 'away' for a while, fold any nr_active delta : 
strstr : for :  * Since this CPU is going 'away' for a while, fold any nr_active delta : 
strstr : while :  * Since this CPU is going 'away' for a while, fold any nr_active delta : 
str :  * we might have. Assumes we're called after migrate_tasks() so that the
strstr : INIT :  * we might have. Assumes we're called after migrate_tasks() so that the : 
strstr : if :  * we might have. Assumes we're called after migrate_tasks() so that the : 
strstr : for :  * we might have. Assumes we're called after migrate_tasks() so that the : 
strstr : while :  * we might have. Assumes we're called after migrate_tasks() so that the : 
str :  * nr_active count is stable.
strstr : INIT :  * nr_active count is stable. : 
strstr : if :  * nr_active count is stable. : 
strstr : for :  * nr_active count is stable. : 
strstr : while :  * nr_active count is stable. : 
str :  *
strstr : INIT :  * : 
strstr : if :  * : 
strstr : for :  * : 
strstr : while :  * : 
str :  * Also see the comment "Global load-average calculations".
strstr : INIT :  * Also see the comment "Global load-average calculations". : 
strstr : if :  * Also see the comment "Global load-average calculations". : 
strstr : for :  * Also see the comment "Global load-average calculations". : 
strstr : while :  * Also see the comment "Global load-average calculations". : 
str :  */
strstr : INIT :  */ : 
strstr : if :  */ : 
strstr : for :  */ : 
strstr : while :  */ : 
str : static void calc_load_migrate(struct rq *rq)
strstr : INIT : static void calc_load_migrate(struct rq *rq) : 
strstr : if : static void calc_load_migrate(struct rq *rq) : 
strstr : for : static void calc_load_migrate(struct rq *rq) : 
strstr : while : static void calc_load_migrate(struct rq *rq) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	long delta = calc_load_fold_active(rq);
strstr : INIT : 	long delta = calc_load_fold_active(rq); : 
strstr : if : 	long delta = calc_load_fold_active(rq); : 
strstr : for : 	long delta = calc_load_fold_active(rq); : 
strstr : while : 	long delta = calc_load_fold_active(rq); : 
str : 	if (delta)
strstr : INIT : 	if (delta) : 
strstr : if : 	if (delta) : 
strstr : for : 	if (delta) : 
strstr : while : 	if (delta) : 
str : 		atomic_long_add(delta, &calc_load_tasks);
strstr : INIT : 		atomic_long_add(delta, &calc_load_tasks); : 
strstr : if : 		atomic_long_add(delta, &calc_load_tasks); : 
strstr : for : 		atomic_long_add(delta, &calc_load_tasks); : 
strstr : while : 		atomic_long_add(delta, &calc_load_tasks); : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : /*
strstr : if : /* : 
strstr : for : /* : 
strstr : while : /* : 
str :  * Migrate all tasks from the rq, sleeping tasks will be migrated by
strstr : INIT :  * Migrate all tasks from the rq, sleeping tasks will be migrated by : 
strstr : if :  * Migrate all tasks from the rq, sleeping tasks will be migrated by : 
strstr : for :  * Migrate all tasks from the rq, sleeping tasks will be migrated by : 
strstr : while :  * Migrate all tasks from the rq, sleeping tasks will be migrated by : 
str :  * try_to_wake_up()->select_task_rq().
strstr : INIT :  * try_to_wake_up()->select_task_rq(). : 
strstr : if :  * try_to_wake_up()->select_task_rq(). : 
strstr : for :  * try_to_wake_up()->select_task_rq(). : 
strstr : while :  * try_to_wake_up()->select_task_rq(). : 
str :  *
strstr : INIT :  * : 
strstr : if :  * : 
strstr : for :  * : 
strstr : while :  * : 
str :  * Called with rq->lock held even though we'er in stop_machine() and
strstr : INIT :  * Called with rq->lock held even though we'er in stop_machine() and : 
strstr : if :  * Called with rq->lock held even though we'er in stop_machine() and : 
strstr : for :  * Called with rq->lock held even though we'er in stop_machine() and : 
strstr : while :  * Called with rq->lock held even though we'er in stop_machine() and : 
str :  * there's no concurrency possible, we hold the required locks anyway
strstr : INIT :  * there's no concurrency possible, we hold the required locks anyway : 
strstr : if :  * there's no concurrency possible, we hold the required locks anyway : 
strstr : for :  * there's no concurrency possible, we hold the required locks anyway : 
strstr : while :  * there's no concurrency possible, we hold the required locks anyway : 
str :  * because of lock validation efforts.
strstr : INIT :  * because of lock validation efforts. : 
strstr : if :  * because of lock validation efforts. : 
strstr : for :  * because of lock validation efforts. : 
strstr : while :  * because of lock validation efforts. : 
str :  */
strstr : INIT :  */ : 
strstr : if :  */ : 
strstr : for :  */ : 
strstr : while :  */ : 
str : static void migrate_tasks(unsigned int dead_cpu)
strstr : INIT : static void migrate_tasks(unsigned int dead_cpu) : 
strstr : if : static void migrate_tasks(unsigned int dead_cpu) : 
strstr : for : static void migrate_tasks(unsigned int dead_cpu) : 
strstr : while : static void migrate_tasks(unsigned int dead_cpu) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	struct rq *rq = cpu_rq(dead_cpu);
strstr : INIT : 	struct rq *rq = cpu_rq(dead_cpu); : 
strstr : if : 	struct rq *rq = cpu_rq(dead_cpu); : 
strstr : for : 	struct rq *rq = cpu_rq(dead_cpu); : 
strstr : while : 	struct rq *rq = cpu_rq(dead_cpu); : 
str : 	struct task_struct *next, *stop = rq->stop;
strstr : INIT : 	struct task_struct *next, *stop = rq->stop; : 
strstr : if : 	struct task_struct *next, *stop = rq->stop; : 
strstr : for : 	struct task_struct *next, *stop = rq->stop; : 
strstr : while : 	struct task_struct *next, *stop = rq->stop; : 
str : 	int dest_cpu;
strstr : INIT : 	int dest_cpu; : 
strstr : if : 	int dest_cpu; : 
strstr : for : 	int dest_cpu; : 
strstr : while : 	int dest_cpu; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	/*
strstr : if : 	/* : 
strstr : for : 	/* : 
strstr : while : 	/* : 
str : 	 * Fudge the rq selection such that the below task selection loop
strstr : INIT : 	 * Fudge the rq selection such that the below task selection loop : 
strstr : if : 	 * Fudge the rq selection such that the below task selection loop : 
strstr : for : 	 * Fudge the rq selection such that the below task selection loop : 
strstr : while : 	 * Fudge the rq selection such that the below task selection loop : 
str : 	 * doesn't get stuck on the currently eligible stop task.
strstr : INIT : 	 * doesn't get stuck on the currently eligible stop task. : 
strstr : if : 	 * doesn't get stuck on the currently eligible stop task. : 
strstr : for : 	 * doesn't get stuck on the currently eligible stop task. : 
strstr : while : 	 * doesn't get stuck on the currently eligible stop task. : 
str : 	 *
strstr : INIT : 	 * : 
strstr : if : 	 * : 
strstr : for : 	 * : 
strstr : while : 	 * : 
str : 	 * We're currently inside stop_machine() and the rq is either stuck
strstr : INIT : 	 * We're currently inside stop_machine() and the rq is either stuck : 
strstr : if : 	 * We're currently inside stop_machine() and the rq is either stuck : 
strstr : for : 	 * We're currently inside stop_machine() and the rq is either stuck : 
strstr : while : 	 * We're currently inside stop_machine() and the rq is either stuck : 
str : 	 * in the stop_machine_cpu_stop() loop, or we're executing this code,
strstr : INIT : 	 * in the stop_machine_cpu_stop() loop, or we're executing this code, : 
strstr : if : 	 * in the stop_machine_cpu_stop() loop, or we're executing this code, : 
strstr : for : 	 * in the stop_machine_cpu_stop() loop, or we're executing this code, : 
strstr : while : 	 * in the stop_machine_cpu_stop() loop, or we're executing this code, : 
str : 	 * either way we should never end up calling schedule() until we're
strstr : INIT : 	 * either way we should never end up calling schedule() until we're : 
strstr : if : 	 * either way we should never end up calling schedule() until we're : 
strstr : for : 	 * either way we should never end up calling schedule() until we're : 
strstr : while : 	 * either way we should never end up calling schedule() until we're : 
str : 	 * done here.
strstr : INIT : 	 * done here. : 
strstr : if : 	 * done here. : 
strstr : for : 	 * done here. : 
strstr : while : 	 * done here. : 
str : 	 */
strstr : INIT : 	 */ : 
strstr : if : 	 */ : 
strstr : for : 	 */ : 
strstr : while : 	 */ : 
str : 	rq->stop = NULL;
strstr : INIT : 	rq->stop = NULL; : 
strstr : if : 	rq->stop = NULL; : 
strstr : for : 	rq->stop = NULL; : 
strstr : while : 	rq->stop = NULL; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	/*
strstr : if : 	/* : 
strstr : for : 	/* : 
strstr : while : 	/* : 
str : 	 * put_prev_task() and pick_next_task() sched
strstr : INIT : 	 * put_prev_task() and pick_next_task() sched : 
strstr : if : 	 * put_prev_task() and pick_next_task() sched : 
strstr : for : 	 * put_prev_task() and pick_next_task() sched : 
strstr : while : 	 * put_prev_task() and pick_next_task() sched : 
str : 	 * class method both need to have an up-to-date
strstr : INIT : 	 * class method both need to have an up-to-date : 
strstr : if : 	 * class method both need to have an up-to-date : 
strstr : for : 	 * class method both need to have an up-to-date : 
strstr : while : 	 * class method both need to have an up-to-date : 
str : 	 * value of rq->clock[_task]
strstr : INIT : 	 * value of rq->clock[_task] : 
strstr : if : 	 * value of rq->clock[_task] : 
strstr : for : 	 * value of rq->clock[_task] : 
strstr : while : 	 * value of rq->clock[_task] : 
str : 	 */
strstr : INIT : 	 */ : 
strstr : if : 	 */ : 
strstr : for : 	 */ : 
strstr : while : 	 */ : 
str : 	update_rq_clock(rq);
strstr : INIT : 	update_rq_clock(rq); : 
strstr : if : 	update_rq_clock(rq); : 
strstr : for : 	update_rq_clock(rq); : 
strstr : while : 	update_rq_clock(rq); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	for ( ; ; ) {
strstr : if : 	for ( ; ; ) { : 
strstr : for : 	for ( ; ; ) { : 
strstr : while : 	for ( ; ; ) { : 
str : 		/*
strstr : INIT : 		/* : 
strstr : if : 		/* : 
strstr : for : 		/* : 
strstr : while : 		/* : 
str : 		 * There's this thread running, bail when that's the only
strstr : INIT : 		 * There's this thread running, bail when that's the only : 
strstr : if : 		 * There's this thread running, bail when that's the only : 
strstr : for : 		 * There's this thread running, bail when that's the only : 
strstr : while : 		 * There's this thread running, bail when that's the only : 
str : 		 * remaining thread.
strstr : INIT : 		 * remaining thread. : 
strstr : if : 		 * remaining thread. : 
strstr : for : 		 * remaining thread. : 
strstr : while : 		 * remaining thread. : 
str : 		 */
strstr : INIT : 		 */ : 
strstr : if : 		 */ : 
strstr : for : 		 */ : 
strstr : while : 		 */ : 
str : 		if (rq->nr_running == 1)
strstr : INIT : 		if (rq->nr_running == 1) : 
strstr : if : 		if (rq->nr_running == 1) : 
strstr : for : 		if (rq->nr_running == 1) : 
strstr : while : 		if (rq->nr_running == 1) : 
str : 			break;
strstr : INIT : 			break; : 
strstr : if : 			break; : 
strstr : for : 			break; : 
strstr : while : 			break; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 		next = pick_next_task(rq);
strstr : if : 		next = pick_next_task(rq); : 
strstr : for : 		next = pick_next_task(rq); : 
strstr : while : 		next = pick_next_task(rq); : 
str : 		BUG_ON(!next);
strstr : INIT : 		BUG_ON(!next); : 
strstr : if : 		BUG_ON(!next); : 
strstr : for : 		BUG_ON(!next); : 
strstr : while : 		BUG_ON(!next); : 
str : 		next->sched_class->put_prev_task(rq, next);
strstr : INIT : 		next->sched_class->put_prev_task(rq, next); : 
strstr : if : 		next->sched_class->put_prev_task(rq, next); : 
strstr : for : 		next->sched_class->put_prev_task(rq, next); : 
strstr : while : 		next->sched_class->put_prev_task(rq, next); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 		/* Find suitable destination for @next, with force if needed. */
strstr : if : 		/* Find suitable destination for @next, with force if needed. */ : 
strstr : for : 		/* Find suitable destination for @next, with force if needed. */ : 
strstr : while : 		/* Find suitable destination for @next, with force if needed. */ : 
str : 		dest_cpu = select_fallback_rq(dead_cpu, next);
strstr : INIT : 		dest_cpu = select_fallback_rq(dead_cpu, next); : 
strstr : if : 		dest_cpu = select_fallback_rq(dead_cpu, next); : 
strstr : for : 		dest_cpu = select_fallback_rq(dead_cpu, next); : 
strstr : while : 		dest_cpu = select_fallback_rq(dead_cpu, next); : 
str : 		raw_spin_unlock(&rq->lock);
strstr : INIT : 		raw_spin_unlock(&rq->lock); : 
strstr : if : 		raw_spin_unlock(&rq->lock); : 
strstr : for : 		raw_spin_unlock(&rq->lock); : 
strstr : while : 		raw_spin_unlock(&rq->lock); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 		__migrate_task(next, dead_cpu, dest_cpu);
strstr : if : 		__migrate_task(next, dead_cpu, dest_cpu); : 
strstr : for : 		__migrate_task(next, dead_cpu, dest_cpu); : 
strstr : while : 		__migrate_task(next, dead_cpu, dest_cpu); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 		raw_spin_lock(&rq->lock);
strstr : if : 		raw_spin_lock(&rq->lock); : 
strstr : for : 		raw_spin_lock(&rq->lock); : 
strstr : while : 		raw_spin_lock(&rq->lock); : 
str : 	}
strstr : INIT : 	} : 
strstr : if : 	} : 
strstr : for : 	} : 
strstr : while : 	} : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	rq->stop = stop;
strstr : if : 	rq->stop = stop; : 
strstr : for : 	rq->stop = stop; : 
strstr : while : 	rq->stop = stop; : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : #endif /* CONFIG_HOTPLUG_CPU */
strstr : if : #endif /* CONFIG_HOTPLUG_CPU */ : 
strstr : for : #endif /* CONFIG_HOTPLUG_CPU */ : 
strstr : while : #endif /* CONFIG_HOTPLUG_CPU */ : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : #if defined(CONFIG_SCHED_DEBUG) && defined(CONFIG_SYSCTL)
strstr : if : #if defined(CONFIG_SCHED_DEBUG) && defined(CONFIG_SYSCTL) : 
strstr : for : #if defined(CONFIG_SCHED_DEBUG) && defined(CONFIG_SYSCTL) : 
strstr : while : #if defined(CONFIG_SCHED_DEBUG) && defined(CONFIG_SYSCTL) : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : static struct ctl_table sd_ctl_dir[] = {
strstr : if : static struct ctl_table sd_ctl_dir[] = { : 
strstr : for : static struct ctl_table sd_ctl_dir[] = { : 
strstr : while : static struct ctl_table sd_ctl_dir[] = { : 
str : 	{
strstr : INIT : 	{ : 
strstr : if : 	{ : 
strstr : for : 	{ : 
strstr : while : 	{ : 
str : 		.procname	= "sched_domain",
strstr : INIT : 		.procname	= "sched_domain", : 
strstr : if : 		.procname	= "sched_domain", : 
strstr : for : 		.procname	= "sched_domain", : 
strstr : while : 		.procname	= "sched_domain", : 
str : 		.mode		= 0555,
strstr : INIT : 		.mode		= 0555, : 
strstr : if : 		.mode		= 0555, : 
strstr : for : 		.mode		= 0555, : 
strstr : while : 		.mode		= 0555, : 
str : 	},
strstr : INIT : 	}, : 
strstr : if : 	}, : 
strstr : for : 	}, : 
strstr : while : 	}, : 
str : 	{}
strstr : INIT : 	{} : 
strstr : if : 	{} : 
strstr : for : 	{} : 
strstr : while : 	{} : 
str : };
strstr : INIT : }; : 
strstr : if : }; : 
strstr : for : }; : 
strstr : while : }; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : static struct ctl_table sd_ctl_root[] = {
strstr : if : static struct ctl_table sd_ctl_root[] = { : 
strstr : for : static struct ctl_table sd_ctl_root[] = { : 
strstr : while : static struct ctl_table sd_ctl_root[] = { : 
str : 	{
strstr : INIT : 	{ : 
strstr : if : 	{ : 
strstr : for : 	{ : 
strstr : while : 	{ : 
str : 		.procname	= "kernel",
strstr : INIT : 		.procname	= "kernel", : 
strstr : if : 		.procname	= "kernel", : 
strstr : for : 		.procname	= "kernel", : 
strstr : while : 		.procname	= "kernel", : 
str : 		.mode		= 0555,
strstr : INIT : 		.mode		= 0555, : 
strstr : if : 		.mode		= 0555, : 
strstr : for : 		.mode		= 0555, : 
strstr : while : 		.mode		= 0555, : 
str : 		.child		= sd_ctl_dir,
strstr : INIT : 		.child		= sd_ctl_dir, : 
strstr : if : 		.child		= sd_ctl_dir, : 
strstr : for : 		.child		= sd_ctl_dir, : 
strstr : while : 		.child		= sd_ctl_dir, : 
str : 	},
strstr : INIT : 	}, : 
strstr : if : 	}, : 
strstr : for : 	}, : 
strstr : while : 	}, : 
str : 	{}
strstr : INIT : 	{} : 
strstr : if : 	{} : 
strstr : for : 	{} : 
strstr : while : 	{} : 
str : };
strstr : INIT : }; : 
strstr : if : }; : 
strstr : for : }; : 
strstr : while : }; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : static struct ctl_table *sd_alloc_ctl_entry(int n)
strstr : if : static struct ctl_table *sd_alloc_ctl_entry(int n) : 
strstr : for : static struct ctl_table *sd_alloc_ctl_entry(int n) : 
strstr : while : static struct ctl_table *sd_alloc_ctl_entry(int n) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	struct ctl_table *entry =
strstr : INIT : 	struct ctl_table *entry = : 
strstr : if : 	struct ctl_table *entry = : 
strstr : for : 	struct ctl_table *entry = : 
strstr : while : 	struct ctl_table *entry = : 
str : 		kcalloc(n, sizeof(struct ctl_table), GFP_KERNEL);
strstr : INIT : 		kcalloc(n, sizeof(struct ctl_table), GFP_KERNEL); : 
strstr : if : 		kcalloc(n, sizeof(struct ctl_table), GFP_KERNEL); : 
strstr : for : 		kcalloc(n, sizeof(struct ctl_table), GFP_KERNEL); : 
strstr : while : 		kcalloc(n, sizeof(struct ctl_table), GFP_KERNEL); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	return entry;
strstr : if : 	return entry; : 
strstr : for : 	return entry; : 
strstr : while : 	return entry; : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : static void sd_free_ctl_entry(struct ctl_table **tablep)
strstr : if : static void sd_free_ctl_entry(struct ctl_table **tablep) : 
strstr : for : static void sd_free_ctl_entry(struct ctl_table **tablep) : 
strstr : while : static void sd_free_ctl_entry(struct ctl_table **tablep) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	struct ctl_table *entry;
strstr : INIT : 	struct ctl_table *entry; : 
strstr : if : 	struct ctl_table *entry; : 
strstr : for : 	struct ctl_table *entry; : 
strstr : while : 	struct ctl_table *entry; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	/*
strstr : if : 	/* : 
strstr : for : 	/* : 
strstr : while : 	/* : 
str : 	 * In the intermediate directories, both the child directory and
strstr : INIT : 	 * In the intermediate directories, both the child directory and : 
strstr : if : 	 * In the intermediate directories, both the child directory and : 
strstr : for : 	 * In the intermediate directories, both the child directory and : 
strstr : while : 	 * In the intermediate directories, both the child directory and : 
str : 	 * procname are dynamically allocated and could fail but the mode
strstr : INIT : 	 * procname are dynamically allocated and could fail but the mode : 
strstr : if : 	 * procname are dynamically allocated and could fail but the mode : 
strstr : for : 	 * procname are dynamically allocated and could fail but the mode : 
strstr : while : 	 * procname are dynamically allocated and could fail but the mode : 
str : 	 * will always be set. In the lowest directory the names are
strstr : INIT : 	 * will always be set. In the lowest directory the names are : 
strstr : if : 	 * will always be set. In the lowest directory the names are : 
strstr : for : 	 * will always be set. In the lowest directory the names are : 
strstr : while : 	 * will always be set. In the lowest directory the names are : 
str : 	 * static strings and all have proc handlers.
strstr : INIT : 	 * static strings and all have proc handlers. : 
strstr : if : 	 * static strings and all have proc handlers. : 
strstr : for : 	 * static strings and all have proc handlers. : 
strstr : while : 	 * static strings and all have proc handlers. : 
str : 	 */
strstr : INIT : 	 */ : 
strstr : if : 	 */ : 
strstr : for : 	 */ : 
strstr : while : 	 */ : 
str : 	for (entry = *tablep; entry->mode; entry++) {
strstr : INIT : 	for (entry = *tablep; entry->mode; entry++) { : 
strstr : if : 	for (entry = *tablep; entry->mode; entry++) { : 
strstr : for : 	for (entry = *tablep; entry->mode; entry++) { : 
strstr : while : 	for (entry = *tablep; entry->mode; entry++) { : 
str : 		if (entry->child)
strstr : INIT : 		if (entry->child) : 
strstr : if : 		if (entry->child) : 
strstr : for : 		if (entry->child) : 
strstr : while : 		if (entry->child) : 
str : 			sd_free_ctl_entry(&entry->child);
strstr : INIT : 			sd_free_ctl_entry(&entry->child); : 
strstr : if : 			sd_free_ctl_entry(&entry->child); : 
strstr : for : 			sd_free_ctl_entry(&entry->child); : 
strstr : while : 			sd_free_ctl_entry(&entry->child); : 
str : 		if (entry->proc_handler == NULL)
strstr : INIT : 		if (entry->proc_handler == NULL) : 
strstr : if : 		if (entry->proc_handler == NULL) : 
strstr : for : 		if (entry->proc_handler == NULL) : 
strstr : while : 		if (entry->proc_handler == NULL) : 
str : 			kfree(entry->procname);
strstr : INIT : 			kfree(entry->procname); : 
strstr : if : 			kfree(entry->procname); : 
strstr : for : 			kfree(entry->procname); : 
strstr : while : 			kfree(entry->procname); : 
str : 	}
strstr : INIT : 	} : 
strstr : if : 	} : 
strstr : for : 	} : 
strstr : while : 	} : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	kfree(*tablep);
strstr : if : 	kfree(*tablep); : 
strstr : for : 	kfree(*tablep); : 
strstr : while : 	kfree(*tablep); : 
str : 	*tablep = NULL;
strstr : INIT : 	*tablep = NULL; : 
strstr : if : 	*tablep = NULL; : 
strstr : for : 	*tablep = NULL; : 
strstr : while : 	*tablep = NULL; : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : static int min_load_idx = 0;
strstr : if : static int min_load_idx = 0; : 
strstr : for : static int min_load_idx = 0; : 
strstr : while : static int min_load_idx = 0; : 
str : static int max_load_idx = CPU_LOAD_IDX_MAX-1;
strstr : INIT : static int max_load_idx = CPU_LOAD_IDX_MAX-1; : 
strstr : if : static int max_load_idx = CPU_LOAD_IDX_MAX-1; : 
strstr : for : static int max_load_idx = CPU_LOAD_IDX_MAX-1; : 
strstr : while : static int max_load_idx = CPU_LOAD_IDX_MAX-1; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : static void
strstr : if : static void : 
strstr : for : static void : 
strstr : while : static void : 
str : set_table_entry(struct ctl_table *entry,
strstr : INIT : set_table_entry(struct ctl_table *entry, : 
strstr : if : set_table_entry(struct ctl_table *entry, : 
strstr : for : set_table_entry(struct ctl_table *entry, : 
strstr : while : set_table_entry(struct ctl_table *entry, : 
str : 		const char *procname, void *data, int maxlen,
strstr : INIT : 		const char *procname, void *data, int maxlen, : 
strstr : if : 		const char *procname, void *data, int maxlen, : 
strstr : for : 		const char *procname, void *data, int maxlen, : 
strstr : while : 		const char *procname, void *data, int maxlen, : 
str : 		umode_t mode, proc_handler *proc_handler,
strstr : INIT : 		umode_t mode, proc_handler *proc_handler, : 
strstr : if : 		umode_t mode, proc_handler *proc_handler, : 
strstr : for : 		umode_t mode, proc_handler *proc_handler, : 
strstr : while : 		umode_t mode, proc_handler *proc_handler, : 
str : 		bool load_idx)
strstr : INIT : 		bool load_idx) : 
strstr : if : 		bool load_idx) : 
strstr : for : 		bool load_idx) : 
strstr : while : 		bool load_idx) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	entry->procname = procname;
strstr : INIT : 	entry->procname = procname; : 
strstr : if : 	entry->procname = procname; : 
strstr : for : 	entry->procname = procname; : 
strstr : while : 	entry->procname = procname; : 
str : 	entry->data = data;
strstr : INIT : 	entry->data = data; : 
strstr : if : 	entry->data = data; : 
strstr : for : 	entry->data = data; : 
strstr : while : 	entry->data = data; : 
str : 	entry->maxlen = maxlen;
strstr : INIT : 	entry->maxlen = maxlen; : 
strstr : if : 	entry->maxlen = maxlen; : 
strstr : for : 	entry->maxlen = maxlen; : 
strstr : while : 	entry->maxlen = maxlen; : 
str : 	entry->mode = mode;
strstr : INIT : 	entry->mode = mode; : 
strstr : if : 	entry->mode = mode; : 
strstr : for : 	entry->mode = mode; : 
strstr : while : 	entry->mode = mode; : 
str : 	entry->proc_handler = proc_handler;
strstr : INIT : 	entry->proc_handler = proc_handler; : 
strstr : if : 	entry->proc_handler = proc_handler; : 
strstr : for : 	entry->proc_handler = proc_handler; : 
strstr : while : 	entry->proc_handler = proc_handler; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	if (load_idx) {
strstr : if : 	if (load_idx) { : 
strstr : for : 	if (load_idx) { : 
strstr : while : 	if (load_idx) { : 
str : 		entry->extra1 = &min_load_idx;
strstr : INIT : 		entry->extra1 = &min_load_idx; : 
strstr : if : 		entry->extra1 = &min_load_idx; : 
strstr : for : 		entry->extra1 = &min_load_idx; : 
strstr : while : 		entry->extra1 = &min_load_idx; : 
str : 		entry->extra2 = &max_load_idx;
strstr : INIT : 		entry->extra2 = &max_load_idx; : 
strstr : if : 		entry->extra2 = &max_load_idx; : 
strstr : for : 		entry->extra2 = &max_load_idx; : 
strstr : while : 		entry->extra2 = &max_load_idx; : 
str : 	}
strstr : INIT : 	} : 
strstr : if : 	} : 
strstr : for : 	} : 
strstr : while : 	} : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : static struct ctl_table *
strstr : if : static struct ctl_table * : 
strstr : for : static struct ctl_table * : 
strstr : while : static struct ctl_table * : 
str : sd_alloc_ctl_domain_table(struct sched_domain *sd)
strstr : INIT : sd_alloc_ctl_domain_table(struct sched_domain *sd) : 
strstr : if : sd_alloc_ctl_domain_table(struct sched_domain *sd) : 
strstr : for : sd_alloc_ctl_domain_table(struct sched_domain *sd) : 
strstr : while : sd_alloc_ctl_domain_table(struct sched_domain *sd) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	struct ctl_table *table = sd_alloc_ctl_entry(13);
strstr : INIT : 	struct ctl_table *table = sd_alloc_ctl_entry(13); : 
strstr : if : 	struct ctl_table *table = sd_alloc_ctl_entry(13); : 
strstr : for : 	struct ctl_table *table = sd_alloc_ctl_entry(13); : 
strstr : while : 	struct ctl_table *table = sd_alloc_ctl_entry(13); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	if (table == NULL)
strstr : if : 	if (table == NULL) : 
strstr : for : 	if (table == NULL) : 
strstr : while : 	if (table == NULL) : 
str : 		return NULL;
strstr : INIT : 		return NULL; : 
strstr : if : 		return NULL; : 
strstr : for : 		return NULL; : 
strstr : while : 		return NULL; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	set_table_entry(&table[0], "min_interval", &sd->min_interval,
strstr : if : 	set_table_entry(&table[0], "min_interval", &sd->min_interval, : 
strstr : for : 	set_table_entry(&table[0], "min_interval", &sd->min_interval, : 
strstr : while : 	set_table_entry(&table[0], "min_interval", &sd->min_interval, : 
str : 		sizeof(long), 0644, proc_doulongvec_minmax, false);
strstr : INIT : 		sizeof(long), 0644, proc_doulongvec_minmax, false); : 
strstr : if : 		sizeof(long), 0644, proc_doulongvec_minmax, false); : 
strstr : for : 		sizeof(long), 0644, proc_doulongvec_minmax, false); : 
strstr : while : 		sizeof(long), 0644, proc_doulongvec_minmax, false); : 
str : 	set_table_entry(&table[1], "max_interval", &sd->max_interval,
strstr : INIT : 	set_table_entry(&table[1], "max_interval", &sd->max_interval, : 
strstr : if : 	set_table_entry(&table[1], "max_interval", &sd->max_interval, : 
strstr : for : 	set_table_entry(&table[1], "max_interval", &sd->max_interval, : 
strstr : while : 	set_table_entry(&table[1], "max_interval", &sd->max_interval, : 
str : 		sizeof(long), 0644, proc_doulongvec_minmax, false);
strstr : INIT : 		sizeof(long), 0644, proc_doulongvec_minmax, false); : 
strstr : if : 		sizeof(long), 0644, proc_doulongvec_minmax, false); : 
strstr : for : 		sizeof(long), 0644, proc_doulongvec_minmax, false); : 
strstr : while : 		sizeof(long), 0644, proc_doulongvec_minmax, false); : 
str : 	set_table_entry(&table[2], "busy_idx", &sd->busy_idx,
strstr : INIT : 	set_table_entry(&table[2], "busy_idx", &sd->busy_idx, : 
strstr : if : 	set_table_entry(&table[2], "busy_idx", &sd->busy_idx, : 
strstr : for : 	set_table_entry(&table[2], "busy_idx", &sd->busy_idx, : 
strstr : while : 	set_table_entry(&table[2], "busy_idx", &sd->busy_idx, : 
str : 		sizeof(int), 0644, proc_dointvec_minmax, true);
strstr : INIT : 		sizeof(int), 0644, proc_dointvec_minmax, true); : 
strstr : if : 		sizeof(int), 0644, proc_dointvec_minmax, true); : 
strstr : for : 		sizeof(int), 0644, proc_dointvec_minmax, true); : 
strstr : while : 		sizeof(int), 0644, proc_dointvec_minmax, true); : 
str : 	set_table_entry(&table[3], "idle_idx", &sd->idle_idx,
strstr : INIT : 	set_table_entry(&table[3], "idle_idx", &sd->idle_idx, : 
strstr : if : 	set_table_entry(&table[3], "idle_idx", &sd->idle_idx, : 
strstr : for : 	set_table_entry(&table[3], "idle_idx", &sd->idle_idx, : 
strstr : while : 	set_table_entry(&table[3], "idle_idx", &sd->idle_idx, : 
str : 		sizeof(int), 0644, proc_dointvec_minmax, true);
strstr : INIT : 		sizeof(int), 0644, proc_dointvec_minmax, true); : 
strstr : if : 		sizeof(int), 0644, proc_dointvec_minmax, true); : 
strstr : for : 		sizeof(int), 0644, proc_dointvec_minmax, true); : 
strstr : while : 		sizeof(int), 0644, proc_dointvec_minmax, true); : 
str : 	set_table_entry(&table[4], "newidle_idx", &sd->newidle_idx,
strstr : INIT : 	set_table_entry(&table[4], "newidle_idx", &sd->newidle_idx, : 
strstr : if : 	set_table_entry(&table[4], "newidle_idx", &sd->newidle_idx, : 
strstr : for : 	set_table_entry(&table[4], "newidle_idx", &sd->newidle_idx, : 
strstr : while : 	set_table_entry(&table[4], "newidle_idx", &sd->newidle_idx, : 
str : 		sizeof(int), 0644, proc_dointvec_minmax, true);
strstr : INIT : 		sizeof(int), 0644, proc_dointvec_minmax, true); : 
strstr : if : 		sizeof(int), 0644, proc_dointvec_minmax, true); : 
strstr : for : 		sizeof(int), 0644, proc_dointvec_minmax, true); : 
strstr : while : 		sizeof(int), 0644, proc_dointvec_minmax, true); : 
str : 	set_table_entry(&table[5], "wake_idx", &sd->wake_idx,
strstr : INIT : 	set_table_entry(&table[5], "wake_idx", &sd->wake_idx, : 
strstr : if : 	set_table_entry(&table[5], "wake_idx", &sd->wake_idx, : 
strstr : for : 	set_table_entry(&table[5], "wake_idx", &sd->wake_idx, : 
strstr : while : 	set_table_entry(&table[5], "wake_idx", &sd->wake_idx, : 
str : 		sizeof(int), 0644, proc_dointvec_minmax, true);
strstr : INIT : 		sizeof(int), 0644, proc_dointvec_minmax, true); : 
strstr : if : 		sizeof(int), 0644, proc_dointvec_minmax, true); : 
strstr : for : 		sizeof(int), 0644, proc_dointvec_minmax, true); : 
strstr : while : 		sizeof(int), 0644, proc_dointvec_minmax, true); : 
str : 	set_table_entry(&table[6], "forkexec_idx", &sd->forkexec_idx,
strstr : INIT : 	set_table_entry(&table[6], "forkexec_idx", &sd->forkexec_idx, : 
strstr : if : 	set_table_entry(&table[6], "forkexec_idx", &sd->forkexec_idx, : 
strstr : for : 	set_table_entry(&table[6], "forkexec_idx", &sd->forkexec_idx, : 
strstr : while : 	set_table_entry(&table[6], "forkexec_idx", &sd->forkexec_idx, : 
str : 		sizeof(int), 0644, proc_dointvec_minmax, true);
strstr : INIT : 		sizeof(int), 0644, proc_dointvec_minmax, true); : 
strstr : if : 		sizeof(int), 0644, proc_dointvec_minmax, true); : 
strstr : for : 		sizeof(int), 0644, proc_dointvec_minmax, true); : 
strstr : while : 		sizeof(int), 0644, proc_dointvec_minmax, true); : 
str : 	set_table_entry(&table[7], "busy_factor", &sd->busy_factor,
strstr : INIT : 	set_table_entry(&table[7], "busy_factor", &sd->busy_factor, : 
strstr : if : 	set_table_entry(&table[7], "busy_factor", &sd->busy_factor, : 
strstr : for : 	set_table_entry(&table[7], "busy_factor", &sd->busy_factor, : 
strstr : while : 	set_table_entry(&table[7], "busy_factor", &sd->busy_factor, : 
str : 		sizeof(int), 0644, proc_dointvec_minmax, false);
strstr : INIT : 		sizeof(int), 0644, proc_dointvec_minmax, false); : 
strstr : if : 		sizeof(int), 0644, proc_dointvec_minmax, false); : 
strstr : for : 		sizeof(int), 0644, proc_dointvec_minmax, false); : 
strstr : while : 		sizeof(int), 0644, proc_dointvec_minmax, false); : 
str : 	set_table_entry(&table[8], "imbalance_pct", &sd->imbalance_pct,
strstr : INIT : 	set_table_entry(&table[8], "imbalance_pct", &sd->imbalance_pct, : 
strstr : if : 	set_table_entry(&table[8], "imbalance_pct", &sd->imbalance_pct, : 
strstr : for : 	set_table_entry(&table[8], "imbalance_pct", &sd->imbalance_pct, : 
strstr : while : 	set_table_entry(&table[8], "imbalance_pct", &sd->imbalance_pct, : 
str : 		sizeof(int), 0644, proc_dointvec_minmax, false);
strstr : INIT : 		sizeof(int), 0644, proc_dointvec_minmax, false); : 
strstr : if : 		sizeof(int), 0644, proc_dointvec_minmax, false); : 
strstr : for : 		sizeof(int), 0644, proc_dointvec_minmax, false); : 
strstr : while : 		sizeof(int), 0644, proc_dointvec_minmax, false); : 
str : 	set_table_entry(&table[9], "cache_nice_tries",
strstr : INIT : 	set_table_entry(&table[9], "cache_nice_tries", : 
strstr : if : 	set_table_entry(&table[9], "cache_nice_tries", : 
strstr : for : 	set_table_entry(&table[9], "cache_nice_tries", : 
strstr : while : 	set_table_entry(&table[9], "cache_nice_tries", : 
str : 		&sd->cache_nice_tries,
strstr : INIT : 		&sd->cache_nice_tries, : 
strstr : if : 		&sd->cache_nice_tries, : 
strstr : for : 		&sd->cache_nice_tries, : 
strstr : while : 		&sd->cache_nice_tries, : 
str : 		sizeof(int), 0644, proc_dointvec_minmax, false);
strstr : INIT : 		sizeof(int), 0644, proc_dointvec_minmax, false); : 
strstr : if : 		sizeof(int), 0644, proc_dointvec_minmax, false); : 
strstr : for : 		sizeof(int), 0644, proc_dointvec_minmax, false); : 
strstr : while : 		sizeof(int), 0644, proc_dointvec_minmax, false); : 
str : 	set_table_entry(&table[10], "flags", &sd->flags,
strstr : INIT : 	set_table_entry(&table[10], "flags", &sd->flags, : 
strstr : if : 	set_table_entry(&table[10], "flags", &sd->flags, : 
strstr : for : 	set_table_entry(&table[10], "flags", &sd->flags, : 
strstr : while : 	set_table_entry(&table[10], "flags", &sd->flags, : 
str : 		sizeof(int), 0644, proc_dointvec_minmax, false);
strstr : INIT : 		sizeof(int), 0644, proc_dointvec_minmax, false); : 
strstr : if : 		sizeof(int), 0644, proc_dointvec_minmax, false); : 
strstr : for : 		sizeof(int), 0644, proc_dointvec_minmax, false); : 
strstr : while : 		sizeof(int), 0644, proc_dointvec_minmax, false); : 
str : 	set_table_entry(&table[11], "name", sd->name,
strstr : INIT : 	set_table_entry(&table[11], "name", sd->name, : 
strstr : if : 	set_table_entry(&table[11], "name", sd->name, : 
strstr : for : 	set_table_entry(&table[11], "name", sd->name, : 
strstr : while : 	set_table_entry(&table[11], "name", sd->name, : 
str : 		CORENAME_MAX_SIZE, 0444, proc_dostring, false);
strstr : INIT : 		CORENAME_MAX_SIZE, 0444, proc_dostring, false); : 
strstr : if : 		CORENAME_MAX_SIZE, 0444, proc_dostring, false); : 
strstr : for : 		CORENAME_MAX_SIZE, 0444, proc_dostring, false); : 
strstr : while : 		CORENAME_MAX_SIZE, 0444, proc_dostring, false); : 
str : 	/* &table[12] is terminator */
strstr : INIT : 	/* &table[12] is terminator */ : 
strstr : if : 	/* &table[12] is terminator */ : 
strstr : for : 	/* &table[12] is terminator */ : 
strstr : while : 	/* &table[12] is terminator */ : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	return table;
strstr : if : 	return table; : 
strstr : for : 	return table; : 
strstr : while : 	return table; : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : static struct ctl_table *sd_alloc_ctl_cpu_table(int cpu)
strstr : if : static struct ctl_table *sd_alloc_ctl_cpu_table(int cpu) : 
strstr : for : static struct ctl_table *sd_alloc_ctl_cpu_table(int cpu) : 
strstr : while : static struct ctl_table *sd_alloc_ctl_cpu_table(int cpu) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	struct ctl_table *entry, *table;
strstr : INIT : 	struct ctl_table *entry, *table; : 
strstr : if : 	struct ctl_table *entry, *table; : 
strstr : for : 	struct ctl_table *entry, *table; : 
strstr : while : 	struct ctl_table *entry, *table; : 
str : 	struct sched_domain *sd;
strstr : INIT : 	struct sched_domain *sd; : 
strstr : if : 	struct sched_domain *sd; : 
strstr : for : 	struct sched_domain *sd; : 
strstr : while : 	struct sched_domain *sd; : 
str : 	int domain_num = 0, i;
strstr : INIT : 	int domain_num = 0, i; : 
strstr : if : 	int domain_num = 0, i; : 
strstr : for : 	int domain_num = 0, i; : 
strstr : while : 	int domain_num = 0, i; : 
str : 	char buf[32];
strstr : INIT : 	char buf[32]; : 
strstr : if : 	char buf[32]; : 
strstr : for : 	char buf[32]; : 
strstr : while : 	char buf[32]; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	for_each_domain(cpu, sd)
strstr : if : 	for_each_domain(cpu, sd) : 
strstr : for : 	for_each_domain(cpu, sd) : 
strstr : while : 	for_each_domain(cpu, sd) : 
str : 		domain_num++;
strstr : INIT : 		domain_num++; : 
strstr : if : 		domain_num++; : 
strstr : for : 		domain_num++; : 
strstr : while : 		domain_num++; : 
str : 	entry = table = sd_alloc_ctl_entry(domain_num + 1);
strstr : INIT : 	entry = table = sd_alloc_ctl_entry(domain_num + 1); : 
strstr : if : 	entry = table = sd_alloc_ctl_entry(domain_num + 1); : 
strstr : for : 	entry = table = sd_alloc_ctl_entry(domain_num + 1); : 
strstr : while : 	entry = table = sd_alloc_ctl_entry(domain_num + 1); : 
str : 	if (table == NULL)
strstr : INIT : 	if (table == NULL) : 
strstr : if : 	if (table == NULL) : 
strstr : for : 	if (table == NULL) : 
strstr : while : 	if (table == NULL) : 
str : 		return NULL;
strstr : INIT : 		return NULL; : 
strstr : if : 		return NULL; : 
strstr : for : 		return NULL; : 
strstr : while : 		return NULL; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	i = 0;
strstr : if : 	i = 0; : 
strstr : for : 	i = 0; : 
strstr : while : 	i = 0; : 
str : 	for_each_domain(cpu, sd) {
strstr : INIT : 	for_each_domain(cpu, sd) { : 
strstr : if : 	for_each_domain(cpu, sd) { : 
strstr : for : 	for_each_domain(cpu, sd) { : 
strstr : while : 	for_each_domain(cpu, sd) { : 
str : 		snprintf(buf, 32, "domain%d", i);
strstr : INIT : 		snprintf(buf, 32, "domain%d", i); : 
strstr : if : 		snprintf(buf, 32, "domain%d", i); : 
strstr : for : 		snprintf(buf, 32, "domain%d", i); : 
strstr : while : 		snprintf(buf, 32, "domain%d", i); : 
str : 		entry->procname = kstrdup(buf, GFP_KERNEL);
strstr : INIT : 		entry->procname = kstrdup(buf, GFP_KERNEL); : 
strstr : if : 		entry->procname = kstrdup(buf, GFP_KERNEL); : 
strstr : for : 		entry->procname = kstrdup(buf, GFP_KERNEL); : 
strstr : while : 		entry->procname = kstrdup(buf, GFP_KERNEL); : 
str : 		entry->mode = 0555;
strstr : INIT : 		entry->mode = 0555; : 
strstr : if : 		entry->mode = 0555; : 
strstr : for : 		entry->mode = 0555; : 
strstr : while : 		entry->mode = 0555; : 
str : 		entry->child = sd_alloc_ctl_domain_table(sd);
strstr : INIT : 		entry->child = sd_alloc_ctl_domain_table(sd); : 
strstr : if : 		entry->child = sd_alloc_ctl_domain_table(sd); : 
strstr : for : 		entry->child = sd_alloc_ctl_domain_table(sd); : 
strstr : while : 		entry->child = sd_alloc_ctl_domain_table(sd); : 
str : 		entry++;
strstr : INIT : 		entry++; : 
strstr : if : 		entry++; : 
strstr : for : 		entry++; : 
strstr : while : 		entry++; : 
str : 		i++;
strstr : INIT : 		i++; : 
strstr : if : 		i++; : 
strstr : for : 		i++; : 
strstr : while : 		i++; : 
str : 	}
strstr : INIT : 	} : 
strstr : if : 	} : 
strstr : for : 	} : 
strstr : while : 	} : 
str : 	return table;
strstr : INIT : 	return table; : 
strstr : if : 	return table; : 
strstr : for : 	return table; : 
strstr : while : 	return table; : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : static struct ctl_table_header *sd_sysctl_header;
strstr : if : static struct ctl_table_header *sd_sysctl_header; : 
strstr : for : static struct ctl_table_header *sd_sysctl_header; : 
strstr : while : static struct ctl_table_header *sd_sysctl_header; : 
str : static void register_sched_domain_sysctl(void)
strstr : INIT : static void register_sched_domain_sysctl(void) : 
strstr : if : static void register_sched_domain_sysctl(void) : 
strstr : for : static void register_sched_domain_sysctl(void) : 
strstr : while : static void register_sched_domain_sysctl(void) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	int i, cpu_num = num_possible_cpus();
strstr : INIT : 	int i, cpu_num = num_possible_cpus(); : 
strstr : if : 	int i, cpu_num = num_possible_cpus(); : 
strstr : for : 	int i, cpu_num = num_possible_cpus(); : 
strstr : while : 	int i, cpu_num = num_possible_cpus(); : 
str : 	struct ctl_table *entry = sd_alloc_ctl_entry(cpu_num + 1);
strstr : INIT : 	struct ctl_table *entry = sd_alloc_ctl_entry(cpu_num + 1); : 
strstr : if : 	struct ctl_table *entry = sd_alloc_ctl_entry(cpu_num + 1); : 
strstr : for : 	struct ctl_table *entry = sd_alloc_ctl_entry(cpu_num + 1); : 
strstr : while : 	struct ctl_table *entry = sd_alloc_ctl_entry(cpu_num + 1); : 
str : 	char buf[32];
strstr : INIT : 	char buf[32]; : 
strstr : if : 	char buf[32]; : 
strstr : for : 	char buf[32]; : 
strstr : while : 	char buf[32]; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	WARN_ON(sd_ctl_dir[0].child);
strstr : if : 	WARN_ON(sd_ctl_dir[0].child); : 
strstr : for : 	WARN_ON(sd_ctl_dir[0].child); : 
strstr : while : 	WARN_ON(sd_ctl_dir[0].child); : 
str : 	sd_ctl_dir[0].child = entry;
strstr : INIT : 	sd_ctl_dir[0].child = entry; : 
strstr : if : 	sd_ctl_dir[0].child = entry; : 
strstr : for : 	sd_ctl_dir[0].child = entry; : 
strstr : while : 	sd_ctl_dir[0].child = entry; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	if (entry == NULL)
strstr : if : 	if (entry == NULL) : 
strstr : for : 	if (entry == NULL) : 
strstr : while : 	if (entry == NULL) : 
str : 		return;
strstr : INIT : 		return; : 
strstr : if : 		return; : 
strstr : for : 		return; : 
strstr : while : 		return; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	for_each_possible_cpu(i) {
strstr : if : 	for_each_possible_cpu(i) { : 
strstr : for : 	for_each_possible_cpu(i) { : 
strstr : while : 	for_each_possible_cpu(i) { : 
str : 		snprintf(buf, 32, "cpu%d", i);
strstr : INIT : 		snprintf(buf, 32, "cpu%d", i); : 
strstr : if : 		snprintf(buf, 32, "cpu%d", i); : 
strstr : for : 		snprintf(buf, 32, "cpu%d", i); : 
strstr : while : 		snprintf(buf, 32, "cpu%d", i); : 
str : 		entry->procname = kstrdup(buf, GFP_KERNEL);
strstr : INIT : 		entry->procname = kstrdup(buf, GFP_KERNEL); : 
strstr : if : 		entry->procname = kstrdup(buf, GFP_KERNEL); : 
strstr : for : 		entry->procname = kstrdup(buf, GFP_KERNEL); : 
strstr : while : 		entry->procname = kstrdup(buf, GFP_KERNEL); : 
str : 		entry->mode = 0555;
strstr : INIT : 		entry->mode = 0555; : 
strstr : if : 		entry->mode = 0555; : 
strstr : for : 		entry->mode = 0555; : 
strstr : while : 		entry->mode = 0555; : 
str : 		entry->child = sd_alloc_ctl_cpu_table(i);
strstr : INIT : 		entry->child = sd_alloc_ctl_cpu_table(i); : 
strstr : if : 		entry->child = sd_alloc_ctl_cpu_table(i); : 
strstr : for : 		entry->child = sd_alloc_ctl_cpu_table(i); : 
strstr : while : 		entry->child = sd_alloc_ctl_cpu_table(i); : 
str : 		entry++;
strstr : INIT : 		entry++; : 
strstr : if : 		entry++; : 
strstr : for : 		entry++; : 
strstr : while : 		entry++; : 
str : 	}
strstr : INIT : 	} : 
strstr : if : 	} : 
strstr : for : 	} : 
strstr : while : 	} : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	WARN_ON(sd_sysctl_header);
strstr : if : 	WARN_ON(sd_sysctl_header); : 
strstr : for : 	WARN_ON(sd_sysctl_header); : 
strstr : while : 	WARN_ON(sd_sysctl_header); : 
str : 	sd_sysctl_header = register_sysctl_table(sd_ctl_root);
strstr : INIT : 	sd_sysctl_header = register_sysctl_table(sd_ctl_root); : 
strstr : if : 	sd_sysctl_header = register_sysctl_table(sd_ctl_root); : 
strstr : for : 	sd_sysctl_header = register_sysctl_table(sd_ctl_root); : 
strstr : while : 	sd_sysctl_header = register_sysctl_table(sd_ctl_root); : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : /* may be called multiple times per register */
strstr : if : /* may be called multiple times per register */ : 
strstr : for : /* may be called multiple times per register */ : 
strstr : while : /* may be called multiple times per register */ : 
str : static void unregister_sched_domain_sysctl(void)
strstr : INIT : static void unregister_sched_domain_sysctl(void) : 
strstr : if : static void unregister_sched_domain_sysctl(void) : 
strstr : for : static void unregister_sched_domain_sysctl(void) : 
strstr : while : static void unregister_sched_domain_sysctl(void) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	if (sd_sysctl_header)
strstr : INIT : 	if (sd_sysctl_header) : 
strstr : if : 	if (sd_sysctl_header) : 
strstr : for : 	if (sd_sysctl_header) : 
strstr : while : 	if (sd_sysctl_header) : 
str : 		unregister_sysctl_table(sd_sysctl_header);
strstr : INIT : 		unregister_sysctl_table(sd_sysctl_header); : 
strstr : if : 		unregister_sysctl_table(sd_sysctl_header); : 
strstr : for : 		unregister_sysctl_table(sd_sysctl_header); : 
strstr : while : 		unregister_sysctl_table(sd_sysctl_header); : 
str : 	sd_sysctl_header = NULL;
strstr : INIT : 	sd_sysctl_header = NULL; : 
strstr : if : 	sd_sysctl_header = NULL; : 
strstr : for : 	sd_sysctl_header = NULL; : 
strstr : while : 	sd_sysctl_header = NULL; : 
str : 	if (sd_ctl_dir[0].child)
strstr : INIT : 	if (sd_ctl_dir[0].child) : 
strstr : if : 	if (sd_ctl_dir[0].child) : 
strstr : for : 	if (sd_ctl_dir[0].child) : 
strstr : while : 	if (sd_ctl_dir[0].child) : 
str : 		sd_free_ctl_entry(&sd_ctl_dir[0].child);
strstr : INIT : 		sd_free_ctl_entry(&sd_ctl_dir[0].child); : 
strstr : if : 		sd_free_ctl_entry(&sd_ctl_dir[0].child); : 
strstr : for : 		sd_free_ctl_entry(&sd_ctl_dir[0].child); : 
strstr : while : 		sd_free_ctl_entry(&sd_ctl_dir[0].child); : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : #else
strstr : INIT : #else : 
strstr : if : #else : 
strstr : for : #else : 
strstr : while : #else : 
str : static void register_sched_domain_sysctl(void)
strstr : INIT : static void register_sched_domain_sysctl(void) : 
strstr : if : static void register_sched_domain_sysctl(void) : 
strstr : for : static void register_sched_domain_sysctl(void) : 
strstr : while : static void register_sched_domain_sysctl(void) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : static void unregister_sched_domain_sysctl(void)
strstr : INIT : static void unregister_sched_domain_sysctl(void) : 
strstr : if : static void unregister_sched_domain_sysctl(void) : 
strstr : for : static void unregister_sched_domain_sysctl(void) : 
strstr : while : static void unregister_sched_domain_sysctl(void) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : #endif
strstr : INIT : #endif : 
strstr : if : #endif : 
strstr : for : #endif : 
strstr : while : #endif : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : static void set_rq_online(struct rq *rq)
strstr : if : static void set_rq_online(struct rq *rq) : 
strstr : for : static void set_rq_online(struct rq *rq) : 
strstr : while : static void set_rq_online(struct rq *rq) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	if (!rq->online) {
strstr : INIT : 	if (!rq->online) { : 
strstr : if : 	if (!rq->online) { : 
strstr : for : 	if (!rq->online) { : 
strstr : while : 	if (!rq->online) { : 
str : 		const struct sched_class *class;
strstr : INIT : 		const struct sched_class *class; : 
strstr : if : 		const struct sched_class *class; : 
strstr : for : 		const struct sched_class *class; : 
strstr : while : 		const struct sched_class *class; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 		cpumask_set_cpu(rq->cpu, rq->rd->online);
strstr : if : 		cpumask_set_cpu(rq->cpu, rq->rd->online); : 
strstr : for : 		cpumask_set_cpu(rq->cpu, rq->rd->online); : 
strstr : while : 		cpumask_set_cpu(rq->cpu, rq->rd->online); : 
str : 		rq->online = 1;
strstr : INIT : 		rq->online = 1; : 
strstr : if : 		rq->online = 1; : 
strstr : for : 		rq->online = 1; : 
strstr : while : 		rq->online = 1; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 		for_each_class(class) {
strstr : if : 		for_each_class(class) { : 
strstr : for : 		for_each_class(class) { : 
strstr : while : 		for_each_class(class) { : 
str : 			if (class->rq_online)
strstr : INIT : 			if (class->rq_online) : 
strstr : if : 			if (class->rq_online) : 
strstr : for : 			if (class->rq_online) : 
strstr : while : 			if (class->rq_online) : 
str : 				class->rq_online(rq);
strstr : INIT : 				class->rq_online(rq); : 
strstr : if : 				class->rq_online(rq); : 
strstr : for : 				class->rq_online(rq); : 
strstr : while : 				class->rq_online(rq); : 
str : 		}
strstr : INIT : 		} : 
strstr : if : 		} : 
strstr : for : 		} : 
strstr : while : 		} : 
str : 	}
strstr : INIT : 	} : 
strstr : if : 	} : 
strstr : for : 	} : 
strstr : while : 	} : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : static void set_rq_offline(struct rq *rq)
strstr : if : static void set_rq_offline(struct rq *rq) : 
strstr : for : static void set_rq_offline(struct rq *rq) : 
strstr : while : static void set_rq_offline(struct rq *rq) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	if (rq->online) {
strstr : INIT : 	if (rq->online) { : 
strstr : if : 	if (rq->online) { : 
strstr : for : 	if (rq->online) { : 
strstr : while : 	if (rq->online) { : 
str : 		const struct sched_class *class;
strstr : INIT : 		const struct sched_class *class; : 
strstr : if : 		const struct sched_class *class; : 
strstr : for : 		const struct sched_class *class; : 
strstr : while : 		const struct sched_class *class; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 		for_each_class(class) {
strstr : if : 		for_each_class(class) { : 
strstr : for : 		for_each_class(class) { : 
strstr : while : 		for_each_class(class) { : 
str : 			if (class->rq_offline)
strstr : INIT : 			if (class->rq_offline) : 
strstr : if : 			if (class->rq_offline) : 
strstr : for : 			if (class->rq_offline) : 
strstr : while : 			if (class->rq_offline) : 
str : 				class->rq_offline(rq);
strstr : INIT : 				class->rq_offline(rq); : 
strstr : if : 				class->rq_offline(rq); : 
strstr : for : 				class->rq_offline(rq); : 
strstr : while : 				class->rq_offline(rq); : 
str : 		}
strstr : INIT : 		} : 
strstr : if : 		} : 
strstr : for : 		} : 
strstr : while : 		} : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 		cpumask_clear_cpu(rq->cpu, rq->rd->online);
strstr : if : 		cpumask_clear_cpu(rq->cpu, rq->rd->online); : 
strstr : for : 		cpumask_clear_cpu(rq->cpu, rq->rd->online); : 
strstr : while : 		cpumask_clear_cpu(rq->cpu, rq->rd->online); : 
str : 		rq->online = 0;
strstr : INIT : 		rq->online = 0; : 
strstr : if : 		rq->online = 0; : 
strstr : for : 		rq->online = 0; : 
strstr : while : 		rq->online = 0; : 
str : 	}
strstr : INIT : 	} : 
strstr : if : 	} : 
strstr : for : 	} : 
strstr : while : 	} : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : /*
strstr : if : /* : 
strstr : for : /* : 
strstr : while : /* : 
str :  * migration_call - callback that gets triggered when a CPU is added.
strstr : INIT :  * migration_call - callback that gets triggered when a CPU is added. : 
strstr : if :  * migration_call - callback that gets triggered when a CPU is added. : 
strstr : for :  * migration_call - callback that gets triggered when a CPU is added. : 
strstr : while :  * migration_call - callback that gets triggered when a CPU is added. : 
str :  * Here we can start up the necessary migration thread for the new CPU.
strstr : INIT :  * Here we can start up the necessary migration thread for the new CPU. : 
strstr : if :  * Here we can start up the necessary migration thread for the new CPU. : 
strstr : for :  * Here we can start up the necessary migration thread for the new CPU. : 
strstr : while :  * Here we can start up the necessary migration thread for the new CPU. : 
str :  */
strstr : INIT :  */ : 
strstr : if :  */ : 
strstr : for :  */ : 
strstr : while :  */ : 
str : static int
strstr : INIT : static int : 
strstr : if : static int : 
strstr : for : static int : 
strstr : while : static int : 
str : migration_call(struct notifier_block *nfb, unsigned long action, void *hcpu)
strstr : INIT : migration_call(struct notifier_block *nfb, unsigned long action, void *hcpu) : 
strstr : if : migration_call(struct notifier_block *nfb, unsigned long action, void *hcpu) : 
strstr : for : migration_call(struct notifier_block *nfb, unsigned long action, void *hcpu) : 
strstr : while : migration_call(struct notifier_block *nfb, unsigned long action, void *hcpu) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	int cpu = (long)hcpu;
strstr : INIT : 	int cpu = (long)hcpu; : 
strstr : if : 	int cpu = (long)hcpu; : 
strstr : for : 	int cpu = (long)hcpu; : 
strstr : while : 	int cpu = (long)hcpu; : 
str : 	unsigned long flags;
strstr : INIT : 	unsigned long flags; : 
strstr : if : 	unsigned long flags; : 
strstr : for : 	unsigned long flags; : 
strstr : while : 	unsigned long flags; : 
str : 	struct rq *rq = cpu_rq(cpu);
strstr : INIT : 	struct rq *rq = cpu_rq(cpu); : 
strstr : if : 	struct rq *rq = cpu_rq(cpu); : 
strstr : for : 	struct rq *rq = cpu_rq(cpu); : 
strstr : while : 	struct rq *rq = cpu_rq(cpu); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	switch (action & ~CPU_TASKS_FROZEN) {
strstr : if : 	switch (action & ~CPU_TASKS_FROZEN) { : 
strstr : for : 	switch (action & ~CPU_TASKS_FROZEN) { : 
strstr : while : 	switch (action & ~CPU_TASKS_FROZEN) { : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	case CPU_UP_PREPARE:
strstr : if : 	case CPU_UP_PREPARE: : 
strstr : for : 	case CPU_UP_PREPARE: : 
strstr : while : 	case CPU_UP_PREPARE: : 
str : 		rq->calc_load_update = calc_load_update;
strstr : INIT : 		rq->calc_load_update = calc_load_update; : 
strstr : if : 		rq->calc_load_update = calc_load_update; : 
strstr : for : 		rq->calc_load_update = calc_load_update; : 
strstr : while : 		rq->calc_load_update = calc_load_update; : 
str : 		break;
strstr : INIT : 		break; : 
strstr : if : 		break; : 
strstr : for : 		break; : 
strstr : while : 		break; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	case CPU_ONLINE:
strstr : if : 	case CPU_ONLINE: : 
strstr : for : 	case CPU_ONLINE: : 
strstr : while : 	case CPU_ONLINE: : 
str : 		/* Update our root-domain */
strstr : INIT : 		/* Update our root-domain */ : 
strstr : if : 		/* Update our root-domain */ : 
strstr : for : 		/* Update our root-domain */ : 
strstr : while : 		/* Update our root-domain */ : 
str : 		raw_spin_lock_irqsave(&rq->lock, flags);
strstr : INIT : 		raw_spin_lock_irqsave(&rq->lock, flags); : 
strstr : if : 		raw_spin_lock_irqsave(&rq->lock, flags); : 
strstr : for : 		raw_spin_lock_irqsave(&rq->lock, flags); : 
strstr : while : 		raw_spin_lock_irqsave(&rq->lock, flags); : 
str : 		if (rq->rd) {
strstr : INIT : 		if (rq->rd) { : 
strstr : if : 		if (rq->rd) { : 
strstr : for : 		if (rq->rd) { : 
strstr : while : 		if (rq->rd) { : 
str : 			BUG_ON(!cpumask_test_cpu(cpu, rq->rd->span));
strstr : INIT : 			BUG_ON(!cpumask_test_cpu(cpu, rq->rd->span)); : 
strstr : if : 			BUG_ON(!cpumask_test_cpu(cpu, rq->rd->span)); : 
strstr : for : 			BUG_ON(!cpumask_test_cpu(cpu, rq->rd->span)); : 
strstr : while : 			BUG_ON(!cpumask_test_cpu(cpu, rq->rd->span)); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 			set_rq_online(rq);
strstr : if : 			set_rq_online(rq); : 
strstr : for : 			set_rq_online(rq); : 
strstr : while : 			set_rq_online(rq); : 
str : 		}
strstr : INIT : 		} : 
strstr : if : 		} : 
strstr : for : 		} : 
strstr : while : 		} : 
str : 		raw_spin_unlock_irqrestore(&rq->lock, flags);
strstr : INIT : 		raw_spin_unlock_irqrestore(&rq->lock, flags); : 
strstr : if : 		raw_spin_unlock_irqrestore(&rq->lock, flags); : 
strstr : for : 		raw_spin_unlock_irqrestore(&rq->lock, flags); : 
strstr : while : 		raw_spin_unlock_irqrestore(&rq->lock, flags); : 
str : 		break;
strstr : INIT : 		break; : 
strstr : if : 		break; : 
strstr : for : 		break; : 
strstr : while : 		break; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : #ifdef CONFIG_HOTPLUG_CPU
strstr : if : #ifdef CONFIG_HOTPLUG_CPU : 
strstr : for : #ifdef CONFIG_HOTPLUG_CPU : 
strstr : while : #ifdef CONFIG_HOTPLUG_CPU : 
str : 	case CPU_DYING:
strstr : INIT : 	case CPU_DYING: : 
strstr : if : 	case CPU_DYING: : 
strstr : for : 	case CPU_DYING: : 
strstr : while : 	case CPU_DYING: : 
str : 		sched_ttwu_pending();
strstr : INIT : 		sched_ttwu_pending(); : 
strstr : if : 		sched_ttwu_pending(); : 
strstr : for : 		sched_ttwu_pending(); : 
strstr : while : 		sched_ttwu_pending(); : 
str : 		/* Update our root-domain */
strstr : INIT : 		/* Update our root-domain */ : 
strstr : if : 		/* Update our root-domain */ : 
strstr : for : 		/* Update our root-domain */ : 
strstr : while : 		/* Update our root-domain */ : 
str : 		raw_spin_lock_irqsave(&rq->lock, flags);
strstr : INIT : 		raw_spin_lock_irqsave(&rq->lock, flags); : 
strstr : if : 		raw_spin_lock_irqsave(&rq->lock, flags); : 
strstr : for : 		raw_spin_lock_irqsave(&rq->lock, flags); : 
strstr : while : 		raw_spin_lock_irqsave(&rq->lock, flags); : 
str : 		if (rq->rd) {
strstr : INIT : 		if (rq->rd) { : 
strstr : if : 		if (rq->rd) { : 
strstr : for : 		if (rq->rd) { : 
strstr : while : 		if (rq->rd) { : 
str : 			BUG_ON(!cpumask_test_cpu(cpu, rq->rd->span));
strstr : INIT : 			BUG_ON(!cpumask_test_cpu(cpu, rq->rd->span)); : 
strstr : if : 			BUG_ON(!cpumask_test_cpu(cpu, rq->rd->span)); : 
strstr : for : 			BUG_ON(!cpumask_test_cpu(cpu, rq->rd->span)); : 
strstr : while : 			BUG_ON(!cpumask_test_cpu(cpu, rq->rd->span)); : 
str : 			set_rq_offline(rq);
strstr : INIT : 			set_rq_offline(rq); : 
strstr : if : 			set_rq_offline(rq); : 
strstr : for : 			set_rq_offline(rq); : 
strstr : while : 			set_rq_offline(rq); : 
str : 		}
strstr : INIT : 		} : 
strstr : if : 		} : 
strstr : for : 		} : 
strstr : while : 		} : 
str : 		migrate_tasks(cpu);
strstr : INIT : 		migrate_tasks(cpu); : 
strstr : if : 		migrate_tasks(cpu); : 
strstr : for : 		migrate_tasks(cpu); : 
strstr : while : 		migrate_tasks(cpu); : 
str : 		BUG_ON(rq->nr_running != 1); /* the migration thread */
strstr : INIT : 		BUG_ON(rq->nr_running != 1); /* the migration thread */ : 
strstr : if : 		BUG_ON(rq->nr_running != 1); /* the migration thread */ : 
strstr : for : 		BUG_ON(rq->nr_running != 1); /* the migration thread */ : 
strstr : while : 		BUG_ON(rq->nr_running != 1); /* the migration thread */ : 
str : 		raw_spin_unlock_irqrestore(&rq->lock, flags);
strstr : INIT : 		raw_spin_unlock_irqrestore(&rq->lock, flags); : 
strstr : if : 		raw_spin_unlock_irqrestore(&rq->lock, flags); : 
strstr : for : 		raw_spin_unlock_irqrestore(&rq->lock, flags); : 
strstr : while : 		raw_spin_unlock_irqrestore(&rq->lock, flags); : 
str : 		break;
strstr : INIT : 		break; : 
strstr : if : 		break; : 
strstr : for : 		break; : 
strstr : while : 		break; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	case CPU_DEAD:
strstr : if : 	case CPU_DEAD: : 
strstr : for : 	case CPU_DEAD: : 
strstr : while : 	case CPU_DEAD: : 
str : 		calc_load_migrate(rq);
strstr : INIT : 		calc_load_migrate(rq); : 
strstr : if : 		calc_load_migrate(rq); : 
strstr : for : 		calc_load_migrate(rq); : 
strstr : while : 		calc_load_migrate(rq); : 
str : 		break;
strstr : INIT : 		break; : 
strstr : if : 		break; : 
strstr : for : 		break; : 
strstr : while : 		break; : 
str : #endif
strstr : INIT : #endif : 
strstr : if : #endif : 
strstr : for : #endif : 
strstr : while : #endif : 
str : 	}
strstr : INIT : 	} : 
strstr : if : 	} : 
strstr : for : 	} : 
strstr : while : 	} : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	update_max_interval();
strstr : if : 	update_max_interval(); : 
strstr : for : 	update_max_interval(); : 
strstr : while : 	update_max_interval(); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	return NOTIFY_OK;
strstr : if : 	return NOTIFY_OK; : 
strstr : for : 	return NOTIFY_OK; : 
strstr : while : 	return NOTIFY_OK; : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : /*
strstr : if : /* : 
strstr : for : /* : 
strstr : while : /* : 
str :  * Register at high priority so that task migration (migrate_all_tasks)
strstr : INIT :  * Register at high priority so that task migration (migrate_all_tasks) : 
strstr : if :  * Register at high priority so that task migration (migrate_all_tasks) : 
strstr : for :  * Register at high priority so that task migration (migrate_all_tasks) : 
strstr : while :  * Register at high priority so that task migration (migrate_all_tasks) : 
str :  * happens before everything else.  This has to be lower priority than
strstr : INIT :  * happens before everything else.  This has to be lower priority than : 
strstr : if :  * happens before everything else.  This has to be lower priority than : 
strstr : for :  * happens before everything else.  This has to be lower priority than : 
strstr : while :  * happens before everything else.  This has to be lower priority than : 
str :  * the notifier in the perf_event subsystem, though.
strstr : INIT :  * the notifier in the perf_event subsystem, though. : 
strstr : if :  * the notifier in the perf_event subsystem, though. : 
strstr : for :  * the notifier in the perf_event subsystem, though. : 
strstr : while :  * the notifier in the perf_event subsystem, though. : 
str :  */
strstr : INIT :  */ : 
strstr : if :  */ : 
strstr : for :  */ : 
strstr : while :  */ : 
str : static struct notifier_block migration_notifier = {
strstr : INIT : static struct notifier_block migration_notifier = { : 
strstr : if : static struct notifier_block migration_notifier = { : 
strstr : for : static struct notifier_block migration_notifier = { : 
strstr : while : static struct notifier_block migration_notifier = { : 
str : 	.notifier_call = migration_call,
strstr : INIT : 	.notifier_call = migration_call, : 
strstr : if : 	.notifier_call = migration_call, : 
strstr : for : 	.notifier_call = migration_call, : 
strstr : while : 	.notifier_call = migration_call, : 
str : 	.priority = CPU_PRI_MIGRATION,
strstr : INIT : 	.priority = CPU_PRI_MIGRATION, : 
strstr : if : 	.priority = CPU_PRI_MIGRATION, : 
strstr : for : 	.priority = CPU_PRI_MIGRATION, : 
strstr : while : 	.priority = CPU_PRI_MIGRATION, : 
str : };
strstr : INIT : }; : 
strstr : if : }; : 
strstr : for : }; : 
strstr : while : }; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : static int sched_cpu_active(struct notifier_block *nfb,
strstr : if : static int sched_cpu_active(struct notifier_block *nfb, : 
strstr : for : static int sched_cpu_active(struct notifier_block *nfb, : 
strstr : while : static int sched_cpu_active(struct notifier_block *nfb, : 
str : 				      unsigned long action, void *hcpu)
strstr : INIT : 				      unsigned long action, void *hcpu) : 
strstr : if : 				      unsigned long action, void *hcpu) : 
strstr : for : 				      unsigned long action, void *hcpu) : 
strstr : while : 				      unsigned long action, void *hcpu) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	switch (action & ~CPU_TASKS_FROZEN) {
strstr : INIT : 	switch (action & ~CPU_TASKS_FROZEN) { : 
strstr : if : 	switch (action & ~CPU_TASKS_FROZEN) { : 
strstr : for : 	switch (action & ~CPU_TASKS_FROZEN) { : 
strstr : while : 	switch (action & ~CPU_TASKS_FROZEN) { : 
str : 	case CPU_DOWN_FAILED:
strstr : INIT : 	case CPU_DOWN_FAILED: : 
strstr : if : 	case CPU_DOWN_FAILED: : 
strstr : for : 	case CPU_DOWN_FAILED: : 
strstr : while : 	case CPU_DOWN_FAILED: : 
str : 		set_cpu_active((long)hcpu, true);
strstr : INIT : 		set_cpu_active((long)hcpu, true); : 
strstr : if : 		set_cpu_active((long)hcpu, true); : 
strstr : for : 		set_cpu_active((long)hcpu, true); : 
strstr : while : 		set_cpu_active((long)hcpu, true); : 
str : 		return NOTIFY_OK;
strstr : INIT : 		return NOTIFY_OK; : 
strstr : if : 		return NOTIFY_OK; : 
strstr : for : 		return NOTIFY_OK; : 
strstr : while : 		return NOTIFY_OK; : 
str : 	default:
strstr : INIT : 	default: : 
strstr : if : 	default: : 
strstr : for : 	default: : 
strstr : while : 	default: : 
str : 		return NOTIFY_DONE;
strstr : INIT : 		return NOTIFY_DONE; : 
strstr : if : 		return NOTIFY_DONE; : 
strstr : for : 		return NOTIFY_DONE; : 
strstr : while : 		return NOTIFY_DONE; : 
str : 	}
strstr : INIT : 	} : 
strstr : if : 	} : 
strstr : for : 	} : 
strstr : while : 	} : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : static int sched_cpu_inactive(struct notifier_block *nfb,
strstr : if : static int sched_cpu_inactive(struct notifier_block *nfb, : 
strstr : for : static int sched_cpu_inactive(struct notifier_block *nfb, : 
strstr : while : static int sched_cpu_inactive(struct notifier_block *nfb, : 
str : 					unsigned long action, void *hcpu)
strstr : INIT : 					unsigned long action, void *hcpu) : 
strstr : if : 					unsigned long action, void *hcpu) : 
strstr : for : 					unsigned long action, void *hcpu) : 
strstr : while : 					unsigned long action, void *hcpu) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	unsigned long flags;
strstr : INIT : 	unsigned long flags; : 
strstr : if : 	unsigned long flags; : 
strstr : for : 	unsigned long flags; : 
strstr : while : 	unsigned long flags; : 
str : 	long cpu = (long)hcpu;
strstr : INIT : 	long cpu = (long)hcpu; : 
strstr : if : 	long cpu = (long)hcpu; : 
strstr : for : 	long cpu = (long)hcpu; : 
strstr : while : 	long cpu = (long)hcpu; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	switch (action & ~CPU_TASKS_FROZEN) {
strstr : if : 	switch (action & ~CPU_TASKS_FROZEN) { : 
strstr : for : 	switch (action & ~CPU_TASKS_FROZEN) { : 
strstr : while : 	switch (action & ~CPU_TASKS_FROZEN) { : 
str : 	case CPU_DOWN_PREPARE:
strstr : INIT : 	case CPU_DOWN_PREPARE: : 
strstr : if : 	case CPU_DOWN_PREPARE: : 
strstr : for : 	case CPU_DOWN_PREPARE: : 
strstr : while : 	case CPU_DOWN_PREPARE: : 
str : 		set_cpu_active(cpu, false);
strstr : INIT : 		set_cpu_active(cpu, false); : 
strstr : if : 		set_cpu_active(cpu, false); : 
strstr : for : 		set_cpu_active(cpu, false); : 
strstr : while : 		set_cpu_active(cpu, false); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 		/* explicitly allow suspend */
strstr : if : 		/* explicitly allow suspend */ : 
strstr : for : 		/* explicitly allow suspend */ : 
strstr : while : 		/* explicitly allow suspend */ : 
str : 		if (!(action & CPU_TASKS_FROZEN)) {
strstr : INIT : 		if (!(action & CPU_TASKS_FROZEN)) { : 
strstr : if : 		if (!(action & CPU_TASKS_FROZEN)) { : 
strstr : for : 		if (!(action & CPU_TASKS_FROZEN)) { : 
strstr : while : 		if (!(action & CPU_TASKS_FROZEN)) { : 
str : 			struct dl_bw *dl_b = dl_bw_of(cpu);
strstr : INIT : 			struct dl_bw *dl_b = dl_bw_of(cpu); : 
strstr : if : 			struct dl_bw *dl_b = dl_bw_of(cpu); : 
strstr : for : 			struct dl_bw *dl_b = dl_bw_of(cpu); : 
strstr : while : 			struct dl_bw *dl_b = dl_bw_of(cpu); : 
str : 			bool overflow;
strstr : INIT : 			bool overflow; : 
strstr : if : 			bool overflow; : 
strstr : for : 			bool overflow; : 
strstr : while : 			bool overflow; : 
str : 			int cpus;
strstr : INIT : 			int cpus; : 
strstr : if : 			int cpus; : 
strstr : for : 			int cpus; : 
strstr : while : 			int cpus; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 			raw_spin_lock_irqsave(&dl_b->lock, flags);
strstr : if : 			raw_spin_lock_irqsave(&dl_b->lock, flags); : 
strstr : for : 			raw_spin_lock_irqsave(&dl_b->lock, flags); : 
strstr : while : 			raw_spin_lock_irqsave(&dl_b->lock, flags); : 
str : 			cpus = dl_bw_cpus(cpu);
strstr : INIT : 			cpus = dl_bw_cpus(cpu); : 
strstr : if : 			cpus = dl_bw_cpus(cpu); : 
strstr : for : 			cpus = dl_bw_cpus(cpu); : 
strstr : while : 			cpus = dl_bw_cpus(cpu); : 
str : 			overflow = __dl_overflow(dl_b, cpus, 0, 0);
strstr : INIT : 			overflow = __dl_overflow(dl_b, cpus, 0, 0); : 
strstr : if : 			overflow = __dl_overflow(dl_b, cpus, 0, 0); : 
strstr : for : 			overflow = __dl_overflow(dl_b, cpus, 0, 0); : 
strstr : while : 			overflow = __dl_overflow(dl_b, cpus, 0, 0); : 
str : 			raw_spin_unlock_irqrestore(&dl_b->lock, flags);
strstr : INIT : 			raw_spin_unlock_irqrestore(&dl_b->lock, flags); : 
strstr : if : 			raw_spin_unlock_irqrestore(&dl_b->lock, flags); : 
strstr : for : 			raw_spin_unlock_irqrestore(&dl_b->lock, flags); : 
strstr : while : 			raw_spin_unlock_irqrestore(&dl_b->lock, flags); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 			if (overflow)
strstr : if : 			if (overflow) : 
strstr : for : 			if (overflow) : 
strstr : while : 			if (overflow) : 
str : 				return notifier_from_errno(-EBUSY);
strstr : INIT : 				return notifier_from_errno(-EBUSY); : 
strstr : if : 				return notifier_from_errno(-EBUSY); : 
strstr : for : 				return notifier_from_errno(-EBUSY); : 
strstr : while : 				return notifier_from_errno(-EBUSY); : 
str : 		}
strstr : INIT : 		} : 
strstr : if : 		} : 
strstr : for : 		} : 
strstr : while : 		} : 
str : 		return NOTIFY_OK;
strstr : INIT : 		return NOTIFY_OK; : 
strstr : if : 		return NOTIFY_OK; : 
strstr : for : 		return NOTIFY_OK; : 
strstr : while : 		return NOTIFY_OK; : 
str : 	}
strstr : INIT : 	} : 
strstr : if : 	} : 
strstr : for : 	} : 
strstr : while : 	} : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	return NOTIFY_DONE;
strstr : if : 	return NOTIFY_DONE; : 
strstr : for : 	return NOTIFY_DONE; : 
strstr : while : 	return NOTIFY_DONE; : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : static int __init migration_init(void)
strstr : if : static int __init migration_init(void) : 
strstr : for : static int __init migration_init(void) : 
strstr : while : static int __init migration_init(void) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	void *cpu = (void *)(long)smp_processor_id();
strstr : INIT : 	void *cpu = (void *)(long)smp_processor_id(); : 
strstr : if : 	void *cpu = (void *)(long)smp_processor_id(); : 
strstr : for : 	void *cpu = (void *)(long)smp_processor_id(); : 
strstr : while : 	void *cpu = (void *)(long)smp_processor_id(); : 
str : 	int err;
strstr : INIT : 	int err; : 
strstr : if : 	int err; : 
strstr : for : 	int err; : 
strstr : while : 	int err; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	/* Initialize migration for the boot CPU */
strstr : if : 	/* Initialize migration for the boot CPU */ : 
strstr : for : 	/* Initialize migration for the boot CPU */ : 
strstr : while : 	/* Initialize migration for the boot CPU */ : 
str : 	err = migration_call(&migration_notifier, CPU_UP_PREPARE, cpu);
strstr : INIT : 	err = migration_call(&migration_notifier, CPU_UP_PREPARE, cpu); : 
strstr : if : 	err = migration_call(&migration_notifier, CPU_UP_PREPARE, cpu); : 
strstr : for : 	err = migration_call(&migration_notifier, CPU_UP_PREPARE, cpu); : 
strstr : while : 	err = migration_call(&migration_notifier, CPU_UP_PREPARE, cpu); : 
str : 	BUG_ON(err == NOTIFY_BAD);
strstr : INIT : 	BUG_ON(err == NOTIFY_BAD); : 
strstr : if : 	BUG_ON(err == NOTIFY_BAD); : 
strstr : for : 	BUG_ON(err == NOTIFY_BAD); : 
strstr : while : 	BUG_ON(err == NOTIFY_BAD); : 
str : 	migration_call(&migration_notifier, CPU_ONLINE, cpu);
strstr : INIT : 	migration_call(&migration_notifier, CPU_ONLINE, cpu); : 
strstr : if : 	migration_call(&migration_notifier, CPU_ONLINE, cpu); : 
strstr : for : 	migration_call(&migration_notifier, CPU_ONLINE, cpu); : 
strstr : while : 	migration_call(&migration_notifier, CPU_ONLINE, cpu); : 
str : 	register_cpu_notifier(&migration_notifier);
strstr : INIT : 	register_cpu_notifier(&migration_notifier); : 
strstr : if : 	register_cpu_notifier(&migration_notifier); : 
strstr : for : 	register_cpu_notifier(&migration_notifier); : 
strstr : while : 	register_cpu_notifier(&migration_notifier); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	/* Register cpu active notifiers */
strstr : if : 	/* Register cpu active notifiers */ : 
strstr : for : 	/* Register cpu active notifiers */ : 
strstr : while : 	/* Register cpu active notifiers */ : 
str : 	cpu_notifier(sched_cpu_active, CPU_PRI_SCHED_ACTIVE);
strstr : INIT : 	cpu_notifier(sched_cpu_active, CPU_PRI_SCHED_ACTIVE); : 
strstr : if : 	cpu_notifier(sched_cpu_active, CPU_PRI_SCHED_ACTIVE); : 
strstr : for : 	cpu_notifier(sched_cpu_active, CPU_PRI_SCHED_ACTIVE); : 
strstr : while : 	cpu_notifier(sched_cpu_active, CPU_PRI_SCHED_ACTIVE); : 
str : 	cpu_notifier(sched_cpu_inactive, CPU_PRI_SCHED_INACTIVE);
strstr : INIT : 	cpu_notifier(sched_cpu_inactive, CPU_PRI_SCHED_INACTIVE); : 
strstr : if : 	cpu_notifier(sched_cpu_inactive, CPU_PRI_SCHED_INACTIVE); : 
strstr : for : 	cpu_notifier(sched_cpu_inactive, CPU_PRI_SCHED_INACTIVE); : 
strstr : while : 	cpu_notifier(sched_cpu_inactive, CPU_PRI_SCHED_INACTIVE); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	return 0;
strstr : if : 	return 0; : 
strstr : for : 	return 0; : 
strstr : while : 	return 0; : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : early_initcall(migration_init);
strstr : INIT : early_initcall(migration_init); : 
strstr : if : early_initcall(migration_init); : 
strstr : for : early_initcall(migration_init); : 
strstr : while : early_initcall(migration_init); : 
str : #endif
strstr : INIT : #endif : 
strstr : if : #endif : 
strstr : for : #endif : 
strstr : while : #endif : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : #ifdef CONFIG_SMP
strstr : if : #ifdef CONFIG_SMP : 
strstr : for : #ifdef CONFIG_SMP : 
strstr : while : #ifdef CONFIG_SMP : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : static cpumask_var_t sched_domains_tmpmask; /* sched_domains_mutex */
strstr : if : static cpumask_var_t sched_domains_tmpmask; /* sched_domains_mutex */ : 
strstr : for : static cpumask_var_t sched_domains_tmpmask; /* sched_domains_mutex */ : 
strstr : while : static cpumask_var_t sched_domains_tmpmask; /* sched_domains_mutex */ : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : #ifdef CONFIG_SCHED_DEBUG
strstr : if : #ifdef CONFIG_SCHED_DEBUG : 
strstr : for : #ifdef CONFIG_SCHED_DEBUG : 
strstr : while : #ifdef CONFIG_SCHED_DEBUG : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : static __read_mostly int sched_debug_enabled;
strstr : if : static __read_mostly int sched_debug_enabled; : 
strstr : for : static __read_mostly int sched_debug_enabled; : 
strstr : while : static __read_mostly int sched_debug_enabled; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : static int __init sched_debug_setup(char *str)
strstr : if : static int __init sched_debug_setup(char *str) : 
strstr : for : static int __init sched_debug_setup(char *str) : 
strstr : while : static int __init sched_debug_setup(char *str) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	sched_debug_enabled = 1;
strstr : INIT : 	sched_debug_enabled = 1; : 
strstr : if : 	sched_debug_enabled = 1; : 
strstr : for : 	sched_debug_enabled = 1; : 
strstr : while : 	sched_debug_enabled = 1; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	return 0;
strstr : if : 	return 0; : 
strstr : for : 	return 0; : 
strstr : while : 	return 0; : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : early_param("sched_debug", sched_debug_setup);
strstr : INIT : early_param("sched_debug", sched_debug_setup); : 
strstr : if : early_param("sched_debug", sched_debug_setup); : 
strstr : for : early_param("sched_debug", sched_debug_setup); : 
strstr : while : early_param("sched_debug", sched_debug_setup); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : static inline bool sched_debug(void)
strstr : if : static inline bool sched_debug(void) : 
strstr : for : static inline bool sched_debug(void) : 
strstr : while : static inline bool sched_debug(void) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	return sched_debug_enabled;
strstr : INIT : 	return sched_debug_enabled; : 
strstr : if : 	return sched_debug_enabled; : 
strstr : for : 	return sched_debug_enabled; : 
strstr : while : 	return sched_debug_enabled; : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : static int sched_domain_debug_one(struct sched_domain *sd, int cpu, int level,
strstr : if : static int sched_domain_debug_one(struct sched_domain *sd, int cpu, int level, : 
strstr : for : static int sched_domain_debug_one(struct sched_domain *sd, int cpu, int level, : 
strstr : while : static int sched_domain_debug_one(struct sched_domain *sd, int cpu, int level, : 
str : 				  struct cpumask *groupmask)
strstr : INIT : 				  struct cpumask *groupmask) : 
strstr : if : 				  struct cpumask *groupmask) : 
strstr : for : 				  struct cpumask *groupmask) : 
strstr : while : 				  struct cpumask *groupmask) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	struct sched_group *group = sd->groups;
strstr : INIT : 	struct sched_group *group = sd->groups; : 
strstr : if : 	struct sched_group *group = sd->groups; : 
strstr : for : 	struct sched_group *group = sd->groups; : 
strstr : while : 	struct sched_group *group = sd->groups; : 
str : 	char str[256];
strstr : INIT : 	char str[256]; : 
strstr : if : 	char str[256]; : 
strstr : for : 	char str[256]; : 
strstr : while : 	char str[256]; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	cpulist_scnprintf(str, sizeof(str), sched_domain_span(sd));
strstr : if : 	cpulist_scnprintf(str, sizeof(str), sched_domain_span(sd)); : 
strstr : for : 	cpulist_scnprintf(str, sizeof(str), sched_domain_span(sd)); : 
strstr : while : 	cpulist_scnprintf(str, sizeof(str), sched_domain_span(sd)); : 
str : 	cpumask_clear(groupmask);
strstr : INIT : 	cpumask_clear(groupmask); : 
strstr : if : 	cpumask_clear(groupmask); : 
strstr : for : 	cpumask_clear(groupmask); : 
strstr : while : 	cpumask_clear(groupmask); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	printk(KERN_DEBUG "%*s domain %d: ", level, "", level);
strstr : if : 	printk(KERN_DEBUG "%*s domain %d: ", level, "", level); : 
strstr : for : 	printk(KERN_DEBUG "%*s domain %d: ", level, "", level); : 
strstr : while : 	printk(KERN_DEBUG "%*s domain %d: ", level, "", level); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	if (!(sd->flags & SD_LOAD_BALANCE)) {
strstr : if : 	if (!(sd->flags & SD_LOAD_BALANCE)) { : 
strstr : for : 	if (!(sd->flags & SD_LOAD_BALANCE)) { : 
strstr : while : 	if (!(sd->flags & SD_LOAD_BALANCE)) { : 
str : 		printk("does not load-balance\n");
strstr : INIT : 		printk("does not load-balance\n"); : 
strstr : if : 		printk("does not load-balance\n"); : 
strstr : for : 		printk("does not load-balance\n"); : 
strstr : while : 		printk("does not load-balance\n"); : 
str : 		if (sd->parent)
strstr : INIT : 		if (sd->parent) : 
strstr : if : 		if (sd->parent) : 
strstr : for : 		if (sd->parent) : 
strstr : while : 		if (sd->parent) : 
str : 			printk(KERN_ERR "ERROR: !SD_LOAD_BALANCE domain"
strstr : INIT : 			printk(KERN_ERR "ERROR: !SD_LOAD_BALANCE domain" : 
strstr : if : 			printk(KERN_ERR "ERROR: !SD_LOAD_BALANCE domain" : 
strstr : for : 			printk(KERN_ERR "ERROR: !SD_LOAD_BALANCE domain" : 
strstr : while : 			printk(KERN_ERR "ERROR: !SD_LOAD_BALANCE domain" : 
str : 					" has parent");
strstr : INIT : 					" has parent"); : 
strstr : if : 					" has parent"); : 
strstr : for : 					" has parent"); : 
strstr : while : 					" has parent"); : 
str : 		return -1;
strstr : INIT : 		return -1; : 
strstr : if : 		return -1; : 
strstr : for : 		return -1; : 
strstr : while : 		return -1; : 
str : 	}
strstr : INIT : 	} : 
strstr : if : 	} : 
strstr : for : 	} : 
strstr : while : 	} : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	printk(KERN_CONT "span %s level %s\n", str, sd->name);
strstr : if : 	printk(KERN_CONT "span %s level %s\n", str, sd->name); : 
strstr : for : 	printk(KERN_CONT "span %s level %s\n", str, sd->name); : 
strstr : while : 	printk(KERN_CONT "span %s level %s\n", str, sd->name); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	if (!cpumask_test_cpu(cpu, sched_domain_span(sd))) {
strstr : if : 	if (!cpumask_test_cpu(cpu, sched_domain_span(sd))) { : 
strstr : for : 	if (!cpumask_test_cpu(cpu, sched_domain_span(sd))) { : 
strstr : while : 	if (!cpumask_test_cpu(cpu, sched_domain_span(sd))) { : 
str : 		printk(KERN_ERR "ERROR: domain->span does not contain "
strstr : INIT : 		printk(KERN_ERR "ERROR: domain->span does not contain " : 
strstr : if : 		printk(KERN_ERR "ERROR: domain->span does not contain " : 
strstr : for : 		printk(KERN_ERR "ERROR: domain->span does not contain " : 
strstr : while : 		printk(KERN_ERR "ERROR: domain->span does not contain " : 
str : 				"CPU%d\n", cpu);
strstr : INIT : 				"CPU%d\n", cpu); : 
strstr : if : 				"CPU%d\n", cpu); : 
strstr : for : 				"CPU%d\n", cpu); : 
strstr : while : 				"CPU%d\n", cpu); : 
str : 	}
strstr : INIT : 	} : 
strstr : if : 	} : 
strstr : for : 	} : 
strstr : while : 	} : 
str : 	if (!cpumask_test_cpu(cpu, sched_group_cpus(group))) {
strstr : INIT : 	if (!cpumask_test_cpu(cpu, sched_group_cpus(group))) { : 
strstr : if : 	if (!cpumask_test_cpu(cpu, sched_group_cpus(group))) { : 
strstr : for : 	if (!cpumask_test_cpu(cpu, sched_group_cpus(group))) { : 
strstr : while : 	if (!cpumask_test_cpu(cpu, sched_group_cpus(group))) { : 
str : 		printk(KERN_ERR "ERROR: domain->groups does not contain"
strstr : INIT : 		printk(KERN_ERR "ERROR: domain->groups does not contain" : 
strstr : if : 		printk(KERN_ERR "ERROR: domain->groups does not contain" : 
strstr : for : 		printk(KERN_ERR "ERROR: domain->groups does not contain" : 
strstr : while : 		printk(KERN_ERR "ERROR: domain->groups does not contain" : 
str : 				" CPU%d\n", cpu);
strstr : INIT : 				" CPU%d\n", cpu); : 
strstr : if : 				" CPU%d\n", cpu); : 
strstr : for : 				" CPU%d\n", cpu); : 
strstr : while : 				" CPU%d\n", cpu); : 
str : 	}
strstr : INIT : 	} : 
strstr : if : 	} : 
strstr : for : 	} : 
strstr : while : 	} : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	printk(KERN_DEBUG "%*s groups:", level + 1, "");
strstr : if : 	printk(KERN_DEBUG "%*s groups:", level + 1, ""); : 
strstr : for : 	printk(KERN_DEBUG "%*s groups:", level + 1, ""); : 
strstr : while : 	printk(KERN_DEBUG "%*s groups:", level + 1, ""); : 
str : 	do {
strstr : INIT : 	do { : 
strstr : if : 	do { : 
strstr : for : 	do { : 
strstr : while : 	do { : 
str : 		if (!group) {
strstr : INIT : 		if (!group) { : 
strstr : if : 		if (!group) { : 
strstr : for : 		if (!group) { : 
strstr : while : 		if (!group) { : 
str : 			printk("\n");
strstr : INIT : 			printk("\n"); : 
strstr : if : 			printk("\n"); : 
strstr : for : 			printk("\n"); : 
strstr : while : 			printk("\n"); : 
str : 			printk(KERN_ERR "ERROR: group is NULL\n");
strstr : INIT : 			printk(KERN_ERR "ERROR: group is NULL\n"); : 
strstr : if : 			printk(KERN_ERR "ERROR: group is NULL\n"); : 
strstr : for : 			printk(KERN_ERR "ERROR: group is NULL\n"); : 
strstr : while : 			printk(KERN_ERR "ERROR: group is NULL\n"); : 
str : 			break;
strstr : INIT : 			break; : 
strstr : if : 			break; : 
strstr : for : 			break; : 
strstr : while : 			break; : 
str : 		}
strstr : INIT : 		} : 
strstr : if : 		} : 
strstr : for : 		} : 
strstr : while : 		} : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 		/*
strstr : if : 		/* : 
strstr : for : 		/* : 
strstr : while : 		/* : 
str : 		 * Even though we initialize ->power to something semi-sane,
strstr : INIT : 		 * Even though we initialize ->power to something semi-sane, : 
strstr : if : 		 * Even though we initialize ->power to something semi-sane, : 
strstr : for : 		 * Even though we initialize ->power to something semi-sane, : 
strstr : while : 		 * Even though we initialize ->power to something semi-sane, : 
str : 		 * we leave power_orig unset. This allows us to detect if
strstr : INIT : 		 * we leave power_orig unset. This allows us to detect if : 
strstr : if : 		 * we leave power_orig unset. This allows us to detect if : 
strstr : for : 		 * we leave power_orig unset. This allows us to detect if : 
strstr : while : 		 * we leave power_orig unset. This allows us to detect if : 
str : 		 * domain iteration is still funny without causing /0 traps.
strstr : INIT : 		 * domain iteration is still funny without causing /0 traps. : 
strstr : if : 		 * domain iteration is still funny without causing /0 traps. : 
strstr : for : 		 * domain iteration is still funny without causing /0 traps. : 
strstr : while : 		 * domain iteration is still funny without causing /0 traps. : 
str : 		 */
strstr : INIT : 		 */ : 
strstr : if : 		 */ : 
strstr : for : 		 */ : 
strstr : while : 		 */ : 
str : 		if (!group->sgp->power_orig) {
strstr : INIT : 		if (!group->sgp->power_orig) { : 
strstr : if : 		if (!group->sgp->power_orig) { : 
strstr : for : 		if (!group->sgp->power_orig) { : 
strstr : while : 		if (!group->sgp->power_orig) { : 
str : 			printk(KERN_CONT "\n");
strstr : INIT : 			printk(KERN_CONT "\n"); : 
strstr : if : 			printk(KERN_CONT "\n"); : 
strstr : for : 			printk(KERN_CONT "\n"); : 
strstr : while : 			printk(KERN_CONT "\n"); : 
str : 			printk(KERN_ERR "ERROR: domain->cpu_power not "
strstr : INIT : 			printk(KERN_ERR "ERROR: domain->cpu_power not " : 
strstr : if : 			printk(KERN_ERR "ERROR: domain->cpu_power not " : 
strstr : for : 			printk(KERN_ERR "ERROR: domain->cpu_power not " : 
strstr : while : 			printk(KERN_ERR "ERROR: domain->cpu_power not " : 
str : 					"set\n");
strstr : INIT : 					"set\n"); : 
strstr : if : 					"set\n"); : 
strstr : for : 					"set\n"); : 
strstr : while : 					"set\n"); : 
str : 			break;
strstr : INIT : 			break; : 
strstr : if : 			break; : 
strstr : for : 			break; : 
strstr : while : 			break; : 
str : 		}
strstr : INIT : 		} : 
strstr : if : 		} : 
strstr : for : 		} : 
strstr : while : 		} : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 		if (!cpumask_weight(sched_group_cpus(group))) {
strstr : if : 		if (!cpumask_weight(sched_group_cpus(group))) { : 
strstr : for : 		if (!cpumask_weight(sched_group_cpus(group))) { : 
strstr : while : 		if (!cpumask_weight(sched_group_cpus(group))) { : 
str : 			printk(KERN_CONT "\n");
strstr : INIT : 			printk(KERN_CONT "\n"); : 
strstr : if : 			printk(KERN_CONT "\n"); : 
strstr : for : 			printk(KERN_CONT "\n"); : 
strstr : while : 			printk(KERN_CONT "\n"); : 
str : 			printk(KERN_ERR "ERROR: empty group\n");
strstr : INIT : 			printk(KERN_ERR "ERROR: empty group\n"); : 
strstr : if : 			printk(KERN_ERR "ERROR: empty group\n"); : 
strstr : for : 			printk(KERN_ERR "ERROR: empty group\n"); : 
strstr : while : 			printk(KERN_ERR "ERROR: empty group\n"); : 
str : 			break;
strstr : INIT : 			break; : 
strstr : if : 			break; : 
strstr : for : 			break; : 
strstr : while : 			break; : 
str : 		}
strstr : INIT : 		} : 
strstr : if : 		} : 
strstr : for : 		} : 
strstr : while : 		} : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 		if (!(sd->flags & SD_OVERLAP) &&
strstr : if : 		if (!(sd->flags & SD_OVERLAP) && : 
strstr : for : 		if (!(sd->flags & SD_OVERLAP) && : 
strstr : while : 		if (!(sd->flags & SD_OVERLAP) && : 
str : 		    cpumask_intersects(groupmask, sched_group_cpus(group))) {
strstr : INIT : 		    cpumask_intersects(groupmask, sched_group_cpus(group))) { : 
strstr : if : 		    cpumask_intersects(groupmask, sched_group_cpus(group))) { : 
strstr : for : 		    cpumask_intersects(groupmask, sched_group_cpus(group))) { : 
strstr : while : 		    cpumask_intersects(groupmask, sched_group_cpus(group))) { : 
str : 			printk(KERN_CONT "\n");
strstr : INIT : 			printk(KERN_CONT "\n"); : 
strstr : if : 			printk(KERN_CONT "\n"); : 
strstr : for : 			printk(KERN_CONT "\n"); : 
strstr : while : 			printk(KERN_CONT "\n"); : 
str : 			printk(KERN_ERR "ERROR: repeated CPUs\n");
strstr : INIT : 			printk(KERN_ERR "ERROR: repeated CPUs\n"); : 
strstr : if : 			printk(KERN_ERR "ERROR: repeated CPUs\n"); : 
strstr : for : 			printk(KERN_ERR "ERROR: repeated CPUs\n"); : 
strstr : while : 			printk(KERN_ERR "ERROR: repeated CPUs\n"); : 
str : 			break;
strstr : INIT : 			break; : 
strstr : if : 			break; : 
strstr : for : 			break; : 
strstr : while : 			break; : 
str : 		}
strstr : INIT : 		} : 
strstr : if : 		} : 
strstr : for : 		} : 
strstr : while : 		} : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 		cpumask_or(groupmask, groupmask, sched_group_cpus(group));
strstr : if : 		cpumask_or(groupmask, groupmask, sched_group_cpus(group)); : 
strstr : for : 		cpumask_or(groupmask, groupmask, sched_group_cpus(group)); : 
strstr : while : 		cpumask_or(groupmask, groupmask, sched_group_cpus(group)); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 		cpulist_scnprintf(str, sizeof(str), sched_group_cpus(group));
strstr : if : 		cpulist_scnprintf(str, sizeof(str), sched_group_cpus(group)); : 
strstr : for : 		cpulist_scnprintf(str, sizeof(str), sched_group_cpus(group)); : 
strstr : while : 		cpulist_scnprintf(str, sizeof(str), sched_group_cpus(group)); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 		printk(KERN_CONT " %s", str);
strstr : if : 		printk(KERN_CONT " %s", str); : 
strstr : for : 		printk(KERN_CONT " %s", str); : 
strstr : while : 		printk(KERN_CONT " %s", str); : 
str : 		if (group->sgp->power != SCHED_POWER_SCALE) {
strstr : INIT : 		if (group->sgp->power != SCHED_POWER_SCALE) { : 
strstr : if : 		if (group->sgp->power != SCHED_POWER_SCALE) { : 
strstr : for : 		if (group->sgp->power != SCHED_POWER_SCALE) { : 
strstr : while : 		if (group->sgp->power != SCHED_POWER_SCALE) { : 
str : 			printk(KERN_CONT " (cpu_power = %d)",
strstr : INIT : 			printk(KERN_CONT " (cpu_power = %d)", : 
strstr : if : 			printk(KERN_CONT " (cpu_power = %d)", : 
strstr : for : 			printk(KERN_CONT " (cpu_power = %d)", : 
strstr : while : 			printk(KERN_CONT " (cpu_power = %d)", : 
str : 				group->sgp->power);
strstr : INIT : 				group->sgp->power); : 
strstr : if : 				group->sgp->power); : 
strstr : for : 				group->sgp->power); : 
strstr : while : 				group->sgp->power); : 
str : 		}
strstr : INIT : 		} : 
strstr : if : 		} : 
strstr : for : 		} : 
strstr : while : 		} : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 		group = group->next;
strstr : if : 		group = group->next; : 
strstr : for : 		group = group->next; : 
strstr : while : 		group = group->next; : 
str : 	} while (group != sd->groups);
strstr : INIT : 	} while (group != sd->groups); : 
strstr : if : 	} while (group != sd->groups); : 
strstr : for : 	} while (group != sd->groups); : 
strstr : while : 	} while (group != sd->groups); : 
str : 	printk(KERN_CONT "\n");
strstr : INIT : 	printk(KERN_CONT "\n"); : 
strstr : if : 	printk(KERN_CONT "\n"); : 
strstr : for : 	printk(KERN_CONT "\n"); : 
strstr : while : 	printk(KERN_CONT "\n"); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	if (!cpumask_equal(sched_domain_span(sd), groupmask))
strstr : if : 	if (!cpumask_equal(sched_domain_span(sd), groupmask)) : 
strstr : for : 	if (!cpumask_equal(sched_domain_span(sd), groupmask)) : 
strstr : while : 	if (!cpumask_equal(sched_domain_span(sd), groupmask)) : 
str : 		printk(KERN_ERR "ERROR: groups don't span domain->span\n");
strstr : INIT : 		printk(KERN_ERR "ERROR: groups don't span domain->span\n"); : 
strstr : if : 		printk(KERN_ERR "ERROR: groups don't span domain->span\n"); : 
strstr : for : 		printk(KERN_ERR "ERROR: groups don't span domain->span\n"); : 
strstr : while : 		printk(KERN_ERR "ERROR: groups don't span domain->span\n"); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	if (sd->parent &&
strstr : if : 	if (sd->parent && : 
strstr : for : 	if (sd->parent && : 
strstr : while : 	if (sd->parent && : 
str : 	    !cpumask_subset(groupmask, sched_domain_span(sd->parent)))
strstr : INIT : 	    !cpumask_subset(groupmask, sched_domain_span(sd->parent))) : 
strstr : if : 	    !cpumask_subset(groupmask, sched_domain_span(sd->parent))) : 
strstr : for : 	    !cpumask_subset(groupmask, sched_domain_span(sd->parent))) : 
strstr : while : 	    !cpumask_subset(groupmask, sched_domain_span(sd->parent))) : 
str : 		printk(KERN_ERR "ERROR: parent span is not a superset "
strstr : INIT : 		printk(KERN_ERR "ERROR: parent span is not a superset " : 
strstr : if : 		printk(KERN_ERR "ERROR: parent span is not a superset " : 
strstr : for : 		printk(KERN_ERR "ERROR: parent span is not a superset " : 
strstr : while : 		printk(KERN_ERR "ERROR: parent span is not a superset " : 
str : 			"of domain->span\n");
strstr : INIT : 			"of domain->span\n"); : 
strstr : if : 			"of domain->span\n"); : 
strstr : for : 			"of domain->span\n"); : 
strstr : while : 			"of domain->span\n"); : 
str : 	return 0;
strstr : INIT : 	return 0; : 
strstr : if : 	return 0; : 
strstr : for : 	return 0; : 
strstr : while : 	return 0; : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : static void sched_domain_debug(struct sched_domain *sd, int cpu)
strstr : if : static void sched_domain_debug(struct sched_domain *sd, int cpu) : 
strstr : for : static void sched_domain_debug(struct sched_domain *sd, int cpu) : 
strstr : while : static void sched_domain_debug(struct sched_domain *sd, int cpu) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	int level = 0;
strstr : INIT : 	int level = 0; : 
strstr : if : 	int level = 0; : 
strstr : for : 	int level = 0; : 
strstr : while : 	int level = 0; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	if (!sched_debug_enabled)
strstr : if : 	if (!sched_debug_enabled) : 
strstr : for : 	if (!sched_debug_enabled) : 
strstr : while : 	if (!sched_debug_enabled) : 
str : 		return;
strstr : INIT : 		return; : 
strstr : if : 		return; : 
strstr : for : 		return; : 
strstr : while : 		return; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	if (!sd) {
strstr : if : 	if (!sd) { : 
strstr : for : 	if (!sd) { : 
strstr : while : 	if (!sd) { : 
str : 		printk(KERN_DEBUG "CPU%d attaching NULL sched-domain.\n", cpu);
strstr : INIT : 		printk(KERN_DEBUG "CPU%d attaching NULL sched-domain.\n", cpu); : 
strstr : if : 		printk(KERN_DEBUG "CPU%d attaching NULL sched-domain.\n", cpu); : 
strstr : for : 		printk(KERN_DEBUG "CPU%d attaching NULL sched-domain.\n", cpu); : 
strstr : while : 		printk(KERN_DEBUG "CPU%d attaching NULL sched-domain.\n", cpu); : 
str : 		return;
strstr : INIT : 		return; : 
strstr : if : 		return; : 
strstr : for : 		return; : 
strstr : while : 		return; : 
str : 	}
strstr : INIT : 	} : 
strstr : if : 	} : 
strstr : for : 	} : 
strstr : while : 	} : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	printk(KERN_DEBUG "CPU%d attaching sched-domain:\n", cpu);
strstr : if : 	printk(KERN_DEBUG "CPU%d attaching sched-domain:\n", cpu); : 
strstr : for : 	printk(KERN_DEBUG "CPU%d attaching sched-domain:\n", cpu); : 
strstr : while : 	printk(KERN_DEBUG "CPU%d attaching sched-domain:\n", cpu); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	for (;;) {
strstr : if : 	for (;;) { : 
strstr : for : 	for (;;) { : 
strstr : while : 	for (;;) { : 
str : 		if (sched_domain_debug_one(sd, cpu, level, sched_domains_tmpmask))
strstr : INIT : 		if (sched_domain_debug_one(sd, cpu, level, sched_domains_tmpmask)) : 
strstr : if : 		if (sched_domain_debug_one(sd, cpu, level, sched_domains_tmpmask)) : 
strstr : for : 		if (sched_domain_debug_one(sd, cpu, level, sched_domains_tmpmask)) : 
strstr : while : 		if (sched_domain_debug_one(sd, cpu, level, sched_domains_tmpmask)) : 
str : 			break;
strstr : INIT : 			break; : 
strstr : if : 			break; : 
strstr : for : 			break; : 
strstr : while : 			break; : 
str : 		level++;
strstr : INIT : 		level++; : 
strstr : if : 		level++; : 
strstr : for : 		level++; : 
strstr : while : 		level++; : 
str : 		sd = sd->parent;
strstr : INIT : 		sd = sd->parent; : 
strstr : if : 		sd = sd->parent; : 
strstr : for : 		sd = sd->parent; : 
strstr : while : 		sd = sd->parent; : 
str : 		if (!sd)
strstr : INIT : 		if (!sd) : 
strstr : if : 		if (!sd) : 
strstr : for : 		if (!sd) : 
strstr : while : 		if (!sd) : 
str : 			break;
strstr : INIT : 			break; : 
strstr : if : 			break; : 
strstr : for : 			break; : 
strstr : while : 			break; : 
str : 	}
strstr : INIT : 	} : 
strstr : if : 	} : 
strstr : for : 	} : 
strstr : while : 	} : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : #else /* !CONFIG_SCHED_DEBUG */
strstr : INIT : #else /* !CONFIG_SCHED_DEBUG */ : 
strstr : if : #else /* !CONFIG_SCHED_DEBUG */ : 
strstr : for : #else /* !CONFIG_SCHED_DEBUG */ : 
strstr : while : #else /* !CONFIG_SCHED_DEBUG */ : 
str : # define sched_domain_debug(sd, cpu) do { } while (0)
strstr : INIT : # define sched_domain_debug(sd, cpu) do { } while (0) : 
strstr : if : # define sched_domain_debug(sd, cpu) do { } while (0) : 
strstr : for : # define sched_domain_debug(sd, cpu) do { } while (0) : 
strstr : while : # define sched_domain_debug(sd, cpu) do { } while (0) : 
str : static inline bool sched_debug(void)
strstr : INIT : static inline bool sched_debug(void) : 
strstr : if : static inline bool sched_debug(void) : 
strstr : for : static inline bool sched_debug(void) : 
strstr : while : static inline bool sched_debug(void) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	return false;
strstr : INIT : 	return false; : 
strstr : if : 	return false; : 
strstr : for : 	return false; : 
strstr : while : 	return false; : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : #endif /* CONFIG_SCHED_DEBUG */
strstr : INIT : #endif /* CONFIG_SCHED_DEBUG */ : 
strstr : if : #endif /* CONFIG_SCHED_DEBUG */ : 
strstr : for : #endif /* CONFIG_SCHED_DEBUG */ : 
strstr : while : #endif /* CONFIG_SCHED_DEBUG */ : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : static int sd_degenerate(struct sched_domain *sd)
strstr : if : static int sd_degenerate(struct sched_domain *sd) : 
strstr : for : static int sd_degenerate(struct sched_domain *sd) : 
strstr : while : static int sd_degenerate(struct sched_domain *sd) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	if (cpumask_weight(sched_domain_span(sd)) == 1)
strstr : INIT : 	if (cpumask_weight(sched_domain_span(sd)) == 1) : 
strstr : if : 	if (cpumask_weight(sched_domain_span(sd)) == 1) : 
strstr : for : 	if (cpumask_weight(sched_domain_span(sd)) == 1) : 
strstr : while : 	if (cpumask_weight(sched_domain_span(sd)) == 1) : 
str : 		return 1;
strstr : INIT : 		return 1; : 
strstr : if : 		return 1; : 
strstr : for : 		return 1; : 
strstr : while : 		return 1; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	/* Following flags need at least 2 groups */
strstr : if : 	/* Following flags need at least 2 groups */ : 
strstr : for : 	/* Following flags need at least 2 groups */ : 
strstr : while : 	/* Following flags need at least 2 groups */ : 
str : 	if (sd->flags & (SD_LOAD_BALANCE |
strstr : INIT : 	if (sd->flags & (SD_LOAD_BALANCE | : 
strstr : if : 	if (sd->flags & (SD_LOAD_BALANCE | : 
strstr : for : 	if (sd->flags & (SD_LOAD_BALANCE | : 
strstr : while : 	if (sd->flags & (SD_LOAD_BALANCE | : 
str : 			 SD_BALANCE_NEWIDLE |
strstr : INIT : 			 SD_BALANCE_NEWIDLE | : 
strstr : if : 			 SD_BALANCE_NEWIDLE | : 
strstr : for : 			 SD_BALANCE_NEWIDLE | : 
strstr : while : 			 SD_BALANCE_NEWIDLE | : 
str : 			 SD_BALANCE_FORK |
strstr : INIT : 			 SD_BALANCE_FORK | : 
strstr : if : 			 SD_BALANCE_FORK | : 
strstr : for : 			 SD_BALANCE_FORK | : 
strstr : while : 			 SD_BALANCE_FORK | : 
str : 			 SD_BALANCE_EXEC |
strstr : INIT : 			 SD_BALANCE_EXEC | : 
strstr : if : 			 SD_BALANCE_EXEC | : 
strstr : for : 			 SD_BALANCE_EXEC | : 
strstr : while : 			 SD_BALANCE_EXEC | : 
str : 			 SD_SHARE_CPUPOWER |
strstr : INIT : 			 SD_SHARE_CPUPOWER | : 
strstr : if : 			 SD_SHARE_CPUPOWER | : 
strstr : for : 			 SD_SHARE_CPUPOWER | : 
strstr : while : 			 SD_SHARE_CPUPOWER | : 
str : 			 SD_SHARE_PKG_RESOURCES)) {
strstr : INIT : 			 SD_SHARE_PKG_RESOURCES)) { : 
strstr : if : 			 SD_SHARE_PKG_RESOURCES)) { : 
strstr : for : 			 SD_SHARE_PKG_RESOURCES)) { : 
strstr : while : 			 SD_SHARE_PKG_RESOURCES)) { : 
str : 		if (sd->groups != sd->groups->next)
strstr : INIT : 		if (sd->groups != sd->groups->next) : 
strstr : if : 		if (sd->groups != sd->groups->next) : 
strstr : for : 		if (sd->groups != sd->groups->next) : 
strstr : while : 		if (sd->groups != sd->groups->next) : 
str : 			return 0;
strstr : INIT : 			return 0; : 
strstr : if : 			return 0; : 
strstr : for : 			return 0; : 
strstr : while : 			return 0; : 
str : 	}
strstr : INIT : 	} : 
strstr : if : 	} : 
strstr : for : 	} : 
strstr : while : 	} : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	/* Following flags don't use groups */
strstr : if : 	/* Following flags don't use groups */ : 
strstr : for : 	/* Following flags don't use groups */ : 
strstr : while : 	/* Following flags don't use groups */ : 
str : 	if (sd->flags & (SD_WAKE_AFFINE))
strstr : INIT : 	if (sd->flags & (SD_WAKE_AFFINE)) : 
strstr : if : 	if (sd->flags & (SD_WAKE_AFFINE)) : 
strstr : for : 	if (sd->flags & (SD_WAKE_AFFINE)) : 
strstr : while : 	if (sd->flags & (SD_WAKE_AFFINE)) : 
str : 		return 0;
strstr : INIT : 		return 0; : 
strstr : if : 		return 0; : 
strstr : for : 		return 0; : 
strstr : while : 		return 0; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	return 1;
strstr : if : 	return 1; : 
strstr : for : 	return 1; : 
strstr : while : 	return 1; : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : static int
strstr : if : static int : 
strstr : for : static int : 
strstr : while : static int : 
str : sd_parent_degenerate(struct sched_domain *sd, struct sched_domain *parent)
strstr : INIT : sd_parent_degenerate(struct sched_domain *sd, struct sched_domain *parent) : 
strstr : if : sd_parent_degenerate(struct sched_domain *sd, struct sched_domain *parent) : 
strstr : for : sd_parent_degenerate(struct sched_domain *sd, struct sched_domain *parent) : 
strstr : while : sd_parent_degenerate(struct sched_domain *sd, struct sched_domain *parent) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	unsigned long cflags = sd->flags, pflags = parent->flags;
strstr : INIT : 	unsigned long cflags = sd->flags, pflags = parent->flags; : 
strstr : if : 	unsigned long cflags = sd->flags, pflags = parent->flags; : 
strstr : for : 	unsigned long cflags = sd->flags, pflags = parent->flags; : 
strstr : while : 	unsigned long cflags = sd->flags, pflags = parent->flags; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	if (sd_degenerate(parent))
strstr : if : 	if (sd_degenerate(parent)) : 
strstr : for : 	if (sd_degenerate(parent)) : 
strstr : while : 	if (sd_degenerate(parent)) : 
str : 		return 1;
strstr : INIT : 		return 1; : 
strstr : if : 		return 1; : 
strstr : for : 		return 1; : 
strstr : while : 		return 1; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	if (!cpumask_equal(sched_domain_span(sd), sched_domain_span(parent)))
strstr : if : 	if (!cpumask_equal(sched_domain_span(sd), sched_domain_span(parent))) : 
strstr : for : 	if (!cpumask_equal(sched_domain_span(sd), sched_domain_span(parent))) : 
strstr : while : 	if (!cpumask_equal(sched_domain_span(sd), sched_domain_span(parent))) : 
str : 		return 0;
strstr : INIT : 		return 0; : 
strstr : if : 		return 0; : 
strstr : for : 		return 0; : 
strstr : while : 		return 0; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	/* Flags needing groups don't count if only 1 group in parent */
strstr : if : 	/* Flags needing groups don't count if only 1 group in parent */ : 
strstr : for : 	/* Flags needing groups don't count if only 1 group in parent */ : 
strstr : while : 	/* Flags needing groups don't count if only 1 group in parent */ : 
str : 	if (parent->groups == parent->groups->next) {
strstr : INIT : 	if (parent->groups == parent->groups->next) { : 
strstr : if : 	if (parent->groups == parent->groups->next) { : 
strstr : for : 	if (parent->groups == parent->groups->next) { : 
strstr : while : 	if (parent->groups == parent->groups->next) { : 
str : 		pflags &= ~(SD_LOAD_BALANCE |
strstr : INIT : 		pflags &= ~(SD_LOAD_BALANCE | : 
strstr : if : 		pflags &= ~(SD_LOAD_BALANCE | : 
strstr : for : 		pflags &= ~(SD_LOAD_BALANCE | : 
strstr : while : 		pflags &= ~(SD_LOAD_BALANCE | : 
str : 				SD_BALANCE_NEWIDLE |
strstr : INIT : 				SD_BALANCE_NEWIDLE | : 
strstr : if : 				SD_BALANCE_NEWIDLE | : 
strstr : for : 				SD_BALANCE_NEWIDLE | : 
strstr : while : 				SD_BALANCE_NEWIDLE | : 
str : 				SD_BALANCE_FORK |
strstr : INIT : 				SD_BALANCE_FORK | : 
strstr : if : 				SD_BALANCE_FORK | : 
strstr : for : 				SD_BALANCE_FORK | : 
strstr : while : 				SD_BALANCE_FORK | : 
str : 				SD_BALANCE_EXEC |
strstr : INIT : 				SD_BALANCE_EXEC | : 
strstr : if : 				SD_BALANCE_EXEC | : 
strstr : for : 				SD_BALANCE_EXEC | : 
strstr : while : 				SD_BALANCE_EXEC | : 
str : 				SD_SHARE_CPUPOWER |
strstr : INIT : 				SD_SHARE_CPUPOWER | : 
strstr : if : 				SD_SHARE_CPUPOWER | : 
strstr : for : 				SD_SHARE_CPUPOWER | : 
strstr : while : 				SD_SHARE_CPUPOWER | : 
str : 				SD_SHARE_PKG_RESOURCES |
strstr : INIT : 				SD_SHARE_PKG_RESOURCES | : 
strstr : if : 				SD_SHARE_PKG_RESOURCES | : 
strstr : for : 				SD_SHARE_PKG_RESOURCES | : 
strstr : while : 				SD_SHARE_PKG_RESOURCES | : 
str : 				SD_PREFER_SIBLING);
strstr : INIT : 				SD_PREFER_SIBLING); : 
strstr : if : 				SD_PREFER_SIBLING); : 
strstr : for : 				SD_PREFER_SIBLING); : 
strstr : while : 				SD_PREFER_SIBLING); : 
str : 		if (nr_node_ids == 1)
strstr : INIT : 		if (nr_node_ids == 1) : 
strstr : if : 		if (nr_node_ids == 1) : 
strstr : for : 		if (nr_node_ids == 1) : 
strstr : while : 		if (nr_node_ids == 1) : 
str : 			pflags &= ~SD_SERIALIZE;
strstr : INIT : 			pflags &= ~SD_SERIALIZE; : 
strstr : if : 			pflags &= ~SD_SERIALIZE; : 
strstr : for : 			pflags &= ~SD_SERIALIZE; : 
strstr : while : 			pflags &= ~SD_SERIALIZE; : 
str : 	}
strstr : INIT : 	} : 
strstr : if : 	} : 
strstr : for : 	} : 
strstr : while : 	} : 
str : 	if (~cflags & pflags)
strstr : INIT : 	if (~cflags & pflags) : 
strstr : if : 	if (~cflags & pflags) : 
strstr : for : 	if (~cflags & pflags) : 
strstr : while : 	if (~cflags & pflags) : 
str : 		return 0;
strstr : INIT : 		return 0; : 
strstr : if : 		return 0; : 
strstr : for : 		return 0; : 
strstr : while : 		return 0; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	return 1;
strstr : if : 	return 1; : 
strstr : for : 	return 1; : 
strstr : while : 	return 1; : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : static void free_rootdomain(struct rcu_head *rcu)
strstr : if : static void free_rootdomain(struct rcu_head *rcu) : 
strstr : for : static void free_rootdomain(struct rcu_head *rcu) : 
strstr : while : static void free_rootdomain(struct rcu_head *rcu) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	struct root_domain *rd = container_of(rcu, struct root_domain, rcu);
strstr : INIT : 	struct root_domain *rd = container_of(rcu, struct root_domain, rcu); : 
strstr : if : 	struct root_domain *rd = container_of(rcu, struct root_domain, rcu); : 
strstr : for : 	struct root_domain *rd = container_of(rcu, struct root_domain, rcu); : 
strstr : while : 	struct root_domain *rd = container_of(rcu, struct root_domain, rcu); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	cpupri_cleanup(&rd->cpupri);
strstr : if : 	cpupri_cleanup(&rd->cpupri); : 
strstr : for : 	cpupri_cleanup(&rd->cpupri); : 
strstr : while : 	cpupri_cleanup(&rd->cpupri); : 
str : 	cpudl_cleanup(&rd->cpudl);
strstr : INIT : 	cpudl_cleanup(&rd->cpudl); : 
strstr : if : 	cpudl_cleanup(&rd->cpudl); : 
strstr : for : 	cpudl_cleanup(&rd->cpudl); : 
strstr : while : 	cpudl_cleanup(&rd->cpudl); : 
str : 	free_cpumask_var(rd->dlo_mask);
strstr : INIT : 	free_cpumask_var(rd->dlo_mask); : 
strstr : if : 	free_cpumask_var(rd->dlo_mask); : 
strstr : for : 	free_cpumask_var(rd->dlo_mask); : 
strstr : while : 	free_cpumask_var(rd->dlo_mask); : 
str : 	free_cpumask_var(rd->rto_mask);
strstr : INIT : 	free_cpumask_var(rd->rto_mask); : 
strstr : if : 	free_cpumask_var(rd->rto_mask); : 
strstr : for : 	free_cpumask_var(rd->rto_mask); : 
strstr : while : 	free_cpumask_var(rd->rto_mask); : 
str : 	free_cpumask_var(rd->online);
strstr : INIT : 	free_cpumask_var(rd->online); : 
strstr : if : 	free_cpumask_var(rd->online); : 
strstr : for : 	free_cpumask_var(rd->online); : 
strstr : while : 	free_cpumask_var(rd->online); : 
str : 	free_cpumask_var(rd->span);
strstr : INIT : 	free_cpumask_var(rd->span); : 
strstr : if : 	free_cpumask_var(rd->span); : 
strstr : for : 	free_cpumask_var(rd->span); : 
strstr : while : 	free_cpumask_var(rd->span); : 
str : 	kfree(rd);
strstr : INIT : 	kfree(rd); : 
strstr : if : 	kfree(rd); : 
strstr : for : 	kfree(rd); : 
strstr : while : 	kfree(rd); : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : static void rq_attach_root(struct rq *rq, struct root_domain *rd)
strstr : if : static void rq_attach_root(struct rq *rq, struct root_domain *rd) : 
strstr : for : static void rq_attach_root(struct rq *rq, struct root_domain *rd) : 
strstr : while : static void rq_attach_root(struct rq *rq, struct root_domain *rd) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	struct root_domain *old_rd = NULL;
strstr : INIT : 	struct root_domain *old_rd = NULL; : 
strstr : if : 	struct root_domain *old_rd = NULL; : 
strstr : for : 	struct root_domain *old_rd = NULL; : 
strstr : while : 	struct root_domain *old_rd = NULL; : 
str : 	unsigned long flags;
strstr : INIT : 	unsigned long flags; : 
strstr : if : 	unsigned long flags; : 
strstr : for : 	unsigned long flags; : 
strstr : while : 	unsigned long flags; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	raw_spin_lock_irqsave(&rq->lock, flags);
strstr : if : 	raw_spin_lock_irqsave(&rq->lock, flags); : 
strstr : for : 	raw_spin_lock_irqsave(&rq->lock, flags); : 
strstr : while : 	raw_spin_lock_irqsave(&rq->lock, flags); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	if (rq->rd) {
strstr : if : 	if (rq->rd) { : 
strstr : for : 	if (rq->rd) { : 
strstr : while : 	if (rq->rd) { : 
str : 		old_rd = rq->rd;
strstr : INIT : 		old_rd = rq->rd; : 
strstr : if : 		old_rd = rq->rd; : 
strstr : for : 		old_rd = rq->rd; : 
strstr : while : 		old_rd = rq->rd; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 		if (cpumask_test_cpu(rq->cpu, old_rd->online))
strstr : if : 		if (cpumask_test_cpu(rq->cpu, old_rd->online)) : 
strstr : for : 		if (cpumask_test_cpu(rq->cpu, old_rd->online)) : 
strstr : while : 		if (cpumask_test_cpu(rq->cpu, old_rd->online)) : 
str : 			set_rq_offline(rq);
strstr : INIT : 			set_rq_offline(rq); : 
strstr : if : 			set_rq_offline(rq); : 
strstr : for : 			set_rq_offline(rq); : 
strstr : while : 			set_rq_offline(rq); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 		cpumask_clear_cpu(rq->cpu, old_rd->span);
strstr : if : 		cpumask_clear_cpu(rq->cpu, old_rd->span); : 
strstr : for : 		cpumask_clear_cpu(rq->cpu, old_rd->span); : 
strstr : while : 		cpumask_clear_cpu(rq->cpu, old_rd->span); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 		/*
strstr : if : 		/* : 
strstr : for : 		/* : 
strstr : while : 		/* : 
str : 		 * If we dont want to free the old_rd yet then
strstr : INIT : 		 * If we dont want to free the old_rd yet then : 
strstr : if : 		 * If we dont want to free the old_rd yet then : 
strstr : for : 		 * If we dont want to free the old_rd yet then : 
strstr : while : 		 * If we dont want to free the old_rd yet then : 
str : 		 * set old_rd to NULL to skip the freeing later
strstr : INIT : 		 * set old_rd to NULL to skip the freeing later : 
strstr : if : 		 * set old_rd to NULL to skip the freeing later : 
strstr : for : 		 * set old_rd to NULL to skip the freeing later : 
strstr : while : 		 * set old_rd to NULL to skip the freeing later : 
str : 		 * in this function:
strstr : INIT : 		 * in this function: : 
strstr : if : 		 * in this function: : 
strstr : for : 		 * in this function: : 
strstr : while : 		 * in this function: : 
str : 		 */
strstr : INIT : 		 */ : 
strstr : if : 		 */ : 
strstr : for : 		 */ : 
strstr : while : 		 */ : 
str : 		if (!atomic_dec_and_test(&old_rd->refcount))
strstr : INIT : 		if (!atomic_dec_and_test(&old_rd->refcount)) : 
strstr : if : 		if (!atomic_dec_and_test(&old_rd->refcount)) : 
strstr : for : 		if (!atomic_dec_and_test(&old_rd->refcount)) : 
strstr : while : 		if (!atomic_dec_and_test(&old_rd->refcount)) : 
str : 			old_rd = NULL;
strstr : INIT : 			old_rd = NULL; : 
strstr : if : 			old_rd = NULL; : 
strstr : for : 			old_rd = NULL; : 
strstr : while : 			old_rd = NULL; : 
str : 	}
strstr : INIT : 	} : 
strstr : if : 	} : 
strstr : for : 	} : 
strstr : while : 	} : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	atomic_inc(&rd->refcount);
strstr : if : 	atomic_inc(&rd->refcount); : 
strstr : for : 	atomic_inc(&rd->refcount); : 
strstr : while : 	atomic_inc(&rd->refcount); : 
str : 	rq->rd = rd;
strstr : INIT : 	rq->rd = rd; : 
strstr : if : 	rq->rd = rd; : 
strstr : for : 	rq->rd = rd; : 
strstr : while : 	rq->rd = rd; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	cpumask_set_cpu(rq->cpu, rd->span);
strstr : if : 	cpumask_set_cpu(rq->cpu, rd->span); : 
strstr : for : 	cpumask_set_cpu(rq->cpu, rd->span); : 
strstr : while : 	cpumask_set_cpu(rq->cpu, rd->span); : 
str : 	if (cpumask_test_cpu(rq->cpu, cpu_active_mask))
strstr : INIT : 	if (cpumask_test_cpu(rq->cpu, cpu_active_mask)) : 
strstr : if : 	if (cpumask_test_cpu(rq->cpu, cpu_active_mask)) : 
strstr : for : 	if (cpumask_test_cpu(rq->cpu, cpu_active_mask)) : 
strstr : while : 	if (cpumask_test_cpu(rq->cpu, cpu_active_mask)) : 
str : 		set_rq_online(rq);
strstr : INIT : 		set_rq_online(rq); : 
strstr : if : 		set_rq_online(rq); : 
strstr : for : 		set_rq_online(rq); : 
strstr : while : 		set_rq_online(rq); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	raw_spin_unlock_irqrestore(&rq->lock, flags);
strstr : if : 	raw_spin_unlock_irqrestore(&rq->lock, flags); : 
strstr : for : 	raw_spin_unlock_irqrestore(&rq->lock, flags); : 
strstr : while : 	raw_spin_unlock_irqrestore(&rq->lock, flags); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	if (old_rd)
strstr : if : 	if (old_rd) : 
strstr : for : 	if (old_rd) : 
strstr : while : 	if (old_rd) : 
str : 		call_rcu_sched(&old_rd->rcu, free_rootdomain);
strstr : INIT : 		call_rcu_sched(&old_rd->rcu, free_rootdomain); : 
strstr : if : 		call_rcu_sched(&old_rd->rcu, free_rootdomain); : 
strstr : for : 		call_rcu_sched(&old_rd->rcu, free_rootdomain); : 
strstr : while : 		call_rcu_sched(&old_rd->rcu, free_rootdomain); : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : static int init_rootdomain(struct root_domain *rd)
strstr : if : static int init_rootdomain(struct root_domain *rd) : 
strstr : for : static int init_rootdomain(struct root_domain *rd) : 
strstr : while : static int init_rootdomain(struct root_domain *rd) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	memset(rd, 0, sizeof(*rd));
strstr : INIT : 	memset(rd, 0, sizeof(*rd)); : 
strstr : if : 	memset(rd, 0, sizeof(*rd)); : 
strstr : for : 	memset(rd, 0, sizeof(*rd)); : 
strstr : while : 	memset(rd, 0, sizeof(*rd)); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	if (!alloc_cpumask_var(&rd->span, GFP_KERNEL))
strstr : if : 	if (!alloc_cpumask_var(&rd->span, GFP_KERNEL)) : 
strstr : for : 	if (!alloc_cpumask_var(&rd->span, GFP_KERNEL)) : 
strstr : while : 	if (!alloc_cpumask_var(&rd->span, GFP_KERNEL)) : 
str : 		goto out;
strstr : INIT : 		goto out; : 
strstr : if : 		goto out; : 
strstr : for : 		goto out; : 
strstr : while : 		goto out; : 
str : 	if (!alloc_cpumask_var(&rd->online, GFP_KERNEL))
strstr : INIT : 	if (!alloc_cpumask_var(&rd->online, GFP_KERNEL)) : 
strstr : if : 	if (!alloc_cpumask_var(&rd->online, GFP_KERNEL)) : 
strstr : for : 	if (!alloc_cpumask_var(&rd->online, GFP_KERNEL)) : 
strstr : while : 	if (!alloc_cpumask_var(&rd->online, GFP_KERNEL)) : 
str : 		goto free_span;
strstr : INIT : 		goto free_span; : 
strstr : if : 		goto free_span; : 
strstr : for : 		goto free_span; : 
strstr : while : 		goto free_span; : 
str : 	if (!alloc_cpumask_var(&rd->dlo_mask, GFP_KERNEL))
strstr : INIT : 	if (!alloc_cpumask_var(&rd->dlo_mask, GFP_KERNEL)) : 
strstr : if : 	if (!alloc_cpumask_var(&rd->dlo_mask, GFP_KERNEL)) : 
strstr : for : 	if (!alloc_cpumask_var(&rd->dlo_mask, GFP_KERNEL)) : 
strstr : while : 	if (!alloc_cpumask_var(&rd->dlo_mask, GFP_KERNEL)) : 
str : 		goto free_online;
strstr : INIT : 		goto free_online; : 
strstr : if : 		goto free_online; : 
strstr : for : 		goto free_online; : 
strstr : while : 		goto free_online; : 
str : 	if (!alloc_cpumask_var(&rd->rto_mask, GFP_KERNEL))
strstr : INIT : 	if (!alloc_cpumask_var(&rd->rto_mask, GFP_KERNEL)) : 
strstr : if : 	if (!alloc_cpumask_var(&rd->rto_mask, GFP_KERNEL)) : 
strstr : for : 	if (!alloc_cpumask_var(&rd->rto_mask, GFP_KERNEL)) : 
strstr : while : 	if (!alloc_cpumask_var(&rd->rto_mask, GFP_KERNEL)) : 
str : 		goto free_dlo_mask;
strstr : INIT : 		goto free_dlo_mask; : 
strstr : if : 		goto free_dlo_mask; : 
strstr : for : 		goto free_dlo_mask; : 
strstr : while : 		goto free_dlo_mask; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	init_dl_bw(&rd->dl_bw);
strstr : if : 	init_dl_bw(&rd->dl_bw); : 
strstr : for : 	init_dl_bw(&rd->dl_bw); : 
strstr : while : 	init_dl_bw(&rd->dl_bw); : 
str : 	if (cpudl_init(&rd->cpudl) != 0)
strstr : INIT : 	if (cpudl_init(&rd->cpudl) != 0) : 
strstr : if : 	if (cpudl_init(&rd->cpudl) != 0) : 
strstr : for : 	if (cpudl_init(&rd->cpudl) != 0) : 
strstr : while : 	if (cpudl_init(&rd->cpudl) != 0) : 
str : 		goto free_dlo_mask;
strstr : INIT : 		goto free_dlo_mask; : 
strstr : if : 		goto free_dlo_mask; : 
strstr : for : 		goto free_dlo_mask; : 
strstr : while : 		goto free_dlo_mask; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	if (cpupri_init(&rd->cpupri) != 0)
strstr : if : 	if (cpupri_init(&rd->cpupri) != 0) : 
strstr : for : 	if (cpupri_init(&rd->cpupri) != 0) : 
strstr : while : 	if (cpupri_init(&rd->cpupri) != 0) : 
str : 		goto free_rto_mask;
strstr : INIT : 		goto free_rto_mask; : 
strstr : if : 		goto free_rto_mask; : 
strstr : for : 		goto free_rto_mask; : 
strstr : while : 		goto free_rto_mask; : 
str : 	return 0;
strstr : INIT : 	return 0; : 
strstr : if : 	return 0; : 
strstr : for : 	return 0; : 
strstr : while : 	return 0; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : free_rto_mask:
strstr : if : free_rto_mask: : 
strstr : for : free_rto_mask: : 
strstr : while : free_rto_mask: : 
str : 	free_cpumask_var(rd->rto_mask);
strstr : INIT : 	free_cpumask_var(rd->rto_mask); : 
strstr : if : 	free_cpumask_var(rd->rto_mask); : 
strstr : for : 	free_cpumask_var(rd->rto_mask); : 
strstr : while : 	free_cpumask_var(rd->rto_mask); : 
str : free_dlo_mask:
strstr : INIT : free_dlo_mask: : 
strstr : if : free_dlo_mask: : 
strstr : for : free_dlo_mask: : 
strstr : while : free_dlo_mask: : 
str : 	free_cpumask_var(rd->dlo_mask);
strstr : INIT : 	free_cpumask_var(rd->dlo_mask); : 
strstr : if : 	free_cpumask_var(rd->dlo_mask); : 
strstr : for : 	free_cpumask_var(rd->dlo_mask); : 
strstr : while : 	free_cpumask_var(rd->dlo_mask); : 
str : free_online:
strstr : INIT : free_online: : 
strstr : if : free_online: : 
strstr : for : free_online: : 
strstr : while : free_online: : 
str : 	free_cpumask_var(rd->online);
strstr : INIT : 	free_cpumask_var(rd->online); : 
strstr : if : 	free_cpumask_var(rd->online); : 
strstr : for : 	free_cpumask_var(rd->online); : 
strstr : while : 	free_cpumask_var(rd->online); : 
str : free_span:
strstr : INIT : free_span: : 
strstr : if : free_span: : 
strstr : for : free_span: : 
strstr : while : free_span: : 
str : 	free_cpumask_var(rd->span);
strstr : INIT : 	free_cpumask_var(rd->span); : 
strstr : if : 	free_cpumask_var(rd->span); : 
strstr : for : 	free_cpumask_var(rd->span); : 
strstr : while : 	free_cpumask_var(rd->span); : 
str : out:
strstr : INIT : out: : 
strstr : if : out: : 
strstr : for : out: : 
strstr : while : out: : 
str : 	return -ENOMEM;
strstr : INIT : 	return -ENOMEM; : 
strstr : if : 	return -ENOMEM; : 
strstr : for : 	return -ENOMEM; : 
strstr : while : 	return -ENOMEM; : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : /*
strstr : if : /* : 
strstr : for : /* : 
strstr : while : /* : 
str :  * By default the system creates a single root-domain with all cpus as
strstr : INIT :  * By default the system creates a single root-domain with all cpus as : 
strstr : if :  * By default the system creates a single root-domain with all cpus as : 
strstr : for :  * By default the system creates a single root-domain with all cpus as : 
strstr : while :  * By default the system creates a single root-domain with all cpus as : 
str :  * members (mimicking the global state we have today).
strstr : INIT :  * members (mimicking the global state we have today). : 
strstr : if :  * members (mimicking the global state we have today). : 
strstr : for :  * members (mimicking the global state we have today). : 
strstr : while :  * members (mimicking the global state we have today). : 
str :  */
strstr : INIT :  */ : 
strstr : if :  */ : 
strstr : for :  */ : 
strstr : while :  */ : 
str : struct root_domain def_root_domain;
strstr : INIT : struct root_domain def_root_domain; : 
strstr : if : struct root_domain def_root_domain; : 
strstr : for : struct root_domain def_root_domain; : 
strstr : while : struct root_domain def_root_domain; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : static void init_defrootdomain(void)
strstr : if : static void init_defrootdomain(void) : 
strstr : for : static void init_defrootdomain(void) : 
strstr : while : static void init_defrootdomain(void) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	init_rootdomain(&def_root_domain);
strstr : INIT : 	init_rootdomain(&def_root_domain); : 
strstr : if : 	init_rootdomain(&def_root_domain); : 
strstr : for : 	init_rootdomain(&def_root_domain); : 
strstr : while : 	init_rootdomain(&def_root_domain); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	atomic_set(&def_root_domain.refcount, 1);
strstr : if : 	atomic_set(&def_root_domain.refcount, 1); : 
strstr : for : 	atomic_set(&def_root_domain.refcount, 1); : 
strstr : while : 	atomic_set(&def_root_domain.refcount, 1); : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : static struct root_domain *alloc_rootdomain(void)
strstr : if : static struct root_domain *alloc_rootdomain(void) : 
strstr : for : static struct root_domain *alloc_rootdomain(void) : 
strstr : while : static struct root_domain *alloc_rootdomain(void) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	struct root_domain *rd;
strstr : INIT : 	struct root_domain *rd; : 
strstr : if : 	struct root_domain *rd; : 
strstr : for : 	struct root_domain *rd; : 
strstr : while : 	struct root_domain *rd; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	rd = kmalloc(sizeof(*rd), GFP_KERNEL);
strstr : if : 	rd = kmalloc(sizeof(*rd), GFP_KERNEL); : 
strstr : for : 	rd = kmalloc(sizeof(*rd), GFP_KERNEL); : 
strstr : while : 	rd = kmalloc(sizeof(*rd), GFP_KERNEL); : 
str : 	if (!rd)
strstr : INIT : 	if (!rd) : 
strstr : if : 	if (!rd) : 
strstr : for : 	if (!rd) : 
strstr : while : 	if (!rd) : 
str : 		return NULL;
strstr : INIT : 		return NULL; : 
strstr : if : 		return NULL; : 
strstr : for : 		return NULL; : 
strstr : while : 		return NULL; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	if (init_rootdomain(rd) != 0) {
strstr : if : 	if (init_rootdomain(rd) != 0) { : 
strstr : for : 	if (init_rootdomain(rd) != 0) { : 
strstr : while : 	if (init_rootdomain(rd) != 0) { : 
str : 		kfree(rd);
strstr : INIT : 		kfree(rd); : 
strstr : if : 		kfree(rd); : 
strstr : for : 		kfree(rd); : 
strstr : while : 		kfree(rd); : 
str : 		return NULL;
strstr : INIT : 		return NULL; : 
strstr : if : 		return NULL; : 
strstr : for : 		return NULL; : 
strstr : while : 		return NULL; : 
str : 	}
strstr : INIT : 	} : 
strstr : if : 	} : 
strstr : for : 	} : 
strstr : while : 	} : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	return rd;
strstr : if : 	return rd; : 
strstr : for : 	return rd; : 
strstr : while : 	return rd; : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : static void free_sched_groups(struct sched_group *sg, int free_sgp)
strstr : if : static void free_sched_groups(struct sched_group *sg, int free_sgp) : 
strstr : for : static void free_sched_groups(struct sched_group *sg, int free_sgp) : 
strstr : while : static void free_sched_groups(struct sched_group *sg, int free_sgp) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	struct sched_group *tmp, *first;
strstr : INIT : 	struct sched_group *tmp, *first; : 
strstr : if : 	struct sched_group *tmp, *first; : 
strstr : for : 	struct sched_group *tmp, *first; : 
strstr : while : 	struct sched_group *tmp, *first; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	if (!sg)
strstr : if : 	if (!sg) : 
strstr : for : 	if (!sg) : 
strstr : while : 	if (!sg) : 
str : 		return;
strstr : INIT : 		return; : 
strstr : if : 		return; : 
strstr : for : 		return; : 
strstr : while : 		return; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	first = sg;
strstr : if : 	first = sg; : 
strstr : for : 	first = sg; : 
strstr : while : 	first = sg; : 
str : 	do {
strstr : INIT : 	do { : 
strstr : if : 	do { : 
strstr : for : 	do { : 
strstr : while : 	do { : 
str : 		tmp = sg->next;
strstr : INIT : 		tmp = sg->next; : 
strstr : if : 		tmp = sg->next; : 
strstr : for : 		tmp = sg->next; : 
strstr : while : 		tmp = sg->next; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 		if (free_sgp && atomic_dec_and_test(&sg->sgp->ref))
strstr : if : 		if (free_sgp && atomic_dec_and_test(&sg->sgp->ref)) : 
strstr : for : 		if (free_sgp && atomic_dec_and_test(&sg->sgp->ref)) : 
strstr : while : 		if (free_sgp && atomic_dec_and_test(&sg->sgp->ref)) : 
str : 			kfree(sg->sgp);
strstr : INIT : 			kfree(sg->sgp); : 
strstr : if : 			kfree(sg->sgp); : 
strstr : for : 			kfree(sg->sgp); : 
strstr : while : 			kfree(sg->sgp); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 		kfree(sg);
strstr : if : 		kfree(sg); : 
strstr : for : 		kfree(sg); : 
strstr : while : 		kfree(sg); : 
str : 		sg = tmp;
strstr : INIT : 		sg = tmp; : 
strstr : if : 		sg = tmp; : 
strstr : for : 		sg = tmp; : 
strstr : while : 		sg = tmp; : 
str : 	} while (sg != first);
strstr : INIT : 	} while (sg != first); : 
strstr : if : 	} while (sg != first); : 
strstr : for : 	} while (sg != first); : 
strstr : while : 	} while (sg != first); : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : static void free_sched_domain(struct rcu_head *rcu)
strstr : if : static void free_sched_domain(struct rcu_head *rcu) : 
strstr : for : static void free_sched_domain(struct rcu_head *rcu) : 
strstr : while : static void free_sched_domain(struct rcu_head *rcu) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	struct sched_domain *sd = container_of(rcu, struct sched_domain, rcu);
strstr : INIT : 	struct sched_domain *sd = container_of(rcu, struct sched_domain, rcu); : 
strstr : if : 	struct sched_domain *sd = container_of(rcu, struct sched_domain, rcu); : 
strstr : for : 	struct sched_domain *sd = container_of(rcu, struct sched_domain, rcu); : 
strstr : while : 	struct sched_domain *sd = container_of(rcu, struct sched_domain, rcu); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	/*
strstr : if : 	/* : 
strstr : for : 	/* : 
strstr : while : 	/* : 
str : 	 * If its an overlapping domain it has private groups, iterate and
strstr : INIT : 	 * If its an overlapping domain it has private groups, iterate and : 
strstr : if : 	 * If its an overlapping domain it has private groups, iterate and : 
strstr : for : 	 * If its an overlapping domain it has private groups, iterate and : 
strstr : while : 	 * If its an overlapping domain it has private groups, iterate and : 
str : 	 * nuke them all.
strstr : INIT : 	 * nuke them all. : 
strstr : if : 	 * nuke them all. : 
strstr : for : 	 * nuke them all. : 
strstr : while : 	 * nuke them all. : 
str : 	 */
strstr : INIT : 	 */ : 
strstr : if : 	 */ : 
strstr : for : 	 */ : 
strstr : while : 	 */ : 
str : 	if (sd->flags & SD_OVERLAP) {
strstr : INIT : 	if (sd->flags & SD_OVERLAP) { : 
strstr : if : 	if (sd->flags & SD_OVERLAP) { : 
strstr : for : 	if (sd->flags & SD_OVERLAP) { : 
strstr : while : 	if (sd->flags & SD_OVERLAP) { : 
str : 		free_sched_groups(sd->groups, 1);
strstr : INIT : 		free_sched_groups(sd->groups, 1); : 
strstr : if : 		free_sched_groups(sd->groups, 1); : 
strstr : for : 		free_sched_groups(sd->groups, 1); : 
strstr : while : 		free_sched_groups(sd->groups, 1); : 
str : 	} else if (atomic_dec_and_test(&sd->groups->ref)) {
strstr : INIT : 	} else if (atomic_dec_and_test(&sd->groups->ref)) { : 
strstr : if : 	} else if (atomic_dec_and_test(&sd->groups->ref)) { : 
strstr : for : 	} else if (atomic_dec_and_test(&sd->groups->ref)) { : 
strstr : while : 	} else if (atomic_dec_and_test(&sd->groups->ref)) { : 
str : 		kfree(sd->groups->sgp);
strstr : INIT : 		kfree(sd->groups->sgp); : 
strstr : if : 		kfree(sd->groups->sgp); : 
strstr : for : 		kfree(sd->groups->sgp); : 
strstr : while : 		kfree(sd->groups->sgp); : 
str : 		kfree(sd->groups);
strstr : INIT : 		kfree(sd->groups); : 
strstr : if : 		kfree(sd->groups); : 
strstr : for : 		kfree(sd->groups); : 
strstr : while : 		kfree(sd->groups); : 
str : 	}
strstr : INIT : 	} : 
strstr : if : 	} : 
strstr : for : 	} : 
strstr : while : 	} : 
str : 	kfree(sd);
strstr : INIT : 	kfree(sd); : 
strstr : if : 	kfree(sd); : 
strstr : for : 	kfree(sd); : 
strstr : while : 	kfree(sd); : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : static void destroy_sched_domain(struct sched_domain *sd, int cpu)
strstr : if : static void destroy_sched_domain(struct sched_domain *sd, int cpu) : 
strstr : for : static void destroy_sched_domain(struct sched_domain *sd, int cpu) : 
strstr : while : static void destroy_sched_domain(struct sched_domain *sd, int cpu) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	call_rcu(&sd->rcu, free_sched_domain);
strstr : INIT : 	call_rcu(&sd->rcu, free_sched_domain); : 
strstr : if : 	call_rcu(&sd->rcu, free_sched_domain); : 
strstr : for : 	call_rcu(&sd->rcu, free_sched_domain); : 
strstr : while : 	call_rcu(&sd->rcu, free_sched_domain); : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : static void destroy_sched_domains(struct sched_domain *sd, int cpu)
strstr : if : static void destroy_sched_domains(struct sched_domain *sd, int cpu) : 
strstr : for : static void destroy_sched_domains(struct sched_domain *sd, int cpu) : 
strstr : while : static void destroy_sched_domains(struct sched_domain *sd, int cpu) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	for (; sd; sd = sd->parent)
strstr : INIT : 	for (; sd; sd = sd->parent) : 
strstr : if : 	for (; sd; sd = sd->parent) : 
strstr : for : 	for (; sd; sd = sd->parent) : 
strstr : while : 	for (; sd; sd = sd->parent) : 
str : 		destroy_sched_domain(sd, cpu);
strstr : INIT : 		destroy_sched_domain(sd, cpu); : 
strstr : if : 		destroy_sched_domain(sd, cpu); : 
strstr : for : 		destroy_sched_domain(sd, cpu); : 
strstr : while : 		destroy_sched_domain(sd, cpu); : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : /*
strstr : if : /* : 
strstr : for : /* : 
strstr : while : /* : 
str :  * Keep a special pointer to the highest sched_domain that has
strstr : INIT :  * Keep a special pointer to the highest sched_domain that has : 
strstr : if :  * Keep a special pointer to the highest sched_domain that has : 
strstr : for :  * Keep a special pointer to the highest sched_domain that has : 
strstr : while :  * Keep a special pointer to the highest sched_domain that has : 
str :  * SD_SHARE_PKG_RESOURCE set (Last Level Cache Domain) for this
strstr : INIT :  * SD_SHARE_PKG_RESOURCE set (Last Level Cache Domain) for this : 
strstr : if :  * SD_SHARE_PKG_RESOURCE set (Last Level Cache Domain) for this : 
strstr : for :  * SD_SHARE_PKG_RESOURCE set (Last Level Cache Domain) for this : 
strstr : while :  * SD_SHARE_PKG_RESOURCE set (Last Level Cache Domain) for this : 
str :  * allows us to avoid some pointer chasing select_idle_sibling().
strstr : INIT :  * allows us to avoid some pointer chasing select_idle_sibling(). : 
strstr : if :  * allows us to avoid some pointer chasing select_idle_sibling(). : 
strstr : for :  * allows us to avoid some pointer chasing select_idle_sibling(). : 
strstr : while :  * allows us to avoid some pointer chasing select_idle_sibling(). : 
str :  *
strstr : INIT :  * : 
strstr : if :  * : 
strstr : for :  * : 
strstr : while :  * : 
str :  * Also keep a unique ID per domain (we use the first cpu number in
strstr : INIT :  * Also keep a unique ID per domain (we use the first cpu number in : 
strstr : if :  * Also keep a unique ID per domain (we use the first cpu number in : 
strstr : for :  * Also keep a unique ID per domain (we use the first cpu number in : 
strstr : while :  * Also keep a unique ID per domain (we use the first cpu number in : 
str :  * the cpumask of the domain), this allows us to quickly tell if
strstr : INIT :  * the cpumask of the domain), this allows us to quickly tell if : 
strstr : if :  * the cpumask of the domain), this allows us to quickly tell if : 
strstr : for :  * the cpumask of the domain), this allows us to quickly tell if : 
strstr : while :  * the cpumask of the domain), this allows us to quickly tell if : 
str :  * two cpus are in the same cache domain, see cpus_share_cache().
strstr : INIT :  * two cpus are in the same cache domain, see cpus_share_cache(). : 
strstr : if :  * two cpus are in the same cache domain, see cpus_share_cache(). : 
strstr : for :  * two cpus are in the same cache domain, see cpus_share_cache(). : 
strstr : while :  * two cpus are in the same cache domain, see cpus_share_cache(). : 
str :  */
strstr : INIT :  */ : 
strstr : if :  */ : 
strstr : for :  */ : 
strstr : while :  */ : 
str : DEFINE_PER_CPU(struct sched_domain *, sd_llc);
strstr : INIT : DEFINE_PER_CPU(struct sched_domain *, sd_llc); : 
strstr : if : DEFINE_PER_CPU(struct sched_domain *, sd_llc); : 
strstr : for : DEFINE_PER_CPU(struct sched_domain *, sd_llc); : 
strstr : while : DEFINE_PER_CPU(struct sched_domain *, sd_llc); : 
str : DEFINE_PER_CPU(int, sd_llc_size);
strstr : INIT : DEFINE_PER_CPU(int, sd_llc_size); : 
strstr : if : DEFINE_PER_CPU(int, sd_llc_size); : 
strstr : for : DEFINE_PER_CPU(int, sd_llc_size); : 
strstr : while : DEFINE_PER_CPU(int, sd_llc_size); : 
str : DEFINE_PER_CPU(int, sd_llc_id);
strstr : INIT : DEFINE_PER_CPU(int, sd_llc_id); : 
strstr : if : DEFINE_PER_CPU(int, sd_llc_id); : 
strstr : for : DEFINE_PER_CPU(int, sd_llc_id); : 
strstr : while : DEFINE_PER_CPU(int, sd_llc_id); : 
str : DEFINE_PER_CPU(struct sched_domain *, sd_numa);
strstr : INIT : DEFINE_PER_CPU(struct sched_domain *, sd_numa); : 
strstr : if : DEFINE_PER_CPU(struct sched_domain *, sd_numa); : 
strstr : for : DEFINE_PER_CPU(struct sched_domain *, sd_numa); : 
strstr : while : DEFINE_PER_CPU(struct sched_domain *, sd_numa); : 
str : DEFINE_PER_CPU(struct sched_domain *, sd_busy);
strstr : INIT : DEFINE_PER_CPU(struct sched_domain *, sd_busy); : 
strstr : if : DEFINE_PER_CPU(struct sched_domain *, sd_busy); : 
strstr : for : DEFINE_PER_CPU(struct sched_domain *, sd_busy); : 
strstr : while : DEFINE_PER_CPU(struct sched_domain *, sd_busy); : 
str : DEFINE_PER_CPU(struct sched_domain *, sd_asym);
strstr : INIT : DEFINE_PER_CPU(struct sched_domain *, sd_asym); : 
strstr : if : DEFINE_PER_CPU(struct sched_domain *, sd_asym); : 
strstr : for : DEFINE_PER_CPU(struct sched_domain *, sd_asym); : 
strstr : while : DEFINE_PER_CPU(struct sched_domain *, sd_asym); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : static void update_top_cache_domain(int cpu)
strstr : if : static void update_top_cache_domain(int cpu) : 
strstr : for : static void update_top_cache_domain(int cpu) : 
strstr : while : static void update_top_cache_domain(int cpu) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	struct sched_domain *sd;
strstr : INIT : 	struct sched_domain *sd; : 
strstr : if : 	struct sched_domain *sd; : 
strstr : for : 	struct sched_domain *sd; : 
strstr : while : 	struct sched_domain *sd; : 
str : 	struct sched_domain *busy_sd = NULL;
strstr : INIT : 	struct sched_domain *busy_sd = NULL; : 
strstr : if : 	struct sched_domain *busy_sd = NULL; : 
strstr : for : 	struct sched_domain *busy_sd = NULL; : 
strstr : while : 	struct sched_domain *busy_sd = NULL; : 
str : 	int id = cpu;
strstr : INIT : 	int id = cpu; : 
strstr : if : 	int id = cpu; : 
strstr : for : 	int id = cpu; : 
strstr : while : 	int id = cpu; : 
str : 	int size = 1;
strstr : INIT : 	int size = 1; : 
strstr : if : 	int size = 1; : 
strstr : for : 	int size = 1; : 
strstr : while : 	int size = 1; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	sd = highest_flag_domain(cpu, SD_SHARE_PKG_RESOURCES);
strstr : if : 	sd = highest_flag_domain(cpu, SD_SHARE_PKG_RESOURCES); : 
strstr : for : 	sd = highest_flag_domain(cpu, SD_SHARE_PKG_RESOURCES); : 
strstr : while : 	sd = highest_flag_domain(cpu, SD_SHARE_PKG_RESOURCES); : 
str : 	if (sd) {
strstr : INIT : 	if (sd) { : 
strstr : if : 	if (sd) { : 
strstr : for : 	if (sd) { : 
strstr : while : 	if (sd) { : 
str : 		id = cpumask_first(sched_domain_span(sd));
strstr : INIT : 		id = cpumask_first(sched_domain_span(sd)); : 
strstr : if : 		id = cpumask_first(sched_domain_span(sd)); : 
strstr : for : 		id = cpumask_first(sched_domain_span(sd)); : 
strstr : while : 		id = cpumask_first(sched_domain_span(sd)); : 
str : 		size = cpumask_weight(sched_domain_span(sd));
strstr : INIT : 		size = cpumask_weight(sched_domain_span(sd)); : 
strstr : if : 		size = cpumask_weight(sched_domain_span(sd)); : 
strstr : for : 		size = cpumask_weight(sched_domain_span(sd)); : 
strstr : while : 		size = cpumask_weight(sched_domain_span(sd)); : 
str : 		busy_sd = sd->parent; /* sd_busy */
strstr : INIT : 		busy_sd = sd->parent; /* sd_busy */ : 
strstr : if : 		busy_sd = sd->parent; /* sd_busy */ : 
strstr : for : 		busy_sd = sd->parent; /* sd_busy */ : 
strstr : while : 		busy_sd = sd->parent; /* sd_busy */ : 
str : 	}
strstr : INIT : 	} : 
strstr : if : 	} : 
strstr : for : 	} : 
strstr : while : 	} : 
str : 	rcu_assign_pointer(per_cpu(sd_busy, cpu), busy_sd);
strstr : INIT : 	rcu_assign_pointer(per_cpu(sd_busy, cpu), busy_sd); : 
strstr : if : 	rcu_assign_pointer(per_cpu(sd_busy, cpu), busy_sd); : 
strstr : for : 	rcu_assign_pointer(per_cpu(sd_busy, cpu), busy_sd); : 
strstr : while : 	rcu_assign_pointer(per_cpu(sd_busy, cpu), busy_sd); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	rcu_assign_pointer(per_cpu(sd_llc, cpu), sd);
strstr : if : 	rcu_assign_pointer(per_cpu(sd_llc, cpu), sd); : 
strstr : for : 	rcu_assign_pointer(per_cpu(sd_llc, cpu), sd); : 
strstr : while : 	rcu_assign_pointer(per_cpu(sd_llc, cpu), sd); : 
str : 	per_cpu(sd_llc_size, cpu) = size;
strstr : INIT : 	per_cpu(sd_llc_size, cpu) = size; : 
strstr : if : 	per_cpu(sd_llc_size, cpu) = size; : 
strstr : for : 	per_cpu(sd_llc_size, cpu) = size; : 
strstr : while : 	per_cpu(sd_llc_size, cpu) = size; : 
str : 	per_cpu(sd_llc_id, cpu) = id;
strstr : INIT : 	per_cpu(sd_llc_id, cpu) = id; : 
strstr : if : 	per_cpu(sd_llc_id, cpu) = id; : 
strstr : for : 	per_cpu(sd_llc_id, cpu) = id; : 
strstr : while : 	per_cpu(sd_llc_id, cpu) = id; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	sd = lowest_flag_domain(cpu, SD_NUMA);
strstr : if : 	sd = lowest_flag_domain(cpu, SD_NUMA); : 
strstr : for : 	sd = lowest_flag_domain(cpu, SD_NUMA); : 
strstr : while : 	sd = lowest_flag_domain(cpu, SD_NUMA); : 
str : 	rcu_assign_pointer(per_cpu(sd_numa, cpu), sd);
strstr : INIT : 	rcu_assign_pointer(per_cpu(sd_numa, cpu), sd); : 
strstr : if : 	rcu_assign_pointer(per_cpu(sd_numa, cpu), sd); : 
strstr : for : 	rcu_assign_pointer(per_cpu(sd_numa, cpu), sd); : 
strstr : while : 	rcu_assign_pointer(per_cpu(sd_numa, cpu), sd); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	sd = highest_flag_domain(cpu, SD_ASYM_PACKING);
strstr : if : 	sd = highest_flag_domain(cpu, SD_ASYM_PACKING); : 
strstr : for : 	sd = highest_flag_domain(cpu, SD_ASYM_PACKING); : 
strstr : while : 	sd = highest_flag_domain(cpu, SD_ASYM_PACKING); : 
str : 	rcu_assign_pointer(per_cpu(sd_asym, cpu), sd);
strstr : INIT : 	rcu_assign_pointer(per_cpu(sd_asym, cpu), sd); : 
strstr : if : 	rcu_assign_pointer(per_cpu(sd_asym, cpu), sd); : 
strstr : for : 	rcu_assign_pointer(per_cpu(sd_asym, cpu), sd); : 
strstr : while : 	rcu_assign_pointer(per_cpu(sd_asym, cpu), sd); : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : /*
strstr : if : /* : 
strstr : for : /* : 
strstr : while : /* : 
str :  * Attach the domain 'sd' to 'cpu' as its base domain. Callers must
strstr : INIT :  * Attach the domain 'sd' to 'cpu' as its base domain. Callers must : 
strstr : if :  * Attach the domain 'sd' to 'cpu' as its base domain. Callers must : 
strstr : for :  * Attach the domain 'sd' to 'cpu' as its base domain. Callers must : 
strstr : while :  * Attach the domain 'sd' to 'cpu' as its base domain. Callers must : 
str :  * hold the hotplug lock.
strstr : INIT :  * hold the hotplug lock. : 
strstr : if :  * hold the hotplug lock. : 
strstr : for :  * hold the hotplug lock. : 
strstr : while :  * hold the hotplug lock. : 
str :  */
strstr : INIT :  */ : 
strstr : if :  */ : 
strstr : for :  */ : 
strstr : while :  */ : 
str : static void
strstr : INIT : static void : 
strstr : if : static void : 
strstr : for : static void : 
strstr : while : static void : 
str : cpu_attach_domain(struct sched_domain *sd, struct root_domain *rd, int cpu)
strstr : INIT : cpu_attach_domain(struct sched_domain *sd, struct root_domain *rd, int cpu) : 
strstr : if : cpu_attach_domain(struct sched_domain *sd, struct root_domain *rd, int cpu) : 
strstr : for : cpu_attach_domain(struct sched_domain *sd, struct root_domain *rd, int cpu) : 
strstr : while : cpu_attach_domain(struct sched_domain *sd, struct root_domain *rd, int cpu) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	struct rq *rq = cpu_rq(cpu);
strstr : INIT : 	struct rq *rq = cpu_rq(cpu); : 
strstr : if : 	struct rq *rq = cpu_rq(cpu); : 
strstr : for : 	struct rq *rq = cpu_rq(cpu); : 
strstr : while : 	struct rq *rq = cpu_rq(cpu); : 
str : 	struct sched_domain *tmp;
strstr : INIT : 	struct sched_domain *tmp; : 
strstr : if : 	struct sched_domain *tmp; : 
strstr : for : 	struct sched_domain *tmp; : 
strstr : while : 	struct sched_domain *tmp; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	/* Remove the sched domains which do not contribute to scheduling. */
strstr : if : 	/* Remove the sched domains which do not contribute to scheduling. */ : 
strstr : for : 	/* Remove the sched domains which do not contribute to scheduling. */ : 
strstr : while : 	/* Remove the sched domains which do not contribute to scheduling. */ : 
str : 	for (tmp = sd; tmp; ) {
strstr : INIT : 	for (tmp = sd; tmp; ) { : 
strstr : if : 	for (tmp = sd; tmp; ) { : 
strstr : for : 	for (tmp = sd; tmp; ) { : 
strstr : while : 	for (tmp = sd; tmp; ) { : 
str : 		struct sched_domain *parent = tmp->parent;
strstr : INIT : 		struct sched_domain *parent = tmp->parent; : 
strstr : if : 		struct sched_domain *parent = tmp->parent; : 
strstr : for : 		struct sched_domain *parent = tmp->parent; : 
strstr : while : 		struct sched_domain *parent = tmp->parent; : 
str : 		if (!parent)
strstr : INIT : 		if (!parent) : 
strstr : if : 		if (!parent) : 
strstr : for : 		if (!parent) : 
strstr : while : 		if (!parent) : 
str : 			break;
strstr : INIT : 			break; : 
strstr : if : 			break; : 
strstr : for : 			break; : 
strstr : while : 			break; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 		if (sd_parent_degenerate(tmp, parent)) {
strstr : if : 		if (sd_parent_degenerate(tmp, parent)) { : 
strstr : for : 		if (sd_parent_degenerate(tmp, parent)) { : 
strstr : while : 		if (sd_parent_degenerate(tmp, parent)) { : 
str : 			tmp->parent = parent->parent;
strstr : INIT : 			tmp->parent = parent->parent; : 
strstr : if : 			tmp->parent = parent->parent; : 
strstr : for : 			tmp->parent = parent->parent; : 
strstr : while : 			tmp->parent = parent->parent; : 
str : 			if (parent->parent)
strstr : INIT : 			if (parent->parent) : 
strstr : if : 			if (parent->parent) : 
strstr : for : 			if (parent->parent) : 
strstr : while : 			if (parent->parent) : 
str : 				parent->parent->child = tmp;
strstr : INIT : 				parent->parent->child = tmp; : 
strstr : if : 				parent->parent->child = tmp; : 
strstr : for : 				parent->parent->child = tmp; : 
strstr : while : 				parent->parent->child = tmp; : 
str : 			/*
strstr : INIT : 			/* : 
strstr : if : 			/* : 
strstr : for : 			/* : 
strstr : while : 			/* : 
str : 			 * Transfer SD_PREFER_SIBLING down in case of a
strstr : INIT : 			 * Transfer SD_PREFER_SIBLING down in case of a : 
strstr : if : 			 * Transfer SD_PREFER_SIBLING down in case of a : 
strstr : for : 			 * Transfer SD_PREFER_SIBLING down in case of a : 
strstr : while : 			 * Transfer SD_PREFER_SIBLING down in case of a : 
str : 			 * degenerate parent; the spans match for this
strstr : INIT : 			 * degenerate parent; the spans match for this : 
strstr : if : 			 * degenerate parent; the spans match for this : 
strstr : for : 			 * degenerate parent; the spans match for this : 
strstr : while : 			 * degenerate parent; the spans match for this : 
str : 			 * so the property transfers.
strstr : INIT : 			 * so the property transfers. : 
strstr : if : 			 * so the property transfers. : 
strstr : for : 			 * so the property transfers. : 
strstr : while : 			 * so the property transfers. : 
str : 			 */
strstr : INIT : 			 */ : 
strstr : if : 			 */ : 
strstr : for : 			 */ : 
strstr : while : 			 */ : 
str : 			if (parent->flags & SD_PREFER_SIBLING)
strstr : INIT : 			if (parent->flags & SD_PREFER_SIBLING) : 
strstr : if : 			if (parent->flags & SD_PREFER_SIBLING) : 
strstr : for : 			if (parent->flags & SD_PREFER_SIBLING) : 
strstr : while : 			if (parent->flags & SD_PREFER_SIBLING) : 
str : 				tmp->flags |= SD_PREFER_SIBLING;
strstr : INIT : 				tmp->flags |= SD_PREFER_SIBLING; : 
strstr : if : 				tmp->flags |= SD_PREFER_SIBLING; : 
strstr : for : 				tmp->flags |= SD_PREFER_SIBLING; : 
strstr : while : 				tmp->flags |= SD_PREFER_SIBLING; : 
str : 			destroy_sched_domain(parent, cpu);
strstr : INIT : 			destroy_sched_domain(parent, cpu); : 
strstr : if : 			destroy_sched_domain(parent, cpu); : 
strstr : for : 			destroy_sched_domain(parent, cpu); : 
strstr : while : 			destroy_sched_domain(parent, cpu); : 
str : 		} else
strstr : INIT : 		} else : 
strstr : if : 		} else : 
strstr : for : 		} else : 
strstr : while : 		} else : 
str : 			tmp = tmp->parent;
strstr : INIT : 			tmp = tmp->parent; : 
strstr : if : 			tmp = tmp->parent; : 
strstr : for : 			tmp = tmp->parent; : 
strstr : while : 			tmp = tmp->parent; : 
str : 	}
strstr : INIT : 	} : 
strstr : if : 	} : 
strstr : for : 	} : 
strstr : while : 	} : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	if (sd && sd_degenerate(sd)) {
strstr : if : 	if (sd && sd_degenerate(sd)) { : 
strstr : for : 	if (sd && sd_degenerate(sd)) { : 
strstr : while : 	if (sd && sd_degenerate(sd)) { : 
str : 		tmp = sd;
strstr : INIT : 		tmp = sd; : 
strstr : if : 		tmp = sd; : 
strstr : for : 		tmp = sd; : 
strstr : while : 		tmp = sd; : 
str : 		sd = sd->parent;
strstr : INIT : 		sd = sd->parent; : 
strstr : if : 		sd = sd->parent; : 
strstr : for : 		sd = sd->parent; : 
strstr : while : 		sd = sd->parent; : 
str : 		destroy_sched_domain(tmp, cpu);
strstr : INIT : 		destroy_sched_domain(tmp, cpu); : 
strstr : if : 		destroy_sched_domain(tmp, cpu); : 
strstr : for : 		destroy_sched_domain(tmp, cpu); : 
strstr : while : 		destroy_sched_domain(tmp, cpu); : 
str : 		if (sd)
strstr : INIT : 		if (sd) : 
strstr : if : 		if (sd) : 
strstr : for : 		if (sd) : 
strstr : while : 		if (sd) : 
str : 			sd->child = NULL;
strstr : INIT : 			sd->child = NULL; : 
strstr : if : 			sd->child = NULL; : 
strstr : for : 			sd->child = NULL; : 
strstr : while : 			sd->child = NULL; : 
str : 	}
strstr : INIT : 	} : 
strstr : if : 	} : 
strstr : for : 	} : 
strstr : while : 	} : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	sched_domain_debug(sd, cpu);
strstr : if : 	sched_domain_debug(sd, cpu); : 
strstr : for : 	sched_domain_debug(sd, cpu); : 
strstr : while : 	sched_domain_debug(sd, cpu); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	rq_attach_root(rq, rd);
strstr : if : 	rq_attach_root(rq, rd); : 
strstr : for : 	rq_attach_root(rq, rd); : 
strstr : while : 	rq_attach_root(rq, rd); : 
str : 	tmp = rq->sd;
strstr : INIT : 	tmp = rq->sd; : 
strstr : if : 	tmp = rq->sd; : 
strstr : for : 	tmp = rq->sd; : 
strstr : while : 	tmp = rq->sd; : 
str : 	rcu_assign_pointer(rq->sd, sd);
strstr : INIT : 	rcu_assign_pointer(rq->sd, sd); : 
strstr : if : 	rcu_assign_pointer(rq->sd, sd); : 
strstr : for : 	rcu_assign_pointer(rq->sd, sd); : 
strstr : while : 	rcu_assign_pointer(rq->sd, sd); : 
str : 	destroy_sched_domains(tmp, cpu);
strstr : INIT : 	destroy_sched_domains(tmp, cpu); : 
strstr : if : 	destroy_sched_domains(tmp, cpu); : 
strstr : for : 	destroy_sched_domains(tmp, cpu); : 
strstr : while : 	destroy_sched_domains(tmp, cpu); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	update_top_cache_domain(cpu);
strstr : if : 	update_top_cache_domain(cpu); : 
strstr : for : 	update_top_cache_domain(cpu); : 
strstr : while : 	update_top_cache_domain(cpu); : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : /* cpus with isolated domains */
strstr : if : /* cpus with isolated domains */ : 
strstr : for : /* cpus with isolated domains */ : 
strstr : while : /* cpus with isolated domains */ : 
str : static cpumask_var_t cpu_isolated_map;
strstr : INIT : static cpumask_var_t cpu_isolated_map; : 
strstr : if : static cpumask_var_t cpu_isolated_map; : 
strstr : for : static cpumask_var_t cpu_isolated_map; : 
strstr : while : static cpumask_var_t cpu_isolated_map; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : /* Setup the mask of cpus configured for isolated domains */
strstr : if : /* Setup the mask of cpus configured for isolated domains */ : 
strstr : for : /* Setup the mask of cpus configured for isolated domains */ : 
strstr : while : /* Setup the mask of cpus configured for isolated domains */ : 
str : static int __init isolated_cpu_setup(char *str)
strstr : INIT : static int __init isolated_cpu_setup(char *str) : 
strstr : if : static int __init isolated_cpu_setup(char *str) : 
strstr : for : static int __init isolated_cpu_setup(char *str) : 
strstr : while : static int __init isolated_cpu_setup(char *str) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	alloc_bootmem_cpumask_var(&cpu_isolated_map);
strstr : INIT : 	alloc_bootmem_cpumask_var(&cpu_isolated_map); : 
strstr : if : 	alloc_bootmem_cpumask_var(&cpu_isolated_map); : 
strstr : for : 	alloc_bootmem_cpumask_var(&cpu_isolated_map); : 
strstr : while : 	alloc_bootmem_cpumask_var(&cpu_isolated_map); : 
str : 	cpulist_parse(str, cpu_isolated_map);
strstr : INIT : 	cpulist_parse(str, cpu_isolated_map); : 
strstr : if : 	cpulist_parse(str, cpu_isolated_map); : 
strstr : for : 	cpulist_parse(str, cpu_isolated_map); : 
strstr : while : 	cpulist_parse(str, cpu_isolated_map); : 
str : 	return 1;
strstr : INIT : 	return 1; : 
strstr : if : 	return 1; : 
strstr : for : 	return 1; : 
strstr : while : 	return 1; : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : __setup("isolcpus=", isolated_cpu_setup);
strstr : if : __setup("isolcpus=", isolated_cpu_setup); : 
strstr : for : __setup("isolcpus=", isolated_cpu_setup); : 
strstr : while : __setup("isolcpus=", isolated_cpu_setup); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : static const struct cpumask *cpu_cpu_mask(int cpu)
strstr : if : static const struct cpumask *cpu_cpu_mask(int cpu) : 
strstr : for : static const struct cpumask *cpu_cpu_mask(int cpu) : 
strstr : while : static const struct cpumask *cpu_cpu_mask(int cpu) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	return cpumask_of_node(cpu_to_node(cpu));
strstr : INIT : 	return cpumask_of_node(cpu_to_node(cpu)); : 
strstr : if : 	return cpumask_of_node(cpu_to_node(cpu)); : 
strstr : for : 	return cpumask_of_node(cpu_to_node(cpu)); : 
strstr : while : 	return cpumask_of_node(cpu_to_node(cpu)); : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : struct sd_data {
strstr : if : struct sd_data { : 
strstr : for : struct sd_data { : 
strstr : while : struct sd_data { : 
str : 	struct sched_domain **__percpu sd;
strstr : INIT : 	struct sched_domain **__percpu sd; : 
strstr : if : 	struct sched_domain **__percpu sd; : 
strstr : for : 	struct sched_domain **__percpu sd; : 
strstr : while : 	struct sched_domain **__percpu sd; : 
str : 	struct sched_group **__percpu sg;
strstr : INIT : 	struct sched_group **__percpu sg; : 
strstr : if : 	struct sched_group **__percpu sg; : 
strstr : for : 	struct sched_group **__percpu sg; : 
strstr : while : 	struct sched_group **__percpu sg; : 
str : 	struct sched_group_power **__percpu sgp;
strstr : INIT : 	struct sched_group_power **__percpu sgp; : 
strstr : if : 	struct sched_group_power **__percpu sgp; : 
strstr : for : 	struct sched_group_power **__percpu sgp; : 
strstr : while : 	struct sched_group_power **__percpu sgp; : 
str : };
strstr : INIT : }; : 
strstr : if : }; : 
strstr : for : }; : 
strstr : while : }; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : struct s_data {
strstr : if : struct s_data { : 
strstr : for : struct s_data { : 
strstr : while : struct s_data { : 
str : 	struct sched_domain ** __percpu sd;
strstr : INIT : 	struct sched_domain ** __percpu sd; : 
strstr : if : 	struct sched_domain ** __percpu sd; : 
strstr : for : 	struct sched_domain ** __percpu sd; : 
strstr : while : 	struct sched_domain ** __percpu sd; : 
str : 	struct root_domain	*rd;
strstr : INIT : 	struct root_domain	*rd; : 
strstr : if : 	struct root_domain	*rd; : 
strstr : for : 	struct root_domain	*rd; : 
strstr : while : 	struct root_domain	*rd; : 
str : };
strstr : INIT : }; : 
strstr : if : }; : 
strstr : for : }; : 
strstr : while : }; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : enum s_alloc {
strstr : if : enum s_alloc { : 
strstr : for : enum s_alloc { : 
strstr : while : enum s_alloc { : 
str : 	sa_rootdomain,
strstr : INIT : 	sa_rootdomain, : 
strstr : if : 	sa_rootdomain, : 
strstr : for : 	sa_rootdomain, : 
strstr : while : 	sa_rootdomain, : 
str : 	sa_sd,
strstr : INIT : 	sa_sd, : 
strstr : if : 	sa_sd, : 
strstr : for : 	sa_sd, : 
strstr : while : 	sa_sd, : 
str : 	sa_sd_storage,
strstr : INIT : 	sa_sd_storage, : 
strstr : if : 	sa_sd_storage, : 
strstr : for : 	sa_sd_storage, : 
strstr : while : 	sa_sd_storage, : 
str : 	sa_none,
strstr : INIT : 	sa_none, : 
strstr : if : 	sa_none, : 
strstr : for : 	sa_none, : 
strstr : while : 	sa_none, : 
str : };
strstr : INIT : }; : 
strstr : if : }; : 
strstr : for : }; : 
strstr : while : }; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : struct sched_domain_topology_level;
strstr : if : struct sched_domain_topology_level; : 
strstr : for : struct sched_domain_topology_level; : 
strstr : while : struct sched_domain_topology_level; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : typedef struct sched_domain *(*sched_domain_init_f)(struct sched_domain_topology_level *tl, int cpu);
strstr : if : typedef struct sched_domain *(*sched_domain_init_f)(struct sched_domain_topology_level *tl, int cpu); : 
strstr : for : typedef struct sched_domain *(*sched_domain_init_f)(struct sched_domain_topology_level *tl, int cpu); : 
strstr : while : typedef struct sched_domain *(*sched_domain_init_f)(struct sched_domain_topology_level *tl, int cpu); : 
str : typedef const struct cpumask *(*sched_domain_mask_f)(int cpu);
strstr : INIT : typedef const struct cpumask *(*sched_domain_mask_f)(int cpu); : 
strstr : if : typedef const struct cpumask *(*sched_domain_mask_f)(int cpu); : 
strstr : for : typedef const struct cpumask *(*sched_domain_mask_f)(int cpu); : 
strstr : while : typedef const struct cpumask *(*sched_domain_mask_f)(int cpu); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : #define SDTL_OVERLAP	0x01
strstr : if : #define SDTL_OVERLAP	0x01 : 
strstr : for : #define SDTL_OVERLAP	0x01 : 
strstr : while : #define SDTL_OVERLAP	0x01 : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : struct sched_domain_topology_level {
strstr : if : struct sched_domain_topology_level { : 
strstr : for : struct sched_domain_topology_level { : 
strstr : while : struct sched_domain_topology_level { : 
str : 	sched_domain_init_f init;
strstr : INIT : 	sched_domain_init_f init; : 
strstr : if : 	sched_domain_init_f init; : 
strstr : for : 	sched_domain_init_f init; : 
strstr : while : 	sched_domain_init_f init; : 
str : 	sched_domain_mask_f mask;
strstr : INIT : 	sched_domain_mask_f mask; : 
strstr : if : 	sched_domain_mask_f mask; : 
strstr : for : 	sched_domain_mask_f mask; : 
strstr : while : 	sched_domain_mask_f mask; : 
str : 	int		    flags;
strstr : INIT : 	int		    flags; : 
strstr : if : 	int		    flags; : 
strstr : for : 	int		    flags; : 
strstr : while : 	int		    flags; : 
str : 	int		    numa_level;
strstr : INIT : 	int		    numa_level; : 
strstr : if : 	int		    numa_level; : 
strstr : for : 	int		    numa_level; : 
strstr : while : 	int		    numa_level; : 
str : 	struct sd_data      data;
strstr : INIT : 	struct sd_data      data; : 
strstr : if : 	struct sd_data      data; : 
strstr : for : 	struct sd_data      data; : 
strstr : while : 	struct sd_data      data; : 
str : };
strstr : INIT : }; : 
strstr : if : }; : 
strstr : for : }; : 
strstr : while : }; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : /*
strstr : if : /* : 
strstr : for : /* : 
strstr : while : /* : 
str :  * Build an iteration mask that can exclude certain CPUs from the upwards
strstr : INIT :  * Build an iteration mask that can exclude certain CPUs from the upwards : 
strstr : if :  * Build an iteration mask that can exclude certain CPUs from the upwards : 
strstr : for :  * Build an iteration mask that can exclude certain CPUs from the upwards : 
strstr : while :  * Build an iteration mask that can exclude certain CPUs from the upwards : 
str :  * domain traversal.
strstr : INIT :  * domain traversal. : 
strstr : if :  * domain traversal. : 
strstr : for :  * domain traversal. : 
strstr : while :  * domain traversal. : 
str :  *
strstr : INIT :  * : 
strstr : if :  * : 
strstr : for :  * : 
strstr : while :  * : 
str :  * Asymmetric node setups can result in situations where the domain tree is of
strstr : INIT :  * Asymmetric node setups can result in situations where the domain tree is of : 
strstr : if :  * Asymmetric node setups can result in situations where the domain tree is of : 
strstr : for :  * Asymmetric node setups can result in situations where the domain tree is of : 
strstr : while :  * Asymmetric node setups can result in situations where the domain tree is of : 
str :  * unequal depth, make sure to skip domains that already cover the entire
strstr : INIT :  * unequal depth, make sure to skip domains that already cover the entire : 
strstr : if :  * unequal depth, make sure to skip domains that already cover the entire : 
strstr : for :  * unequal depth, make sure to skip domains that already cover the entire : 
strstr : while :  * unequal depth, make sure to skip domains that already cover the entire : 
str :  * range.
strstr : INIT :  * range. : 
strstr : if :  * range. : 
strstr : for :  * range. : 
strstr : while :  * range. : 
str :  *
strstr : INIT :  * : 
strstr : if :  * : 
strstr : for :  * : 
strstr : while :  * : 
str :  * In that case build_sched_domains() will have terminated the iteration early
strstr : INIT :  * In that case build_sched_domains() will have terminated the iteration early : 
strstr : if :  * In that case build_sched_domains() will have terminated the iteration early : 
strstr : for :  * In that case build_sched_domains() will have terminated the iteration early : 
strstr : while :  * In that case build_sched_domains() will have terminated the iteration early : 
str :  * and our sibling sd spans will be empty. Domains should always include the
strstr : INIT :  * and our sibling sd spans will be empty. Domains should always include the : 
strstr : if :  * and our sibling sd spans will be empty. Domains should always include the : 
strstr : for :  * and our sibling sd spans will be empty. Domains should always include the : 
strstr : while :  * and our sibling sd spans will be empty. Domains should always include the : 
str :  * cpu they're built on, so check that.
strstr : INIT :  * cpu they're built on, so check that. : 
strstr : if :  * cpu they're built on, so check that. : 
strstr : for :  * cpu they're built on, so check that. : 
strstr : while :  * cpu they're built on, so check that. : 
str :  *
strstr : INIT :  * : 
strstr : if :  * : 
strstr : for :  * : 
strstr : while :  * : 
str :  */
strstr : INIT :  */ : 
strstr : if :  */ : 
strstr : for :  */ : 
strstr : while :  */ : 
str : static void build_group_mask(struct sched_domain *sd, struct sched_group *sg)
strstr : INIT : static void build_group_mask(struct sched_domain *sd, struct sched_group *sg) : 
strstr : if : static void build_group_mask(struct sched_domain *sd, struct sched_group *sg) : 
strstr : for : static void build_group_mask(struct sched_domain *sd, struct sched_group *sg) : 
strstr : while : static void build_group_mask(struct sched_domain *sd, struct sched_group *sg) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	const struct cpumask *span = sched_domain_span(sd);
strstr : INIT : 	const struct cpumask *span = sched_domain_span(sd); : 
strstr : if : 	const struct cpumask *span = sched_domain_span(sd); : 
strstr : for : 	const struct cpumask *span = sched_domain_span(sd); : 
strstr : while : 	const struct cpumask *span = sched_domain_span(sd); : 
str : 	struct sd_data *sdd = sd->private;
strstr : INIT : 	struct sd_data *sdd = sd->private; : 
strstr : if : 	struct sd_data *sdd = sd->private; : 
strstr : for : 	struct sd_data *sdd = sd->private; : 
strstr : while : 	struct sd_data *sdd = sd->private; : 
str : 	struct sched_domain *sibling;
strstr : INIT : 	struct sched_domain *sibling; : 
strstr : if : 	struct sched_domain *sibling; : 
strstr : for : 	struct sched_domain *sibling; : 
strstr : while : 	struct sched_domain *sibling; : 
str : 	int i;
strstr : INIT : 	int i; : 
strstr : if : 	int i; : 
strstr : for : 	int i; : 
strstr : while : 	int i; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	for_each_cpu(i, span) {
strstr : if : 	for_each_cpu(i, span) { : 
strstr : for : 	for_each_cpu(i, span) { : 
strstr : while : 	for_each_cpu(i, span) { : 
str : 		sibling = *per_cpu_ptr(sdd->sd, i);
strstr : INIT : 		sibling = *per_cpu_ptr(sdd->sd, i); : 
strstr : if : 		sibling = *per_cpu_ptr(sdd->sd, i); : 
strstr : for : 		sibling = *per_cpu_ptr(sdd->sd, i); : 
strstr : while : 		sibling = *per_cpu_ptr(sdd->sd, i); : 
str : 		if (!cpumask_test_cpu(i, sched_domain_span(sibling)))
strstr : INIT : 		if (!cpumask_test_cpu(i, sched_domain_span(sibling))) : 
strstr : if : 		if (!cpumask_test_cpu(i, sched_domain_span(sibling))) : 
strstr : for : 		if (!cpumask_test_cpu(i, sched_domain_span(sibling))) : 
strstr : while : 		if (!cpumask_test_cpu(i, sched_domain_span(sibling))) : 
str : 			continue;
strstr : INIT : 			continue; : 
strstr : if : 			continue; : 
strstr : for : 			continue; : 
strstr : while : 			continue; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 		cpumask_set_cpu(i, sched_group_mask(sg));
strstr : if : 		cpumask_set_cpu(i, sched_group_mask(sg)); : 
strstr : for : 		cpumask_set_cpu(i, sched_group_mask(sg)); : 
strstr : while : 		cpumask_set_cpu(i, sched_group_mask(sg)); : 
str : 	}
strstr : INIT : 	} : 
strstr : if : 	} : 
strstr : for : 	} : 
strstr : while : 	} : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : /*
strstr : if : /* : 
strstr : for : /* : 
strstr : while : /* : 
str :  * Return the canonical balance cpu for this group, this is the first cpu
strstr : INIT :  * Return the canonical balance cpu for this group, this is the first cpu : 
strstr : if :  * Return the canonical balance cpu for this group, this is the first cpu : 
strstr : for :  * Return the canonical balance cpu for this group, this is the first cpu : 
strstr : while :  * Return the canonical balance cpu for this group, this is the first cpu : 
str :  * of this group that's also in the iteration mask.
strstr : INIT :  * of this group that's also in the iteration mask. : 
strstr : if :  * of this group that's also in the iteration mask. : 
strstr : for :  * of this group that's also in the iteration mask. : 
strstr : while :  * of this group that's also in the iteration mask. : 
str :  */
strstr : INIT :  */ : 
strstr : if :  */ : 
strstr : for :  */ : 
strstr : while :  */ : 
str : int group_balance_cpu(struct sched_group *sg)
strstr : INIT : int group_balance_cpu(struct sched_group *sg) : 
strstr : if : int group_balance_cpu(struct sched_group *sg) : 
strstr : for : int group_balance_cpu(struct sched_group *sg) : 
strstr : while : int group_balance_cpu(struct sched_group *sg) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	return cpumask_first_and(sched_group_cpus(sg), sched_group_mask(sg));
strstr : INIT : 	return cpumask_first_and(sched_group_cpus(sg), sched_group_mask(sg)); : 
strstr : if : 	return cpumask_first_and(sched_group_cpus(sg), sched_group_mask(sg)); : 
strstr : for : 	return cpumask_first_and(sched_group_cpus(sg), sched_group_mask(sg)); : 
strstr : while : 	return cpumask_first_and(sched_group_cpus(sg), sched_group_mask(sg)); : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : static int
strstr : if : static int : 
strstr : for : static int : 
strstr : while : static int : 
str : build_overlap_sched_groups(struct sched_domain *sd, int cpu)
strstr : INIT : build_overlap_sched_groups(struct sched_domain *sd, int cpu) : 
strstr : if : build_overlap_sched_groups(struct sched_domain *sd, int cpu) : 
strstr : for : build_overlap_sched_groups(struct sched_domain *sd, int cpu) : 
strstr : while : build_overlap_sched_groups(struct sched_domain *sd, int cpu) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	struct sched_group *first = NULL, *last = NULL, *groups = NULL, *sg;
strstr : INIT : 	struct sched_group *first = NULL, *last = NULL, *groups = NULL, *sg; : 
strstr : if : 	struct sched_group *first = NULL, *last = NULL, *groups = NULL, *sg; : 
strstr : for : 	struct sched_group *first = NULL, *last = NULL, *groups = NULL, *sg; : 
strstr : while : 	struct sched_group *first = NULL, *last = NULL, *groups = NULL, *sg; : 
str : 	const struct cpumask *span = sched_domain_span(sd);
strstr : INIT : 	const struct cpumask *span = sched_domain_span(sd); : 
strstr : if : 	const struct cpumask *span = sched_domain_span(sd); : 
strstr : for : 	const struct cpumask *span = sched_domain_span(sd); : 
strstr : while : 	const struct cpumask *span = sched_domain_span(sd); : 
str : 	struct cpumask *covered = sched_domains_tmpmask;
strstr : INIT : 	struct cpumask *covered = sched_domains_tmpmask; : 
strstr : if : 	struct cpumask *covered = sched_domains_tmpmask; : 
strstr : for : 	struct cpumask *covered = sched_domains_tmpmask; : 
strstr : while : 	struct cpumask *covered = sched_domains_tmpmask; : 
str : 	struct sd_data *sdd = sd->private;
strstr : INIT : 	struct sd_data *sdd = sd->private; : 
strstr : if : 	struct sd_data *sdd = sd->private; : 
strstr : for : 	struct sd_data *sdd = sd->private; : 
strstr : while : 	struct sd_data *sdd = sd->private; : 
str : 	struct sched_domain *child;
strstr : INIT : 	struct sched_domain *child; : 
strstr : if : 	struct sched_domain *child; : 
strstr : for : 	struct sched_domain *child; : 
strstr : while : 	struct sched_domain *child; : 
str : 	int i;
strstr : INIT : 	int i; : 
strstr : if : 	int i; : 
strstr : for : 	int i; : 
strstr : while : 	int i; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	cpumask_clear(covered);
strstr : if : 	cpumask_clear(covered); : 
strstr : for : 	cpumask_clear(covered); : 
strstr : while : 	cpumask_clear(covered); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	for_each_cpu(i, span) {
strstr : if : 	for_each_cpu(i, span) { : 
strstr : for : 	for_each_cpu(i, span) { : 
strstr : while : 	for_each_cpu(i, span) { : 
str : 		struct cpumask *sg_span;
strstr : INIT : 		struct cpumask *sg_span; : 
strstr : if : 		struct cpumask *sg_span; : 
strstr : for : 		struct cpumask *sg_span; : 
strstr : while : 		struct cpumask *sg_span; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 		if (cpumask_test_cpu(i, covered))
strstr : if : 		if (cpumask_test_cpu(i, covered)) : 
strstr : for : 		if (cpumask_test_cpu(i, covered)) : 
strstr : while : 		if (cpumask_test_cpu(i, covered)) : 
str : 			continue;
strstr : INIT : 			continue; : 
strstr : if : 			continue; : 
strstr : for : 			continue; : 
strstr : while : 			continue; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 		child = *per_cpu_ptr(sdd->sd, i);
strstr : if : 		child = *per_cpu_ptr(sdd->sd, i); : 
strstr : for : 		child = *per_cpu_ptr(sdd->sd, i); : 
strstr : while : 		child = *per_cpu_ptr(sdd->sd, i); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 		/* See the comment near build_group_mask(). */
strstr : if : 		/* See the comment near build_group_mask(). */ : 
strstr : for : 		/* See the comment near build_group_mask(). */ : 
strstr : while : 		/* See the comment near build_group_mask(). */ : 
str : 		if (!cpumask_test_cpu(i, sched_domain_span(child)))
strstr : INIT : 		if (!cpumask_test_cpu(i, sched_domain_span(child))) : 
strstr : if : 		if (!cpumask_test_cpu(i, sched_domain_span(child))) : 
strstr : for : 		if (!cpumask_test_cpu(i, sched_domain_span(child))) : 
strstr : while : 		if (!cpumask_test_cpu(i, sched_domain_span(child))) : 
str : 			continue;
strstr : INIT : 			continue; : 
strstr : if : 			continue; : 
strstr : for : 			continue; : 
strstr : while : 			continue; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 		sg = kzalloc_node(sizeof(struct sched_group) + cpumask_size(),
strstr : if : 		sg = kzalloc_node(sizeof(struct sched_group) + cpumask_size(), : 
strstr : for : 		sg = kzalloc_node(sizeof(struct sched_group) + cpumask_size(), : 
strstr : while : 		sg = kzalloc_node(sizeof(struct sched_group) + cpumask_size(), : 
str : 				GFP_KERNEL, cpu_to_node(cpu));
strstr : INIT : 				GFP_KERNEL, cpu_to_node(cpu)); : 
strstr : if : 				GFP_KERNEL, cpu_to_node(cpu)); : 
strstr : for : 				GFP_KERNEL, cpu_to_node(cpu)); : 
strstr : while : 				GFP_KERNEL, cpu_to_node(cpu)); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 		if (!sg)
strstr : if : 		if (!sg) : 
strstr : for : 		if (!sg) : 
strstr : while : 		if (!sg) : 
str : 			goto fail;
strstr : INIT : 			goto fail; : 
strstr : if : 			goto fail; : 
strstr : for : 			goto fail; : 
strstr : while : 			goto fail; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 		sg_span = sched_group_cpus(sg);
strstr : if : 		sg_span = sched_group_cpus(sg); : 
strstr : for : 		sg_span = sched_group_cpus(sg); : 
strstr : while : 		sg_span = sched_group_cpus(sg); : 
str : 		if (child->child) {
strstr : INIT : 		if (child->child) { : 
strstr : if : 		if (child->child) { : 
strstr : for : 		if (child->child) { : 
strstr : while : 		if (child->child) { : 
str : 			child = child->child;
strstr : INIT : 			child = child->child; : 
strstr : if : 			child = child->child; : 
strstr : for : 			child = child->child; : 
strstr : while : 			child = child->child; : 
str : 			cpumask_copy(sg_span, sched_domain_span(child));
strstr : INIT : 			cpumask_copy(sg_span, sched_domain_span(child)); : 
strstr : if : 			cpumask_copy(sg_span, sched_domain_span(child)); : 
strstr : for : 			cpumask_copy(sg_span, sched_domain_span(child)); : 
strstr : while : 			cpumask_copy(sg_span, sched_domain_span(child)); : 
str : 		} else
strstr : INIT : 		} else : 
strstr : if : 		} else : 
strstr : for : 		} else : 
strstr : while : 		} else : 
str : 			cpumask_set_cpu(i, sg_span);
strstr : INIT : 			cpumask_set_cpu(i, sg_span); : 
strstr : if : 			cpumask_set_cpu(i, sg_span); : 
strstr : for : 			cpumask_set_cpu(i, sg_span); : 
strstr : while : 			cpumask_set_cpu(i, sg_span); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 		cpumask_or(covered, covered, sg_span);
strstr : if : 		cpumask_or(covered, covered, sg_span); : 
strstr : for : 		cpumask_or(covered, covered, sg_span); : 
strstr : while : 		cpumask_or(covered, covered, sg_span); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 		sg->sgp = *per_cpu_ptr(sdd->sgp, i);
strstr : if : 		sg->sgp = *per_cpu_ptr(sdd->sgp, i); : 
strstr : for : 		sg->sgp = *per_cpu_ptr(sdd->sgp, i); : 
strstr : while : 		sg->sgp = *per_cpu_ptr(sdd->sgp, i); : 
str : 		if (atomic_inc_return(&sg->sgp->ref) == 1)
strstr : INIT : 		if (atomic_inc_return(&sg->sgp->ref) == 1) : 
strstr : if : 		if (atomic_inc_return(&sg->sgp->ref) == 1) : 
strstr : for : 		if (atomic_inc_return(&sg->sgp->ref) == 1) : 
strstr : while : 		if (atomic_inc_return(&sg->sgp->ref) == 1) : 
str : 			build_group_mask(sd, sg);
strstr : INIT : 			build_group_mask(sd, sg); : 
strstr : if : 			build_group_mask(sd, sg); : 
strstr : for : 			build_group_mask(sd, sg); : 
strstr : while : 			build_group_mask(sd, sg); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 		/*
strstr : if : 		/* : 
strstr : for : 		/* : 
strstr : while : 		/* : 
str : 		 * Initialize sgp->power such that even if we mess up the
strstr : INIT : 		 * Initialize sgp->power such that even if we mess up the : 
strstr : if : 		 * Initialize sgp->power such that even if we mess up the : 
strstr : for : 		 * Initialize sgp->power such that even if we mess up the : 
strstr : while : 		 * Initialize sgp->power such that even if we mess up the : 
str : 		 * domains and no possible iteration will get us here, we won't
strstr : INIT : 		 * domains and no possible iteration will get us here, we won't : 
strstr : if : 		 * domains and no possible iteration will get us here, we won't : 
strstr : for : 		 * domains and no possible iteration will get us here, we won't : 
strstr : while : 		 * domains and no possible iteration will get us here, we won't : 
str : 		 * die on a /0 trap.
strstr : INIT : 		 * die on a /0 trap. : 
strstr : if : 		 * die on a /0 trap. : 
strstr : for : 		 * die on a /0 trap. : 
strstr : while : 		 * die on a /0 trap. : 
str : 		 */
strstr : INIT : 		 */ : 
strstr : if : 		 */ : 
strstr : for : 		 */ : 
strstr : while : 		 */ : 
str : 		sg->sgp->power = SCHED_POWER_SCALE * cpumask_weight(sg_span);
strstr : INIT : 		sg->sgp->power = SCHED_POWER_SCALE * cpumask_weight(sg_span); : 
strstr : if : 		sg->sgp->power = SCHED_POWER_SCALE * cpumask_weight(sg_span); : 
strstr : for : 		sg->sgp->power = SCHED_POWER_SCALE * cpumask_weight(sg_span); : 
strstr : while : 		sg->sgp->power = SCHED_POWER_SCALE * cpumask_weight(sg_span); : 
str : 		sg->sgp->power_orig = sg->sgp->power;
strstr : INIT : 		sg->sgp->power_orig = sg->sgp->power; : 
strstr : if : 		sg->sgp->power_orig = sg->sgp->power; : 
strstr : for : 		sg->sgp->power_orig = sg->sgp->power; : 
strstr : while : 		sg->sgp->power_orig = sg->sgp->power; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 		/*
strstr : if : 		/* : 
strstr : for : 		/* : 
strstr : while : 		/* : 
str : 		 * Make sure the first group of this domain contains the
strstr : INIT : 		 * Make sure the first group of this domain contains the : 
strstr : if : 		 * Make sure the first group of this domain contains the : 
strstr : for : 		 * Make sure the first group of this domain contains the : 
strstr : while : 		 * Make sure the first group of this domain contains the : 
str : 		 * canonical balance cpu. Otherwise the sched_domain iteration
strstr : INIT : 		 * canonical balance cpu. Otherwise the sched_domain iteration : 
strstr : if : 		 * canonical balance cpu. Otherwise the sched_domain iteration : 
strstr : for : 		 * canonical balance cpu. Otherwise the sched_domain iteration : 
strstr : while : 		 * canonical balance cpu. Otherwise the sched_domain iteration : 
str : 		 * breaks. See update_sg_lb_stats().
strstr : INIT : 		 * breaks. See update_sg_lb_stats(). : 
strstr : if : 		 * breaks. See update_sg_lb_stats(). : 
strstr : for : 		 * breaks. See update_sg_lb_stats(). : 
strstr : while : 		 * breaks. See update_sg_lb_stats(). : 
str : 		 */
strstr : INIT : 		 */ : 
strstr : if : 		 */ : 
strstr : for : 		 */ : 
strstr : while : 		 */ : 
str : 		if ((!groups && cpumask_test_cpu(cpu, sg_span)) ||
strstr : INIT : 		if ((!groups && cpumask_test_cpu(cpu, sg_span)) || : 
strstr : if : 		if ((!groups && cpumask_test_cpu(cpu, sg_span)) || : 
strstr : for : 		if ((!groups && cpumask_test_cpu(cpu, sg_span)) || : 
strstr : while : 		if ((!groups && cpumask_test_cpu(cpu, sg_span)) || : 
str : 		    group_balance_cpu(sg) == cpu)
strstr : INIT : 		    group_balance_cpu(sg) == cpu) : 
strstr : if : 		    group_balance_cpu(sg) == cpu) : 
strstr : for : 		    group_balance_cpu(sg) == cpu) : 
strstr : while : 		    group_balance_cpu(sg) == cpu) : 
str : 			groups = sg;
strstr : INIT : 			groups = sg; : 
strstr : if : 			groups = sg; : 
strstr : for : 			groups = sg; : 
strstr : while : 			groups = sg; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 		if (!first)
strstr : if : 		if (!first) : 
strstr : for : 		if (!first) : 
strstr : while : 		if (!first) : 
str : 			first = sg;
strstr : INIT : 			first = sg; : 
strstr : if : 			first = sg; : 
strstr : for : 			first = sg; : 
strstr : while : 			first = sg; : 
str : 		if (last)
strstr : INIT : 		if (last) : 
strstr : if : 		if (last) : 
strstr : for : 		if (last) : 
strstr : while : 		if (last) : 
str : 			last->next = sg;
strstr : INIT : 			last->next = sg; : 
strstr : if : 			last->next = sg; : 
strstr : for : 			last->next = sg; : 
strstr : while : 			last->next = sg; : 
str : 		last = sg;
strstr : INIT : 		last = sg; : 
strstr : if : 		last = sg; : 
strstr : for : 		last = sg; : 
strstr : while : 		last = sg; : 
str : 		last->next = first;
strstr : INIT : 		last->next = first; : 
strstr : if : 		last->next = first; : 
strstr : for : 		last->next = first; : 
strstr : while : 		last->next = first; : 
str : 	}
strstr : INIT : 	} : 
strstr : if : 	} : 
strstr : for : 	} : 
strstr : while : 	} : 
str : 	sd->groups = groups;
strstr : INIT : 	sd->groups = groups; : 
strstr : if : 	sd->groups = groups; : 
strstr : for : 	sd->groups = groups; : 
strstr : while : 	sd->groups = groups; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	return 0;
strstr : if : 	return 0; : 
strstr : for : 	return 0; : 
strstr : while : 	return 0; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : fail:
strstr : if : fail: : 
strstr : for : fail: : 
strstr : while : fail: : 
str : 	free_sched_groups(first, 0);
strstr : INIT : 	free_sched_groups(first, 0); : 
strstr : if : 	free_sched_groups(first, 0); : 
strstr : for : 	free_sched_groups(first, 0); : 
strstr : while : 	free_sched_groups(first, 0); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	return -ENOMEM;
strstr : if : 	return -ENOMEM; : 
strstr : for : 	return -ENOMEM; : 
strstr : while : 	return -ENOMEM; : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : static int get_group(int cpu, struct sd_data *sdd, struct sched_group **sg)
strstr : if : static int get_group(int cpu, struct sd_data *sdd, struct sched_group **sg) : 
strstr : for : static int get_group(int cpu, struct sd_data *sdd, struct sched_group **sg) : 
strstr : while : static int get_group(int cpu, struct sd_data *sdd, struct sched_group **sg) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	struct sched_domain *sd = *per_cpu_ptr(sdd->sd, cpu);
strstr : INIT : 	struct sched_domain *sd = *per_cpu_ptr(sdd->sd, cpu); : 
strstr : if : 	struct sched_domain *sd = *per_cpu_ptr(sdd->sd, cpu); : 
strstr : for : 	struct sched_domain *sd = *per_cpu_ptr(sdd->sd, cpu); : 
strstr : while : 	struct sched_domain *sd = *per_cpu_ptr(sdd->sd, cpu); : 
str : 	struct sched_domain *child = sd->child;
strstr : INIT : 	struct sched_domain *child = sd->child; : 
strstr : if : 	struct sched_domain *child = sd->child; : 
strstr : for : 	struct sched_domain *child = sd->child; : 
strstr : while : 	struct sched_domain *child = sd->child; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	if (child)
strstr : if : 	if (child) : 
strstr : for : 	if (child) : 
strstr : while : 	if (child) : 
str : 		cpu = cpumask_first(sched_domain_span(child));
strstr : INIT : 		cpu = cpumask_first(sched_domain_span(child)); : 
strstr : if : 		cpu = cpumask_first(sched_domain_span(child)); : 
strstr : for : 		cpu = cpumask_first(sched_domain_span(child)); : 
strstr : while : 		cpu = cpumask_first(sched_domain_span(child)); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	if (sg) {
strstr : if : 	if (sg) { : 
strstr : for : 	if (sg) { : 
strstr : while : 	if (sg) { : 
str : 		*sg = *per_cpu_ptr(sdd->sg, cpu);
strstr : INIT : 		*sg = *per_cpu_ptr(sdd->sg, cpu); : 
strstr : if : 		*sg = *per_cpu_ptr(sdd->sg, cpu); : 
strstr : for : 		*sg = *per_cpu_ptr(sdd->sg, cpu); : 
strstr : while : 		*sg = *per_cpu_ptr(sdd->sg, cpu); : 
str : 		(*sg)->sgp = *per_cpu_ptr(sdd->sgp, cpu);
strstr : INIT : 		(*sg)->sgp = *per_cpu_ptr(sdd->sgp, cpu); : 
strstr : if : 		(*sg)->sgp = *per_cpu_ptr(sdd->sgp, cpu); : 
strstr : for : 		(*sg)->sgp = *per_cpu_ptr(sdd->sgp, cpu); : 
strstr : while : 		(*sg)->sgp = *per_cpu_ptr(sdd->sgp, cpu); : 
str : 		atomic_set(&(*sg)->sgp->ref, 1); /* for claim_allocations */
strstr : INIT : 		atomic_set(&(*sg)->sgp->ref, 1); /* for claim_allocations */ : 
strstr : if : 		atomic_set(&(*sg)->sgp->ref, 1); /* for claim_allocations */ : 
strstr : for : 		atomic_set(&(*sg)->sgp->ref, 1); /* for claim_allocations */ : 
strstr : while : 		atomic_set(&(*sg)->sgp->ref, 1); /* for claim_allocations */ : 
str : 	}
strstr : INIT : 	} : 
strstr : if : 	} : 
strstr : for : 	} : 
strstr : while : 	} : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	return cpu;
strstr : if : 	return cpu; : 
strstr : for : 	return cpu; : 
strstr : while : 	return cpu; : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : /*
strstr : if : /* : 
strstr : for : /* : 
strstr : while : /* : 
str :  * build_sched_groups will build a circular linked list of the groups
strstr : INIT :  * build_sched_groups will build a circular linked list of the groups : 
strstr : if :  * build_sched_groups will build a circular linked list of the groups : 
strstr : for :  * build_sched_groups will build a circular linked list of the groups : 
strstr : while :  * build_sched_groups will build a circular linked list of the groups : 
str :  * covered by the given span, and will set each group's ->cpumask correctly,
strstr : INIT :  * covered by the given span, and will set each group's ->cpumask correctly, : 
strstr : if :  * covered by the given span, and will set each group's ->cpumask correctly, : 
strstr : for :  * covered by the given span, and will set each group's ->cpumask correctly, : 
strstr : while :  * covered by the given span, and will set each group's ->cpumask correctly, : 
str :  * and ->cpu_power to 0.
strstr : INIT :  * and ->cpu_power to 0. : 
strstr : if :  * and ->cpu_power to 0. : 
strstr : for :  * and ->cpu_power to 0. : 
strstr : while :  * and ->cpu_power to 0. : 
str :  *
strstr : INIT :  * : 
strstr : if :  * : 
strstr : for :  * : 
strstr : while :  * : 
str :  * Assumes the sched_domain tree is fully constructed
strstr : INIT :  * Assumes the sched_domain tree is fully constructed : 
strstr : if :  * Assumes the sched_domain tree is fully constructed : 
strstr : for :  * Assumes the sched_domain tree is fully constructed : 
strstr : while :  * Assumes the sched_domain tree is fully constructed : 
str :  */
strstr : INIT :  */ : 
strstr : if :  */ : 
strstr : for :  */ : 
strstr : while :  */ : 
str : static int
strstr : INIT : static int : 
strstr : if : static int : 
strstr : for : static int : 
strstr : while : static int : 
str : build_sched_groups(struct sched_domain *sd, int cpu)
strstr : INIT : build_sched_groups(struct sched_domain *sd, int cpu) : 
strstr : if : build_sched_groups(struct sched_domain *sd, int cpu) : 
strstr : for : build_sched_groups(struct sched_domain *sd, int cpu) : 
strstr : while : build_sched_groups(struct sched_domain *sd, int cpu) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	struct sched_group *first = NULL, *last = NULL;
strstr : INIT : 	struct sched_group *first = NULL, *last = NULL; : 
strstr : if : 	struct sched_group *first = NULL, *last = NULL; : 
strstr : for : 	struct sched_group *first = NULL, *last = NULL; : 
strstr : while : 	struct sched_group *first = NULL, *last = NULL; : 
str : 	struct sd_data *sdd = sd->private;
strstr : INIT : 	struct sd_data *sdd = sd->private; : 
strstr : if : 	struct sd_data *sdd = sd->private; : 
strstr : for : 	struct sd_data *sdd = sd->private; : 
strstr : while : 	struct sd_data *sdd = sd->private; : 
str : 	const struct cpumask *span = sched_domain_span(sd);
strstr : INIT : 	const struct cpumask *span = sched_domain_span(sd); : 
strstr : if : 	const struct cpumask *span = sched_domain_span(sd); : 
strstr : for : 	const struct cpumask *span = sched_domain_span(sd); : 
strstr : while : 	const struct cpumask *span = sched_domain_span(sd); : 
str : 	struct cpumask *covered;
strstr : INIT : 	struct cpumask *covered; : 
strstr : if : 	struct cpumask *covered; : 
strstr : for : 	struct cpumask *covered; : 
strstr : while : 	struct cpumask *covered; : 
str : 	int i;
strstr : INIT : 	int i; : 
strstr : if : 	int i; : 
strstr : for : 	int i; : 
strstr : while : 	int i; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	get_group(cpu, sdd, &sd->groups);
strstr : if : 	get_group(cpu, sdd, &sd->groups); : 
strstr : for : 	get_group(cpu, sdd, &sd->groups); : 
strstr : while : 	get_group(cpu, sdd, &sd->groups); : 
str : 	atomic_inc(&sd->groups->ref);
strstr : INIT : 	atomic_inc(&sd->groups->ref); : 
strstr : if : 	atomic_inc(&sd->groups->ref); : 
strstr : for : 	atomic_inc(&sd->groups->ref); : 
strstr : while : 	atomic_inc(&sd->groups->ref); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	if (cpu != cpumask_first(span))
strstr : if : 	if (cpu != cpumask_first(span)) : 
strstr : for : 	if (cpu != cpumask_first(span)) : 
strstr : while : 	if (cpu != cpumask_first(span)) : 
str : 		return 0;
strstr : INIT : 		return 0; : 
strstr : if : 		return 0; : 
strstr : for : 		return 0; : 
strstr : while : 		return 0; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	lockdep_assert_held(&sched_domains_mutex);
strstr : if : 	lockdep_assert_held(&sched_domains_mutex); : 
strstr : for : 	lockdep_assert_held(&sched_domains_mutex); : 
strstr : while : 	lockdep_assert_held(&sched_domains_mutex); : 
str : 	covered = sched_domains_tmpmask;
strstr : INIT : 	covered = sched_domains_tmpmask; : 
strstr : if : 	covered = sched_domains_tmpmask; : 
strstr : for : 	covered = sched_domains_tmpmask; : 
strstr : while : 	covered = sched_domains_tmpmask; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	cpumask_clear(covered);
strstr : if : 	cpumask_clear(covered); : 
strstr : for : 	cpumask_clear(covered); : 
strstr : while : 	cpumask_clear(covered); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	for_each_cpu(i, span) {
strstr : if : 	for_each_cpu(i, span) { : 
strstr : for : 	for_each_cpu(i, span) { : 
strstr : while : 	for_each_cpu(i, span) { : 
str : 		struct sched_group *sg;
strstr : INIT : 		struct sched_group *sg; : 
strstr : if : 		struct sched_group *sg; : 
strstr : for : 		struct sched_group *sg; : 
strstr : while : 		struct sched_group *sg; : 
str : 		int group, j;
strstr : INIT : 		int group, j; : 
strstr : if : 		int group, j; : 
strstr : for : 		int group, j; : 
strstr : while : 		int group, j; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 		if (cpumask_test_cpu(i, covered))
strstr : if : 		if (cpumask_test_cpu(i, covered)) : 
strstr : for : 		if (cpumask_test_cpu(i, covered)) : 
strstr : while : 		if (cpumask_test_cpu(i, covered)) : 
str : 			continue;
strstr : INIT : 			continue; : 
strstr : if : 			continue; : 
strstr : for : 			continue; : 
strstr : while : 			continue; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 		group = get_group(i, sdd, &sg);
strstr : if : 		group = get_group(i, sdd, &sg); : 
strstr : for : 		group = get_group(i, sdd, &sg); : 
strstr : while : 		group = get_group(i, sdd, &sg); : 
str : 		cpumask_clear(sched_group_cpus(sg));
strstr : INIT : 		cpumask_clear(sched_group_cpus(sg)); : 
strstr : if : 		cpumask_clear(sched_group_cpus(sg)); : 
strstr : for : 		cpumask_clear(sched_group_cpus(sg)); : 
strstr : while : 		cpumask_clear(sched_group_cpus(sg)); : 
str : 		sg->sgp->power = 0;
strstr : INIT : 		sg->sgp->power = 0; : 
strstr : if : 		sg->sgp->power = 0; : 
strstr : for : 		sg->sgp->power = 0; : 
strstr : while : 		sg->sgp->power = 0; : 
str : 		cpumask_setall(sched_group_mask(sg));
strstr : INIT : 		cpumask_setall(sched_group_mask(sg)); : 
strstr : if : 		cpumask_setall(sched_group_mask(sg)); : 
strstr : for : 		cpumask_setall(sched_group_mask(sg)); : 
strstr : while : 		cpumask_setall(sched_group_mask(sg)); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 		for_each_cpu(j, span) {
strstr : if : 		for_each_cpu(j, span) { : 
strstr : for : 		for_each_cpu(j, span) { : 
strstr : while : 		for_each_cpu(j, span) { : 
str : 			if (get_group(j, sdd, NULL) != group)
strstr : INIT : 			if (get_group(j, sdd, NULL) != group) : 
strstr : if : 			if (get_group(j, sdd, NULL) != group) : 
strstr : for : 			if (get_group(j, sdd, NULL) != group) : 
strstr : while : 			if (get_group(j, sdd, NULL) != group) : 
str : 				continue;
strstr : INIT : 				continue; : 
strstr : if : 				continue; : 
strstr : for : 				continue; : 
strstr : while : 				continue; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 			cpumask_set_cpu(j, covered);
strstr : if : 			cpumask_set_cpu(j, covered); : 
strstr : for : 			cpumask_set_cpu(j, covered); : 
strstr : while : 			cpumask_set_cpu(j, covered); : 
str : 			cpumask_set_cpu(j, sched_group_cpus(sg));
strstr : INIT : 			cpumask_set_cpu(j, sched_group_cpus(sg)); : 
strstr : if : 			cpumask_set_cpu(j, sched_group_cpus(sg)); : 
strstr : for : 			cpumask_set_cpu(j, sched_group_cpus(sg)); : 
strstr : while : 			cpumask_set_cpu(j, sched_group_cpus(sg)); : 
str : 		}
strstr : INIT : 		} : 
strstr : if : 		} : 
strstr : for : 		} : 
strstr : while : 		} : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 		if (!first)
strstr : if : 		if (!first) : 
strstr : for : 		if (!first) : 
strstr : while : 		if (!first) : 
str : 			first = sg;
strstr : INIT : 			first = sg; : 
strstr : if : 			first = sg; : 
strstr : for : 			first = sg; : 
strstr : while : 			first = sg; : 
str : 		if (last)
strstr : INIT : 		if (last) : 
strstr : if : 		if (last) : 
strstr : for : 		if (last) : 
strstr : while : 		if (last) : 
str : 			last->next = sg;
strstr : INIT : 			last->next = sg; : 
strstr : if : 			last->next = sg; : 
strstr : for : 			last->next = sg; : 
strstr : while : 			last->next = sg; : 
str : 		last = sg;
strstr : INIT : 		last = sg; : 
strstr : if : 		last = sg; : 
strstr : for : 		last = sg; : 
strstr : while : 		last = sg; : 
str : 	}
strstr : INIT : 	} : 
strstr : if : 	} : 
strstr : for : 	} : 
strstr : while : 	} : 
str : 	last->next = first;
strstr : INIT : 	last->next = first; : 
strstr : if : 	last->next = first; : 
strstr : for : 	last->next = first; : 
strstr : while : 	last->next = first; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	return 0;
strstr : if : 	return 0; : 
strstr : for : 	return 0; : 
strstr : while : 	return 0; : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : /*
strstr : if : /* : 
strstr : for : /* : 
strstr : while : /* : 
str :  * Initialize sched groups cpu_power.
strstr : INIT :  * Initialize sched groups cpu_power. : 
strstr : if :  * Initialize sched groups cpu_power. : 
strstr : for :  * Initialize sched groups cpu_power. : 
strstr : while :  * Initialize sched groups cpu_power. : 
str :  *
strstr : INIT :  * : 
strstr : if :  * : 
strstr : for :  * : 
strstr : while :  * : 
str :  * cpu_power indicates the capacity of sched group, which is used while
strstr : INIT :  * cpu_power indicates the capacity of sched group, which is used while : 
strstr : if :  * cpu_power indicates the capacity of sched group, which is used while : 
strstr : for :  * cpu_power indicates the capacity of sched group, which is used while : 
strstr : while :  * cpu_power indicates the capacity of sched group, which is used while : 
str :  * distributing the load between different sched groups in a sched domain.
strstr : INIT :  * distributing the load between different sched groups in a sched domain. : 
strstr : if :  * distributing the load between different sched groups in a sched domain. : 
strstr : for :  * distributing the load between different sched groups in a sched domain. : 
strstr : while :  * distributing the load between different sched groups in a sched domain. : 
str :  * Typically cpu_power for all the groups in a sched domain will be same unless
strstr : INIT :  * Typically cpu_power for all the groups in a sched domain will be same unless : 
strstr : if :  * Typically cpu_power for all the groups in a sched domain will be same unless : 
strstr : for :  * Typically cpu_power for all the groups in a sched domain will be same unless : 
strstr : while :  * Typically cpu_power for all the groups in a sched domain will be same unless : 
str :  * there are asymmetries in the topology. If there are asymmetries, group
strstr : INIT :  * there are asymmetries in the topology. If there are asymmetries, group : 
strstr : if :  * there are asymmetries in the topology. If there are asymmetries, group : 
strstr : for :  * there are asymmetries in the topology. If there are asymmetries, group : 
strstr : while :  * there are asymmetries in the topology. If there are asymmetries, group : 
str :  * having more cpu_power will pickup more load compared to the group having
strstr : INIT :  * having more cpu_power will pickup more load compared to the group having : 
strstr : if :  * having more cpu_power will pickup more load compared to the group having : 
strstr : for :  * having more cpu_power will pickup more load compared to the group having : 
strstr : while :  * having more cpu_power will pickup more load compared to the group having : 
str :  * less cpu_power.
strstr : INIT :  * less cpu_power. : 
strstr : if :  * less cpu_power. : 
strstr : for :  * less cpu_power. : 
strstr : while :  * less cpu_power. : 
str :  */
strstr : INIT :  */ : 
strstr : if :  */ : 
strstr : for :  */ : 
strstr : while :  */ : 
str : static void init_sched_groups_power(int cpu, struct sched_domain *sd)
strstr : INIT : static void init_sched_groups_power(int cpu, struct sched_domain *sd) : 
strstr : if : static void init_sched_groups_power(int cpu, struct sched_domain *sd) : 
strstr : for : static void init_sched_groups_power(int cpu, struct sched_domain *sd) : 
strstr : while : static void init_sched_groups_power(int cpu, struct sched_domain *sd) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	struct sched_group *sg = sd->groups;
strstr : INIT : 	struct sched_group *sg = sd->groups; : 
strstr : if : 	struct sched_group *sg = sd->groups; : 
strstr : for : 	struct sched_group *sg = sd->groups; : 
strstr : while : 	struct sched_group *sg = sd->groups; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	WARN_ON(!sg);
strstr : if : 	WARN_ON(!sg); : 
strstr : for : 	WARN_ON(!sg); : 
strstr : while : 	WARN_ON(!sg); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	do {
strstr : if : 	do { : 
strstr : for : 	do { : 
strstr : while : 	do { : 
str : 		sg->group_weight = cpumask_weight(sched_group_cpus(sg));
strstr : INIT : 		sg->group_weight = cpumask_weight(sched_group_cpus(sg)); : 
strstr : if : 		sg->group_weight = cpumask_weight(sched_group_cpus(sg)); : 
strstr : for : 		sg->group_weight = cpumask_weight(sched_group_cpus(sg)); : 
strstr : while : 		sg->group_weight = cpumask_weight(sched_group_cpus(sg)); : 
str : 		sg = sg->next;
strstr : INIT : 		sg = sg->next; : 
strstr : if : 		sg = sg->next; : 
strstr : for : 		sg = sg->next; : 
strstr : while : 		sg = sg->next; : 
str : 	} while (sg != sd->groups);
strstr : INIT : 	} while (sg != sd->groups); : 
strstr : if : 	} while (sg != sd->groups); : 
strstr : for : 	} while (sg != sd->groups); : 
strstr : while : 	} while (sg != sd->groups); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	if (cpu != group_balance_cpu(sg))
strstr : if : 	if (cpu != group_balance_cpu(sg)) : 
strstr : for : 	if (cpu != group_balance_cpu(sg)) : 
strstr : while : 	if (cpu != group_balance_cpu(sg)) : 
str : 		return;
strstr : INIT : 		return; : 
strstr : if : 		return; : 
strstr : for : 		return; : 
strstr : while : 		return; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	update_group_power(sd, cpu);
strstr : if : 	update_group_power(sd, cpu); : 
strstr : for : 	update_group_power(sd, cpu); : 
strstr : while : 	update_group_power(sd, cpu); : 
str : 	atomic_set(&sg->sgp->nr_busy_cpus, sg->group_weight);
strstr : INIT : 	atomic_set(&sg->sgp->nr_busy_cpus, sg->group_weight); : 
strstr : if : 	atomic_set(&sg->sgp->nr_busy_cpus, sg->group_weight); : 
strstr : for : 	atomic_set(&sg->sgp->nr_busy_cpus, sg->group_weight); : 
strstr : while : 	atomic_set(&sg->sgp->nr_busy_cpus, sg->group_weight); : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : int __weak arch_sd_sibling_asym_packing(void)
strstr : if : int __weak arch_sd_sibling_asym_packing(void) : 
strstr : for : int __weak arch_sd_sibling_asym_packing(void) : 
strstr : while : int __weak arch_sd_sibling_asym_packing(void) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str :        return 0*SD_ASYM_PACKING;
strstr : INIT :        return 0*SD_ASYM_PACKING; : 
strstr : if :        return 0*SD_ASYM_PACKING; : 
strstr : for :        return 0*SD_ASYM_PACKING; : 
strstr : while :        return 0*SD_ASYM_PACKING; : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : /*
strstr : if : /* : 
strstr : for : /* : 
strstr : while : /* : 
str :  * Initializers for schedule domains
strstr : INIT :  * Initializers for schedule domains : 
strstr : if :  * Initializers for schedule domains : 
strstr : for :  * Initializers for schedule domains : 
strstr : while :  * Initializers for schedule domains : 
str :  * Non-inlined to reduce accumulated stack pressure in build_sched_domains()
strstr : INIT :  * Non-inlined to reduce accumulated stack pressure in build_sched_domains() : 
strstr : if :  * Non-inlined to reduce accumulated stack pressure in build_sched_domains() : 
strstr : for :  * Non-inlined to reduce accumulated stack pressure in build_sched_domains() : 
strstr : while :  * Non-inlined to reduce accumulated stack pressure in build_sched_domains() : 
str :  */
strstr : INIT :  */ : 
strstr : if :  */ : 
strstr : for :  */ : 
strstr : while :  */ : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : #ifdef CONFIG_SCHED_DEBUG
strstr : if : #ifdef CONFIG_SCHED_DEBUG : 
strstr : for : #ifdef CONFIG_SCHED_DEBUG : 
strstr : while : #ifdef CONFIG_SCHED_DEBUG : 
str : # define SD_INIT_NAME(sd, type)		sd->name = #type
strstr : INIT : # define SD_INIT_NAME(sd, type)		sd->name = #type : 
strstr : if : # define SD_INIT_NAME(sd, type)		sd->name = #type : 
strstr : for : # define SD_INIT_NAME(sd, type)		sd->name = #type : 
strstr : while : # define SD_INIT_NAME(sd, type)		sd->name = #type : 
str : #else
strstr : INIT : #else : 
strstr : if : #else : 
strstr : for : #else : 
strstr : while : #else : 
str : # define SD_INIT_NAME(sd, type)		do { } while (0)
strstr : INIT : # define SD_INIT_NAME(sd, type)		do { } while (0) : 
strstr : if : # define SD_INIT_NAME(sd, type)		do { } while (0) : 
strstr : for : # define SD_INIT_NAME(sd, type)		do { } while (0) : 
strstr : while : # define SD_INIT_NAME(sd, type)		do { } while (0) : 
str : #endif
strstr : INIT : #endif : 
strstr : if : #endif : 
strstr : for : #endif : 
strstr : while : #endif : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : #define SD_INIT_FUNC(type)						\
strstr : if : #define SD_INIT_FUNC(type)						\ : 
strstr : for : #define SD_INIT_FUNC(type)						\ : 
strstr : while : #define SD_INIT_FUNC(type)						\ : 
str : static noinline struct sched_domain *					\
strstr : INIT : static noinline struct sched_domain *					\ : 
strstr : if : static noinline struct sched_domain *					\ : 
strstr : for : static noinline struct sched_domain *					\ : 
strstr : while : static noinline struct sched_domain *					\ : 
str : sd_init_##type(struct sched_domain_topology_level *tl, int cpu) 	\
strstr : INIT : sd_init_##type(struct sched_domain_topology_level *tl, int cpu) 	\ : 
strstr : if : sd_init_##type(struct sched_domain_topology_level *tl, int cpu) 	\ : 
strstr : for : sd_init_##type(struct sched_domain_topology_level *tl, int cpu) 	\ : 
strstr : while : sd_init_##type(struct sched_domain_topology_level *tl, int cpu) 	\ : 
str : {									\
strstr : INIT : {									\ : 
strstr : if : {									\ : 
strstr : for : {									\ : 
strstr : while : {									\ : 
str : 	struct sched_domain *sd = *per_cpu_ptr(tl->data.sd, cpu);	\
strstr : INIT : 	struct sched_domain *sd = *per_cpu_ptr(tl->data.sd, cpu);	\ : 
strstr : if : 	struct sched_domain *sd = *per_cpu_ptr(tl->data.sd, cpu);	\ : 
strstr : for : 	struct sched_domain *sd = *per_cpu_ptr(tl->data.sd, cpu);	\ : 
strstr : while : 	struct sched_domain *sd = *per_cpu_ptr(tl->data.sd, cpu);	\ : 
str : 	*sd = SD_##type##_INIT;						\
strstr : INIT : 	*sd = SD_##type##_INIT;						\ : 
strstr : if : 	*sd = SD_##type##_INIT;						\ : 
strstr : for : 	*sd = SD_##type##_INIT;						\ : 
strstr : while : 	*sd = SD_##type##_INIT;						\ : 
str : 	SD_INIT_NAME(sd, type);						\
strstr : INIT : 	SD_INIT_NAME(sd, type);						\ : 
strstr : if : 	SD_INIT_NAME(sd, type);						\ : 
strstr : for : 	SD_INIT_NAME(sd, type);						\ : 
strstr : while : 	SD_INIT_NAME(sd, type);						\ : 
str : 	sd->private = &tl->data;					\
strstr : INIT : 	sd->private = &tl->data;					\ : 
strstr : if : 	sd->private = &tl->data;					\ : 
strstr : for : 	sd->private = &tl->data;					\ : 
strstr : while : 	sd->private = &tl->data;					\ : 
str : 	return sd;							\
strstr : INIT : 	return sd;							\ : 
strstr : if : 	return sd;							\ : 
strstr : for : 	return sd;							\ : 
strstr : while : 	return sd;							\ : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : SD_INIT_FUNC(CPU)
strstr : if : SD_INIT_FUNC(CPU) : 
strstr : for : SD_INIT_FUNC(CPU) : 
strstr : while : SD_INIT_FUNC(CPU) : 
str : #ifdef CONFIG_SCHED_SMT
strstr : INIT : #ifdef CONFIG_SCHED_SMT : 
strstr : if : #ifdef CONFIG_SCHED_SMT : 
strstr : for : #ifdef CONFIG_SCHED_SMT : 
strstr : while : #ifdef CONFIG_SCHED_SMT : 
str :  SD_INIT_FUNC(SIBLING)
strstr : INIT :  SD_INIT_FUNC(SIBLING) : 
strstr : if :  SD_INIT_FUNC(SIBLING) : 
strstr : for :  SD_INIT_FUNC(SIBLING) : 
strstr : while :  SD_INIT_FUNC(SIBLING) : 
str : #endif
strstr : INIT : #endif : 
strstr : if : #endif : 
strstr : for : #endif : 
strstr : while : #endif : 
str : #ifdef CONFIG_SCHED_MC
strstr : INIT : #ifdef CONFIG_SCHED_MC : 
strstr : if : #ifdef CONFIG_SCHED_MC : 
strstr : for : #ifdef CONFIG_SCHED_MC : 
strstr : while : #ifdef CONFIG_SCHED_MC : 
str :  SD_INIT_FUNC(MC)
strstr : INIT :  SD_INIT_FUNC(MC) : 
strstr : if :  SD_INIT_FUNC(MC) : 
strstr : for :  SD_INIT_FUNC(MC) : 
strstr : while :  SD_INIT_FUNC(MC) : 
str : #endif
strstr : INIT : #endif : 
strstr : if : #endif : 
strstr : for : #endif : 
strstr : while : #endif : 
str : #ifdef CONFIG_SCHED_BOOK
strstr : INIT : #ifdef CONFIG_SCHED_BOOK : 
strstr : if : #ifdef CONFIG_SCHED_BOOK : 
strstr : for : #ifdef CONFIG_SCHED_BOOK : 
strstr : while : #ifdef CONFIG_SCHED_BOOK : 
str :  SD_INIT_FUNC(BOOK)
strstr : INIT :  SD_INIT_FUNC(BOOK) : 
strstr : if :  SD_INIT_FUNC(BOOK) : 
strstr : for :  SD_INIT_FUNC(BOOK) : 
strstr : while :  SD_INIT_FUNC(BOOK) : 
str : #endif
strstr : INIT : #endif : 
strstr : if : #endif : 
strstr : for : #endif : 
strstr : while : #endif : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : static int default_relax_domain_level = -1;
strstr : if : static int default_relax_domain_level = -1; : 
strstr : for : static int default_relax_domain_level = -1; : 
strstr : while : static int default_relax_domain_level = -1; : 
str : int sched_domain_level_max;
strstr : INIT : int sched_domain_level_max; : 
strstr : if : int sched_domain_level_max; : 
strstr : for : int sched_domain_level_max; : 
strstr : while : int sched_domain_level_max; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : static int __init setup_relax_domain_level(char *str)
strstr : if : static int __init setup_relax_domain_level(char *str) : 
strstr : for : static int __init setup_relax_domain_level(char *str) : 
strstr : while : static int __init setup_relax_domain_level(char *str) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	if (kstrtoint(str, 0, &default_relax_domain_level))
strstr : INIT : 	if (kstrtoint(str, 0, &default_relax_domain_level)) : 
strstr : if : 	if (kstrtoint(str, 0, &default_relax_domain_level)) : 
strstr : for : 	if (kstrtoint(str, 0, &default_relax_domain_level)) : 
strstr : while : 	if (kstrtoint(str, 0, &default_relax_domain_level)) : 
str : 		pr_warn("Unable to set relax_domain_level\n");
strstr : INIT : 		pr_warn("Unable to set relax_domain_level\n"); : 
strstr : if : 		pr_warn("Unable to set relax_domain_level\n"); : 
strstr : for : 		pr_warn("Unable to set relax_domain_level\n"); : 
strstr : while : 		pr_warn("Unable to set relax_domain_level\n"); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	return 1;
strstr : if : 	return 1; : 
strstr : for : 	return 1; : 
strstr : while : 	return 1; : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : __setup("relax_domain_level=", setup_relax_domain_level);
strstr : INIT : __setup("relax_domain_level=", setup_relax_domain_level); : 
strstr : if : __setup("relax_domain_level=", setup_relax_domain_level); : 
strstr : for : __setup("relax_domain_level=", setup_relax_domain_level); : 
strstr : while : __setup("relax_domain_level=", setup_relax_domain_level); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : static void set_domain_attribute(struct sched_domain *sd,
strstr : if : static void set_domain_attribute(struct sched_domain *sd, : 
strstr : for : static void set_domain_attribute(struct sched_domain *sd, : 
strstr : while : static void set_domain_attribute(struct sched_domain *sd, : 
str : 				 struct sched_domain_attr *attr)
strstr : INIT : 				 struct sched_domain_attr *attr) : 
strstr : if : 				 struct sched_domain_attr *attr) : 
strstr : for : 				 struct sched_domain_attr *attr) : 
strstr : while : 				 struct sched_domain_attr *attr) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	int request;
strstr : INIT : 	int request; : 
strstr : if : 	int request; : 
strstr : for : 	int request; : 
strstr : while : 	int request; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	if (!attr || attr->relax_domain_level < 0) {
strstr : if : 	if (!attr || attr->relax_domain_level < 0) { : 
strstr : for : 	if (!attr || attr->relax_domain_level < 0) { : 
strstr : while : 	if (!attr || attr->relax_domain_level < 0) { : 
str : 		if (default_relax_domain_level < 0)
strstr : INIT : 		if (default_relax_domain_level < 0) : 
strstr : if : 		if (default_relax_domain_level < 0) : 
strstr : for : 		if (default_relax_domain_level < 0) : 
strstr : while : 		if (default_relax_domain_level < 0) : 
str : 			return;
strstr : INIT : 			return; : 
strstr : if : 			return; : 
strstr : for : 			return; : 
strstr : while : 			return; : 
str : 		else
strstr : INIT : 		else : 
strstr : if : 		else : 
strstr : for : 		else : 
strstr : while : 		else : 
str : 			request = default_relax_domain_level;
strstr : INIT : 			request = default_relax_domain_level; : 
strstr : if : 			request = default_relax_domain_level; : 
strstr : for : 			request = default_relax_domain_level; : 
strstr : while : 			request = default_relax_domain_level; : 
str : 	} else
strstr : INIT : 	} else : 
strstr : if : 	} else : 
strstr : for : 	} else : 
strstr : while : 	} else : 
str : 		request = attr->relax_domain_level;
strstr : INIT : 		request = attr->relax_domain_level; : 
strstr : if : 		request = attr->relax_domain_level; : 
strstr : for : 		request = attr->relax_domain_level; : 
strstr : while : 		request = attr->relax_domain_level; : 
str : 	if (request < sd->level) {
strstr : INIT : 	if (request < sd->level) { : 
strstr : if : 	if (request < sd->level) { : 
strstr : for : 	if (request < sd->level) { : 
strstr : while : 	if (request < sd->level) { : 
str : 		/* turn off idle balance on this domain */
strstr : INIT : 		/* turn off idle balance on this domain */ : 
strstr : if : 		/* turn off idle balance on this domain */ : 
strstr : for : 		/* turn off idle balance on this domain */ : 
strstr : while : 		/* turn off idle balance on this domain */ : 
str : 		sd->flags &= ~(SD_BALANCE_WAKE|SD_BALANCE_NEWIDLE);
strstr : INIT : 		sd->flags &= ~(SD_BALANCE_WAKE|SD_BALANCE_NEWIDLE); : 
strstr : if : 		sd->flags &= ~(SD_BALANCE_WAKE|SD_BALANCE_NEWIDLE); : 
strstr : for : 		sd->flags &= ~(SD_BALANCE_WAKE|SD_BALANCE_NEWIDLE); : 
strstr : while : 		sd->flags &= ~(SD_BALANCE_WAKE|SD_BALANCE_NEWIDLE); : 
str : 	} else {
strstr : INIT : 	} else { : 
strstr : if : 	} else { : 
strstr : for : 	} else { : 
strstr : while : 	} else { : 
str : 		/* turn on idle balance on this domain */
strstr : INIT : 		/* turn on idle balance on this domain */ : 
strstr : if : 		/* turn on idle balance on this domain */ : 
strstr : for : 		/* turn on idle balance on this domain */ : 
strstr : while : 		/* turn on idle balance on this domain */ : 
str : 		sd->flags |= (SD_BALANCE_WAKE|SD_BALANCE_NEWIDLE);
strstr : INIT : 		sd->flags |= (SD_BALANCE_WAKE|SD_BALANCE_NEWIDLE); : 
strstr : if : 		sd->flags |= (SD_BALANCE_WAKE|SD_BALANCE_NEWIDLE); : 
strstr : for : 		sd->flags |= (SD_BALANCE_WAKE|SD_BALANCE_NEWIDLE); : 
strstr : while : 		sd->flags |= (SD_BALANCE_WAKE|SD_BALANCE_NEWIDLE); : 
str : 	}
strstr : INIT : 	} : 
strstr : if : 	} : 
strstr : for : 	} : 
strstr : while : 	} : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : static void __sdt_free(const struct cpumask *cpu_map);
strstr : if : static void __sdt_free(const struct cpumask *cpu_map); : 
strstr : for : static void __sdt_free(const struct cpumask *cpu_map); : 
strstr : while : static void __sdt_free(const struct cpumask *cpu_map); : 
str : static int __sdt_alloc(const struct cpumask *cpu_map);
strstr : INIT : static int __sdt_alloc(const struct cpumask *cpu_map); : 
strstr : if : static int __sdt_alloc(const struct cpumask *cpu_map); : 
strstr : for : static int __sdt_alloc(const struct cpumask *cpu_map); : 
strstr : while : static int __sdt_alloc(const struct cpumask *cpu_map); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : static void __free_domain_allocs(struct s_data *d, enum s_alloc what,
strstr : if : static void __free_domain_allocs(struct s_data *d, enum s_alloc what, : 
strstr : for : static void __free_domain_allocs(struct s_data *d, enum s_alloc what, : 
strstr : while : static void __free_domain_allocs(struct s_data *d, enum s_alloc what, : 
str : 				 const struct cpumask *cpu_map)
strstr : INIT : 				 const struct cpumask *cpu_map) : 
strstr : if : 				 const struct cpumask *cpu_map) : 
strstr : for : 				 const struct cpumask *cpu_map) : 
strstr : while : 				 const struct cpumask *cpu_map) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	switch (what) {
strstr : INIT : 	switch (what) { : 
strstr : if : 	switch (what) { : 
strstr : for : 	switch (what) { : 
strstr : while : 	switch (what) { : 
str : 	case sa_rootdomain:
strstr : INIT : 	case sa_rootdomain: : 
strstr : if : 	case sa_rootdomain: : 
strstr : for : 	case sa_rootdomain: : 
strstr : while : 	case sa_rootdomain: : 
str : 		if (!atomic_read(&d->rd->refcount))
strstr : INIT : 		if (!atomic_read(&d->rd->refcount)) : 
strstr : if : 		if (!atomic_read(&d->rd->refcount)) : 
strstr : for : 		if (!atomic_read(&d->rd->refcount)) : 
strstr : while : 		if (!atomic_read(&d->rd->refcount)) : 
str : 			free_rootdomain(&d->rd->rcu); /* fall through */
strstr : INIT : 			free_rootdomain(&d->rd->rcu); /* fall through */ : 
strstr : if : 			free_rootdomain(&d->rd->rcu); /* fall through */ : 
strstr : for : 			free_rootdomain(&d->rd->rcu); /* fall through */ : 
strstr : while : 			free_rootdomain(&d->rd->rcu); /* fall through */ : 
str : 	case sa_sd:
strstr : INIT : 	case sa_sd: : 
strstr : if : 	case sa_sd: : 
strstr : for : 	case sa_sd: : 
strstr : while : 	case sa_sd: : 
str : 		free_percpu(d->sd); /* fall through */
strstr : INIT : 		free_percpu(d->sd); /* fall through */ : 
strstr : if : 		free_percpu(d->sd); /* fall through */ : 
strstr : for : 		free_percpu(d->sd); /* fall through */ : 
strstr : while : 		free_percpu(d->sd); /* fall through */ : 
str : 	case sa_sd_storage:
strstr : INIT : 	case sa_sd_storage: : 
strstr : if : 	case sa_sd_storage: : 
strstr : for : 	case sa_sd_storage: : 
strstr : while : 	case sa_sd_storage: : 
str : 		__sdt_free(cpu_map); /* fall through */
strstr : INIT : 		__sdt_free(cpu_map); /* fall through */ : 
strstr : if : 		__sdt_free(cpu_map); /* fall through */ : 
strstr : for : 		__sdt_free(cpu_map); /* fall through */ : 
strstr : while : 		__sdt_free(cpu_map); /* fall through */ : 
str : 	case sa_none:
strstr : INIT : 	case sa_none: : 
strstr : if : 	case sa_none: : 
strstr : for : 	case sa_none: : 
strstr : while : 	case sa_none: : 
str : 		break;
strstr : INIT : 		break; : 
strstr : if : 		break; : 
strstr : for : 		break; : 
strstr : while : 		break; : 
str : 	}
strstr : INIT : 	} : 
strstr : if : 	} : 
strstr : for : 	} : 
strstr : while : 	} : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : static enum s_alloc __visit_domain_allocation_hell(struct s_data *d,
strstr : if : static enum s_alloc __visit_domain_allocation_hell(struct s_data *d, : 
strstr : for : static enum s_alloc __visit_domain_allocation_hell(struct s_data *d, : 
strstr : while : static enum s_alloc __visit_domain_allocation_hell(struct s_data *d, : 
str : 						   const struct cpumask *cpu_map)
strstr : INIT : 						   const struct cpumask *cpu_map) : 
strstr : if : 						   const struct cpumask *cpu_map) : 
strstr : for : 						   const struct cpumask *cpu_map) : 
strstr : while : 						   const struct cpumask *cpu_map) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	memset(d, 0, sizeof(*d));
strstr : INIT : 	memset(d, 0, sizeof(*d)); : 
strstr : if : 	memset(d, 0, sizeof(*d)); : 
strstr : for : 	memset(d, 0, sizeof(*d)); : 
strstr : while : 	memset(d, 0, sizeof(*d)); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	if (__sdt_alloc(cpu_map))
strstr : if : 	if (__sdt_alloc(cpu_map)) : 
strstr : for : 	if (__sdt_alloc(cpu_map)) : 
strstr : while : 	if (__sdt_alloc(cpu_map)) : 
str : 		return sa_sd_storage;
strstr : INIT : 		return sa_sd_storage; : 
strstr : if : 		return sa_sd_storage; : 
strstr : for : 		return sa_sd_storage; : 
strstr : while : 		return sa_sd_storage; : 
str : 	d->sd = alloc_percpu(struct sched_domain *);
strstr : INIT : 	d->sd = alloc_percpu(struct sched_domain *); : 
strstr : if : 	d->sd = alloc_percpu(struct sched_domain *); : 
strstr : for : 	d->sd = alloc_percpu(struct sched_domain *); : 
strstr : while : 	d->sd = alloc_percpu(struct sched_domain *); : 
str : 	if (!d->sd)
strstr : INIT : 	if (!d->sd) : 
strstr : if : 	if (!d->sd) : 
strstr : for : 	if (!d->sd) : 
strstr : while : 	if (!d->sd) : 
str : 		return sa_sd_storage;
strstr : INIT : 		return sa_sd_storage; : 
strstr : if : 		return sa_sd_storage; : 
strstr : for : 		return sa_sd_storage; : 
strstr : while : 		return sa_sd_storage; : 
str : 	d->rd = alloc_rootdomain();
strstr : INIT : 	d->rd = alloc_rootdomain(); : 
strstr : if : 	d->rd = alloc_rootdomain(); : 
strstr : for : 	d->rd = alloc_rootdomain(); : 
strstr : while : 	d->rd = alloc_rootdomain(); : 
str : 	if (!d->rd)
strstr : INIT : 	if (!d->rd) : 
strstr : if : 	if (!d->rd) : 
strstr : for : 	if (!d->rd) : 
strstr : while : 	if (!d->rd) : 
str : 		return sa_sd;
strstr : INIT : 		return sa_sd; : 
strstr : if : 		return sa_sd; : 
strstr : for : 		return sa_sd; : 
strstr : while : 		return sa_sd; : 
str : 	return sa_rootdomain;
strstr : INIT : 	return sa_rootdomain; : 
strstr : if : 	return sa_rootdomain; : 
strstr : for : 	return sa_rootdomain; : 
strstr : while : 	return sa_rootdomain; : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : /*
strstr : if : /* : 
strstr : for : /* : 
strstr : while : /* : 
str :  * NULL the sd_data elements we've used to build the sched_domain and
strstr : INIT :  * NULL the sd_data elements we've used to build the sched_domain and : 
strstr : if :  * NULL the sd_data elements we've used to build the sched_domain and : 
strstr : for :  * NULL the sd_data elements we've used to build the sched_domain and : 
strstr : while :  * NULL the sd_data elements we've used to build the sched_domain and : 
str :  * sched_group structure so that the subsequent __free_domain_allocs()
strstr : INIT :  * sched_group structure so that the subsequent __free_domain_allocs() : 
strstr : if :  * sched_group structure so that the subsequent __free_domain_allocs() : 
strstr : for :  * sched_group structure so that the subsequent __free_domain_allocs() : 
strstr : while :  * sched_group structure so that the subsequent __free_domain_allocs() : 
str :  * will not free the data we're using.
strstr : INIT :  * will not free the data we're using. : 
strstr : if :  * will not free the data we're using. : 
strstr : for :  * will not free the data we're using. : 
strstr : while :  * will not free the data we're using. : 
str :  */
strstr : INIT :  */ : 
strstr : if :  */ : 
strstr : for :  */ : 
strstr : while :  */ : 
str : static void claim_allocations(int cpu, struct sched_domain *sd)
strstr : INIT : static void claim_allocations(int cpu, struct sched_domain *sd) : 
strstr : if : static void claim_allocations(int cpu, struct sched_domain *sd) : 
strstr : for : static void claim_allocations(int cpu, struct sched_domain *sd) : 
strstr : while : static void claim_allocations(int cpu, struct sched_domain *sd) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	struct sd_data *sdd = sd->private;
strstr : INIT : 	struct sd_data *sdd = sd->private; : 
strstr : if : 	struct sd_data *sdd = sd->private; : 
strstr : for : 	struct sd_data *sdd = sd->private; : 
strstr : while : 	struct sd_data *sdd = sd->private; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	WARN_ON_ONCE(*per_cpu_ptr(sdd->sd, cpu) != sd);
strstr : if : 	WARN_ON_ONCE(*per_cpu_ptr(sdd->sd, cpu) != sd); : 
strstr : for : 	WARN_ON_ONCE(*per_cpu_ptr(sdd->sd, cpu) != sd); : 
strstr : while : 	WARN_ON_ONCE(*per_cpu_ptr(sdd->sd, cpu) != sd); : 
str : 	*per_cpu_ptr(sdd->sd, cpu) = NULL;
strstr : INIT : 	*per_cpu_ptr(sdd->sd, cpu) = NULL; : 
strstr : if : 	*per_cpu_ptr(sdd->sd, cpu) = NULL; : 
strstr : for : 	*per_cpu_ptr(sdd->sd, cpu) = NULL; : 
strstr : while : 	*per_cpu_ptr(sdd->sd, cpu) = NULL; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	if (atomic_read(&(*per_cpu_ptr(sdd->sg, cpu))->ref))
strstr : if : 	if (atomic_read(&(*per_cpu_ptr(sdd->sg, cpu))->ref)) : 
strstr : for : 	if (atomic_read(&(*per_cpu_ptr(sdd->sg, cpu))->ref)) : 
strstr : while : 	if (atomic_read(&(*per_cpu_ptr(sdd->sg, cpu))->ref)) : 
str : 		*per_cpu_ptr(sdd->sg, cpu) = NULL;
strstr : INIT : 		*per_cpu_ptr(sdd->sg, cpu) = NULL; : 
strstr : if : 		*per_cpu_ptr(sdd->sg, cpu) = NULL; : 
strstr : for : 		*per_cpu_ptr(sdd->sg, cpu) = NULL; : 
strstr : while : 		*per_cpu_ptr(sdd->sg, cpu) = NULL; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	if (atomic_read(&(*per_cpu_ptr(sdd->sgp, cpu))->ref))
strstr : if : 	if (atomic_read(&(*per_cpu_ptr(sdd->sgp, cpu))->ref)) : 
strstr : for : 	if (atomic_read(&(*per_cpu_ptr(sdd->sgp, cpu))->ref)) : 
strstr : while : 	if (atomic_read(&(*per_cpu_ptr(sdd->sgp, cpu))->ref)) : 
str : 		*per_cpu_ptr(sdd->sgp, cpu) = NULL;
strstr : INIT : 		*per_cpu_ptr(sdd->sgp, cpu) = NULL; : 
strstr : if : 		*per_cpu_ptr(sdd->sgp, cpu) = NULL; : 
strstr : for : 		*per_cpu_ptr(sdd->sgp, cpu) = NULL; : 
strstr : while : 		*per_cpu_ptr(sdd->sgp, cpu) = NULL; : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : #ifdef CONFIG_SCHED_SMT
strstr : if : #ifdef CONFIG_SCHED_SMT : 
strstr : for : #ifdef CONFIG_SCHED_SMT : 
strstr : while : #ifdef CONFIG_SCHED_SMT : 
str : static const struct cpumask *cpu_smt_mask(int cpu)
strstr : INIT : static const struct cpumask *cpu_smt_mask(int cpu) : 
strstr : if : static const struct cpumask *cpu_smt_mask(int cpu) : 
strstr : for : static const struct cpumask *cpu_smt_mask(int cpu) : 
strstr : while : static const struct cpumask *cpu_smt_mask(int cpu) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	return topology_thread_cpumask(cpu);
strstr : INIT : 	return topology_thread_cpumask(cpu); : 
strstr : if : 	return topology_thread_cpumask(cpu); : 
strstr : for : 	return topology_thread_cpumask(cpu); : 
strstr : while : 	return topology_thread_cpumask(cpu); : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : #endif
strstr : INIT : #endif : 
strstr : if : #endif : 
strstr : for : #endif : 
strstr : while : #endif : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : /*
strstr : if : /* : 
strstr : for : /* : 
strstr : while : /* : 
str :  * Topology list, bottom-up.
strstr : INIT :  * Topology list, bottom-up. : 
strstr : if :  * Topology list, bottom-up. : 
strstr : for :  * Topology list, bottom-up. : 
strstr : while :  * Topology list, bottom-up. : 
str :  */
strstr : INIT :  */ : 
strstr : if :  */ : 
strstr : for :  */ : 
strstr : while :  */ : 
str : static struct sched_domain_topology_level default_topology[] = {
strstr : INIT : static struct sched_domain_topology_level default_topology[] = { : 
strstr : if : static struct sched_domain_topology_level default_topology[] = { : 
strstr : for : static struct sched_domain_topology_level default_topology[] = { : 
strstr : while : static struct sched_domain_topology_level default_topology[] = { : 
str : #ifdef CONFIG_SCHED_SMT
strstr : INIT : #ifdef CONFIG_SCHED_SMT : 
strstr : if : #ifdef CONFIG_SCHED_SMT : 
strstr : for : #ifdef CONFIG_SCHED_SMT : 
strstr : while : #ifdef CONFIG_SCHED_SMT : 
str : 	{ sd_init_SIBLING, cpu_smt_mask, },
strstr : INIT : 	{ sd_init_SIBLING, cpu_smt_mask, }, : 
strstr : if : 	{ sd_init_SIBLING, cpu_smt_mask, }, : 
strstr : for : 	{ sd_init_SIBLING, cpu_smt_mask, }, : 
strstr : while : 	{ sd_init_SIBLING, cpu_smt_mask, }, : 
str : #endif
strstr : INIT : #endif : 
strstr : if : #endif : 
strstr : for : #endif : 
strstr : while : #endif : 
str : #ifdef CONFIG_SCHED_MC
strstr : INIT : #ifdef CONFIG_SCHED_MC : 
strstr : if : #ifdef CONFIG_SCHED_MC : 
strstr : for : #ifdef CONFIG_SCHED_MC : 
strstr : while : #ifdef CONFIG_SCHED_MC : 
str : 	{ sd_init_MC, cpu_coregroup_mask, },
strstr : INIT : 	{ sd_init_MC, cpu_coregroup_mask, }, : 
strstr : if : 	{ sd_init_MC, cpu_coregroup_mask, }, : 
strstr : for : 	{ sd_init_MC, cpu_coregroup_mask, }, : 
strstr : while : 	{ sd_init_MC, cpu_coregroup_mask, }, : 
str : #endif
strstr : INIT : #endif : 
strstr : if : #endif : 
strstr : for : #endif : 
strstr : while : #endif : 
str : #ifdef CONFIG_SCHED_BOOK
strstr : INIT : #ifdef CONFIG_SCHED_BOOK : 
strstr : if : #ifdef CONFIG_SCHED_BOOK : 
strstr : for : #ifdef CONFIG_SCHED_BOOK : 
strstr : while : #ifdef CONFIG_SCHED_BOOK : 
str : 	{ sd_init_BOOK, cpu_book_mask, },
strstr : INIT : 	{ sd_init_BOOK, cpu_book_mask, }, : 
strstr : if : 	{ sd_init_BOOK, cpu_book_mask, }, : 
strstr : for : 	{ sd_init_BOOK, cpu_book_mask, }, : 
strstr : while : 	{ sd_init_BOOK, cpu_book_mask, }, : 
str : #endif
strstr : INIT : #endif : 
strstr : if : #endif : 
strstr : for : #endif : 
strstr : while : #endif : 
str : 	{ sd_init_CPU, cpu_cpu_mask, },
strstr : INIT : 	{ sd_init_CPU, cpu_cpu_mask, }, : 
strstr : if : 	{ sd_init_CPU, cpu_cpu_mask, }, : 
strstr : for : 	{ sd_init_CPU, cpu_cpu_mask, }, : 
strstr : while : 	{ sd_init_CPU, cpu_cpu_mask, }, : 
str : 	{ NULL, },
strstr : INIT : 	{ NULL, }, : 
strstr : if : 	{ NULL, }, : 
strstr : for : 	{ NULL, }, : 
strstr : while : 	{ NULL, }, : 
str : };
strstr : INIT : }; : 
strstr : if : }; : 
strstr : for : }; : 
strstr : while : }; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : static struct sched_domain_topology_level *sched_domain_topology = default_topology;
strstr : if : static struct sched_domain_topology_level *sched_domain_topology = default_topology; : 
strstr : for : static struct sched_domain_topology_level *sched_domain_topology = default_topology; : 
strstr : while : static struct sched_domain_topology_level *sched_domain_topology = default_topology; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : #define for_each_sd_topology(tl)			\
strstr : if : #define for_each_sd_topology(tl)			\ : 
strstr : for : #define for_each_sd_topology(tl)			\ : 
strstr : while : #define for_each_sd_topology(tl)			\ : 
str : 	for (tl = sched_domain_topology; tl->init; tl++)
strstr : INIT : 	for (tl = sched_domain_topology; tl->init; tl++) : 
strstr : if : 	for (tl = sched_domain_topology; tl->init; tl++) : 
strstr : for : 	for (tl = sched_domain_topology; tl->init; tl++) : 
strstr : while : 	for (tl = sched_domain_topology; tl->init; tl++) : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : #ifdef CONFIG_NUMA
strstr : if : #ifdef CONFIG_NUMA : 
strstr : for : #ifdef CONFIG_NUMA : 
strstr : while : #ifdef CONFIG_NUMA : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : static int sched_domains_numa_levels;
strstr : if : static int sched_domains_numa_levels; : 
strstr : for : static int sched_domains_numa_levels; : 
strstr : while : static int sched_domains_numa_levels; : 
str : static int *sched_domains_numa_distance;
strstr : INIT : static int *sched_domains_numa_distance; : 
strstr : if : static int *sched_domains_numa_distance; : 
strstr : for : static int *sched_domains_numa_distance; : 
strstr : while : static int *sched_domains_numa_distance; : 
str : static struct cpumask ***sched_domains_numa_masks;
strstr : INIT : static struct cpumask ***sched_domains_numa_masks; : 
strstr : if : static struct cpumask ***sched_domains_numa_masks; : 
strstr : for : static struct cpumask ***sched_domains_numa_masks; : 
strstr : while : static struct cpumask ***sched_domains_numa_masks; : 
str : static int sched_domains_curr_level;
strstr : INIT : static int sched_domains_curr_level; : 
strstr : if : static int sched_domains_curr_level; : 
strstr : for : static int sched_domains_curr_level; : 
strstr : while : static int sched_domains_curr_level; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : static inline int sd_local_flags(int level)
strstr : if : static inline int sd_local_flags(int level) : 
strstr : for : static inline int sd_local_flags(int level) : 
strstr : while : static inline int sd_local_flags(int level) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	if (sched_domains_numa_distance[level] > RECLAIM_DISTANCE)
strstr : INIT : 	if (sched_domains_numa_distance[level] > RECLAIM_DISTANCE) : 
strstr : if : 	if (sched_domains_numa_distance[level] > RECLAIM_DISTANCE) : 
strstr : for : 	if (sched_domains_numa_distance[level] > RECLAIM_DISTANCE) : 
strstr : while : 	if (sched_domains_numa_distance[level] > RECLAIM_DISTANCE) : 
str : 		return 0;
strstr : INIT : 		return 0; : 
strstr : if : 		return 0; : 
strstr : for : 		return 0; : 
strstr : while : 		return 0; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	return SD_BALANCE_EXEC | SD_BALANCE_FORK | SD_WAKE_AFFINE;
strstr : if : 	return SD_BALANCE_EXEC | SD_BALANCE_FORK | SD_WAKE_AFFINE; : 
strstr : for : 	return SD_BALANCE_EXEC | SD_BALANCE_FORK | SD_WAKE_AFFINE; : 
strstr : while : 	return SD_BALANCE_EXEC | SD_BALANCE_FORK | SD_WAKE_AFFINE; : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : static struct sched_domain *
strstr : if : static struct sched_domain * : 
strstr : for : static struct sched_domain * : 
strstr : while : static struct sched_domain * : 
str : sd_numa_init(struct sched_domain_topology_level *tl, int cpu)
strstr : INIT : sd_numa_init(struct sched_domain_topology_level *tl, int cpu) : 
strstr : if : sd_numa_init(struct sched_domain_topology_level *tl, int cpu) : 
strstr : for : sd_numa_init(struct sched_domain_topology_level *tl, int cpu) : 
strstr : while : sd_numa_init(struct sched_domain_topology_level *tl, int cpu) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	struct sched_domain *sd = *per_cpu_ptr(tl->data.sd, cpu);
strstr : INIT : 	struct sched_domain *sd = *per_cpu_ptr(tl->data.sd, cpu); : 
strstr : if : 	struct sched_domain *sd = *per_cpu_ptr(tl->data.sd, cpu); : 
strstr : for : 	struct sched_domain *sd = *per_cpu_ptr(tl->data.sd, cpu); : 
strstr : while : 	struct sched_domain *sd = *per_cpu_ptr(tl->data.sd, cpu); : 
str : 	int level = tl->numa_level;
strstr : INIT : 	int level = tl->numa_level; : 
strstr : if : 	int level = tl->numa_level; : 
strstr : for : 	int level = tl->numa_level; : 
strstr : while : 	int level = tl->numa_level; : 
str : 	int sd_weight = cpumask_weight(
strstr : INIT : 	int sd_weight = cpumask_weight( : 
strstr : if : 	int sd_weight = cpumask_weight( : 
strstr : for : 	int sd_weight = cpumask_weight( : 
strstr : while : 	int sd_weight = cpumask_weight( : 
str : 			sched_domains_numa_masks[level][cpu_to_node(cpu)]);
strstr : INIT : 			sched_domains_numa_masks[level][cpu_to_node(cpu)]); : 
strstr : if : 			sched_domains_numa_masks[level][cpu_to_node(cpu)]); : 
strstr : for : 			sched_domains_numa_masks[level][cpu_to_node(cpu)]); : 
strstr : while : 			sched_domains_numa_masks[level][cpu_to_node(cpu)]); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	*sd = (struct sched_domain){
strstr : if : 	*sd = (struct sched_domain){ : 
strstr : for : 	*sd = (struct sched_domain){ : 
strstr : while : 	*sd = (struct sched_domain){ : 
str : 		.min_interval		= sd_weight,
strstr : INIT : 		.min_interval		= sd_weight, : 
strstr : if : 		.min_interval		= sd_weight, : 
strstr : for : 		.min_interval		= sd_weight, : 
strstr : while : 		.min_interval		= sd_weight, : 
str : 		.max_interval		= 2*sd_weight,
strstr : INIT : 		.max_interval		= 2*sd_weight, : 
strstr : if : 		.max_interval		= 2*sd_weight, : 
strstr : for : 		.max_interval		= 2*sd_weight, : 
strstr : while : 		.max_interval		= 2*sd_weight, : 
str : 		.busy_factor		= 32,
strstr : INIT : 		.busy_factor		= 32, : 
strstr : if : 		.busy_factor		= 32, : 
strstr : for : 		.busy_factor		= 32, : 
strstr : while : 		.busy_factor		= 32, : 
str : 		.imbalance_pct		= 125,
strstr : INIT : 		.imbalance_pct		= 125, : 
strstr : if : 		.imbalance_pct		= 125, : 
strstr : for : 		.imbalance_pct		= 125, : 
strstr : while : 		.imbalance_pct		= 125, : 
str : 		.cache_nice_tries	= 2,
strstr : INIT : 		.cache_nice_tries	= 2, : 
strstr : if : 		.cache_nice_tries	= 2, : 
strstr : for : 		.cache_nice_tries	= 2, : 
strstr : while : 		.cache_nice_tries	= 2, : 
str : 		.busy_idx		= 3,
strstr : INIT : 		.busy_idx		= 3, : 
strstr : if : 		.busy_idx		= 3, : 
strstr : for : 		.busy_idx		= 3, : 
strstr : while : 		.busy_idx		= 3, : 
str : 		.idle_idx		= 2,
strstr : INIT : 		.idle_idx		= 2, : 
strstr : if : 		.idle_idx		= 2, : 
strstr : for : 		.idle_idx		= 2, : 
strstr : while : 		.idle_idx		= 2, : 
str : 		.newidle_idx		= 0,
strstr : INIT : 		.newidle_idx		= 0, : 
strstr : if : 		.newidle_idx		= 0, : 
strstr : for : 		.newidle_idx		= 0, : 
strstr : while : 		.newidle_idx		= 0, : 
str : 		.wake_idx		= 0,
strstr : INIT : 		.wake_idx		= 0, : 
strstr : if : 		.wake_idx		= 0, : 
strstr : for : 		.wake_idx		= 0, : 
strstr : while : 		.wake_idx		= 0, : 
str : 		.forkexec_idx		= 0,
strstr : INIT : 		.forkexec_idx		= 0, : 
strstr : if : 		.forkexec_idx		= 0, : 
strstr : for : 		.forkexec_idx		= 0, : 
strstr : while : 		.forkexec_idx		= 0, : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 		.flags			= 1*SD_LOAD_BALANCE
strstr : if : 		.flags			= 1*SD_LOAD_BALANCE : 
strstr : for : 		.flags			= 1*SD_LOAD_BALANCE : 
strstr : while : 		.flags			= 1*SD_LOAD_BALANCE : 
str : 					| 1*SD_BALANCE_NEWIDLE
strstr : INIT : 					| 1*SD_BALANCE_NEWIDLE : 
strstr : if : 					| 1*SD_BALANCE_NEWIDLE : 
strstr : for : 					| 1*SD_BALANCE_NEWIDLE : 
strstr : while : 					| 1*SD_BALANCE_NEWIDLE : 
str : 					| 0*SD_BALANCE_EXEC
strstr : INIT : 					| 0*SD_BALANCE_EXEC : 
strstr : if : 					| 0*SD_BALANCE_EXEC : 
strstr : for : 					| 0*SD_BALANCE_EXEC : 
strstr : while : 					| 0*SD_BALANCE_EXEC : 
str : 					| 0*SD_BALANCE_FORK
strstr : INIT : 					| 0*SD_BALANCE_FORK : 
strstr : if : 					| 0*SD_BALANCE_FORK : 
strstr : for : 					| 0*SD_BALANCE_FORK : 
strstr : while : 					| 0*SD_BALANCE_FORK : 
str : 					| 0*SD_BALANCE_WAKE
strstr : INIT : 					| 0*SD_BALANCE_WAKE : 
strstr : if : 					| 0*SD_BALANCE_WAKE : 
strstr : for : 					| 0*SD_BALANCE_WAKE : 
strstr : while : 					| 0*SD_BALANCE_WAKE : 
str : 					| 0*SD_WAKE_AFFINE
strstr : INIT : 					| 0*SD_WAKE_AFFINE : 
strstr : if : 					| 0*SD_WAKE_AFFINE : 
strstr : for : 					| 0*SD_WAKE_AFFINE : 
strstr : while : 					| 0*SD_WAKE_AFFINE : 
str : 					| 0*SD_SHARE_CPUPOWER
strstr : INIT : 					| 0*SD_SHARE_CPUPOWER : 
strstr : if : 					| 0*SD_SHARE_CPUPOWER : 
strstr : for : 					| 0*SD_SHARE_CPUPOWER : 
strstr : while : 					| 0*SD_SHARE_CPUPOWER : 
str : 					| 0*SD_SHARE_PKG_RESOURCES
strstr : INIT : 					| 0*SD_SHARE_PKG_RESOURCES : 
strstr : if : 					| 0*SD_SHARE_PKG_RESOURCES : 
strstr : for : 					| 0*SD_SHARE_PKG_RESOURCES : 
strstr : while : 					| 0*SD_SHARE_PKG_RESOURCES : 
str : 					| 1*SD_SERIALIZE
strstr : INIT : 					| 1*SD_SERIALIZE : 
strstr : if : 					| 1*SD_SERIALIZE : 
strstr : for : 					| 1*SD_SERIALIZE : 
strstr : while : 					| 1*SD_SERIALIZE : 
str : 					| 0*SD_PREFER_SIBLING
strstr : INIT : 					| 0*SD_PREFER_SIBLING : 
strstr : if : 					| 0*SD_PREFER_SIBLING : 
strstr : for : 					| 0*SD_PREFER_SIBLING : 
strstr : while : 					| 0*SD_PREFER_SIBLING : 
str : 					| 1*SD_NUMA
strstr : INIT : 					| 1*SD_NUMA : 
strstr : if : 					| 1*SD_NUMA : 
strstr : for : 					| 1*SD_NUMA : 
strstr : while : 					| 1*SD_NUMA : 
str : 					| sd_local_flags(level)
strstr : INIT : 					| sd_local_flags(level) : 
strstr : if : 					| sd_local_flags(level) : 
strstr : for : 					| sd_local_flags(level) : 
strstr : while : 					| sd_local_flags(level) : 
str : 					,
strstr : INIT : 					, : 
strstr : if : 					, : 
strstr : for : 					, : 
strstr : while : 					, : 
str : 		.last_balance		= jiffies,
strstr : INIT : 		.last_balance		= jiffies, : 
strstr : if : 		.last_balance		= jiffies, : 
strstr : for : 		.last_balance		= jiffies, : 
strstr : while : 		.last_balance		= jiffies, : 
str : 		.balance_interval	= sd_weight,
strstr : INIT : 		.balance_interval	= sd_weight, : 
strstr : if : 		.balance_interval	= sd_weight, : 
strstr : for : 		.balance_interval	= sd_weight, : 
strstr : while : 		.balance_interval	= sd_weight, : 
str : 	};
strstr : INIT : 	}; : 
strstr : if : 	}; : 
strstr : for : 	}; : 
strstr : while : 	}; : 
str : 	SD_INIT_NAME(sd, NUMA);
strstr : INIT : 	SD_INIT_NAME(sd, NUMA); : 
strstr : if : 	SD_INIT_NAME(sd, NUMA); : 
strstr : for : 	SD_INIT_NAME(sd, NUMA); : 
strstr : while : 	SD_INIT_NAME(sd, NUMA); : 
str : 	sd->private = &tl->data;
strstr : INIT : 	sd->private = &tl->data; : 
strstr : if : 	sd->private = &tl->data; : 
strstr : for : 	sd->private = &tl->data; : 
strstr : while : 	sd->private = &tl->data; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	/*
strstr : if : 	/* : 
strstr : for : 	/* : 
strstr : while : 	/* : 
str : 	 * Ugly hack to pass state to sd_numa_mask()...
strstr : INIT : 	 * Ugly hack to pass state to sd_numa_mask()... : 
strstr : if : 	 * Ugly hack to pass state to sd_numa_mask()... : 
strstr : for : 	 * Ugly hack to pass state to sd_numa_mask()... : 
strstr : while : 	 * Ugly hack to pass state to sd_numa_mask()... : 
str : 	 */
strstr : INIT : 	 */ : 
strstr : if : 	 */ : 
strstr : for : 	 */ : 
strstr : while : 	 */ : 
str : 	sched_domains_curr_level = tl->numa_level;
strstr : INIT : 	sched_domains_curr_level = tl->numa_level; : 
strstr : if : 	sched_domains_curr_level = tl->numa_level; : 
strstr : for : 	sched_domains_curr_level = tl->numa_level; : 
strstr : while : 	sched_domains_curr_level = tl->numa_level; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	return sd;
strstr : if : 	return sd; : 
strstr : for : 	return sd; : 
strstr : while : 	return sd; : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : static const struct cpumask *sd_numa_mask(int cpu)
strstr : if : static const struct cpumask *sd_numa_mask(int cpu) : 
strstr : for : static const struct cpumask *sd_numa_mask(int cpu) : 
strstr : while : static const struct cpumask *sd_numa_mask(int cpu) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	return sched_domains_numa_masks[sched_domains_curr_level][cpu_to_node(cpu)];
strstr : INIT : 	return sched_domains_numa_masks[sched_domains_curr_level][cpu_to_node(cpu)]; : 
strstr : if : 	return sched_domains_numa_masks[sched_domains_curr_level][cpu_to_node(cpu)]; : 
strstr : for : 	return sched_domains_numa_masks[sched_domains_curr_level][cpu_to_node(cpu)]; : 
strstr : while : 	return sched_domains_numa_masks[sched_domains_curr_level][cpu_to_node(cpu)]; : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : static void sched_numa_warn(const char *str)
strstr : if : static void sched_numa_warn(const char *str) : 
strstr : for : static void sched_numa_warn(const char *str) : 
strstr : while : static void sched_numa_warn(const char *str) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	static int done = false;
strstr : INIT : 	static int done = false; : 
strstr : if : 	static int done = false; : 
strstr : for : 	static int done = false; : 
strstr : while : 	static int done = false; : 
str : 	int i,j;
strstr : INIT : 	int i,j; : 
strstr : if : 	int i,j; : 
strstr : for : 	int i,j; : 
strstr : while : 	int i,j; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	if (done)
strstr : if : 	if (done) : 
strstr : for : 	if (done) : 
strstr : while : 	if (done) : 
str : 		return;
strstr : INIT : 		return; : 
strstr : if : 		return; : 
strstr : for : 		return; : 
strstr : while : 		return; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	done = true;
strstr : if : 	done = true; : 
strstr : for : 	done = true; : 
strstr : while : 	done = true; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	printk(KERN_WARNING "ERROR: %s\n\n", str);
strstr : if : 	printk(KERN_WARNING "ERROR: %s\n\n", str); : 
strstr : for : 	printk(KERN_WARNING "ERROR: %s\n\n", str); : 
strstr : while : 	printk(KERN_WARNING "ERROR: %s\n\n", str); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	for (i = 0; i < nr_node_ids; i++) {
strstr : if : 	for (i = 0; i < nr_node_ids; i++) { : 
strstr : for : 	for (i = 0; i < nr_node_ids; i++) { : 
strstr : while : 	for (i = 0; i < nr_node_ids; i++) { : 
str : 		printk(KERN_WARNING "  ");
strstr : INIT : 		printk(KERN_WARNING "  "); : 
strstr : if : 		printk(KERN_WARNING "  "); : 
strstr : for : 		printk(KERN_WARNING "  "); : 
strstr : while : 		printk(KERN_WARNING "  "); : 
str : 		for (j = 0; j < nr_node_ids; j++)
strstr : INIT : 		for (j = 0; j < nr_node_ids; j++) : 
strstr : if : 		for (j = 0; j < nr_node_ids; j++) : 
strstr : for : 		for (j = 0; j < nr_node_ids; j++) : 
strstr : while : 		for (j = 0; j < nr_node_ids; j++) : 
str : 			printk(KERN_CONT "%02d ", node_distance(i,j));
strstr : INIT : 			printk(KERN_CONT "%02d ", node_distance(i,j)); : 
strstr : if : 			printk(KERN_CONT "%02d ", node_distance(i,j)); : 
strstr : for : 			printk(KERN_CONT "%02d ", node_distance(i,j)); : 
strstr : while : 			printk(KERN_CONT "%02d ", node_distance(i,j)); : 
str : 		printk(KERN_CONT "\n");
strstr : INIT : 		printk(KERN_CONT "\n"); : 
strstr : if : 		printk(KERN_CONT "\n"); : 
strstr : for : 		printk(KERN_CONT "\n"); : 
strstr : while : 		printk(KERN_CONT "\n"); : 
str : 	}
strstr : INIT : 	} : 
strstr : if : 	} : 
strstr : for : 	} : 
strstr : while : 	} : 
str : 	printk(KERN_WARNING "\n");
strstr : INIT : 	printk(KERN_WARNING "\n"); : 
strstr : if : 	printk(KERN_WARNING "\n"); : 
strstr : for : 	printk(KERN_WARNING "\n"); : 
strstr : while : 	printk(KERN_WARNING "\n"); : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : static bool find_numa_distance(int distance)
strstr : if : static bool find_numa_distance(int distance) : 
strstr : for : static bool find_numa_distance(int distance) : 
strstr : while : static bool find_numa_distance(int distance) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	int i;
strstr : INIT : 	int i; : 
strstr : if : 	int i; : 
strstr : for : 	int i; : 
strstr : while : 	int i; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	if (distance == node_distance(0, 0))
strstr : if : 	if (distance == node_distance(0, 0)) : 
strstr : for : 	if (distance == node_distance(0, 0)) : 
strstr : while : 	if (distance == node_distance(0, 0)) : 
str : 		return true;
strstr : INIT : 		return true; : 
strstr : if : 		return true; : 
strstr : for : 		return true; : 
strstr : while : 		return true; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	for (i = 0; i < sched_domains_numa_levels; i++) {
strstr : if : 	for (i = 0; i < sched_domains_numa_levels; i++) { : 
strstr : for : 	for (i = 0; i < sched_domains_numa_levels; i++) { : 
strstr : while : 	for (i = 0; i < sched_domains_numa_levels; i++) { : 
str : 		if (sched_domains_numa_distance[i] == distance)
strstr : INIT : 		if (sched_domains_numa_distance[i] == distance) : 
strstr : if : 		if (sched_domains_numa_distance[i] == distance) : 
strstr : for : 		if (sched_domains_numa_distance[i] == distance) : 
strstr : while : 		if (sched_domains_numa_distance[i] == distance) : 
str : 			return true;
strstr : INIT : 			return true; : 
strstr : if : 			return true; : 
strstr : for : 			return true; : 
strstr : while : 			return true; : 
str : 	}
strstr : INIT : 	} : 
strstr : if : 	} : 
strstr : for : 	} : 
strstr : while : 	} : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	return false;
strstr : if : 	return false; : 
strstr : for : 	return false; : 
strstr : while : 	return false; : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : static void sched_init_numa(void)
strstr : if : static void sched_init_numa(void) : 
strstr : for : static void sched_init_numa(void) : 
strstr : while : static void sched_init_numa(void) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	int next_distance, curr_distance = node_distance(0, 0);
strstr : INIT : 	int next_distance, curr_distance = node_distance(0, 0); : 
strstr : if : 	int next_distance, curr_distance = node_distance(0, 0); : 
strstr : for : 	int next_distance, curr_distance = node_distance(0, 0); : 
strstr : while : 	int next_distance, curr_distance = node_distance(0, 0); : 
str : 	struct sched_domain_topology_level *tl;
strstr : INIT : 	struct sched_domain_topology_level *tl; : 
strstr : if : 	struct sched_domain_topology_level *tl; : 
strstr : for : 	struct sched_domain_topology_level *tl; : 
strstr : while : 	struct sched_domain_topology_level *tl; : 
str : 	int level = 0;
strstr : INIT : 	int level = 0; : 
strstr : if : 	int level = 0; : 
strstr : for : 	int level = 0; : 
strstr : while : 	int level = 0; : 
str : 	int i, j, k;
strstr : INIT : 	int i, j, k; : 
strstr : if : 	int i, j, k; : 
strstr : for : 	int i, j, k; : 
strstr : while : 	int i, j, k; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	sched_domains_numa_distance = kzalloc(sizeof(int) * nr_node_ids, GFP_KERNEL);
strstr : if : 	sched_domains_numa_distance = kzalloc(sizeof(int) * nr_node_ids, GFP_KERNEL); : 
strstr : for : 	sched_domains_numa_distance = kzalloc(sizeof(int) * nr_node_ids, GFP_KERNEL); : 
strstr : while : 	sched_domains_numa_distance = kzalloc(sizeof(int) * nr_node_ids, GFP_KERNEL); : 
str : 	if (!sched_domains_numa_distance)
strstr : INIT : 	if (!sched_domains_numa_distance) : 
strstr : if : 	if (!sched_domains_numa_distance) : 
strstr : for : 	if (!sched_domains_numa_distance) : 
strstr : while : 	if (!sched_domains_numa_distance) : 
str : 		return;
strstr : INIT : 		return; : 
strstr : if : 		return; : 
strstr : for : 		return; : 
strstr : while : 		return; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	/*
strstr : if : 	/* : 
strstr : for : 	/* : 
strstr : while : 	/* : 
str : 	 * O(nr_nodes^2) deduplicating selection sort -- in order to find the
strstr : INIT : 	 * O(nr_nodes^2) deduplicating selection sort -- in order to find the : 
strstr : if : 	 * O(nr_nodes^2) deduplicating selection sort -- in order to find the : 
strstr : for : 	 * O(nr_nodes^2) deduplicating selection sort -- in order to find the : 
strstr : while : 	 * O(nr_nodes^2) deduplicating selection sort -- in order to find the : 
str : 	 * unique distances in the node_distance() table.
strstr : INIT : 	 * unique distances in the node_distance() table. : 
strstr : if : 	 * unique distances in the node_distance() table. : 
strstr : for : 	 * unique distances in the node_distance() table. : 
strstr : while : 	 * unique distances in the node_distance() table. : 
str : 	 *
strstr : INIT : 	 * : 
strstr : if : 	 * : 
strstr : for : 	 * : 
strstr : while : 	 * : 
str : 	 * Assumes node_distance(0,j) includes all distances in
strstr : INIT : 	 * Assumes node_distance(0,j) includes all distances in : 
strstr : if : 	 * Assumes node_distance(0,j) includes all distances in : 
strstr : for : 	 * Assumes node_distance(0,j) includes all distances in : 
strstr : while : 	 * Assumes node_distance(0,j) includes all distances in : 
str : 	 * node_distance(i,j) in order to avoid cubic time.
strstr : INIT : 	 * node_distance(i,j) in order to avoid cubic time. : 
strstr : if : 	 * node_distance(i,j) in order to avoid cubic time. : 
strstr : for : 	 * node_distance(i,j) in order to avoid cubic time. : 
strstr : while : 	 * node_distance(i,j) in order to avoid cubic time. : 
str : 	 */
strstr : INIT : 	 */ : 
strstr : if : 	 */ : 
strstr : for : 	 */ : 
strstr : while : 	 */ : 
str : 	next_distance = curr_distance;
strstr : INIT : 	next_distance = curr_distance; : 
strstr : if : 	next_distance = curr_distance; : 
strstr : for : 	next_distance = curr_distance; : 
strstr : while : 	next_distance = curr_distance; : 
str : 	for (i = 0; i < nr_node_ids; i++) {
strstr : INIT : 	for (i = 0; i < nr_node_ids; i++) { : 
strstr : if : 	for (i = 0; i < nr_node_ids; i++) { : 
strstr : for : 	for (i = 0; i < nr_node_ids; i++) { : 
strstr : while : 	for (i = 0; i < nr_node_ids; i++) { : 
str : 		for (j = 0; j < nr_node_ids; j++) {
strstr : INIT : 		for (j = 0; j < nr_node_ids; j++) { : 
strstr : if : 		for (j = 0; j < nr_node_ids; j++) { : 
strstr : for : 		for (j = 0; j < nr_node_ids; j++) { : 
strstr : while : 		for (j = 0; j < nr_node_ids; j++) { : 
str : 			for (k = 0; k < nr_node_ids; k++) {
strstr : INIT : 			for (k = 0; k < nr_node_ids; k++) { : 
strstr : if : 			for (k = 0; k < nr_node_ids; k++) { : 
strstr : for : 			for (k = 0; k < nr_node_ids; k++) { : 
strstr : while : 			for (k = 0; k < nr_node_ids; k++) { : 
str : 				int distance = node_distance(i, k);
strstr : INIT : 				int distance = node_distance(i, k); : 
strstr : if : 				int distance = node_distance(i, k); : 
strstr : for : 				int distance = node_distance(i, k); : 
strstr : while : 				int distance = node_distance(i, k); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 				if (distance > curr_distance &&
strstr : if : 				if (distance > curr_distance && : 
strstr : for : 				if (distance > curr_distance && : 
strstr : while : 				if (distance > curr_distance && : 
str : 				    (distance < next_distance ||
strstr : INIT : 				    (distance < next_distance || : 
strstr : if : 				    (distance < next_distance || : 
strstr : for : 				    (distance < next_distance || : 
strstr : while : 				    (distance < next_distance || : 
str : 				     next_distance == curr_distance))
strstr : INIT : 				     next_distance == curr_distance)) : 
strstr : if : 				     next_distance == curr_distance)) : 
strstr : for : 				     next_distance == curr_distance)) : 
strstr : while : 				     next_distance == curr_distance)) : 
str : 					next_distance = distance;
strstr : INIT : 					next_distance = distance; : 
strstr : if : 					next_distance = distance; : 
strstr : for : 					next_distance = distance; : 
strstr : while : 					next_distance = distance; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 				/*
strstr : if : 				/* : 
strstr : for : 				/* : 
strstr : while : 				/* : 
str : 				 * While not a strong assumption it would be nice to know
strstr : INIT : 				 * While not a strong assumption it would be nice to know : 
strstr : if : 				 * While not a strong assumption it would be nice to know : 
strstr : for : 				 * While not a strong assumption it would be nice to know : 
strstr : while : 				 * While not a strong assumption it would be nice to know : 
str : 				 * about cases where if node A is connected to B, B is not
strstr : INIT : 				 * about cases where if node A is connected to B, B is not : 
strstr : if : 				 * about cases where if node A is connected to B, B is not : 
strstr : for : 				 * about cases where if node A is connected to B, B is not : 
strstr : while : 				 * about cases where if node A is connected to B, B is not : 
str : 				 * equally connected to A.
strstr : INIT : 				 * equally connected to A. : 
strstr : if : 				 * equally connected to A. : 
strstr : for : 				 * equally connected to A. : 
strstr : while : 				 * equally connected to A. : 
str : 				 */
strstr : INIT : 				 */ : 
strstr : if : 				 */ : 
strstr : for : 				 */ : 
strstr : while : 				 */ : 
str : 				if (sched_debug() && node_distance(k, i) != distance)
strstr : INIT : 				if (sched_debug() && node_distance(k, i) != distance) : 
strstr : if : 				if (sched_debug() && node_distance(k, i) != distance) : 
strstr : for : 				if (sched_debug() && node_distance(k, i) != distance) : 
strstr : while : 				if (sched_debug() && node_distance(k, i) != distance) : 
str : 					sched_numa_warn("Node-distance not symmetric");
strstr : INIT : 					sched_numa_warn("Node-distance not symmetric"); : 
strstr : if : 					sched_numa_warn("Node-distance not symmetric"); : 
strstr : for : 					sched_numa_warn("Node-distance not symmetric"); : 
strstr : while : 					sched_numa_warn("Node-distance not symmetric"); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 				if (sched_debug() && i && !find_numa_distance(distance))
strstr : if : 				if (sched_debug() && i && !find_numa_distance(distance)) : 
strstr : for : 				if (sched_debug() && i && !find_numa_distance(distance)) : 
strstr : while : 				if (sched_debug() && i && !find_numa_distance(distance)) : 
str : 					sched_numa_warn("Node-0 not representative");
strstr : INIT : 					sched_numa_warn("Node-0 not representative"); : 
strstr : if : 					sched_numa_warn("Node-0 not representative"); : 
strstr : for : 					sched_numa_warn("Node-0 not representative"); : 
strstr : while : 					sched_numa_warn("Node-0 not representative"); : 
str : 			}
strstr : INIT : 			} : 
strstr : if : 			} : 
strstr : for : 			} : 
strstr : while : 			} : 
str : 			if (next_distance != curr_distance) {
strstr : INIT : 			if (next_distance != curr_distance) { : 
strstr : if : 			if (next_distance != curr_distance) { : 
strstr : for : 			if (next_distance != curr_distance) { : 
strstr : while : 			if (next_distance != curr_distance) { : 
str : 				sched_domains_numa_distance[level++] = next_distance;
strstr : INIT : 				sched_domains_numa_distance[level++] = next_distance; : 
strstr : if : 				sched_domains_numa_distance[level++] = next_distance; : 
strstr : for : 				sched_domains_numa_distance[level++] = next_distance; : 
strstr : while : 				sched_domains_numa_distance[level++] = next_distance; : 
str : 				sched_domains_numa_levels = level;
strstr : INIT : 				sched_domains_numa_levels = level; : 
strstr : if : 				sched_domains_numa_levels = level; : 
strstr : for : 				sched_domains_numa_levels = level; : 
strstr : while : 				sched_domains_numa_levels = level; : 
str : 				curr_distance = next_distance;
strstr : INIT : 				curr_distance = next_distance; : 
strstr : if : 				curr_distance = next_distance; : 
strstr : for : 				curr_distance = next_distance; : 
strstr : while : 				curr_distance = next_distance; : 
str : 			} else break;
strstr : INIT : 			} else break; : 
strstr : if : 			} else break; : 
strstr : for : 			} else break; : 
strstr : while : 			} else break; : 
str : 		}
strstr : INIT : 		} : 
strstr : if : 		} : 
strstr : for : 		} : 
strstr : while : 		} : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 		/*
strstr : if : 		/* : 
strstr : for : 		/* : 
strstr : while : 		/* : 
str : 		 * In case of sched_debug() we verify the above assumption.
strstr : INIT : 		 * In case of sched_debug() we verify the above assumption. : 
strstr : if : 		 * In case of sched_debug() we verify the above assumption. : 
strstr : for : 		 * In case of sched_debug() we verify the above assumption. : 
strstr : while : 		 * In case of sched_debug() we verify the above assumption. : 
str : 		 */
strstr : INIT : 		 */ : 
strstr : if : 		 */ : 
strstr : for : 		 */ : 
strstr : while : 		 */ : 
str : 		if (!sched_debug())
strstr : INIT : 		if (!sched_debug()) : 
strstr : if : 		if (!sched_debug()) : 
strstr : for : 		if (!sched_debug()) : 
strstr : while : 		if (!sched_debug()) : 
str : 			break;
strstr : INIT : 			break; : 
strstr : if : 			break; : 
strstr : for : 			break; : 
strstr : while : 			break; : 
str : 	}
strstr : INIT : 	} : 
strstr : if : 	} : 
strstr : for : 	} : 
strstr : while : 	} : 
str : 	/*
strstr : INIT : 	/* : 
strstr : if : 	/* : 
strstr : for : 	/* : 
strstr : while : 	/* : 
str : 	 * 'level' contains the number of unique distances, excluding the
strstr : INIT : 	 * 'level' contains the number of unique distances, excluding the : 
strstr : if : 	 * 'level' contains the number of unique distances, excluding the : 
strstr : for : 	 * 'level' contains the number of unique distances, excluding the : 
strstr : while : 	 * 'level' contains the number of unique distances, excluding the : 
str : 	 * identity distance node_distance(i,i).
strstr : INIT : 	 * identity distance node_distance(i,i). : 
strstr : if : 	 * identity distance node_distance(i,i). : 
strstr : for : 	 * identity distance node_distance(i,i). : 
strstr : while : 	 * identity distance node_distance(i,i). : 
str : 	 *
strstr : INIT : 	 * : 
strstr : if : 	 * : 
strstr : for : 	 * : 
strstr : while : 	 * : 
str : 	 * The sched_domains_numa_distance[] array includes the actual distance
strstr : INIT : 	 * The sched_domains_numa_distance[] array includes the actual distance : 
strstr : if : 	 * The sched_domains_numa_distance[] array includes the actual distance : 
strstr : for : 	 * The sched_domains_numa_distance[] array includes the actual distance : 
strstr : while : 	 * The sched_domains_numa_distance[] array includes the actual distance : 
str : 	 * numbers.
strstr : INIT : 	 * numbers. : 
strstr : if : 	 * numbers. : 
strstr : for : 	 * numbers. : 
strstr : while : 	 * numbers. : 
str : 	 */
strstr : INIT : 	 */ : 
strstr : if : 	 */ : 
strstr : for : 	 */ : 
strstr : while : 	 */ : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	/*
strstr : if : 	/* : 
strstr : for : 	/* : 
strstr : while : 	/* : 
str : 	 * Here, we should temporarily reset sched_domains_numa_levels to 0.
strstr : INIT : 	 * Here, we should temporarily reset sched_domains_numa_levels to 0. : 
strstr : if : 	 * Here, we should temporarily reset sched_domains_numa_levels to 0. : 
strstr : for : 	 * Here, we should temporarily reset sched_domains_numa_levels to 0. : 
strstr : while : 	 * Here, we should temporarily reset sched_domains_numa_levels to 0. : 
str : 	 * If it fails to allocate memory for array sched_domains_numa_masks[][],
strstr : INIT : 	 * If it fails to allocate memory for array sched_domains_numa_masks[][], : 
strstr : if : 	 * If it fails to allocate memory for array sched_domains_numa_masks[][], : 
strstr : for : 	 * If it fails to allocate memory for array sched_domains_numa_masks[][], : 
strstr : while : 	 * If it fails to allocate memory for array sched_domains_numa_masks[][], : 
str : 	 * the array will contain less then 'level' members. This could be
strstr : INIT : 	 * the array will contain less then 'level' members. This could be : 
strstr : if : 	 * the array will contain less then 'level' members. This could be : 
strstr : for : 	 * the array will contain less then 'level' members. This could be : 
strstr : while : 	 * the array will contain less then 'level' members. This could be : 
str : 	 * dangerous when we use it to iterate array sched_domains_numa_masks[][]
strstr : INIT : 	 * dangerous when we use it to iterate array sched_domains_numa_masks[][] : 
strstr : if : 	 * dangerous when we use it to iterate array sched_domains_numa_masks[][] : 
strstr : for : 	 * dangerous when we use it to iterate array sched_domains_numa_masks[][] : 
strstr : while : 	 * dangerous when we use it to iterate array sched_domains_numa_masks[][] : 
str : 	 * in other functions.
strstr : INIT : 	 * in other functions. : 
strstr : if : 	 * in other functions. : 
strstr : for : 	 * in other functions. : 
strstr : while : 	 * in other functions. : 
str : 	 *
strstr : INIT : 	 * : 
strstr : if : 	 * : 
strstr : for : 	 * : 
strstr : while : 	 * : 
str : 	 * We reset it to 'level' at the end of this function.
strstr : INIT : 	 * We reset it to 'level' at the end of this function. : 
strstr : if : 	 * We reset it to 'level' at the end of this function. : 
strstr : for : 	 * We reset it to 'level' at the end of this function. : 
strstr : while : 	 * We reset it to 'level' at the end of this function. : 
str : 	 */
strstr : INIT : 	 */ : 
strstr : if : 	 */ : 
strstr : for : 	 */ : 
strstr : while : 	 */ : 
str : 	sched_domains_numa_levels = 0;
strstr : INIT : 	sched_domains_numa_levels = 0; : 
strstr : if : 	sched_domains_numa_levels = 0; : 
strstr : for : 	sched_domains_numa_levels = 0; : 
strstr : while : 	sched_domains_numa_levels = 0; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	sched_domains_numa_masks = kzalloc(sizeof(void *) * level, GFP_KERNEL);
strstr : if : 	sched_domains_numa_masks = kzalloc(sizeof(void *) * level, GFP_KERNEL); : 
strstr : for : 	sched_domains_numa_masks = kzalloc(sizeof(void *) * level, GFP_KERNEL); : 
strstr : while : 	sched_domains_numa_masks = kzalloc(sizeof(void *) * level, GFP_KERNEL); : 
str : 	if (!sched_domains_numa_masks)
strstr : INIT : 	if (!sched_domains_numa_masks) : 
strstr : if : 	if (!sched_domains_numa_masks) : 
strstr : for : 	if (!sched_domains_numa_masks) : 
strstr : while : 	if (!sched_domains_numa_masks) : 
str : 		return;
strstr : INIT : 		return; : 
strstr : if : 		return; : 
strstr : for : 		return; : 
strstr : while : 		return; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	/*
strstr : if : 	/* : 
strstr : for : 	/* : 
strstr : while : 	/* : 
str : 	 * Now for each level, construct a mask per node which contains all
strstr : INIT : 	 * Now for each level, construct a mask per node which contains all : 
strstr : if : 	 * Now for each level, construct a mask per node which contains all : 
strstr : for : 	 * Now for each level, construct a mask per node which contains all : 
strstr : while : 	 * Now for each level, construct a mask per node which contains all : 
str : 	 * cpus of nodes that are that many hops away from us.
strstr : INIT : 	 * cpus of nodes that are that many hops away from us. : 
strstr : if : 	 * cpus of nodes that are that many hops away from us. : 
strstr : for : 	 * cpus of nodes that are that many hops away from us. : 
strstr : while : 	 * cpus of nodes that are that many hops away from us. : 
str : 	 */
strstr : INIT : 	 */ : 
strstr : if : 	 */ : 
strstr : for : 	 */ : 
strstr : while : 	 */ : 
str : 	for (i = 0; i < level; i++) {
strstr : INIT : 	for (i = 0; i < level; i++) { : 
strstr : if : 	for (i = 0; i < level; i++) { : 
strstr : for : 	for (i = 0; i < level; i++) { : 
strstr : while : 	for (i = 0; i < level; i++) { : 
str : 		sched_domains_numa_masks[i] =
strstr : INIT : 		sched_domains_numa_masks[i] = : 
strstr : if : 		sched_domains_numa_masks[i] = : 
strstr : for : 		sched_domains_numa_masks[i] = : 
strstr : while : 		sched_domains_numa_masks[i] = : 
str : 			kzalloc(nr_node_ids * sizeof(void *), GFP_KERNEL);
strstr : INIT : 			kzalloc(nr_node_ids * sizeof(void *), GFP_KERNEL); : 
strstr : if : 			kzalloc(nr_node_ids * sizeof(void *), GFP_KERNEL); : 
strstr : for : 			kzalloc(nr_node_ids * sizeof(void *), GFP_KERNEL); : 
strstr : while : 			kzalloc(nr_node_ids * sizeof(void *), GFP_KERNEL); : 
str : 		if (!sched_domains_numa_masks[i])
strstr : INIT : 		if (!sched_domains_numa_masks[i]) : 
strstr : if : 		if (!sched_domains_numa_masks[i]) : 
strstr : for : 		if (!sched_domains_numa_masks[i]) : 
strstr : while : 		if (!sched_domains_numa_masks[i]) : 
str : 			return;
strstr : INIT : 			return; : 
strstr : if : 			return; : 
strstr : for : 			return; : 
strstr : while : 			return; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 		for (j = 0; j < nr_node_ids; j++) {
strstr : if : 		for (j = 0; j < nr_node_ids; j++) { : 
strstr : for : 		for (j = 0; j < nr_node_ids; j++) { : 
strstr : while : 		for (j = 0; j < nr_node_ids; j++) { : 
str : 			struct cpumask *mask = kzalloc(cpumask_size(), GFP_KERNEL);
strstr : INIT : 			struct cpumask *mask = kzalloc(cpumask_size(), GFP_KERNEL); : 
strstr : if : 			struct cpumask *mask = kzalloc(cpumask_size(), GFP_KERNEL); : 
strstr : for : 			struct cpumask *mask = kzalloc(cpumask_size(), GFP_KERNEL); : 
strstr : while : 			struct cpumask *mask = kzalloc(cpumask_size(), GFP_KERNEL); : 
str : 			if (!mask)
strstr : INIT : 			if (!mask) : 
strstr : if : 			if (!mask) : 
strstr : for : 			if (!mask) : 
strstr : while : 			if (!mask) : 
str : 				return;
strstr : INIT : 				return; : 
strstr : if : 				return; : 
strstr : for : 				return; : 
strstr : while : 				return; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 			sched_domains_numa_masks[i][j] = mask;
strstr : if : 			sched_domains_numa_masks[i][j] = mask; : 
strstr : for : 			sched_domains_numa_masks[i][j] = mask; : 
strstr : while : 			sched_domains_numa_masks[i][j] = mask; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 			for (k = 0; k < nr_node_ids; k++) {
strstr : if : 			for (k = 0; k < nr_node_ids; k++) { : 
strstr : for : 			for (k = 0; k < nr_node_ids; k++) { : 
strstr : while : 			for (k = 0; k < nr_node_ids; k++) { : 
str : 				if (node_distance(j, k) > sched_domains_numa_distance[i])
strstr : INIT : 				if (node_distance(j, k) > sched_domains_numa_distance[i]) : 
strstr : if : 				if (node_distance(j, k) > sched_domains_numa_distance[i]) : 
strstr : for : 				if (node_distance(j, k) > sched_domains_numa_distance[i]) : 
strstr : while : 				if (node_distance(j, k) > sched_domains_numa_distance[i]) : 
str : 					continue;
strstr : INIT : 					continue; : 
strstr : if : 					continue; : 
strstr : for : 					continue; : 
strstr : while : 					continue; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 				cpumask_or(mask, mask, cpumask_of_node(k));
strstr : if : 				cpumask_or(mask, mask, cpumask_of_node(k)); : 
strstr : for : 				cpumask_or(mask, mask, cpumask_of_node(k)); : 
strstr : while : 				cpumask_or(mask, mask, cpumask_of_node(k)); : 
str : 			}
strstr : INIT : 			} : 
strstr : if : 			} : 
strstr : for : 			} : 
strstr : while : 			} : 
str : 		}
strstr : INIT : 		} : 
strstr : if : 		} : 
strstr : for : 		} : 
strstr : while : 		} : 
str : 	}
strstr : INIT : 	} : 
strstr : if : 	} : 
strstr : for : 	} : 
strstr : while : 	} : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	tl = kzalloc((ARRAY_SIZE(default_topology) + level) *
strstr : if : 	tl = kzalloc((ARRAY_SIZE(default_topology) + level) * : 
strstr : for : 	tl = kzalloc((ARRAY_SIZE(default_topology) + level) * : 
strstr : while : 	tl = kzalloc((ARRAY_SIZE(default_topology) + level) * : 
str : 			sizeof(struct sched_domain_topology_level), GFP_KERNEL);
strstr : INIT : 			sizeof(struct sched_domain_topology_level), GFP_KERNEL); : 
strstr : if : 			sizeof(struct sched_domain_topology_level), GFP_KERNEL); : 
strstr : for : 			sizeof(struct sched_domain_topology_level), GFP_KERNEL); : 
strstr : while : 			sizeof(struct sched_domain_topology_level), GFP_KERNEL); : 
str : 	if (!tl)
strstr : INIT : 	if (!tl) : 
strstr : if : 	if (!tl) : 
strstr : for : 	if (!tl) : 
strstr : while : 	if (!tl) : 
str : 		return;
strstr : INIT : 		return; : 
strstr : if : 		return; : 
strstr : for : 		return; : 
strstr : while : 		return; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	/*
strstr : if : 	/* : 
strstr : for : 	/* : 
strstr : while : 	/* : 
str : 	 * Copy the default topology bits..
strstr : INIT : 	 * Copy the default topology bits.. : 
strstr : if : 	 * Copy the default topology bits.. : 
strstr : for : 	 * Copy the default topology bits.. : 
strstr : while : 	 * Copy the default topology bits.. : 
str : 	 */
strstr : INIT : 	 */ : 
strstr : if : 	 */ : 
strstr : for : 	 */ : 
strstr : while : 	 */ : 
str : 	for (i = 0; default_topology[i].init; i++)
strstr : INIT : 	for (i = 0; default_topology[i].init; i++) : 
strstr : if : 	for (i = 0; default_topology[i].init; i++) : 
strstr : for : 	for (i = 0; default_topology[i].init; i++) : 
strstr : while : 	for (i = 0; default_topology[i].init; i++) : 
str : 		tl[i] = default_topology[i];
strstr : INIT : 		tl[i] = default_topology[i]; : 
strstr : if : 		tl[i] = default_topology[i]; : 
strstr : for : 		tl[i] = default_topology[i]; : 
strstr : while : 		tl[i] = default_topology[i]; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	/*
strstr : if : 	/* : 
strstr : for : 	/* : 
strstr : while : 	/* : 
str : 	 * .. and append 'j' levels of NUMA goodness.
strstr : INIT : 	 * .. and append 'j' levels of NUMA goodness. : 
strstr : if : 	 * .. and append 'j' levels of NUMA goodness. : 
strstr : for : 	 * .. and append 'j' levels of NUMA goodness. : 
strstr : while : 	 * .. and append 'j' levels of NUMA goodness. : 
str : 	 */
strstr : INIT : 	 */ : 
strstr : if : 	 */ : 
strstr : for : 	 */ : 
strstr : while : 	 */ : 
str : 	for (j = 0; j < level; i++, j++) {
strstr : INIT : 	for (j = 0; j < level; i++, j++) { : 
strstr : if : 	for (j = 0; j < level; i++, j++) { : 
strstr : for : 	for (j = 0; j < level; i++, j++) { : 
strstr : while : 	for (j = 0; j < level; i++, j++) { : 
str : 		tl[i] = (struct sched_domain_topology_level){
strstr : INIT : 		tl[i] = (struct sched_domain_topology_level){ : 
strstr : if : 		tl[i] = (struct sched_domain_topology_level){ : 
strstr : for : 		tl[i] = (struct sched_domain_topology_level){ : 
strstr : while : 		tl[i] = (struct sched_domain_topology_level){ : 
str : 			.init = sd_numa_init,
strstr : INIT : 			.init = sd_numa_init, : 
strstr : if : 			.init = sd_numa_init, : 
strstr : for : 			.init = sd_numa_init, : 
strstr : while : 			.init = sd_numa_init, : 
str : 			.mask = sd_numa_mask,
strstr : INIT : 			.mask = sd_numa_mask, : 
strstr : if : 			.mask = sd_numa_mask, : 
strstr : for : 			.mask = sd_numa_mask, : 
strstr : while : 			.mask = sd_numa_mask, : 
str : 			.flags = SDTL_OVERLAP,
strstr : INIT : 			.flags = SDTL_OVERLAP, : 
strstr : if : 			.flags = SDTL_OVERLAP, : 
strstr : for : 			.flags = SDTL_OVERLAP, : 
strstr : while : 			.flags = SDTL_OVERLAP, : 
str : 			.numa_level = j,
strstr : INIT : 			.numa_level = j, : 
strstr : if : 			.numa_level = j, : 
strstr : for : 			.numa_level = j, : 
strstr : while : 			.numa_level = j, : 
str : 		};
strstr : INIT : 		}; : 
strstr : if : 		}; : 
strstr : for : 		}; : 
strstr : while : 		}; : 
str : 	}
strstr : INIT : 	} : 
strstr : if : 	} : 
strstr : for : 	} : 
strstr : while : 	} : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	sched_domain_topology = tl;
strstr : if : 	sched_domain_topology = tl; : 
strstr : for : 	sched_domain_topology = tl; : 
strstr : while : 	sched_domain_topology = tl; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	sched_domains_numa_levels = level;
strstr : if : 	sched_domains_numa_levels = level; : 
strstr : for : 	sched_domains_numa_levels = level; : 
strstr : while : 	sched_domains_numa_levels = level; : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : static void sched_domains_numa_masks_set(int cpu)
strstr : if : static void sched_domains_numa_masks_set(int cpu) : 
strstr : for : static void sched_domains_numa_masks_set(int cpu) : 
strstr : while : static void sched_domains_numa_masks_set(int cpu) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	int i, j;
strstr : INIT : 	int i, j; : 
strstr : if : 	int i, j; : 
strstr : for : 	int i, j; : 
strstr : while : 	int i, j; : 
str : 	int node = cpu_to_node(cpu);
strstr : INIT : 	int node = cpu_to_node(cpu); : 
strstr : if : 	int node = cpu_to_node(cpu); : 
strstr : for : 	int node = cpu_to_node(cpu); : 
strstr : while : 	int node = cpu_to_node(cpu); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	for (i = 0; i < sched_domains_numa_levels; i++) {
strstr : if : 	for (i = 0; i < sched_domains_numa_levels; i++) { : 
strstr : for : 	for (i = 0; i < sched_domains_numa_levels; i++) { : 
strstr : while : 	for (i = 0; i < sched_domains_numa_levels; i++) { : 
str : 		for (j = 0; j < nr_node_ids; j++) {
strstr : INIT : 		for (j = 0; j < nr_node_ids; j++) { : 
strstr : if : 		for (j = 0; j < nr_node_ids; j++) { : 
strstr : for : 		for (j = 0; j < nr_node_ids; j++) { : 
strstr : while : 		for (j = 0; j < nr_node_ids; j++) { : 
str : 			if (node_distance(j, node) <= sched_domains_numa_distance[i])
strstr : INIT : 			if (node_distance(j, node) <= sched_domains_numa_distance[i]) : 
strstr : if : 			if (node_distance(j, node) <= sched_domains_numa_distance[i]) : 
strstr : for : 			if (node_distance(j, node) <= sched_domains_numa_distance[i]) : 
strstr : while : 			if (node_distance(j, node) <= sched_domains_numa_distance[i]) : 
str : 				cpumask_set_cpu(cpu, sched_domains_numa_masks[i][j]);
strstr : INIT : 				cpumask_set_cpu(cpu, sched_domains_numa_masks[i][j]); : 
strstr : if : 				cpumask_set_cpu(cpu, sched_domains_numa_masks[i][j]); : 
strstr : for : 				cpumask_set_cpu(cpu, sched_domains_numa_masks[i][j]); : 
strstr : while : 				cpumask_set_cpu(cpu, sched_domains_numa_masks[i][j]); : 
str : 		}
strstr : INIT : 		} : 
strstr : if : 		} : 
strstr : for : 		} : 
strstr : while : 		} : 
str : 	}
strstr : INIT : 	} : 
strstr : if : 	} : 
strstr : for : 	} : 
strstr : while : 	} : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : static void sched_domains_numa_masks_clear(int cpu)
strstr : if : static void sched_domains_numa_masks_clear(int cpu) : 
strstr : for : static void sched_domains_numa_masks_clear(int cpu) : 
strstr : while : static void sched_domains_numa_masks_clear(int cpu) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	int i, j;
strstr : INIT : 	int i, j; : 
strstr : if : 	int i, j; : 
strstr : for : 	int i, j; : 
strstr : while : 	int i, j; : 
str : 	for (i = 0; i < sched_domains_numa_levels; i++) {
strstr : INIT : 	for (i = 0; i < sched_domains_numa_levels; i++) { : 
strstr : if : 	for (i = 0; i < sched_domains_numa_levels; i++) { : 
strstr : for : 	for (i = 0; i < sched_domains_numa_levels; i++) { : 
strstr : while : 	for (i = 0; i < sched_domains_numa_levels; i++) { : 
str : 		for (j = 0; j < nr_node_ids; j++)
strstr : INIT : 		for (j = 0; j < nr_node_ids; j++) : 
strstr : if : 		for (j = 0; j < nr_node_ids; j++) : 
strstr : for : 		for (j = 0; j < nr_node_ids; j++) : 
strstr : while : 		for (j = 0; j < nr_node_ids; j++) : 
str : 			cpumask_clear_cpu(cpu, sched_domains_numa_masks[i][j]);
strstr : INIT : 			cpumask_clear_cpu(cpu, sched_domains_numa_masks[i][j]); : 
strstr : if : 			cpumask_clear_cpu(cpu, sched_domains_numa_masks[i][j]); : 
strstr : for : 			cpumask_clear_cpu(cpu, sched_domains_numa_masks[i][j]); : 
strstr : while : 			cpumask_clear_cpu(cpu, sched_domains_numa_masks[i][j]); : 
str : 	}
strstr : INIT : 	} : 
strstr : if : 	} : 
strstr : for : 	} : 
strstr : while : 	} : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : /*
strstr : if : /* : 
strstr : for : /* : 
strstr : while : /* : 
str :  * Update sched_domains_numa_masks[level][node] array when new cpus
strstr : INIT :  * Update sched_domains_numa_masks[level][node] array when new cpus : 
strstr : if :  * Update sched_domains_numa_masks[level][node] array when new cpus : 
strstr : for :  * Update sched_domains_numa_masks[level][node] array when new cpus : 
strstr : while :  * Update sched_domains_numa_masks[level][node] array when new cpus : 
str :  * are onlined.
strstr : INIT :  * are onlined. : 
strstr : if :  * are onlined. : 
strstr : for :  * are onlined. : 
strstr : while :  * are onlined. : 
str :  */
strstr : INIT :  */ : 
strstr : if :  */ : 
strstr : for :  */ : 
strstr : while :  */ : 
str : static int sched_domains_numa_masks_update(struct notifier_block *nfb,
strstr : INIT : static int sched_domains_numa_masks_update(struct notifier_block *nfb, : 
strstr : if : static int sched_domains_numa_masks_update(struct notifier_block *nfb, : 
strstr : for : static int sched_domains_numa_masks_update(struct notifier_block *nfb, : 
strstr : while : static int sched_domains_numa_masks_update(struct notifier_block *nfb, : 
str : 					   unsigned long action,
strstr : INIT : 					   unsigned long action, : 
strstr : if : 					   unsigned long action, : 
strstr : for : 					   unsigned long action, : 
strstr : while : 					   unsigned long action, : 
str : 					   void *hcpu)
strstr : INIT : 					   void *hcpu) : 
strstr : if : 					   void *hcpu) : 
strstr : for : 					   void *hcpu) : 
strstr : while : 					   void *hcpu) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	int cpu = (long)hcpu;
strstr : INIT : 	int cpu = (long)hcpu; : 
strstr : if : 	int cpu = (long)hcpu; : 
strstr : for : 	int cpu = (long)hcpu; : 
strstr : while : 	int cpu = (long)hcpu; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	switch (action & ~CPU_TASKS_FROZEN) {
strstr : if : 	switch (action & ~CPU_TASKS_FROZEN) { : 
strstr : for : 	switch (action & ~CPU_TASKS_FROZEN) { : 
strstr : while : 	switch (action & ~CPU_TASKS_FROZEN) { : 
str : 	case CPU_ONLINE:
strstr : INIT : 	case CPU_ONLINE: : 
strstr : if : 	case CPU_ONLINE: : 
strstr : for : 	case CPU_ONLINE: : 
strstr : while : 	case CPU_ONLINE: : 
str : 		sched_domains_numa_masks_set(cpu);
strstr : INIT : 		sched_domains_numa_masks_set(cpu); : 
strstr : if : 		sched_domains_numa_masks_set(cpu); : 
strstr : for : 		sched_domains_numa_masks_set(cpu); : 
strstr : while : 		sched_domains_numa_masks_set(cpu); : 
str : 		break;
strstr : INIT : 		break; : 
strstr : if : 		break; : 
strstr : for : 		break; : 
strstr : while : 		break; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	case CPU_DEAD:
strstr : if : 	case CPU_DEAD: : 
strstr : for : 	case CPU_DEAD: : 
strstr : while : 	case CPU_DEAD: : 
str : 		sched_domains_numa_masks_clear(cpu);
strstr : INIT : 		sched_domains_numa_masks_clear(cpu); : 
strstr : if : 		sched_domains_numa_masks_clear(cpu); : 
strstr : for : 		sched_domains_numa_masks_clear(cpu); : 
strstr : while : 		sched_domains_numa_masks_clear(cpu); : 
str : 		break;
strstr : INIT : 		break; : 
strstr : if : 		break; : 
strstr : for : 		break; : 
strstr : while : 		break; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	default:
strstr : if : 	default: : 
strstr : for : 	default: : 
strstr : while : 	default: : 
str : 		return NOTIFY_DONE;
strstr : INIT : 		return NOTIFY_DONE; : 
strstr : if : 		return NOTIFY_DONE; : 
strstr : for : 		return NOTIFY_DONE; : 
strstr : while : 		return NOTIFY_DONE; : 
str : 	}
strstr : INIT : 	} : 
strstr : if : 	} : 
strstr : for : 	} : 
strstr : while : 	} : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	return NOTIFY_OK;
strstr : if : 	return NOTIFY_OK; : 
strstr : for : 	return NOTIFY_OK; : 
strstr : while : 	return NOTIFY_OK; : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : #else
strstr : INIT : #else : 
strstr : if : #else : 
strstr : for : #else : 
strstr : while : #else : 
str : static inline void sched_init_numa(void)
strstr : INIT : static inline void sched_init_numa(void) : 
strstr : if : static inline void sched_init_numa(void) : 
strstr : for : static inline void sched_init_numa(void) : 
strstr : while : static inline void sched_init_numa(void) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : static int sched_domains_numa_masks_update(struct notifier_block *nfb,
strstr : if : static int sched_domains_numa_masks_update(struct notifier_block *nfb, : 
strstr : for : static int sched_domains_numa_masks_update(struct notifier_block *nfb, : 
strstr : while : static int sched_domains_numa_masks_update(struct notifier_block *nfb, : 
str : 					   unsigned long action,
strstr : INIT : 					   unsigned long action, : 
strstr : if : 					   unsigned long action, : 
strstr : for : 					   unsigned long action, : 
strstr : while : 					   unsigned long action, : 
str : 					   void *hcpu)
strstr : INIT : 					   void *hcpu) : 
strstr : if : 					   void *hcpu) : 
strstr : for : 					   void *hcpu) : 
strstr : while : 					   void *hcpu) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	return 0;
strstr : INIT : 	return 0; : 
strstr : if : 	return 0; : 
strstr : for : 	return 0; : 
strstr : while : 	return 0; : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : #endif /* CONFIG_NUMA */
strstr : INIT : #endif /* CONFIG_NUMA */ : 
strstr : if : #endif /* CONFIG_NUMA */ : 
strstr : for : #endif /* CONFIG_NUMA */ : 
strstr : while : #endif /* CONFIG_NUMA */ : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : static int __sdt_alloc(const struct cpumask *cpu_map)
strstr : if : static int __sdt_alloc(const struct cpumask *cpu_map) : 
strstr : for : static int __sdt_alloc(const struct cpumask *cpu_map) : 
strstr : while : static int __sdt_alloc(const struct cpumask *cpu_map) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	struct sched_domain_topology_level *tl;
strstr : INIT : 	struct sched_domain_topology_level *tl; : 
strstr : if : 	struct sched_domain_topology_level *tl; : 
strstr : for : 	struct sched_domain_topology_level *tl; : 
strstr : while : 	struct sched_domain_topology_level *tl; : 
str : 	int j;
strstr : INIT : 	int j; : 
strstr : if : 	int j; : 
strstr : for : 	int j; : 
strstr : while : 	int j; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	for_each_sd_topology(tl) {
strstr : if : 	for_each_sd_topology(tl) { : 
strstr : for : 	for_each_sd_topology(tl) { : 
strstr : while : 	for_each_sd_topology(tl) { : 
str : 		struct sd_data *sdd = &tl->data;
strstr : INIT : 		struct sd_data *sdd = &tl->data; : 
strstr : if : 		struct sd_data *sdd = &tl->data; : 
strstr : for : 		struct sd_data *sdd = &tl->data; : 
strstr : while : 		struct sd_data *sdd = &tl->data; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 		sdd->sd = alloc_percpu(struct sched_domain *);
strstr : if : 		sdd->sd = alloc_percpu(struct sched_domain *); : 
strstr : for : 		sdd->sd = alloc_percpu(struct sched_domain *); : 
strstr : while : 		sdd->sd = alloc_percpu(struct sched_domain *); : 
str : 		if (!sdd->sd)
strstr : INIT : 		if (!sdd->sd) : 
strstr : if : 		if (!sdd->sd) : 
strstr : for : 		if (!sdd->sd) : 
strstr : while : 		if (!sdd->sd) : 
str : 			return -ENOMEM;
strstr : INIT : 			return -ENOMEM; : 
strstr : if : 			return -ENOMEM; : 
strstr : for : 			return -ENOMEM; : 
strstr : while : 			return -ENOMEM; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 		sdd->sg = alloc_percpu(struct sched_group *);
strstr : if : 		sdd->sg = alloc_percpu(struct sched_group *); : 
strstr : for : 		sdd->sg = alloc_percpu(struct sched_group *); : 
strstr : while : 		sdd->sg = alloc_percpu(struct sched_group *); : 
str : 		if (!sdd->sg)
strstr : INIT : 		if (!sdd->sg) : 
strstr : if : 		if (!sdd->sg) : 
strstr : for : 		if (!sdd->sg) : 
strstr : while : 		if (!sdd->sg) : 
str : 			return -ENOMEM;
strstr : INIT : 			return -ENOMEM; : 
strstr : if : 			return -ENOMEM; : 
strstr : for : 			return -ENOMEM; : 
strstr : while : 			return -ENOMEM; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 		sdd->sgp = alloc_percpu(struct sched_group_power *);
strstr : if : 		sdd->sgp = alloc_percpu(struct sched_group_power *); : 
strstr : for : 		sdd->sgp = alloc_percpu(struct sched_group_power *); : 
strstr : while : 		sdd->sgp = alloc_percpu(struct sched_group_power *); : 
str : 		if (!sdd->sgp)
strstr : INIT : 		if (!sdd->sgp) : 
strstr : if : 		if (!sdd->sgp) : 
strstr : for : 		if (!sdd->sgp) : 
strstr : while : 		if (!sdd->sgp) : 
str : 			return -ENOMEM;
strstr : INIT : 			return -ENOMEM; : 
strstr : if : 			return -ENOMEM; : 
strstr : for : 			return -ENOMEM; : 
strstr : while : 			return -ENOMEM; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 		for_each_cpu(j, cpu_map) {
strstr : if : 		for_each_cpu(j, cpu_map) { : 
strstr : for : 		for_each_cpu(j, cpu_map) { : 
strstr : while : 		for_each_cpu(j, cpu_map) { : 
str : 			struct sched_domain *sd;
strstr : INIT : 			struct sched_domain *sd; : 
strstr : if : 			struct sched_domain *sd; : 
strstr : for : 			struct sched_domain *sd; : 
strstr : while : 			struct sched_domain *sd; : 
str : 			struct sched_group *sg;
strstr : INIT : 			struct sched_group *sg; : 
strstr : if : 			struct sched_group *sg; : 
strstr : for : 			struct sched_group *sg; : 
strstr : while : 			struct sched_group *sg; : 
str : 			struct sched_group_power *sgp;
strstr : INIT : 			struct sched_group_power *sgp; : 
strstr : if : 			struct sched_group_power *sgp; : 
strstr : for : 			struct sched_group_power *sgp; : 
strstr : while : 			struct sched_group_power *sgp; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 		       	sd = kzalloc_node(sizeof(struct sched_domain) + cpumask_size(),
strstr : if : 		       	sd = kzalloc_node(sizeof(struct sched_domain) + cpumask_size(), : 
strstr : for : 		       	sd = kzalloc_node(sizeof(struct sched_domain) + cpumask_size(), : 
strstr : while : 		       	sd = kzalloc_node(sizeof(struct sched_domain) + cpumask_size(), : 
str : 					GFP_KERNEL, cpu_to_node(j));
strstr : INIT : 					GFP_KERNEL, cpu_to_node(j)); : 
strstr : if : 					GFP_KERNEL, cpu_to_node(j)); : 
strstr : for : 					GFP_KERNEL, cpu_to_node(j)); : 
strstr : while : 					GFP_KERNEL, cpu_to_node(j)); : 
str : 			if (!sd)
strstr : INIT : 			if (!sd) : 
strstr : if : 			if (!sd) : 
strstr : for : 			if (!sd) : 
strstr : while : 			if (!sd) : 
str : 				return -ENOMEM;
strstr : INIT : 				return -ENOMEM; : 
strstr : if : 				return -ENOMEM; : 
strstr : for : 				return -ENOMEM; : 
strstr : while : 				return -ENOMEM; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 			*per_cpu_ptr(sdd->sd, j) = sd;
strstr : if : 			*per_cpu_ptr(sdd->sd, j) = sd; : 
strstr : for : 			*per_cpu_ptr(sdd->sd, j) = sd; : 
strstr : while : 			*per_cpu_ptr(sdd->sd, j) = sd; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 			sg = kzalloc_node(sizeof(struct sched_group) + cpumask_size(),
strstr : if : 			sg = kzalloc_node(sizeof(struct sched_group) + cpumask_size(), : 
strstr : for : 			sg = kzalloc_node(sizeof(struct sched_group) + cpumask_size(), : 
strstr : while : 			sg = kzalloc_node(sizeof(struct sched_group) + cpumask_size(), : 
str : 					GFP_KERNEL, cpu_to_node(j));
strstr : INIT : 					GFP_KERNEL, cpu_to_node(j)); : 
strstr : if : 					GFP_KERNEL, cpu_to_node(j)); : 
strstr : for : 					GFP_KERNEL, cpu_to_node(j)); : 
strstr : while : 					GFP_KERNEL, cpu_to_node(j)); : 
str : 			if (!sg)
strstr : INIT : 			if (!sg) : 
strstr : if : 			if (!sg) : 
strstr : for : 			if (!sg) : 
strstr : while : 			if (!sg) : 
str : 				return -ENOMEM;
strstr : INIT : 				return -ENOMEM; : 
strstr : if : 				return -ENOMEM; : 
strstr : for : 				return -ENOMEM; : 
strstr : while : 				return -ENOMEM; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 			sg->next = sg;
strstr : if : 			sg->next = sg; : 
strstr : for : 			sg->next = sg; : 
strstr : while : 			sg->next = sg; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 			*per_cpu_ptr(sdd->sg, j) = sg;
strstr : if : 			*per_cpu_ptr(sdd->sg, j) = sg; : 
strstr : for : 			*per_cpu_ptr(sdd->sg, j) = sg; : 
strstr : while : 			*per_cpu_ptr(sdd->sg, j) = sg; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 			sgp = kzalloc_node(sizeof(struct sched_group_power) + cpumask_size(),
strstr : if : 			sgp = kzalloc_node(sizeof(struct sched_group_power) + cpumask_size(), : 
strstr : for : 			sgp = kzalloc_node(sizeof(struct sched_group_power) + cpumask_size(), : 
strstr : while : 			sgp = kzalloc_node(sizeof(struct sched_group_power) + cpumask_size(), : 
str : 					GFP_KERNEL, cpu_to_node(j));
strstr : INIT : 					GFP_KERNEL, cpu_to_node(j)); : 
strstr : if : 					GFP_KERNEL, cpu_to_node(j)); : 
strstr : for : 					GFP_KERNEL, cpu_to_node(j)); : 
strstr : while : 					GFP_KERNEL, cpu_to_node(j)); : 
str : 			if (!sgp)
strstr : INIT : 			if (!sgp) : 
strstr : if : 			if (!sgp) : 
strstr : for : 			if (!sgp) : 
strstr : while : 			if (!sgp) : 
str : 				return -ENOMEM;
strstr : INIT : 				return -ENOMEM; : 
strstr : if : 				return -ENOMEM; : 
strstr : for : 				return -ENOMEM; : 
strstr : while : 				return -ENOMEM; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 			*per_cpu_ptr(sdd->sgp, j) = sgp;
strstr : if : 			*per_cpu_ptr(sdd->sgp, j) = sgp; : 
strstr : for : 			*per_cpu_ptr(sdd->sgp, j) = sgp; : 
strstr : while : 			*per_cpu_ptr(sdd->sgp, j) = sgp; : 
str : 		}
strstr : INIT : 		} : 
strstr : if : 		} : 
strstr : for : 		} : 
strstr : while : 		} : 
str : 	}
strstr : INIT : 	} : 
strstr : if : 	} : 
strstr : for : 	} : 
strstr : while : 	} : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	return 0;
strstr : if : 	return 0; : 
strstr : for : 	return 0; : 
strstr : while : 	return 0; : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : static void __sdt_free(const struct cpumask *cpu_map)
strstr : if : static void __sdt_free(const struct cpumask *cpu_map) : 
strstr : for : static void __sdt_free(const struct cpumask *cpu_map) : 
strstr : while : static void __sdt_free(const struct cpumask *cpu_map) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	struct sched_domain_topology_level *tl;
strstr : INIT : 	struct sched_domain_topology_level *tl; : 
strstr : if : 	struct sched_domain_topology_level *tl; : 
strstr : for : 	struct sched_domain_topology_level *tl; : 
strstr : while : 	struct sched_domain_topology_level *tl; : 
str : 	int j;
strstr : INIT : 	int j; : 
strstr : if : 	int j; : 
strstr : for : 	int j; : 
strstr : while : 	int j; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	for_each_sd_topology(tl) {
strstr : if : 	for_each_sd_topology(tl) { : 
strstr : for : 	for_each_sd_topology(tl) { : 
strstr : while : 	for_each_sd_topology(tl) { : 
str : 		struct sd_data *sdd = &tl->data;
strstr : INIT : 		struct sd_data *sdd = &tl->data; : 
strstr : if : 		struct sd_data *sdd = &tl->data; : 
strstr : for : 		struct sd_data *sdd = &tl->data; : 
strstr : while : 		struct sd_data *sdd = &tl->data; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 		for_each_cpu(j, cpu_map) {
strstr : if : 		for_each_cpu(j, cpu_map) { : 
strstr : for : 		for_each_cpu(j, cpu_map) { : 
strstr : while : 		for_each_cpu(j, cpu_map) { : 
str : 			struct sched_domain *sd;
strstr : INIT : 			struct sched_domain *sd; : 
strstr : if : 			struct sched_domain *sd; : 
strstr : for : 			struct sched_domain *sd; : 
strstr : while : 			struct sched_domain *sd; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 			if (sdd->sd) {
strstr : if : 			if (sdd->sd) { : 
strstr : for : 			if (sdd->sd) { : 
strstr : while : 			if (sdd->sd) { : 
str : 				sd = *per_cpu_ptr(sdd->sd, j);
strstr : INIT : 				sd = *per_cpu_ptr(sdd->sd, j); : 
strstr : if : 				sd = *per_cpu_ptr(sdd->sd, j); : 
strstr : for : 				sd = *per_cpu_ptr(sdd->sd, j); : 
strstr : while : 				sd = *per_cpu_ptr(sdd->sd, j); : 
str : 				if (sd && (sd->flags & SD_OVERLAP))
strstr : INIT : 				if (sd && (sd->flags & SD_OVERLAP)) : 
strstr : if : 				if (sd && (sd->flags & SD_OVERLAP)) : 
strstr : for : 				if (sd && (sd->flags & SD_OVERLAP)) : 
strstr : while : 				if (sd && (sd->flags & SD_OVERLAP)) : 
str : 					free_sched_groups(sd->groups, 0);
strstr : INIT : 					free_sched_groups(sd->groups, 0); : 
strstr : if : 					free_sched_groups(sd->groups, 0); : 
strstr : for : 					free_sched_groups(sd->groups, 0); : 
strstr : while : 					free_sched_groups(sd->groups, 0); : 
str : 				kfree(*per_cpu_ptr(sdd->sd, j));
strstr : INIT : 				kfree(*per_cpu_ptr(sdd->sd, j)); : 
strstr : if : 				kfree(*per_cpu_ptr(sdd->sd, j)); : 
strstr : for : 				kfree(*per_cpu_ptr(sdd->sd, j)); : 
strstr : while : 				kfree(*per_cpu_ptr(sdd->sd, j)); : 
str : 			}
strstr : INIT : 			} : 
strstr : if : 			} : 
strstr : for : 			} : 
strstr : while : 			} : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 			if (sdd->sg)
strstr : if : 			if (sdd->sg) : 
strstr : for : 			if (sdd->sg) : 
strstr : while : 			if (sdd->sg) : 
str : 				kfree(*per_cpu_ptr(sdd->sg, j));
strstr : INIT : 				kfree(*per_cpu_ptr(sdd->sg, j)); : 
strstr : if : 				kfree(*per_cpu_ptr(sdd->sg, j)); : 
strstr : for : 				kfree(*per_cpu_ptr(sdd->sg, j)); : 
strstr : while : 				kfree(*per_cpu_ptr(sdd->sg, j)); : 
str : 			if (sdd->sgp)
strstr : INIT : 			if (sdd->sgp) : 
strstr : if : 			if (sdd->sgp) : 
strstr : for : 			if (sdd->sgp) : 
strstr : while : 			if (sdd->sgp) : 
str : 				kfree(*per_cpu_ptr(sdd->sgp, j));
strstr : INIT : 				kfree(*per_cpu_ptr(sdd->sgp, j)); : 
strstr : if : 				kfree(*per_cpu_ptr(sdd->sgp, j)); : 
strstr : for : 				kfree(*per_cpu_ptr(sdd->sgp, j)); : 
strstr : while : 				kfree(*per_cpu_ptr(sdd->sgp, j)); : 
str : 		}
strstr : INIT : 		} : 
strstr : if : 		} : 
strstr : for : 		} : 
strstr : while : 		} : 
str : 		free_percpu(sdd->sd);
strstr : INIT : 		free_percpu(sdd->sd); : 
strstr : if : 		free_percpu(sdd->sd); : 
strstr : for : 		free_percpu(sdd->sd); : 
strstr : while : 		free_percpu(sdd->sd); : 
str : 		sdd->sd = NULL;
strstr : INIT : 		sdd->sd = NULL; : 
strstr : if : 		sdd->sd = NULL; : 
strstr : for : 		sdd->sd = NULL; : 
strstr : while : 		sdd->sd = NULL; : 
str : 		free_percpu(sdd->sg);
strstr : INIT : 		free_percpu(sdd->sg); : 
strstr : if : 		free_percpu(sdd->sg); : 
strstr : for : 		free_percpu(sdd->sg); : 
strstr : while : 		free_percpu(sdd->sg); : 
str : 		sdd->sg = NULL;
strstr : INIT : 		sdd->sg = NULL; : 
strstr : if : 		sdd->sg = NULL; : 
strstr : for : 		sdd->sg = NULL; : 
strstr : while : 		sdd->sg = NULL; : 
str : 		free_percpu(sdd->sgp);
strstr : INIT : 		free_percpu(sdd->sgp); : 
strstr : if : 		free_percpu(sdd->sgp); : 
strstr : for : 		free_percpu(sdd->sgp); : 
strstr : while : 		free_percpu(sdd->sgp); : 
str : 		sdd->sgp = NULL;
strstr : INIT : 		sdd->sgp = NULL; : 
strstr : if : 		sdd->sgp = NULL; : 
strstr : for : 		sdd->sgp = NULL; : 
strstr : while : 		sdd->sgp = NULL; : 
str : 	}
strstr : INIT : 	} : 
strstr : if : 	} : 
strstr : for : 	} : 
strstr : while : 	} : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : struct sched_domain *build_sched_domain(struct sched_domain_topology_level *tl,
strstr : if : struct sched_domain *build_sched_domain(struct sched_domain_topology_level *tl, : 
strstr : for : struct sched_domain *build_sched_domain(struct sched_domain_topology_level *tl, : 
strstr : while : struct sched_domain *build_sched_domain(struct sched_domain_topology_level *tl, : 
str : 		const struct cpumask *cpu_map, struct sched_domain_attr *attr,
strstr : INIT : 		const struct cpumask *cpu_map, struct sched_domain_attr *attr, : 
strstr : if : 		const struct cpumask *cpu_map, struct sched_domain_attr *attr, : 
strstr : for : 		const struct cpumask *cpu_map, struct sched_domain_attr *attr, : 
strstr : while : 		const struct cpumask *cpu_map, struct sched_domain_attr *attr, : 
str : 		struct sched_domain *child, int cpu)
strstr : INIT : 		struct sched_domain *child, int cpu) : 
strstr : if : 		struct sched_domain *child, int cpu) : 
strstr : for : 		struct sched_domain *child, int cpu) : 
strstr : while : 		struct sched_domain *child, int cpu) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	struct sched_domain *sd = tl->init(tl, cpu);
strstr : INIT : 	struct sched_domain *sd = tl->init(tl, cpu); : 
strstr : if : 	struct sched_domain *sd = tl->init(tl, cpu); : 
strstr : for : 	struct sched_domain *sd = tl->init(tl, cpu); : 
strstr : while : 	struct sched_domain *sd = tl->init(tl, cpu); : 
str : 	if (!sd)
strstr : INIT : 	if (!sd) : 
strstr : if : 	if (!sd) : 
strstr : for : 	if (!sd) : 
strstr : while : 	if (!sd) : 
str : 		return child;
strstr : INIT : 		return child; : 
strstr : if : 		return child; : 
strstr : for : 		return child; : 
strstr : while : 		return child; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	cpumask_and(sched_domain_span(sd), cpu_map, tl->mask(cpu));
strstr : if : 	cpumask_and(sched_domain_span(sd), cpu_map, tl->mask(cpu)); : 
strstr : for : 	cpumask_and(sched_domain_span(sd), cpu_map, tl->mask(cpu)); : 
strstr : while : 	cpumask_and(sched_domain_span(sd), cpu_map, tl->mask(cpu)); : 
str : 	if (child) {
strstr : INIT : 	if (child) { : 
strstr : if : 	if (child) { : 
strstr : for : 	if (child) { : 
strstr : while : 	if (child) { : 
str : 		sd->level = child->level + 1;
strstr : INIT : 		sd->level = child->level + 1; : 
strstr : if : 		sd->level = child->level + 1; : 
strstr : for : 		sd->level = child->level + 1; : 
strstr : while : 		sd->level = child->level + 1; : 
str : 		sched_domain_level_max = max(sched_domain_level_max, sd->level);
strstr : INIT : 		sched_domain_level_max = max(sched_domain_level_max, sd->level); : 
strstr : if : 		sched_domain_level_max = max(sched_domain_level_max, sd->level); : 
strstr : for : 		sched_domain_level_max = max(sched_domain_level_max, sd->level); : 
strstr : while : 		sched_domain_level_max = max(sched_domain_level_max, sd->level); : 
str : 		child->parent = sd;
strstr : INIT : 		child->parent = sd; : 
strstr : if : 		child->parent = sd; : 
strstr : for : 		child->parent = sd; : 
strstr : while : 		child->parent = sd; : 
str : 		sd->child = child;
strstr : INIT : 		sd->child = child; : 
strstr : if : 		sd->child = child; : 
strstr : for : 		sd->child = child; : 
strstr : while : 		sd->child = child; : 
str : 	}
strstr : INIT : 	} : 
strstr : if : 	} : 
strstr : for : 	} : 
strstr : while : 	} : 
str : 	set_domain_attribute(sd, attr);
strstr : INIT : 	set_domain_attribute(sd, attr); : 
strstr : if : 	set_domain_attribute(sd, attr); : 
strstr : for : 	set_domain_attribute(sd, attr); : 
strstr : while : 	set_domain_attribute(sd, attr); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	return sd;
strstr : if : 	return sd; : 
strstr : for : 	return sd; : 
strstr : while : 	return sd; : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : /*
strstr : if : /* : 
strstr : for : /* : 
strstr : while : /* : 
str :  * Build sched domains for a given set of cpus and attach the sched domains
strstr : INIT :  * Build sched domains for a given set of cpus and attach the sched domains : 
strstr : if :  * Build sched domains for a given set of cpus and attach the sched domains : 
strstr : for :  * Build sched domains for a given set of cpus and attach the sched domains : 
strstr : while :  * Build sched domains for a given set of cpus and attach the sched domains : 
str :  * to the individual cpus
strstr : INIT :  * to the individual cpus : 
strstr : if :  * to the individual cpus : 
strstr : for :  * to the individual cpus : 
strstr : while :  * to the individual cpus : 
str :  */
strstr : INIT :  */ : 
strstr : if :  */ : 
strstr : for :  */ : 
strstr : while :  */ : 
str : static int build_sched_domains(const struct cpumask *cpu_map,
strstr : INIT : static int build_sched_domains(const struct cpumask *cpu_map, : 
strstr : if : static int build_sched_domains(const struct cpumask *cpu_map, : 
strstr : for : static int build_sched_domains(const struct cpumask *cpu_map, : 
strstr : while : static int build_sched_domains(const struct cpumask *cpu_map, : 
str : 			       struct sched_domain_attr *attr)
strstr : INIT : 			       struct sched_domain_attr *attr) : 
strstr : if : 			       struct sched_domain_attr *attr) : 
strstr : for : 			       struct sched_domain_attr *attr) : 
strstr : while : 			       struct sched_domain_attr *attr) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	enum s_alloc alloc_state;
strstr : INIT : 	enum s_alloc alloc_state; : 
strstr : if : 	enum s_alloc alloc_state; : 
strstr : for : 	enum s_alloc alloc_state; : 
strstr : while : 	enum s_alloc alloc_state; : 
str : 	struct sched_domain *sd;
strstr : INIT : 	struct sched_domain *sd; : 
strstr : if : 	struct sched_domain *sd; : 
strstr : for : 	struct sched_domain *sd; : 
strstr : while : 	struct sched_domain *sd; : 
str : 	struct s_data d;
strstr : INIT : 	struct s_data d; : 
strstr : if : 	struct s_data d; : 
strstr : for : 	struct s_data d; : 
strstr : while : 	struct s_data d; : 
str : 	int i, ret = -ENOMEM;
strstr : INIT : 	int i, ret = -ENOMEM; : 
strstr : if : 	int i, ret = -ENOMEM; : 
strstr : for : 	int i, ret = -ENOMEM; : 
strstr : while : 	int i, ret = -ENOMEM; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	alloc_state = __visit_domain_allocation_hell(&d, cpu_map);
strstr : if : 	alloc_state = __visit_domain_allocation_hell(&d, cpu_map); : 
strstr : for : 	alloc_state = __visit_domain_allocation_hell(&d, cpu_map); : 
strstr : while : 	alloc_state = __visit_domain_allocation_hell(&d, cpu_map); : 
str : 	if (alloc_state != sa_rootdomain)
strstr : INIT : 	if (alloc_state != sa_rootdomain) : 
strstr : if : 	if (alloc_state != sa_rootdomain) : 
strstr : for : 	if (alloc_state != sa_rootdomain) : 
strstr : while : 	if (alloc_state != sa_rootdomain) : 
str : 		goto error;
strstr : INIT : 		goto error; : 
strstr : if : 		goto error; : 
strstr : for : 		goto error; : 
strstr : while : 		goto error; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	/* Set up domains for cpus specified by the cpu_map. */
strstr : if : 	/* Set up domains for cpus specified by the cpu_map. */ : 
strstr : for : 	/* Set up domains for cpus specified by the cpu_map. */ : 
strstr : while : 	/* Set up domains for cpus specified by the cpu_map. */ : 
str : 	for_each_cpu(i, cpu_map) {
strstr : INIT : 	for_each_cpu(i, cpu_map) { : 
strstr : if : 	for_each_cpu(i, cpu_map) { : 
strstr : for : 	for_each_cpu(i, cpu_map) { : 
strstr : while : 	for_each_cpu(i, cpu_map) { : 
str : 		struct sched_domain_topology_level *tl;
strstr : INIT : 		struct sched_domain_topology_level *tl; : 
strstr : if : 		struct sched_domain_topology_level *tl; : 
strstr : for : 		struct sched_domain_topology_level *tl; : 
strstr : while : 		struct sched_domain_topology_level *tl; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 		sd = NULL;
strstr : if : 		sd = NULL; : 
strstr : for : 		sd = NULL; : 
strstr : while : 		sd = NULL; : 
str : 		for_each_sd_topology(tl) {
strstr : INIT : 		for_each_sd_topology(tl) { : 
strstr : if : 		for_each_sd_topology(tl) { : 
strstr : for : 		for_each_sd_topology(tl) { : 
strstr : while : 		for_each_sd_topology(tl) { : 
str : 			sd = build_sched_domain(tl, cpu_map, attr, sd, i);
strstr : INIT : 			sd = build_sched_domain(tl, cpu_map, attr, sd, i); : 
strstr : if : 			sd = build_sched_domain(tl, cpu_map, attr, sd, i); : 
strstr : for : 			sd = build_sched_domain(tl, cpu_map, attr, sd, i); : 
strstr : while : 			sd = build_sched_domain(tl, cpu_map, attr, sd, i); : 
str : 			if (tl == sched_domain_topology)
strstr : INIT : 			if (tl == sched_domain_topology) : 
strstr : if : 			if (tl == sched_domain_topology) : 
strstr : for : 			if (tl == sched_domain_topology) : 
strstr : while : 			if (tl == sched_domain_topology) : 
str : 				*per_cpu_ptr(d.sd, i) = sd;
strstr : INIT : 				*per_cpu_ptr(d.sd, i) = sd; : 
strstr : if : 				*per_cpu_ptr(d.sd, i) = sd; : 
strstr : for : 				*per_cpu_ptr(d.sd, i) = sd; : 
strstr : while : 				*per_cpu_ptr(d.sd, i) = sd; : 
str : 			if (tl->flags & SDTL_OVERLAP || sched_feat(FORCE_SD_OVERLAP))
strstr : INIT : 			if (tl->flags & SDTL_OVERLAP || sched_feat(FORCE_SD_OVERLAP)) : 
strstr : if : 			if (tl->flags & SDTL_OVERLAP || sched_feat(FORCE_SD_OVERLAP)) : 
strstr : for : 			if (tl->flags & SDTL_OVERLAP || sched_feat(FORCE_SD_OVERLAP)) : 
strstr : while : 			if (tl->flags & SDTL_OVERLAP || sched_feat(FORCE_SD_OVERLAP)) : 
str : 				sd->flags |= SD_OVERLAP;
strstr : INIT : 				sd->flags |= SD_OVERLAP; : 
strstr : if : 				sd->flags |= SD_OVERLAP; : 
strstr : for : 				sd->flags |= SD_OVERLAP; : 
strstr : while : 				sd->flags |= SD_OVERLAP; : 
str : 			if (cpumask_equal(cpu_map, sched_domain_span(sd)))
strstr : INIT : 			if (cpumask_equal(cpu_map, sched_domain_span(sd))) : 
strstr : if : 			if (cpumask_equal(cpu_map, sched_domain_span(sd))) : 
strstr : for : 			if (cpumask_equal(cpu_map, sched_domain_span(sd))) : 
strstr : while : 			if (cpumask_equal(cpu_map, sched_domain_span(sd))) : 
str : 				break;
strstr : INIT : 				break; : 
strstr : if : 				break; : 
strstr : for : 				break; : 
strstr : while : 				break; : 
str : 		}
strstr : INIT : 		} : 
strstr : if : 		} : 
strstr : for : 		} : 
strstr : while : 		} : 
str : 	}
strstr : INIT : 	} : 
strstr : if : 	} : 
strstr : for : 	} : 
strstr : while : 	} : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	/* Build the groups for the domains */
strstr : if : 	/* Build the groups for the domains */ : 
strstr : for : 	/* Build the groups for the domains */ : 
strstr : while : 	/* Build the groups for the domains */ : 
str : 	for_each_cpu(i, cpu_map) {
strstr : INIT : 	for_each_cpu(i, cpu_map) { : 
strstr : if : 	for_each_cpu(i, cpu_map) { : 
strstr : for : 	for_each_cpu(i, cpu_map) { : 
strstr : while : 	for_each_cpu(i, cpu_map) { : 
str : 		for (sd = *per_cpu_ptr(d.sd, i); sd; sd = sd->parent) {
strstr : INIT : 		for (sd = *per_cpu_ptr(d.sd, i); sd; sd = sd->parent) { : 
strstr : if : 		for (sd = *per_cpu_ptr(d.sd, i); sd; sd = sd->parent) { : 
strstr : for : 		for (sd = *per_cpu_ptr(d.sd, i); sd; sd = sd->parent) { : 
strstr : while : 		for (sd = *per_cpu_ptr(d.sd, i); sd; sd = sd->parent) { : 
str : 			sd->span_weight = cpumask_weight(sched_domain_span(sd));
strstr : INIT : 			sd->span_weight = cpumask_weight(sched_domain_span(sd)); : 
strstr : if : 			sd->span_weight = cpumask_weight(sched_domain_span(sd)); : 
strstr : for : 			sd->span_weight = cpumask_weight(sched_domain_span(sd)); : 
strstr : while : 			sd->span_weight = cpumask_weight(sched_domain_span(sd)); : 
str : 			if (sd->flags & SD_OVERLAP) {
strstr : INIT : 			if (sd->flags & SD_OVERLAP) { : 
strstr : if : 			if (sd->flags & SD_OVERLAP) { : 
strstr : for : 			if (sd->flags & SD_OVERLAP) { : 
strstr : while : 			if (sd->flags & SD_OVERLAP) { : 
str : 				if (build_overlap_sched_groups(sd, i))
strstr : INIT : 				if (build_overlap_sched_groups(sd, i)) : 
strstr : if : 				if (build_overlap_sched_groups(sd, i)) : 
strstr : for : 				if (build_overlap_sched_groups(sd, i)) : 
strstr : while : 				if (build_overlap_sched_groups(sd, i)) : 
str : 					goto error;
strstr : INIT : 					goto error; : 
strstr : if : 					goto error; : 
strstr : for : 					goto error; : 
strstr : while : 					goto error; : 
str : 			} else {
strstr : INIT : 			} else { : 
strstr : if : 			} else { : 
strstr : for : 			} else { : 
strstr : while : 			} else { : 
str : 				if (build_sched_groups(sd, i))
strstr : INIT : 				if (build_sched_groups(sd, i)) : 
strstr : if : 				if (build_sched_groups(sd, i)) : 
strstr : for : 				if (build_sched_groups(sd, i)) : 
strstr : while : 				if (build_sched_groups(sd, i)) : 
str : 					goto error;
strstr : INIT : 					goto error; : 
strstr : if : 					goto error; : 
strstr : for : 					goto error; : 
strstr : while : 					goto error; : 
str : 			}
strstr : INIT : 			} : 
strstr : if : 			} : 
strstr : for : 			} : 
strstr : while : 			} : 
str : 		}
strstr : INIT : 		} : 
strstr : if : 		} : 
strstr : for : 		} : 
strstr : while : 		} : 
str : 	}
strstr : INIT : 	} : 
strstr : if : 	} : 
strstr : for : 	} : 
strstr : while : 	} : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	/* Calculate CPU power for physical packages and nodes */
strstr : if : 	/* Calculate CPU power for physical packages and nodes */ : 
strstr : for : 	/* Calculate CPU power for physical packages and nodes */ : 
strstr : while : 	/* Calculate CPU power for physical packages and nodes */ : 
str : 	for (i = nr_cpumask_bits-1; i >= 0; i--) {
strstr : INIT : 	for (i = nr_cpumask_bits-1; i >= 0; i--) { : 
strstr : if : 	for (i = nr_cpumask_bits-1; i >= 0; i--) { : 
strstr : for : 	for (i = nr_cpumask_bits-1; i >= 0; i--) { : 
strstr : while : 	for (i = nr_cpumask_bits-1; i >= 0; i--) { : 
str : 		if (!cpumask_test_cpu(i, cpu_map))
strstr : INIT : 		if (!cpumask_test_cpu(i, cpu_map)) : 
strstr : if : 		if (!cpumask_test_cpu(i, cpu_map)) : 
strstr : for : 		if (!cpumask_test_cpu(i, cpu_map)) : 
strstr : while : 		if (!cpumask_test_cpu(i, cpu_map)) : 
str : 			continue;
strstr : INIT : 			continue; : 
strstr : if : 			continue; : 
strstr : for : 			continue; : 
strstr : while : 			continue; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 		for (sd = *per_cpu_ptr(d.sd, i); sd; sd = sd->parent) {
strstr : if : 		for (sd = *per_cpu_ptr(d.sd, i); sd; sd = sd->parent) { : 
strstr : for : 		for (sd = *per_cpu_ptr(d.sd, i); sd; sd = sd->parent) { : 
strstr : while : 		for (sd = *per_cpu_ptr(d.sd, i); sd; sd = sd->parent) { : 
str : 			claim_allocations(i, sd);
strstr : INIT : 			claim_allocations(i, sd); : 
strstr : if : 			claim_allocations(i, sd); : 
strstr : for : 			claim_allocations(i, sd); : 
strstr : while : 			claim_allocations(i, sd); : 
str : 			init_sched_groups_power(i, sd);
strstr : INIT : 			init_sched_groups_power(i, sd); : 
strstr : if : 			init_sched_groups_power(i, sd); : 
strstr : for : 			init_sched_groups_power(i, sd); : 
strstr : while : 			init_sched_groups_power(i, sd); : 
str : 		}
strstr : INIT : 		} : 
strstr : if : 		} : 
strstr : for : 		} : 
strstr : while : 		} : 
str : 	}
strstr : INIT : 	} : 
strstr : if : 	} : 
strstr : for : 	} : 
strstr : while : 	} : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	/* Attach the domains */
strstr : if : 	/* Attach the domains */ : 
strstr : for : 	/* Attach the domains */ : 
strstr : while : 	/* Attach the domains */ : 
str : 	rcu_read_lock();
strstr : INIT : 	rcu_read_lock(); : 
strstr : if : 	rcu_read_lock(); : 
strstr : for : 	rcu_read_lock(); : 
strstr : while : 	rcu_read_lock(); : 
str : 	for_each_cpu(i, cpu_map) {
strstr : INIT : 	for_each_cpu(i, cpu_map) { : 
strstr : if : 	for_each_cpu(i, cpu_map) { : 
strstr : for : 	for_each_cpu(i, cpu_map) { : 
strstr : while : 	for_each_cpu(i, cpu_map) { : 
str : 		sd = *per_cpu_ptr(d.sd, i);
strstr : INIT : 		sd = *per_cpu_ptr(d.sd, i); : 
strstr : if : 		sd = *per_cpu_ptr(d.sd, i); : 
strstr : for : 		sd = *per_cpu_ptr(d.sd, i); : 
strstr : while : 		sd = *per_cpu_ptr(d.sd, i); : 
str : 		cpu_attach_domain(sd, d.rd, i);
strstr : INIT : 		cpu_attach_domain(sd, d.rd, i); : 
strstr : if : 		cpu_attach_domain(sd, d.rd, i); : 
strstr : for : 		cpu_attach_domain(sd, d.rd, i); : 
strstr : while : 		cpu_attach_domain(sd, d.rd, i); : 
str : 	}
strstr : INIT : 	} : 
strstr : if : 	} : 
strstr : for : 	} : 
strstr : while : 	} : 
str : 	rcu_read_unlock();
strstr : INIT : 	rcu_read_unlock(); : 
strstr : if : 	rcu_read_unlock(); : 
strstr : for : 	rcu_read_unlock(); : 
strstr : while : 	rcu_read_unlock(); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	ret = 0;
strstr : if : 	ret = 0; : 
strstr : for : 	ret = 0; : 
strstr : while : 	ret = 0; : 
str : error:
strstr : INIT : error: : 
strstr : if : error: : 
strstr : for : error: : 
strstr : while : error: : 
str : 	__free_domain_allocs(&d, alloc_state, cpu_map);
strstr : INIT : 	__free_domain_allocs(&d, alloc_state, cpu_map); : 
strstr : if : 	__free_domain_allocs(&d, alloc_state, cpu_map); : 
strstr : for : 	__free_domain_allocs(&d, alloc_state, cpu_map); : 
strstr : while : 	__free_domain_allocs(&d, alloc_state, cpu_map); : 
str : 	return ret;
strstr : INIT : 	return ret; : 
strstr : if : 	return ret; : 
strstr : for : 	return ret; : 
strstr : while : 	return ret; : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : static cpumask_var_t *doms_cur;	/* current sched domains */
strstr : if : static cpumask_var_t *doms_cur;	/* current sched domains */ : 
strstr : for : static cpumask_var_t *doms_cur;	/* current sched domains */ : 
strstr : while : static cpumask_var_t *doms_cur;	/* current sched domains */ : 
str : static int ndoms_cur;		/* number of sched domains in 'doms_cur' */
strstr : INIT : static int ndoms_cur;		/* number of sched domains in 'doms_cur' */ : 
strstr : if : static int ndoms_cur;		/* number of sched domains in 'doms_cur' */ : 
strstr : for : static int ndoms_cur;		/* number of sched domains in 'doms_cur' */ : 
strstr : while : static int ndoms_cur;		/* number of sched domains in 'doms_cur' */ : 
str : static struct sched_domain_attr *dattr_cur;
strstr : INIT : static struct sched_domain_attr *dattr_cur; : 
strstr : if : static struct sched_domain_attr *dattr_cur; : 
strstr : for : static struct sched_domain_attr *dattr_cur; : 
strstr : while : static struct sched_domain_attr *dattr_cur; : 
str : 				/* attribues of custom domains in 'doms_cur' */
strstr : INIT : 				/* attribues of custom domains in 'doms_cur' */ : 
strstr : if : 				/* attribues of custom domains in 'doms_cur' */ : 
strstr : for : 				/* attribues of custom domains in 'doms_cur' */ : 
strstr : while : 				/* attribues of custom domains in 'doms_cur' */ : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : /*
strstr : if : /* : 
strstr : for : /* : 
strstr : while : /* : 
str :  * Special case: If a kmalloc of a doms_cur partition (array of
strstr : INIT :  * Special case: If a kmalloc of a doms_cur partition (array of : 
strstr : if :  * Special case: If a kmalloc of a doms_cur partition (array of : 
strstr : for :  * Special case: If a kmalloc of a doms_cur partition (array of : 
strstr : while :  * Special case: If a kmalloc of a doms_cur partition (array of : 
str :  * cpumask) fails, then fallback to a single sched domain,
strstr : INIT :  * cpumask) fails, then fallback to a single sched domain, : 
strstr : if :  * cpumask) fails, then fallback to a single sched domain, : 
strstr : for :  * cpumask) fails, then fallback to a single sched domain, : 
strstr : while :  * cpumask) fails, then fallback to a single sched domain, : 
str :  * as determined by the single cpumask fallback_doms.
strstr : INIT :  * as determined by the single cpumask fallback_doms. : 
strstr : if :  * as determined by the single cpumask fallback_doms. : 
strstr : for :  * as determined by the single cpumask fallback_doms. : 
strstr : while :  * as determined by the single cpumask fallback_doms. : 
str :  */
strstr : INIT :  */ : 
strstr : if :  */ : 
strstr : for :  */ : 
strstr : while :  */ : 
str : static cpumask_var_t fallback_doms;
strstr : INIT : static cpumask_var_t fallback_doms; : 
strstr : if : static cpumask_var_t fallback_doms; : 
strstr : for : static cpumask_var_t fallback_doms; : 
strstr : while : static cpumask_var_t fallback_doms; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : /*
strstr : if : /* : 
strstr : for : /* : 
strstr : while : /* : 
str :  * arch_update_cpu_topology lets virtualized architectures update the
strstr : INIT :  * arch_update_cpu_topology lets virtualized architectures update the : 
strstr : if :  * arch_update_cpu_topology lets virtualized architectures update the : 
strstr : for :  * arch_update_cpu_topology lets virtualized architectures update the : 
strstr : while :  * arch_update_cpu_topology lets virtualized architectures update the : 
str :  * cpu core maps. It is supposed to return 1 if the topology changed
strstr : INIT :  * cpu core maps. It is supposed to return 1 if the topology changed : 
strstr : if :  * cpu core maps. It is supposed to return 1 if the topology changed : 
strstr : for :  * cpu core maps. It is supposed to return 1 if the topology changed : 
strstr : while :  * cpu core maps. It is supposed to return 1 if the topology changed : 
str :  * or 0 if it stayed the same.
strstr : INIT :  * or 0 if it stayed the same. : 
strstr : if :  * or 0 if it stayed the same. : 
strstr : for :  * or 0 if it stayed the same. : 
strstr : while :  * or 0 if it stayed the same. : 
str :  */
strstr : INIT :  */ : 
strstr : if :  */ : 
strstr : for :  */ : 
strstr : while :  */ : 
str : int __attribute__((weak)) arch_update_cpu_topology(void)
strstr : INIT : int __attribute__((weak)) arch_update_cpu_topology(void) : 
strstr : if : int __attribute__((weak)) arch_update_cpu_topology(void) : 
strstr : for : int __attribute__((weak)) arch_update_cpu_topology(void) : 
strstr : while : int __attribute__((weak)) arch_update_cpu_topology(void) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	return 0;
strstr : INIT : 	return 0; : 
strstr : if : 	return 0; : 
strstr : for : 	return 0; : 
strstr : while : 	return 0; : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : cpumask_var_t *alloc_sched_domains(unsigned int ndoms)
strstr : if : cpumask_var_t *alloc_sched_domains(unsigned int ndoms) : 
strstr : for : cpumask_var_t *alloc_sched_domains(unsigned int ndoms) : 
strstr : while : cpumask_var_t *alloc_sched_domains(unsigned int ndoms) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	int i;
strstr : INIT : 	int i; : 
strstr : if : 	int i; : 
strstr : for : 	int i; : 
strstr : while : 	int i; : 
str : 	cpumask_var_t *doms;
strstr : INIT : 	cpumask_var_t *doms; : 
strstr : if : 	cpumask_var_t *doms; : 
strstr : for : 	cpumask_var_t *doms; : 
strstr : while : 	cpumask_var_t *doms; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	doms = kmalloc(sizeof(*doms) * ndoms, GFP_KERNEL);
strstr : if : 	doms = kmalloc(sizeof(*doms) * ndoms, GFP_KERNEL); : 
strstr : for : 	doms = kmalloc(sizeof(*doms) * ndoms, GFP_KERNEL); : 
strstr : while : 	doms = kmalloc(sizeof(*doms) * ndoms, GFP_KERNEL); : 
str : 	if (!doms)
strstr : INIT : 	if (!doms) : 
strstr : if : 	if (!doms) : 
strstr : for : 	if (!doms) : 
strstr : while : 	if (!doms) : 
str : 		return NULL;
strstr : INIT : 		return NULL; : 
strstr : if : 		return NULL; : 
strstr : for : 		return NULL; : 
strstr : while : 		return NULL; : 
str : 	for (i = 0; i < ndoms; i++) {
strstr : INIT : 	for (i = 0; i < ndoms; i++) { : 
strstr : if : 	for (i = 0; i < ndoms; i++) { : 
strstr : for : 	for (i = 0; i < ndoms; i++) { : 
strstr : while : 	for (i = 0; i < ndoms; i++) { : 
str : 		if (!alloc_cpumask_var(&doms[i], GFP_KERNEL)) {
strstr : INIT : 		if (!alloc_cpumask_var(&doms[i], GFP_KERNEL)) { : 
strstr : if : 		if (!alloc_cpumask_var(&doms[i], GFP_KERNEL)) { : 
strstr : for : 		if (!alloc_cpumask_var(&doms[i], GFP_KERNEL)) { : 
strstr : while : 		if (!alloc_cpumask_var(&doms[i], GFP_KERNEL)) { : 
str : 			free_sched_domains(doms, i);
strstr : INIT : 			free_sched_domains(doms, i); : 
strstr : if : 			free_sched_domains(doms, i); : 
strstr : for : 			free_sched_domains(doms, i); : 
strstr : while : 			free_sched_domains(doms, i); : 
str : 			return NULL;
strstr : INIT : 			return NULL; : 
strstr : if : 			return NULL; : 
strstr : for : 			return NULL; : 
strstr : while : 			return NULL; : 
str : 		}
strstr : INIT : 		} : 
strstr : if : 		} : 
strstr : for : 		} : 
strstr : while : 		} : 
str : 	}
strstr : INIT : 	} : 
strstr : if : 	} : 
strstr : for : 	} : 
strstr : while : 	} : 
str : 	return doms;
strstr : INIT : 	return doms; : 
strstr : if : 	return doms; : 
strstr : for : 	return doms; : 
strstr : while : 	return doms; : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : void free_sched_domains(cpumask_var_t doms[], unsigned int ndoms)
strstr : if : void free_sched_domains(cpumask_var_t doms[], unsigned int ndoms) : 
strstr : for : void free_sched_domains(cpumask_var_t doms[], unsigned int ndoms) : 
strstr : while : void free_sched_domains(cpumask_var_t doms[], unsigned int ndoms) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	unsigned int i;
strstr : INIT : 	unsigned int i; : 
strstr : if : 	unsigned int i; : 
strstr : for : 	unsigned int i; : 
strstr : while : 	unsigned int i; : 
str : 	for (i = 0; i < ndoms; i++)
strstr : INIT : 	for (i = 0; i < ndoms; i++) : 
strstr : if : 	for (i = 0; i < ndoms; i++) : 
strstr : for : 	for (i = 0; i < ndoms; i++) : 
strstr : while : 	for (i = 0; i < ndoms; i++) : 
str : 		free_cpumask_var(doms[i]);
strstr : INIT : 		free_cpumask_var(doms[i]); : 
strstr : if : 		free_cpumask_var(doms[i]); : 
strstr : for : 		free_cpumask_var(doms[i]); : 
strstr : while : 		free_cpumask_var(doms[i]); : 
str : 	kfree(doms);
strstr : INIT : 	kfree(doms); : 
strstr : if : 	kfree(doms); : 
strstr : for : 	kfree(doms); : 
strstr : while : 	kfree(doms); : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : /*
strstr : if : /* : 
strstr : for : /* : 
strstr : while : /* : 
str :  * Set up scheduler domains and groups. Callers must hold the hotplug lock.
strstr : INIT :  * Set up scheduler domains and groups. Callers must hold the hotplug lock. : 
strstr : if :  * Set up scheduler domains and groups. Callers must hold the hotplug lock. : 
strstr : for :  * Set up scheduler domains and groups. Callers must hold the hotplug lock. : 
strstr : while :  * Set up scheduler domains and groups. Callers must hold the hotplug lock. : 
str :  * For now this just excludes isolated cpus, but could be used to
strstr : INIT :  * For now this just excludes isolated cpus, but could be used to : 
strstr : if :  * For now this just excludes isolated cpus, but could be used to : 
strstr : for :  * For now this just excludes isolated cpus, but could be used to : 
strstr : while :  * For now this just excludes isolated cpus, but could be used to : 
str :  * exclude other special cases in the future.
strstr : INIT :  * exclude other special cases in the future. : 
strstr : if :  * exclude other special cases in the future. : 
strstr : for :  * exclude other special cases in the future. : 
strstr : while :  * exclude other special cases in the future. : 
str :  */
strstr : INIT :  */ : 
strstr : if :  */ : 
strstr : for :  */ : 
strstr : while :  */ : 
str : static int init_sched_domains(const struct cpumask *cpu_map)
strstr : INIT : static int init_sched_domains(const struct cpumask *cpu_map) : 
strstr : if : static int init_sched_domains(const struct cpumask *cpu_map) : 
strstr : for : static int init_sched_domains(const struct cpumask *cpu_map) : 
strstr : while : static int init_sched_domains(const struct cpumask *cpu_map) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	int err;
strstr : INIT : 	int err; : 
strstr : if : 	int err; : 
strstr : for : 	int err; : 
strstr : while : 	int err; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	arch_update_cpu_topology();
strstr : if : 	arch_update_cpu_topology(); : 
strstr : for : 	arch_update_cpu_topology(); : 
strstr : while : 	arch_update_cpu_topology(); : 
str : 	ndoms_cur = 1;
strstr : INIT : 	ndoms_cur = 1; : 
strstr : if : 	ndoms_cur = 1; : 
strstr : for : 	ndoms_cur = 1; : 
strstr : while : 	ndoms_cur = 1; : 
str : 	doms_cur = alloc_sched_domains(ndoms_cur);
strstr : INIT : 	doms_cur = alloc_sched_domains(ndoms_cur); : 
strstr : if : 	doms_cur = alloc_sched_domains(ndoms_cur); : 
strstr : for : 	doms_cur = alloc_sched_domains(ndoms_cur); : 
strstr : while : 	doms_cur = alloc_sched_domains(ndoms_cur); : 
str : 	if (!doms_cur)
strstr : INIT : 	if (!doms_cur) : 
strstr : if : 	if (!doms_cur) : 
strstr : for : 	if (!doms_cur) : 
strstr : while : 	if (!doms_cur) : 
str : 		doms_cur = &fallback_doms;
strstr : INIT : 		doms_cur = &fallback_doms; : 
strstr : if : 		doms_cur = &fallback_doms; : 
strstr : for : 		doms_cur = &fallback_doms; : 
strstr : while : 		doms_cur = &fallback_doms; : 
str : 	cpumask_andnot(doms_cur[0], cpu_map, cpu_isolated_map);
strstr : INIT : 	cpumask_andnot(doms_cur[0], cpu_map, cpu_isolated_map); : 
strstr : if : 	cpumask_andnot(doms_cur[0], cpu_map, cpu_isolated_map); : 
strstr : for : 	cpumask_andnot(doms_cur[0], cpu_map, cpu_isolated_map); : 
strstr : while : 	cpumask_andnot(doms_cur[0], cpu_map, cpu_isolated_map); : 
str : 	err = build_sched_domains(doms_cur[0], NULL);
strstr : INIT : 	err = build_sched_domains(doms_cur[0], NULL); : 
strstr : if : 	err = build_sched_domains(doms_cur[0], NULL); : 
strstr : for : 	err = build_sched_domains(doms_cur[0], NULL); : 
strstr : while : 	err = build_sched_domains(doms_cur[0], NULL); : 
str : 	register_sched_domain_sysctl();
strstr : INIT : 	register_sched_domain_sysctl(); : 
strstr : if : 	register_sched_domain_sysctl(); : 
strstr : for : 	register_sched_domain_sysctl(); : 
strstr : while : 	register_sched_domain_sysctl(); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	return err;
strstr : if : 	return err; : 
strstr : for : 	return err; : 
strstr : while : 	return err; : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : /*
strstr : if : /* : 
strstr : for : /* : 
strstr : while : /* : 
str :  * Detach sched domains from a group of cpus specified in cpu_map
strstr : INIT :  * Detach sched domains from a group of cpus specified in cpu_map : 
strstr : if :  * Detach sched domains from a group of cpus specified in cpu_map : 
strstr : for :  * Detach sched domains from a group of cpus specified in cpu_map : 
strstr : while :  * Detach sched domains from a group of cpus specified in cpu_map : 
str :  * These cpus will now be attached to the NULL domain
strstr : INIT :  * These cpus will now be attached to the NULL domain : 
strstr : if :  * These cpus will now be attached to the NULL domain : 
strstr : for :  * These cpus will now be attached to the NULL domain : 
strstr : while :  * These cpus will now be attached to the NULL domain : 
str :  */
strstr : INIT :  */ : 
strstr : if :  */ : 
strstr : for :  */ : 
strstr : while :  */ : 
str : static void detach_destroy_domains(const struct cpumask *cpu_map)
strstr : INIT : static void detach_destroy_domains(const struct cpumask *cpu_map) : 
strstr : if : static void detach_destroy_domains(const struct cpumask *cpu_map) : 
strstr : for : static void detach_destroy_domains(const struct cpumask *cpu_map) : 
strstr : while : static void detach_destroy_domains(const struct cpumask *cpu_map) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	int i;
strstr : INIT : 	int i; : 
strstr : if : 	int i; : 
strstr : for : 	int i; : 
strstr : while : 	int i; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	rcu_read_lock();
strstr : if : 	rcu_read_lock(); : 
strstr : for : 	rcu_read_lock(); : 
strstr : while : 	rcu_read_lock(); : 
str : 	for_each_cpu(i, cpu_map)
strstr : INIT : 	for_each_cpu(i, cpu_map) : 
strstr : if : 	for_each_cpu(i, cpu_map) : 
strstr : for : 	for_each_cpu(i, cpu_map) : 
strstr : while : 	for_each_cpu(i, cpu_map) : 
str : 		cpu_attach_domain(NULL, &def_root_domain, i);
strstr : INIT : 		cpu_attach_domain(NULL, &def_root_domain, i); : 
strstr : if : 		cpu_attach_domain(NULL, &def_root_domain, i); : 
strstr : for : 		cpu_attach_domain(NULL, &def_root_domain, i); : 
strstr : while : 		cpu_attach_domain(NULL, &def_root_domain, i); : 
str : 	rcu_read_unlock();
strstr : INIT : 	rcu_read_unlock(); : 
strstr : if : 	rcu_read_unlock(); : 
strstr : for : 	rcu_read_unlock(); : 
strstr : while : 	rcu_read_unlock(); : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : /* handle null as "default" */
strstr : if : /* handle null as "default" */ : 
strstr : for : /* handle null as "default" */ : 
strstr : while : /* handle null as "default" */ : 
str : static int dattrs_equal(struct sched_domain_attr *cur, int idx_cur,
strstr : INIT : static int dattrs_equal(struct sched_domain_attr *cur, int idx_cur, : 
strstr : if : static int dattrs_equal(struct sched_domain_attr *cur, int idx_cur, : 
strstr : for : static int dattrs_equal(struct sched_domain_attr *cur, int idx_cur, : 
strstr : while : static int dattrs_equal(struct sched_domain_attr *cur, int idx_cur, : 
str : 			struct sched_domain_attr *new, int idx_new)
strstr : INIT : 			struct sched_domain_attr *new, int idx_new) : 
strstr : if : 			struct sched_domain_attr *new, int idx_new) : 
strstr : for : 			struct sched_domain_attr *new, int idx_new) : 
strstr : while : 			struct sched_domain_attr *new, int idx_new) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	struct sched_domain_attr tmp;
strstr : INIT : 	struct sched_domain_attr tmp; : 
strstr : if : 	struct sched_domain_attr tmp; : 
strstr : for : 	struct sched_domain_attr tmp; : 
strstr : while : 	struct sched_domain_attr tmp; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	/* fast path */
strstr : if : 	/* fast path */ : 
strstr : for : 	/* fast path */ : 
strstr : while : 	/* fast path */ : 
str : 	if (!new && !cur)
strstr : INIT : 	if (!new && !cur) : 
strstr : if : 	if (!new && !cur) : 
strstr : for : 	if (!new && !cur) : 
strstr : while : 	if (!new && !cur) : 
str : 		return 1;
strstr : INIT : 		return 1; : 
strstr : if : 		return 1; : 
strstr : for : 		return 1; : 
strstr : while : 		return 1; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	tmp = SD_ATTR_INIT;
strstr : if : 	tmp = SD_ATTR_INIT; : 
strstr : for : 	tmp = SD_ATTR_INIT; : 
strstr : while : 	tmp = SD_ATTR_INIT; : 
str : 	return !memcmp(cur ? (cur + idx_cur) : &tmp,
strstr : INIT : 	return !memcmp(cur ? (cur + idx_cur) : &tmp, : 
strstr : if : 	return !memcmp(cur ? (cur + idx_cur) : &tmp, : 
strstr : for : 	return !memcmp(cur ? (cur + idx_cur) : &tmp, : 
strstr : while : 	return !memcmp(cur ? (cur + idx_cur) : &tmp, : 
str : 			new ? (new + idx_new) : &tmp,
strstr : INIT : 			new ? (new + idx_new) : &tmp, : 
strstr : if : 			new ? (new + idx_new) : &tmp, : 
strstr : for : 			new ? (new + idx_new) : &tmp, : 
strstr : while : 			new ? (new + idx_new) : &tmp, : 
str : 			sizeof(struct sched_domain_attr));
strstr : INIT : 			sizeof(struct sched_domain_attr)); : 
strstr : if : 			sizeof(struct sched_domain_attr)); : 
strstr : for : 			sizeof(struct sched_domain_attr)); : 
strstr : while : 			sizeof(struct sched_domain_attr)); : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : /*
strstr : if : /* : 
strstr : for : /* : 
strstr : while : /* : 
str :  * Partition sched domains as specified by the 'ndoms_new'
strstr : INIT :  * Partition sched domains as specified by the 'ndoms_new' : 
strstr : if :  * Partition sched domains as specified by the 'ndoms_new' : 
strstr : for :  * Partition sched domains as specified by the 'ndoms_new' : 
strstr : while :  * Partition sched domains as specified by the 'ndoms_new' : 
str :  * cpumasks in the array doms_new[] of cpumasks. This compares
strstr : INIT :  * cpumasks in the array doms_new[] of cpumasks. This compares : 
strstr : if :  * cpumasks in the array doms_new[] of cpumasks. This compares : 
strstr : for :  * cpumasks in the array doms_new[] of cpumasks. This compares : 
strstr : while :  * cpumasks in the array doms_new[] of cpumasks. This compares : 
str :  * doms_new[] to the current sched domain partitioning, doms_cur[].
strstr : INIT :  * doms_new[] to the current sched domain partitioning, doms_cur[]. : 
strstr : if :  * doms_new[] to the current sched domain partitioning, doms_cur[]. : 
strstr : for :  * doms_new[] to the current sched domain partitioning, doms_cur[]. : 
strstr : while :  * doms_new[] to the current sched domain partitioning, doms_cur[]. : 
str :  * It destroys each deleted domain and builds each new domain.
strstr : INIT :  * It destroys each deleted domain and builds each new domain. : 
strstr : if :  * It destroys each deleted domain and builds each new domain. : 
strstr : for :  * It destroys each deleted domain and builds each new domain. : 
strstr : while :  * It destroys each deleted domain and builds each new domain. : 
str :  *
strstr : INIT :  * : 
strstr : if :  * : 
strstr : for :  * : 
strstr : while :  * : 
str :  * 'doms_new' is an array of cpumask_var_t's of length 'ndoms_new'.
strstr : INIT :  * 'doms_new' is an array of cpumask_var_t's of length 'ndoms_new'. : 
strstr : if :  * 'doms_new' is an array of cpumask_var_t's of length 'ndoms_new'. : 
strstr : for :  * 'doms_new' is an array of cpumask_var_t's of length 'ndoms_new'. : 
strstr : while :  * 'doms_new' is an array of cpumask_var_t's of length 'ndoms_new'. : 
str :  * The masks don't intersect (don't overlap.) We should setup one
strstr : INIT :  * The masks don't intersect (don't overlap.) We should setup one : 
strstr : if :  * The masks don't intersect (don't overlap.) We should setup one : 
strstr : for :  * The masks don't intersect (don't overlap.) We should setup one : 
strstr : while :  * The masks don't intersect (don't overlap.) We should setup one : 
str :  * sched domain for each mask. CPUs not in any of the cpumasks will
strstr : INIT :  * sched domain for each mask. CPUs not in any of the cpumasks will : 
strstr : if :  * sched domain for each mask. CPUs not in any of the cpumasks will : 
strstr : for :  * sched domain for each mask. CPUs not in any of the cpumasks will : 
strstr : while :  * sched domain for each mask. CPUs not in any of the cpumasks will : 
str :  * not be load balanced. If the same cpumask appears both in the
strstr : INIT :  * not be load balanced. If the same cpumask appears both in the : 
strstr : if :  * not be load balanced. If the same cpumask appears both in the : 
strstr : for :  * not be load balanced. If the same cpumask appears both in the : 
strstr : while :  * not be load balanced. If the same cpumask appears both in the : 
str :  * current 'doms_cur' domains and in the new 'doms_new', we can leave
strstr : INIT :  * current 'doms_cur' domains and in the new 'doms_new', we can leave : 
strstr : if :  * current 'doms_cur' domains and in the new 'doms_new', we can leave : 
strstr : for :  * current 'doms_cur' domains and in the new 'doms_new', we can leave : 
strstr : while :  * current 'doms_cur' domains and in the new 'doms_new', we can leave : 
str :  * it as it is.
strstr : INIT :  * it as it is. : 
strstr : if :  * it as it is. : 
strstr : for :  * it as it is. : 
strstr : while :  * it as it is. : 
str :  *
strstr : INIT :  * : 
strstr : if :  * : 
strstr : for :  * : 
strstr : while :  * : 
str :  * The passed in 'doms_new' should be allocated using
strstr : INIT :  * The passed in 'doms_new' should be allocated using : 
strstr : if :  * The passed in 'doms_new' should be allocated using : 
strstr : for :  * The passed in 'doms_new' should be allocated using : 
strstr : while :  * The passed in 'doms_new' should be allocated using : 
str :  * alloc_sched_domains.  This routine takes ownership of it and will
strstr : INIT :  * alloc_sched_domains.  This routine takes ownership of it and will : 
strstr : if :  * alloc_sched_domains.  This routine takes ownership of it and will : 
strstr : for :  * alloc_sched_domains.  This routine takes ownership of it and will : 
strstr : while :  * alloc_sched_domains.  This routine takes ownership of it and will : 
str :  * free_sched_domains it when done with it. If the caller failed the
strstr : INIT :  * free_sched_domains it when done with it. If the caller failed the : 
strstr : if :  * free_sched_domains it when done with it. If the caller failed the : 
strstr : for :  * free_sched_domains it when done with it. If the caller failed the : 
strstr : while :  * free_sched_domains it when done with it. If the caller failed the : 
str :  * alloc call, then it can pass in doms_new == NULL && ndoms_new == 1,
strstr : INIT :  * alloc call, then it can pass in doms_new == NULL && ndoms_new == 1, : 
strstr : if :  * alloc call, then it can pass in doms_new == NULL && ndoms_new == 1, : 
strstr : for :  * alloc call, then it can pass in doms_new == NULL && ndoms_new == 1, : 
strstr : while :  * alloc call, then it can pass in doms_new == NULL && ndoms_new == 1, : 
str :  * and partition_sched_domains() will fallback to the single partition
strstr : INIT :  * and partition_sched_domains() will fallback to the single partition : 
strstr : if :  * and partition_sched_domains() will fallback to the single partition : 
strstr : for :  * and partition_sched_domains() will fallback to the single partition : 
strstr : while :  * and partition_sched_domains() will fallback to the single partition : 
str :  * 'fallback_doms', it also forces the domains to be rebuilt.
strstr : INIT :  * 'fallback_doms', it also forces the domains to be rebuilt. : 
strstr : if :  * 'fallback_doms', it also forces the domains to be rebuilt. : 
strstr : for :  * 'fallback_doms', it also forces the domains to be rebuilt. : 
strstr : while :  * 'fallback_doms', it also forces the domains to be rebuilt. : 
str :  *
strstr : INIT :  * : 
strstr : if :  * : 
strstr : for :  * : 
strstr : while :  * : 
str :  * If doms_new == NULL it will be replaced with cpu_online_mask.
strstr : INIT :  * If doms_new == NULL it will be replaced with cpu_online_mask. : 
strstr : if :  * If doms_new == NULL it will be replaced with cpu_online_mask. : 
strstr : for :  * If doms_new == NULL it will be replaced with cpu_online_mask. : 
strstr : while :  * If doms_new == NULL it will be replaced with cpu_online_mask. : 
str :  * ndoms_new == 0 is a special case for destroying existing domains,
strstr : INIT :  * ndoms_new == 0 is a special case for destroying existing domains, : 
strstr : if :  * ndoms_new == 0 is a special case for destroying existing domains, : 
strstr : for :  * ndoms_new == 0 is a special case for destroying existing domains, : 
strstr : while :  * ndoms_new == 0 is a special case for destroying existing domains, : 
str :  * and it will not create the default domain.
strstr : INIT :  * and it will not create the default domain. : 
strstr : if :  * and it will not create the default domain. : 
strstr : for :  * and it will not create the default domain. : 
strstr : while :  * and it will not create the default domain. : 
str :  *
strstr : INIT :  * : 
strstr : if :  * : 
strstr : for :  * : 
strstr : while :  * : 
str :  * Call with hotplug lock held
strstr : INIT :  * Call with hotplug lock held : 
strstr : if :  * Call with hotplug lock held : 
strstr : for :  * Call with hotplug lock held : 
strstr : while :  * Call with hotplug lock held : 
str :  */
strstr : INIT :  */ : 
strstr : if :  */ : 
strstr : for :  */ : 
strstr : while :  */ : 
str : void partition_sched_domains(int ndoms_new, cpumask_var_t doms_new[],
strstr : INIT : void partition_sched_domains(int ndoms_new, cpumask_var_t doms_new[], : 
strstr : if : void partition_sched_domains(int ndoms_new, cpumask_var_t doms_new[], : 
strstr : for : void partition_sched_domains(int ndoms_new, cpumask_var_t doms_new[], : 
strstr : while : void partition_sched_domains(int ndoms_new, cpumask_var_t doms_new[], : 
str : 			     struct sched_domain_attr *dattr_new)
strstr : INIT : 			     struct sched_domain_attr *dattr_new) : 
strstr : if : 			     struct sched_domain_attr *dattr_new) : 
strstr : for : 			     struct sched_domain_attr *dattr_new) : 
strstr : while : 			     struct sched_domain_attr *dattr_new) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	int i, j, n;
strstr : INIT : 	int i, j, n; : 
strstr : if : 	int i, j, n; : 
strstr : for : 	int i, j, n; : 
strstr : while : 	int i, j, n; : 
str : 	int new_topology;
strstr : INIT : 	int new_topology; : 
strstr : if : 	int new_topology; : 
strstr : for : 	int new_topology; : 
strstr : while : 	int new_topology; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	mutex_lock(&sched_domains_mutex);
strstr : if : 	mutex_lock(&sched_domains_mutex); : 
strstr : for : 	mutex_lock(&sched_domains_mutex); : 
strstr : while : 	mutex_lock(&sched_domains_mutex); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	/* always unregister in case we don't destroy any domains */
strstr : if : 	/* always unregister in case we don't destroy any domains */ : 
strstr : for : 	/* always unregister in case we don't destroy any domains */ : 
strstr : while : 	/* always unregister in case we don't destroy any domains */ : 
str : 	unregister_sched_domain_sysctl();
strstr : INIT : 	unregister_sched_domain_sysctl(); : 
strstr : if : 	unregister_sched_domain_sysctl(); : 
strstr : for : 	unregister_sched_domain_sysctl(); : 
strstr : while : 	unregister_sched_domain_sysctl(); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	/* Let architecture update cpu core mappings. */
strstr : if : 	/* Let architecture update cpu core mappings. */ : 
strstr : for : 	/* Let architecture update cpu core mappings. */ : 
strstr : while : 	/* Let architecture update cpu core mappings. */ : 
str : 	new_topology = arch_update_cpu_topology();
strstr : INIT : 	new_topology = arch_update_cpu_topology(); : 
strstr : if : 	new_topology = arch_update_cpu_topology(); : 
strstr : for : 	new_topology = arch_update_cpu_topology(); : 
strstr : while : 	new_topology = arch_update_cpu_topology(); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	n = doms_new ? ndoms_new : 0;
strstr : if : 	n = doms_new ? ndoms_new : 0; : 
strstr : for : 	n = doms_new ? ndoms_new : 0; : 
strstr : while : 	n = doms_new ? ndoms_new : 0; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	/* Destroy deleted domains */
strstr : if : 	/* Destroy deleted domains */ : 
strstr : for : 	/* Destroy deleted domains */ : 
strstr : while : 	/* Destroy deleted domains */ : 
str : 	for (i = 0; i < ndoms_cur; i++) {
strstr : INIT : 	for (i = 0; i < ndoms_cur; i++) { : 
strstr : if : 	for (i = 0; i < ndoms_cur; i++) { : 
strstr : for : 	for (i = 0; i < ndoms_cur; i++) { : 
strstr : while : 	for (i = 0; i < ndoms_cur; i++) { : 
str : 		for (j = 0; j < n && !new_topology; j++) {
strstr : INIT : 		for (j = 0; j < n && !new_topology; j++) { : 
strstr : if : 		for (j = 0; j < n && !new_topology; j++) { : 
strstr : for : 		for (j = 0; j < n && !new_topology; j++) { : 
strstr : while : 		for (j = 0; j < n && !new_topology; j++) { : 
str : 			if (cpumask_equal(doms_cur[i], doms_new[j])
strstr : INIT : 			if (cpumask_equal(doms_cur[i], doms_new[j]) : 
strstr : if : 			if (cpumask_equal(doms_cur[i], doms_new[j]) : 
strstr : for : 			if (cpumask_equal(doms_cur[i], doms_new[j]) : 
strstr : while : 			if (cpumask_equal(doms_cur[i], doms_new[j]) : 
str : 			    && dattrs_equal(dattr_cur, i, dattr_new, j))
strstr : INIT : 			    && dattrs_equal(dattr_cur, i, dattr_new, j)) : 
strstr : if : 			    && dattrs_equal(dattr_cur, i, dattr_new, j)) : 
strstr : for : 			    && dattrs_equal(dattr_cur, i, dattr_new, j)) : 
strstr : while : 			    && dattrs_equal(dattr_cur, i, dattr_new, j)) : 
str : 				goto match1;
strstr : INIT : 				goto match1; : 
strstr : if : 				goto match1; : 
strstr : for : 				goto match1; : 
strstr : while : 				goto match1; : 
str : 		}
strstr : INIT : 		} : 
strstr : if : 		} : 
strstr : for : 		} : 
strstr : while : 		} : 
str : 		/* no match - a current sched domain not in new doms_new[] */
strstr : INIT : 		/* no match - a current sched domain not in new doms_new[] */ : 
strstr : if : 		/* no match - a current sched domain not in new doms_new[] */ : 
strstr : for : 		/* no match - a current sched domain not in new doms_new[] */ : 
strstr : while : 		/* no match - a current sched domain not in new doms_new[] */ : 
str : 		detach_destroy_domains(doms_cur[i]);
strstr : INIT : 		detach_destroy_domains(doms_cur[i]); : 
strstr : if : 		detach_destroy_domains(doms_cur[i]); : 
strstr : for : 		detach_destroy_domains(doms_cur[i]); : 
strstr : while : 		detach_destroy_domains(doms_cur[i]); : 
str : match1:
strstr : INIT : match1: : 
strstr : if : match1: : 
strstr : for : match1: : 
strstr : while : match1: : 
str : 		;
strstr : INIT : 		; : 
strstr : if : 		; : 
strstr : for : 		; : 
strstr : while : 		; : 
str : 	}
strstr : INIT : 	} : 
strstr : if : 	} : 
strstr : for : 	} : 
strstr : while : 	} : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	n = ndoms_cur;
strstr : if : 	n = ndoms_cur; : 
strstr : for : 	n = ndoms_cur; : 
strstr : while : 	n = ndoms_cur; : 
str : 	if (doms_new == NULL) {
strstr : INIT : 	if (doms_new == NULL) { : 
strstr : if : 	if (doms_new == NULL) { : 
strstr : for : 	if (doms_new == NULL) { : 
strstr : while : 	if (doms_new == NULL) { : 
str : 		n = 0;
strstr : INIT : 		n = 0; : 
strstr : if : 		n = 0; : 
strstr : for : 		n = 0; : 
strstr : while : 		n = 0; : 
str : 		doms_new = &fallback_doms;
strstr : INIT : 		doms_new = &fallback_doms; : 
strstr : if : 		doms_new = &fallback_doms; : 
strstr : for : 		doms_new = &fallback_doms; : 
strstr : while : 		doms_new = &fallback_doms; : 
str : 		cpumask_andnot(doms_new[0], cpu_active_mask, cpu_isolated_map);
strstr : INIT : 		cpumask_andnot(doms_new[0], cpu_active_mask, cpu_isolated_map); : 
strstr : if : 		cpumask_andnot(doms_new[0], cpu_active_mask, cpu_isolated_map); : 
strstr : for : 		cpumask_andnot(doms_new[0], cpu_active_mask, cpu_isolated_map); : 
strstr : while : 		cpumask_andnot(doms_new[0], cpu_active_mask, cpu_isolated_map); : 
str : 		WARN_ON_ONCE(dattr_new);
strstr : INIT : 		WARN_ON_ONCE(dattr_new); : 
strstr : if : 		WARN_ON_ONCE(dattr_new); : 
strstr : for : 		WARN_ON_ONCE(dattr_new); : 
strstr : while : 		WARN_ON_ONCE(dattr_new); : 
str : 	}
strstr : INIT : 	} : 
strstr : if : 	} : 
strstr : for : 	} : 
strstr : while : 	} : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	/* Build new domains */
strstr : if : 	/* Build new domains */ : 
strstr : for : 	/* Build new domains */ : 
strstr : while : 	/* Build new domains */ : 
str : 	for (i = 0; i < ndoms_new; i++) {
strstr : INIT : 	for (i = 0; i < ndoms_new; i++) { : 
strstr : if : 	for (i = 0; i < ndoms_new; i++) { : 
strstr : for : 	for (i = 0; i < ndoms_new; i++) { : 
strstr : while : 	for (i = 0; i < ndoms_new; i++) { : 
str : 		for (j = 0; j < n && !new_topology; j++) {
strstr : INIT : 		for (j = 0; j < n && !new_topology; j++) { : 
strstr : if : 		for (j = 0; j < n && !new_topology; j++) { : 
strstr : for : 		for (j = 0; j < n && !new_topology; j++) { : 
strstr : while : 		for (j = 0; j < n && !new_topology; j++) { : 
str : 			if (cpumask_equal(doms_new[i], doms_cur[j])
strstr : INIT : 			if (cpumask_equal(doms_new[i], doms_cur[j]) : 
strstr : if : 			if (cpumask_equal(doms_new[i], doms_cur[j]) : 
strstr : for : 			if (cpumask_equal(doms_new[i], doms_cur[j]) : 
strstr : while : 			if (cpumask_equal(doms_new[i], doms_cur[j]) : 
str : 			    && dattrs_equal(dattr_new, i, dattr_cur, j))
strstr : INIT : 			    && dattrs_equal(dattr_new, i, dattr_cur, j)) : 
strstr : if : 			    && dattrs_equal(dattr_new, i, dattr_cur, j)) : 
strstr : for : 			    && dattrs_equal(dattr_new, i, dattr_cur, j)) : 
strstr : while : 			    && dattrs_equal(dattr_new, i, dattr_cur, j)) : 
str : 				goto match2;
strstr : INIT : 				goto match2; : 
strstr : if : 				goto match2; : 
strstr : for : 				goto match2; : 
strstr : while : 				goto match2; : 
str : 		}
strstr : INIT : 		} : 
strstr : if : 		} : 
strstr : for : 		} : 
strstr : while : 		} : 
str : 		/* no match - add a new doms_new */
strstr : INIT : 		/* no match - add a new doms_new */ : 
strstr : if : 		/* no match - add a new doms_new */ : 
strstr : for : 		/* no match - add a new doms_new */ : 
strstr : while : 		/* no match - add a new doms_new */ : 
str : 		build_sched_domains(doms_new[i], dattr_new ? dattr_new + i : NULL);
strstr : INIT : 		build_sched_domains(doms_new[i], dattr_new ? dattr_new + i : NULL); : 
strstr : if : 		build_sched_domains(doms_new[i], dattr_new ? dattr_new + i : NULL); : 
strstr : for : 		build_sched_domains(doms_new[i], dattr_new ? dattr_new + i : NULL); : 
strstr : while : 		build_sched_domains(doms_new[i], dattr_new ? dattr_new + i : NULL); : 
str : match2:
strstr : INIT : match2: : 
strstr : if : match2: : 
strstr : for : match2: : 
strstr : while : match2: : 
str : 		;
strstr : INIT : 		; : 
strstr : if : 		; : 
strstr : for : 		; : 
strstr : while : 		; : 
str : 	}
strstr : INIT : 	} : 
strstr : if : 	} : 
strstr : for : 	} : 
strstr : while : 	} : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	/* Remember the new sched domains */
strstr : if : 	/* Remember the new sched domains */ : 
strstr : for : 	/* Remember the new sched domains */ : 
strstr : while : 	/* Remember the new sched domains */ : 
str : 	if (doms_cur != &fallback_doms)
strstr : INIT : 	if (doms_cur != &fallback_doms) : 
strstr : if : 	if (doms_cur != &fallback_doms) : 
strstr : for : 	if (doms_cur != &fallback_doms) : 
strstr : while : 	if (doms_cur != &fallback_doms) : 
str : 		free_sched_domains(doms_cur, ndoms_cur);
strstr : INIT : 		free_sched_domains(doms_cur, ndoms_cur); : 
strstr : if : 		free_sched_domains(doms_cur, ndoms_cur); : 
strstr : for : 		free_sched_domains(doms_cur, ndoms_cur); : 
strstr : while : 		free_sched_domains(doms_cur, ndoms_cur); : 
str : 	kfree(dattr_cur);	/* kfree(NULL) is safe */
strstr : INIT : 	kfree(dattr_cur);	/* kfree(NULL) is safe */ : 
strstr : if : 	kfree(dattr_cur);	/* kfree(NULL) is safe */ : 
strstr : for : 	kfree(dattr_cur);	/* kfree(NULL) is safe */ : 
strstr : while : 	kfree(dattr_cur);	/* kfree(NULL) is safe */ : 
str : 	doms_cur = doms_new;
strstr : INIT : 	doms_cur = doms_new; : 
strstr : if : 	doms_cur = doms_new; : 
strstr : for : 	doms_cur = doms_new; : 
strstr : while : 	doms_cur = doms_new; : 
str : 	dattr_cur = dattr_new;
strstr : INIT : 	dattr_cur = dattr_new; : 
strstr : if : 	dattr_cur = dattr_new; : 
strstr : for : 	dattr_cur = dattr_new; : 
strstr : while : 	dattr_cur = dattr_new; : 
str : 	ndoms_cur = ndoms_new;
strstr : INIT : 	ndoms_cur = ndoms_new; : 
strstr : if : 	ndoms_cur = ndoms_new; : 
strstr : for : 	ndoms_cur = ndoms_new; : 
strstr : while : 	ndoms_cur = ndoms_new; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	register_sched_domain_sysctl();
strstr : if : 	register_sched_domain_sysctl(); : 
strstr : for : 	register_sched_domain_sysctl(); : 
strstr : while : 	register_sched_domain_sysctl(); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	mutex_unlock(&sched_domains_mutex);
strstr : if : 	mutex_unlock(&sched_domains_mutex); : 
strstr : for : 	mutex_unlock(&sched_domains_mutex); : 
strstr : while : 	mutex_unlock(&sched_domains_mutex); : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : static int num_cpus_frozen;	/* used to mark begin/end of suspend/resume */
strstr : if : static int num_cpus_frozen;	/* used to mark begin/end of suspend/resume */ : 
strstr : for : static int num_cpus_frozen;	/* used to mark begin/end of suspend/resume */ : 
strstr : while : static int num_cpus_frozen;	/* used to mark begin/end of suspend/resume */ : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : /*
strstr : if : /* : 
strstr : for : /* : 
strstr : while : /* : 
str :  * Update cpusets according to cpu_active mask.  If cpusets are
strstr : INIT :  * Update cpusets according to cpu_active mask.  If cpusets are : 
strstr : if :  * Update cpusets according to cpu_active mask.  If cpusets are : 
strstr : for :  * Update cpusets according to cpu_active mask.  If cpusets are : 
strstr : while :  * Update cpusets according to cpu_active mask.  If cpusets are : 
str :  * disabled, cpuset_update_active_cpus() becomes a simple wrapper
strstr : INIT :  * disabled, cpuset_update_active_cpus() becomes a simple wrapper : 
strstr : if :  * disabled, cpuset_update_active_cpus() becomes a simple wrapper : 
strstr : for :  * disabled, cpuset_update_active_cpus() becomes a simple wrapper : 
strstr : while :  * disabled, cpuset_update_active_cpus() becomes a simple wrapper : 
str :  * around partition_sched_domains().
strstr : INIT :  * around partition_sched_domains(). : 
strstr : if :  * around partition_sched_domains(). : 
strstr : for :  * around partition_sched_domains(). : 
strstr : while :  * around partition_sched_domains(). : 
str :  *
strstr : INIT :  * : 
strstr : if :  * : 
strstr : for :  * : 
strstr : while :  * : 
str :  * If we come here as part of a suspend/resume, don't touch cpusets because we
strstr : INIT :  * If we come here as part of a suspend/resume, don't touch cpusets because we : 
strstr : if :  * If we come here as part of a suspend/resume, don't touch cpusets because we : 
strstr : for :  * If we come here as part of a suspend/resume, don't touch cpusets because we : 
strstr : while :  * If we come here as part of a suspend/resume, don't touch cpusets because we : 
str :  * want to restore it back to its original state upon resume anyway.
strstr : INIT :  * want to restore it back to its original state upon resume anyway. : 
strstr : if :  * want to restore it back to its original state upon resume anyway. : 
strstr : for :  * want to restore it back to its original state upon resume anyway. : 
strstr : while :  * want to restore it back to its original state upon resume anyway. : 
str :  */
strstr : INIT :  */ : 
strstr : if :  */ : 
strstr : for :  */ : 
strstr : while :  */ : 
str : static int cpuset_cpu_active(struct notifier_block *nfb, unsigned long action,
strstr : INIT : static int cpuset_cpu_active(struct notifier_block *nfb, unsigned long action, : 
strstr : if : static int cpuset_cpu_active(struct notifier_block *nfb, unsigned long action, : 
strstr : for : static int cpuset_cpu_active(struct notifier_block *nfb, unsigned long action, : 
strstr : while : static int cpuset_cpu_active(struct notifier_block *nfb, unsigned long action, : 
str : 			     void *hcpu)
strstr : INIT : 			     void *hcpu) : 
strstr : if : 			     void *hcpu) : 
strstr : for : 			     void *hcpu) : 
strstr : while : 			     void *hcpu) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	switch (action) {
strstr : INIT : 	switch (action) { : 
strstr : if : 	switch (action) { : 
strstr : for : 	switch (action) { : 
strstr : while : 	switch (action) { : 
str : 	case CPU_ONLINE_FROZEN:
strstr : INIT : 	case CPU_ONLINE_FROZEN: : 
strstr : if : 	case CPU_ONLINE_FROZEN: : 
strstr : for : 	case CPU_ONLINE_FROZEN: : 
strstr : while : 	case CPU_ONLINE_FROZEN: : 
str : 	case CPU_DOWN_FAILED_FROZEN:
strstr : INIT : 	case CPU_DOWN_FAILED_FROZEN: : 
strstr : if : 	case CPU_DOWN_FAILED_FROZEN: : 
strstr : for : 	case CPU_DOWN_FAILED_FROZEN: : 
strstr : while : 	case CPU_DOWN_FAILED_FROZEN: : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 		/*
strstr : if : 		/* : 
strstr : for : 		/* : 
strstr : while : 		/* : 
str : 		 * num_cpus_frozen tracks how many CPUs are involved in suspend
strstr : INIT : 		 * num_cpus_frozen tracks how many CPUs are involved in suspend : 
strstr : if : 		 * num_cpus_frozen tracks how many CPUs are involved in suspend : 
strstr : for : 		 * num_cpus_frozen tracks how many CPUs are involved in suspend : 
strstr : while : 		 * num_cpus_frozen tracks how many CPUs are involved in suspend : 
str : 		 * resume sequence. As long as this is not the last online
strstr : INIT : 		 * resume sequence. As long as this is not the last online : 
strstr : if : 		 * resume sequence. As long as this is not the last online : 
strstr : for : 		 * resume sequence. As long as this is not the last online : 
strstr : while : 		 * resume sequence. As long as this is not the last online : 
str : 		 * operation in the resume sequence, just build a single sched
strstr : INIT : 		 * operation in the resume sequence, just build a single sched : 
strstr : if : 		 * operation in the resume sequence, just build a single sched : 
strstr : for : 		 * operation in the resume sequence, just build a single sched : 
strstr : while : 		 * operation in the resume sequence, just build a single sched : 
str : 		 * domain, ignoring cpusets.
strstr : INIT : 		 * domain, ignoring cpusets. : 
strstr : if : 		 * domain, ignoring cpusets. : 
strstr : for : 		 * domain, ignoring cpusets. : 
strstr : while : 		 * domain, ignoring cpusets. : 
str : 		 */
strstr : INIT : 		 */ : 
strstr : if : 		 */ : 
strstr : for : 		 */ : 
strstr : while : 		 */ : 
str : 		num_cpus_frozen--;
strstr : INIT : 		num_cpus_frozen--; : 
strstr : if : 		num_cpus_frozen--; : 
strstr : for : 		num_cpus_frozen--; : 
strstr : while : 		num_cpus_frozen--; : 
str : 		if (likely(num_cpus_frozen)) {
strstr : INIT : 		if (likely(num_cpus_frozen)) { : 
strstr : if : 		if (likely(num_cpus_frozen)) { : 
strstr : for : 		if (likely(num_cpus_frozen)) { : 
strstr : while : 		if (likely(num_cpus_frozen)) { : 
str : 			partition_sched_domains(1, NULL, NULL);
strstr : INIT : 			partition_sched_domains(1, NULL, NULL); : 
strstr : if : 			partition_sched_domains(1, NULL, NULL); : 
strstr : for : 			partition_sched_domains(1, NULL, NULL); : 
strstr : while : 			partition_sched_domains(1, NULL, NULL); : 
str : 			break;
strstr : INIT : 			break; : 
strstr : if : 			break; : 
strstr : for : 			break; : 
strstr : while : 			break; : 
str : 		}
strstr : INIT : 		} : 
strstr : if : 		} : 
strstr : for : 		} : 
strstr : while : 		} : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 		/*
strstr : if : 		/* : 
strstr : for : 		/* : 
strstr : while : 		/* : 
str : 		 * This is the last CPU online operation. So fall through and
strstr : INIT : 		 * This is the last CPU online operation. So fall through and : 
strstr : if : 		 * This is the last CPU online operation. So fall through and : 
strstr : for : 		 * This is the last CPU online operation. So fall through and : 
strstr : while : 		 * This is the last CPU online operation. So fall through and : 
str : 		 * restore the original sched domains by considering the
strstr : INIT : 		 * restore the original sched domains by considering the : 
strstr : if : 		 * restore the original sched domains by considering the : 
strstr : for : 		 * restore the original sched domains by considering the : 
strstr : while : 		 * restore the original sched domains by considering the : 
str : 		 * cpuset configurations.
strstr : INIT : 		 * cpuset configurations. : 
strstr : if : 		 * cpuset configurations. : 
strstr : for : 		 * cpuset configurations. : 
strstr : while : 		 * cpuset configurations. : 
str : 		 */
strstr : INIT : 		 */ : 
strstr : if : 		 */ : 
strstr : for : 		 */ : 
strstr : while : 		 */ : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	case CPU_ONLINE:
strstr : if : 	case CPU_ONLINE: : 
strstr : for : 	case CPU_ONLINE: : 
strstr : while : 	case CPU_ONLINE: : 
str : 	case CPU_DOWN_FAILED:
strstr : INIT : 	case CPU_DOWN_FAILED: : 
strstr : if : 	case CPU_DOWN_FAILED: : 
strstr : for : 	case CPU_DOWN_FAILED: : 
strstr : while : 	case CPU_DOWN_FAILED: : 
str : 		cpuset_update_active_cpus(true);
strstr : INIT : 		cpuset_update_active_cpus(true); : 
strstr : if : 		cpuset_update_active_cpus(true); : 
strstr : for : 		cpuset_update_active_cpus(true); : 
strstr : while : 		cpuset_update_active_cpus(true); : 
str : 		break;
strstr : INIT : 		break; : 
strstr : if : 		break; : 
strstr : for : 		break; : 
strstr : while : 		break; : 
str : 	default:
strstr : INIT : 	default: : 
strstr : if : 	default: : 
strstr : for : 	default: : 
strstr : while : 	default: : 
str : 		return NOTIFY_DONE;
strstr : INIT : 		return NOTIFY_DONE; : 
strstr : if : 		return NOTIFY_DONE; : 
strstr : for : 		return NOTIFY_DONE; : 
strstr : while : 		return NOTIFY_DONE; : 
str : 	}
strstr : INIT : 	} : 
strstr : if : 	} : 
strstr : for : 	} : 
strstr : while : 	} : 
str : 	return NOTIFY_OK;
strstr : INIT : 	return NOTIFY_OK; : 
strstr : if : 	return NOTIFY_OK; : 
strstr : for : 	return NOTIFY_OK; : 
strstr : while : 	return NOTIFY_OK; : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : static int cpuset_cpu_inactive(struct notifier_block *nfb, unsigned long action,
strstr : if : static int cpuset_cpu_inactive(struct notifier_block *nfb, unsigned long action, : 
strstr : for : static int cpuset_cpu_inactive(struct notifier_block *nfb, unsigned long action, : 
strstr : while : static int cpuset_cpu_inactive(struct notifier_block *nfb, unsigned long action, : 
str : 			       void *hcpu)
strstr : INIT : 			       void *hcpu) : 
strstr : if : 			       void *hcpu) : 
strstr : for : 			       void *hcpu) : 
strstr : while : 			       void *hcpu) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	switch (action) {
strstr : INIT : 	switch (action) { : 
strstr : if : 	switch (action) { : 
strstr : for : 	switch (action) { : 
strstr : while : 	switch (action) { : 
str : 	case CPU_DOWN_PREPARE:
strstr : INIT : 	case CPU_DOWN_PREPARE: : 
strstr : if : 	case CPU_DOWN_PREPARE: : 
strstr : for : 	case CPU_DOWN_PREPARE: : 
strstr : while : 	case CPU_DOWN_PREPARE: : 
str : 		cpuset_update_active_cpus(false);
strstr : INIT : 		cpuset_update_active_cpus(false); : 
strstr : if : 		cpuset_update_active_cpus(false); : 
strstr : for : 		cpuset_update_active_cpus(false); : 
strstr : while : 		cpuset_update_active_cpus(false); : 
str : 		break;
strstr : INIT : 		break; : 
strstr : if : 		break; : 
strstr : for : 		break; : 
strstr : while : 		break; : 
str : 	case CPU_DOWN_PREPARE_FROZEN:
strstr : INIT : 	case CPU_DOWN_PREPARE_FROZEN: : 
strstr : if : 	case CPU_DOWN_PREPARE_FROZEN: : 
strstr : for : 	case CPU_DOWN_PREPARE_FROZEN: : 
strstr : while : 	case CPU_DOWN_PREPARE_FROZEN: : 
str : 		num_cpus_frozen++;
strstr : INIT : 		num_cpus_frozen++; : 
strstr : if : 		num_cpus_frozen++; : 
strstr : for : 		num_cpus_frozen++; : 
strstr : while : 		num_cpus_frozen++; : 
str : 		partition_sched_domains(1, NULL, NULL);
strstr : INIT : 		partition_sched_domains(1, NULL, NULL); : 
strstr : if : 		partition_sched_domains(1, NULL, NULL); : 
strstr : for : 		partition_sched_domains(1, NULL, NULL); : 
strstr : while : 		partition_sched_domains(1, NULL, NULL); : 
str : 		break;
strstr : INIT : 		break; : 
strstr : if : 		break; : 
strstr : for : 		break; : 
strstr : while : 		break; : 
str : 	default:
strstr : INIT : 	default: : 
strstr : if : 	default: : 
strstr : for : 	default: : 
strstr : while : 	default: : 
str : 		return NOTIFY_DONE;
strstr : INIT : 		return NOTIFY_DONE; : 
strstr : if : 		return NOTIFY_DONE; : 
strstr : for : 		return NOTIFY_DONE; : 
strstr : while : 		return NOTIFY_DONE; : 
str : 	}
strstr : INIT : 	} : 
strstr : if : 	} : 
strstr : for : 	} : 
strstr : while : 	} : 
str : 	return NOTIFY_OK;
strstr : INIT : 	return NOTIFY_OK; : 
strstr : if : 	return NOTIFY_OK; : 
strstr : for : 	return NOTIFY_OK; : 
strstr : while : 	return NOTIFY_OK; : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : void __init sched_init_smp(void)
strstr : if : void __init sched_init_smp(void) : 
strstr : for : void __init sched_init_smp(void) : 
strstr : while : void __init sched_init_smp(void) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	cpumask_var_t non_isolated_cpus;
strstr : INIT : 	cpumask_var_t non_isolated_cpus; : 
strstr : if : 	cpumask_var_t non_isolated_cpus; : 
strstr : for : 	cpumask_var_t non_isolated_cpus; : 
strstr : while : 	cpumask_var_t non_isolated_cpus; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	alloc_cpumask_var(&non_isolated_cpus, GFP_KERNEL);
strstr : if : 	alloc_cpumask_var(&non_isolated_cpus, GFP_KERNEL); : 
strstr : for : 	alloc_cpumask_var(&non_isolated_cpus, GFP_KERNEL); : 
strstr : while : 	alloc_cpumask_var(&non_isolated_cpus, GFP_KERNEL); : 
str : 	alloc_cpumask_var(&fallback_doms, GFP_KERNEL);
strstr : INIT : 	alloc_cpumask_var(&fallback_doms, GFP_KERNEL); : 
strstr : if : 	alloc_cpumask_var(&fallback_doms, GFP_KERNEL); : 
strstr : for : 	alloc_cpumask_var(&fallback_doms, GFP_KERNEL); : 
strstr : while : 	alloc_cpumask_var(&fallback_doms, GFP_KERNEL); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	sched_init_numa();
strstr : if : 	sched_init_numa(); : 
strstr : for : 	sched_init_numa(); : 
strstr : while : 	sched_init_numa(); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	/*
strstr : if : 	/* : 
strstr : for : 	/* : 
strstr : while : 	/* : 
str : 	 * There's no userspace yet to cause hotplug operations; hence all the
strstr : INIT : 	 * There's no userspace yet to cause hotplug operations; hence all the : 
strstr : if : 	 * There's no userspace yet to cause hotplug operations; hence all the : 
strstr : for : 	 * There's no userspace yet to cause hotplug operations; hence all the : 
strstr : while : 	 * There's no userspace yet to cause hotplug operations; hence all the : 
str : 	 * cpu masks are stable and all blatant races in the below code cannot
strstr : INIT : 	 * cpu masks are stable and all blatant races in the below code cannot : 
strstr : if : 	 * cpu masks are stable and all blatant races in the below code cannot : 
strstr : for : 	 * cpu masks are stable and all blatant races in the below code cannot : 
strstr : while : 	 * cpu masks are stable and all blatant races in the below code cannot : 
str : 	 * happen.
strstr : INIT : 	 * happen. : 
strstr : if : 	 * happen. : 
strstr : for : 	 * happen. : 
strstr : while : 	 * happen. : 
str : 	 */
strstr : INIT : 	 */ : 
strstr : if : 	 */ : 
strstr : for : 	 */ : 
strstr : while : 	 */ : 
str : 	mutex_lock(&sched_domains_mutex);
strstr : INIT : 	mutex_lock(&sched_domains_mutex); : 
strstr : if : 	mutex_lock(&sched_domains_mutex); : 
strstr : for : 	mutex_lock(&sched_domains_mutex); : 
strstr : while : 	mutex_lock(&sched_domains_mutex); : 
str : 	init_sched_domains(cpu_active_mask);
strstr : INIT : 	init_sched_domains(cpu_active_mask); : 
strstr : if : 	init_sched_domains(cpu_active_mask); : 
strstr : for : 	init_sched_domains(cpu_active_mask); : 
strstr : while : 	init_sched_domains(cpu_active_mask); : 
str : 	cpumask_andnot(non_isolated_cpus, cpu_possible_mask, cpu_isolated_map);
strstr : INIT : 	cpumask_andnot(non_isolated_cpus, cpu_possible_mask, cpu_isolated_map); : 
strstr : if : 	cpumask_andnot(non_isolated_cpus, cpu_possible_mask, cpu_isolated_map); : 
strstr : for : 	cpumask_andnot(non_isolated_cpus, cpu_possible_mask, cpu_isolated_map); : 
strstr : while : 	cpumask_andnot(non_isolated_cpus, cpu_possible_mask, cpu_isolated_map); : 
str : 	if (cpumask_empty(non_isolated_cpus))
strstr : INIT : 	if (cpumask_empty(non_isolated_cpus)) : 
strstr : if : 	if (cpumask_empty(non_isolated_cpus)) : 
strstr : for : 	if (cpumask_empty(non_isolated_cpus)) : 
strstr : while : 	if (cpumask_empty(non_isolated_cpus)) : 
str : 		cpumask_set_cpu(smp_processor_id(), non_isolated_cpus);
strstr : INIT : 		cpumask_set_cpu(smp_processor_id(), non_isolated_cpus); : 
strstr : if : 		cpumask_set_cpu(smp_processor_id(), non_isolated_cpus); : 
strstr : for : 		cpumask_set_cpu(smp_processor_id(), non_isolated_cpus); : 
strstr : while : 		cpumask_set_cpu(smp_processor_id(), non_isolated_cpus); : 
str : 	mutex_unlock(&sched_domains_mutex);
strstr : INIT : 	mutex_unlock(&sched_domains_mutex); : 
strstr : if : 	mutex_unlock(&sched_domains_mutex); : 
strstr : for : 	mutex_unlock(&sched_domains_mutex); : 
strstr : while : 	mutex_unlock(&sched_domains_mutex); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	hotcpu_notifier(sched_domains_numa_masks_update, CPU_PRI_SCHED_ACTIVE);
strstr : if : 	hotcpu_notifier(sched_domains_numa_masks_update, CPU_PRI_SCHED_ACTIVE); : 
strstr : for : 	hotcpu_notifier(sched_domains_numa_masks_update, CPU_PRI_SCHED_ACTIVE); : 
strstr : while : 	hotcpu_notifier(sched_domains_numa_masks_update, CPU_PRI_SCHED_ACTIVE); : 
str : 	hotcpu_notifier(cpuset_cpu_active, CPU_PRI_CPUSET_ACTIVE);
strstr : INIT : 	hotcpu_notifier(cpuset_cpu_active, CPU_PRI_CPUSET_ACTIVE); : 
strstr : if : 	hotcpu_notifier(cpuset_cpu_active, CPU_PRI_CPUSET_ACTIVE); : 
strstr : for : 	hotcpu_notifier(cpuset_cpu_active, CPU_PRI_CPUSET_ACTIVE); : 
strstr : while : 	hotcpu_notifier(cpuset_cpu_active, CPU_PRI_CPUSET_ACTIVE); : 
str : 	hotcpu_notifier(cpuset_cpu_inactive, CPU_PRI_CPUSET_INACTIVE);
strstr : INIT : 	hotcpu_notifier(cpuset_cpu_inactive, CPU_PRI_CPUSET_INACTIVE); : 
strstr : if : 	hotcpu_notifier(cpuset_cpu_inactive, CPU_PRI_CPUSET_INACTIVE); : 
strstr : for : 	hotcpu_notifier(cpuset_cpu_inactive, CPU_PRI_CPUSET_INACTIVE); : 
strstr : while : 	hotcpu_notifier(cpuset_cpu_inactive, CPU_PRI_CPUSET_INACTIVE); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	init_hrtick();
strstr : if : 	init_hrtick(); : 
strstr : for : 	init_hrtick(); : 
strstr : while : 	init_hrtick(); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	/* Move init over to a non-isolated CPU */
strstr : if : 	/* Move init over to a non-isolated CPU */ : 
strstr : for : 	/* Move init over to a non-isolated CPU */ : 
strstr : while : 	/* Move init over to a non-isolated CPU */ : 
str : 	if (set_cpus_allowed_ptr(current, non_isolated_cpus) < 0)
strstr : INIT : 	if (set_cpus_allowed_ptr(current, non_isolated_cpus) < 0) : 
strstr : if : 	if (set_cpus_allowed_ptr(current, non_isolated_cpus) < 0) : 
strstr : for : 	if (set_cpus_allowed_ptr(current, non_isolated_cpus) < 0) : 
strstr : while : 	if (set_cpus_allowed_ptr(current, non_isolated_cpus) < 0) : 
str : 		BUG();
strstr : INIT : 		BUG(); : 
strstr : if : 		BUG(); : 
strstr : for : 		BUG(); : 
strstr : while : 		BUG(); : 
str : 	sched_init_granularity();
strstr : INIT : 	sched_init_granularity(); : 
strstr : if : 	sched_init_granularity(); : 
strstr : for : 	sched_init_granularity(); : 
strstr : while : 	sched_init_granularity(); : 
str : 	free_cpumask_var(non_isolated_cpus);
strstr : INIT : 	free_cpumask_var(non_isolated_cpus); : 
strstr : if : 	free_cpumask_var(non_isolated_cpus); : 
strstr : for : 	free_cpumask_var(non_isolated_cpus); : 
strstr : while : 	free_cpumask_var(non_isolated_cpus); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	init_sched_rt_class();
strstr : if : 	init_sched_rt_class(); : 
strstr : for : 	init_sched_rt_class(); : 
strstr : while : 	init_sched_rt_class(); : 
str : 	init_sched_dl_class();
strstr : INIT : 	init_sched_dl_class(); : 
strstr : if : 	init_sched_dl_class(); : 
strstr : for : 	init_sched_dl_class(); : 
strstr : while : 	init_sched_dl_class(); : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : #else
strstr : INIT : #else : 
strstr : if : #else : 
strstr : for : #else : 
strstr : while : #else : 
str : void __init sched_init_smp(void)
strstr : INIT : void __init sched_init_smp(void) : 
strstr : if : void __init sched_init_smp(void) : 
strstr : for : void __init sched_init_smp(void) : 
strstr : while : void __init sched_init_smp(void) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	sched_init_granularity();
strstr : INIT : 	sched_init_granularity(); : 
strstr : if : 	sched_init_granularity(); : 
strstr : for : 	sched_init_granularity(); : 
strstr : while : 	sched_init_granularity(); : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : #endif /* CONFIG_SMP */
strstr : INIT : #endif /* CONFIG_SMP */ : 
strstr : if : #endif /* CONFIG_SMP */ : 
strstr : for : #endif /* CONFIG_SMP */ : 
strstr : while : #endif /* CONFIG_SMP */ : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : const_debug unsigned int sysctl_timer_migration = 1;
strstr : if : const_debug unsigned int sysctl_timer_migration = 1; : 
strstr : for : const_debug unsigned int sysctl_timer_migration = 1; : 
strstr : while : const_debug unsigned int sysctl_timer_migration = 1; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : int in_sched_functions(unsigned long addr)
strstr : if : int in_sched_functions(unsigned long addr) : 
strstr : for : int in_sched_functions(unsigned long addr) : 
strstr : while : int in_sched_functions(unsigned long addr) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	return in_lock_functions(addr) ||
strstr : INIT : 	return in_lock_functions(addr) || : 
strstr : if : 	return in_lock_functions(addr) || : 
strstr : for : 	return in_lock_functions(addr) || : 
strstr : while : 	return in_lock_functions(addr) || : 
str : 		(addr >= (unsigned long)__sched_text_start
strstr : INIT : 		(addr >= (unsigned long)__sched_text_start : 
strstr : if : 		(addr >= (unsigned long)__sched_text_start : 
strstr : for : 		(addr >= (unsigned long)__sched_text_start : 
strstr : while : 		(addr >= (unsigned long)__sched_text_start : 
str : 		&& addr < (unsigned long)__sched_text_end);
strstr : INIT : 		&& addr < (unsigned long)__sched_text_end); : 
strstr : if : 		&& addr < (unsigned long)__sched_text_end); : 
strstr : for : 		&& addr < (unsigned long)__sched_text_end); : 
strstr : while : 		&& addr < (unsigned long)__sched_text_end); : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : #ifdef CONFIG_CGROUP_SCHED
strstr : if : #ifdef CONFIG_CGROUP_SCHED : 
strstr : for : #ifdef CONFIG_CGROUP_SCHED : 
strstr : while : #ifdef CONFIG_CGROUP_SCHED : 
str : /*
strstr : INIT : /* : 
strstr : if : /* : 
strstr : for : /* : 
strstr : while : /* : 
str :  * Default task group.
strstr : INIT :  * Default task group. : 
strstr : if :  * Default task group. : 
strstr : for :  * Default task group. : 
strstr : while :  * Default task group. : 
str :  * Every task in system belongs to this group at bootup.
strstr : INIT :  * Every task in system belongs to this group at bootup. : 
strstr : if :  * Every task in system belongs to this group at bootup. : 
strstr : for :  * Every task in system belongs to this group at bootup. : 
strstr : while :  * Every task in system belongs to this group at bootup. : 
str :  */
strstr : INIT :  */ : 
strstr : if :  */ : 
strstr : for :  */ : 
strstr : while :  */ : 
str : struct task_group root_task_group;
strstr : INIT : struct task_group root_task_group; : 
strstr : if : struct task_group root_task_group; : 
strstr : for : struct task_group root_task_group; : 
strstr : while : struct task_group root_task_group; : 
str : LIST_HEAD(task_groups);
strstr : INIT : LIST_HEAD(task_groups); : 
strstr : if : LIST_HEAD(task_groups); : 
strstr : for : LIST_HEAD(task_groups); : 
strstr : while : LIST_HEAD(task_groups); : 
str : #endif
strstr : INIT : #endif : 
strstr : if : #endif : 
strstr : for : #endif : 
strstr : while : #endif : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : DECLARE_PER_CPU(cpumask_var_t, load_balance_mask);
strstr : if : DECLARE_PER_CPU(cpumask_var_t, load_balance_mask); : 
strstr : for : DECLARE_PER_CPU(cpumask_var_t, load_balance_mask); : 
strstr : while : DECLARE_PER_CPU(cpumask_var_t, load_balance_mask); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : void __init sched_init(void)
strstr : if : void __init sched_init(void) : 
strstr : for : void __init sched_init(void) : 
strstr : while : void __init sched_init(void) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	int i, j;
strstr : INIT : 	int i, j; : 
strstr : if : 	int i, j; : 
strstr : for : 	int i, j; : 
strstr : while : 	int i, j; : 
str : 	unsigned long alloc_size = 0, ptr;
strstr : INIT : 	unsigned long alloc_size = 0, ptr; : 
strstr : if : 	unsigned long alloc_size = 0, ptr; : 
strstr : for : 	unsigned long alloc_size = 0, ptr; : 
strstr : while : 	unsigned long alloc_size = 0, ptr; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : #ifdef CONFIG_FAIR_GROUP_SCHED
strstr : if : #ifdef CONFIG_FAIR_GROUP_SCHED : 
strstr : for : #ifdef CONFIG_FAIR_GROUP_SCHED : 
strstr : while : #ifdef CONFIG_FAIR_GROUP_SCHED : 
str : 	alloc_size += 2 * nr_cpu_ids * sizeof(void **);
strstr : INIT : 	alloc_size += 2 * nr_cpu_ids * sizeof(void **); : 
strstr : if : 	alloc_size += 2 * nr_cpu_ids * sizeof(void **); : 
strstr : for : 	alloc_size += 2 * nr_cpu_ids * sizeof(void **); : 
strstr : while : 	alloc_size += 2 * nr_cpu_ids * sizeof(void **); : 
str : #endif
strstr : INIT : #endif : 
strstr : if : #endif : 
strstr : for : #endif : 
strstr : while : #endif : 
str : #ifdef CONFIG_RT_GROUP_SCHED
strstr : INIT : #ifdef CONFIG_RT_GROUP_SCHED : 
strstr : if : #ifdef CONFIG_RT_GROUP_SCHED : 
strstr : for : #ifdef CONFIG_RT_GROUP_SCHED : 
strstr : while : #ifdef CONFIG_RT_GROUP_SCHED : 
str : 	alloc_size += 2 * nr_cpu_ids * sizeof(void **);
strstr : INIT : 	alloc_size += 2 * nr_cpu_ids * sizeof(void **); : 
strstr : if : 	alloc_size += 2 * nr_cpu_ids * sizeof(void **); : 
strstr : for : 	alloc_size += 2 * nr_cpu_ids * sizeof(void **); : 
strstr : while : 	alloc_size += 2 * nr_cpu_ids * sizeof(void **); : 
str : #endif
strstr : INIT : #endif : 
strstr : if : #endif : 
strstr : for : #endif : 
strstr : while : #endif : 
str : #ifdef CONFIG_CPUMASK_OFFSTACK
strstr : INIT : #ifdef CONFIG_CPUMASK_OFFSTACK : 
strstr : if : #ifdef CONFIG_CPUMASK_OFFSTACK : 
strstr : for : #ifdef CONFIG_CPUMASK_OFFSTACK : 
strstr : while : #ifdef CONFIG_CPUMASK_OFFSTACK : 
str : 	alloc_size += num_possible_cpus() * cpumask_size();
strstr : INIT : 	alloc_size += num_possible_cpus() * cpumask_size(); : 
strstr : if : 	alloc_size += num_possible_cpus() * cpumask_size(); : 
strstr : for : 	alloc_size += num_possible_cpus() * cpumask_size(); : 
strstr : while : 	alloc_size += num_possible_cpus() * cpumask_size(); : 
str : #endif
strstr : INIT : #endif : 
strstr : if : #endif : 
strstr : for : #endif : 
strstr : while : #endif : 
str : 	if (alloc_size) {
strstr : INIT : 	if (alloc_size) { : 
strstr : if : 	if (alloc_size) { : 
strstr : for : 	if (alloc_size) { : 
strstr : while : 	if (alloc_size) { : 
str : 		ptr = (unsigned long)kzalloc(alloc_size, GFP_NOWAIT);
strstr : INIT : 		ptr = (unsigned long)kzalloc(alloc_size, GFP_NOWAIT); : 
strstr : if : 		ptr = (unsigned long)kzalloc(alloc_size, GFP_NOWAIT); : 
strstr : for : 		ptr = (unsigned long)kzalloc(alloc_size, GFP_NOWAIT); : 
strstr : while : 		ptr = (unsigned long)kzalloc(alloc_size, GFP_NOWAIT); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : #ifdef CONFIG_FAIR_GROUP_SCHED
strstr : if : #ifdef CONFIG_FAIR_GROUP_SCHED : 
strstr : for : #ifdef CONFIG_FAIR_GROUP_SCHED : 
strstr : while : #ifdef CONFIG_FAIR_GROUP_SCHED : 
str : 		root_task_group.se = (struct sched_entity **)ptr;
strstr : INIT : 		root_task_group.se = (struct sched_entity **)ptr; : 
strstr : if : 		root_task_group.se = (struct sched_entity **)ptr; : 
strstr : for : 		root_task_group.se = (struct sched_entity **)ptr; : 
strstr : while : 		root_task_group.se = (struct sched_entity **)ptr; : 
str : 		ptr += nr_cpu_ids * sizeof(void **);
strstr : INIT : 		ptr += nr_cpu_ids * sizeof(void **); : 
strstr : if : 		ptr += nr_cpu_ids * sizeof(void **); : 
strstr : for : 		ptr += nr_cpu_ids * sizeof(void **); : 
strstr : while : 		ptr += nr_cpu_ids * sizeof(void **); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 		root_task_group.cfs_rq = (struct cfs_rq **)ptr;
strstr : if : 		root_task_group.cfs_rq = (struct cfs_rq **)ptr; : 
strstr : for : 		root_task_group.cfs_rq = (struct cfs_rq **)ptr; : 
strstr : while : 		root_task_group.cfs_rq = (struct cfs_rq **)ptr; : 
str : 		ptr += nr_cpu_ids * sizeof(void **);
strstr : INIT : 		ptr += nr_cpu_ids * sizeof(void **); : 
strstr : if : 		ptr += nr_cpu_ids * sizeof(void **); : 
strstr : for : 		ptr += nr_cpu_ids * sizeof(void **); : 
strstr : while : 		ptr += nr_cpu_ids * sizeof(void **); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : #endif /* CONFIG_FAIR_GROUP_SCHED */
strstr : if : #endif /* CONFIG_FAIR_GROUP_SCHED */ : 
strstr : for : #endif /* CONFIG_FAIR_GROUP_SCHED */ : 
strstr : while : #endif /* CONFIG_FAIR_GROUP_SCHED */ : 
str : #ifdef CONFIG_RT_GROUP_SCHED
strstr : INIT : #ifdef CONFIG_RT_GROUP_SCHED : 
strstr : if : #ifdef CONFIG_RT_GROUP_SCHED : 
strstr : for : #ifdef CONFIG_RT_GROUP_SCHED : 
strstr : while : #ifdef CONFIG_RT_GROUP_SCHED : 
str : 		root_task_group.rt_se = (struct sched_rt_entity **)ptr;
strstr : INIT : 		root_task_group.rt_se = (struct sched_rt_entity **)ptr; : 
strstr : if : 		root_task_group.rt_se = (struct sched_rt_entity **)ptr; : 
strstr : for : 		root_task_group.rt_se = (struct sched_rt_entity **)ptr; : 
strstr : while : 		root_task_group.rt_se = (struct sched_rt_entity **)ptr; : 
str : 		ptr += nr_cpu_ids * sizeof(void **);
strstr : INIT : 		ptr += nr_cpu_ids * sizeof(void **); : 
strstr : if : 		ptr += nr_cpu_ids * sizeof(void **); : 
strstr : for : 		ptr += nr_cpu_ids * sizeof(void **); : 
strstr : while : 		ptr += nr_cpu_ids * sizeof(void **); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 		root_task_group.rt_rq = (struct rt_rq **)ptr;
strstr : if : 		root_task_group.rt_rq = (struct rt_rq **)ptr; : 
strstr : for : 		root_task_group.rt_rq = (struct rt_rq **)ptr; : 
strstr : while : 		root_task_group.rt_rq = (struct rt_rq **)ptr; : 
str : 		ptr += nr_cpu_ids * sizeof(void **);
strstr : INIT : 		ptr += nr_cpu_ids * sizeof(void **); : 
strstr : if : 		ptr += nr_cpu_ids * sizeof(void **); : 
strstr : for : 		ptr += nr_cpu_ids * sizeof(void **); : 
strstr : while : 		ptr += nr_cpu_ids * sizeof(void **); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : #endif /* CONFIG_RT_GROUP_SCHED */
strstr : if : #endif /* CONFIG_RT_GROUP_SCHED */ : 
strstr : for : #endif /* CONFIG_RT_GROUP_SCHED */ : 
strstr : while : #endif /* CONFIG_RT_GROUP_SCHED */ : 
str : #ifdef CONFIG_CPUMASK_OFFSTACK
strstr : INIT : #ifdef CONFIG_CPUMASK_OFFSTACK : 
strstr : if : #ifdef CONFIG_CPUMASK_OFFSTACK : 
strstr : for : #ifdef CONFIG_CPUMASK_OFFSTACK : 
strstr : while : #ifdef CONFIG_CPUMASK_OFFSTACK : 
str : 		for_each_possible_cpu(i) {
strstr : INIT : 		for_each_possible_cpu(i) { : 
strstr : if : 		for_each_possible_cpu(i) { : 
strstr : for : 		for_each_possible_cpu(i) { : 
strstr : while : 		for_each_possible_cpu(i) { : 
str : 			per_cpu(load_balance_mask, i) = (void *)ptr;
strstr : INIT : 			per_cpu(load_balance_mask, i) = (void *)ptr; : 
strstr : if : 			per_cpu(load_balance_mask, i) = (void *)ptr; : 
strstr : for : 			per_cpu(load_balance_mask, i) = (void *)ptr; : 
strstr : while : 			per_cpu(load_balance_mask, i) = (void *)ptr; : 
str : 			ptr += cpumask_size();
strstr : INIT : 			ptr += cpumask_size(); : 
strstr : if : 			ptr += cpumask_size(); : 
strstr : for : 			ptr += cpumask_size(); : 
strstr : while : 			ptr += cpumask_size(); : 
str : 		}
strstr : INIT : 		} : 
strstr : if : 		} : 
strstr : for : 		} : 
strstr : while : 		} : 
str : #endif /* CONFIG_CPUMASK_OFFSTACK */
strstr : INIT : #endif /* CONFIG_CPUMASK_OFFSTACK */ : 
strstr : if : #endif /* CONFIG_CPUMASK_OFFSTACK */ : 
strstr : for : #endif /* CONFIG_CPUMASK_OFFSTACK */ : 
strstr : while : #endif /* CONFIG_CPUMASK_OFFSTACK */ : 
str : 	}
strstr : INIT : 	} : 
strstr : if : 	} : 
strstr : for : 	} : 
strstr : while : 	} : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	init_rt_bandwidth(&def_rt_bandwidth,
strstr : if : 	init_rt_bandwidth(&def_rt_bandwidth, : 
strstr : for : 	init_rt_bandwidth(&def_rt_bandwidth, : 
strstr : while : 	init_rt_bandwidth(&def_rt_bandwidth, : 
str : 			global_rt_period(), global_rt_runtime());
strstr : INIT : 			global_rt_period(), global_rt_runtime()); : 
strstr : if : 			global_rt_period(), global_rt_runtime()); : 
strstr : for : 			global_rt_period(), global_rt_runtime()); : 
strstr : while : 			global_rt_period(), global_rt_runtime()); : 
str : 	init_dl_bandwidth(&def_dl_bandwidth,
strstr : INIT : 	init_dl_bandwidth(&def_dl_bandwidth, : 
strstr : if : 	init_dl_bandwidth(&def_dl_bandwidth, : 
strstr : for : 	init_dl_bandwidth(&def_dl_bandwidth, : 
strstr : while : 	init_dl_bandwidth(&def_dl_bandwidth, : 
str : 			global_rt_period(), global_rt_runtime());
strstr : INIT : 			global_rt_period(), global_rt_runtime()); : 
strstr : if : 			global_rt_period(), global_rt_runtime()); : 
strstr : for : 			global_rt_period(), global_rt_runtime()); : 
strstr : while : 			global_rt_period(), global_rt_runtime()); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : #ifdef CONFIG_SMP
strstr : if : #ifdef CONFIG_SMP : 
strstr : for : #ifdef CONFIG_SMP : 
strstr : while : #ifdef CONFIG_SMP : 
str : 	init_defrootdomain();
strstr : INIT : 	init_defrootdomain(); : 
strstr : if : 	init_defrootdomain(); : 
strstr : for : 	init_defrootdomain(); : 
strstr : while : 	init_defrootdomain(); : 
str : #endif
strstr : INIT : #endif : 
strstr : if : #endif : 
strstr : for : #endif : 
strstr : while : #endif : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : #ifdef CONFIG_RT_GROUP_SCHED
strstr : if : #ifdef CONFIG_RT_GROUP_SCHED : 
strstr : for : #ifdef CONFIG_RT_GROUP_SCHED : 
strstr : while : #ifdef CONFIG_RT_GROUP_SCHED : 
str : 	init_rt_bandwidth(&root_task_group.rt_bandwidth,
strstr : INIT : 	init_rt_bandwidth(&root_task_group.rt_bandwidth, : 
strstr : if : 	init_rt_bandwidth(&root_task_group.rt_bandwidth, : 
strstr : for : 	init_rt_bandwidth(&root_task_group.rt_bandwidth, : 
strstr : while : 	init_rt_bandwidth(&root_task_group.rt_bandwidth, : 
str : 			global_rt_period(), global_rt_runtime());
strstr : INIT : 			global_rt_period(), global_rt_runtime()); : 
strstr : if : 			global_rt_period(), global_rt_runtime()); : 
strstr : for : 			global_rt_period(), global_rt_runtime()); : 
strstr : while : 			global_rt_period(), global_rt_runtime()); : 
str : #endif /* CONFIG_RT_GROUP_SCHED */
strstr : INIT : #endif /* CONFIG_RT_GROUP_SCHED */ : 
strstr : if : #endif /* CONFIG_RT_GROUP_SCHED */ : 
strstr : for : #endif /* CONFIG_RT_GROUP_SCHED */ : 
strstr : while : #endif /* CONFIG_RT_GROUP_SCHED */ : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : #ifdef CONFIG_CGROUP_SCHED
strstr : if : #ifdef CONFIG_CGROUP_SCHED : 
strstr : for : #ifdef CONFIG_CGROUP_SCHED : 
strstr : while : #ifdef CONFIG_CGROUP_SCHED : 
str : 	list_add(&root_task_group.list, &task_groups);
strstr : INIT : 	list_add(&root_task_group.list, &task_groups); : 
strstr : if : 	list_add(&root_task_group.list, &task_groups); : 
strstr : for : 	list_add(&root_task_group.list, &task_groups); : 
strstr : while : 	list_add(&root_task_group.list, &task_groups); : 
str : 	INIT_LIST_HEAD(&root_task_group.children);
strstr : INIT : 	INIT_LIST_HEAD(&root_task_group.children); : 
strstr : if : 	INIT_LIST_HEAD(&root_task_group.children); : 
strstr : for : 	INIT_LIST_HEAD(&root_task_group.children); : 
strstr : while : 	INIT_LIST_HEAD(&root_task_group.children); : 
str : 	INIT_LIST_HEAD(&root_task_group.siblings);
strstr : INIT : 	INIT_LIST_HEAD(&root_task_group.siblings); : 
strstr : if : 	INIT_LIST_HEAD(&root_task_group.siblings); : 
strstr : for : 	INIT_LIST_HEAD(&root_task_group.siblings); : 
strstr : while : 	INIT_LIST_HEAD(&root_task_group.siblings); : 
str : 	autogroup_init(&init_task);
strstr : INIT : 	autogroup_init(&init_task); : 
strstr : if : 	autogroup_init(&init_task); : 
strstr : for : 	autogroup_init(&init_task); : 
strstr : while : 	autogroup_init(&init_task); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : #endif /* CONFIG_CGROUP_SCHED */
strstr : if : #endif /* CONFIG_CGROUP_SCHED */ : 
strstr : for : #endif /* CONFIG_CGROUP_SCHED */ : 
strstr : while : #endif /* CONFIG_CGROUP_SCHED */ : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	for_each_possible_cpu(i) {
strstr : if : 	for_each_possible_cpu(i) { : 
strstr : for : 	for_each_possible_cpu(i) { : 
strstr : while : 	for_each_possible_cpu(i) { : 
str : 		struct rq *rq;
strstr : INIT : 		struct rq *rq; : 
strstr : if : 		struct rq *rq; : 
strstr : for : 		struct rq *rq; : 
strstr : while : 		struct rq *rq; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 		rq = cpu_rq(i);
strstr : if : 		rq = cpu_rq(i); : 
strstr : for : 		rq = cpu_rq(i); : 
strstr : while : 		rq = cpu_rq(i); : 
str : 		raw_spin_lock_init(&rq->lock);
strstr : INIT : 		raw_spin_lock_init(&rq->lock); : 
strstr : if : 		raw_spin_lock_init(&rq->lock); : 
strstr : for : 		raw_spin_lock_init(&rq->lock); : 
strstr : while : 		raw_spin_lock_init(&rq->lock); : 
str : 		rq->nr_running = 0;
strstr : INIT : 		rq->nr_running = 0; : 
strstr : if : 		rq->nr_running = 0; : 
strstr : for : 		rq->nr_running = 0; : 
strstr : while : 		rq->nr_running = 0; : 
str : 		rq->calc_load_active = 0;
strstr : INIT : 		rq->calc_load_active = 0; : 
strstr : if : 		rq->calc_load_active = 0; : 
strstr : for : 		rq->calc_load_active = 0; : 
strstr : while : 		rq->calc_load_active = 0; : 
str : 		rq->calc_load_update = jiffies + LOAD_FREQ;
strstr : INIT : 		rq->calc_load_update = jiffies + LOAD_FREQ; : 
strstr : if : 		rq->calc_load_update = jiffies + LOAD_FREQ; : 
strstr : for : 		rq->calc_load_update = jiffies + LOAD_FREQ; : 
strstr : while : 		rq->calc_load_update = jiffies + LOAD_FREQ; : 
str : 		init_cfs_rq(&rq->cfs);
strstr : INIT : 		init_cfs_rq(&rq->cfs); : 
strstr : if : 		init_cfs_rq(&rq->cfs); : 
strstr : for : 		init_cfs_rq(&rq->cfs); : 
strstr : while : 		init_cfs_rq(&rq->cfs); : 
str : 		init_rt_rq(&rq->rt, rq);
strstr : INIT : 		init_rt_rq(&rq->rt, rq); : 
strstr : if : 		init_rt_rq(&rq->rt, rq); : 
strstr : for : 		init_rt_rq(&rq->rt, rq); : 
strstr : while : 		init_rt_rq(&rq->rt, rq); : 
str : 		init_dl_rq(&rq->dl, rq);
strstr : INIT : 		init_dl_rq(&rq->dl, rq); : 
strstr : if : 		init_dl_rq(&rq->dl, rq); : 
strstr : for : 		init_dl_rq(&rq->dl, rq); : 
strstr : while : 		init_dl_rq(&rq->dl, rq); : 
str : #ifdef CONFIG_FAIR_GROUP_SCHED
strstr : INIT : #ifdef CONFIG_FAIR_GROUP_SCHED : 
strstr : if : #ifdef CONFIG_FAIR_GROUP_SCHED : 
strstr : for : #ifdef CONFIG_FAIR_GROUP_SCHED : 
strstr : while : #ifdef CONFIG_FAIR_GROUP_SCHED : 
str : 		root_task_group.shares = ROOT_TASK_GROUP_LOAD;
strstr : INIT : 		root_task_group.shares = ROOT_TASK_GROUP_LOAD; : 
strstr : if : 		root_task_group.shares = ROOT_TASK_GROUP_LOAD; : 
strstr : for : 		root_task_group.shares = ROOT_TASK_GROUP_LOAD; : 
strstr : while : 		root_task_group.shares = ROOT_TASK_GROUP_LOAD; : 
str : 		INIT_LIST_HEAD(&rq->leaf_cfs_rq_list);
strstr : INIT : 		INIT_LIST_HEAD(&rq->leaf_cfs_rq_list); : 
strstr : if : 		INIT_LIST_HEAD(&rq->leaf_cfs_rq_list); : 
strstr : for : 		INIT_LIST_HEAD(&rq->leaf_cfs_rq_list); : 
strstr : while : 		INIT_LIST_HEAD(&rq->leaf_cfs_rq_list); : 
str : 		/*
strstr : INIT : 		/* : 
strstr : if : 		/* : 
strstr : for : 		/* : 
strstr : while : 		/* : 
str : 		 * How much cpu bandwidth does root_task_group get?
strstr : INIT : 		 * How much cpu bandwidth does root_task_group get? : 
strstr : if : 		 * How much cpu bandwidth does root_task_group get? : 
strstr : for : 		 * How much cpu bandwidth does root_task_group get? : 
strstr : while : 		 * How much cpu bandwidth does root_task_group get? : 
str : 		 *
strstr : INIT : 		 * : 
strstr : if : 		 * : 
strstr : for : 		 * : 
strstr : while : 		 * : 
str : 		 * In case of task-groups formed thr' the cgroup filesystem, it
strstr : INIT : 		 * In case of task-groups formed thr' the cgroup filesystem, it : 
strstr : if : 		 * In case of task-groups formed thr' the cgroup filesystem, it : 
strstr : for : 		 * In case of task-groups formed thr' the cgroup filesystem, it : 
strstr : while : 		 * In case of task-groups formed thr' the cgroup filesystem, it : 
str : 		 * gets 100% of the cpu resources in the system. This overall
strstr : INIT : 		 * gets 100% of the cpu resources in the system. This overall : 
strstr : if : 		 * gets 100% of the cpu resources in the system. This overall : 
strstr : for : 		 * gets 100% of the cpu resources in the system. This overall : 
strstr : while : 		 * gets 100% of the cpu resources in the system. This overall : 
str : 		 * system cpu resource is divided among the tasks of
strstr : INIT : 		 * system cpu resource is divided among the tasks of : 
strstr : if : 		 * system cpu resource is divided among the tasks of : 
strstr : for : 		 * system cpu resource is divided among the tasks of : 
strstr : while : 		 * system cpu resource is divided among the tasks of : 
str : 		 * root_task_group and its child task-groups in a fair manner,
strstr : INIT : 		 * root_task_group and its child task-groups in a fair manner, : 
strstr : if : 		 * root_task_group and its child task-groups in a fair manner, : 
strstr : for : 		 * root_task_group and its child task-groups in a fair manner, : 
strstr : while : 		 * root_task_group and its child task-groups in a fair manner, : 
str : 		 * based on each entity's (task or task-group's) weight
strstr : INIT : 		 * based on each entity's (task or task-group's) weight : 
strstr : if : 		 * based on each entity's (task or task-group's) weight : 
strstr : for : 		 * based on each entity's (task or task-group's) weight : 
strstr : while : 		 * based on each entity's (task or task-group's) weight : 
str : 		 * (se->load.weight).
strstr : INIT : 		 * (se->load.weight). : 
strstr : if : 		 * (se->load.weight). : 
strstr : for : 		 * (se->load.weight). : 
strstr : while : 		 * (se->load.weight). : 
str : 		 *
strstr : INIT : 		 * : 
strstr : if : 		 * : 
strstr : for : 		 * : 
strstr : while : 		 * : 
str : 		 * In other words, if root_task_group has 10 tasks of weight
strstr : INIT : 		 * In other words, if root_task_group has 10 tasks of weight : 
strstr : if : 		 * In other words, if root_task_group has 10 tasks of weight : 
strstr : for : 		 * In other words, if root_task_group has 10 tasks of weight : 
strstr : while : 		 * In other words, if root_task_group has 10 tasks of weight : 
str : 		 * 1024) and two child groups A0 and A1 (of weight 1024 each),
strstr : INIT : 		 * 1024) and two child groups A0 and A1 (of weight 1024 each), : 
strstr : if : 		 * 1024) and two child groups A0 and A1 (of weight 1024 each), : 
strstr : for : 		 * 1024) and two child groups A0 and A1 (of weight 1024 each), : 
strstr : while : 		 * 1024) and two child groups A0 and A1 (of weight 1024 each), : 
str : 		 * then A0's share of the cpu resource is:
strstr : INIT : 		 * then A0's share of the cpu resource is: : 
strstr : if : 		 * then A0's share of the cpu resource is: : 
strstr : for : 		 * then A0's share of the cpu resource is: : 
strstr : while : 		 * then A0's share of the cpu resource is: : 
str : 		 *
strstr : INIT : 		 * : 
strstr : if : 		 * : 
strstr : for : 		 * : 
strstr : while : 		 * : 
str : 		 *	A0's bandwidth = 1024 / (10*1024 + 1024 + 1024) = 8.33%
strstr : INIT : 		 *	A0's bandwidth = 1024 / (10*1024 + 1024 + 1024) = 8.33% : 
strstr : if : 		 *	A0's bandwidth = 1024 / (10*1024 + 1024 + 1024) = 8.33% : 
strstr : for : 		 *	A0's bandwidth = 1024 / (10*1024 + 1024 + 1024) = 8.33% : 
strstr : while : 		 *	A0's bandwidth = 1024 / (10*1024 + 1024 + 1024) = 8.33% : 
str : 		 *
strstr : INIT : 		 * : 
strstr : if : 		 * : 
strstr : for : 		 * : 
strstr : while : 		 * : 
str : 		 * We achieve this by letting root_task_group's tasks sit
strstr : INIT : 		 * We achieve this by letting root_task_group's tasks sit : 
strstr : if : 		 * We achieve this by letting root_task_group's tasks sit : 
strstr : for : 		 * We achieve this by letting root_task_group's tasks sit : 
strstr : while : 		 * We achieve this by letting root_task_group's tasks sit : 
str : 		 * directly in rq->cfs (i.e root_task_group->se[] = NULL).
strstr : INIT : 		 * directly in rq->cfs (i.e root_task_group->se[] = NULL). : 
strstr : if : 		 * directly in rq->cfs (i.e root_task_group->se[] = NULL). : 
strstr : for : 		 * directly in rq->cfs (i.e root_task_group->se[] = NULL). : 
strstr : while : 		 * directly in rq->cfs (i.e root_task_group->se[] = NULL). : 
str : 		 */
strstr : INIT : 		 */ : 
strstr : if : 		 */ : 
strstr : for : 		 */ : 
strstr : while : 		 */ : 
str : 		init_cfs_bandwidth(&root_task_group.cfs_bandwidth);
strstr : INIT : 		init_cfs_bandwidth(&root_task_group.cfs_bandwidth); : 
strstr : if : 		init_cfs_bandwidth(&root_task_group.cfs_bandwidth); : 
strstr : for : 		init_cfs_bandwidth(&root_task_group.cfs_bandwidth); : 
strstr : while : 		init_cfs_bandwidth(&root_task_group.cfs_bandwidth); : 
str : 		init_tg_cfs_entry(&root_task_group, &rq->cfs, NULL, i, NULL);
strstr : INIT : 		init_tg_cfs_entry(&root_task_group, &rq->cfs, NULL, i, NULL); : 
strstr : if : 		init_tg_cfs_entry(&root_task_group, &rq->cfs, NULL, i, NULL); : 
strstr : for : 		init_tg_cfs_entry(&root_task_group, &rq->cfs, NULL, i, NULL); : 
strstr : while : 		init_tg_cfs_entry(&root_task_group, &rq->cfs, NULL, i, NULL); : 
str : #endif /* CONFIG_FAIR_GROUP_SCHED */
strstr : INIT : #endif /* CONFIG_FAIR_GROUP_SCHED */ : 
strstr : if : #endif /* CONFIG_FAIR_GROUP_SCHED */ : 
strstr : for : #endif /* CONFIG_FAIR_GROUP_SCHED */ : 
strstr : while : #endif /* CONFIG_FAIR_GROUP_SCHED */ : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 		rq->rt.rt_runtime = def_rt_bandwidth.rt_runtime;
strstr : if : 		rq->rt.rt_runtime = def_rt_bandwidth.rt_runtime; : 
strstr : for : 		rq->rt.rt_runtime = def_rt_bandwidth.rt_runtime; : 
strstr : while : 		rq->rt.rt_runtime = def_rt_bandwidth.rt_runtime; : 
str : #ifdef CONFIG_RT_GROUP_SCHED
strstr : INIT : #ifdef CONFIG_RT_GROUP_SCHED : 
strstr : if : #ifdef CONFIG_RT_GROUP_SCHED : 
strstr : for : #ifdef CONFIG_RT_GROUP_SCHED : 
strstr : while : #ifdef CONFIG_RT_GROUP_SCHED : 
str : 		INIT_LIST_HEAD(&rq->leaf_rt_rq_list);
strstr : INIT : 		INIT_LIST_HEAD(&rq->leaf_rt_rq_list); : 
strstr : if : 		INIT_LIST_HEAD(&rq->leaf_rt_rq_list); : 
strstr : for : 		INIT_LIST_HEAD(&rq->leaf_rt_rq_list); : 
strstr : while : 		INIT_LIST_HEAD(&rq->leaf_rt_rq_list); : 
str : 		init_tg_rt_entry(&root_task_group, &rq->rt, NULL, i, NULL);
strstr : INIT : 		init_tg_rt_entry(&root_task_group, &rq->rt, NULL, i, NULL); : 
strstr : if : 		init_tg_rt_entry(&root_task_group, &rq->rt, NULL, i, NULL); : 
strstr : for : 		init_tg_rt_entry(&root_task_group, &rq->rt, NULL, i, NULL); : 
strstr : while : 		init_tg_rt_entry(&root_task_group, &rq->rt, NULL, i, NULL); : 
str : #endif
strstr : INIT : #endif : 
strstr : if : #endif : 
strstr : for : #endif : 
strstr : while : #endif : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 		for (j = 0; j < CPU_LOAD_IDX_MAX; j++)
strstr : if : 		for (j = 0; j < CPU_LOAD_IDX_MAX; j++) : 
strstr : for : 		for (j = 0; j < CPU_LOAD_IDX_MAX; j++) : 
strstr : while : 		for (j = 0; j < CPU_LOAD_IDX_MAX; j++) : 
str : 			rq->cpu_load[j] = 0;
strstr : INIT : 			rq->cpu_load[j] = 0; : 
strstr : if : 			rq->cpu_load[j] = 0; : 
strstr : for : 			rq->cpu_load[j] = 0; : 
strstr : while : 			rq->cpu_load[j] = 0; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 		rq->last_load_update_tick = jiffies;
strstr : if : 		rq->last_load_update_tick = jiffies; : 
strstr : for : 		rq->last_load_update_tick = jiffies; : 
strstr : while : 		rq->last_load_update_tick = jiffies; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : #ifdef CONFIG_SMP
strstr : if : #ifdef CONFIG_SMP : 
strstr : for : #ifdef CONFIG_SMP : 
strstr : while : #ifdef CONFIG_SMP : 
str : 		rq->sd = NULL;
strstr : INIT : 		rq->sd = NULL; : 
strstr : if : 		rq->sd = NULL; : 
strstr : for : 		rq->sd = NULL; : 
strstr : while : 		rq->sd = NULL; : 
str : 		rq->rd = NULL;
strstr : INIT : 		rq->rd = NULL; : 
strstr : if : 		rq->rd = NULL; : 
strstr : for : 		rq->rd = NULL; : 
strstr : while : 		rq->rd = NULL; : 
str : 		rq->cpu_power = SCHED_POWER_SCALE;
strstr : INIT : 		rq->cpu_power = SCHED_POWER_SCALE; : 
strstr : if : 		rq->cpu_power = SCHED_POWER_SCALE; : 
strstr : for : 		rq->cpu_power = SCHED_POWER_SCALE; : 
strstr : while : 		rq->cpu_power = SCHED_POWER_SCALE; : 
str : 		rq->post_schedule = 0;
strstr : INIT : 		rq->post_schedule = 0; : 
strstr : if : 		rq->post_schedule = 0; : 
strstr : for : 		rq->post_schedule = 0; : 
strstr : while : 		rq->post_schedule = 0; : 
str : 		rq->active_balance = 0;
strstr : INIT : 		rq->active_balance = 0; : 
strstr : if : 		rq->active_balance = 0; : 
strstr : for : 		rq->active_balance = 0; : 
strstr : while : 		rq->active_balance = 0; : 
str : 		rq->next_balance = jiffies;
strstr : INIT : 		rq->next_balance = jiffies; : 
strstr : if : 		rq->next_balance = jiffies; : 
strstr : for : 		rq->next_balance = jiffies; : 
strstr : while : 		rq->next_balance = jiffies; : 
str : 		rq->push_cpu = 0;
strstr : INIT : 		rq->push_cpu = 0; : 
strstr : if : 		rq->push_cpu = 0; : 
strstr : for : 		rq->push_cpu = 0; : 
strstr : while : 		rq->push_cpu = 0; : 
str : 		rq->cpu = i;
strstr : INIT : 		rq->cpu = i; : 
strstr : if : 		rq->cpu = i; : 
strstr : for : 		rq->cpu = i; : 
strstr : while : 		rq->cpu = i; : 
str : 		rq->online = 0;
strstr : INIT : 		rq->online = 0; : 
strstr : if : 		rq->online = 0; : 
strstr : for : 		rq->online = 0; : 
strstr : while : 		rq->online = 0; : 
str : 		rq->idle_stamp = 0;
strstr : INIT : 		rq->idle_stamp = 0; : 
strstr : if : 		rq->idle_stamp = 0; : 
strstr : for : 		rq->idle_stamp = 0; : 
strstr : while : 		rq->idle_stamp = 0; : 
str : 		rq->avg_idle = 2*sysctl_sched_migration_cost;
strstr : INIT : 		rq->avg_idle = 2*sysctl_sched_migration_cost; : 
strstr : if : 		rq->avg_idle = 2*sysctl_sched_migration_cost; : 
strstr : for : 		rq->avg_idle = 2*sysctl_sched_migration_cost; : 
strstr : while : 		rq->avg_idle = 2*sysctl_sched_migration_cost; : 
str : 		rq->max_idle_balance_cost = sysctl_sched_migration_cost;
strstr : INIT : 		rq->max_idle_balance_cost = sysctl_sched_migration_cost; : 
strstr : if : 		rq->max_idle_balance_cost = sysctl_sched_migration_cost; : 
strstr : for : 		rq->max_idle_balance_cost = sysctl_sched_migration_cost; : 
strstr : while : 		rq->max_idle_balance_cost = sysctl_sched_migration_cost; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 		INIT_LIST_HEAD(&rq->cfs_tasks);
strstr : if : 		INIT_LIST_HEAD(&rq->cfs_tasks); : 
strstr : for : 		INIT_LIST_HEAD(&rq->cfs_tasks); : 
strstr : while : 		INIT_LIST_HEAD(&rq->cfs_tasks); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 		rq_attach_root(rq, &def_root_domain);
strstr : if : 		rq_attach_root(rq, &def_root_domain); : 
strstr : for : 		rq_attach_root(rq, &def_root_domain); : 
strstr : while : 		rq_attach_root(rq, &def_root_domain); : 
str : #ifdef CONFIG_NO_HZ_COMMON
strstr : INIT : #ifdef CONFIG_NO_HZ_COMMON : 
strstr : if : #ifdef CONFIG_NO_HZ_COMMON : 
strstr : for : #ifdef CONFIG_NO_HZ_COMMON : 
strstr : while : #ifdef CONFIG_NO_HZ_COMMON : 
str : 		rq->nohz_flags = 0;
strstr : INIT : 		rq->nohz_flags = 0; : 
strstr : if : 		rq->nohz_flags = 0; : 
strstr : for : 		rq->nohz_flags = 0; : 
strstr : while : 		rq->nohz_flags = 0; : 
str : #endif
strstr : INIT : #endif : 
strstr : if : #endif : 
strstr : for : #endif : 
strstr : while : #endif : 
str : #ifdef CONFIG_NO_HZ_FULL
strstr : INIT : #ifdef CONFIG_NO_HZ_FULL : 
strstr : if : #ifdef CONFIG_NO_HZ_FULL : 
strstr : for : #ifdef CONFIG_NO_HZ_FULL : 
strstr : while : #ifdef CONFIG_NO_HZ_FULL : 
str : 		rq->last_sched_tick = 0;
strstr : INIT : 		rq->last_sched_tick = 0; : 
strstr : if : 		rq->last_sched_tick = 0; : 
strstr : for : 		rq->last_sched_tick = 0; : 
strstr : while : 		rq->last_sched_tick = 0; : 
str : #endif
strstr : INIT : #endif : 
strstr : if : #endif : 
strstr : for : #endif : 
strstr : while : #endif : 
str : #endif
strstr : INIT : #endif : 
strstr : if : #endif : 
strstr : for : #endif : 
strstr : while : #endif : 
str : 		init_rq_hrtick(rq);
strstr : INIT : 		init_rq_hrtick(rq); : 
strstr : if : 		init_rq_hrtick(rq); : 
strstr : for : 		init_rq_hrtick(rq); : 
strstr : while : 		init_rq_hrtick(rq); : 
str : 		atomic_set(&rq->nr_iowait, 0);
strstr : INIT : 		atomic_set(&rq->nr_iowait, 0); : 
strstr : if : 		atomic_set(&rq->nr_iowait, 0); : 
strstr : for : 		atomic_set(&rq->nr_iowait, 0); : 
strstr : while : 		atomic_set(&rq->nr_iowait, 0); : 
str : 	}
strstr : INIT : 	} : 
strstr : if : 	} : 
strstr : for : 	} : 
strstr : while : 	} : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	set_load_weight(&init_task);
strstr : if : 	set_load_weight(&init_task); : 
strstr : for : 	set_load_weight(&init_task); : 
strstr : while : 	set_load_weight(&init_task); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : #ifdef CONFIG_PREEMPT_NOTIFIERS
strstr : if : #ifdef CONFIG_PREEMPT_NOTIFIERS : 
strstr : for : #ifdef CONFIG_PREEMPT_NOTIFIERS : 
strstr : while : #ifdef CONFIG_PREEMPT_NOTIFIERS : 
str : 	INIT_HLIST_HEAD(&init_task.preempt_notifiers);
strstr : INIT : 	INIT_HLIST_HEAD(&init_task.preempt_notifiers); : 
strstr : if : 	INIT_HLIST_HEAD(&init_task.preempt_notifiers); : 
strstr : for : 	INIT_HLIST_HEAD(&init_task.preempt_notifiers); : 
strstr : while : 	INIT_HLIST_HEAD(&init_task.preempt_notifiers); : 
str : #endif
strstr : INIT : #endif : 
strstr : if : #endif : 
strstr : for : #endif : 
strstr : while : #endif : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	/*
strstr : if : 	/* : 
strstr : for : 	/* : 
strstr : while : 	/* : 
str : 	 * The boot idle thread does lazy MMU switching as well:
strstr : INIT : 	 * The boot idle thread does lazy MMU switching as well: : 
strstr : if : 	 * The boot idle thread does lazy MMU switching as well: : 
strstr : for : 	 * The boot idle thread does lazy MMU switching as well: : 
strstr : while : 	 * The boot idle thread does lazy MMU switching as well: : 
str : 	 */
strstr : INIT : 	 */ : 
strstr : if : 	 */ : 
strstr : for : 	 */ : 
strstr : while : 	 */ : 
str : 	atomic_inc(&init_mm.mm_count);
strstr : INIT : 	atomic_inc(&init_mm.mm_count); : 
strstr : if : 	atomic_inc(&init_mm.mm_count); : 
strstr : for : 	atomic_inc(&init_mm.mm_count); : 
strstr : while : 	atomic_inc(&init_mm.mm_count); : 
str : 	enter_lazy_tlb(&init_mm, current);
strstr : INIT : 	enter_lazy_tlb(&init_mm, current); : 
strstr : if : 	enter_lazy_tlb(&init_mm, current); : 
strstr : for : 	enter_lazy_tlb(&init_mm, current); : 
strstr : while : 	enter_lazy_tlb(&init_mm, current); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	/*
strstr : if : 	/* : 
strstr : for : 	/* : 
strstr : while : 	/* : 
str : 	 * Make us the idle thread. Technically, schedule() should not be
strstr : INIT : 	 * Make us the idle thread. Technically, schedule() should not be : 
strstr : if : 	 * Make us the idle thread. Technically, schedule() should not be : 
strstr : for : 	 * Make us the idle thread. Technically, schedule() should not be : 
strstr : while : 	 * Make us the idle thread. Technically, schedule() should not be : 
str : 	 * called from this thread, however somewhere below it might be,
strstr : INIT : 	 * called from this thread, however somewhere below it might be, : 
strstr : if : 	 * called from this thread, however somewhere below it might be, : 
strstr : for : 	 * called from this thread, however somewhere below it might be, : 
strstr : while : 	 * called from this thread, however somewhere below it might be, : 
str : 	 * but because we are the idle thread, we just pick up running again
strstr : INIT : 	 * but because we are the idle thread, we just pick up running again : 
strstr : if : 	 * but because we are the idle thread, we just pick up running again : 
strstr : for : 	 * but because we are the idle thread, we just pick up running again : 
strstr : while : 	 * but because we are the idle thread, we just pick up running again : 
str : 	 * when this runqueue becomes "idle".
strstr : INIT : 	 * when this runqueue becomes "idle". : 
strstr : if : 	 * when this runqueue becomes "idle". : 
strstr : for : 	 * when this runqueue becomes "idle". : 
strstr : while : 	 * when this runqueue becomes "idle". : 
str : 	 */
strstr : INIT : 	 */ : 
strstr : if : 	 */ : 
strstr : for : 	 */ : 
strstr : while : 	 */ : 
str : 	init_idle(current, smp_processor_id());
strstr : INIT : 	init_idle(current, smp_processor_id()); : 
strstr : if : 	init_idle(current, smp_processor_id()); : 
strstr : for : 	init_idle(current, smp_processor_id()); : 
strstr : while : 	init_idle(current, smp_processor_id()); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	calc_load_update = jiffies + LOAD_FREQ;
strstr : if : 	calc_load_update = jiffies + LOAD_FREQ; : 
strstr : for : 	calc_load_update = jiffies + LOAD_FREQ; : 
strstr : while : 	calc_load_update = jiffies + LOAD_FREQ; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	/*
strstr : if : 	/* : 
strstr : for : 	/* : 
strstr : while : 	/* : 
str : 	 * During early bootup we pretend to be a normal task:
strstr : INIT : 	 * During early bootup we pretend to be a normal task: : 
strstr : if : 	 * During early bootup we pretend to be a normal task: : 
strstr : for : 	 * During early bootup we pretend to be a normal task: : 
strstr : while : 	 * During early bootup we pretend to be a normal task: : 
str : 	 */
strstr : INIT : 	 */ : 
strstr : if : 	 */ : 
strstr : for : 	 */ : 
strstr : while : 	 */ : 
str : 	current->sched_class = &fair_sched_class;
strstr : INIT : 	current->sched_class = &fair_sched_class; : 
strstr : if : 	current->sched_class = &fair_sched_class; : 
strstr : for : 	current->sched_class = &fair_sched_class; : 
strstr : while : 	current->sched_class = &fair_sched_class; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : #ifdef CONFIG_SMP
strstr : if : #ifdef CONFIG_SMP : 
strstr : for : #ifdef CONFIG_SMP : 
strstr : while : #ifdef CONFIG_SMP : 
str : 	zalloc_cpumask_var(&sched_domains_tmpmask, GFP_NOWAIT);
strstr : INIT : 	zalloc_cpumask_var(&sched_domains_tmpmask, GFP_NOWAIT); : 
strstr : if : 	zalloc_cpumask_var(&sched_domains_tmpmask, GFP_NOWAIT); : 
strstr : for : 	zalloc_cpumask_var(&sched_domains_tmpmask, GFP_NOWAIT); : 
strstr : while : 	zalloc_cpumask_var(&sched_domains_tmpmask, GFP_NOWAIT); : 
str : 	/* May be allocated at isolcpus cmdline parse time */
strstr : INIT : 	/* May be allocated at isolcpus cmdline parse time */ : 
strstr : if : 	/* May be allocated at isolcpus cmdline parse time */ : 
strstr : for : 	/* May be allocated at isolcpus cmdline parse time */ : 
strstr : while : 	/* May be allocated at isolcpus cmdline parse time */ : 
str : 	if (cpu_isolated_map == NULL)
strstr : INIT : 	if (cpu_isolated_map == NULL) : 
strstr : if : 	if (cpu_isolated_map == NULL) : 
strstr : for : 	if (cpu_isolated_map == NULL) : 
strstr : while : 	if (cpu_isolated_map == NULL) : 
str : 		zalloc_cpumask_var(&cpu_isolated_map, GFP_NOWAIT);
strstr : INIT : 		zalloc_cpumask_var(&cpu_isolated_map, GFP_NOWAIT); : 
strstr : if : 		zalloc_cpumask_var(&cpu_isolated_map, GFP_NOWAIT); : 
strstr : for : 		zalloc_cpumask_var(&cpu_isolated_map, GFP_NOWAIT); : 
strstr : while : 		zalloc_cpumask_var(&cpu_isolated_map, GFP_NOWAIT); : 
str : 	idle_thread_set_boot_cpu();
strstr : INIT : 	idle_thread_set_boot_cpu(); : 
strstr : if : 	idle_thread_set_boot_cpu(); : 
strstr : for : 	idle_thread_set_boot_cpu(); : 
strstr : while : 	idle_thread_set_boot_cpu(); : 
str : #endif
strstr : INIT : #endif : 
strstr : if : #endif : 
strstr : for : #endif : 
strstr : while : #endif : 
str : 	init_sched_fair_class();
strstr : INIT : 	init_sched_fair_class(); : 
strstr : if : 	init_sched_fair_class(); : 
strstr : for : 	init_sched_fair_class(); : 
strstr : while : 	init_sched_fair_class(); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	scheduler_running = 1;
strstr : if : 	scheduler_running = 1; : 
strstr : for : 	scheduler_running = 1; : 
strstr : while : 	scheduler_running = 1; : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : #ifdef CONFIG_DEBUG_ATOMIC_SLEEP
strstr : if : #ifdef CONFIG_DEBUG_ATOMIC_SLEEP : 
strstr : for : #ifdef CONFIG_DEBUG_ATOMIC_SLEEP : 
strstr : while : #ifdef CONFIG_DEBUG_ATOMIC_SLEEP : 
str : static inline int preempt_count_equals(int preempt_offset)
strstr : INIT : static inline int preempt_count_equals(int preempt_offset) : 
strstr : if : static inline int preempt_count_equals(int preempt_offset) : 
strstr : for : static inline int preempt_count_equals(int preempt_offset) : 
strstr : while : static inline int preempt_count_equals(int preempt_offset) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	int nested = (preempt_count() & ~PREEMPT_ACTIVE) + rcu_preempt_depth();
strstr : INIT : 	int nested = (preempt_count() & ~PREEMPT_ACTIVE) + rcu_preempt_depth(); : 
strstr : if : 	int nested = (preempt_count() & ~PREEMPT_ACTIVE) + rcu_preempt_depth(); : 
strstr : for : 	int nested = (preempt_count() & ~PREEMPT_ACTIVE) + rcu_preempt_depth(); : 
strstr : while : 	int nested = (preempt_count() & ~PREEMPT_ACTIVE) + rcu_preempt_depth(); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	return (nested == preempt_offset);
strstr : if : 	return (nested == preempt_offset); : 
strstr : for : 	return (nested == preempt_offset); : 
strstr : while : 	return (nested == preempt_offset); : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : void __might_sleep(const char *file, int line, int preempt_offset)
strstr : if : void __might_sleep(const char *file, int line, int preempt_offset) : 
strstr : for : void __might_sleep(const char *file, int line, int preempt_offset) : 
strstr : while : void __might_sleep(const char *file, int line, int preempt_offset) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	static unsigned long prev_jiffy;	/* ratelimiting */
strstr : INIT : 	static unsigned long prev_jiffy;	/* ratelimiting */ : 
strstr : if : 	static unsigned long prev_jiffy;	/* ratelimiting */ : 
strstr : for : 	static unsigned long prev_jiffy;	/* ratelimiting */ : 
strstr : while : 	static unsigned long prev_jiffy;	/* ratelimiting */ : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	rcu_sleep_check(); /* WARN_ON_ONCE() by default, no rate limit reqd. */
strstr : if : 	rcu_sleep_check(); /* WARN_ON_ONCE() by default, no rate limit reqd. */ : 
strstr : for : 	rcu_sleep_check(); /* WARN_ON_ONCE() by default, no rate limit reqd. */ : 
strstr : while : 	rcu_sleep_check(); /* WARN_ON_ONCE() by default, no rate limit reqd. */ : 
str : 	if ((preempt_count_equals(preempt_offset) && !irqs_disabled()) ||
strstr : INIT : 	if ((preempt_count_equals(preempt_offset) && !irqs_disabled()) || : 
strstr : if : 	if ((preempt_count_equals(preempt_offset) && !irqs_disabled()) || : 
strstr : for : 	if ((preempt_count_equals(preempt_offset) && !irqs_disabled()) || : 
strstr : while : 	if ((preempt_count_equals(preempt_offset) && !irqs_disabled()) || : 
str : 	    system_state != SYSTEM_RUNNING || oops_in_progress)
strstr : INIT : 	    system_state != SYSTEM_RUNNING || oops_in_progress) : 
strstr : if : 	    system_state != SYSTEM_RUNNING || oops_in_progress) : 
strstr : for : 	    system_state != SYSTEM_RUNNING || oops_in_progress) : 
strstr : while : 	    system_state != SYSTEM_RUNNING || oops_in_progress) : 
str : 		return;
strstr : INIT : 		return; : 
strstr : if : 		return; : 
strstr : for : 		return; : 
strstr : while : 		return; : 
str : 	if (time_before(jiffies, prev_jiffy + HZ) && prev_jiffy)
strstr : INIT : 	if (time_before(jiffies, prev_jiffy + HZ) && prev_jiffy) : 
strstr : if : 	if (time_before(jiffies, prev_jiffy + HZ) && prev_jiffy) : 
strstr : for : 	if (time_before(jiffies, prev_jiffy + HZ) && prev_jiffy) : 
strstr : while : 	if (time_before(jiffies, prev_jiffy + HZ) && prev_jiffy) : 
str : 		return;
strstr : INIT : 		return; : 
strstr : if : 		return; : 
strstr : for : 		return; : 
strstr : while : 		return; : 
str : 	prev_jiffy = jiffies;
strstr : INIT : 	prev_jiffy = jiffies; : 
strstr : if : 	prev_jiffy = jiffies; : 
strstr : for : 	prev_jiffy = jiffies; : 
strstr : while : 	prev_jiffy = jiffies; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	printk(KERN_ERR
strstr : if : 	printk(KERN_ERR : 
strstr : for : 	printk(KERN_ERR : 
strstr : while : 	printk(KERN_ERR : 
str : 		"BUG: sleeping function called from invalid context at %s:%d\n",
strstr : INIT : 		"BUG: sleeping function called from invalid context at %s:%d\n", : 
strstr : if : 		"BUG: sleeping function called from invalid context at %s:%d\n", : 
strstr : for : 		"BUG: sleeping function called from invalid context at %s:%d\n", : 
strstr : while : 		"BUG: sleeping function called from invalid context at %s:%d\n", : 
str : 			file, line);
strstr : INIT : 			file, line); : 
strstr : if : 			file, line); : 
strstr : for : 			file, line); : 
strstr : while : 			file, line); : 
str : 	printk(KERN_ERR
strstr : INIT : 	printk(KERN_ERR : 
strstr : if : 	printk(KERN_ERR : 
strstr : for : 	printk(KERN_ERR : 
strstr : while : 	printk(KERN_ERR : 
str : 		"in_atomic(): %d, irqs_disabled(): %d, pid: %d, name: %s\n",
strstr : INIT : 		"in_atomic(): %d, irqs_disabled(): %d, pid: %d, name: %s\n", : 
strstr : if : 		"in_atomic(): %d, irqs_disabled(): %d, pid: %d, name: %s\n", : 
strstr : for : 		"in_atomic(): %d, irqs_disabled(): %d, pid: %d, name: %s\n", : 
strstr : while : 		"in_atomic(): %d, irqs_disabled(): %d, pid: %d, name: %s\n", : 
str : 			in_atomic(), irqs_disabled(),
strstr : INIT : 			in_atomic(), irqs_disabled(), : 
strstr : if : 			in_atomic(), irqs_disabled(), : 
strstr : for : 			in_atomic(), irqs_disabled(), : 
strstr : while : 			in_atomic(), irqs_disabled(), : 
str : 			current->pid, current->comm);
strstr : INIT : 			current->pid, current->comm); : 
strstr : if : 			current->pid, current->comm); : 
strstr : for : 			current->pid, current->comm); : 
strstr : while : 			current->pid, current->comm); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	debug_show_held_locks(current);
strstr : if : 	debug_show_held_locks(current); : 
strstr : for : 	debug_show_held_locks(current); : 
strstr : while : 	debug_show_held_locks(current); : 
str : 	if (irqs_disabled())
strstr : INIT : 	if (irqs_disabled()) : 
strstr : if : 	if (irqs_disabled()) : 
strstr : for : 	if (irqs_disabled()) : 
strstr : while : 	if (irqs_disabled()) : 
str : 		print_irqtrace_events(current);
strstr : INIT : 		print_irqtrace_events(current); : 
strstr : if : 		print_irqtrace_events(current); : 
strstr : for : 		print_irqtrace_events(current); : 
strstr : while : 		print_irqtrace_events(current); : 
str : 	dump_stack();
strstr : INIT : 	dump_stack(); : 
strstr : if : 	dump_stack(); : 
strstr : for : 	dump_stack(); : 
strstr : while : 	dump_stack(); : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : EXPORT_SYMBOL(__might_sleep);
strstr : INIT : EXPORT_SYMBOL(__might_sleep); : 
strstr : if : EXPORT_SYMBOL(__might_sleep); : 
strstr : for : EXPORT_SYMBOL(__might_sleep); : 
strstr : while : EXPORT_SYMBOL(__might_sleep); : 
str : #endif
strstr : INIT : #endif : 
strstr : if : #endif : 
strstr : for : #endif : 
strstr : while : #endif : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : #ifdef CONFIG_MAGIC_SYSRQ
strstr : if : #ifdef CONFIG_MAGIC_SYSRQ : 
strstr : for : #ifdef CONFIG_MAGIC_SYSRQ : 
strstr : while : #ifdef CONFIG_MAGIC_SYSRQ : 
str : static void normalize_task(struct rq *rq, struct task_struct *p)
strstr : INIT : static void normalize_task(struct rq *rq, struct task_struct *p) : 
strstr : if : static void normalize_task(struct rq *rq, struct task_struct *p) : 
strstr : for : static void normalize_task(struct rq *rq, struct task_struct *p) : 
strstr : while : static void normalize_task(struct rq *rq, struct task_struct *p) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	const struct sched_class *prev_class = p->sched_class;
strstr : INIT : 	const struct sched_class *prev_class = p->sched_class; : 
strstr : if : 	const struct sched_class *prev_class = p->sched_class; : 
strstr : for : 	const struct sched_class *prev_class = p->sched_class; : 
strstr : while : 	const struct sched_class *prev_class = p->sched_class; : 
str : 	struct sched_attr attr = {
strstr : INIT : 	struct sched_attr attr = { : 
strstr : if : 	struct sched_attr attr = { : 
strstr : for : 	struct sched_attr attr = { : 
strstr : while : 	struct sched_attr attr = { : 
str : 		.sched_policy = SCHED_NORMAL,
strstr : INIT : 		.sched_policy = SCHED_NORMAL, : 
strstr : if : 		.sched_policy = SCHED_NORMAL, : 
strstr : for : 		.sched_policy = SCHED_NORMAL, : 
strstr : while : 		.sched_policy = SCHED_NORMAL, : 
str : 	};
strstr : INIT : 	}; : 
strstr : if : 	}; : 
strstr : for : 	}; : 
strstr : while : 	}; : 
str : 	int old_prio = p->prio;
strstr : INIT : 	int old_prio = p->prio; : 
strstr : if : 	int old_prio = p->prio; : 
strstr : for : 	int old_prio = p->prio; : 
strstr : while : 	int old_prio = p->prio; : 
str : 	int on_rq;
strstr : INIT : 	int on_rq; : 
strstr : if : 	int on_rq; : 
strstr : for : 	int on_rq; : 
strstr : while : 	int on_rq; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	on_rq = p->on_rq;
strstr : if : 	on_rq = p->on_rq; : 
strstr : for : 	on_rq = p->on_rq; : 
strstr : while : 	on_rq = p->on_rq; : 
str : 	if (on_rq)
strstr : INIT : 	if (on_rq) : 
strstr : if : 	if (on_rq) : 
strstr : for : 	if (on_rq) : 
strstr : while : 	if (on_rq) : 
str : 		dequeue_task(rq, p, 0);
strstr : INIT : 		dequeue_task(rq, p, 0); : 
strstr : if : 		dequeue_task(rq, p, 0); : 
strstr : for : 		dequeue_task(rq, p, 0); : 
strstr : while : 		dequeue_task(rq, p, 0); : 
str : 	__setscheduler(rq, p, &attr);
strstr : INIT : 	__setscheduler(rq, p, &attr); : 
strstr : if : 	__setscheduler(rq, p, &attr); : 
strstr : for : 	__setscheduler(rq, p, &attr); : 
strstr : while : 	__setscheduler(rq, p, &attr); : 
str : 	if (on_rq) {
strstr : INIT : 	if (on_rq) { : 
strstr : if : 	if (on_rq) { : 
strstr : for : 	if (on_rq) { : 
strstr : while : 	if (on_rq) { : 
str : 		enqueue_task(rq, p, 0);
strstr : INIT : 		enqueue_task(rq, p, 0); : 
strstr : if : 		enqueue_task(rq, p, 0); : 
strstr : for : 		enqueue_task(rq, p, 0); : 
strstr : while : 		enqueue_task(rq, p, 0); : 
str : 		resched_task(rq->curr);
strstr : INIT : 		resched_task(rq->curr); : 
strstr : if : 		resched_task(rq->curr); : 
strstr : for : 		resched_task(rq->curr); : 
strstr : while : 		resched_task(rq->curr); : 
str : 	}
strstr : INIT : 	} : 
strstr : if : 	} : 
strstr : for : 	} : 
strstr : while : 	} : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	check_class_changed(rq, p, prev_class, old_prio);
strstr : if : 	check_class_changed(rq, p, prev_class, old_prio); : 
strstr : for : 	check_class_changed(rq, p, prev_class, old_prio); : 
strstr : while : 	check_class_changed(rq, p, prev_class, old_prio); : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : void normalize_rt_tasks(void)
strstr : if : void normalize_rt_tasks(void) : 
strstr : for : void normalize_rt_tasks(void) : 
strstr : while : void normalize_rt_tasks(void) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	struct task_struct *g, *p;
strstr : INIT : 	struct task_struct *g, *p; : 
strstr : if : 	struct task_struct *g, *p; : 
strstr : for : 	struct task_struct *g, *p; : 
strstr : while : 	struct task_struct *g, *p; : 
str : 	unsigned long flags;
strstr : INIT : 	unsigned long flags; : 
strstr : if : 	unsigned long flags; : 
strstr : for : 	unsigned long flags; : 
strstr : while : 	unsigned long flags; : 
str : 	struct rq *rq;
strstr : INIT : 	struct rq *rq; : 
strstr : if : 	struct rq *rq; : 
strstr : for : 	struct rq *rq; : 
strstr : while : 	struct rq *rq; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	read_lock_irqsave(&tasklist_lock, flags);
strstr : if : 	read_lock_irqsave(&tasklist_lock, flags); : 
strstr : for : 	read_lock_irqsave(&tasklist_lock, flags); : 
strstr : while : 	read_lock_irqsave(&tasklist_lock, flags); : 
str : 	do_each_thread(g, p) {
strstr : INIT : 	do_each_thread(g, p) { : 
strstr : if : 	do_each_thread(g, p) { : 
strstr : for : 	do_each_thread(g, p) { : 
strstr : while : 	do_each_thread(g, p) { : 
str : 		/*
strstr : INIT : 		/* : 
strstr : if : 		/* : 
strstr : for : 		/* : 
strstr : while : 		/* : 
str : 		 * Only normalize user tasks:
strstr : INIT : 		 * Only normalize user tasks: : 
strstr : if : 		 * Only normalize user tasks: : 
strstr : for : 		 * Only normalize user tasks: : 
strstr : while : 		 * Only normalize user tasks: : 
str : 		 */
strstr : INIT : 		 */ : 
strstr : if : 		 */ : 
strstr : for : 		 */ : 
strstr : while : 		 */ : 
str : 		if (!p->mm)
strstr : INIT : 		if (!p->mm) : 
strstr : if : 		if (!p->mm) : 
strstr : for : 		if (!p->mm) : 
strstr : while : 		if (!p->mm) : 
str : 			continue;
strstr : INIT : 			continue; : 
strstr : if : 			continue; : 
strstr : for : 			continue; : 
strstr : while : 			continue; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 		p->se.exec_start		= 0;
strstr : if : 		p->se.exec_start		= 0; : 
strstr : for : 		p->se.exec_start		= 0; : 
strstr : while : 		p->se.exec_start		= 0; : 
str : #ifdef CONFIG_SCHEDSTATS
strstr : INIT : #ifdef CONFIG_SCHEDSTATS : 
strstr : if : #ifdef CONFIG_SCHEDSTATS : 
strstr : for : #ifdef CONFIG_SCHEDSTATS : 
strstr : while : #ifdef CONFIG_SCHEDSTATS : 
str : 		p->se.statistics.wait_start	= 0;
strstr : INIT : 		p->se.statistics.wait_start	= 0; : 
strstr : if : 		p->se.statistics.wait_start	= 0; : 
strstr : for : 		p->se.statistics.wait_start	= 0; : 
strstr : while : 		p->se.statistics.wait_start	= 0; : 
str : 		p->se.statistics.sleep_start	= 0;
strstr : INIT : 		p->se.statistics.sleep_start	= 0; : 
strstr : if : 		p->se.statistics.sleep_start	= 0; : 
strstr : for : 		p->se.statistics.sleep_start	= 0; : 
strstr : while : 		p->se.statistics.sleep_start	= 0; : 
str : 		p->se.statistics.block_start	= 0;
strstr : INIT : 		p->se.statistics.block_start	= 0; : 
strstr : if : 		p->se.statistics.block_start	= 0; : 
strstr : for : 		p->se.statistics.block_start	= 0; : 
strstr : while : 		p->se.statistics.block_start	= 0; : 
str : #endif
strstr : INIT : #endif : 
strstr : if : #endif : 
strstr : for : #endif : 
strstr : while : #endif : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 		if (!dl_task(p) && !rt_task(p)) {
strstr : if : 		if (!dl_task(p) && !rt_task(p)) { : 
strstr : for : 		if (!dl_task(p) && !rt_task(p)) { : 
strstr : while : 		if (!dl_task(p) && !rt_task(p)) { : 
str : 			/*
strstr : INIT : 			/* : 
strstr : if : 			/* : 
strstr : for : 			/* : 
strstr : while : 			/* : 
str : 			 * Renice negative nice level userspace
strstr : INIT : 			 * Renice negative nice level userspace : 
strstr : if : 			 * Renice negative nice level userspace : 
strstr : for : 			 * Renice negative nice level userspace : 
strstr : while : 			 * Renice negative nice level userspace : 
str : 			 * tasks back to 0:
strstr : INIT : 			 * tasks back to 0: : 
strstr : if : 			 * tasks back to 0: : 
strstr : for : 			 * tasks back to 0: : 
strstr : while : 			 * tasks back to 0: : 
str : 			 */
strstr : INIT : 			 */ : 
strstr : if : 			 */ : 
strstr : for : 			 */ : 
strstr : while : 			 */ : 
str : 			if (TASK_NICE(p) < 0 && p->mm)
strstr : INIT : 			if (TASK_NICE(p) < 0 && p->mm) : 
strstr : if : 			if (TASK_NICE(p) < 0 && p->mm) : 
strstr : for : 			if (TASK_NICE(p) < 0 && p->mm) : 
strstr : while : 			if (TASK_NICE(p) < 0 && p->mm) : 
str : 				set_user_nice(p, 0);
strstr : INIT : 				set_user_nice(p, 0); : 
strstr : if : 				set_user_nice(p, 0); : 
strstr : for : 				set_user_nice(p, 0); : 
strstr : while : 				set_user_nice(p, 0); : 
str : 			continue;
strstr : INIT : 			continue; : 
strstr : if : 			continue; : 
strstr : for : 			continue; : 
strstr : while : 			continue; : 
str : 		}
strstr : INIT : 		} : 
strstr : if : 		} : 
strstr : for : 		} : 
strstr : while : 		} : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 		raw_spin_lock(&p->pi_lock);
strstr : if : 		raw_spin_lock(&p->pi_lock); : 
strstr : for : 		raw_spin_lock(&p->pi_lock); : 
strstr : while : 		raw_spin_lock(&p->pi_lock); : 
str : 		rq = __task_rq_lock(p);
strstr : INIT : 		rq = __task_rq_lock(p); : 
strstr : if : 		rq = __task_rq_lock(p); : 
strstr : for : 		rq = __task_rq_lock(p); : 
strstr : while : 		rq = __task_rq_lock(p); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 		normalize_task(rq, p);
strstr : if : 		normalize_task(rq, p); : 
strstr : for : 		normalize_task(rq, p); : 
strstr : while : 		normalize_task(rq, p); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 		__task_rq_unlock(rq);
strstr : if : 		__task_rq_unlock(rq); : 
strstr : for : 		__task_rq_unlock(rq); : 
strstr : while : 		__task_rq_unlock(rq); : 
str : 		raw_spin_unlock(&p->pi_lock);
strstr : INIT : 		raw_spin_unlock(&p->pi_lock); : 
strstr : if : 		raw_spin_unlock(&p->pi_lock); : 
strstr : for : 		raw_spin_unlock(&p->pi_lock); : 
strstr : while : 		raw_spin_unlock(&p->pi_lock); : 
str : 	} while_each_thread(g, p);
strstr : INIT : 	} while_each_thread(g, p); : 
strstr : if : 	} while_each_thread(g, p); : 
strstr : for : 	} while_each_thread(g, p); : 
strstr : while : 	} while_each_thread(g, p); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	read_unlock_irqrestore(&tasklist_lock, flags);
strstr : if : 	read_unlock_irqrestore(&tasklist_lock, flags); : 
strstr : for : 	read_unlock_irqrestore(&tasklist_lock, flags); : 
strstr : while : 	read_unlock_irqrestore(&tasklist_lock, flags); : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : #endif /* CONFIG_MAGIC_SYSRQ */
strstr : if : #endif /* CONFIG_MAGIC_SYSRQ */ : 
strstr : for : #endif /* CONFIG_MAGIC_SYSRQ */ : 
strstr : while : #endif /* CONFIG_MAGIC_SYSRQ */ : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : #if defined(CONFIG_IA64) || defined(CONFIG_KGDB_KDB)
strstr : if : #if defined(CONFIG_IA64) || defined(CONFIG_KGDB_KDB) : 
strstr : for : #if defined(CONFIG_IA64) || defined(CONFIG_KGDB_KDB) : 
strstr : while : #if defined(CONFIG_IA64) || defined(CONFIG_KGDB_KDB) : 
str : /*
strstr : INIT : /* : 
strstr : if : /* : 
strstr : for : /* : 
strstr : while : /* : 
str :  * These functions are only useful for the IA64 MCA handling, or kdb.
strstr : INIT :  * These functions are only useful for the IA64 MCA handling, or kdb. : 
strstr : if :  * These functions are only useful for the IA64 MCA handling, or kdb. : 
strstr : for :  * These functions are only useful for the IA64 MCA handling, or kdb. : 
strstr : while :  * These functions are only useful for the IA64 MCA handling, or kdb. : 
str :  *
strstr : INIT :  * : 
strstr : if :  * : 
strstr : for :  * : 
strstr : while :  * : 
str :  * They can only be called when the whole system has been
strstr : INIT :  * They can only be called when the whole system has been : 
strstr : if :  * They can only be called when the whole system has been : 
strstr : for :  * They can only be called when the whole system has been : 
strstr : while :  * They can only be called when the whole system has been : 
str :  * stopped - every CPU needs to be quiescent, and no scheduling
strstr : INIT :  * stopped - every CPU needs to be quiescent, and no scheduling : 
strstr : if :  * stopped - every CPU needs to be quiescent, and no scheduling : 
strstr : for :  * stopped - every CPU needs to be quiescent, and no scheduling : 
strstr : while :  * stopped - every CPU needs to be quiescent, and no scheduling : 
str :  * activity can take place. Using them for anything else would
strstr : INIT :  * activity can take place. Using them for anything else would : 
strstr : if :  * activity can take place. Using them for anything else would : 
strstr : for :  * activity can take place. Using them for anything else would : 
strstr : while :  * activity can take place. Using them for anything else would : 
str :  * be a serious bug, and as a result, they aren't even visible
strstr : INIT :  * be a serious bug, and as a result, they aren't even visible : 
strstr : if :  * be a serious bug, and as a result, they aren't even visible : 
strstr : for :  * be a serious bug, and as a result, they aren't even visible : 
strstr : while :  * be a serious bug, and as a result, they aren't even visible : 
str :  * under any other configuration.
strstr : INIT :  * under any other configuration. : 
strstr : if :  * under any other configuration. : 
strstr : for :  * under any other configuration. : 
strstr : while :  * under any other configuration. : 
str :  */
strstr : INIT :  */ : 
strstr : if :  */ : 
strstr : for :  */ : 
strstr : while :  */ : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : /**
strstr : if : /** : 
strstr : for : /** : 
strstr : while : /** : 
str :  * curr_task - return the current task for a given cpu.
strstr : INIT :  * curr_task - return the current task for a given cpu. : 
strstr : if :  * curr_task - return the current task for a given cpu. : 
strstr : for :  * curr_task - return the current task for a given cpu. : 
strstr : while :  * curr_task - return the current task for a given cpu. : 
str :  * @cpu: the processor in question.
strstr : INIT :  * @cpu: the processor in question. : 
strstr : if :  * @cpu: the processor in question. : 
strstr : for :  * @cpu: the processor in question. : 
strstr : while :  * @cpu: the processor in question. : 
str :  *
strstr : INIT :  * : 
strstr : if :  * : 
strstr : for :  * : 
strstr : while :  * : 
str :  * ONLY VALID WHEN THE WHOLE SYSTEM IS STOPPED!
strstr : INIT :  * ONLY VALID WHEN THE WHOLE SYSTEM IS STOPPED! : 
strstr : if :  * ONLY VALID WHEN THE WHOLE SYSTEM IS STOPPED! : 
strstr : for :  * ONLY VALID WHEN THE WHOLE SYSTEM IS STOPPED! : 
strstr : while :  * ONLY VALID WHEN THE WHOLE SYSTEM IS STOPPED! : 
str :  *
strstr : INIT :  * : 
strstr : if :  * : 
strstr : for :  * : 
strstr : while :  * : 
str :  * Return: The current task for @cpu.
strstr : INIT :  * Return: The current task for @cpu. : 
strstr : if :  * Return: The current task for @cpu. : 
strstr : for :  * Return: The current task for @cpu. : 
strstr : while :  * Return: The current task for @cpu. : 
str :  */
strstr : INIT :  */ : 
strstr : if :  */ : 
strstr : for :  */ : 
strstr : while :  */ : 
str : struct task_struct *curr_task(int cpu)
strstr : INIT : struct task_struct *curr_task(int cpu) : 
strstr : if : struct task_struct *curr_task(int cpu) : 
strstr : for : struct task_struct *curr_task(int cpu) : 
strstr : while : struct task_struct *curr_task(int cpu) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	return cpu_curr(cpu);
strstr : INIT : 	return cpu_curr(cpu); : 
strstr : if : 	return cpu_curr(cpu); : 
strstr : for : 	return cpu_curr(cpu); : 
strstr : while : 	return cpu_curr(cpu); : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : #endif /* defined(CONFIG_IA64) || defined(CONFIG_KGDB_KDB) */
strstr : if : #endif /* defined(CONFIG_IA64) || defined(CONFIG_KGDB_KDB) */ : 
strstr : for : #endif /* defined(CONFIG_IA64) || defined(CONFIG_KGDB_KDB) */ : 
strstr : while : #endif /* defined(CONFIG_IA64) || defined(CONFIG_KGDB_KDB) */ : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : #ifdef CONFIG_IA64
strstr : if : #ifdef CONFIG_IA64 : 
strstr : for : #ifdef CONFIG_IA64 : 
strstr : while : #ifdef CONFIG_IA64 : 
str : /**
strstr : INIT : /** : 
strstr : if : /** : 
strstr : for : /** : 
strstr : while : /** : 
str :  * set_curr_task - set the current task for a given cpu.
strstr : INIT :  * set_curr_task - set the current task for a given cpu. : 
strstr : if :  * set_curr_task - set the current task for a given cpu. : 
strstr : for :  * set_curr_task - set the current task for a given cpu. : 
strstr : while :  * set_curr_task - set the current task for a given cpu. : 
str :  * @cpu: the processor in question.
strstr : INIT :  * @cpu: the processor in question. : 
strstr : if :  * @cpu: the processor in question. : 
strstr : for :  * @cpu: the processor in question. : 
strstr : while :  * @cpu: the processor in question. : 
str :  * @p: the task pointer to set.
strstr : INIT :  * @p: the task pointer to set. : 
strstr : if :  * @p: the task pointer to set. : 
strstr : for :  * @p: the task pointer to set. : 
strstr : while :  * @p: the task pointer to set. : 
str :  *
strstr : INIT :  * : 
strstr : if :  * : 
strstr : for :  * : 
strstr : while :  * : 
str :  * Description: This function must only be used when non-maskable interrupts
strstr : INIT :  * Description: This function must only be used when non-maskable interrupts : 
strstr : if :  * Description: This function must only be used when non-maskable interrupts : 
strstr : for :  * Description: This function must only be used when non-maskable interrupts : 
strstr : while :  * Description: This function must only be used when non-maskable interrupts : 
str :  * are serviced on a separate stack. It allows the architecture to switch the
strstr : INIT :  * are serviced on a separate stack. It allows the architecture to switch the : 
strstr : if :  * are serviced on a separate stack. It allows the architecture to switch the : 
strstr : for :  * are serviced on a separate stack. It allows the architecture to switch the : 
strstr : while :  * are serviced on a separate stack. It allows the architecture to switch the : 
str :  * notion of the current task on a cpu in a non-blocking manner. This function
strstr : INIT :  * notion of the current task on a cpu in a non-blocking manner. This function : 
strstr : if :  * notion of the current task on a cpu in a non-blocking manner. This function : 
strstr : for :  * notion of the current task on a cpu in a non-blocking manner. This function : 
strstr : while :  * notion of the current task on a cpu in a non-blocking manner. This function : 
str :  * must be called with all CPU's synchronized, and interrupts disabled, the
strstr : INIT :  * must be called with all CPU's synchronized, and interrupts disabled, the : 
strstr : if :  * must be called with all CPU's synchronized, and interrupts disabled, the : 
strstr : for :  * must be called with all CPU's synchronized, and interrupts disabled, the : 
strstr : while :  * must be called with all CPU's synchronized, and interrupts disabled, the : 
str :  * and caller must save the original value of the current task (see
strstr : INIT :  * and caller must save the original value of the current task (see : 
strstr : if :  * and caller must save the original value of the current task (see : 
strstr : for :  * and caller must save the original value of the current task (see : 
strstr : while :  * and caller must save the original value of the current task (see : 
str :  * curr_task() above) and restore that value before reenabling interrupts and
strstr : INIT :  * curr_task() above) and restore that value before reenabling interrupts and : 
strstr : if :  * curr_task() above) and restore that value before reenabling interrupts and : 
strstr : for :  * curr_task() above) and restore that value before reenabling interrupts and : 
strstr : while :  * curr_task() above) and restore that value before reenabling interrupts and : 
str :  * re-starting the system.
strstr : INIT :  * re-starting the system. : 
strstr : if :  * re-starting the system. : 
strstr : for :  * re-starting the system. : 
strstr : while :  * re-starting the system. : 
str :  *
strstr : INIT :  * : 
strstr : if :  * : 
strstr : for :  * : 
strstr : while :  * : 
str :  * ONLY VALID WHEN THE WHOLE SYSTEM IS STOPPED!
strstr : INIT :  * ONLY VALID WHEN THE WHOLE SYSTEM IS STOPPED! : 
strstr : if :  * ONLY VALID WHEN THE WHOLE SYSTEM IS STOPPED! : 
strstr : for :  * ONLY VALID WHEN THE WHOLE SYSTEM IS STOPPED! : 
strstr : while :  * ONLY VALID WHEN THE WHOLE SYSTEM IS STOPPED! : 
str :  */
strstr : INIT :  */ : 
strstr : if :  */ : 
strstr : for :  */ : 
strstr : while :  */ : 
str : void set_curr_task(int cpu, struct task_struct *p)
strstr : INIT : void set_curr_task(int cpu, struct task_struct *p) : 
strstr : if : void set_curr_task(int cpu, struct task_struct *p) : 
strstr : for : void set_curr_task(int cpu, struct task_struct *p) : 
strstr : while : void set_curr_task(int cpu, struct task_struct *p) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	cpu_curr(cpu) = p;
strstr : INIT : 	cpu_curr(cpu) = p; : 
strstr : if : 	cpu_curr(cpu) = p; : 
strstr : for : 	cpu_curr(cpu) = p; : 
strstr : while : 	cpu_curr(cpu) = p; : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : #endif
strstr : if : #endif : 
strstr : for : #endif : 
strstr : while : #endif : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : #ifdef CONFIG_CGROUP_SCHED
strstr : if : #ifdef CONFIG_CGROUP_SCHED : 
strstr : for : #ifdef CONFIG_CGROUP_SCHED : 
strstr : while : #ifdef CONFIG_CGROUP_SCHED : 
str : /* task_group_lock serializes the addition/removal of task groups */
strstr : INIT : /* task_group_lock serializes the addition/removal of task groups */ : 
strstr : if : /* task_group_lock serializes the addition/removal of task groups */ : 
strstr : for : /* task_group_lock serializes the addition/removal of task groups */ : 
strstr : while : /* task_group_lock serializes the addition/removal of task groups */ : 
str : static DEFINE_SPINLOCK(task_group_lock);
strstr : INIT : static DEFINE_SPINLOCK(task_group_lock); : 
strstr : if : static DEFINE_SPINLOCK(task_group_lock); : 
strstr : for : static DEFINE_SPINLOCK(task_group_lock); : 
strstr : while : static DEFINE_SPINLOCK(task_group_lock); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : static void free_sched_group(struct task_group *tg)
strstr : if : static void free_sched_group(struct task_group *tg) : 
strstr : for : static void free_sched_group(struct task_group *tg) : 
strstr : while : static void free_sched_group(struct task_group *tg) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	free_fair_sched_group(tg);
strstr : INIT : 	free_fair_sched_group(tg); : 
strstr : if : 	free_fair_sched_group(tg); : 
strstr : for : 	free_fair_sched_group(tg); : 
strstr : while : 	free_fair_sched_group(tg); : 
str : 	free_rt_sched_group(tg);
strstr : INIT : 	free_rt_sched_group(tg); : 
strstr : if : 	free_rt_sched_group(tg); : 
strstr : for : 	free_rt_sched_group(tg); : 
strstr : while : 	free_rt_sched_group(tg); : 
str : 	autogroup_free(tg);
strstr : INIT : 	autogroup_free(tg); : 
strstr : if : 	autogroup_free(tg); : 
strstr : for : 	autogroup_free(tg); : 
strstr : while : 	autogroup_free(tg); : 
str : 	kfree(tg);
strstr : INIT : 	kfree(tg); : 
strstr : if : 	kfree(tg); : 
strstr : for : 	kfree(tg); : 
strstr : while : 	kfree(tg); : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : /* allocate runqueue etc for a new task group */
strstr : if : /* allocate runqueue etc for a new task group */ : 
strstr : for : /* allocate runqueue etc for a new task group */ : 
strstr : while : /* allocate runqueue etc for a new task group */ : 
str : struct task_group *sched_create_group(struct task_group *parent)
strstr : INIT : struct task_group *sched_create_group(struct task_group *parent) : 
strstr : if : struct task_group *sched_create_group(struct task_group *parent) : 
strstr : for : struct task_group *sched_create_group(struct task_group *parent) : 
strstr : while : struct task_group *sched_create_group(struct task_group *parent) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	struct task_group *tg;
strstr : INIT : 	struct task_group *tg; : 
strstr : if : 	struct task_group *tg; : 
strstr : for : 	struct task_group *tg; : 
strstr : while : 	struct task_group *tg; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	tg = kzalloc(sizeof(*tg), GFP_KERNEL);
strstr : if : 	tg = kzalloc(sizeof(*tg), GFP_KERNEL); : 
strstr : for : 	tg = kzalloc(sizeof(*tg), GFP_KERNEL); : 
strstr : while : 	tg = kzalloc(sizeof(*tg), GFP_KERNEL); : 
str : 	if (!tg)
strstr : INIT : 	if (!tg) : 
strstr : if : 	if (!tg) : 
strstr : for : 	if (!tg) : 
strstr : while : 	if (!tg) : 
str : 		return ERR_PTR(-ENOMEM);
strstr : INIT : 		return ERR_PTR(-ENOMEM); : 
strstr : if : 		return ERR_PTR(-ENOMEM); : 
strstr : for : 		return ERR_PTR(-ENOMEM); : 
strstr : while : 		return ERR_PTR(-ENOMEM); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	if (!alloc_fair_sched_group(tg, parent))
strstr : if : 	if (!alloc_fair_sched_group(tg, parent)) : 
strstr : for : 	if (!alloc_fair_sched_group(tg, parent)) : 
strstr : while : 	if (!alloc_fair_sched_group(tg, parent)) : 
str : 		goto err;
strstr : INIT : 		goto err; : 
strstr : if : 		goto err; : 
strstr : for : 		goto err; : 
strstr : while : 		goto err; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	if (!alloc_rt_sched_group(tg, parent))
strstr : if : 	if (!alloc_rt_sched_group(tg, parent)) : 
strstr : for : 	if (!alloc_rt_sched_group(tg, parent)) : 
strstr : while : 	if (!alloc_rt_sched_group(tg, parent)) : 
str : 		goto err;
strstr : INIT : 		goto err; : 
strstr : if : 		goto err; : 
strstr : for : 		goto err; : 
strstr : while : 		goto err; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	return tg;
strstr : if : 	return tg; : 
strstr : for : 	return tg; : 
strstr : while : 	return tg; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : err:
strstr : if : err: : 
strstr : for : err: : 
strstr : while : err: : 
str : 	free_sched_group(tg);
strstr : INIT : 	free_sched_group(tg); : 
strstr : if : 	free_sched_group(tg); : 
strstr : for : 	free_sched_group(tg); : 
strstr : while : 	free_sched_group(tg); : 
str : 	return ERR_PTR(-ENOMEM);
strstr : INIT : 	return ERR_PTR(-ENOMEM); : 
strstr : if : 	return ERR_PTR(-ENOMEM); : 
strstr : for : 	return ERR_PTR(-ENOMEM); : 
strstr : while : 	return ERR_PTR(-ENOMEM); : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : void sched_online_group(struct task_group *tg, struct task_group *parent)
strstr : if : void sched_online_group(struct task_group *tg, struct task_group *parent) : 
strstr : for : void sched_online_group(struct task_group *tg, struct task_group *parent) : 
strstr : while : void sched_online_group(struct task_group *tg, struct task_group *parent) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	unsigned long flags;
strstr : INIT : 	unsigned long flags; : 
strstr : if : 	unsigned long flags; : 
strstr : for : 	unsigned long flags; : 
strstr : while : 	unsigned long flags; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	spin_lock_irqsave(&task_group_lock, flags);
strstr : if : 	spin_lock_irqsave(&task_group_lock, flags); : 
strstr : for : 	spin_lock_irqsave(&task_group_lock, flags); : 
strstr : while : 	spin_lock_irqsave(&task_group_lock, flags); : 
str : 	list_add_rcu(&tg->list, &task_groups);
strstr : INIT : 	list_add_rcu(&tg->list, &task_groups); : 
strstr : if : 	list_add_rcu(&tg->list, &task_groups); : 
strstr : for : 	list_add_rcu(&tg->list, &task_groups); : 
strstr : while : 	list_add_rcu(&tg->list, &task_groups); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	WARN_ON(!parent); /* root should already exist */
strstr : if : 	WARN_ON(!parent); /* root should already exist */ : 
strstr : for : 	WARN_ON(!parent); /* root should already exist */ : 
strstr : while : 	WARN_ON(!parent); /* root should already exist */ : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	tg->parent = parent;
strstr : if : 	tg->parent = parent; : 
strstr : for : 	tg->parent = parent; : 
strstr : while : 	tg->parent = parent; : 
str : 	INIT_LIST_HEAD(&tg->children);
strstr : INIT : 	INIT_LIST_HEAD(&tg->children); : 
strstr : if : 	INIT_LIST_HEAD(&tg->children); : 
strstr : for : 	INIT_LIST_HEAD(&tg->children); : 
strstr : while : 	INIT_LIST_HEAD(&tg->children); : 
str : 	list_add_rcu(&tg->siblings, &parent->children);
strstr : INIT : 	list_add_rcu(&tg->siblings, &parent->children); : 
strstr : if : 	list_add_rcu(&tg->siblings, &parent->children); : 
strstr : for : 	list_add_rcu(&tg->siblings, &parent->children); : 
strstr : while : 	list_add_rcu(&tg->siblings, &parent->children); : 
str : 	spin_unlock_irqrestore(&task_group_lock, flags);
strstr : INIT : 	spin_unlock_irqrestore(&task_group_lock, flags); : 
strstr : if : 	spin_unlock_irqrestore(&task_group_lock, flags); : 
strstr : for : 	spin_unlock_irqrestore(&task_group_lock, flags); : 
strstr : while : 	spin_unlock_irqrestore(&task_group_lock, flags); : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : /* rcu callback to free various structures associated with a task group */
strstr : if : /* rcu callback to free various structures associated with a task group */ : 
strstr : for : /* rcu callback to free various structures associated with a task group */ : 
strstr : while : /* rcu callback to free various structures associated with a task group */ : 
str : static void free_sched_group_rcu(struct rcu_head *rhp)
strstr : INIT : static void free_sched_group_rcu(struct rcu_head *rhp) : 
strstr : if : static void free_sched_group_rcu(struct rcu_head *rhp) : 
strstr : for : static void free_sched_group_rcu(struct rcu_head *rhp) : 
strstr : while : static void free_sched_group_rcu(struct rcu_head *rhp) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	/* now it should be safe to free those cfs_rqs */
strstr : INIT : 	/* now it should be safe to free those cfs_rqs */ : 
strstr : if : 	/* now it should be safe to free those cfs_rqs */ : 
strstr : for : 	/* now it should be safe to free those cfs_rqs */ : 
strstr : while : 	/* now it should be safe to free those cfs_rqs */ : 
str : 	free_sched_group(container_of(rhp, struct task_group, rcu));
strstr : INIT : 	free_sched_group(container_of(rhp, struct task_group, rcu)); : 
strstr : if : 	free_sched_group(container_of(rhp, struct task_group, rcu)); : 
strstr : for : 	free_sched_group(container_of(rhp, struct task_group, rcu)); : 
strstr : while : 	free_sched_group(container_of(rhp, struct task_group, rcu)); : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : /* Destroy runqueue etc associated with a task group */
strstr : if : /* Destroy runqueue etc associated with a task group */ : 
strstr : for : /* Destroy runqueue etc associated with a task group */ : 
strstr : while : /* Destroy runqueue etc associated with a task group */ : 
str : void sched_destroy_group(struct task_group *tg)
strstr : INIT : void sched_destroy_group(struct task_group *tg) : 
strstr : if : void sched_destroy_group(struct task_group *tg) : 
strstr : for : void sched_destroy_group(struct task_group *tg) : 
strstr : while : void sched_destroy_group(struct task_group *tg) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	/* wait for possible concurrent references to cfs_rqs complete */
strstr : INIT : 	/* wait for possible concurrent references to cfs_rqs complete */ : 
strstr : if : 	/* wait for possible concurrent references to cfs_rqs complete */ : 
strstr : for : 	/* wait for possible concurrent references to cfs_rqs complete */ : 
strstr : while : 	/* wait for possible concurrent references to cfs_rqs complete */ : 
str : 	call_rcu(&tg->rcu, free_sched_group_rcu);
strstr : INIT : 	call_rcu(&tg->rcu, free_sched_group_rcu); : 
strstr : if : 	call_rcu(&tg->rcu, free_sched_group_rcu); : 
strstr : for : 	call_rcu(&tg->rcu, free_sched_group_rcu); : 
strstr : while : 	call_rcu(&tg->rcu, free_sched_group_rcu); : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : void sched_offline_group(struct task_group *tg)
strstr : if : void sched_offline_group(struct task_group *tg) : 
strstr : for : void sched_offline_group(struct task_group *tg) : 
strstr : while : void sched_offline_group(struct task_group *tg) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	unsigned long flags;
strstr : INIT : 	unsigned long flags; : 
strstr : if : 	unsigned long flags; : 
strstr : for : 	unsigned long flags; : 
strstr : while : 	unsigned long flags; : 
str : 	int i;
strstr : INIT : 	int i; : 
strstr : if : 	int i; : 
strstr : for : 	int i; : 
strstr : while : 	int i; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	/* end participation in shares distribution */
strstr : if : 	/* end participation in shares distribution */ : 
strstr : for : 	/* end participation in shares distribution */ : 
strstr : while : 	/* end participation in shares distribution */ : 
str : 	for_each_possible_cpu(i)
strstr : INIT : 	for_each_possible_cpu(i) : 
strstr : if : 	for_each_possible_cpu(i) : 
strstr : for : 	for_each_possible_cpu(i) : 
strstr : while : 	for_each_possible_cpu(i) : 
str : 		unregister_fair_sched_group(tg, i);
strstr : INIT : 		unregister_fair_sched_group(tg, i); : 
strstr : if : 		unregister_fair_sched_group(tg, i); : 
strstr : for : 		unregister_fair_sched_group(tg, i); : 
strstr : while : 		unregister_fair_sched_group(tg, i); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	spin_lock_irqsave(&task_group_lock, flags);
strstr : if : 	spin_lock_irqsave(&task_group_lock, flags); : 
strstr : for : 	spin_lock_irqsave(&task_group_lock, flags); : 
strstr : while : 	spin_lock_irqsave(&task_group_lock, flags); : 
str : 	list_del_rcu(&tg->list);
strstr : INIT : 	list_del_rcu(&tg->list); : 
strstr : if : 	list_del_rcu(&tg->list); : 
strstr : for : 	list_del_rcu(&tg->list); : 
strstr : while : 	list_del_rcu(&tg->list); : 
str : 	list_del_rcu(&tg->siblings);
strstr : INIT : 	list_del_rcu(&tg->siblings); : 
strstr : if : 	list_del_rcu(&tg->siblings); : 
strstr : for : 	list_del_rcu(&tg->siblings); : 
strstr : while : 	list_del_rcu(&tg->siblings); : 
str : 	spin_unlock_irqrestore(&task_group_lock, flags);
strstr : INIT : 	spin_unlock_irqrestore(&task_group_lock, flags); : 
strstr : if : 	spin_unlock_irqrestore(&task_group_lock, flags); : 
strstr : for : 	spin_unlock_irqrestore(&task_group_lock, flags); : 
strstr : while : 	spin_unlock_irqrestore(&task_group_lock, flags); : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : /* change task's runqueue when it moves between groups.
strstr : if : /* change task's runqueue when it moves between groups. : 
strstr : for : /* change task's runqueue when it moves between groups. : 
strstr : while : /* change task's runqueue when it moves between groups. : 
str :  *	The caller of this function should have put the task in its new group
strstr : INIT :  *	The caller of this function should have put the task in its new group : 
strstr : if :  *	The caller of this function should have put the task in its new group : 
strstr : for :  *	The caller of this function should have put the task in its new group : 
strstr : while :  *	The caller of this function should have put the task in its new group : 
str :  *	by now. This function just updates tsk->se.cfs_rq and tsk->se.parent to
strstr : INIT :  *	by now. This function just updates tsk->se.cfs_rq and tsk->se.parent to : 
strstr : if :  *	by now. This function just updates tsk->se.cfs_rq and tsk->se.parent to : 
strstr : for :  *	by now. This function just updates tsk->se.cfs_rq and tsk->se.parent to : 
strstr : while :  *	by now. This function just updates tsk->se.cfs_rq and tsk->se.parent to : 
str :  *	reflect its new group.
strstr : INIT :  *	reflect its new group. : 
strstr : if :  *	reflect its new group. : 
strstr : for :  *	reflect its new group. : 
strstr : while :  *	reflect its new group. : 
str :  */
strstr : INIT :  */ : 
strstr : if :  */ : 
strstr : for :  */ : 
strstr : while :  */ : 
str : void sched_move_task(struct task_struct *tsk)
strstr : INIT : void sched_move_task(struct task_struct *tsk) : 
strstr : if : void sched_move_task(struct task_struct *tsk) : 
strstr : for : void sched_move_task(struct task_struct *tsk) : 
strstr : while : void sched_move_task(struct task_struct *tsk) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	struct task_group *tg;
strstr : INIT : 	struct task_group *tg; : 
strstr : if : 	struct task_group *tg; : 
strstr : for : 	struct task_group *tg; : 
strstr : while : 	struct task_group *tg; : 
str : 	int on_rq, running;
strstr : INIT : 	int on_rq, running; : 
strstr : if : 	int on_rq, running; : 
strstr : for : 	int on_rq, running; : 
strstr : while : 	int on_rq, running; : 
str : 	unsigned long flags;
strstr : INIT : 	unsigned long flags; : 
strstr : if : 	unsigned long flags; : 
strstr : for : 	unsigned long flags; : 
strstr : while : 	unsigned long flags; : 
str : 	struct rq *rq;
strstr : INIT : 	struct rq *rq; : 
strstr : if : 	struct rq *rq; : 
strstr : for : 	struct rq *rq; : 
strstr : while : 	struct rq *rq; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	rq = task_rq_lock(tsk, &flags);
strstr : if : 	rq = task_rq_lock(tsk, &flags); : 
strstr : for : 	rq = task_rq_lock(tsk, &flags); : 
strstr : while : 	rq = task_rq_lock(tsk, &flags); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	running = task_current(rq, tsk);
strstr : if : 	running = task_current(rq, tsk); : 
strstr : for : 	running = task_current(rq, tsk); : 
strstr : while : 	running = task_current(rq, tsk); : 
str : 	on_rq = tsk->on_rq;
strstr : INIT : 	on_rq = tsk->on_rq; : 
strstr : if : 	on_rq = tsk->on_rq; : 
strstr : for : 	on_rq = tsk->on_rq; : 
strstr : while : 	on_rq = tsk->on_rq; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	if (on_rq)
strstr : if : 	if (on_rq) : 
strstr : for : 	if (on_rq) : 
strstr : while : 	if (on_rq) : 
str : 		dequeue_task(rq, tsk, 0);
strstr : INIT : 		dequeue_task(rq, tsk, 0); : 
strstr : if : 		dequeue_task(rq, tsk, 0); : 
strstr : for : 		dequeue_task(rq, tsk, 0); : 
strstr : while : 		dequeue_task(rq, tsk, 0); : 
str : 	if (unlikely(running))
strstr : INIT : 	if (unlikely(running)) : 
strstr : if : 	if (unlikely(running)) : 
strstr : for : 	if (unlikely(running)) : 
strstr : while : 	if (unlikely(running)) : 
str : 		tsk->sched_class->put_prev_task(rq, tsk);
strstr : INIT : 		tsk->sched_class->put_prev_task(rq, tsk); : 
strstr : if : 		tsk->sched_class->put_prev_task(rq, tsk); : 
strstr : for : 		tsk->sched_class->put_prev_task(rq, tsk); : 
strstr : while : 		tsk->sched_class->put_prev_task(rq, tsk); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	tg = container_of(task_css_check(tsk, cpu_cgroup_subsys_id,
strstr : if : 	tg = container_of(task_css_check(tsk, cpu_cgroup_subsys_id, : 
strstr : for : 	tg = container_of(task_css_check(tsk, cpu_cgroup_subsys_id, : 
strstr : while : 	tg = container_of(task_css_check(tsk, cpu_cgroup_subsys_id, : 
str : 				lockdep_is_held(&tsk->sighand->siglock)),
strstr : INIT : 				lockdep_is_held(&tsk->sighand->siglock)), : 
strstr : if : 				lockdep_is_held(&tsk->sighand->siglock)), : 
strstr : for : 				lockdep_is_held(&tsk->sighand->siglock)), : 
strstr : while : 				lockdep_is_held(&tsk->sighand->siglock)), : 
str : 			  struct task_group, css);
strstr : INIT : 			  struct task_group, css); : 
strstr : if : 			  struct task_group, css); : 
strstr : for : 			  struct task_group, css); : 
strstr : while : 			  struct task_group, css); : 
str : 	tg = autogroup_task_group(tsk, tg);
strstr : INIT : 	tg = autogroup_task_group(tsk, tg); : 
strstr : if : 	tg = autogroup_task_group(tsk, tg); : 
strstr : for : 	tg = autogroup_task_group(tsk, tg); : 
strstr : while : 	tg = autogroup_task_group(tsk, tg); : 
str : 	tsk->sched_task_group = tg;
strstr : INIT : 	tsk->sched_task_group = tg; : 
strstr : if : 	tsk->sched_task_group = tg; : 
strstr : for : 	tsk->sched_task_group = tg; : 
strstr : while : 	tsk->sched_task_group = tg; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : #ifdef CONFIG_FAIR_GROUP_SCHED
strstr : if : #ifdef CONFIG_FAIR_GROUP_SCHED : 
strstr : for : #ifdef CONFIG_FAIR_GROUP_SCHED : 
strstr : while : #ifdef CONFIG_FAIR_GROUP_SCHED : 
str : 	if (tsk->sched_class->task_move_group)
strstr : INIT : 	if (tsk->sched_class->task_move_group) : 
strstr : if : 	if (tsk->sched_class->task_move_group) : 
strstr : for : 	if (tsk->sched_class->task_move_group) : 
strstr : while : 	if (tsk->sched_class->task_move_group) : 
str : 		tsk->sched_class->task_move_group(tsk, on_rq);
strstr : INIT : 		tsk->sched_class->task_move_group(tsk, on_rq); : 
strstr : if : 		tsk->sched_class->task_move_group(tsk, on_rq); : 
strstr : for : 		tsk->sched_class->task_move_group(tsk, on_rq); : 
strstr : while : 		tsk->sched_class->task_move_group(tsk, on_rq); : 
str : 	else
strstr : INIT : 	else : 
strstr : if : 	else : 
strstr : for : 	else : 
strstr : while : 	else : 
str : #endif
strstr : INIT : #endif : 
strstr : if : #endif : 
strstr : for : #endif : 
strstr : while : #endif : 
str : 		set_task_rq(tsk, task_cpu(tsk));
strstr : INIT : 		set_task_rq(tsk, task_cpu(tsk)); : 
strstr : if : 		set_task_rq(tsk, task_cpu(tsk)); : 
strstr : for : 		set_task_rq(tsk, task_cpu(tsk)); : 
strstr : while : 		set_task_rq(tsk, task_cpu(tsk)); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	if (unlikely(running))
strstr : if : 	if (unlikely(running)) : 
strstr : for : 	if (unlikely(running)) : 
strstr : while : 	if (unlikely(running)) : 
str : 		tsk->sched_class->set_curr_task(rq);
strstr : INIT : 		tsk->sched_class->set_curr_task(rq); : 
strstr : if : 		tsk->sched_class->set_curr_task(rq); : 
strstr : for : 		tsk->sched_class->set_curr_task(rq); : 
strstr : while : 		tsk->sched_class->set_curr_task(rq); : 
str : 	if (on_rq)
strstr : INIT : 	if (on_rq) : 
strstr : if : 	if (on_rq) : 
strstr : for : 	if (on_rq) : 
strstr : while : 	if (on_rq) : 
str : 		enqueue_task(rq, tsk, 0);
strstr : INIT : 		enqueue_task(rq, tsk, 0); : 
strstr : if : 		enqueue_task(rq, tsk, 0); : 
strstr : for : 		enqueue_task(rq, tsk, 0); : 
strstr : while : 		enqueue_task(rq, tsk, 0); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	task_rq_unlock(rq, tsk, &flags);
strstr : if : 	task_rq_unlock(rq, tsk, &flags); : 
strstr : for : 	task_rq_unlock(rq, tsk, &flags); : 
strstr : while : 	task_rq_unlock(rq, tsk, &flags); : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : #endif /* CONFIG_CGROUP_SCHED */
strstr : INIT : #endif /* CONFIG_CGROUP_SCHED */ : 
strstr : if : #endif /* CONFIG_CGROUP_SCHED */ : 
strstr : for : #endif /* CONFIG_CGROUP_SCHED */ : 
strstr : while : #endif /* CONFIG_CGROUP_SCHED */ : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : #ifdef CONFIG_RT_GROUP_SCHED
strstr : if : #ifdef CONFIG_RT_GROUP_SCHED : 
strstr : for : #ifdef CONFIG_RT_GROUP_SCHED : 
strstr : while : #ifdef CONFIG_RT_GROUP_SCHED : 
str : /*
strstr : INIT : /* : 
strstr : if : /* : 
strstr : for : /* : 
strstr : while : /* : 
str :  * Ensure that the real time constraints are schedulable.
strstr : INIT :  * Ensure that the real time constraints are schedulable. : 
strstr : if :  * Ensure that the real time constraints are schedulable. : 
strstr : for :  * Ensure that the real time constraints are schedulable. : 
strstr : while :  * Ensure that the real time constraints are schedulable. : 
str :  */
strstr : INIT :  */ : 
strstr : if :  */ : 
strstr : for :  */ : 
strstr : while :  */ : 
str : static DEFINE_MUTEX(rt_constraints_mutex);
strstr : INIT : static DEFINE_MUTEX(rt_constraints_mutex); : 
strstr : if : static DEFINE_MUTEX(rt_constraints_mutex); : 
strstr : for : static DEFINE_MUTEX(rt_constraints_mutex); : 
strstr : while : static DEFINE_MUTEX(rt_constraints_mutex); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : /* Must be called with tasklist_lock held */
strstr : if : /* Must be called with tasklist_lock held */ : 
strstr : for : /* Must be called with tasklist_lock held */ : 
strstr : while : /* Must be called with tasklist_lock held */ : 
str : static inline int tg_has_rt_tasks(struct task_group *tg)
strstr : INIT : static inline int tg_has_rt_tasks(struct task_group *tg) : 
strstr : if : static inline int tg_has_rt_tasks(struct task_group *tg) : 
strstr : for : static inline int tg_has_rt_tasks(struct task_group *tg) : 
strstr : while : static inline int tg_has_rt_tasks(struct task_group *tg) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	struct task_struct *g, *p;
strstr : INIT : 	struct task_struct *g, *p; : 
strstr : if : 	struct task_struct *g, *p; : 
strstr : for : 	struct task_struct *g, *p; : 
strstr : while : 	struct task_struct *g, *p; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	do_each_thread(g, p) {
strstr : if : 	do_each_thread(g, p) { : 
strstr : for : 	do_each_thread(g, p) { : 
strstr : while : 	do_each_thread(g, p) { : 
str : 		if (rt_task(p) && task_rq(p)->rt.tg == tg)
strstr : INIT : 		if (rt_task(p) && task_rq(p)->rt.tg == tg) : 
strstr : if : 		if (rt_task(p) && task_rq(p)->rt.tg == tg) : 
strstr : for : 		if (rt_task(p) && task_rq(p)->rt.tg == tg) : 
strstr : while : 		if (rt_task(p) && task_rq(p)->rt.tg == tg) : 
str : 			return 1;
strstr : INIT : 			return 1; : 
strstr : if : 			return 1; : 
strstr : for : 			return 1; : 
strstr : while : 			return 1; : 
str : 	} while_each_thread(g, p);
strstr : INIT : 	} while_each_thread(g, p); : 
strstr : if : 	} while_each_thread(g, p); : 
strstr : for : 	} while_each_thread(g, p); : 
strstr : while : 	} while_each_thread(g, p); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	return 0;
strstr : if : 	return 0; : 
strstr : for : 	return 0; : 
strstr : while : 	return 0; : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : struct rt_schedulable_data {
strstr : if : struct rt_schedulable_data { : 
strstr : for : struct rt_schedulable_data { : 
strstr : while : struct rt_schedulable_data { : 
str : 	struct task_group *tg;
strstr : INIT : 	struct task_group *tg; : 
strstr : if : 	struct task_group *tg; : 
strstr : for : 	struct task_group *tg; : 
strstr : while : 	struct task_group *tg; : 
str : 	u64 rt_period;
strstr : INIT : 	u64 rt_period; : 
strstr : if : 	u64 rt_period; : 
strstr : for : 	u64 rt_period; : 
strstr : while : 	u64 rt_period; : 
str : 	u64 rt_runtime;
strstr : INIT : 	u64 rt_runtime; : 
strstr : if : 	u64 rt_runtime; : 
strstr : for : 	u64 rt_runtime; : 
strstr : while : 	u64 rt_runtime; : 
str : };
strstr : INIT : }; : 
strstr : if : }; : 
strstr : for : }; : 
strstr : while : }; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : static int tg_rt_schedulable(struct task_group *tg, void *data)
strstr : if : static int tg_rt_schedulable(struct task_group *tg, void *data) : 
strstr : for : static int tg_rt_schedulable(struct task_group *tg, void *data) : 
strstr : while : static int tg_rt_schedulable(struct task_group *tg, void *data) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	struct rt_schedulable_data *d = data;
strstr : INIT : 	struct rt_schedulable_data *d = data; : 
strstr : if : 	struct rt_schedulable_data *d = data; : 
strstr : for : 	struct rt_schedulable_data *d = data; : 
strstr : while : 	struct rt_schedulable_data *d = data; : 
str : 	struct task_group *child;
strstr : INIT : 	struct task_group *child; : 
strstr : if : 	struct task_group *child; : 
strstr : for : 	struct task_group *child; : 
strstr : while : 	struct task_group *child; : 
str : 	unsigned long total, sum = 0;
strstr : INIT : 	unsigned long total, sum = 0; : 
strstr : if : 	unsigned long total, sum = 0; : 
strstr : for : 	unsigned long total, sum = 0; : 
strstr : while : 	unsigned long total, sum = 0; : 
str : 	u64 period, runtime;
strstr : INIT : 	u64 period, runtime; : 
strstr : if : 	u64 period, runtime; : 
strstr : for : 	u64 period, runtime; : 
strstr : while : 	u64 period, runtime; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	period = ktime_to_ns(tg->rt_bandwidth.rt_period);
strstr : if : 	period = ktime_to_ns(tg->rt_bandwidth.rt_period); : 
strstr : for : 	period = ktime_to_ns(tg->rt_bandwidth.rt_period); : 
strstr : while : 	period = ktime_to_ns(tg->rt_bandwidth.rt_period); : 
str : 	runtime = tg->rt_bandwidth.rt_runtime;
strstr : INIT : 	runtime = tg->rt_bandwidth.rt_runtime; : 
strstr : if : 	runtime = tg->rt_bandwidth.rt_runtime; : 
strstr : for : 	runtime = tg->rt_bandwidth.rt_runtime; : 
strstr : while : 	runtime = tg->rt_bandwidth.rt_runtime; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	if (tg == d->tg) {
strstr : if : 	if (tg == d->tg) { : 
strstr : for : 	if (tg == d->tg) { : 
strstr : while : 	if (tg == d->tg) { : 
str : 		period = d->rt_period;
strstr : INIT : 		period = d->rt_period; : 
strstr : if : 		period = d->rt_period; : 
strstr : for : 		period = d->rt_period; : 
strstr : while : 		period = d->rt_period; : 
str : 		runtime = d->rt_runtime;
strstr : INIT : 		runtime = d->rt_runtime; : 
strstr : if : 		runtime = d->rt_runtime; : 
strstr : for : 		runtime = d->rt_runtime; : 
strstr : while : 		runtime = d->rt_runtime; : 
str : 	}
strstr : INIT : 	} : 
strstr : if : 	} : 
strstr : for : 	} : 
strstr : while : 	} : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	/*
strstr : if : 	/* : 
strstr : for : 	/* : 
strstr : while : 	/* : 
str : 	 * Cannot have more runtime than the period.
strstr : INIT : 	 * Cannot have more runtime than the period. : 
strstr : if : 	 * Cannot have more runtime than the period. : 
strstr : for : 	 * Cannot have more runtime than the period. : 
strstr : while : 	 * Cannot have more runtime than the period. : 
str : 	 */
strstr : INIT : 	 */ : 
strstr : if : 	 */ : 
strstr : for : 	 */ : 
strstr : while : 	 */ : 
str : 	if (runtime > period && runtime != RUNTIME_INF)
strstr : INIT : 	if (runtime > period && runtime != RUNTIME_INF) : 
strstr : if : 	if (runtime > period && runtime != RUNTIME_INF) : 
strstr : for : 	if (runtime > period && runtime != RUNTIME_INF) : 
strstr : while : 	if (runtime > period && runtime != RUNTIME_INF) : 
str : 		return -EINVAL;
strstr : INIT : 		return -EINVAL; : 
strstr : if : 		return -EINVAL; : 
strstr : for : 		return -EINVAL; : 
strstr : while : 		return -EINVAL; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	/*
strstr : if : 	/* : 
strstr : for : 	/* : 
strstr : while : 	/* : 
str : 	 * Ensure we don't starve existing RT tasks.
strstr : INIT : 	 * Ensure we don't starve existing RT tasks. : 
strstr : if : 	 * Ensure we don't starve existing RT tasks. : 
strstr : for : 	 * Ensure we don't starve existing RT tasks. : 
strstr : while : 	 * Ensure we don't starve existing RT tasks. : 
str : 	 */
strstr : INIT : 	 */ : 
strstr : if : 	 */ : 
strstr : for : 	 */ : 
strstr : while : 	 */ : 
str : 	if (rt_bandwidth_enabled() && !runtime && tg_has_rt_tasks(tg))
strstr : INIT : 	if (rt_bandwidth_enabled() && !runtime && tg_has_rt_tasks(tg)) : 
strstr : if : 	if (rt_bandwidth_enabled() && !runtime && tg_has_rt_tasks(tg)) : 
strstr : for : 	if (rt_bandwidth_enabled() && !runtime && tg_has_rt_tasks(tg)) : 
strstr : while : 	if (rt_bandwidth_enabled() && !runtime && tg_has_rt_tasks(tg)) : 
str : 		return -EBUSY;
strstr : INIT : 		return -EBUSY; : 
strstr : if : 		return -EBUSY; : 
strstr : for : 		return -EBUSY; : 
strstr : while : 		return -EBUSY; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	total = to_ratio(period, runtime);
strstr : if : 	total = to_ratio(period, runtime); : 
strstr : for : 	total = to_ratio(period, runtime); : 
strstr : while : 	total = to_ratio(period, runtime); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	/*
strstr : if : 	/* : 
strstr : for : 	/* : 
strstr : while : 	/* : 
str : 	 * Nobody can have more than the global setting allows.
strstr : INIT : 	 * Nobody can have more than the global setting allows. : 
strstr : if : 	 * Nobody can have more than the global setting allows. : 
strstr : for : 	 * Nobody can have more than the global setting allows. : 
strstr : while : 	 * Nobody can have more than the global setting allows. : 
str : 	 */
strstr : INIT : 	 */ : 
strstr : if : 	 */ : 
strstr : for : 	 */ : 
strstr : while : 	 */ : 
str : 	if (total > to_ratio(global_rt_period(), global_rt_runtime()))
strstr : INIT : 	if (total > to_ratio(global_rt_period(), global_rt_runtime())) : 
strstr : if : 	if (total > to_ratio(global_rt_period(), global_rt_runtime())) : 
strstr : for : 	if (total > to_ratio(global_rt_period(), global_rt_runtime())) : 
strstr : while : 	if (total > to_ratio(global_rt_period(), global_rt_runtime())) : 
str : 		return -EINVAL;
strstr : INIT : 		return -EINVAL; : 
strstr : if : 		return -EINVAL; : 
strstr : for : 		return -EINVAL; : 
strstr : while : 		return -EINVAL; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	/*
strstr : if : 	/* : 
strstr : for : 	/* : 
strstr : while : 	/* : 
str : 	 * The sum of our children's runtime should not exceed our own.
strstr : INIT : 	 * The sum of our children's runtime should not exceed our own. : 
strstr : if : 	 * The sum of our children's runtime should not exceed our own. : 
strstr : for : 	 * The sum of our children's runtime should not exceed our own. : 
strstr : while : 	 * The sum of our children's runtime should not exceed our own. : 
str : 	 */
strstr : INIT : 	 */ : 
strstr : if : 	 */ : 
strstr : for : 	 */ : 
strstr : while : 	 */ : 
str : 	list_for_each_entry_rcu(child, &tg->children, siblings) {
strstr : INIT : 	list_for_each_entry_rcu(child, &tg->children, siblings) { : 
strstr : if : 	list_for_each_entry_rcu(child, &tg->children, siblings) { : 
strstr : for : 	list_for_each_entry_rcu(child, &tg->children, siblings) { : 
strstr : while : 	list_for_each_entry_rcu(child, &tg->children, siblings) { : 
str : 		period = ktime_to_ns(child->rt_bandwidth.rt_period);
strstr : INIT : 		period = ktime_to_ns(child->rt_bandwidth.rt_period); : 
strstr : if : 		period = ktime_to_ns(child->rt_bandwidth.rt_period); : 
strstr : for : 		period = ktime_to_ns(child->rt_bandwidth.rt_period); : 
strstr : while : 		period = ktime_to_ns(child->rt_bandwidth.rt_period); : 
str : 		runtime = child->rt_bandwidth.rt_runtime;
strstr : INIT : 		runtime = child->rt_bandwidth.rt_runtime; : 
strstr : if : 		runtime = child->rt_bandwidth.rt_runtime; : 
strstr : for : 		runtime = child->rt_bandwidth.rt_runtime; : 
strstr : while : 		runtime = child->rt_bandwidth.rt_runtime; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 		if (child == d->tg) {
strstr : if : 		if (child == d->tg) { : 
strstr : for : 		if (child == d->tg) { : 
strstr : while : 		if (child == d->tg) { : 
str : 			period = d->rt_period;
strstr : INIT : 			period = d->rt_period; : 
strstr : if : 			period = d->rt_period; : 
strstr : for : 			period = d->rt_period; : 
strstr : while : 			period = d->rt_period; : 
str : 			runtime = d->rt_runtime;
strstr : INIT : 			runtime = d->rt_runtime; : 
strstr : if : 			runtime = d->rt_runtime; : 
strstr : for : 			runtime = d->rt_runtime; : 
strstr : while : 			runtime = d->rt_runtime; : 
str : 		}
strstr : INIT : 		} : 
strstr : if : 		} : 
strstr : for : 		} : 
strstr : while : 		} : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 		sum += to_ratio(period, runtime);
strstr : if : 		sum += to_ratio(period, runtime); : 
strstr : for : 		sum += to_ratio(period, runtime); : 
strstr : while : 		sum += to_ratio(period, runtime); : 
str : 	}
strstr : INIT : 	} : 
strstr : if : 	} : 
strstr : for : 	} : 
strstr : while : 	} : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	if (sum > total)
strstr : if : 	if (sum > total) : 
strstr : for : 	if (sum > total) : 
strstr : while : 	if (sum > total) : 
str : 		return -EINVAL;
strstr : INIT : 		return -EINVAL; : 
strstr : if : 		return -EINVAL; : 
strstr : for : 		return -EINVAL; : 
strstr : while : 		return -EINVAL; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	return 0;
strstr : if : 	return 0; : 
strstr : for : 	return 0; : 
strstr : while : 	return 0; : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : static int __rt_schedulable(struct task_group *tg, u64 period, u64 runtime)
strstr : if : static int __rt_schedulable(struct task_group *tg, u64 period, u64 runtime) : 
strstr : for : static int __rt_schedulable(struct task_group *tg, u64 period, u64 runtime) : 
strstr : while : static int __rt_schedulable(struct task_group *tg, u64 period, u64 runtime) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	int ret;
strstr : INIT : 	int ret; : 
strstr : if : 	int ret; : 
strstr : for : 	int ret; : 
strstr : while : 	int ret; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	struct rt_schedulable_data data = {
strstr : if : 	struct rt_schedulable_data data = { : 
strstr : for : 	struct rt_schedulable_data data = { : 
strstr : while : 	struct rt_schedulable_data data = { : 
str : 		.tg = tg,
strstr : INIT : 		.tg = tg, : 
strstr : if : 		.tg = tg, : 
strstr : for : 		.tg = tg, : 
strstr : while : 		.tg = tg, : 
str : 		.rt_period = period,
strstr : INIT : 		.rt_period = period, : 
strstr : if : 		.rt_period = period, : 
strstr : for : 		.rt_period = period, : 
strstr : while : 		.rt_period = period, : 
str : 		.rt_runtime = runtime,
strstr : INIT : 		.rt_runtime = runtime, : 
strstr : if : 		.rt_runtime = runtime, : 
strstr : for : 		.rt_runtime = runtime, : 
strstr : while : 		.rt_runtime = runtime, : 
str : 	};
strstr : INIT : 	}; : 
strstr : if : 	}; : 
strstr : for : 	}; : 
strstr : while : 	}; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	rcu_read_lock();
strstr : if : 	rcu_read_lock(); : 
strstr : for : 	rcu_read_lock(); : 
strstr : while : 	rcu_read_lock(); : 
str : 	ret = walk_tg_tree(tg_rt_schedulable, tg_nop, &data);
strstr : INIT : 	ret = walk_tg_tree(tg_rt_schedulable, tg_nop, &data); : 
strstr : if : 	ret = walk_tg_tree(tg_rt_schedulable, tg_nop, &data); : 
strstr : for : 	ret = walk_tg_tree(tg_rt_schedulable, tg_nop, &data); : 
strstr : while : 	ret = walk_tg_tree(tg_rt_schedulable, tg_nop, &data); : 
str : 	rcu_read_unlock();
strstr : INIT : 	rcu_read_unlock(); : 
strstr : if : 	rcu_read_unlock(); : 
strstr : for : 	rcu_read_unlock(); : 
strstr : while : 	rcu_read_unlock(); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	return ret;
strstr : if : 	return ret; : 
strstr : for : 	return ret; : 
strstr : while : 	return ret; : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : static int tg_set_rt_bandwidth(struct task_group *tg,
strstr : if : static int tg_set_rt_bandwidth(struct task_group *tg, : 
strstr : for : static int tg_set_rt_bandwidth(struct task_group *tg, : 
strstr : while : static int tg_set_rt_bandwidth(struct task_group *tg, : 
str : 		u64 rt_period, u64 rt_runtime)
strstr : INIT : 		u64 rt_period, u64 rt_runtime) : 
strstr : if : 		u64 rt_period, u64 rt_runtime) : 
strstr : for : 		u64 rt_period, u64 rt_runtime) : 
strstr : while : 		u64 rt_period, u64 rt_runtime) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	int i, err = 0;
strstr : INIT : 	int i, err = 0; : 
strstr : if : 	int i, err = 0; : 
strstr : for : 	int i, err = 0; : 
strstr : while : 	int i, err = 0; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	mutex_lock(&rt_constraints_mutex);
strstr : if : 	mutex_lock(&rt_constraints_mutex); : 
strstr : for : 	mutex_lock(&rt_constraints_mutex); : 
strstr : while : 	mutex_lock(&rt_constraints_mutex); : 
str : 	read_lock(&tasklist_lock);
strstr : INIT : 	read_lock(&tasklist_lock); : 
strstr : if : 	read_lock(&tasklist_lock); : 
strstr : for : 	read_lock(&tasklist_lock); : 
strstr : while : 	read_lock(&tasklist_lock); : 
str : 	err = __rt_schedulable(tg, rt_period, rt_runtime);
strstr : INIT : 	err = __rt_schedulable(tg, rt_period, rt_runtime); : 
strstr : if : 	err = __rt_schedulable(tg, rt_period, rt_runtime); : 
strstr : for : 	err = __rt_schedulable(tg, rt_period, rt_runtime); : 
strstr : while : 	err = __rt_schedulable(tg, rt_period, rt_runtime); : 
str : 	if (err)
strstr : INIT : 	if (err) : 
strstr : if : 	if (err) : 
strstr : for : 	if (err) : 
strstr : while : 	if (err) : 
str : 		goto unlock;
strstr : INIT : 		goto unlock; : 
strstr : if : 		goto unlock; : 
strstr : for : 		goto unlock; : 
strstr : while : 		goto unlock; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	raw_spin_lock_irq(&tg->rt_bandwidth.rt_runtime_lock);
strstr : if : 	raw_spin_lock_irq(&tg->rt_bandwidth.rt_runtime_lock); : 
strstr : for : 	raw_spin_lock_irq(&tg->rt_bandwidth.rt_runtime_lock); : 
strstr : while : 	raw_spin_lock_irq(&tg->rt_bandwidth.rt_runtime_lock); : 
str : 	tg->rt_bandwidth.rt_period = ns_to_ktime(rt_period);
strstr : INIT : 	tg->rt_bandwidth.rt_period = ns_to_ktime(rt_period); : 
strstr : if : 	tg->rt_bandwidth.rt_period = ns_to_ktime(rt_period); : 
strstr : for : 	tg->rt_bandwidth.rt_period = ns_to_ktime(rt_period); : 
strstr : while : 	tg->rt_bandwidth.rt_period = ns_to_ktime(rt_period); : 
str : 	tg->rt_bandwidth.rt_runtime = rt_runtime;
strstr : INIT : 	tg->rt_bandwidth.rt_runtime = rt_runtime; : 
strstr : if : 	tg->rt_bandwidth.rt_runtime = rt_runtime; : 
strstr : for : 	tg->rt_bandwidth.rt_runtime = rt_runtime; : 
strstr : while : 	tg->rt_bandwidth.rt_runtime = rt_runtime; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	for_each_possible_cpu(i) {
strstr : if : 	for_each_possible_cpu(i) { : 
strstr : for : 	for_each_possible_cpu(i) { : 
strstr : while : 	for_each_possible_cpu(i) { : 
str : 		struct rt_rq *rt_rq = tg->rt_rq[i];
strstr : INIT : 		struct rt_rq *rt_rq = tg->rt_rq[i]; : 
strstr : if : 		struct rt_rq *rt_rq = tg->rt_rq[i]; : 
strstr : for : 		struct rt_rq *rt_rq = tg->rt_rq[i]; : 
strstr : while : 		struct rt_rq *rt_rq = tg->rt_rq[i]; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 		raw_spin_lock(&rt_rq->rt_runtime_lock);
strstr : if : 		raw_spin_lock(&rt_rq->rt_runtime_lock); : 
strstr : for : 		raw_spin_lock(&rt_rq->rt_runtime_lock); : 
strstr : while : 		raw_spin_lock(&rt_rq->rt_runtime_lock); : 
str : 		rt_rq->rt_runtime = rt_runtime;
strstr : INIT : 		rt_rq->rt_runtime = rt_runtime; : 
strstr : if : 		rt_rq->rt_runtime = rt_runtime; : 
strstr : for : 		rt_rq->rt_runtime = rt_runtime; : 
strstr : while : 		rt_rq->rt_runtime = rt_runtime; : 
str : 		raw_spin_unlock(&rt_rq->rt_runtime_lock);
strstr : INIT : 		raw_spin_unlock(&rt_rq->rt_runtime_lock); : 
strstr : if : 		raw_spin_unlock(&rt_rq->rt_runtime_lock); : 
strstr : for : 		raw_spin_unlock(&rt_rq->rt_runtime_lock); : 
strstr : while : 		raw_spin_unlock(&rt_rq->rt_runtime_lock); : 
str : 	}
strstr : INIT : 	} : 
strstr : if : 	} : 
strstr : for : 	} : 
strstr : while : 	} : 
str : 	raw_spin_unlock_irq(&tg->rt_bandwidth.rt_runtime_lock);
strstr : INIT : 	raw_spin_unlock_irq(&tg->rt_bandwidth.rt_runtime_lock); : 
strstr : if : 	raw_spin_unlock_irq(&tg->rt_bandwidth.rt_runtime_lock); : 
strstr : for : 	raw_spin_unlock_irq(&tg->rt_bandwidth.rt_runtime_lock); : 
strstr : while : 	raw_spin_unlock_irq(&tg->rt_bandwidth.rt_runtime_lock); : 
str : unlock:
strstr : INIT : unlock: : 
strstr : if : unlock: : 
strstr : for : unlock: : 
strstr : while : unlock: : 
str : 	read_unlock(&tasklist_lock);
strstr : INIT : 	read_unlock(&tasklist_lock); : 
strstr : if : 	read_unlock(&tasklist_lock); : 
strstr : for : 	read_unlock(&tasklist_lock); : 
strstr : while : 	read_unlock(&tasklist_lock); : 
str : 	mutex_unlock(&rt_constraints_mutex);
strstr : INIT : 	mutex_unlock(&rt_constraints_mutex); : 
strstr : if : 	mutex_unlock(&rt_constraints_mutex); : 
strstr : for : 	mutex_unlock(&rt_constraints_mutex); : 
strstr : while : 	mutex_unlock(&rt_constraints_mutex); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	return err;
strstr : if : 	return err; : 
strstr : for : 	return err; : 
strstr : while : 	return err; : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : static int sched_group_set_rt_runtime(struct task_group *tg, long rt_runtime_us)
strstr : if : static int sched_group_set_rt_runtime(struct task_group *tg, long rt_runtime_us) : 
strstr : for : static int sched_group_set_rt_runtime(struct task_group *tg, long rt_runtime_us) : 
strstr : while : static int sched_group_set_rt_runtime(struct task_group *tg, long rt_runtime_us) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	u64 rt_runtime, rt_period;
strstr : INIT : 	u64 rt_runtime, rt_period; : 
strstr : if : 	u64 rt_runtime, rt_period; : 
strstr : for : 	u64 rt_runtime, rt_period; : 
strstr : while : 	u64 rt_runtime, rt_period; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	rt_period = ktime_to_ns(tg->rt_bandwidth.rt_period);
strstr : if : 	rt_period = ktime_to_ns(tg->rt_bandwidth.rt_period); : 
strstr : for : 	rt_period = ktime_to_ns(tg->rt_bandwidth.rt_period); : 
strstr : while : 	rt_period = ktime_to_ns(tg->rt_bandwidth.rt_period); : 
str : 	rt_runtime = (u64)rt_runtime_us * NSEC_PER_USEC;
strstr : INIT : 	rt_runtime = (u64)rt_runtime_us * NSEC_PER_USEC; : 
strstr : if : 	rt_runtime = (u64)rt_runtime_us * NSEC_PER_USEC; : 
strstr : for : 	rt_runtime = (u64)rt_runtime_us * NSEC_PER_USEC; : 
strstr : while : 	rt_runtime = (u64)rt_runtime_us * NSEC_PER_USEC; : 
str : 	if (rt_runtime_us < 0)
strstr : INIT : 	if (rt_runtime_us < 0) : 
strstr : if : 	if (rt_runtime_us < 0) : 
strstr : for : 	if (rt_runtime_us < 0) : 
strstr : while : 	if (rt_runtime_us < 0) : 
str : 		rt_runtime = RUNTIME_INF;
strstr : INIT : 		rt_runtime = RUNTIME_INF; : 
strstr : if : 		rt_runtime = RUNTIME_INF; : 
strstr : for : 		rt_runtime = RUNTIME_INF; : 
strstr : while : 		rt_runtime = RUNTIME_INF; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	return tg_set_rt_bandwidth(tg, rt_period, rt_runtime);
strstr : if : 	return tg_set_rt_bandwidth(tg, rt_period, rt_runtime); : 
strstr : for : 	return tg_set_rt_bandwidth(tg, rt_period, rt_runtime); : 
strstr : while : 	return tg_set_rt_bandwidth(tg, rt_period, rt_runtime); : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : static long sched_group_rt_runtime(struct task_group *tg)
strstr : if : static long sched_group_rt_runtime(struct task_group *tg) : 
strstr : for : static long sched_group_rt_runtime(struct task_group *tg) : 
strstr : while : static long sched_group_rt_runtime(struct task_group *tg) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	u64 rt_runtime_us;
strstr : INIT : 	u64 rt_runtime_us; : 
strstr : if : 	u64 rt_runtime_us; : 
strstr : for : 	u64 rt_runtime_us; : 
strstr : while : 	u64 rt_runtime_us; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	if (tg->rt_bandwidth.rt_runtime == RUNTIME_INF)
strstr : if : 	if (tg->rt_bandwidth.rt_runtime == RUNTIME_INF) : 
strstr : for : 	if (tg->rt_bandwidth.rt_runtime == RUNTIME_INF) : 
strstr : while : 	if (tg->rt_bandwidth.rt_runtime == RUNTIME_INF) : 
str : 		return -1;
strstr : INIT : 		return -1; : 
strstr : if : 		return -1; : 
strstr : for : 		return -1; : 
strstr : while : 		return -1; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	rt_runtime_us = tg->rt_bandwidth.rt_runtime;
strstr : if : 	rt_runtime_us = tg->rt_bandwidth.rt_runtime; : 
strstr : for : 	rt_runtime_us = tg->rt_bandwidth.rt_runtime; : 
strstr : while : 	rt_runtime_us = tg->rt_bandwidth.rt_runtime; : 
str : 	do_div(rt_runtime_us, NSEC_PER_USEC);
strstr : INIT : 	do_div(rt_runtime_us, NSEC_PER_USEC); : 
strstr : if : 	do_div(rt_runtime_us, NSEC_PER_USEC); : 
strstr : for : 	do_div(rt_runtime_us, NSEC_PER_USEC); : 
strstr : while : 	do_div(rt_runtime_us, NSEC_PER_USEC); : 
str : 	return rt_runtime_us;
strstr : INIT : 	return rt_runtime_us; : 
strstr : if : 	return rt_runtime_us; : 
strstr : for : 	return rt_runtime_us; : 
strstr : while : 	return rt_runtime_us; : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : static int sched_group_set_rt_period(struct task_group *tg, long rt_period_us)
strstr : if : static int sched_group_set_rt_period(struct task_group *tg, long rt_period_us) : 
strstr : for : static int sched_group_set_rt_period(struct task_group *tg, long rt_period_us) : 
strstr : while : static int sched_group_set_rt_period(struct task_group *tg, long rt_period_us) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	u64 rt_runtime, rt_period;
strstr : INIT : 	u64 rt_runtime, rt_period; : 
strstr : if : 	u64 rt_runtime, rt_period; : 
strstr : for : 	u64 rt_runtime, rt_period; : 
strstr : while : 	u64 rt_runtime, rt_period; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	rt_period = (u64)rt_period_us * NSEC_PER_USEC;
strstr : if : 	rt_period = (u64)rt_period_us * NSEC_PER_USEC; : 
strstr : for : 	rt_period = (u64)rt_period_us * NSEC_PER_USEC; : 
strstr : while : 	rt_period = (u64)rt_period_us * NSEC_PER_USEC; : 
str : 	rt_runtime = tg->rt_bandwidth.rt_runtime;
strstr : INIT : 	rt_runtime = tg->rt_bandwidth.rt_runtime; : 
strstr : if : 	rt_runtime = tg->rt_bandwidth.rt_runtime; : 
strstr : for : 	rt_runtime = tg->rt_bandwidth.rt_runtime; : 
strstr : while : 	rt_runtime = tg->rt_bandwidth.rt_runtime; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	if (rt_period == 0)
strstr : if : 	if (rt_period == 0) : 
strstr : for : 	if (rt_period == 0) : 
strstr : while : 	if (rt_period == 0) : 
str : 		return -EINVAL;
strstr : INIT : 		return -EINVAL; : 
strstr : if : 		return -EINVAL; : 
strstr : for : 		return -EINVAL; : 
strstr : while : 		return -EINVAL; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	return tg_set_rt_bandwidth(tg, rt_period, rt_runtime);
strstr : if : 	return tg_set_rt_bandwidth(tg, rt_period, rt_runtime); : 
strstr : for : 	return tg_set_rt_bandwidth(tg, rt_period, rt_runtime); : 
strstr : while : 	return tg_set_rt_bandwidth(tg, rt_period, rt_runtime); : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : static long sched_group_rt_period(struct task_group *tg)
strstr : if : static long sched_group_rt_period(struct task_group *tg) : 
strstr : for : static long sched_group_rt_period(struct task_group *tg) : 
strstr : while : static long sched_group_rt_period(struct task_group *tg) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	u64 rt_period_us;
strstr : INIT : 	u64 rt_period_us; : 
strstr : if : 	u64 rt_period_us; : 
strstr : for : 	u64 rt_period_us; : 
strstr : while : 	u64 rt_period_us; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	rt_period_us = ktime_to_ns(tg->rt_bandwidth.rt_period);
strstr : if : 	rt_period_us = ktime_to_ns(tg->rt_bandwidth.rt_period); : 
strstr : for : 	rt_period_us = ktime_to_ns(tg->rt_bandwidth.rt_period); : 
strstr : while : 	rt_period_us = ktime_to_ns(tg->rt_bandwidth.rt_period); : 
str : 	do_div(rt_period_us, NSEC_PER_USEC);
strstr : INIT : 	do_div(rt_period_us, NSEC_PER_USEC); : 
strstr : if : 	do_div(rt_period_us, NSEC_PER_USEC); : 
strstr : for : 	do_div(rt_period_us, NSEC_PER_USEC); : 
strstr : while : 	do_div(rt_period_us, NSEC_PER_USEC); : 
str : 	return rt_period_us;
strstr : INIT : 	return rt_period_us; : 
strstr : if : 	return rt_period_us; : 
strstr : for : 	return rt_period_us; : 
strstr : while : 	return rt_period_us; : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : #endif /* CONFIG_RT_GROUP_SCHED */
strstr : INIT : #endif /* CONFIG_RT_GROUP_SCHED */ : 
strstr : if : #endif /* CONFIG_RT_GROUP_SCHED */ : 
strstr : for : #endif /* CONFIG_RT_GROUP_SCHED */ : 
strstr : while : #endif /* CONFIG_RT_GROUP_SCHED */ : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : #ifdef CONFIG_RT_GROUP_SCHED
strstr : if : #ifdef CONFIG_RT_GROUP_SCHED : 
strstr : for : #ifdef CONFIG_RT_GROUP_SCHED : 
strstr : while : #ifdef CONFIG_RT_GROUP_SCHED : 
str : static int sched_rt_global_constraints(void)
strstr : INIT : static int sched_rt_global_constraints(void) : 
strstr : if : static int sched_rt_global_constraints(void) : 
strstr : for : static int sched_rt_global_constraints(void) : 
strstr : while : static int sched_rt_global_constraints(void) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	int ret = 0;
strstr : INIT : 	int ret = 0; : 
strstr : if : 	int ret = 0; : 
strstr : for : 	int ret = 0; : 
strstr : while : 	int ret = 0; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	mutex_lock(&rt_constraints_mutex);
strstr : if : 	mutex_lock(&rt_constraints_mutex); : 
strstr : for : 	mutex_lock(&rt_constraints_mutex); : 
strstr : while : 	mutex_lock(&rt_constraints_mutex); : 
str : 	read_lock(&tasklist_lock);
strstr : INIT : 	read_lock(&tasklist_lock); : 
strstr : if : 	read_lock(&tasklist_lock); : 
strstr : for : 	read_lock(&tasklist_lock); : 
strstr : while : 	read_lock(&tasklist_lock); : 
str : 	ret = __rt_schedulable(NULL, 0, 0);
strstr : INIT : 	ret = __rt_schedulable(NULL, 0, 0); : 
strstr : if : 	ret = __rt_schedulable(NULL, 0, 0); : 
strstr : for : 	ret = __rt_schedulable(NULL, 0, 0); : 
strstr : while : 	ret = __rt_schedulable(NULL, 0, 0); : 
str : 	read_unlock(&tasklist_lock);
strstr : INIT : 	read_unlock(&tasklist_lock); : 
strstr : if : 	read_unlock(&tasklist_lock); : 
strstr : for : 	read_unlock(&tasklist_lock); : 
strstr : while : 	read_unlock(&tasklist_lock); : 
str : 	mutex_unlock(&rt_constraints_mutex);
strstr : INIT : 	mutex_unlock(&rt_constraints_mutex); : 
strstr : if : 	mutex_unlock(&rt_constraints_mutex); : 
strstr : for : 	mutex_unlock(&rt_constraints_mutex); : 
strstr : while : 	mutex_unlock(&rt_constraints_mutex); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	return ret;
strstr : if : 	return ret; : 
strstr : for : 	return ret; : 
strstr : while : 	return ret; : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : static int sched_rt_can_attach(struct task_group *tg, struct task_struct *tsk)
strstr : if : static int sched_rt_can_attach(struct task_group *tg, struct task_struct *tsk) : 
strstr : for : static int sched_rt_can_attach(struct task_group *tg, struct task_struct *tsk) : 
strstr : while : static int sched_rt_can_attach(struct task_group *tg, struct task_struct *tsk) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	/* Don't accept realtime tasks when there is no way for them to run */
strstr : INIT : 	/* Don't accept realtime tasks when there is no way for them to run */ : 
strstr : if : 	/* Don't accept realtime tasks when there is no way for them to run */ : 
strstr : for : 	/* Don't accept realtime tasks when there is no way for them to run */ : 
strstr : while : 	/* Don't accept realtime tasks when there is no way for them to run */ : 
str : 	if (rt_task(tsk) && tg->rt_bandwidth.rt_runtime == 0)
strstr : INIT : 	if (rt_task(tsk) && tg->rt_bandwidth.rt_runtime == 0) : 
strstr : if : 	if (rt_task(tsk) && tg->rt_bandwidth.rt_runtime == 0) : 
strstr : for : 	if (rt_task(tsk) && tg->rt_bandwidth.rt_runtime == 0) : 
strstr : while : 	if (rt_task(tsk) && tg->rt_bandwidth.rt_runtime == 0) : 
str : 		return 0;
strstr : INIT : 		return 0; : 
strstr : if : 		return 0; : 
strstr : for : 		return 0; : 
strstr : while : 		return 0; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	return 1;
strstr : if : 	return 1; : 
strstr : for : 	return 1; : 
strstr : while : 	return 1; : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : #else /* !CONFIG_RT_GROUP_SCHED */
strstr : if : #else /* !CONFIG_RT_GROUP_SCHED */ : 
strstr : for : #else /* !CONFIG_RT_GROUP_SCHED */ : 
strstr : while : #else /* !CONFIG_RT_GROUP_SCHED */ : 
str : static int sched_rt_global_constraints(void)
strstr : INIT : static int sched_rt_global_constraints(void) : 
strstr : if : static int sched_rt_global_constraints(void) : 
strstr : for : static int sched_rt_global_constraints(void) : 
strstr : while : static int sched_rt_global_constraints(void) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	unsigned long flags;
strstr : INIT : 	unsigned long flags; : 
strstr : if : 	unsigned long flags; : 
strstr : for : 	unsigned long flags; : 
strstr : while : 	unsigned long flags; : 
str : 	int i, ret = 0;
strstr : INIT : 	int i, ret = 0; : 
strstr : if : 	int i, ret = 0; : 
strstr : for : 	int i, ret = 0; : 
strstr : while : 	int i, ret = 0; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	raw_spin_lock_irqsave(&def_rt_bandwidth.rt_runtime_lock, flags);
strstr : if : 	raw_spin_lock_irqsave(&def_rt_bandwidth.rt_runtime_lock, flags); : 
strstr : for : 	raw_spin_lock_irqsave(&def_rt_bandwidth.rt_runtime_lock, flags); : 
strstr : while : 	raw_spin_lock_irqsave(&def_rt_bandwidth.rt_runtime_lock, flags); : 
str : 	for_each_possible_cpu(i) {
strstr : INIT : 	for_each_possible_cpu(i) { : 
strstr : if : 	for_each_possible_cpu(i) { : 
strstr : for : 	for_each_possible_cpu(i) { : 
strstr : while : 	for_each_possible_cpu(i) { : 
str : 		struct rt_rq *rt_rq = &cpu_rq(i)->rt;
strstr : INIT : 		struct rt_rq *rt_rq = &cpu_rq(i)->rt; : 
strstr : if : 		struct rt_rq *rt_rq = &cpu_rq(i)->rt; : 
strstr : for : 		struct rt_rq *rt_rq = &cpu_rq(i)->rt; : 
strstr : while : 		struct rt_rq *rt_rq = &cpu_rq(i)->rt; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 		raw_spin_lock(&rt_rq->rt_runtime_lock);
strstr : if : 		raw_spin_lock(&rt_rq->rt_runtime_lock); : 
strstr : for : 		raw_spin_lock(&rt_rq->rt_runtime_lock); : 
strstr : while : 		raw_spin_lock(&rt_rq->rt_runtime_lock); : 
str : 		rt_rq->rt_runtime = global_rt_runtime();
strstr : INIT : 		rt_rq->rt_runtime = global_rt_runtime(); : 
strstr : if : 		rt_rq->rt_runtime = global_rt_runtime(); : 
strstr : for : 		rt_rq->rt_runtime = global_rt_runtime(); : 
strstr : while : 		rt_rq->rt_runtime = global_rt_runtime(); : 
str : 		raw_spin_unlock(&rt_rq->rt_runtime_lock);
strstr : INIT : 		raw_spin_unlock(&rt_rq->rt_runtime_lock); : 
strstr : if : 		raw_spin_unlock(&rt_rq->rt_runtime_lock); : 
strstr : for : 		raw_spin_unlock(&rt_rq->rt_runtime_lock); : 
strstr : while : 		raw_spin_unlock(&rt_rq->rt_runtime_lock); : 
str : 	}
strstr : INIT : 	} : 
strstr : if : 	} : 
strstr : for : 	} : 
strstr : while : 	} : 
str : 	raw_spin_unlock_irqrestore(&def_rt_bandwidth.rt_runtime_lock, flags);
strstr : INIT : 	raw_spin_unlock_irqrestore(&def_rt_bandwidth.rt_runtime_lock, flags); : 
strstr : if : 	raw_spin_unlock_irqrestore(&def_rt_bandwidth.rt_runtime_lock, flags); : 
strstr : for : 	raw_spin_unlock_irqrestore(&def_rt_bandwidth.rt_runtime_lock, flags); : 
strstr : while : 	raw_spin_unlock_irqrestore(&def_rt_bandwidth.rt_runtime_lock, flags); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	return ret;
strstr : if : 	return ret; : 
strstr : for : 	return ret; : 
strstr : while : 	return ret; : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : #endif /* CONFIG_RT_GROUP_SCHED */
strstr : INIT : #endif /* CONFIG_RT_GROUP_SCHED */ : 
strstr : if : #endif /* CONFIG_RT_GROUP_SCHED */ : 
strstr : for : #endif /* CONFIG_RT_GROUP_SCHED */ : 
strstr : while : #endif /* CONFIG_RT_GROUP_SCHED */ : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : static int sched_dl_global_constraints(void)
strstr : if : static int sched_dl_global_constraints(void) : 
strstr : for : static int sched_dl_global_constraints(void) : 
strstr : while : static int sched_dl_global_constraints(void) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	u64 runtime = global_rt_runtime();
strstr : INIT : 	u64 runtime = global_rt_runtime(); : 
strstr : if : 	u64 runtime = global_rt_runtime(); : 
strstr : for : 	u64 runtime = global_rt_runtime(); : 
strstr : while : 	u64 runtime = global_rt_runtime(); : 
str : 	u64 period = global_rt_period();
strstr : INIT : 	u64 period = global_rt_period(); : 
strstr : if : 	u64 period = global_rt_period(); : 
strstr : for : 	u64 period = global_rt_period(); : 
strstr : while : 	u64 period = global_rt_period(); : 
str : 	u64 new_bw = to_ratio(period, runtime);
strstr : INIT : 	u64 new_bw = to_ratio(period, runtime); : 
strstr : if : 	u64 new_bw = to_ratio(period, runtime); : 
strstr : for : 	u64 new_bw = to_ratio(period, runtime); : 
strstr : while : 	u64 new_bw = to_ratio(period, runtime); : 
str : 	int cpu, ret = 0;
strstr : INIT : 	int cpu, ret = 0; : 
strstr : if : 	int cpu, ret = 0; : 
strstr : for : 	int cpu, ret = 0; : 
strstr : while : 	int cpu, ret = 0; : 
str : 	unsigned long flags;
strstr : INIT : 	unsigned long flags; : 
strstr : if : 	unsigned long flags; : 
strstr : for : 	unsigned long flags; : 
strstr : while : 	unsigned long flags; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	/*
strstr : if : 	/* : 
strstr : for : 	/* : 
strstr : while : 	/* : 
str : 	 * Here we want to check the bandwidth not being set to some
strstr : INIT : 	 * Here we want to check the bandwidth not being set to some : 
strstr : if : 	 * Here we want to check the bandwidth not being set to some : 
strstr : for : 	 * Here we want to check the bandwidth not being set to some : 
strstr : while : 	 * Here we want to check the bandwidth not being set to some : 
str : 	 * value smaller than the currently allocated bandwidth in
strstr : INIT : 	 * value smaller than the currently allocated bandwidth in : 
strstr : if : 	 * value smaller than the currently allocated bandwidth in : 
strstr : for : 	 * value smaller than the currently allocated bandwidth in : 
strstr : while : 	 * value smaller than the currently allocated bandwidth in : 
str : 	 * any of the root_domains.
strstr : INIT : 	 * any of the root_domains. : 
strstr : if : 	 * any of the root_domains. : 
strstr : for : 	 * any of the root_domains. : 
strstr : while : 	 * any of the root_domains. : 
str : 	 *
strstr : INIT : 	 * : 
strstr : if : 	 * : 
strstr : for : 	 * : 
strstr : while : 	 * : 
str : 	 * FIXME: Cycling on all the CPUs is overdoing, but simpler than
strstr : INIT : 	 * FIXME: Cycling on all the CPUs is overdoing, but simpler than : 
strstr : if : 	 * FIXME: Cycling on all the CPUs is overdoing, but simpler than : 
strstr : for : 	 * FIXME: Cycling on all the CPUs is overdoing, but simpler than : 
strstr : while : 	 * FIXME: Cycling on all the CPUs is overdoing, but simpler than : 
str : 	 * cycling on root_domains... Discussion on different/better
strstr : INIT : 	 * cycling on root_domains... Discussion on different/better : 
strstr : if : 	 * cycling on root_domains... Discussion on different/better : 
strstr : for : 	 * cycling on root_domains... Discussion on different/better : 
strstr : while : 	 * cycling on root_domains... Discussion on different/better : 
str : 	 * solutions is welcome!
strstr : INIT : 	 * solutions is welcome! : 
strstr : if : 	 * solutions is welcome! : 
strstr : for : 	 * solutions is welcome! : 
strstr : while : 	 * solutions is welcome! : 
str : 	 */
strstr : INIT : 	 */ : 
strstr : if : 	 */ : 
strstr : for : 	 */ : 
strstr : while : 	 */ : 
str : 	for_each_possible_cpu(cpu) {
strstr : INIT : 	for_each_possible_cpu(cpu) { : 
strstr : if : 	for_each_possible_cpu(cpu) { : 
strstr : for : 	for_each_possible_cpu(cpu) { : 
strstr : while : 	for_each_possible_cpu(cpu) { : 
str : 		struct dl_bw *dl_b = dl_bw_of(cpu);
strstr : INIT : 		struct dl_bw *dl_b = dl_bw_of(cpu); : 
strstr : if : 		struct dl_bw *dl_b = dl_bw_of(cpu); : 
strstr : for : 		struct dl_bw *dl_b = dl_bw_of(cpu); : 
strstr : while : 		struct dl_bw *dl_b = dl_bw_of(cpu); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 		raw_spin_lock_irqsave(&dl_b->lock, flags);
strstr : if : 		raw_spin_lock_irqsave(&dl_b->lock, flags); : 
strstr : for : 		raw_spin_lock_irqsave(&dl_b->lock, flags); : 
strstr : while : 		raw_spin_lock_irqsave(&dl_b->lock, flags); : 
str : 		if (new_bw < dl_b->total_bw)
strstr : INIT : 		if (new_bw < dl_b->total_bw) : 
strstr : if : 		if (new_bw < dl_b->total_bw) : 
strstr : for : 		if (new_bw < dl_b->total_bw) : 
strstr : while : 		if (new_bw < dl_b->total_bw) : 
str : 			ret = -EBUSY;
strstr : INIT : 			ret = -EBUSY; : 
strstr : if : 			ret = -EBUSY; : 
strstr : for : 			ret = -EBUSY; : 
strstr : while : 			ret = -EBUSY; : 
str : 		raw_spin_unlock_irqrestore(&dl_b->lock, flags);
strstr : INIT : 		raw_spin_unlock_irqrestore(&dl_b->lock, flags); : 
strstr : if : 		raw_spin_unlock_irqrestore(&dl_b->lock, flags); : 
strstr : for : 		raw_spin_unlock_irqrestore(&dl_b->lock, flags); : 
strstr : while : 		raw_spin_unlock_irqrestore(&dl_b->lock, flags); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 		if (ret)
strstr : if : 		if (ret) : 
strstr : for : 		if (ret) : 
strstr : while : 		if (ret) : 
str : 			break;
strstr : INIT : 			break; : 
strstr : if : 			break; : 
strstr : for : 			break; : 
strstr : while : 			break; : 
str : 	}
strstr : INIT : 	} : 
strstr : if : 	} : 
strstr : for : 	} : 
strstr : while : 	} : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	return ret;
strstr : if : 	return ret; : 
strstr : for : 	return ret; : 
strstr : while : 	return ret; : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : static void sched_dl_do_global(void)
strstr : if : static void sched_dl_do_global(void) : 
strstr : for : static void sched_dl_do_global(void) : 
strstr : while : static void sched_dl_do_global(void) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	u64 new_bw = -1;
strstr : INIT : 	u64 new_bw = -1; : 
strstr : if : 	u64 new_bw = -1; : 
strstr : for : 	u64 new_bw = -1; : 
strstr : while : 	u64 new_bw = -1; : 
str : 	int cpu;
strstr : INIT : 	int cpu; : 
strstr : if : 	int cpu; : 
strstr : for : 	int cpu; : 
strstr : while : 	int cpu; : 
str : 	unsigned long flags;
strstr : INIT : 	unsigned long flags; : 
strstr : if : 	unsigned long flags; : 
strstr : for : 	unsigned long flags; : 
strstr : while : 	unsigned long flags; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	def_dl_bandwidth.dl_period = global_rt_period();
strstr : if : 	def_dl_bandwidth.dl_period = global_rt_period(); : 
strstr : for : 	def_dl_bandwidth.dl_period = global_rt_period(); : 
strstr : while : 	def_dl_bandwidth.dl_period = global_rt_period(); : 
str : 	def_dl_bandwidth.dl_runtime = global_rt_runtime();
strstr : INIT : 	def_dl_bandwidth.dl_runtime = global_rt_runtime(); : 
strstr : if : 	def_dl_bandwidth.dl_runtime = global_rt_runtime(); : 
strstr : for : 	def_dl_bandwidth.dl_runtime = global_rt_runtime(); : 
strstr : while : 	def_dl_bandwidth.dl_runtime = global_rt_runtime(); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	if (global_rt_runtime() != RUNTIME_INF)
strstr : if : 	if (global_rt_runtime() != RUNTIME_INF) : 
strstr : for : 	if (global_rt_runtime() != RUNTIME_INF) : 
strstr : while : 	if (global_rt_runtime() != RUNTIME_INF) : 
str : 		new_bw = to_ratio(global_rt_period(), global_rt_runtime());
strstr : INIT : 		new_bw = to_ratio(global_rt_period(), global_rt_runtime()); : 
strstr : if : 		new_bw = to_ratio(global_rt_period(), global_rt_runtime()); : 
strstr : for : 		new_bw = to_ratio(global_rt_period(), global_rt_runtime()); : 
strstr : while : 		new_bw = to_ratio(global_rt_period(), global_rt_runtime()); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	/*
strstr : if : 	/* : 
strstr : for : 	/* : 
strstr : while : 	/* : 
str : 	 * FIXME: As above...
strstr : INIT : 	 * FIXME: As above... : 
strstr : if : 	 * FIXME: As above... : 
strstr : for : 	 * FIXME: As above... : 
strstr : while : 	 * FIXME: As above... : 
str : 	 */
strstr : INIT : 	 */ : 
strstr : if : 	 */ : 
strstr : for : 	 */ : 
strstr : while : 	 */ : 
str : 	for_each_possible_cpu(cpu) {
strstr : INIT : 	for_each_possible_cpu(cpu) { : 
strstr : if : 	for_each_possible_cpu(cpu) { : 
strstr : for : 	for_each_possible_cpu(cpu) { : 
strstr : while : 	for_each_possible_cpu(cpu) { : 
str : 		struct dl_bw *dl_b = dl_bw_of(cpu);
strstr : INIT : 		struct dl_bw *dl_b = dl_bw_of(cpu); : 
strstr : if : 		struct dl_bw *dl_b = dl_bw_of(cpu); : 
strstr : for : 		struct dl_bw *dl_b = dl_bw_of(cpu); : 
strstr : while : 		struct dl_bw *dl_b = dl_bw_of(cpu); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 		raw_spin_lock_irqsave(&dl_b->lock, flags);
strstr : if : 		raw_spin_lock_irqsave(&dl_b->lock, flags); : 
strstr : for : 		raw_spin_lock_irqsave(&dl_b->lock, flags); : 
strstr : while : 		raw_spin_lock_irqsave(&dl_b->lock, flags); : 
str : 		dl_b->bw = new_bw;
strstr : INIT : 		dl_b->bw = new_bw; : 
strstr : if : 		dl_b->bw = new_bw; : 
strstr : for : 		dl_b->bw = new_bw; : 
strstr : while : 		dl_b->bw = new_bw; : 
str : 		raw_spin_unlock_irqrestore(&dl_b->lock, flags);
strstr : INIT : 		raw_spin_unlock_irqrestore(&dl_b->lock, flags); : 
strstr : if : 		raw_spin_unlock_irqrestore(&dl_b->lock, flags); : 
strstr : for : 		raw_spin_unlock_irqrestore(&dl_b->lock, flags); : 
strstr : while : 		raw_spin_unlock_irqrestore(&dl_b->lock, flags); : 
str : 	}
strstr : INIT : 	} : 
strstr : if : 	} : 
strstr : for : 	} : 
strstr : while : 	} : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : static int sched_rt_global_validate(void)
strstr : if : static int sched_rt_global_validate(void) : 
strstr : for : static int sched_rt_global_validate(void) : 
strstr : while : static int sched_rt_global_validate(void) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	if (sysctl_sched_rt_period <= 0)
strstr : INIT : 	if (sysctl_sched_rt_period <= 0) : 
strstr : if : 	if (sysctl_sched_rt_period <= 0) : 
strstr : for : 	if (sysctl_sched_rt_period <= 0) : 
strstr : while : 	if (sysctl_sched_rt_period <= 0) : 
str : 		return -EINVAL;
strstr : INIT : 		return -EINVAL; : 
strstr : if : 		return -EINVAL; : 
strstr : for : 		return -EINVAL; : 
strstr : while : 		return -EINVAL; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	if ((sysctl_sched_rt_runtime != RUNTIME_INF) &&
strstr : if : 	if ((sysctl_sched_rt_runtime != RUNTIME_INF) && : 
strstr : for : 	if ((sysctl_sched_rt_runtime != RUNTIME_INF) && : 
strstr : while : 	if ((sysctl_sched_rt_runtime != RUNTIME_INF) && : 
str : 		(sysctl_sched_rt_runtime > sysctl_sched_rt_period))
strstr : INIT : 		(sysctl_sched_rt_runtime > sysctl_sched_rt_period)) : 
strstr : if : 		(sysctl_sched_rt_runtime > sysctl_sched_rt_period)) : 
strstr : for : 		(sysctl_sched_rt_runtime > sysctl_sched_rt_period)) : 
strstr : while : 		(sysctl_sched_rt_runtime > sysctl_sched_rt_period)) : 
str : 		return -EINVAL;
strstr : INIT : 		return -EINVAL; : 
strstr : if : 		return -EINVAL; : 
strstr : for : 		return -EINVAL; : 
strstr : while : 		return -EINVAL; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	return 0;
strstr : if : 	return 0; : 
strstr : for : 	return 0; : 
strstr : while : 	return 0; : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : static void sched_rt_do_global(void)
strstr : if : static void sched_rt_do_global(void) : 
strstr : for : static void sched_rt_do_global(void) : 
strstr : while : static void sched_rt_do_global(void) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	def_rt_bandwidth.rt_runtime = global_rt_runtime();
strstr : INIT : 	def_rt_bandwidth.rt_runtime = global_rt_runtime(); : 
strstr : if : 	def_rt_bandwidth.rt_runtime = global_rt_runtime(); : 
strstr : for : 	def_rt_bandwidth.rt_runtime = global_rt_runtime(); : 
strstr : while : 	def_rt_bandwidth.rt_runtime = global_rt_runtime(); : 
str : 	def_rt_bandwidth.rt_period = ns_to_ktime(global_rt_period());
strstr : INIT : 	def_rt_bandwidth.rt_period = ns_to_ktime(global_rt_period()); : 
strstr : if : 	def_rt_bandwidth.rt_period = ns_to_ktime(global_rt_period()); : 
strstr : for : 	def_rt_bandwidth.rt_period = ns_to_ktime(global_rt_period()); : 
strstr : while : 	def_rt_bandwidth.rt_period = ns_to_ktime(global_rt_period()); : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : int sched_rt_handler(struct ctl_table *table, int write,
strstr : if : int sched_rt_handler(struct ctl_table *table, int write, : 
strstr : for : int sched_rt_handler(struct ctl_table *table, int write, : 
strstr : while : int sched_rt_handler(struct ctl_table *table, int write, : 
str : 		void __user *buffer, size_t *lenp,
strstr : INIT : 		void __user *buffer, size_t *lenp, : 
strstr : if : 		void __user *buffer, size_t *lenp, : 
strstr : for : 		void __user *buffer, size_t *lenp, : 
strstr : while : 		void __user *buffer, size_t *lenp, : 
str : 		loff_t *ppos)
strstr : INIT : 		loff_t *ppos) : 
strstr : if : 		loff_t *ppos) : 
strstr : for : 		loff_t *ppos) : 
strstr : while : 		loff_t *ppos) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	int old_period, old_runtime;
strstr : INIT : 	int old_period, old_runtime; : 
strstr : if : 	int old_period, old_runtime; : 
strstr : for : 	int old_period, old_runtime; : 
strstr : while : 	int old_period, old_runtime; : 
str : 	static DEFINE_MUTEX(mutex);
strstr : INIT : 	static DEFINE_MUTEX(mutex); : 
strstr : if : 	static DEFINE_MUTEX(mutex); : 
strstr : for : 	static DEFINE_MUTEX(mutex); : 
strstr : while : 	static DEFINE_MUTEX(mutex); : 
str : 	int ret;
strstr : INIT : 	int ret; : 
strstr : if : 	int ret; : 
strstr : for : 	int ret; : 
strstr : while : 	int ret; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	mutex_lock(&mutex);
strstr : if : 	mutex_lock(&mutex); : 
strstr : for : 	mutex_lock(&mutex); : 
strstr : while : 	mutex_lock(&mutex); : 
str : 	old_period = sysctl_sched_rt_period;
strstr : INIT : 	old_period = sysctl_sched_rt_period; : 
strstr : if : 	old_period = sysctl_sched_rt_period; : 
strstr : for : 	old_period = sysctl_sched_rt_period; : 
strstr : while : 	old_period = sysctl_sched_rt_period; : 
str : 	old_runtime = sysctl_sched_rt_runtime;
strstr : INIT : 	old_runtime = sysctl_sched_rt_runtime; : 
strstr : if : 	old_runtime = sysctl_sched_rt_runtime; : 
strstr : for : 	old_runtime = sysctl_sched_rt_runtime; : 
strstr : while : 	old_runtime = sysctl_sched_rt_runtime; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	ret = proc_dointvec(table, write, buffer, lenp, ppos);
strstr : if : 	ret = proc_dointvec(table, write, buffer, lenp, ppos); : 
strstr : for : 	ret = proc_dointvec(table, write, buffer, lenp, ppos); : 
strstr : while : 	ret = proc_dointvec(table, write, buffer, lenp, ppos); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	if (!ret && write) {
strstr : if : 	if (!ret && write) { : 
strstr : for : 	if (!ret && write) { : 
strstr : while : 	if (!ret && write) { : 
str : 		ret = sched_rt_global_validate();
strstr : INIT : 		ret = sched_rt_global_validate(); : 
strstr : if : 		ret = sched_rt_global_validate(); : 
strstr : for : 		ret = sched_rt_global_validate(); : 
strstr : while : 		ret = sched_rt_global_validate(); : 
str : 		if (ret)
strstr : INIT : 		if (ret) : 
strstr : if : 		if (ret) : 
strstr : for : 		if (ret) : 
strstr : while : 		if (ret) : 
str : 			goto undo;
strstr : INIT : 			goto undo; : 
strstr : if : 			goto undo; : 
strstr : for : 			goto undo; : 
strstr : while : 			goto undo; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 		ret = sched_rt_global_constraints();
strstr : if : 		ret = sched_rt_global_constraints(); : 
strstr : for : 		ret = sched_rt_global_constraints(); : 
strstr : while : 		ret = sched_rt_global_constraints(); : 
str : 		if (ret)
strstr : INIT : 		if (ret) : 
strstr : if : 		if (ret) : 
strstr : for : 		if (ret) : 
strstr : while : 		if (ret) : 
str : 			goto undo;
strstr : INIT : 			goto undo; : 
strstr : if : 			goto undo; : 
strstr : for : 			goto undo; : 
strstr : while : 			goto undo; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 		ret = sched_dl_global_constraints();
strstr : if : 		ret = sched_dl_global_constraints(); : 
strstr : for : 		ret = sched_dl_global_constraints(); : 
strstr : while : 		ret = sched_dl_global_constraints(); : 
str : 		if (ret)
strstr : INIT : 		if (ret) : 
strstr : if : 		if (ret) : 
strstr : for : 		if (ret) : 
strstr : while : 		if (ret) : 
str : 			goto undo;
strstr : INIT : 			goto undo; : 
strstr : if : 			goto undo; : 
strstr : for : 			goto undo; : 
strstr : while : 			goto undo; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 		sched_rt_do_global();
strstr : if : 		sched_rt_do_global(); : 
strstr : for : 		sched_rt_do_global(); : 
strstr : while : 		sched_rt_do_global(); : 
str : 		sched_dl_do_global();
strstr : INIT : 		sched_dl_do_global(); : 
strstr : if : 		sched_dl_do_global(); : 
strstr : for : 		sched_dl_do_global(); : 
strstr : while : 		sched_dl_do_global(); : 
str : 	}
strstr : INIT : 	} : 
strstr : if : 	} : 
strstr : for : 	} : 
strstr : while : 	} : 
str : 	if (0) {
strstr : INIT : 	if (0) { : 
strstr : if : 	if (0) { : 
strstr : for : 	if (0) { : 
strstr : while : 	if (0) { : 
str : undo:
strstr : INIT : undo: : 
strstr : if : undo: : 
strstr : for : undo: : 
strstr : while : undo: : 
str : 		sysctl_sched_rt_period = old_period;
strstr : INIT : 		sysctl_sched_rt_period = old_period; : 
strstr : if : 		sysctl_sched_rt_period = old_period; : 
strstr : for : 		sysctl_sched_rt_period = old_period; : 
strstr : while : 		sysctl_sched_rt_period = old_period; : 
str : 		sysctl_sched_rt_runtime = old_runtime;
strstr : INIT : 		sysctl_sched_rt_runtime = old_runtime; : 
strstr : if : 		sysctl_sched_rt_runtime = old_runtime; : 
strstr : for : 		sysctl_sched_rt_runtime = old_runtime; : 
strstr : while : 		sysctl_sched_rt_runtime = old_runtime; : 
str : 	}
strstr : INIT : 	} : 
strstr : if : 	} : 
strstr : for : 	} : 
strstr : while : 	} : 
str : 	mutex_unlock(&mutex);
strstr : INIT : 	mutex_unlock(&mutex); : 
strstr : if : 	mutex_unlock(&mutex); : 
strstr : for : 	mutex_unlock(&mutex); : 
strstr : while : 	mutex_unlock(&mutex); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	return ret;
strstr : if : 	return ret; : 
strstr : for : 	return ret; : 
strstr : while : 	return ret; : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : int sched_rr_handler(struct ctl_table *table, int write,
strstr : if : int sched_rr_handler(struct ctl_table *table, int write, : 
strstr : for : int sched_rr_handler(struct ctl_table *table, int write, : 
strstr : while : int sched_rr_handler(struct ctl_table *table, int write, : 
str : 		void __user *buffer, size_t *lenp,
strstr : INIT : 		void __user *buffer, size_t *lenp, : 
strstr : if : 		void __user *buffer, size_t *lenp, : 
strstr : for : 		void __user *buffer, size_t *lenp, : 
strstr : while : 		void __user *buffer, size_t *lenp, : 
str : 		loff_t *ppos)
strstr : INIT : 		loff_t *ppos) : 
strstr : if : 		loff_t *ppos) : 
strstr : for : 		loff_t *ppos) : 
strstr : while : 		loff_t *ppos) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	int ret;
strstr : INIT : 	int ret; : 
strstr : if : 	int ret; : 
strstr : for : 	int ret; : 
strstr : while : 	int ret; : 
str : 	static DEFINE_MUTEX(mutex);
strstr : INIT : 	static DEFINE_MUTEX(mutex); : 
strstr : if : 	static DEFINE_MUTEX(mutex); : 
strstr : for : 	static DEFINE_MUTEX(mutex); : 
strstr : while : 	static DEFINE_MUTEX(mutex); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	mutex_lock(&mutex);
strstr : if : 	mutex_lock(&mutex); : 
strstr : for : 	mutex_lock(&mutex); : 
strstr : while : 	mutex_lock(&mutex); : 
str : 	ret = proc_dointvec(table, write, buffer, lenp, ppos);
strstr : INIT : 	ret = proc_dointvec(table, write, buffer, lenp, ppos); : 
strstr : if : 	ret = proc_dointvec(table, write, buffer, lenp, ppos); : 
strstr : for : 	ret = proc_dointvec(table, write, buffer, lenp, ppos); : 
strstr : while : 	ret = proc_dointvec(table, write, buffer, lenp, ppos); : 
str : 	/* make sure that internally we keep jiffies */
strstr : INIT : 	/* make sure that internally we keep jiffies */ : 
strstr : if : 	/* make sure that internally we keep jiffies */ : 
strstr : for : 	/* make sure that internally we keep jiffies */ : 
strstr : while : 	/* make sure that internally we keep jiffies */ : 
str : 	/* also, writing zero resets timeslice to default */
strstr : INIT : 	/* also, writing zero resets timeslice to default */ : 
strstr : if : 	/* also, writing zero resets timeslice to default */ : 
strstr : for : 	/* also, writing zero resets timeslice to default */ : 
strstr : while : 	/* also, writing zero resets timeslice to default */ : 
str : 	if (!ret && write) {
strstr : INIT : 	if (!ret && write) { : 
strstr : if : 	if (!ret && write) { : 
strstr : for : 	if (!ret && write) { : 
strstr : while : 	if (!ret && write) { : 
str : 		sched_rr_timeslice = sched_rr_timeslice <= 0 ?
strstr : INIT : 		sched_rr_timeslice = sched_rr_timeslice <= 0 ? : 
strstr : if : 		sched_rr_timeslice = sched_rr_timeslice <= 0 ? : 
strstr : for : 		sched_rr_timeslice = sched_rr_timeslice <= 0 ? : 
strstr : while : 		sched_rr_timeslice = sched_rr_timeslice <= 0 ? : 
str : 			RR_TIMESLICE : msecs_to_jiffies(sched_rr_timeslice);
strstr : INIT : 			RR_TIMESLICE : msecs_to_jiffies(sched_rr_timeslice); : 
strstr : if : 			RR_TIMESLICE : msecs_to_jiffies(sched_rr_timeslice); : 
strstr : for : 			RR_TIMESLICE : msecs_to_jiffies(sched_rr_timeslice); : 
strstr : while : 			RR_TIMESLICE : msecs_to_jiffies(sched_rr_timeslice); : 
str : 	}
strstr : INIT : 	} : 
strstr : if : 	} : 
strstr : for : 	} : 
strstr : while : 	} : 
str : 	mutex_unlock(&mutex);
strstr : INIT : 	mutex_unlock(&mutex); : 
strstr : if : 	mutex_unlock(&mutex); : 
strstr : for : 	mutex_unlock(&mutex); : 
strstr : while : 	mutex_unlock(&mutex); : 
str : 	return ret;
strstr : INIT : 	return ret; : 
strstr : if : 	return ret; : 
strstr : for : 	return ret; : 
strstr : while : 	return ret; : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : #ifdef CONFIG_CGROUP_SCHED
strstr : if : #ifdef CONFIG_CGROUP_SCHED : 
strstr : for : #ifdef CONFIG_CGROUP_SCHED : 
strstr : while : #ifdef CONFIG_CGROUP_SCHED : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : static inline struct task_group *css_tg(struct cgroup_subsys_state *css)
strstr : if : static inline struct task_group *css_tg(struct cgroup_subsys_state *css) : 
strstr : for : static inline struct task_group *css_tg(struct cgroup_subsys_state *css) : 
strstr : while : static inline struct task_group *css_tg(struct cgroup_subsys_state *css) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	return css ? container_of(css, struct task_group, css) : NULL;
strstr : INIT : 	return css ? container_of(css, struct task_group, css) : NULL; : 
strstr : if : 	return css ? container_of(css, struct task_group, css) : NULL; : 
strstr : for : 	return css ? container_of(css, struct task_group, css) : NULL; : 
strstr : while : 	return css ? container_of(css, struct task_group, css) : NULL; : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : static struct cgroup_subsys_state *
strstr : if : static struct cgroup_subsys_state * : 
strstr : for : static struct cgroup_subsys_state * : 
strstr : while : static struct cgroup_subsys_state * : 
str : cpu_cgroup_css_alloc(struct cgroup_subsys_state *parent_css)
strstr : INIT : cpu_cgroup_css_alloc(struct cgroup_subsys_state *parent_css) : 
strstr : if : cpu_cgroup_css_alloc(struct cgroup_subsys_state *parent_css) : 
strstr : for : cpu_cgroup_css_alloc(struct cgroup_subsys_state *parent_css) : 
strstr : while : cpu_cgroup_css_alloc(struct cgroup_subsys_state *parent_css) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	struct task_group *parent = css_tg(parent_css);
strstr : INIT : 	struct task_group *parent = css_tg(parent_css); : 
strstr : if : 	struct task_group *parent = css_tg(parent_css); : 
strstr : for : 	struct task_group *parent = css_tg(parent_css); : 
strstr : while : 	struct task_group *parent = css_tg(parent_css); : 
str : 	struct task_group *tg;
strstr : INIT : 	struct task_group *tg; : 
strstr : if : 	struct task_group *tg; : 
strstr : for : 	struct task_group *tg; : 
strstr : while : 	struct task_group *tg; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	if (!parent) {
strstr : if : 	if (!parent) { : 
strstr : for : 	if (!parent) { : 
strstr : while : 	if (!parent) { : 
str : 		/* This is early initialization for the top cgroup */
strstr : INIT : 		/* This is early initialization for the top cgroup */ : 
strstr : if : 		/* This is early initialization for the top cgroup */ : 
strstr : for : 		/* This is early initialization for the top cgroup */ : 
strstr : while : 		/* This is early initialization for the top cgroup */ : 
str : 		return &root_task_group.css;
strstr : INIT : 		return &root_task_group.css; : 
strstr : if : 		return &root_task_group.css; : 
strstr : for : 		return &root_task_group.css; : 
strstr : while : 		return &root_task_group.css; : 
str : 	}
strstr : INIT : 	} : 
strstr : if : 	} : 
strstr : for : 	} : 
strstr : while : 	} : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	tg = sched_create_group(parent);
strstr : if : 	tg = sched_create_group(parent); : 
strstr : for : 	tg = sched_create_group(parent); : 
strstr : while : 	tg = sched_create_group(parent); : 
str : 	if (IS_ERR(tg))
strstr : INIT : 	if (IS_ERR(tg)) : 
strstr : if : 	if (IS_ERR(tg)) : 
strstr : for : 	if (IS_ERR(tg)) : 
strstr : while : 	if (IS_ERR(tg)) : 
str : 		return ERR_PTR(-ENOMEM);
strstr : INIT : 		return ERR_PTR(-ENOMEM); : 
strstr : if : 		return ERR_PTR(-ENOMEM); : 
strstr : for : 		return ERR_PTR(-ENOMEM); : 
strstr : while : 		return ERR_PTR(-ENOMEM); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	return &tg->css;
strstr : if : 	return &tg->css; : 
strstr : for : 	return &tg->css; : 
strstr : while : 	return &tg->css; : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : static int cpu_cgroup_css_online(struct cgroup_subsys_state *css)
strstr : if : static int cpu_cgroup_css_online(struct cgroup_subsys_state *css) : 
strstr : for : static int cpu_cgroup_css_online(struct cgroup_subsys_state *css) : 
strstr : while : static int cpu_cgroup_css_online(struct cgroup_subsys_state *css) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	struct task_group *tg = css_tg(css);
strstr : INIT : 	struct task_group *tg = css_tg(css); : 
strstr : if : 	struct task_group *tg = css_tg(css); : 
strstr : for : 	struct task_group *tg = css_tg(css); : 
strstr : while : 	struct task_group *tg = css_tg(css); : 
str : 	struct task_group *parent = css_tg(css_parent(css));
strstr : INIT : 	struct task_group *parent = css_tg(css_parent(css)); : 
strstr : if : 	struct task_group *parent = css_tg(css_parent(css)); : 
strstr : for : 	struct task_group *parent = css_tg(css_parent(css)); : 
strstr : while : 	struct task_group *parent = css_tg(css_parent(css)); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	if (parent)
strstr : if : 	if (parent) : 
strstr : for : 	if (parent) : 
strstr : while : 	if (parent) : 
str : 		sched_online_group(tg, parent);
strstr : INIT : 		sched_online_group(tg, parent); : 
strstr : if : 		sched_online_group(tg, parent); : 
strstr : for : 		sched_online_group(tg, parent); : 
strstr : while : 		sched_online_group(tg, parent); : 
str : 	return 0;
strstr : INIT : 	return 0; : 
strstr : if : 	return 0; : 
strstr : for : 	return 0; : 
strstr : while : 	return 0; : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : static void cpu_cgroup_css_free(struct cgroup_subsys_state *css)
strstr : if : static void cpu_cgroup_css_free(struct cgroup_subsys_state *css) : 
strstr : for : static void cpu_cgroup_css_free(struct cgroup_subsys_state *css) : 
strstr : while : static void cpu_cgroup_css_free(struct cgroup_subsys_state *css) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	struct task_group *tg = css_tg(css);
strstr : INIT : 	struct task_group *tg = css_tg(css); : 
strstr : if : 	struct task_group *tg = css_tg(css); : 
strstr : for : 	struct task_group *tg = css_tg(css); : 
strstr : while : 	struct task_group *tg = css_tg(css); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	sched_destroy_group(tg);
strstr : if : 	sched_destroy_group(tg); : 
strstr : for : 	sched_destroy_group(tg); : 
strstr : while : 	sched_destroy_group(tg); : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : static void cpu_cgroup_css_offline(struct cgroup_subsys_state *css)
strstr : if : static void cpu_cgroup_css_offline(struct cgroup_subsys_state *css) : 
strstr : for : static void cpu_cgroup_css_offline(struct cgroup_subsys_state *css) : 
strstr : while : static void cpu_cgroup_css_offline(struct cgroup_subsys_state *css) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	struct task_group *tg = css_tg(css);
strstr : INIT : 	struct task_group *tg = css_tg(css); : 
strstr : if : 	struct task_group *tg = css_tg(css); : 
strstr : for : 	struct task_group *tg = css_tg(css); : 
strstr : while : 	struct task_group *tg = css_tg(css); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	sched_offline_group(tg);
strstr : if : 	sched_offline_group(tg); : 
strstr : for : 	sched_offline_group(tg); : 
strstr : while : 	sched_offline_group(tg); : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : static int cpu_cgroup_can_attach(struct cgroup_subsys_state *css,
strstr : if : static int cpu_cgroup_can_attach(struct cgroup_subsys_state *css, : 
strstr : for : static int cpu_cgroup_can_attach(struct cgroup_subsys_state *css, : 
strstr : while : static int cpu_cgroup_can_attach(struct cgroup_subsys_state *css, : 
str : 				 struct cgroup_taskset *tset)
strstr : INIT : 				 struct cgroup_taskset *tset) : 
strstr : if : 				 struct cgroup_taskset *tset) : 
strstr : for : 				 struct cgroup_taskset *tset) : 
strstr : while : 				 struct cgroup_taskset *tset) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	struct task_struct *task;
strstr : INIT : 	struct task_struct *task; : 
strstr : if : 	struct task_struct *task; : 
strstr : for : 	struct task_struct *task; : 
strstr : while : 	struct task_struct *task; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	cgroup_taskset_for_each(task, css, tset) {
strstr : if : 	cgroup_taskset_for_each(task, css, tset) { : 
strstr : for : 	cgroup_taskset_for_each(task, css, tset) { : 
strstr : while : 	cgroup_taskset_for_each(task, css, tset) { : 
str : #ifdef CONFIG_RT_GROUP_SCHED
strstr : INIT : #ifdef CONFIG_RT_GROUP_SCHED : 
strstr : if : #ifdef CONFIG_RT_GROUP_SCHED : 
strstr : for : #ifdef CONFIG_RT_GROUP_SCHED : 
strstr : while : #ifdef CONFIG_RT_GROUP_SCHED : 
str : 		if (!sched_rt_can_attach(css_tg(css), task))
strstr : INIT : 		if (!sched_rt_can_attach(css_tg(css), task)) : 
strstr : if : 		if (!sched_rt_can_attach(css_tg(css), task)) : 
strstr : for : 		if (!sched_rt_can_attach(css_tg(css), task)) : 
strstr : while : 		if (!sched_rt_can_attach(css_tg(css), task)) : 
str : 			return -EINVAL;
strstr : INIT : 			return -EINVAL; : 
strstr : if : 			return -EINVAL; : 
strstr : for : 			return -EINVAL; : 
strstr : while : 			return -EINVAL; : 
str : #else
strstr : INIT : #else : 
strstr : if : #else : 
strstr : for : #else : 
strstr : while : #else : 
str : 		/* We don't support RT-tasks being in separate groups */
strstr : INIT : 		/* We don't support RT-tasks being in separate groups */ : 
strstr : if : 		/* We don't support RT-tasks being in separate groups */ : 
strstr : for : 		/* We don't support RT-tasks being in separate groups */ : 
strstr : while : 		/* We don't support RT-tasks being in separate groups */ : 
str : 		if (task->sched_class != &fair_sched_class)
strstr : INIT : 		if (task->sched_class != &fair_sched_class) : 
strstr : if : 		if (task->sched_class != &fair_sched_class) : 
strstr : for : 		if (task->sched_class != &fair_sched_class) : 
strstr : while : 		if (task->sched_class != &fair_sched_class) : 
str : 			return -EINVAL;
strstr : INIT : 			return -EINVAL; : 
strstr : if : 			return -EINVAL; : 
strstr : for : 			return -EINVAL; : 
strstr : while : 			return -EINVAL; : 
str : #endif
strstr : INIT : #endif : 
strstr : if : #endif : 
strstr : for : #endif : 
strstr : while : #endif : 
str : 	}
strstr : INIT : 	} : 
strstr : if : 	} : 
strstr : for : 	} : 
strstr : while : 	} : 
str : 	return 0;
strstr : INIT : 	return 0; : 
strstr : if : 	return 0; : 
strstr : for : 	return 0; : 
strstr : while : 	return 0; : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : static void cpu_cgroup_attach(struct cgroup_subsys_state *css,
strstr : if : static void cpu_cgroup_attach(struct cgroup_subsys_state *css, : 
strstr : for : static void cpu_cgroup_attach(struct cgroup_subsys_state *css, : 
strstr : while : static void cpu_cgroup_attach(struct cgroup_subsys_state *css, : 
str : 			      struct cgroup_taskset *tset)
strstr : INIT : 			      struct cgroup_taskset *tset) : 
strstr : if : 			      struct cgroup_taskset *tset) : 
strstr : for : 			      struct cgroup_taskset *tset) : 
strstr : while : 			      struct cgroup_taskset *tset) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	struct task_struct *task;
strstr : INIT : 	struct task_struct *task; : 
strstr : if : 	struct task_struct *task; : 
strstr : for : 	struct task_struct *task; : 
strstr : while : 	struct task_struct *task; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	cgroup_taskset_for_each(task, css, tset)
strstr : if : 	cgroup_taskset_for_each(task, css, tset) : 
strstr : for : 	cgroup_taskset_for_each(task, css, tset) : 
strstr : while : 	cgroup_taskset_for_each(task, css, tset) : 
str : 		sched_move_task(task);
strstr : INIT : 		sched_move_task(task); : 
strstr : if : 		sched_move_task(task); : 
strstr : for : 		sched_move_task(task); : 
strstr : while : 		sched_move_task(task); : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : static void cpu_cgroup_exit(struct cgroup_subsys_state *css,
strstr : if : static void cpu_cgroup_exit(struct cgroup_subsys_state *css, : 
strstr : for : static void cpu_cgroup_exit(struct cgroup_subsys_state *css, : 
strstr : while : static void cpu_cgroup_exit(struct cgroup_subsys_state *css, : 
str : 			    struct cgroup_subsys_state *old_css,
strstr : INIT : 			    struct cgroup_subsys_state *old_css, : 
strstr : if : 			    struct cgroup_subsys_state *old_css, : 
strstr : for : 			    struct cgroup_subsys_state *old_css, : 
strstr : while : 			    struct cgroup_subsys_state *old_css, : 
str : 			    struct task_struct *task)
strstr : INIT : 			    struct task_struct *task) : 
strstr : if : 			    struct task_struct *task) : 
strstr : for : 			    struct task_struct *task) : 
strstr : while : 			    struct task_struct *task) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	/*
strstr : INIT : 	/* : 
strstr : if : 	/* : 
strstr : for : 	/* : 
strstr : while : 	/* : 
str : 	 * cgroup_exit() is called in the copy_process() failure path.
strstr : INIT : 	 * cgroup_exit() is called in the copy_process() failure path. : 
strstr : if : 	 * cgroup_exit() is called in the copy_process() failure path. : 
strstr : for : 	 * cgroup_exit() is called in the copy_process() failure path. : 
strstr : while : 	 * cgroup_exit() is called in the copy_process() failure path. : 
str : 	 * Ignore this case since the task hasn't ran yet, this avoids
strstr : INIT : 	 * Ignore this case since the task hasn't ran yet, this avoids : 
strstr : if : 	 * Ignore this case since the task hasn't ran yet, this avoids : 
strstr : for : 	 * Ignore this case since the task hasn't ran yet, this avoids : 
strstr : while : 	 * Ignore this case since the task hasn't ran yet, this avoids : 
str : 	 * trying to poke a half freed task state from generic code.
strstr : INIT : 	 * trying to poke a half freed task state from generic code. : 
strstr : if : 	 * trying to poke a half freed task state from generic code. : 
strstr : for : 	 * trying to poke a half freed task state from generic code. : 
strstr : while : 	 * trying to poke a half freed task state from generic code. : 
str : 	 */
strstr : INIT : 	 */ : 
strstr : if : 	 */ : 
strstr : for : 	 */ : 
strstr : while : 	 */ : 
str : 	if (!(task->flags & PF_EXITING))
strstr : INIT : 	if (!(task->flags & PF_EXITING)) : 
strstr : if : 	if (!(task->flags & PF_EXITING)) : 
strstr : for : 	if (!(task->flags & PF_EXITING)) : 
strstr : while : 	if (!(task->flags & PF_EXITING)) : 
str : 		return;
strstr : INIT : 		return; : 
strstr : if : 		return; : 
strstr : for : 		return; : 
strstr : while : 		return; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	sched_move_task(task);
strstr : if : 	sched_move_task(task); : 
strstr : for : 	sched_move_task(task); : 
strstr : while : 	sched_move_task(task); : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : #ifdef CONFIG_FAIR_GROUP_SCHED
strstr : if : #ifdef CONFIG_FAIR_GROUP_SCHED : 
strstr : for : #ifdef CONFIG_FAIR_GROUP_SCHED : 
strstr : while : #ifdef CONFIG_FAIR_GROUP_SCHED : 
str : static int cpu_shares_write_u64(struct cgroup_subsys_state *css,
strstr : INIT : static int cpu_shares_write_u64(struct cgroup_subsys_state *css, : 
strstr : if : static int cpu_shares_write_u64(struct cgroup_subsys_state *css, : 
strstr : for : static int cpu_shares_write_u64(struct cgroup_subsys_state *css, : 
strstr : while : static int cpu_shares_write_u64(struct cgroup_subsys_state *css, : 
str : 				struct cftype *cftype, u64 shareval)
strstr : INIT : 				struct cftype *cftype, u64 shareval) : 
strstr : if : 				struct cftype *cftype, u64 shareval) : 
strstr : for : 				struct cftype *cftype, u64 shareval) : 
strstr : while : 				struct cftype *cftype, u64 shareval) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	return sched_group_set_shares(css_tg(css), scale_load(shareval));
strstr : INIT : 	return sched_group_set_shares(css_tg(css), scale_load(shareval)); : 
strstr : if : 	return sched_group_set_shares(css_tg(css), scale_load(shareval)); : 
strstr : for : 	return sched_group_set_shares(css_tg(css), scale_load(shareval)); : 
strstr : while : 	return sched_group_set_shares(css_tg(css), scale_load(shareval)); : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : static u64 cpu_shares_read_u64(struct cgroup_subsys_state *css,
strstr : if : static u64 cpu_shares_read_u64(struct cgroup_subsys_state *css, : 
strstr : for : static u64 cpu_shares_read_u64(struct cgroup_subsys_state *css, : 
strstr : while : static u64 cpu_shares_read_u64(struct cgroup_subsys_state *css, : 
str : 			       struct cftype *cft)
strstr : INIT : 			       struct cftype *cft) : 
strstr : if : 			       struct cftype *cft) : 
strstr : for : 			       struct cftype *cft) : 
strstr : while : 			       struct cftype *cft) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	struct task_group *tg = css_tg(css);
strstr : INIT : 	struct task_group *tg = css_tg(css); : 
strstr : if : 	struct task_group *tg = css_tg(css); : 
strstr : for : 	struct task_group *tg = css_tg(css); : 
strstr : while : 	struct task_group *tg = css_tg(css); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	return (u64) scale_load_down(tg->shares);
strstr : if : 	return (u64) scale_load_down(tg->shares); : 
strstr : for : 	return (u64) scale_load_down(tg->shares); : 
strstr : while : 	return (u64) scale_load_down(tg->shares); : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : #ifdef CONFIG_CFS_BANDWIDTH
strstr : if : #ifdef CONFIG_CFS_BANDWIDTH : 
strstr : for : #ifdef CONFIG_CFS_BANDWIDTH : 
strstr : while : #ifdef CONFIG_CFS_BANDWIDTH : 
str : static DEFINE_MUTEX(cfs_constraints_mutex);
strstr : INIT : static DEFINE_MUTEX(cfs_constraints_mutex); : 
strstr : if : static DEFINE_MUTEX(cfs_constraints_mutex); : 
strstr : for : static DEFINE_MUTEX(cfs_constraints_mutex); : 
strstr : while : static DEFINE_MUTEX(cfs_constraints_mutex); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : const u64 max_cfs_quota_period = 1 * NSEC_PER_SEC; /* 1s */
strstr : if : const u64 max_cfs_quota_period = 1 * NSEC_PER_SEC; /* 1s */ : 
strstr : for : const u64 max_cfs_quota_period = 1 * NSEC_PER_SEC; /* 1s */ : 
strstr : while : const u64 max_cfs_quota_period = 1 * NSEC_PER_SEC; /* 1s */ : 
str : const u64 min_cfs_quota_period = 1 * NSEC_PER_MSEC; /* 1ms */
strstr : INIT : const u64 min_cfs_quota_period = 1 * NSEC_PER_MSEC; /* 1ms */ : 
strstr : if : const u64 min_cfs_quota_period = 1 * NSEC_PER_MSEC; /* 1ms */ : 
strstr : for : const u64 min_cfs_quota_period = 1 * NSEC_PER_MSEC; /* 1ms */ : 
strstr : while : const u64 min_cfs_quota_period = 1 * NSEC_PER_MSEC; /* 1ms */ : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : static int __cfs_schedulable(struct task_group *tg, u64 period, u64 runtime);
strstr : if : static int __cfs_schedulable(struct task_group *tg, u64 period, u64 runtime); : 
strstr : for : static int __cfs_schedulable(struct task_group *tg, u64 period, u64 runtime); : 
strstr : while : static int __cfs_schedulable(struct task_group *tg, u64 period, u64 runtime); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : static int tg_set_cfs_bandwidth(struct task_group *tg, u64 period, u64 quota)
strstr : if : static int tg_set_cfs_bandwidth(struct task_group *tg, u64 period, u64 quota) : 
strstr : for : static int tg_set_cfs_bandwidth(struct task_group *tg, u64 period, u64 quota) : 
strstr : while : static int tg_set_cfs_bandwidth(struct task_group *tg, u64 period, u64 quota) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	int i, ret = 0, runtime_enabled, runtime_was_enabled;
strstr : INIT : 	int i, ret = 0, runtime_enabled, runtime_was_enabled; : 
strstr : if : 	int i, ret = 0, runtime_enabled, runtime_was_enabled; : 
strstr : for : 	int i, ret = 0, runtime_enabled, runtime_was_enabled; : 
strstr : while : 	int i, ret = 0, runtime_enabled, runtime_was_enabled; : 
str : 	struct cfs_bandwidth *cfs_b = &tg->cfs_bandwidth;
strstr : INIT : 	struct cfs_bandwidth *cfs_b = &tg->cfs_bandwidth; : 
strstr : if : 	struct cfs_bandwidth *cfs_b = &tg->cfs_bandwidth; : 
strstr : for : 	struct cfs_bandwidth *cfs_b = &tg->cfs_bandwidth; : 
strstr : while : 	struct cfs_bandwidth *cfs_b = &tg->cfs_bandwidth; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	if (tg == &root_task_group)
strstr : if : 	if (tg == &root_task_group) : 
strstr : for : 	if (tg == &root_task_group) : 
strstr : while : 	if (tg == &root_task_group) : 
str : 		return -EINVAL;
strstr : INIT : 		return -EINVAL; : 
strstr : if : 		return -EINVAL; : 
strstr : for : 		return -EINVAL; : 
strstr : while : 		return -EINVAL; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	/*
strstr : if : 	/* : 
strstr : for : 	/* : 
strstr : while : 	/* : 
str : 	 * Ensure we have at some amount of bandwidth every period.  This is
strstr : INIT : 	 * Ensure we have at some amount of bandwidth every period.  This is : 
strstr : if : 	 * Ensure we have at some amount of bandwidth every period.  This is : 
strstr : for : 	 * Ensure we have at some amount of bandwidth every period.  This is : 
strstr : while : 	 * Ensure we have at some amount of bandwidth every period.  This is : 
str : 	 * to prevent reaching a state of large arrears when throttled via
strstr : INIT : 	 * to prevent reaching a state of large arrears when throttled via : 
strstr : if : 	 * to prevent reaching a state of large arrears when throttled via : 
strstr : for : 	 * to prevent reaching a state of large arrears when throttled via : 
strstr : while : 	 * to prevent reaching a state of large arrears when throttled via : 
str : 	 * entity_tick() resulting in prolonged exit starvation.
strstr : INIT : 	 * entity_tick() resulting in prolonged exit starvation. : 
strstr : if : 	 * entity_tick() resulting in prolonged exit starvation. : 
strstr : for : 	 * entity_tick() resulting in prolonged exit starvation. : 
strstr : while : 	 * entity_tick() resulting in prolonged exit starvation. : 
str : 	 */
strstr : INIT : 	 */ : 
strstr : if : 	 */ : 
strstr : for : 	 */ : 
strstr : while : 	 */ : 
str : 	if (quota < min_cfs_quota_period || period < min_cfs_quota_period)
strstr : INIT : 	if (quota < min_cfs_quota_period || period < min_cfs_quota_period) : 
strstr : if : 	if (quota < min_cfs_quota_period || period < min_cfs_quota_period) : 
strstr : for : 	if (quota < min_cfs_quota_period || period < min_cfs_quota_period) : 
strstr : while : 	if (quota < min_cfs_quota_period || period < min_cfs_quota_period) : 
str : 		return -EINVAL;
strstr : INIT : 		return -EINVAL; : 
strstr : if : 		return -EINVAL; : 
strstr : for : 		return -EINVAL; : 
strstr : while : 		return -EINVAL; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	/*
strstr : if : 	/* : 
strstr : for : 	/* : 
strstr : while : 	/* : 
str : 	 * Likewise, bound things on the otherside by preventing insane quota
strstr : INIT : 	 * Likewise, bound things on the otherside by preventing insane quota : 
strstr : if : 	 * Likewise, bound things on the otherside by preventing insane quota : 
strstr : for : 	 * Likewise, bound things on the otherside by preventing insane quota : 
strstr : while : 	 * Likewise, bound things on the otherside by preventing insane quota : 
str : 	 * periods.  This also allows us to normalize in computing quota
strstr : INIT : 	 * periods.  This also allows us to normalize in computing quota : 
strstr : if : 	 * periods.  This also allows us to normalize in computing quota : 
strstr : for : 	 * periods.  This also allows us to normalize in computing quota : 
strstr : while : 	 * periods.  This also allows us to normalize in computing quota : 
str : 	 * feasibility.
strstr : INIT : 	 * feasibility. : 
strstr : if : 	 * feasibility. : 
strstr : for : 	 * feasibility. : 
strstr : while : 	 * feasibility. : 
str : 	 */
strstr : INIT : 	 */ : 
strstr : if : 	 */ : 
strstr : for : 	 */ : 
strstr : while : 	 */ : 
str : 	if (period > max_cfs_quota_period)
strstr : INIT : 	if (period > max_cfs_quota_period) : 
strstr : if : 	if (period > max_cfs_quota_period) : 
strstr : for : 	if (period > max_cfs_quota_period) : 
strstr : while : 	if (period > max_cfs_quota_period) : 
str : 		return -EINVAL;
strstr : INIT : 		return -EINVAL; : 
strstr : if : 		return -EINVAL; : 
strstr : for : 		return -EINVAL; : 
strstr : while : 		return -EINVAL; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	mutex_lock(&cfs_constraints_mutex);
strstr : if : 	mutex_lock(&cfs_constraints_mutex); : 
strstr : for : 	mutex_lock(&cfs_constraints_mutex); : 
strstr : while : 	mutex_lock(&cfs_constraints_mutex); : 
str : 	ret = __cfs_schedulable(tg, period, quota);
strstr : INIT : 	ret = __cfs_schedulable(tg, period, quota); : 
strstr : if : 	ret = __cfs_schedulable(tg, period, quota); : 
strstr : for : 	ret = __cfs_schedulable(tg, period, quota); : 
strstr : while : 	ret = __cfs_schedulable(tg, period, quota); : 
str : 	if (ret)
strstr : INIT : 	if (ret) : 
strstr : if : 	if (ret) : 
strstr : for : 	if (ret) : 
strstr : while : 	if (ret) : 
str : 		goto out_unlock;
strstr : INIT : 		goto out_unlock; : 
strstr : if : 		goto out_unlock; : 
strstr : for : 		goto out_unlock; : 
strstr : while : 		goto out_unlock; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	runtime_enabled = quota != RUNTIME_INF;
strstr : if : 	runtime_enabled = quota != RUNTIME_INF; : 
strstr : for : 	runtime_enabled = quota != RUNTIME_INF; : 
strstr : while : 	runtime_enabled = quota != RUNTIME_INF; : 
str : 	runtime_was_enabled = cfs_b->quota != RUNTIME_INF;
strstr : INIT : 	runtime_was_enabled = cfs_b->quota != RUNTIME_INF; : 
strstr : if : 	runtime_was_enabled = cfs_b->quota != RUNTIME_INF; : 
strstr : for : 	runtime_was_enabled = cfs_b->quota != RUNTIME_INF; : 
strstr : while : 	runtime_was_enabled = cfs_b->quota != RUNTIME_INF; : 
str : 	/*
strstr : INIT : 	/* : 
strstr : if : 	/* : 
strstr : for : 	/* : 
strstr : while : 	/* : 
str : 	 * If we need to toggle cfs_bandwidth_used, off->on must occur
strstr : INIT : 	 * If we need to toggle cfs_bandwidth_used, off->on must occur : 
strstr : if : 	 * If we need to toggle cfs_bandwidth_used, off->on must occur : 
strstr : for : 	 * If we need to toggle cfs_bandwidth_used, off->on must occur : 
strstr : while : 	 * If we need to toggle cfs_bandwidth_used, off->on must occur : 
str : 	 * before making related changes, and on->off must occur afterwards
strstr : INIT : 	 * before making related changes, and on->off must occur afterwards : 
strstr : if : 	 * before making related changes, and on->off must occur afterwards : 
strstr : for : 	 * before making related changes, and on->off must occur afterwards : 
strstr : while : 	 * before making related changes, and on->off must occur afterwards : 
str : 	 */
strstr : INIT : 	 */ : 
strstr : if : 	 */ : 
strstr : for : 	 */ : 
strstr : while : 	 */ : 
str : 	if (runtime_enabled && !runtime_was_enabled)
strstr : INIT : 	if (runtime_enabled && !runtime_was_enabled) : 
strstr : if : 	if (runtime_enabled && !runtime_was_enabled) : 
strstr : for : 	if (runtime_enabled && !runtime_was_enabled) : 
strstr : while : 	if (runtime_enabled && !runtime_was_enabled) : 
str : 		cfs_bandwidth_usage_inc();
strstr : INIT : 		cfs_bandwidth_usage_inc(); : 
strstr : if : 		cfs_bandwidth_usage_inc(); : 
strstr : for : 		cfs_bandwidth_usage_inc(); : 
strstr : while : 		cfs_bandwidth_usage_inc(); : 
str : 	raw_spin_lock_irq(&cfs_b->lock);
strstr : INIT : 	raw_spin_lock_irq(&cfs_b->lock); : 
strstr : if : 	raw_spin_lock_irq(&cfs_b->lock); : 
strstr : for : 	raw_spin_lock_irq(&cfs_b->lock); : 
strstr : while : 	raw_spin_lock_irq(&cfs_b->lock); : 
str : 	cfs_b->period = ns_to_ktime(period);
strstr : INIT : 	cfs_b->period = ns_to_ktime(period); : 
strstr : if : 	cfs_b->period = ns_to_ktime(period); : 
strstr : for : 	cfs_b->period = ns_to_ktime(period); : 
strstr : while : 	cfs_b->period = ns_to_ktime(period); : 
str : 	cfs_b->quota = quota;
strstr : INIT : 	cfs_b->quota = quota; : 
strstr : if : 	cfs_b->quota = quota; : 
strstr : for : 	cfs_b->quota = quota; : 
strstr : while : 	cfs_b->quota = quota; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	__refill_cfs_bandwidth_runtime(cfs_b);
strstr : if : 	__refill_cfs_bandwidth_runtime(cfs_b); : 
strstr : for : 	__refill_cfs_bandwidth_runtime(cfs_b); : 
strstr : while : 	__refill_cfs_bandwidth_runtime(cfs_b); : 
str : 	/* restart the period timer (if active) to handle new period expiry */
strstr : INIT : 	/* restart the period timer (if active) to handle new period expiry */ : 
strstr : if : 	/* restart the period timer (if active) to handle new period expiry */ : 
strstr : for : 	/* restart the period timer (if active) to handle new period expiry */ : 
strstr : while : 	/* restart the period timer (if active) to handle new period expiry */ : 
str : 	if (runtime_enabled && cfs_b->timer_active) {
strstr : INIT : 	if (runtime_enabled && cfs_b->timer_active) { : 
strstr : if : 	if (runtime_enabled && cfs_b->timer_active) { : 
strstr : for : 	if (runtime_enabled && cfs_b->timer_active) { : 
strstr : while : 	if (runtime_enabled && cfs_b->timer_active) { : 
str : 		/* force a reprogram */
strstr : INIT : 		/* force a reprogram */ : 
strstr : if : 		/* force a reprogram */ : 
strstr : for : 		/* force a reprogram */ : 
strstr : while : 		/* force a reprogram */ : 
str : 		cfs_b->timer_active = 0;
strstr : INIT : 		cfs_b->timer_active = 0; : 
strstr : if : 		cfs_b->timer_active = 0; : 
strstr : for : 		cfs_b->timer_active = 0; : 
strstr : while : 		cfs_b->timer_active = 0; : 
str : 		__start_cfs_bandwidth(cfs_b);
strstr : INIT : 		__start_cfs_bandwidth(cfs_b); : 
strstr : if : 		__start_cfs_bandwidth(cfs_b); : 
strstr : for : 		__start_cfs_bandwidth(cfs_b); : 
strstr : while : 		__start_cfs_bandwidth(cfs_b); : 
str : 	}
strstr : INIT : 	} : 
strstr : if : 	} : 
strstr : for : 	} : 
strstr : while : 	} : 
str : 	raw_spin_unlock_irq(&cfs_b->lock);
strstr : INIT : 	raw_spin_unlock_irq(&cfs_b->lock); : 
strstr : if : 	raw_spin_unlock_irq(&cfs_b->lock); : 
strstr : for : 	raw_spin_unlock_irq(&cfs_b->lock); : 
strstr : while : 	raw_spin_unlock_irq(&cfs_b->lock); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	for_each_possible_cpu(i) {
strstr : if : 	for_each_possible_cpu(i) { : 
strstr : for : 	for_each_possible_cpu(i) { : 
strstr : while : 	for_each_possible_cpu(i) { : 
str : 		struct cfs_rq *cfs_rq = tg->cfs_rq[i];
strstr : INIT : 		struct cfs_rq *cfs_rq = tg->cfs_rq[i]; : 
strstr : if : 		struct cfs_rq *cfs_rq = tg->cfs_rq[i]; : 
strstr : for : 		struct cfs_rq *cfs_rq = tg->cfs_rq[i]; : 
strstr : while : 		struct cfs_rq *cfs_rq = tg->cfs_rq[i]; : 
str : 		struct rq *rq = cfs_rq->rq;
strstr : INIT : 		struct rq *rq = cfs_rq->rq; : 
strstr : if : 		struct rq *rq = cfs_rq->rq; : 
strstr : for : 		struct rq *rq = cfs_rq->rq; : 
strstr : while : 		struct rq *rq = cfs_rq->rq; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 		raw_spin_lock_irq(&rq->lock);
strstr : if : 		raw_spin_lock_irq(&rq->lock); : 
strstr : for : 		raw_spin_lock_irq(&rq->lock); : 
strstr : while : 		raw_spin_lock_irq(&rq->lock); : 
str : 		cfs_rq->runtime_enabled = runtime_enabled;
strstr : INIT : 		cfs_rq->runtime_enabled = runtime_enabled; : 
strstr : if : 		cfs_rq->runtime_enabled = runtime_enabled; : 
strstr : for : 		cfs_rq->runtime_enabled = runtime_enabled; : 
strstr : while : 		cfs_rq->runtime_enabled = runtime_enabled; : 
str : 		cfs_rq->runtime_remaining = 0;
strstr : INIT : 		cfs_rq->runtime_remaining = 0; : 
strstr : if : 		cfs_rq->runtime_remaining = 0; : 
strstr : for : 		cfs_rq->runtime_remaining = 0; : 
strstr : while : 		cfs_rq->runtime_remaining = 0; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 		if (cfs_rq->throttled)
strstr : if : 		if (cfs_rq->throttled) : 
strstr : for : 		if (cfs_rq->throttled) : 
strstr : while : 		if (cfs_rq->throttled) : 
str : 			unthrottle_cfs_rq(cfs_rq);
strstr : INIT : 			unthrottle_cfs_rq(cfs_rq); : 
strstr : if : 			unthrottle_cfs_rq(cfs_rq); : 
strstr : for : 			unthrottle_cfs_rq(cfs_rq); : 
strstr : while : 			unthrottle_cfs_rq(cfs_rq); : 
str : 		raw_spin_unlock_irq(&rq->lock);
strstr : INIT : 		raw_spin_unlock_irq(&rq->lock); : 
strstr : if : 		raw_spin_unlock_irq(&rq->lock); : 
strstr : for : 		raw_spin_unlock_irq(&rq->lock); : 
strstr : while : 		raw_spin_unlock_irq(&rq->lock); : 
str : 	}
strstr : INIT : 	} : 
strstr : if : 	} : 
strstr : for : 	} : 
strstr : while : 	} : 
str : 	if (runtime_was_enabled && !runtime_enabled)
strstr : INIT : 	if (runtime_was_enabled && !runtime_enabled) : 
strstr : if : 	if (runtime_was_enabled && !runtime_enabled) : 
strstr : for : 	if (runtime_was_enabled && !runtime_enabled) : 
strstr : while : 	if (runtime_was_enabled && !runtime_enabled) : 
str : 		cfs_bandwidth_usage_dec();
strstr : INIT : 		cfs_bandwidth_usage_dec(); : 
strstr : if : 		cfs_bandwidth_usage_dec(); : 
strstr : for : 		cfs_bandwidth_usage_dec(); : 
strstr : while : 		cfs_bandwidth_usage_dec(); : 
str : out_unlock:
strstr : INIT : out_unlock: : 
strstr : if : out_unlock: : 
strstr : for : out_unlock: : 
strstr : while : out_unlock: : 
str : 	mutex_unlock(&cfs_constraints_mutex);
strstr : INIT : 	mutex_unlock(&cfs_constraints_mutex); : 
strstr : if : 	mutex_unlock(&cfs_constraints_mutex); : 
strstr : for : 	mutex_unlock(&cfs_constraints_mutex); : 
strstr : while : 	mutex_unlock(&cfs_constraints_mutex); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	return ret;
strstr : if : 	return ret; : 
strstr : for : 	return ret; : 
strstr : while : 	return ret; : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : int tg_set_cfs_quota(struct task_group *tg, long cfs_quota_us)
strstr : if : int tg_set_cfs_quota(struct task_group *tg, long cfs_quota_us) : 
strstr : for : int tg_set_cfs_quota(struct task_group *tg, long cfs_quota_us) : 
strstr : while : int tg_set_cfs_quota(struct task_group *tg, long cfs_quota_us) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	u64 quota, period;
strstr : INIT : 	u64 quota, period; : 
strstr : if : 	u64 quota, period; : 
strstr : for : 	u64 quota, period; : 
strstr : while : 	u64 quota, period; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	period = ktime_to_ns(tg->cfs_bandwidth.period);
strstr : if : 	period = ktime_to_ns(tg->cfs_bandwidth.period); : 
strstr : for : 	period = ktime_to_ns(tg->cfs_bandwidth.period); : 
strstr : while : 	period = ktime_to_ns(tg->cfs_bandwidth.period); : 
str : 	if (cfs_quota_us < 0)
strstr : INIT : 	if (cfs_quota_us < 0) : 
strstr : if : 	if (cfs_quota_us < 0) : 
strstr : for : 	if (cfs_quota_us < 0) : 
strstr : while : 	if (cfs_quota_us < 0) : 
str : 		quota = RUNTIME_INF;
strstr : INIT : 		quota = RUNTIME_INF; : 
strstr : if : 		quota = RUNTIME_INF; : 
strstr : for : 		quota = RUNTIME_INF; : 
strstr : while : 		quota = RUNTIME_INF; : 
str : 	else
strstr : INIT : 	else : 
strstr : if : 	else : 
strstr : for : 	else : 
strstr : while : 	else : 
str : 		quota = (u64)cfs_quota_us * NSEC_PER_USEC;
strstr : INIT : 		quota = (u64)cfs_quota_us * NSEC_PER_USEC; : 
strstr : if : 		quota = (u64)cfs_quota_us * NSEC_PER_USEC; : 
strstr : for : 		quota = (u64)cfs_quota_us * NSEC_PER_USEC; : 
strstr : while : 		quota = (u64)cfs_quota_us * NSEC_PER_USEC; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	return tg_set_cfs_bandwidth(tg, period, quota);
strstr : if : 	return tg_set_cfs_bandwidth(tg, period, quota); : 
strstr : for : 	return tg_set_cfs_bandwidth(tg, period, quota); : 
strstr : while : 	return tg_set_cfs_bandwidth(tg, period, quota); : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : long tg_get_cfs_quota(struct task_group *tg)
strstr : if : long tg_get_cfs_quota(struct task_group *tg) : 
strstr : for : long tg_get_cfs_quota(struct task_group *tg) : 
strstr : while : long tg_get_cfs_quota(struct task_group *tg) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	u64 quota_us;
strstr : INIT : 	u64 quota_us; : 
strstr : if : 	u64 quota_us; : 
strstr : for : 	u64 quota_us; : 
strstr : while : 	u64 quota_us; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	if (tg->cfs_bandwidth.quota == RUNTIME_INF)
strstr : if : 	if (tg->cfs_bandwidth.quota == RUNTIME_INF) : 
strstr : for : 	if (tg->cfs_bandwidth.quota == RUNTIME_INF) : 
strstr : while : 	if (tg->cfs_bandwidth.quota == RUNTIME_INF) : 
str : 		return -1;
strstr : INIT : 		return -1; : 
strstr : if : 		return -1; : 
strstr : for : 		return -1; : 
strstr : while : 		return -1; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	quota_us = tg->cfs_bandwidth.quota;
strstr : if : 	quota_us = tg->cfs_bandwidth.quota; : 
strstr : for : 	quota_us = tg->cfs_bandwidth.quota; : 
strstr : while : 	quota_us = tg->cfs_bandwidth.quota; : 
str : 	do_div(quota_us, NSEC_PER_USEC);
strstr : INIT : 	do_div(quota_us, NSEC_PER_USEC); : 
strstr : if : 	do_div(quota_us, NSEC_PER_USEC); : 
strstr : for : 	do_div(quota_us, NSEC_PER_USEC); : 
strstr : while : 	do_div(quota_us, NSEC_PER_USEC); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	return quota_us;
strstr : if : 	return quota_us; : 
strstr : for : 	return quota_us; : 
strstr : while : 	return quota_us; : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : int tg_set_cfs_period(struct task_group *tg, long cfs_period_us)
strstr : if : int tg_set_cfs_period(struct task_group *tg, long cfs_period_us) : 
strstr : for : int tg_set_cfs_period(struct task_group *tg, long cfs_period_us) : 
strstr : while : int tg_set_cfs_period(struct task_group *tg, long cfs_period_us) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	u64 quota, period;
strstr : INIT : 	u64 quota, period; : 
strstr : if : 	u64 quota, period; : 
strstr : for : 	u64 quota, period; : 
strstr : while : 	u64 quota, period; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	period = (u64)cfs_period_us * NSEC_PER_USEC;
strstr : if : 	period = (u64)cfs_period_us * NSEC_PER_USEC; : 
strstr : for : 	period = (u64)cfs_period_us * NSEC_PER_USEC; : 
strstr : while : 	period = (u64)cfs_period_us * NSEC_PER_USEC; : 
str : 	quota = tg->cfs_bandwidth.quota;
strstr : INIT : 	quota = tg->cfs_bandwidth.quota; : 
strstr : if : 	quota = tg->cfs_bandwidth.quota; : 
strstr : for : 	quota = tg->cfs_bandwidth.quota; : 
strstr : while : 	quota = tg->cfs_bandwidth.quota; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	return tg_set_cfs_bandwidth(tg, period, quota);
strstr : if : 	return tg_set_cfs_bandwidth(tg, period, quota); : 
strstr : for : 	return tg_set_cfs_bandwidth(tg, period, quota); : 
strstr : while : 	return tg_set_cfs_bandwidth(tg, period, quota); : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : long tg_get_cfs_period(struct task_group *tg)
strstr : if : long tg_get_cfs_period(struct task_group *tg) : 
strstr : for : long tg_get_cfs_period(struct task_group *tg) : 
strstr : while : long tg_get_cfs_period(struct task_group *tg) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	u64 cfs_period_us;
strstr : INIT : 	u64 cfs_period_us; : 
strstr : if : 	u64 cfs_period_us; : 
strstr : for : 	u64 cfs_period_us; : 
strstr : while : 	u64 cfs_period_us; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	cfs_period_us = ktime_to_ns(tg->cfs_bandwidth.period);
strstr : if : 	cfs_period_us = ktime_to_ns(tg->cfs_bandwidth.period); : 
strstr : for : 	cfs_period_us = ktime_to_ns(tg->cfs_bandwidth.period); : 
strstr : while : 	cfs_period_us = ktime_to_ns(tg->cfs_bandwidth.period); : 
str : 	do_div(cfs_period_us, NSEC_PER_USEC);
strstr : INIT : 	do_div(cfs_period_us, NSEC_PER_USEC); : 
strstr : if : 	do_div(cfs_period_us, NSEC_PER_USEC); : 
strstr : for : 	do_div(cfs_period_us, NSEC_PER_USEC); : 
strstr : while : 	do_div(cfs_period_us, NSEC_PER_USEC); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	return cfs_period_us;
strstr : if : 	return cfs_period_us; : 
strstr : for : 	return cfs_period_us; : 
strstr : while : 	return cfs_period_us; : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : static s64 cpu_cfs_quota_read_s64(struct cgroup_subsys_state *css,
strstr : if : static s64 cpu_cfs_quota_read_s64(struct cgroup_subsys_state *css, : 
strstr : for : static s64 cpu_cfs_quota_read_s64(struct cgroup_subsys_state *css, : 
strstr : while : static s64 cpu_cfs_quota_read_s64(struct cgroup_subsys_state *css, : 
str : 				  struct cftype *cft)
strstr : INIT : 				  struct cftype *cft) : 
strstr : if : 				  struct cftype *cft) : 
strstr : for : 				  struct cftype *cft) : 
strstr : while : 				  struct cftype *cft) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	return tg_get_cfs_quota(css_tg(css));
strstr : INIT : 	return tg_get_cfs_quota(css_tg(css)); : 
strstr : if : 	return tg_get_cfs_quota(css_tg(css)); : 
strstr : for : 	return tg_get_cfs_quota(css_tg(css)); : 
strstr : while : 	return tg_get_cfs_quota(css_tg(css)); : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : static int cpu_cfs_quota_write_s64(struct cgroup_subsys_state *css,
strstr : if : static int cpu_cfs_quota_write_s64(struct cgroup_subsys_state *css, : 
strstr : for : static int cpu_cfs_quota_write_s64(struct cgroup_subsys_state *css, : 
strstr : while : static int cpu_cfs_quota_write_s64(struct cgroup_subsys_state *css, : 
str : 				   struct cftype *cftype, s64 cfs_quota_us)
strstr : INIT : 				   struct cftype *cftype, s64 cfs_quota_us) : 
strstr : if : 				   struct cftype *cftype, s64 cfs_quota_us) : 
strstr : for : 				   struct cftype *cftype, s64 cfs_quota_us) : 
strstr : while : 				   struct cftype *cftype, s64 cfs_quota_us) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	return tg_set_cfs_quota(css_tg(css), cfs_quota_us);
strstr : INIT : 	return tg_set_cfs_quota(css_tg(css), cfs_quota_us); : 
strstr : if : 	return tg_set_cfs_quota(css_tg(css), cfs_quota_us); : 
strstr : for : 	return tg_set_cfs_quota(css_tg(css), cfs_quota_us); : 
strstr : while : 	return tg_set_cfs_quota(css_tg(css), cfs_quota_us); : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : static u64 cpu_cfs_period_read_u64(struct cgroup_subsys_state *css,
strstr : if : static u64 cpu_cfs_period_read_u64(struct cgroup_subsys_state *css, : 
strstr : for : static u64 cpu_cfs_period_read_u64(struct cgroup_subsys_state *css, : 
strstr : while : static u64 cpu_cfs_period_read_u64(struct cgroup_subsys_state *css, : 
str : 				   struct cftype *cft)
strstr : INIT : 				   struct cftype *cft) : 
strstr : if : 				   struct cftype *cft) : 
strstr : for : 				   struct cftype *cft) : 
strstr : while : 				   struct cftype *cft) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	return tg_get_cfs_period(css_tg(css));
strstr : INIT : 	return tg_get_cfs_period(css_tg(css)); : 
strstr : if : 	return tg_get_cfs_period(css_tg(css)); : 
strstr : for : 	return tg_get_cfs_period(css_tg(css)); : 
strstr : while : 	return tg_get_cfs_period(css_tg(css)); : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : static int cpu_cfs_period_write_u64(struct cgroup_subsys_state *css,
strstr : if : static int cpu_cfs_period_write_u64(struct cgroup_subsys_state *css, : 
strstr : for : static int cpu_cfs_period_write_u64(struct cgroup_subsys_state *css, : 
strstr : while : static int cpu_cfs_period_write_u64(struct cgroup_subsys_state *css, : 
str : 				    struct cftype *cftype, u64 cfs_period_us)
strstr : INIT : 				    struct cftype *cftype, u64 cfs_period_us) : 
strstr : if : 				    struct cftype *cftype, u64 cfs_period_us) : 
strstr : for : 				    struct cftype *cftype, u64 cfs_period_us) : 
strstr : while : 				    struct cftype *cftype, u64 cfs_period_us) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	return tg_set_cfs_period(css_tg(css), cfs_period_us);
strstr : INIT : 	return tg_set_cfs_period(css_tg(css), cfs_period_us); : 
strstr : if : 	return tg_set_cfs_period(css_tg(css), cfs_period_us); : 
strstr : for : 	return tg_set_cfs_period(css_tg(css), cfs_period_us); : 
strstr : while : 	return tg_set_cfs_period(css_tg(css), cfs_period_us); : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : struct cfs_schedulable_data {
strstr : if : struct cfs_schedulable_data { : 
strstr : for : struct cfs_schedulable_data { : 
strstr : while : struct cfs_schedulable_data { : 
str : 	struct task_group *tg;
strstr : INIT : 	struct task_group *tg; : 
strstr : if : 	struct task_group *tg; : 
strstr : for : 	struct task_group *tg; : 
strstr : while : 	struct task_group *tg; : 
str : 	u64 period, quota;
strstr : INIT : 	u64 period, quota; : 
strstr : if : 	u64 period, quota; : 
strstr : for : 	u64 period, quota; : 
strstr : while : 	u64 period, quota; : 
str : };
strstr : INIT : }; : 
strstr : if : }; : 
strstr : for : }; : 
strstr : while : }; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : /*
strstr : if : /* : 
strstr : for : /* : 
strstr : while : /* : 
str :  * normalize group quota/period to be quota/max_period
strstr : INIT :  * normalize group quota/period to be quota/max_period : 
strstr : if :  * normalize group quota/period to be quota/max_period : 
strstr : for :  * normalize group quota/period to be quota/max_period : 
strstr : while :  * normalize group quota/period to be quota/max_period : 
str :  * note: units are usecs
strstr : INIT :  * note: units are usecs : 
strstr : if :  * note: units are usecs : 
strstr : for :  * note: units are usecs : 
strstr : while :  * note: units are usecs : 
str :  */
strstr : INIT :  */ : 
strstr : if :  */ : 
strstr : for :  */ : 
strstr : while :  */ : 
str : static u64 normalize_cfs_quota(struct task_group *tg,
strstr : INIT : static u64 normalize_cfs_quota(struct task_group *tg, : 
strstr : if : static u64 normalize_cfs_quota(struct task_group *tg, : 
strstr : for : static u64 normalize_cfs_quota(struct task_group *tg, : 
strstr : while : static u64 normalize_cfs_quota(struct task_group *tg, : 
str : 			       struct cfs_schedulable_data *d)
strstr : INIT : 			       struct cfs_schedulable_data *d) : 
strstr : if : 			       struct cfs_schedulable_data *d) : 
strstr : for : 			       struct cfs_schedulable_data *d) : 
strstr : while : 			       struct cfs_schedulable_data *d) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	u64 quota, period;
strstr : INIT : 	u64 quota, period; : 
strstr : if : 	u64 quota, period; : 
strstr : for : 	u64 quota, period; : 
strstr : while : 	u64 quota, period; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	if (tg == d->tg) {
strstr : if : 	if (tg == d->tg) { : 
strstr : for : 	if (tg == d->tg) { : 
strstr : while : 	if (tg == d->tg) { : 
str : 		period = d->period;
strstr : INIT : 		period = d->period; : 
strstr : if : 		period = d->period; : 
strstr : for : 		period = d->period; : 
strstr : while : 		period = d->period; : 
str : 		quota = d->quota;
strstr : INIT : 		quota = d->quota; : 
strstr : if : 		quota = d->quota; : 
strstr : for : 		quota = d->quota; : 
strstr : while : 		quota = d->quota; : 
str : 	} else {
strstr : INIT : 	} else { : 
strstr : if : 	} else { : 
strstr : for : 	} else { : 
strstr : while : 	} else { : 
str : 		period = tg_get_cfs_period(tg);
strstr : INIT : 		period = tg_get_cfs_period(tg); : 
strstr : if : 		period = tg_get_cfs_period(tg); : 
strstr : for : 		period = tg_get_cfs_period(tg); : 
strstr : while : 		period = tg_get_cfs_period(tg); : 
str : 		quota = tg_get_cfs_quota(tg);
strstr : INIT : 		quota = tg_get_cfs_quota(tg); : 
strstr : if : 		quota = tg_get_cfs_quota(tg); : 
strstr : for : 		quota = tg_get_cfs_quota(tg); : 
strstr : while : 		quota = tg_get_cfs_quota(tg); : 
str : 	}
strstr : INIT : 	} : 
strstr : if : 	} : 
strstr : for : 	} : 
strstr : while : 	} : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	/* note: these should typically be equivalent */
strstr : if : 	/* note: these should typically be equivalent */ : 
strstr : for : 	/* note: these should typically be equivalent */ : 
strstr : while : 	/* note: these should typically be equivalent */ : 
str : 	if (quota == RUNTIME_INF || quota == -1)
strstr : INIT : 	if (quota == RUNTIME_INF || quota == -1) : 
strstr : if : 	if (quota == RUNTIME_INF || quota == -1) : 
strstr : for : 	if (quota == RUNTIME_INF || quota == -1) : 
strstr : while : 	if (quota == RUNTIME_INF || quota == -1) : 
str : 		return RUNTIME_INF;
strstr : INIT : 		return RUNTIME_INF; : 
strstr : if : 		return RUNTIME_INF; : 
strstr : for : 		return RUNTIME_INF; : 
strstr : while : 		return RUNTIME_INF; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	return to_ratio(period, quota);
strstr : if : 	return to_ratio(period, quota); : 
strstr : for : 	return to_ratio(period, quota); : 
strstr : while : 	return to_ratio(period, quota); : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : static int tg_cfs_schedulable_down(struct task_group *tg, void *data)
strstr : if : static int tg_cfs_schedulable_down(struct task_group *tg, void *data) : 
strstr : for : static int tg_cfs_schedulable_down(struct task_group *tg, void *data) : 
strstr : while : static int tg_cfs_schedulable_down(struct task_group *tg, void *data) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	struct cfs_schedulable_data *d = data;
strstr : INIT : 	struct cfs_schedulable_data *d = data; : 
strstr : if : 	struct cfs_schedulable_data *d = data; : 
strstr : for : 	struct cfs_schedulable_data *d = data; : 
strstr : while : 	struct cfs_schedulable_data *d = data; : 
str : 	struct cfs_bandwidth *cfs_b = &tg->cfs_bandwidth;
strstr : INIT : 	struct cfs_bandwidth *cfs_b = &tg->cfs_bandwidth; : 
strstr : if : 	struct cfs_bandwidth *cfs_b = &tg->cfs_bandwidth; : 
strstr : for : 	struct cfs_bandwidth *cfs_b = &tg->cfs_bandwidth; : 
strstr : while : 	struct cfs_bandwidth *cfs_b = &tg->cfs_bandwidth; : 
str : 	s64 quota = 0, parent_quota = -1;
strstr : INIT : 	s64 quota = 0, parent_quota = -1; : 
strstr : if : 	s64 quota = 0, parent_quota = -1; : 
strstr : for : 	s64 quota = 0, parent_quota = -1; : 
strstr : while : 	s64 quota = 0, parent_quota = -1; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	if (!tg->parent) {
strstr : if : 	if (!tg->parent) { : 
strstr : for : 	if (!tg->parent) { : 
strstr : while : 	if (!tg->parent) { : 
str : 		quota = RUNTIME_INF;
strstr : INIT : 		quota = RUNTIME_INF; : 
strstr : if : 		quota = RUNTIME_INF; : 
strstr : for : 		quota = RUNTIME_INF; : 
strstr : while : 		quota = RUNTIME_INF; : 
str : 	} else {
strstr : INIT : 	} else { : 
strstr : if : 	} else { : 
strstr : for : 	} else { : 
strstr : while : 	} else { : 
str : 		struct cfs_bandwidth *parent_b = &tg->parent->cfs_bandwidth;
strstr : INIT : 		struct cfs_bandwidth *parent_b = &tg->parent->cfs_bandwidth; : 
strstr : if : 		struct cfs_bandwidth *parent_b = &tg->parent->cfs_bandwidth; : 
strstr : for : 		struct cfs_bandwidth *parent_b = &tg->parent->cfs_bandwidth; : 
strstr : while : 		struct cfs_bandwidth *parent_b = &tg->parent->cfs_bandwidth; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 		quota = normalize_cfs_quota(tg, d);
strstr : if : 		quota = normalize_cfs_quota(tg, d); : 
strstr : for : 		quota = normalize_cfs_quota(tg, d); : 
strstr : while : 		quota = normalize_cfs_quota(tg, d); : 
str : 		parent_quota = parent_b->hierarchal_quota;
strstr : INIT : 		parent_quota = parent_b->hierarchal_quota; : 
strstr : if : 		parent_quota = parent_b->hierarchal_quota; : 
strstr : for : 		parent_quota = parent_b->hierarchal_quota; : 
strstr : while : 		parent_quota = parent_b->hierarchal_quota; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 		/*
strstr : if : 		/* : 
strstr : for : 		/* : 
strstr : while : 		/* : 
str : 		 * ensure max(child_quota) <= parent_quota, inherit when no
strstr : INIT : 		 * ensure max(child_quota) <= parent_quota, inherit when no : 
strstr : if : 		 * ensure max(child_quota) <= parent_quota, inherit when no : 
strstr : for : 		 * ensure max(child_quota) <= parent_quota, inherit when no : 
strstr : while : 		 * ensure max(child_quota) <= parent_quota, inherit when no : 
str : 		 * limit is set
strstr : INIT : 		 * limit is set : 
strstr : if : 		 * limit is set : 
strstr : for : 		 * limit is set : 
strstr : while : 		 * limit is set : 
str : 		 */
strstr : INIT : 		 */ : 
strstr : if : 		 */ : 
strstr : for : 		 */ : 
strstr : while : 		 */ : 
str : 		if (quota == RUNTIME_INF)
strstr : INIT : 		if (quota == RUNTIME_INF) : 
strstr : if : 		if (quota == RUNTIME_INF) : 
strstr : for : 		if (quota == RUNTIME_INF) : 
strstr : while : 		if (quota == RUNTIME_INF) : 
str : 			quota = parent_quota;
strstr : INIT : 			quota = parent_quota; : 
strstr : if : 			quota = parent_quota; : 
strstr : for : 			quota = parent_quota; : 
strstr : while : 			quota = parent_quota; : 
str : 		else if (parent_quota != RUNTIME_INF && quota > parent_quota)
strstr : INIT : 		else if (parent_quota != RUNTIME_INF && quota > parent_quota) : 
strstr : if : 		else if (parent_quota != RUNTIME_INF && quota > parent_quota) : 
strstr : for : 		else if (parent_quota != RUNTIME_INF && quota > parent_quota) : 
strstr : while : 		else if (parent_quota != RUNTIME_INF && quota > parent_quota) : 
str : 			return -EINVAL;
strstr : INIT : 			return -EINVAL; : 
strstr : if : 			return -EINVAL; : 
strstr : for : 			return -EINVAL; : 
strstr : while : 			return -EINVAL; : 
str : 	}
strstr : INIT : 	} : 
strstr : if : 	} : 
strstr : for : 	} : 
strstr : while : 	} : 
str : 	cfs_b->hierarchal_quota = quota;
strstr : INIT : 	cfs_b->hierarchal_quota = quota; : 
strstr : if : 	cfs_b->hierarchal_quota = quota; : 
strstr : for : 	cfs_b->hierarchal_quota = quota; : 
strstr : while : 	cfs_b->hierarchal_quota = quota; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	return 0;
strstr : if : 	return 0; : 
strstr : for : 	return 0; : 
strstr : while : 	return 0; : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : static int __cfs_schedulable(struct task_group *tg, u64 period, u64 quota)
strstr : if : static int __cfs_schedulable(struct task_group *tg, u64 period, u64 quota) : 
strstr : for : static int __cfs_schedulable(struct task_group *tg, u64 period, u64 quota) : 
strstr : while : static int __cfs_schedulable(struct task_group *tg, u64 period, u64 quota) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	int ret;
strstr : INIT : 	int ret; : 
strstr : if : 	int ret; : 
strstr : for : 	int ret; : 
strstr : while : 	int ret; : 
str : 	struct cfs_schedulable_data data = {
strstr : INIT : 	struct cfs_schedulable_data data = { : 
strstr : if : 	struct cfs_schedulable_data data = { : 
strstr : for : 	struct cfs_schedulable_data data = { : 
strstr : while : 	struct cfs_schedulable_data data = { : 
str : 		.tg = tg,
strstr : INIT : 		.tg = tg, : 
strstr : if : 		.tg = tg, : 
strstr : for : 		.tg = tg, : 
strstr : while : 		.tg = tg, : 
str : 		.period = period,
strstr : INIT : 		.period = period, : 
strstr : if : 		.period = period, : 
strstr : for : 		.period = period, : 
strstr : while : 		.period = period, : 
str : 		.quota = quota,
strstr : INIT : 		.quota = quota, : 
strstr : if : 		.quota = quota, : 
strstr : for : 		.quota = quota, : 
strstr : while : 		.quota = quota, : 
str : 	};
strstr : INIT : 	}; : 
strstr : if : 	}; : 
strstr : for : 	}; : 
strstr : while : 	}; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	if (quota != RUNTIME_INF) {
strstr : if : 	if (quota != RUNTIME_INF) { : 
strstr : for : 	if (quota != RUNTIME_INF) { : 
strstr : while : 	if (quota != RUNTIME_INF) { : 
str : 		do_div(data.period, NSEC_PER_USEC);
strstr : INIT : 		do_div(data.period, NSEC_PER_USEC); : 
strstr : if : 		do_div(data.period, NSEC_PER_USEC); : 
strstr : for : 		do_div(data.period, NSEC_PER_USEC); : 
strstr : while : 		do_div(data.period, NSEC_PER_USEC); : 
str : 		do_div(data.quota, NSEC_PER_USEC);
strstr : INIT : 		do_div(data.quota, NSEC_PER_USEC); : 
strstr : if : 		do_div(data.quota, NSEC_PER_USEC); : 
strstr : for : 		do_div(data.quota, NSEC_PER_USEC); : 
strstr : while : 		do_div(data.quota, NSEC_PER_USEC); : 
str : 	}
strstr : INIT : 	} : 
strstr : if : 	} : 
strstr : for : 	} : 
strstr : while : 	} : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	rcu_read_lock();
strstr : if : 	rcu_read_lock(); : 
strstr : for : 	rcu_read_lock(); : 
strstr : while : 	rcu_read_lock(); : 
str : 	ret = walk_tg_tree(tg_cfs_schedulable_down, tg_nop, &data);
strstr : INIT : 	ret = walk_tg_tree(tg_cfs_schedulable_down, tg_nop, &data); : 
strstr : if : 	ret = walk_tg_tree(tg_cfs_schedulable_down, tg_nop, &data); : 
strstr : for : 	ret = walk_tg_tree(tg_cfs_schedulable_down, tg_nop, &data); : 
strstr : while : 	ret = walk_tg_tree(tg_cfs_schedulable_down, tg_nop, &data); : 
str : 	rcu_read_unlock();
strstr : INIT : 	rcu_read_unlock(); : 
strstr : if : 	rcu_read_unlock(); : 
strstr : for : 	rcu_read_unlock(); : 
strstr : while : 	rcu_read_unlock(); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	return ret;
strstr : if : 	return ret; : 
strstr : for : 	return ret; : 
strstr : while : 	return ret; : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : static int cpu_stats_show(struct seq_file *sf, void *v)
strstr : if : static int cpu_stats_show(struct seq_file *sf, void *v) : 
strstr : for : static int cpu_stats_show(struct seq_file *sf, void *v) : 
strstr : while : static int cpu_stats_show(struct seq_file *sf, void *v) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	struct task_group *tg = css_tg(seq_css(sf));
strstr : INIT : 	struct task_group *tg = css_tg(seq_css(sf)); : 
strstr : if : 	struct task_group *tg = css_tg(seq_css(sf)); : 
strstr : for : 	struct task_group *tg = css_tg(seq_css(sf)); : 
strstr : while : 	struct task_group *tg = css_tg(seq_css(sf)); : 
str : 	struct cfs_bandwidth *cfs_b = &tg->cfs_bandwidth;
strstr : INIT : 	struct cfs_bandwidth *cfs_b = &tg->cfs_bandwidth; : 
strstr : if : 	struct cfs_bandwidth *cfs_b = &tg->cfs_bandwidth; : 
strstr : for : 	struct cfs_bandwidth *cfs_b = &tg->cfs_bandwidth; : 
strstr : while : 	struct cfs_bandwidth *cfs_b = &tg->cfs_bandwidth; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	seq_printf(sf, "nr_periods %d\n", cfs_b->nr_periods);
strstr : if : 	seq_printf(sf, "nr_periods %d\n", cfs_b->nr_periods); : 
strstr : for : 	seq_printf(sf, "nr_periods %d\n", cfs_b->nr_periods); : 
strstr : while : 	seq_printf(sf, "nr_periods %d\n", cfs_b->nr_periods); : 
str : 	seq_printf(sf, "nr_throttled %d\n", cfs_b->nr_throttled);
strstr : INIT : 	seq_printf(sf, "nr_throttled %d\n", cfs_b->nr_throttled); : 
strstr : if : 	seq_printf(sf, "nr_throttled %d\n", cfs_b->nr_throttled); : 
strstr : for : 	seq_printf(sf, "nr_throttled %d\n", cfs_b->nr_throttled); : 
strstr : while : 	seq_printf(sf, "nr_throttled %d\n", cfs_b->nr_throttled); : 
str : 	seq_printf(sf, "throttled_time %llu\n", cfs_b->throttled_time);
strstr : INIT : 	seq_printf(sf, "throttled_time %llu\n", cfs_b->throttled_time); : 
strstr : if : 	seq_printf(sf, "throttled_time %llu\n", cfs_b->throttled_time); : 
strstr : for : 	seq_printf(sf, "throttled_time %llu\n", cfs_b->throttled_time); : 
strstr : while : 	seq_printf(sf, "throttled_time %llu\n", cfs_b->throttled_time); : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : 	return 0;
strstr : if : 	return 0; : 
strstr : for : 	return 0; : 
strstr : while : 	return 0; : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : #endif /* CONFIG_CFS_BANDWIDTH */
strstr : INIT : #endif /* CONFIG_CFS_BANDWIDTH */ : 
strstr : if : #endif /* CONFIG_CFS_BANDWIDTH */ : 
strstr : for : #endif /* CONFIG_CFS_BANDWIDTH */ : 
strstr : while : #endif /* CONFIG_CFS_BANDWIDTH */ : 
str : #endif /* CONFIG_FAIR_GROUP_SCHED */
strstr : INIT : #endif /* CONFIG_FAIR_GROUP_SCHED */ : 
strstr : if : #endif /* CONFIG_FAIR_GROUP_SCHED */ : 
strstr : for : #endif /* CONFIG_FAIR_GROUP_SCHED */ : 
strstr : while : #endif /* CONFIG_FAIR_GROUP_SCHED */ : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : #ifdef CONFIG_RT_GROUP_SCHED
strstr : if : #ifdef CONFIG_RT_GROUP_SCHED : 
strstr : for : #ifdef CONFIG_RT_GROUP_SCHED : 
strstr : while : #ifdef CONFIG_RT_GROUP_SCHED : 
str : static int cpu_rt_runtime_write(struct cgroup_subsys_state *css,
strstr : INIT : static int cpu_rt_runtime_write(struct cgroup_subsys_state *css, : 
strstr : if : static int cpu_rt_runtime_write(struct cgroup_subsys_state *css, : 
strstr : for : static int cpu_rt_runtime_write(struct cgroup_subsys_state *css, : 
strstr : while : static int cpu_rt_runtime_write(struct cgroup_subsys_state *css, : 
str : 				struct cftype *cft, s64 val)
strstr : INIT : 				struct cftype *cft, s64 val) : 
strstr : if : 				struct cftype *cft, s64 val) : 
strstr : for : 				struct cftype *cft, s64 val) : 
strstr : while : 				struct cftype *cft, s64 val) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	return sched_group_set_rt_runtime(css_tg(css), val);
strstr : INIT : 	return sched_group_set_rt_runtime(css_tg(css), val); : 
strstr : if : 	return sched_group_set_rt_runtime(css_tg(css), val); : 
strstr : for : 	return sched_group_set_rt_runtime(css_tg(css), val); : 
strstr : while : 	return sched_group_set_rt_runtime(css_tg(css), val); : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : static s64 cpu_rt_runtime_read(struct cgroup_subsys_state *css,
strstr : if : static s64 cpu_rt_runtime_read(struct cgroup_subsys_state *css, : 
strstr : for : static s64 cpu_rt_runtime_read(struct cgroup_subsys_state *css, : 
strstr : while : static s64 cpu_rt_runtime_read(struct cgroup_subsys_state *css, : 
str : 			       struct cftype *cft)
strstr : INIT : 			       struct cftype *cft) : 
strstr : if : 			       struct cftype *cft) : 
strstr : for : 			       struct cftype *cft) : 
strstr : while : 			       struct cftype *cft) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	return sched_group_rt_runtime(css_tg(css));
strstr : INIT : 	return sched_group_rt_runtime(css_tg(css)); : 
strstr : if : 	return sched_group_rt_runtime(css_tg(css)); : 
strstr : for : 	return sched_group_rt_runtime(css_tg(css)); : 
strstr : while : 	return sched_group_rt_runtime(css_tg(css)); : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : static int cpu_rt_period_write_uint(struct cgroup_subsys_state *css,
strstr : if : static int cpu_rt_period_write_uint(struct cgroup_subsys_state *css, : 
strstr : for : static int cpu_rt_period_write_uint(struct cgroup_subsys_state *css, : 
strstr : while : static int cpu_rt_period_write_uint(struct cgroup_subsys_state *css, : 
str : 				    struct cftype *cftype, u64 rt_period_us)
strstr : INIT : 				    struct cftype *cftype, u64 rt_period_us) : 
strstr : if : 				    struct cftype *cftype, u64 rt_period_us) : 
strstr : for : 				    struct cftype *cftype, u64 rt_period_us) : 
strstr : while : 				    struct cftype *cftype, u64 rt_period_us) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	return sched_group_set_rt_period(css_tg(css), rt_period_us);
strstr : INIT : 	return sched_group_set_rt_period(css_tg(css), rt_period_us); : 
strstr : if : 	return sched_group_set_rt_period(css_tg(css), rt_period_us); : 
strstr : for : 	return sched_group_set_rt_period(css_tg(css), rt_period_us); : 
strstr : while : 	return sched_group_set_rt_period(css_tg(css), rt_period_us); : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : static u64 cpu_rt_period_read_uint(struct cgroup_subsys_state *css,
strstr : if : static u64 cpu_rt_period_read_uint(struct cgroup_subsys_state *css, : 
strstr : for : static u64 cpu_rt_period_read_uint(struct cgroup_subsys_state *css, : 
strstr : while : static u64 cpu_rt_period_read_uint(struct cgroup_subsys_state *css, : 
str : 				   struct cftype *cft)
strstr : INIT : 				   struct cftype *cft) : 
strstr : if : 				   struct cftype *cft) : 
strstr : for : 				   struct cftype *cft) : 
strstr : while : 				   struct cftype *cft) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	return sched_group_rt_period(css_tg(css));
strstr : INIT : 	return sched_group_rt_period(css_tg(css)); : 
strstr : if : 	return sched_group_rt_period(css_tg(css)); : 
strstr : for : 	return sched_group_rt_period(css_tg(css)); : 
strstr : while : 	return sched_group_rt_period(css_tg(css)); : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
str : #endif /* CONFIG_RT_GROUP_SCHED */
strstr : INIT : #endif /* CONFIG_RT_GROUP_SCHED */ : 
strstr : if : #endif /* CONFIG_RT_GROUP_SCHED */ : 
strstr : for : #endif /* CONFIG_RT_GROUP_SCHED */ : 
strstr : while : #endif /* CONFIG_RT_GROUP_SCHED */ : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : static struct cftype cpu_files[] = {
strstr : if : static struct cftype cpu_files[] = { : 
strstr : for : static struct cftype cpu_files[] = { : 
strstr : while : static struct cftype cpu_files[] = { : 
str : #ifdef CONFIG_FAIR_GROUP_SCHED
strstr : INIT : #ifdef CONFIG_FAIR_GROUP_SCHED : 
strstr : if : #ifdef CONFIG_FAIR_GROUP_SCHED : 
strstr : for : #ifdef CONFIG_FAIR_GROUP_SCHED : 
strstr : while : #ifdef CONFIG_FAIR_GROUP_SCHED : 
str : 	{
strstr : INIT : 	{ : 
strstr : if : 	{ : 
strstr : for : 	{ : 
strstr : while : 	{ : 
str : 		.name = "shares",
strstr : INIT : 		.name = "shares", : 
strstr : if : 		.name = "shares", : 
strstr : for : 		.name = "shares", : 
strstr : while : 		.name = "shares", : 
str : 		.read_u64 = cpu_shares_read_u64,
strstr : INIT : 		.read_u64 = cpu_shares_read_u64, : 
strstr : if : 		.read_u64 = cpu_shares_read_u64, : 
strstr : for : 		.read_u64 = cpu_shares_read_u64, : 
strstr : while : 		.read_u64 = cpu_shares_read_u64, : 
str : 		.write_u64 = cpu_shares_write_u64,
strstr : INIT : 		.write_u64 = cpu_shares_write_u64, : 
strstr : if : 		.write_u64 = cpu_shares_write_u64, : 
strstr : for : 		.write_u64 = cpu_shares_write_u64, : 
strstr : while : 		.write_u64 = cpu_shares_write_u64, : 
str : 	},
strstr : INIT : 	}, : 
strstr : if : 	}, : 
strstr : for : 	}, : 
strstr : while : 	}, : 
str : #endif
strstr : INIT : #endif : 
strstr : if : #endif : 
strstr : for : #endif : 
strstr : while : #endif : 
str : #ifdef CONFIG_CFS_BANDWIDTH
strstr : INIT : #ifdef CONFIG_CFS_BANDWIDTH : 
strstr : if : #ifdef CONFIG_CFS_BANDWIDTH : 
strstr : for : #ifdef CONFIG_CFS_BANDWIDTH : 
strstr : while : #ifdef CONFIG_CFS_BANDWIDTH : 
str : 	{
strstr : INIT : 	{ : 
strstr : if : 	{ : 
strstr : for : 	{ : 
strstr : while : 	{ : 
str : 		.name = "cfs_quota_us",
strstr : INIT : 		.name = "cfs_quota_us", : 
strstr : if : 		.name = "cfs_quota_us", : 
strstr : for : 		.name = "cfs_quota_us", : 
strstr : while : 		.name = "cfs_quota_us", : 
str : 		.read_s64 = cpu_cfs_quota_read_s64,
strstr : INIT : 		.read_s64 = cpu_cfs_quota_read_s64, : 
strstr : if : 		.read_s64 = cpu_cfs_quota_read_s64, : 
strstr : for : 		.read_s64 = cpu_cfs_quota_read_s64, : 
strstr : while : 		.read_s64 = cpu_cfs_quota_read_s64, : 
str : 		.write_s64 = cpu_cfs_quota_write_s64,
strstr : INIT : 		.write_s64 = cpu_cfs_quota_write_s64, : 
strstr : if : 		.write_s64 = cpu_cfs_quota_write_s64, : 
strstr : for : 		.write_s64 = cpu_cfs_quota_write_s64, : 
strstr : while : 		.write_s64 = cpu_cfs_quota_write_s64, : 
str : 	},
strstr : INIT : 	}, : 
strstr : if : 	}, : 
strstr : for : 	}, : 
strstr : while : 	}, : 
str : 	{
strstr : INIT : 	{ : 
strstr : if : 	{ : 
strstr : for : 	{ : 
strstr : while : 	{ : 
str : 		.name = "cfs_period_us",
strstr : INIT : 		.name = "cfs_period_us", : 
strstr : if : 		.name = "cfs_period_us", : 
strstr : for : 		.name = "cfs_period_us", : 
strstr : while : 		.name = "cfs_period_us", : 
str : 		.read_u64 = cpu_cfs_period_read_u64,
strstr : INIT : 		.read_u64 = cpu_cfs_period_read_u64, : 
strstr : if : 		.read_u64 = cpu_cfs_period_read_u64, : 
strstr : for : 		.read_u64 = cpu_cfs_period_read_u64, : 
strstr : while : 		.read_u64 = cpu_cfs_period_read_u64, : 
str : 		.write_u64 = cpu_cfs_period_write_u64,
strstr : INIT : 		.write_u64 = cpu_cfs_period_write_u64, : 
strstr : if : 		.write_u64 = cpu_cfs_period_write_u64, : 
strstr : for : 		.write_u64 = cpu_cfs_period_write_u64, : 
strstr : while : 		.write_u64 = cpu_cfs_period_write_u64, : 
str : 	},
strstr : INIT : 	}, : 
strstr : if : 	}, : 
strstr : for : 	}, : 
strstr : while : 	}, : 
str : 	{
strstr : INIT : 	{ : 
strstr : if : 	{ : 
strstr : for : 	{ : 
strstr : while : 	{ : 
str : 		.name = "stat",
strstr : INIT : 		.name = "stat", : 
strstr : if : 		.name = "stat", : 
strstr : for : 		.name = "stat", : 
strstr : while : 		.name = "stat", : 
str : 		.seq_show = cpu_stats_show,
strstr : INIT : 		.seq_show = cpu_stats_show, : 
strstr : if : 		.seq_show = cpu_stats_show, : 
strstr : for : 		.seq_show = cpu_stats_show, : 
strstr : while : 		.seq_show = cpu_stats_show, : 
str : 	},
strstr : INIT : 	}, : 
strstr : if : 	}, : 
strstr : for : 	}, : 
strstr : while : 	}, : 
str : #endif
strstr : INIT : #endif : 
strstr : if : #endif : 
strstr : for : #endif : 
strstr : while : #endif : 
str : #ifdef CONFIG_RT_GROUP_SCHED
strstr : INIT : #ifdef CONFIG_RT_GROUP_SCHED : 
strstr : if : #ifdef CONFIG_RT_GROUP_SCHED : 
strstr : for : #ifdef CONFIG_RT_GROUP_SCHED : 
strstr : while : #ifdef CONFIG_RT_GROUP_SCHED : 
str : 	{
strstr : INIT : 	{ : 
strstr : if : 	{ : 
strstr : for : 	{ : 
strstr : while : 	{ : 
str : 		.name = "rt_runtime_us",
strstr : INIT : 		.name = "rt_runtime_us", : 
strstr : if : 		.name = "rt_runtime_us", : 
strstr : for : 		.name = "rt_runtime_us", : 
strstr : while : 		.name = "rt_runtime_us", : 
str : 		.read_s64 = cpu_rt_runtime_read,
strstr : INIT : 		.read_s64 = cpu_rt_runtime_read, : 
strstr : if : 		.read_s64 = cpu_rt_runtime_read, : 
strstr : for : 		.read_s64 = cpu_rt_runtime_read, : 
strstr : while : 		.read_s64 = cpu_rt_runtime_read, : 
str : 		.write_s64 = cpu_rt_runtime_write,
strstr : INIT : 		.write_s64 = cpu_rt_runtime_write, : 
strstr : if : 		.write_s64 = cpu_rt_runtime_write, : 
strstr : for : 		.write_s64 = cpu_rt_runtime_write, : 
strstr : while : 		.write_s64 = cpu_rt_runtime_write, : 
str : 	},
strstr : INIT : 	}, : 
strstr : if : 	}, : 
strstr : for : 	}, : 
strstr : while : 	}, : 
str : 	{
strstr : INIT : 	{ : 
strstr : if : 	{ : 
strstr : for : 	{ : 
strstr : while : 	{ : 
str : 		.name = "rt_period_us",
strstr : INIT : 		.name = "rt_period_us", : 
strstr : if : 		.name = "rt_period_us", : 
strstr : for : 		.name = "rt_period_us", : 
strstr : while : 		.name = "rt_period_us", : 
str : 		.read_u64 = cpu_rt_period_read_uint,
strstr : INIT : 		.read_u64 = cpu_rt_period_read_uint, : 
strstr : if : 		.read_u64 = cpu_rt_period_read_uint, : 
strstr : for : 		.read_u64 = cpu_rt_period_read_uint, : 
strstr : while : 		.read_u64 = cpu_rt_period_read_uint, : 
str : 		.write_u64 = cpu_rt_period_write_uint,
strstr : INIT : 		.write_u64 = cpu_rt_period_write_uint, : 
strstr : if : 		.write_u64 = cpu_rt_period_write_uint, : 
strstr : for : 		.write_u64 = cpu_rt_period_write_uint, : 
strstr : while : 		.write_u64 = cpu_rt_period_write_uint, : 
str : 	},
strstr : INIT : 	}, : 
strstr : if : 	}, : 
strstr : for : 	}, : 
strstr : while : 	}, : 
str : #endif
strstr : INIT : #endif : 
strstr : if : #endif : 
strstr : for : #endif : 
strstr : while : #endif : 
str : 	{ }	/* terminate */
strstr : INIT : 	{ }	/* terminate */ : 
strstr : if : 	{ }	/* terminate */ : 
strstr : for : 	{ }	/* terminate */ : 
strstr : while : 	{ }	/* terminate */ : 
str : };
strstr : INIT : }; : 
strstr : if : }; : 
strstr : for : }; : 
strstr : while : }; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : struct cgroup_subsys cpu_cgroup_subsys = {
strstr : if : struct cgroup_subsys cpu_cgroup_subsys = { : 
strstr : for : struct cgroup_subsys cpu_cgroup_subsys = { : 
strstr : while : struct cgroup_subsys cpu_cgroup_subsys = { : 
str : 	.name		= "cpu",
strstr : INIT : 	.name		= "cpu", : 
strstr : if : 	.name		= "cpu", : 
strstr : for : 	.name		= "cpu", : 
strstr : while : 	.name		= "cpu", : 
str : 	.css_alloc	= cpu_cgroup_css_alloc,
strstr : INIT : 	.css_alloc	= cpu_cgroup_css_alloc, : 
strstr : if : 	.css_alloc	= cpu_cgroup_css_alloc, : 
strstr : for : 	.css_alloc	= cpu_cgroup_css_alloc, : 
strstr : while : 	.css_alloc	= cpu_cgroup_css_alloc, : 
str : 	.css_free	= cpu_cgroup_css_free,
strstr : INIT : 	.css_free	= cpu_cgroup_css_free, : 
strstr : if : 	.css_free	= cpu_cgroup_css_free, : 
strstr : for : 	.css_free	= cpu_cgroup_css_free, : 
strstr : while : 	.css_free	= cpu_cgroup_css_free, : 
str : 	.css_online	= cpu_cgroup_css_online,
strstr : INIT : 	.css_online	= cpu_cgroup_css_online, : 
strstr : if : 	.css_online	= cpu_cgroup_css_online, : 
strstr : for : 	.css_online	= cpu_cgroup_css_online, : 
strstr : while : 	.css_online	= cpu_cgroup_css_online, : 
str : 	.css_offline	= cpu_cgroup_css_offline,
strstr : INIT : 	.css_offline	= cpu_cgroup_css_offline, : 
strstr : if : 	.css_offline	= cpu_cgroup_css_offline, : 
strstr : for : 	.css_offline	= cpu_cgroup_css_offline, : 
strstr : while : 	.css_offline	= cpu_cgroup_css_offline, : 
str : 	.can_attach	= cpu_cgroup_can_attach,
strstr : INIT : 	.can_attach	= cpu_cgroup_can_attach, : 
strstr : if : 	.can_attach	= cpu_cgroup_can_attach, : 
strstr : for : 	.can_attach	= cpu_cgroup_can_attach, : 
strstr : while : 	.can_attach	= cpu_cgroup_can_attach, : 
str : 	.attach		= cpu_cgroup_attach,
strstr : INIT : 	.attach		= cpu_cgroup_attach, : 
strstr : if : 	.attach		= cpu_cgroup_attach, : 
strstr : for : 	.attach		= cpu_cgroup_attach, : 
strstr : while : 	.attach		= cpu_cgroup_attach, : 
str : 	.exit		= cpu_cgroup_exit,
strstr : INIT : 	.exit		= cpu_cgroup_exit, : 
strstr : if : 	.exit		= cpu_cgroup_exit, : 
strstr : for : 	.exit		= cpu_cgroup_exit, : 
strstr : while : 	.exit		= cpu_cgroup_exit, : 
str : 	.subsys_id	= cpu_cgroup_subsys_id,
strstr : INIT : 	.subsys_id	= cpu_cgroup_subsys_id, : 
strstr : if : 	.subsys_id	= cpu_cgroup_subsys_id, : 
strstr : for : 	.subsys_id	= cpu_cgroup_subsys_id, : 
strstr : while : 	.subsys_id	= cpu_cgroup_subsys_id, : 
str : 	.base_cftypes	= cpu_files,
strstr : INIT : 	.base_cftypes	= cpu_files, : 
strstr : if : 	.base_cftypes	= cpu_files, : 
strstr : for : 	.base_cftypes	= cpu_files, : 
strstr : while : 	.base_cftypes	= cpu_files, : 
str : 	.early_init	= 1,
strstr : INIT : 	.early_init	= 1, : 
strstr : if : 	.early_init	= 1, : 
strstr : for : 	.early_init	= 1, : 
strstr : while : 	.early_init	= 1, : 
str : };
strstr : INIT : }; : 
strstr : if : }; : 
strstr : for : }; : 
strstr : while : }; : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : #endif	/* CONFIG_CGROUP_SCHED */
strstr : if : #endif	/* CONFIG_CGROUP_SCHED */ : 
strstr : for : #endif	/* CONFIG_CGROUP_SCHED */ : 
strstr : while : #endif	/* CONFIG_CGROUP_SCHED */ : 
str : 
strstr : INIT :  : 
list str ok : INIT :  : 
str : void dump_cpu_task(int cpu)
strstr : if : void dump_cpu_task(int cpu) : 
strstr : for : void dump_cpu_task(int cpu) : 
strstr : while : void dump_cpu_task(int cpu) : 
str : {
strstr : INIT : { : 
strstr : if : { : 
strstr : for : { : 
strstr : while : { : 
str : 	pr_info("Task dump for CPU %d:\n", cpu);
strstr : INIT : 	pr_info("Task dump for CPU %d:\n", cpu); : 
strstr : if : 	pr_info("Task dump for CPU %d:\n", cpu); : 
strstr : for : 	pr_info("Task dump for CPU %d:\n", cpu); : 
strstr : while : 	pr_info("Task dump for CPU %d:\n", cpu); : 
str : 	sched_show_task(cpu_curr(cpu));
strstr : INIT : 	sched_show_task(cpu_curr(cpu)); : 
strstr : if : 	sched_show_task(cpu_curr(cpu)); : 
strstr : for : 	sched_show_task(cpu_curr(cpu)); : 
strstr : while : 	sched_show_task(cpu_curr(cpu)); : 
str : }
strstr : INIT : } : 
strstr : if : } : 
strstr : for : } : 
strstr : while : } : 
