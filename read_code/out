list print :      (nil) ( 0x1407040  DKDK_HEAD)  0x1407060 
list print :  0x1407040 ( 0x1407060         if)  0x1407080 
list print :  0x1407060 ( 0x1407080        for)  0x14070a0 
list print :  0x1407080 ( 0x14070a0      while)      (nil) 
[ OK ] open : 3 ok... 
file : ./test/kernel/fs/afs/main.c 
[ OK ] open : 4 ok... 
buf : /* AFS client file system
ify it under the terms of the GNU General Public License 
if (ret < 0) 
if (ret < 0) 
if (!afs_wq) 
if (ret < 0) 
ifdef CONFIG_AFS_FSCACHE 
if (ret < 0) 
if 
if (ret < 0) 
if (ret < 0) 
if (ret < 0) 
if (ret < 0) 
if (ret < 0) 
ifdef CONFIG_AFS_FSCACHE 
if 
ifdef CONFIG_AFS_FSCACHE 
if 
file : ./test/kernel/fs/dlm/main.c 
[ OK ] open : 4 ok... 
buf : /******************************************************************************
ify, copy, or redistribute it subject to the terms and conditions 
if (error) 
if (error) 
if (error) 
if (error) 
if (error) 
if (error) 
if (error) 
file : ./test/kernel/fs/cachefiles/main.c 
[ OK ] open : 4 ok... 
buf : /* Network filesystem caching backend to use cache files on a premounted
ify it under the terms of the GNU General Public Licence 
if (ret < 0) 
if (!cachefiles_object_jar) { 
if (ret < 0) 
file : ./test/kernel/fs/ecryptfs/main.c 
[ OK ] open : 4 ok... 
buf : /**
ify it under the terms of the GNU General Public License as 
for more details. 
if not, write to the Free Software 
for a response from ecryptfsd.  The actual sleep time will be, more than 
for a message response from " 
formance and memory use. 
if (fmt[1] == '7') { /* KERN_DEBUG */ 
for every lower 
for that inode is created, this function creates the 
if 
if a lower file is already 
if (rc) { 
for lower_dentry [0x%p] and lower_mnt [0x%p]; " 
if (WARN_ON_ONCE(count < 1)) 
if (count == 1) { 
if (rc) 
if (atomic_dec_and_mutex_lock(&inode_info->lower_file_count, 
for_each_entry(global_auth_tok, 
for_sig( 
if (rc) { 
ified in mount " 
if device uid should be checked against the ruid 
for debug output 
if the key can not be 
if (!options) { 
while ((p = strsep(&options, ",")) != NULL) { 
if (rc) { 
if (rc) { 
if (!sig_set) { 
if (!cipher_name_set) { 
if ((mount_crypt_stat->flags & ECRYPTFS_GLOBAL_ENCRYPT_FILENAMES) 
if (!cipher_key_bytes_set) 
if ((mount_crypt_stat->flags & ECRYPTFS_GLOBAL_ENCRYPT_FILENAMES) 
for_cipher_string( 
if (!cipher_code) { 
if (!ecryptfs_tfm_exists(mount_crypt_stat->global_default_cipher_name, 
if (rc) { 
if ((mount_crypt_stat->flags & ECRYPTFS_GLOBAL_ENCRYPT_FILENAMES) 
if (rc) { 
if (rc) 
if (!sbi) { 
if (rc) { 
if (IS_ERR(s)) { 
if (rc) 
if (rc) { 
if (path.dentry->d_sb->s_type == &ecryptfs_fs_type) { 
if (check_ruid && !uid_eq(path.dentry->d_inode->i_uid, current_uid())) { 
if the lower mount is ro. 
if (IS_ERR(inode)) 
if (!s->s_root) { 
if (!root_info) 
if (sbi) { 
if (!sb_info) 
fore we 
for (i = 0; i < ARRAY_SIZE(ecryptfs_cache_infos); i++) { 
if (*(info->cache)) 
for (i = 0; i < ARRAY_SIZE(ecryptfs_cache_infos); i++) { 
if (!*(info->cache)) { 
if (!ecryptfs_kobj) { 
if (rc) { 
if (ECRYPTFS_DEFAULT_EXTENT_SIZE > PAGE_CACHE_SIZE) { 
if (rc) { 
if (rc) { 
if (rc) { 
if (rc) { 
while attempting to " 
if (rc) { 
if (rc) { 
if (ecryptfs_verbosity > 0) 
if (rc) 
file : ./test/kernel/fs/fscache/main.c 
[ OK ] open : 4 ok... 
buf : /* General filesystem local caching manager
ify it under the terms of the GNU General Public License 
ifdef CONFIG_SYSCTL 
if (ret == 0) 
if 
if (!fscache_object_wq) 
if (!fscache_op_wq) 
for_each_possible_cpu(cpu) 
if (ret < 0) 
ifdef CONFIG_SYSCTL 
if (!fscache_sysctl_header) 
if 
if (!fscache_cookie_jar) { 
if (!fscache_root) 
ifdef CONFIG_SYSCTL 
if 
ifdef CONFIG_SYSCTL 
if 
for uninterruptible waiting 
for interruptible waiting 
for uninterruptible waiting 
file : ./test/kernel/fs/gfs2/main.c 
[ OK ] open : 4 ok... 
buf : /*
ify, copy, or redistribute it subject to the terms and conditions 
if (error) 
if (error) 
if (error) 
if (!gfs2_glock_cachep) 
if (!gfs2_glock_aspace_cachep) 
if (!gfs2_inode_cachep) 
if (!gfs2_bufdata_cachep) 
if (!gfs2_rgrpd_cachep) 
if (!gfs2_quotad_cachep) 
if (!gfs2_rsrv_cachep) 
if (error) 
if (error) 
if (!gfs_recovery_wq) 
if (!gfs2_control_wq) 
if (!gfs2_page_pool) 
if (gfs2_rsrv_cachep) 
if (gfs2_quotad_cachep) 
if (gfs2_rgrpd_cachep) 
if (gfs2_bufdata_cachep) 
if (gfs2_inode_cachep) 
if (gfs2_glock_aspace_cachep) 
if (gfs2_glock_cachep) 
file : ./test/kernel/kernel/power/main.c 
[ OK ] open : 4 ok... 
buf : /*
ifdef CONFIG_PM_SLEEP 
for PM-transition notifications */ 
ifier(struct notifier_block *nb) 
ifier); 
ifier_chain_unregister(&pm_chain_head, nb); 
ifier_call_chain(unsigned long val) 
ifier_to_errno(ret); 
if (kstrtoul(buf, 10, &val)) 
if (val > 1) 
ifdef CONFIG_PM_DEBUG 
form", 
for (level = TEST_FIRST; level <= TEST_MAX; level++) 
if (level == pm_test_level) 
if (s != buf) 
for (s = &pm_tests[level]; level <= TEST_MAX; s++, level++) 
if /* CONFIG_PM_DEBUG */ 
for (i = 1; i < REC_FAILED_NUM; i++) { 
for (i = 1; i < REC_FAILED_NUM; i++) { 
for (i = 1; i < REC_FAILED_NUM; i++) { 
if /* CONFIG_DEBUG_FS */ 
ifdef CONFIG_PM_SLEEP_DEBUG 
if (kstrtoul(buf, 10, &val)) 
if (val > 1) 
if /* CONFIG_PM_SLEEP_DEBUG */ 
for a 
ifdef CONFIG_SUSPEND 
for (i = PM_SUSPEND_MIN; i < PM_SUSPEND_MAX; i++) 
if 
if (s != buf) 
ifdef CONFIG_SUSPEND 
if 
if (len == 4 && !strncmp(buf, "disk", len)) 
ifdef CONFIG_SUSPEND 
for (s = &pm_states[state]; state < PM_SUSPEND_MAX; s++, state++) 
if 
if (error) 
if (pm_autosleep_state() > PM_SUSPEND_ON) { 
if (state < PM_SUSPEND_MAX) 
if (state == PM_SUSPEND_MAX) 
ifdef CONFIG_PM_SLEEP 
if an event that would wake the system up from a sleep 
if such an event occurs when the 
fore it is 
ifficulty may be overcome if user space uses 'wakeup_count' before 
for the system 
if there 
if (error) 
if (pm_autosleep_state() > PM_SUSPEND_ON) { 
if (sscanf(buf, "%u", &val) == 1) { 
ifdef CONFIG_PM_AUTOSLEEP 
if (state == PM_SUSPEND_ON) 
ifdef CONFIG_SUSPEND 
if 
if 
if (state == PM_SUSPEND_ON 
if /* CONFIG_PM_AUTOSLEEP */ 
if /* CONFIG_PM_WAKELOCKS */ 
ifdef CONFIG_PM_TRACE 
if (sscanf(buf, "%d", &val) == 1) { 
if (pm_trace_enabled) { 
if /* CONFIG_PM_TRACE */ 
if (kstrtoul(buf, 10, &val)) 
if	/* CONFIG_FREEZER*/ 
ifdef CONFIG_PM_TRACE 
if 
ifdef CONFIG_PM_AUTOSLEEP 
if 
if 
if 
if 
ifdef CONFIG_FREEZER 
if 
ifdef CONFIG_PM_RUNTIME 
if 
if (error) 
if (!power_kobj) 
if (error) 
file : ./test/kernel/tools/power/cpupower/bench/main.c 
[ OK ] open : 4 ok... 
buf : /*  cpufreq-bench CPUFreq microbenchmark
ify 
for more details. 
if not, write to the Free Software 
if (config == NULL) 
while (1) { 
if (c == -1) 
if (config->output != NULL) 
if (config->output == NULL) 
if (string_to_prio(optarg) != SCHED_ERR) { 
if (config != NULL) { 
if (prepare_config(optarg, config)) 
if (config != NULL) { 
if (config->verbose) { 
if (config->output != stdout) 
file : ./test/kernel/init/main.c 
[ OK ] open : 4 ok... 
buf : /*
if gcc is old, avoiding bogus kernels - Paul Gortmaker, May '96 
ifdef CONFIG_X86_LOCAL_APIC 
if 
fork_init(unsigned long); 
ifndef CONFIG_DEBUG_RODATA 
if 
fore the flag is cleared and some 
while the 
ific code. */ 
for /proc) */ 
for parameter parsing */ 
for per-initcall parameter parsing */ 
if static_key manipulation functions are used 
fore jump_label_init is called. 
fore going ahead with the initialization otherwise driver might 
if kernel is booting in an unreliable environment. 
if (parameqn(line, p->str, n)) { 
if (line[n] == '\0' || line[n] == '=') 
if (!p->setup_func) { 
if (p->setup_func(line + n)) 
while (p < __setup_end); 
ift), and will 
iffy = (1<<12); 
if (get_option(&str, &newlevel)) { 
if (val) { 
if (val == param+strlen(param)+1) 
if (val == param+strlen(param)+2) { 
if (panic_later) 
for (i = 0; argv_init[i]; i++) { 
if (obsolete_checksetup(param)) 
if (strchr(param, '.') && (!val || strchr(param, '.') < val)) 
if (panic_later) 
if (val) { 
for (i = 0; envp_init[i]; i++) { 
if (!strncmp(param, envp_init[i], val - param)) 
for (i = 0; argv_init[i]; i++) { 
fore the whole cmdline which makes 
fore_ init=... [MJ] 
for (i = 1; i < MAX_INIT_ARGS; i++) 
for (i = 1; i < MAX_INIT_ARGS; i++) 
ifndef CONFIG_SMP 
ifdef CONFIG_X86_LOCAL_APIC 
while (0) 
if 
for future reference. 
formed in place, and we should allow a component to 
fore the root thread has proceeded to 
if 
fore we create kthreadd, will OOPS. 
for early params. */ 
for (p = __setup_start; p < __setup_end; p++) { 
if (p->setup_func(val) != 0) 
formed early option '%s'\n", param); 
if not, just before other parsing. */ 
if (done) 
for SMP and UP case */ 
if THREAD_SIZE >= PAGE_SIZE 
if 
ific boot-cpu hooks */ 
if (after_dashes) 
while we still have a functioning scheduler. 
for the first time. 
if (WARN(!irqs_disabled(), "Interrupts were enabled *very* early, fixing it\n")) 
fore init_ISA_irqs() */ 
fore 
if (panic_later) 
ifdef CONFIG_BLK_DEV_INITRD 
if 
if (late_time_init) 
ifdef CONFIG_X86 
if 
fore the first non-init thread is created */ 
if 
fork_init(totalram_pages); 
if (efi_enabled(EFI_RUNTIME_SERVICES)) { 
ifdef CONFIG_CONSTRUCTORS 
for (; fn < (ctor_fn_t *) __ctors_end; fn++) 
if 
ifdef CONFIG_KALLSYMS 
if (str_entry) { 
while (str_entry); 
if (!fn_name) 
for_each(tmp, &blacklisted_initcalls) { 
if (!strcmp(fn_name, entry->buf)) { 
if 
if (initcall_blacklisted(fn)) 
if (initcall_debug) 
if (preempt_count() != count) { 
if (irqs_disabled()) { 
for (fn = initcall_levels[level]; fn < initcall_levels[level+1]; fn++) 
for (level = 0; level < ARRAY_SIZE(initcall_levels) - 1; level++) 
for (fn = __initcall_start; fn < __initcall0_start; fn++) 
fore init is 
fore control is passed to userland. 
if (ret && ret != -ENOENT) { 
fore freeing the memory */ 
if (ramdisk_execute_command) { 
if (!ret) 
if we are 
if (execute_command) { 
if (!ret) 
if (!try_to_run_init_process("/sbin/init") || 
for guidance."); 
for_completion(&kthreadd_done); 
if (sys_open((const char __user *) "/dev/console", O_RDWR, 0) < 0) 
if there is an early userspace init.  If yes, let it do all 
if (!ramdisk_execute_command) 
if (sys_access((const char __user *) ramdisk_execute_command, 0) != 0) { 
file : ./test/kernel/arch/x86/kernel/cpu/mtrr/main.c 
[ OK ] open : 4 ok... 
buf : /*  Generic MTRR (Memory Type Range Register) driver.
ify it under the terms of the GNU Library General Public 
for more details. 
if not, write to the Free 
if; 
if (ops->vendor && ops->vendor < X86_VENDOR_NUM) 
if we have the write-combining memory type  */ 
if (dev != NULL) { 
for other 
if (dev->vendor == PCI_VENDOR_ID_SERVERWORKS && 
if (dev->vendor == PCI_VENDOR_ID_INTEL && 
if->have_wrcomb ? mtrr_if->have_wrcomb() : 0; 
if (use_intel()) 
if (is_cpu(AMD)) 
if (is_cpu(CYRIX) || is_cpu(CENTAUR)) 
for (i = 0; i < max; i++) 
ific MTRR. 
if->set_all() (On the logical cpu that 
if (data->smp_reg != ~0U) { 
if (mtrr_aps_delayed_init || !cpu_online(smp_processor_id())) { 
fortunately, Intel spelled it out for us cleanly: 
for all procs to do so 
for buddies to catch up 
for us? Well, stop_machine() will ensure that 
ifferently, so we call mtrr_if->set() 
for UP systems, too; all the SMP stuff 
ifics of each processor's 
for this entry is returned, but should be treated 
for the cases where drivers do not mind 
if (!mtrr_if) 
if->validate_add_page(base, size, type); 
if (type >= MTRR_NUM_TYPES) { 
if ((type == MTRR_TYPE_WRCOMB) && !have_wrcomb()) { 
if (!size) { 
if ((base | (base + size - 1)) >> 
for existing MTRR  */ 
for (i = 0; i < num_var_ranges; ++i) { 
if (!lsize || base > lbase + lsize - 1 || 
if (base < lbase || base + size - 1 > lbase + lsize - 1) { 
if (type == ltype) { 
if (types_compatible(type, ltype)) 
if (ltype != type) { 
for %lx000,%lx000 old: %s new: %s\n", 
if (increment) 
for an empty MTRR */ 
if (i >= 0) { 
if (likely(replace < 0)) { 
if (increment) 
if (unlikely(replace != i)) { 
if ((base & (PAGE_SIZE - 1)) || (size & (PAGE_SIZE - 1))) { 
ifics of each processor's 
for this entry is returned, but should be treated 
for the cases where drivers do not mind 
if (mtrr_check(base, size)) 
if (!mtrr_if) 
if (reg < 0) { 
for existing MTRR  */ 
if->get(i, &lbase, &lsize, &ltype); 
if (reg < 0) { 
for %lx000,%lx000 found\n", 
if (reg >= max) { 
if->get(reg, &lbase, &lsize, &ltype); 
if (mtrr_usage_table[reg] < 1) { 
if (--mtrr_usage_table[reg] < 1) 
if (mtrr_check(base, size)) 
if PAT is unavailable 
if this fails. 
if (pat_enabled) 
if (ret < 0) { 
for [%p-%p]; performance may suffer.", 
if_needed. 
if_needed(0) do nothing. 
if (handle >= 1) { 
for debugging. 
if (handle < MTRR_TO_PHYS_WC_OFFSET) 
ifs(void) 
if 
for CPU without MTRR. CPU using generic 
for (i = 0; i < num_var_ranges; i++) { 
for (i = 0; i < num_var_ranges; i++) { 
fore any of the other CPUs are 
ifs(); 
if (cpu_has_mtrr) { 
ific MSR, but we assume(hope?) that 
if (cpuid_eax(0x80000000) >= 0x80000008) { 
for Intel 0F33/0F34 CPU */ 
if (boot_cpu_data.x86_vendor == X86_VENDOR_CENTAUR && 
if (cpu_has_k6_mtrr) { 
if = mtrr_ops[X86_VENDOR_AMD]; 
if (cpu_has_centaur_mcr) { 
if (cpu_has_cyrix_arr) { 
if (mtrr_if) { 
if (use_intel()) { 
if (mtrr_cleanup(phys_addr)) { 
if->set_all(); 
if (!use_intel() || mtrr_aps_delayed_init) 
if (!use_intel()) 
for all AP's 
if (!use_intel()) 
if someone has requested the delay of AP MTRR initialization, 
if (!mtrr_aps_delayed_init) 
if (!use_intel()) 
if->set_all(); 
if (!mtrr_if) 
if (use_intel()) { 
ific drivers, we use a tricky method to support 
for them. 
file : ./test/kernel/arch/x86/boot/main.c 
[ OK ] open : 4 ok... 
buf : /* -*- linux-c -*- ------------------------------------------------------- *
for the real-mode kernel code 
if (!boot_params.hdr.cmd_line_ptr && 
if the command line falls in the region 
if (oldcmd->cl_offset < boot_params.hdr.setup_move_size) 
formation. 
if (cpu.level < 6) 
ifdef CONFIG_X86_64 
if 
if (boot_params.hdr.loadflags & CAN_USE_HEAP) { 
if (heap_end > stack_end) 
if (cmdline_find_option_bool("debug")) 
if (validate_cpu()) { 
for your CPU.\n"); 
formation */ 
formation */ 
formation */ 
if 
formation */ 
if 
file : ./test/kernel/arch/powerpc/boot/main.c 
[ OK ] open : 4 ok... 
buf : /*
for PPC64 by Todd Inglett, Dave Engebretsen & Peter Bergner. 
ify it under the terms of the GNU General Public License 
if (!parse_elf64(elfheader, &ei) && !parse_elf32(elfheader, &ei)) 
if (platform_ops.image_hdr) 
form_ops.image_hdr(elfheader); 
for kernel ...\n\r", ei.memsize); 
form_ops.vmlinux_alloc(ei.memsize); 
if the kernel image (without bss) would overwrite the 
if ((unsigned long)_start < ei.loadsize) 
for kernel at address 0!" 
if ((unsigned long)_end < ei.memsize) 
if (len != ei.loadsize) 
if (_initrd_end > _initrd_start) { 
if (initrd_size > 0) { 
if (! initrd_size) 
if (initrd_addr < vmlinux.size) { 
for initrd ...\n\r", 
if (! initrd_addr) 
for initial " 
if (cmdline[0] == '\0') 
if (console_ops.edit_cmdline) 
for the kernel */ 
form_ops platform_ops; 
if a 
if ((loader_info.cmdline_len > 0) && (cmdline[0] == '\0')) 
if (console_ops.open && (console_ops.open() < 0)) 
if (platform_ops.fixups) 
form_ops.fixups(); 
if (!chosen) 
if (dt_ops.finalize) 
if (ft_addr) 
if (console_ops.close) 
if (ft_addr) 
file : ./test/kernel/arch/alpha/boot/main.c 
[ OK ] open : 4 ok... 
buf : /*
for the Linux/AXP kernel 
for that. The kernel proper should replace this PCB with 
if (i) { 
if (result < 0) 
if (result < 0) 
if (result) 
for Linux " UTS_RELEASE "\n"); 
if (dev < 0) { 
if (i != KERNEL_SIZE) { 
if (nbytes < 0) { 
for (i = 0 ; i < 0x100000000 ; i++) 
file : ./test/kernel/arch/um/os-Linux/main.c 
[ OK ] open : 4 ok... 
buf : /*
if (getrlimit(RLIMIT_STACK, &lim) < 0) { 
if ((lim.rlim_cur == RLIM_INFINITY) || (lim.rlim_cur > STACKSIZE)) { 
if (setrlimit(RLIMIT_STACK, &lim) < 0) { 
while (call < &__uml_initcall_end) { 
if an exit 
for some reason, the UML will just die 
if (sigaction(sig, &action, NULL) < 0) { 
for signal %d - errno = %d\n", 
if no PATH variable is set or it has an empty value 
if (!old_path || (path_len = strlen(old_path)) == 0) { 
if (!new_path) { 
if (putenv(new_path)) { 
if (new_argv == NULL) { 
for (i = 0; i < argc; i++) { 
if (new_argv[i] == NULL) { 
if all other 
ifdef CONFIG_ARCH_REUSE_HOST_VSYSCALL_AREA 
if 
fore 
formation, presumably because that takes 
for the fds and set SIGIO to be ignored */ 
if (err) 
if (ret) { 
if (!kmalloc_ok) 
if (size <= UM_KERN_PAGE_SIZE) 
if malloc fails, errno should be 
if (ret == NULL) 
if (ptr == NULL) 
for memory leaks. 
if ((addr >= uml_physmem) && (addr < high_physmem)) { 
if ((addr >= start_vm) && (addr < end_vm)) { 
file : ./test/kernel/drivers/bcma/main.c 
[ OK ] open : 4 ok... 
buf : /*
ific AMBA 
for details. 
form_device.h> 
ific AMBA driver"); 
if (bus->chipinfo.id == BCMA_CHIP_ID_BCM4706) 
for_each_entry(core, &bus->cores, list) { 
iffies + timeout; 
if ((val & mask) == value) 
iffies, deadline)); 
for register 0x%04X!\n", reg); 
if (core->io_addr) 
if (core->io_wrap) 
for_each_entry(core, &bus->cores, list) { 
if (core->id.id == BCMA_CORE_4706_MAC_GBIT && 
if (err) { 
for core 0x%03X\n", 
ifdef CONFIG_BCMA_DRIVER_MIPS 
form_device_register(&bcma_pflash_dev); 
if 
if (bus->drv_cc.sflash.present) { 
form_device_register(&bcma_sflash_dev); 
if 
if (bus->drv_cc.nflash.present) { 
form_device_register(&bcma_nflash_dev); 
if 
if (err == -ENOTSUPP) 
if (err) 
if (bus->hosttype == BCMA_HOSTTYPE_SOC) { 
if (err) 
for_each_entry_safe(core, tmp, &bus->cores, list) { 
if (core->dev_registered) 
if (bus->hosttype == BCMA_HOSTTYPE_SOC) 
form_device_unregister(bus->drv_cc.watchdog); 
for devices (cores) */ 
if (err) { 
if (core) { 
if (err == -ENOENT) { 
if (err) 
if (core) { 
if (core) { 
if (core) { 
if (core) { 
if (core) { 
if (err == -EBUSY) 
if (err) 
for chip common core */ 
if (err) { 
for common core: %d\n", err); 
for mips core */ 
if (err) { 
for mips core: %d\n", err); 
if (core) { 
if (core) { 
ifdef CONFIG_PM 
for_each_entry(core, &bus->cores, list) { 
if (drv) { 
if (adrv->suspend) 
if (bus->drv_cc.core) { 
for_each_entry(core, &bus->cores, list) { 
if (drv) { 
if (adrv->resume) 
if 
for (did = adrv->id_table; did->manuf || did->id || did->rev; did++) { 
if (adrv->probe) 
if (adrv->remove) 
if (err) 
ifdef CONFIG_BCMA_HOST_PCI 
if (err) { 
if 
ifdef CONFIG_BCMA_HOST_PCI 
if 
file : ./test/kernel/drivers/base/power/main.c 
[ OK ] open : 4 ok... 
buf : /*
for 
for keeping track of power info, because the power 
while holding 
for %s:%s\n", 
if (dev->parent && dev->parent->power.is_prepared) 
for %s:%s\n", 
fore - Move device in the PM core's list of active devices. 
fore. 
fore(struct device *deva, struct device *devb) 
fore devb. */ 
if (pm_print_times_enabled) { 
if (pm_print_times_enabled) { 
for a PM operation to complete. 
if the device's power.async_suspend flag is set. 
if (!dev) 
if (async || (pm_async_enabled && dev->power.async_suspend)) 
for_completion(&dev->power.completion); 
for_children(struct device *dev, bool async) 
for given PM event. 
ifdef CONFIG_SUSPEND 
if /* CONFIG_SUSPEND */ 
if /* CONFIG_HIBERNATE_CALLBACKS */ 
for given PM event. 
for @dev while this function is being executed. 
ifdef CONFIG_SUSPEND 
if /* CONFIG_SUSPEND */ 
if /* CONFIG_HIBERNATE_CALLBACKS */ 
for given PM event. 
while this function is being 
ifdef CONFIG_SUSPEND 
if /* CONFIG_SUSPEND */ 
if /* CONFIG_HIBERNATE_CALLBACKS */ 
if (usecs == 0) 
if (!cb) 
ifdef CONFIG_DPM_WATCHDOG 
for given device. 
for both suspend and resume */ 
if 
for given device. 
while this function is being 
if (dev->power.syscore || dev->power.direct_complete) 
if (!dev->power.is_noirq_suspended) 
if (dev->pm_domain) { 
if (dev->type && dev->type->pm) { 
if (dev->class && dev->class->pm) { 
if (dev->bus && dev->bus->pm) { 
if (!callback && dev->driver && dev->driver->pm) { 
if (error) 
for all devices. 
for all devices in dpm_noirq_list and 
for_each_entry(dev, &dpm_noirq_list, power.entry) { 
if (is_async(dev)) { 
while (!list_empty(&dpm_noirq_list)) { 
if (!is_async(dev)) { 
if (error) { 
for given device. 
for @dev while this function is being executed. 
if (dev->power.syscore || dev->power.direct_complete) 
if (!dev->power.is_late_suspended) 
if (dev->pm_domain) { 
if (dev->type && dev->type->pm) { 
if (dev->class && dev->class->pm) { 
if (dev->bus && dev->bus->pm) { 
if (!callback && dev->driver && dev->driver->pm) { 
if (error) 
for all devices. 
for_each_entry(dev, &dpm_late_early_list, power.entry) { 
if (is_async(dev)) { 
while (!list_empty(&dpm_late_early_list)) { 
if (!is_async(dev)) { 
if (error) { 
for given device. 
if (dev->power.syscore) 
if (dev->power.direct_complete) { 
if the device hasn't been completed yet. 
if (!dev->power.is_suspended) 
if (dev->pm_domain) { 
if (dev->type && dev->type->pm) { 
if (dev->class) { 
if (dev->class->resume) { 
if (dev->bus) { 
if (dev->bus->resume) { 
if (!callback && dev->driver && dev->driver->pm) { 
if (error) 
for non-sysdev devices. 
for all devices whose status 
for_each_entry(dev, &dpm_suspended_list, power.entry) { 
if (is_async(dev)) { 
while (!list_empty(&dpm_suspended_list)) { 
if (!is_async(dev)) { 
if (error) { 
if (!list_empty(&dev->power.entry)) 
for given device. 
if (dev->power.syscore) 
if (dev->pm_domain) { 
if (dev->type && dev->type->pm) { 
if (dev->class && dev->class->pm) { 
if (dev->bus && dev->bus->pm) { 
if (!callback && dev->driver && dev->driver->pm) { 
if (callback) { 
for all non-sysdev devices. 
for all devices whose PM status is not 
while (!list_empty(&dpm_prepared_list)) { 
for all devices and complete the PM transition of 
for given "suspend" sleep state. 
for given device. 
while this function is being 
if (async_error) 
if (pm_wakeup_pending()) { 
if (dev->power.syscore || dev->power.direct_complete) 
for_children(dev, async); 
if (dev->type && dev->type->pm) { 
if (dev->class && dev->class->pm) { 
if (dev->bus && dev->bus->pm) { 
if (!callback && dev->driver && dev->driver->pm) { 
if (!error) 
if (error) { 
if (pm_async_enabled && dev->power.async_suspend) { 
for all devices. 
for all non-sysdev devices. 
while (!list_empty(&dpm_late_early_list)) { 
if (error) { 
if (!list_empty(&dev->power.entry)) 
if (async_error) 
if (!error) 
if (error) { 
for given device. 
for @dev while this function is being executed. 
if (async_error) 
if (pm_wakeup_pending()) { 
if (dev->power.syscore || dev->power.direct_complete) 
for_children(dev, async); 
if (dev->type && dev->type->pm) { 
if (dev->class && dev->class->pm) { 
if (dev->bus && dev->bus->pm) { 
if (!callback && dev->driver && dev->driver->pm) { 
if (!error) 
if (error) { 
if (pm_async_enabled && dev->power.async_suspend) { 
for all devices. 
while (!list_empty(&dpm_suspended_list)) { 
if (error) { 
if (!list_empty(&dev->power.entry)) 
if (async_error) 
if (error) { 
if (error) 
if (error) { 
for device. 
for given device. 
for_children(dev, async); 
for it, this is equivalent to the device signaling wakeup, so the 
if (pm_runtime_barrier(dev) && device_may_wakeup(dev)) 
if (pm_wakeup_pending()) { 
if (dev->power.syscore) 
if (dev->power.direct_complete) { 
if (pm_runtime_suspended_if_enabled(dev)) 
if (dev->pm_domain) { 
if (dev->type && dev->type->pm) { 
if (dev->class) { 
if (dev->class->suspend) { 
if (dev->bus) { 
if (dev->bus->suspend) { 
if (!callback && dev->driver && dev->driver->pm) { 
if (!error) { 
if (parent) { 
if (dev->power.wakeup_path 
if (error) 
if (error) { 
if (pm_async_enabled && dev->power.async_suspend) { 
for all non-sysdev devices. 
while (!list_empty(&dpm_prepared_list)) { 
if (error) { 
if (!list_empty(&dev->power.entry)) 
if (async_error) 
if (!error) 
if (error) { 
for system power transition. 
for given device.  No new children of the 
if (dev->power.syscore) 
if (dev->pm_domain) { 
if (dev->type && dev->type->pm) { 
if (dev->class && dev->class->pm) { 
if (dev->bus && dev->bus->pm) { 
if (!callback && dev->driver && dev->driver->pm) { 
if (callback) { 
if (ret < 0) { 
if it really is 
for a system PM transition. 
for all devices. 
while (!list_empty(&dpm_list)) { 
if (error) { 
for power transition: code %d\n", 
if (!list_empty(&dev->power.entry)) 
for PM transition and suspend them. 
for system PM transition and execute "suspend" 
if (error) { 
if (ret) 
for_dev - Wait for suspend/resume of a device to complete. 
for @dev. 
for_dev(struct device *subordinate, struct device *dev) 
for_dev); 
for_each_dev - device iterator. 
for each device. 
for_each_dev(void *data, void (*fn)(struct device *, void *)) 
if (!fn) 
for_each_entry(dev, &dpm_list, power.entry) 
for_each_dev); 
file : ./test/kernel/drivers/mtd/nand/bcm47xxnflash/main.c 
[ OK ] open : 4 ok... 
buf : /*
ify 
form_device.h> 
for BCMA bus"); 
form_device *pdev) 
if (!b47n) 
if (b47n->cc->core->bus->chipinfo.id == BCMA_CHIP_ID_BCM4706) { 
if (err) { 
if (err) { 
form_device *pdev) 
if (nflash->mtd) 
form_driver bcm47xxnflash_driver = { 
form_driver(bcm47xxnflash_driver); 
file : ./test/kernel/drivers/staging/speakup/main.c 
[ OK ] open : 4 ok... 
buf : /* speakup.c
for the speakup screen review package. 
ified by David Borowski. 
ify 
for more details. 
if not, write to the Free Software 
iffies.h> 
for KT_SHIFT */ 
ifier.h> 
iffies(500) 
if speakup is built in."); 
ift, synth_flags; 
ift_table; 
iform", "victer", "whiskey", 
for each character description) 
for each character) 
iffy; 
ifier_call(struct notifier_block *, 
ifier_block keyboard_notifier_block = { 
ifier_call(struct notifier_block *, 
ifier_block vt_notifier_block = { 
if (val > 11) 
iffies = msecs_to_jiffies(time); 
if (spk_killed) 
if (synth != NULL) 
if (val == 0) 
if disabled */ 
if (spk_shut_up & 0x80) { 
if (spk_parked & 0x80) { 
if (!mark_cut_flag) { 
if (mark_cut_flag) { 
if (fg > 8) { 
if (bg > 7) { 
if (spk_bleeps & 1) 
if ((spk_bleeps & 2) && (msg_id < edge_quiet)) 
if (direct && direct->u.n.value) { 
ift++; 
if (IS_CHAR(ch, B_CAP)) 
if (cp == NULL) { 
if (IS_CHAR(ch, B_CAP)) { 
if (*cp == '^') { 
if (vc && pos) { 
if (w & vc->vc_hi_font_mask) 
if (spk_attr != spk_old_attr) { 
if (spk_attrib_bleep & 2) 
if (isascii(ch) && isalpha(ch)) { 
if (IS_CHAR(ch, B_NUM)) 
if (spk_x == 0) { 
if (spk_x == vc->vc_cols - 1) { 
if the character under the 
if there is a word starting on the next position to the right 
if on a space (mis-information */ 
if ((tmpx < vc->vc_cols - 2) 
while (tmpx > 0) { 
if ((ch == SPACE || ch == 0 || IS_WDLM(ch)) 
while (tmpx < vc->vc_cols - 1) { 
if ((ch == SPACE) || ch == 0 
if (cnt == 0) 
if (spk_x == 0) { 
while (1) { 
if (spk_y == 0) { 
if (edge_said != edge_quiet) 
if (state > 0) 
if (ch == SPACE || ch == 0) 
if (IS_WDLM(ch)) 
if (state < last_state) { 
if (spk_x == 0 && edge_said == edge_quiet) 
if (edge_said > 0 && edge_said < edge_quiet) 
if (spk_x == vc->vc_cols - 1 && spk_y == vc->vc_rows - 1) { 
while (1) { 
if (ch == SPACE || ch == 0) 
if (IS_WDLM(ch)) 
if (state > last_state) 
if (spk_x >= vc->vc_cols - 1) { 
if (edge_said > 0) 
if (!get_word(vc)) 
while ((ch = (u_char) *cp)) { 
if (IS_CHAR(ch, B_CAP)) { 
if (*spk_str_caps_stop) 
if (str_cap != last_cap) { 
if (this_speakup_key == SPELL_PHONETIC 
if (*cp1 == '^') { 
if (str_cap != spk_str_caps_stop) 
for (i = 0; i < vc->vc_cols; i++) { 
for (--i; i >= 0; i--) 
if (i == 0) { 
if (this_speakup_key == SAY_LINE_INDENT) { 
while (*cp == SPACE) 
if (spk_y == 0) { 
if (spk_y == vc->vc_rows - 1) { 
while (from < to) { 
if (i >= vc->vc_size_row) 
for (--i; i >= 0; i--) 
if (i < 1) 
if (read_punc) 
if (read_punc) 
if (say_from_to(vc, start, end, read_punc) <= 0) 
if (prev && --bn == -1) 
if (num > numsentences[bn]) 
if (currbuf == 2) 
while (start < end) { 
if (i > 0) { 
if (i >= vc->vc_size_row) 
for (--i; i >= 0; i--) 
if (i < 1) 
if (from > 0) 
if (to > vc->vc_rows) 
for (from = start; from < end; from = to) { 
if (win_start < 2) { 
while (start <= end) { 
if (len == 0) { 
for (i = 0; i < len; i++) 
if (len == 0) { 
while (count--) { 
if ((in_buf == sentmarks[bn][currsentence]) && 
if (ch == old_ch && !(char_type & B_NUM)) { 
if ((last_type & CH_RPT) && rep_count > 2) { 
if (ch == spk_lastkey) { 
if (spk_key_echo == 1 && ch >= MINECHOCHAR) 
if (char_type & B_ALPHA) { 
if (char_type & B_NUM) { 
if (char_type & spk_punc_mask) { 
for dec nospell processing */ 
for expression. 
if someone has 
if (ch != old_ch) 
if next is num overwrite space */ 
if (in_count > 2 && rep_count > 2) { 
ift(struct vc_data *vc, u_char value, char up_flag) 
if (synth == NULL || up_flag || spk_killed) 
if (cursor_track == read_all_mode) { 
if (spk_say_ctrl && value < NUM_CTL_LABELS) 
if (up_flag) { 
if (synth == NULL || spk_killed) { 
if (spk_key_echo == 2 && value >= MINECHOCHAR) 
if (version != KEY_MAP_VER) 
if (key_data_len + SHIFT_TBL_SIZE + 4 >= sizeof(spk_key_buf)) 
ift_table = k_buffer; 
ift states */ 
for (i = 1; i <= states; i++) { 
if (ch >= SHIFT_TBL_SIZE) 
ift_table[ch] = i; 
while ((ch = *cp1)) { 
if (cursor_track == read_all_mode) 
if (++cursor_track >= CT_Max) 
for (i = 0; i < 256; i++) { 
if (type != KT_LATIN || (ch_type & B_NUM) || ch < SPACE) 
if (ch == SPACE) { 
if (mask < PUNC && !(ch_type & PUNC)) 
if (speakup_console[vc_num] == NULL) { 
if (speakup_console[vc_num] == NULL) 
if (!spk_parked) 
if ((vc->vc_num != fg_console) || synth == NULL || spk_shut_up) 
if (!synth_supports_indexing()) 
if (cursor_track != read_all_mode) 
if (get_sentence_buf(vc, 0) == -1) 
iffies + msecs_to_jiffies(cursor_timeout->u.n.value)); 
if (indcount == 1) { 
if (!say_sentence_num(sentcount + 1, 1)) { 
if (!say_sentence_num(sn, 0)) { 
if (get_sentence_buf(vc, 0) == -1) { 
if (rv == -1) 
if (rv == 0) 
if (indcount < 2) 
if (cursor_track == read_all_mode) { 
if (synth == NULL || up_flag || spk_shut_up) { 
if (synth == NULL || up_flag || spk_shut_up || cursor_track == CT_Off) { 
if (spk_no_intr) 
if !no_inter but we want to flush on cursor 
if (cursor_track == CT_Highlight) 
iffies + msecs_to_jiffies(cursor_timeout->u.n.value)); 
if (speakup_console[vc_num]->ht.highsize[bi] == 0) { 
while ((hi < COLOR_BUFFER_SIZE) && (i < len)) { 
if ((ic[i] == 32) && (hi != 0)) { 
for (i = 0; i < 8; i++) 
for (i = 0; i < 8; i++) 
for (i = 0; i < vc->vc_rows; i++) { 
for (ptr = start; ptr < end; ptr++) { 
for (i = 0; i < 8; i++) 
for (i = 0; i < 8; i++) 
for (i = 0; i < 7; i++) 
if (speakup_console[vc_num]->ht.bgcount[cptr[i]] > 
for (i = 0; i < 8; i++) 
if (speakup_console[vc_num]->ht.highsize[cptr[i]] > 0) 
if (count_highlight_color(vc) == 1) 
if (hc != -1) { 
if ((d == 1) || (d == -1)) 
if (cursor_con != fg_console) { 
if (win_enabled) { 
if (cursor_track == read_all_mode) { 
if (cursor_track == CT_Highlight) { 
if (cursor_track == CT_Window) 
if (is_cursor == 1 || is_cursor == 4) 
ifier_call() */ 
if (!speakup_console[vc->vc_num]) 
if (!spin_trylock_irqsave(&speakup_info.spinlock, flags)) 
if (!spk_parked) 
if (spk_shut_up || synth == NULL) { 
if (vc->vc_num == fg_console && spk_keydown) { 
if (!is_cursor) 
ifier_call() */ 
if ((vc->vc_num != fg_console) || spk_shut_up || synth == NULL) 
if (!spin_trylock_irqsave(&speakup_info.spinlock, flags)) 
if (spk_bell_pos && spk_keydown && (vc->vc_x == spk_bell_pos - 1)) 
if ((is_cursor) || (cursor_track == read_all_mode)) { 
if (win_enabled) { 
if (speakup_console[vc->vc_num] == NULL || spk_parked) 
if (!spin_trylock_irqsave(&speakup_info.spinlock, flags)) 
if (synth == NULL || up_flag || spk_killed) 
if (spk_no_intr) 
if (speakup_console[vc->vc_num]) 
if (on_off < 2) 
if (p_header == NULL) 
if (p_header->var_type != VAR_NUM) 
if (spk_set_num_var(1, p_header, how) != 0) 
if (!spk_close_press) { 
for (pn = p_header->name; *pn; pn++) { 
if (win_start > 1) { 
if (spk_x < win_left || spk_y < win_top) { 
if (win_start && spk_x == win_left && spk_y == win_top) { 
if (!win_start) { 
if (win_start < 2) { 
if (win_enabled) 
if (spk_special_handler != NULL || val < 1 || val > 6) { 
if (type == KT_SPKUP && ch == SPEAKUP_GOTO) 
if (type == KT_LATIN && ch == '\n') 
if (type != 0) 
if (ch == 8) { 
if (ch < '+' || ch > 'y') 
if ((ch == '+' || ch == '-') && num == 1) 
if (ch >= '0' && ch <= '9' && num < maxlen) 
if (num < maxlen - 1 || num > maxlen) 
if (ch < 'x' || ch > 'y') { 
if (!spk_killed) 
if (*cp == 'x') { 
if (goto_pos > 0) 
if (goto_pos >= vc->vc_cols) 
if (*goto_buf < '0') 
if (goto_pos > 0) 
if (goto_pos >= vc->vc_rows) 
if (goto_x) { 
if (spk_special_handler != NULL) { 
if (!spk_key_locked) 
for indent */ 
if (spk_killed && value != SPEECH_KILL) 
if (value < SPKUP_MAX_FUNC && spkup_handler[value]) { 
if (inc_dec_var(value) < 0) 
ift_state, int keycode, u_short keysym, 
ift_info, offset; 
if (synth == NULL) 
if (type >= 0xf0) 
if (type == KT_PAD 
if (up_flag) { 
if (keycode >= MAX_KEY) 
if (!key_info) 
if ((cursor_track == read_all_mode) && (!up_flag)) { 
ift_info = (shift_state & 0x0f) + key_speakup; 
if (offset) { 
if (new_key) { 
if (new_key == SPK_KEY) { 
if (up_flag || spk_killed) 
if (up_flag) 
if (last_keycode == keycode && 
ift_table[shift_info + 32]; 
if (offset && key_info[offset]) 
iffy = jiffies; 
if (type == KT_SPKUP && spk_special_handler == NULL) { 
if (up_flag || spk_killed || type == KT_SHIFT) 
if ((cursor_track != read_all_mode) || !kh) 
if (spk_special_handler) { 
if (type == KT_LETTER) 
if (value == 0x7f) 
if (ret < 0) 
ifier_call(struct notifier_block *nb, 
ifier_param *param = _param; 
if (vc->vc_mode == KD_GRAPHICS) 
while it is held by the 
if (speakup_fake_key_pressed()) 
if (speakup_key(vc, param->shift, keycode, param->value, up)) 
if (KTYP(param->value) == KT_CUR) 
ift(vc, val, up); 
ifier_call(struct notifier_block *nb, 
ifier_param *param = _param; 
if (vc->vc_mode == KD_TEXT) 
if (param->c == '\b') 
if (param->c < 0x100) { 
ifier(&keyboard_notifier_block); 
for (i = 0; i < MAX_NR_CONSOLES; i++) 
for (i = 0; i < MAXVARS; i++) 
for (i = 0; i < 256; i++) { 
for i18n. */ 
for (var = spk_vars; var->var_id != MAXVARS; var++) 
for (var = synth_time_vars; 
for (i = 1; spk_punc_info[i].mask != 0; i++) 
if (err) 
if (!first_console) { 
for (i = 0; i < MAX_NR_CONSOLES; i++) 
if (err) 
if (spk_quiet_boot) 
if (err) 
ifier(&keyboard_notifier_block); 
ifier; 
if (err) 
if (IS_ERR(speakup_task)) { 
ifier(&vt_notifier_block); 
ifier(&keyboard_notifier_block); 
ifier: 
for (i = 0; i < MAX_NR_CONSOLES; i++) 
for (i = 0; i < MAXVARS; i++) 
for (i = 0; i < 256; i++) { 
file : ./test/kernel/drivers/tty/ipwireless/main.c 
[ OK ] open : 4 ok... 
buf : /*
if (ret) 
if (!request_region(p_dev->resource[0]->start, 
if (ret != 0) 
if (ret != 0) 
if (!request_mem_region(p_dev->resource[2]->start, 
if (ret != 0) 
if (ret != 0) 
if (!request_mem_region(p_dev->resource[3]->start, 
if (ret != 0) 
if (ret != 0) 
if (ipw->attr_memory && ipw->common_memory) 
if (!ipw->network) 
if (!ipw->tty) 
fore we're ready for them. 
if (ret != 0) 
if (ipw->common_memory) { 
if (ipw->attr_memory) { 
if (ipw->common_memory) { 
if (ipw->attr_memory) { 
for one device (one interface).  The device 
if (!ipw) 
if (!ipw->hardware) { 
if (ret != 0) { 
if (ipw->tty != NULL) 
if (ipw->network != NULL) 
if (ipw->hardware != NULL) 
if (ret != 0) 
if (ret != 0) 
file : ./test/kernel/drivers/ssb/main.c 
[ OK ] open : 4 ok... 
buf : /*
for details. 
form_device.h> 
if running buses */ 
ifferences in the codeflow, if the bus is 
ifdef CONFIG_SSB_PCIHOST 
for_each_entry(bus, &buses, list) { 
if /* CONFIG_SSB_PCIHOST */ 
for_each_entry(bus, &buses, list) { 
if /* CONFIG_SSB_PCMCIAHOST */ 
for_each_entry(bus, &buses, list) { 
if /* CONFIG_SSB_SDIOHOST */ 
for_each_bus_call(unsigned long data, 
for_each_entry(bus, &buses, list) { 
if (res >= 0) { 
if (dev) 
if (dev) 
if (dev->driver) { 
if (ssb_drv && ssb_drv->resume) 
if (err) 
if (dev->driver) { 
if (ssb_drv && ssb_drv->suspend) 
if (err) 
formation in memory, so that HW is 
ifdef CONFIG_SSB_DRIVER_PCICORE 
if 
if (err) 
if (err) { 
ifdef CONFIG_SSB_SPROM 
for (i = 0; i < bus->nr_devices; i++) { 
if (!sdev->dev || !sdev->dev->driver || 
if (SSB_WARN_ON(!sdrv->remove)) 
for (i = 0; i < bus->nr_devices; i++) { 
if (SSB_WARN_ON(!sdev->dev || !sdev->dev->driver)) 
if (SSB_WARN_ON(!sdrv || !sdrv->probe)) 
if (err) { 
if /* CONFIG_SSB_SPROM */ 
if (!dev->driver) 
if (ssb_drv && ssb_drv->shutdown) 
if (ssb_drv && ssb_drv->remove) 
if (ssb_drv && ssb_drv->probe) 
if (err) 
if ((tabid->vendor != devid->vendor) && 
if ((tabid->coreid != devid->coreid) && 
if ((tabid->revision != devid->revision) && 
for (id = ssb_drv->id_table; 
if (ssb_match_devid(id, &ssb_dev->id)) 
if (!dev) 
format_string) \ 
format_string, dev_to_ssb_dev(dev)->field); \ 
if (!ssb_is_early_boot) 
if (!ssb_is_early_boot) 
for (i = bus->nr_devices - 1; i >= 0; i--) { 
if (sdev->dev) 
ifdef CONFIG_SSB_EMBEDDED 
form_device_unregister(bus->watchdog); 
if (err == -EBUSY) 
if (err) 
for (i = 0; i < bus->nr_devices; i++) { 
for them are built into SSB. */ 
if (!devwrap) { 
ifdef CONFIG_SSB_PCIHOST 
if 
ifdef CONFIG_SSB_PCMCIAHOST 
if 
ifdef CONFIG_SSB_SDIOHOST 
if 
if (err) { 
ifdef CONFIG_SSB_DRIVER_MIPS 
form_device_register(&ssb_pflash_dev); 
if 
if (bus->mipscore.sflash.present) { 
form_device_register(&ssb_sflash_dev); 
if 
for_each_entry_safe(bus, n, &attach_queue, list) { 
for embedded systems 
if (err) 
if (bus->bustype == SSB_BUSTYPE_SSB) 
if (err == -ENOTSUPP) 
if (err) 
if (err) { 
ifdef CONFIG_SSB_BLOCKIO 
while (count) { 
while (count) { 
while (count) { 
if /* CONFIG_SSB_BLOCKIO */ 
ifdef CONFIG_SSB_BLOCKIO 
while (count) { 
while (count) { 
while (count) { 
if /* CONFIG_SSB_BLOCKIO */ 
for the plain SSB bus without a host-device (no PCI or PCMCIA). */ 
ifdef CONFIG_SSB_BLOCKIO 
if 
if (err) 
ifdef CONFIG_SSB_EMBEDDED 
if 
if (err) 
if any), before the scan */ 
if (err) 
for devices (cores) */ 
if (err) 
if any) */ 
if (err) 
if any) */ 
if (err) 
if available) */ 
if (err) 
if_init(&bus->extif); 
if (err) { 
for attach. 
if (!ssb_is_early_boot) { 
if (err) 
ifdef CONFIG_SSB_PCIHOST 
if (!err) { 
if /* CONFIG_SSB_PCIHOST */ 
if (!err) { 
if /* CONFIG_SSB_PCMCIAHOST */ 
if (!err) { 
if /* CONFIG_SSB_PCMCIAHOST */ 
if (!err) { 
for (i = 0; i < bus->nr_devices; i++) { 
if (ent->id.vendor != dev->id.vendor) 
if (ent->id.coreid != dev->id.coreid) 
if (m & SSB_CHIPCO_CLK_T6_MMASK) 
if (!clock) 
if ((plltype == SSB_PLLTYPE_1) || 
if (!(mc & SSB_CHIPCO_CLK_T2MC_M1BYP)) 
if (!(mc & SSB_CHIPCO_CLK_T2MC_M2BYP)) 
if (!(mc & SSB_CHIPCO_CLK_T2MC_M3BYP)) 
if (bus->chipco.capabilities & SSB_CHIPCO_CAP_PMU) 
if (ssb_extif_available(&bus->extif)) 
if (bus->chipco.dev) 
if (bus->chip_id == 0x5365) { 
if (plltype == SSB_PLLTYPE_3) /* 25Mhz, 2 dividers */ 
ifferent for Backplane rev 2.3 */ 
for the device 
ific_flags) 
ific_flags); 
ific_flags); 
if set. This is a hw bug workaround. */ 
if (val & (SSB_IMSTATE_IBE | SSB_IMSTATE_TO)) { 
ific_flags); 
ific_flags); 
for bitmask in a register to get set or cleared. 
for (i = 0; i < timeout; i++) { 
if (set) { 
if (!(val & bitmask)) 
for bitmask %08X on " 
ific_flags) 
if (ssb_read32(dev, SSB_TMSLOW) & SSB_TMSLOW_RESET) 
if (ssb_read32(dev, SSB_TMSLOW) & SSB_TMSLOW_CLOCK) { 
if (ssb_read32(dev, SSB_IDLOW) & SSB_IDLOW_INITIATOR) { 
ific_flags); 
if (ssb_read32(dev, SSB_IDLOW) & SSB_IDLOW_INITIATOR) { 
ific_flags); 
for PCIe and 64-bit DMA */ 
if (dev->id.coreid == SSB_DEV_80211) { 
if (pci_is_pcie(dev->bus->host_pci) && 
if (ssb_dma_translation_special_bit(dev)) 
if there are 
if (bus->bustype == SSB_BUSTYPE_SSB) 
if (!cc->dev) 
if (cc->dev->id.revision < 5) 
if (err) 
ifdef CONFIG_SSB_DEBUG 
if 
if (err) 
ifdef CONFIG_SSB_DEBUG 
if 
ifdef CONFIG_SSB_DRIVER_PCICORE 
for both, PCI and ChipCommon core, so be careful. */ 
if 
ifdef CONFIG_SSB_DRIVER_PCICORE 
if 
forces an update of the cached registers. */ 
if (err) 
for this and attach them 
if (err) { 
if (err) { 
if (err) { 
fore the ssb drivers. 
file : ./test/kernel/drivers/infiniband/hw/mlx5/main.c 
[ OK ] open : 4 ok... 
buf : /*
forms, with or 
form must reproduce the above 
for_each_entry_safe(eq, n, &dev->eqs_list, list) { 
for (i = 0; i < ncomp_vec; i++) { 
if (!eq) { 
if (err) { 
for_each_entry_safe(eq, n, &dev->eqs_list, list) { 
if (mlx5_destroy_unmap_eq(&dev->mdev, eq)) 
for_each_entry_safe(eq, n, &dev->eqs_list, list) { 
if (mlx5_destroy_unmap_eq(&dev->mdev, eq)) 
if (!in_mad || !out_mad) 
if (err) 
if (flags & MLX5_DEV_CAP_FLAG_BAD_PKEY_CNTR) 
if (flags & MLX5_DEV_CAP_FLAG_BAD_QKEY_CNTR) 
if (flags & MLX5_DEV_CAP_FLAG_APM) 
if (flags & MLX5_DEV_CAP_FLAG_XRC) 
if (flags & MLX5_DEV_CAP_FLAG_SIG_HAND_OVER) { 
for signature handover */ 
if (flags & MLX5_DEV_CAP_FLAG_BLOCK_MCAST) 
if (port < 1 || port > dev->mdev.caps.num_ports) { 
if (!in_mad || !out_mad) 
if (err) { 
if extended speeds (EDR/FDR/...) are supported */ 
if is FDR-10 */ 
if (dev->mdev.caps.ext_port_cap[port - 1] & 
if (err) 
for FDR-10 */ 
if (!in_mad || !out_mad) 
if (err) 
if (err) 
if (!in_mad || !out_mad) 
if (err) 
ify_device(struct ib_device *ibdev, int mask, 
if (mask & ~IB_DEVICE_MODIFY_NODE_DESC) 
if (!(mask & IB_DEVICE_MODIFY_NODE_DESC)) 
if (err) 
ify_port(struct ib_device *ibdev, u8 port, int mask, 
if (err) 
if (!dev->ib_active) 
if (reqlen == sizeof(struct mlx5_ib_alloc_ucontext_req)) 
if (reqlen == sizeof(struct mlx5_ib_alloc_ucontext_req_v2)) 
if (err) 
if (req.flags || req.reserved) 
if (req.total_num_uuars > MLX5_MAX_UUARS) 
if (req.total_num_uuars == 0) 
if (req.num_low_latency_uuars > req.total_num_uuars - 1) 
if (!context) 
if (!uars) { 
if (!uuari->bitmap) { 
for (i = 0; i < gross_uuars; i++) { 
if (uuarn == 2 || uuarn == 3) 
if (!uuari->count) { 
for (i = 0; i < num_uars; i++) { 
if (err) 
if (err) 
for (i--; i >= 0; i--) 
for (i = 0; i < uuari->num_uars; i++) { 
if (vma->vm_end - vma->vm_start != PAGE_SIZE) 
if (idx >= uuari->num_uars) 
if (io_remap_pfn_range(vma, vma->vm_start, pfn, 
if (!in) 
if (err) { 
if (err) 
if (!pd) 
if (err) { 
if (context) { 
if (ib_copy_to_udata(udata, &resp, sizeof(resp))) { 
if (err) { 
if (!pd->uobject) 
if (err) 
if (err) 
if (!in_mad || !out_mad) 
if (err) 
if (err) 
if (port < 1 || port > ibdev->num_ports) { 
if (ibdev->ib_active) 
for (port = 1; port <= dev->mdev.caps.num_ports; port++) 
if (!pprops) 
if (!dprops) 
if (err) { 
for (port = 1; port <= dev->mdev.caps.num_ports; port++) { 
if (err) { 
if (err) 
if (!attr || !init_attr) { 
if (IS_ERR(pd)) { 
for sync UMR QP\n"); 
if (IS_ERR(mr)) { 
for sync UMR QP\n"); 
if (IS_ERR(cq)) { 
for sync UMR QP\n"); 
ify_cq(cq, IB_CQ_NEXT_COMP); 
if (IS_ERR(qp)) { 
ify_qp(qp, attr, IB_QP_STATE | IB_QP_PKEY_INDEX | 
if (ret) { 
ify_qp(qp, attr, IB_QP_STATE, NULL); 
ify umr QP to rtr\n"); 
ify_qp(qp, attr, IB_QP_STATE, NULL); 
ify umr QP to rts\n"); 
if (ret) { 
if (IS_ERR(devr->p0)) { 
if (IS_ERR(devr->c0)) { 
if (IS_ERR(devr->x0)) { 
if (IS_ERR(devr->x1)) { 
if (IS_ERR(devr->s0)) { 
if (!dev) 
if (prof_sel >= ARRAY_SIZE(profile)) { 
if (err) 
if (err) 
if (err) 
ify_device	= mlx5_ib_modify_device; 
ify_srq		= mlx5_ib_modify_srq; 
ify_qp		= mlx5_ib_modify_qp; 
ify_cq		= mlx5_ib_modify_cq; 
ify_cq	= mlx5_ib_arm_cq; 
if (mdev->caps.flags & MLX5_DEV_CAP_FLAG_XRC) { 
if (err) 
if (err) 
if (err) 
if (err) 
for (i = 0; i < ARRAY_SIZE(mlx5_class_attributes); i++) { 
if (err) 
file : ./test/kernel/drivers/infiniband/hw/mlx4/main.c 
[ OK ] open : 4 ok... 
buf : /*
forms, with or 
form must reproduce the above 
if_vlan.h> 
if sm_guid_assign > 0 (Default: 1)"); 
if (dmfs) { 
foreach_port(i, dev, MLX4_PORT_TYPE_ETH) 
foreach_port(i, dev, MLX4_PORT_TYPE_IB) 
if (ib_num_ports && mlx4_is_mfunc(dev)) { 
for IB port in multifunction env.\n"); 
if (!in_mad || !out_mad) 
if (err) 
if (dev->dev->caps.flags & MLX4_DEV_CAP_FLAG_BAD_PKEY_CNTR) 
if (dev->dev->caps.flags & MLX4_DEV_CAP_FLAG_BAD_QKEY_CNTR) 
if (dev->dev->caps.flags & MLX4_DEV_CAP_FLAG_APM) 
if (dev->dev->caps.flags & MLX4_DEV_CAP_FLAG_UD_AV_PORT) 
if (dev->dev->caps.flags & MLX4_DEV_CAP_FLAG_IPOIB_CSUM) 
if (dev->dev->caps.max_gso_sz && dev->dev->caps.flags & MLX4_DEV_CAP_FLAG_BLH) 
if (dev->dev->caps.bmme_flags & MLX4_BMME_FLAG_RESERVED_LKEY) 
if ((dev->dev->caps.bmme_flags & MLX4_BMME_FLAG_LOCAL_INV) && 
if (dev->dev->caps.flags & MLX4_DEV_CAP_FLAG_XRC) 
if (dev->dev->caps.flags & MLX4_DEV_CAP_FLAG_MEM_WINDOW) 
if (dev->dev->caps.bmme_flags & MLX4_BMME_FLAG_TYPE_2_WIN) { 
if (dev->steering_support ==  MLX4_STEERING_MODE_DEVICE_MANAGED) 
ifc_flags = MLX4_MAD_IFC_IGNORE_KEYS; 
if (!in_mad || !out_mad) 
if (mlx4_is_mfunc(to_mdev(ibdev)->dev) && netw_view) 
ifc_flags, port, NULL, NULL, 
if (err) 
if (netw_view) 
if extended speeds (EDR/FDR/...) are supported */ 
if is FDR-10 */ 
ifc_flags, port, 
if (err) 
for FDR-10 */ 
if the IB link is down. */ 
if (IS_ERR(mailbox)) 
if (err) 
if (!ndev) 
if_running(ndev) && netif_carrier_ok(ndev)) ? 
ifc_flags = MLX4_MAD_IFC_IGNORE_KEYS; 
if (!in_mad || !out_mad) 
if (mlx4_is_mfunc(dev->dev) && netw_view) 
ifc_flags, port, NULL, NULL, in_mad, out_mad); 
if (mlx4_is_mfunc(dev->dev) && !netw_view) { 
ifc_flags, port, 
if (err) 
if (clear) 
if (rdma_port_get_link_layer(ibdev, port) == IB_LINK_LAYER_INFINIBAND) 
ifc_flags = MLX4_MAD_IFC_IGNORE_KEYS; 
if (!in_mad || !out_mad) 
if (mlx4_is_mfunc(to_mdev(ibdev)->dev) && netw_view) 
ifc_flags, port, NULL, NULL, 
if (err) 
ify_device(struct ib_device *ibdev, int mask, 
if (mask & ~IB_DEVICE_MODIFY_NODE_DESC) 
if (!(mask & IB_DEVICE_MODIFY_NODE_DESC)) 
if (mlx4_is_slave(to_mdev(ibdev)->dev)) 
if (IS_ERR(mailbox)) 
if (IS_ERR(mailbox)) 
if (dev->dev->flags & MLX4_FLAG_OLD_PORT_CMDS) { 
ify_port(struct ib_device *ibdev, u8 port, int mask, 
if this is RoCE. CM calls ib_modify_port() regardless 
if (is_eth) 
if (err) 
if (!dev->ib_active) 
if (ibdev->uverbs_abi_ver == MLX4_IB_UVERBS_NO_DEV_CAPS_ABI_VERSION) { 
if (!context) 
if (err) { 
if (ibdev->uverbs_abi_ver == MLX4_IB_UVERBS_NO_DEV_CAPS_ABI_VERSION) 
if (err) { 
if (vma->vm_end - vma->vm_start != PAGE_SIZE) 
if (vma->vm_pgoff == 0) { 
if (io_remap_pfn_range(vma, vma->vm_start, 
if (vma->vm_pgoff == 1 && dev->dev->caps.bf_reg_size != 0) { 
if (io_remap_pfn_range(vma, vma->vm_start, 
if (!pd) 
if (err) { 
if (context) 
if (!(to_mdev(ibdev)->dev->caps.flags & MLX4_DEV_CAP_FLAG_XRC)) 
if (!xrcd) 
if (err) 
if (IS_ERR(xrcd->pd)) { 
if (IS_ERR(xrcd->cq)) { 
if (!ge) 
if (mlx4_ib_add_mc(mdev, mqp, gid)) { 
if (!mqp->port) 
if (ndev) 
if (ndev) { 
if (mlx4_map_sw_to_hw_steering_id(dev, type) < 0 || 
for (i = 0; i < sizeof(default_table)/sizeof(default_table[0]); i++, 
if (link_layer != pdefault_rules->link_layer) 
for (j = 0, k = 0; k < IB_FLOW_SPEC_SUPPORT_LAYERS && 
ifferent type */ 
if (current_flow->type == 
for (j = 0; j < flow_attr->num_of_specs; 
for (k = 0; k < IB_FLOW_SPEC_SUPPORT_LAYERS; k++) 
if (((union ib_flow_spec *)ib_flow)->type == 
for (i = 0; i < sizeof(pdefault_rules->rules_create_list)/ 
if (ret < 0) { 
if (flow_attr->priority > MLX4_IB_FLOW_MAX_PRIO) { 
if (domain >= IB_FLOW_DOMAIN_NUM) { 
if (mlx4_map_sw_to_hw_steering_mode(mdev->dev, flow_type) < 0) 
if (IS_ERR(mailbox)) 
if (default_flow >= 0) { 
if (ret < 0) { 
for (i = 0; i < flow_attr->num_of_specs; i++) { 
if (ret < 0) { 
if (ret == -ENOMEM) 
if (ret == -ENXIO) 
if (ret) 
if (err) 
if (!mflow) { 
while (i < ARRAY_SIZE(type) && type[i]) { 
if (err) 
while (i < ARRAY_SIZE(mflow->reg_id) && mflow->reg_id[i]) { 
if (err) 
if (mdev->dev->caps.steering_mode == 
if (!ib_steering) 
if (err) 
if (err) 
if (ib_steering) { 
for_each_entry_safe(ge, tmp, &qp->gid_list, list) { 
if (mdev->dev->caps.steering_mode == 
for_each_entry(ib_steering, &mqp->steering_rules, list) { 
if (&ib_steering->list == &mqp->steering_rules) { 
for mgid. Steering rule is left attached\n"); 
if (err) 
if (ge) { 
if (ndev) 
if (ndev) 
ifc_flags = MLX4_MAD_IFC_IGNORE_KEYS; 
if (!in_mad || !out_mad) 
if (mlx4_is_master(dev->dev)) 
ifc_flags, 1, NULL, NULL, in_mad, out_mad); 
ifc_flags, 1, NULL, NULL, in_mad, out_mad); 
ifid_eui48(u8 *eui, u16 vlan_id, 
if (vlan_id < 0x1000) { 
if (IS_ERR(mailbox)) { 
if (err) 
if (IS_ERR(mailbox)) { 
if (mlx4_ib_port_link_layer(&gw->dev->ib_dev, gw->port) == 
if (err) 
if (default_gid) { 
for (i = 1; i < max_gids; ++i) { 
if (clear) { 
if (found >= 0) 
if (free < 0 && 
if (found == -1 && !clear && free >= 0) { 
if (!need_update) 
if (!work) 
ifid_eui48(&gid->raw[8], 0xffff, dev); 
if (!work) 
if (!memcmp(gid, &default_gid, sizeof(*gid))) 
if (event != NETDEV_DOWN && event != NETDEV_UP) 
if ((real_dev != event_netdev) && 
for (port = 1; port <= ibdev->dev->caps.num_ports; ++port) 
if_is_bond_master(real_dev) && 
for (port = 1; port <= ibdev->dev->caps.num_ports; ++port) 
if_is_bond_master(real_dev) && 
if ((port == 0) || (port > ibdev->dev->caps.num_ports)) 
ifier_block *this, unsigned long event, 
ifaddr *ifa = ptr; 
ifa->ifa_dev->dev; 
if IS_ENABLED(CONFIG_IPV6) 
ifaddr *ifa = ptr; 
ifa->idev->dev; 
if 
if (qp) { 
if (new_smac == old_smac) 
if (new_smac_index < 0) 
if (mlx4_update_qp(ibdev->dev, &qp->mqp, MLX4_UPDATE_QP_SMAC, 
if (release_mac != MLX4_IB_INVALID_MAC) 
if IS_ENABLED(CONFIG_IPV6) 
ifaddr *ifp; 
if ((port == 0) || (port > ibdev->dev->caps.num_ports)) 
if (in_dev) { 
for_ifa(in_dev) { 
ifa->ifa_address, 
ifa(in_dev); 
if IS_ENABLED(CONFIG_IPV6) 
if (in6_dev) { 
ifp, &in6_dev->addr_list, if_list) { 
if 
for (i = 1; i <= ibdev->num_ports; ++i) 
for_each_netdev(&init_net, dev) { 
if (port) 
foreach_ib_transport_port(port, ibdev->dev) { 
if (iboe->netdevs[port - 1]) 
if (iboe->netdevs[port - 1] && 
if (dev == iboe->netdevs[port - 1] && 
if (curr_netdev) { 
if using bonding/team and a slave port is down, we don't the bond IP 
if (curr_master && (port_state == IB_PORT_DOWN)) { 
if bonding is used it is possible that we add it to masters 
if (curr_master && (old_master != curr_master)) { 
if (!curr_master && (old_master != curr_master)) { 
if (update_qps_port > 0) 
ifier_block *this, 
ifier_info_to_dev(ptr); 
if (!net_eq(dev_net(dev), &init_net)) 
if (mlx4_is_master(ibdev->dev)) { 
for (slave = 0; slave <= ibdev->dev->num_vfs; ++slave) { 
for (i = 0; 
for (port = 1; port <= ibdev->dev->caps.num_ports; ++port) { 
if (dev->caps.comp_pool == 0 || 
foreach_port(i, dev, MLX4_PORT_TYPE_IB) 
if (!ibdev->eq_table) 
foreach_port(i, dev, MLX4_PORT_TYPE_IB) { 
ific name (per ring) */ 
for (i = 0, eq = added_eqs; i < dev->caps.num_comp_vectors; i++) 
if (!ibdev->eq_table) 
for (i = 0; i < ibdev->eq_added; i++) { 
if (ibdev->eq_table[i] <= dev->caps.num_comp_vectors) 
foreach_ib_transport_port(i, dev) 
if (num_ports == 0) 
if (!ibdev) { 
if (mlx4_pd_alloc(dev, &ibdev->priv_pdn)) 
if (mlx4_uar_alloc(dev, &ibdev->priv_uar)) 
if (!ibdev->uar_map) 
if (dev->caps.userspace_caps) 
ify_device	= mlx4_ib_modify_device; 
ify_srq	= mlx4_ib_modify_srq; 
ify_qp		= mlx4_ib_modify_qp; 
ify_cq		= mlx4_ib_modify_cq; 
ify_cq	= mlx4_ib_arm_cq; 
if (!mlx4_is_slave(ibdev->dev)) { 
if (dev->caps.flags & MLX4_DEV_CAP_FLAG_MEM_WINDOW || 
if (dev->caps.flags & MLX4_DEV_CAP_FLAG_XRC) { 
if (check_flow_steering_support(dev)) { 
if (init_node_data(ibdev)) 
for (i = 0; i < ibdev->num_ports; ++i) { 
if (mlx4_ib_port_link_layer(&ibdev->ib_dev, i + 1) == 
if (err) 
foreach_port(i, dev, MLX4_PORT_TYPE_IB) 
if (ibdev->steering_support == MLX4_STEERING_MODE_DEVICE_MANAGED && 
if (err) 
if (!ibdev->ib_uc_qpns_bitmap) { 
if (err) 
if (ib_register_device(&ibdev->ib_dev, NULL)) 
if (mlx4_ib_mad_init(ibdev)) 
if (mlx4_ib_init_sriov(ibdev)) 
if (dev->caps.flags & MLX4_DEV_CAP_FLAG_IBOE) { 
ifier_call = mlx4_ib_netdev_event; 
if (err) { 
if; 
if (!iboe->nb_inet.notifier_call) { 
ifier(&iboe->nb_inet); 
ifier_call = NULL; 
if IS_ENABLED(CONFIG_IPV6) 
ifier_call = mlx4_ib_inet6_event; 
if (err) { 
if; 
if 
for (i = 1 ; i <= ibdev->num_ports ; ++i) 
for (j = 0; j < ARRAY_SIZE(mlx4_class_attributes); ++j) { 
if; 
if (mlx4_is_mfunc(ibdev->dev)) 
for any VFs which are active */ 
for (j = 0; j < MLX4_MFUNC_MAX; j++) { 
if (mlx4_is_slave_active(ibdev->dev, j)) 
if: 
if (unregister_netdevice_notifier(&ibdev->iboe.nb)) 
ifier_call = NULL; 
if (unregister_inetaddr_notifier(&ibdev->iboe.nb_inet)) 
ifier_call = NULL; 
if (ibdev->iboe.nb_inet6.notifier_call) { 
ifier\n"); 
if 
if (ibdev->steering_support == MLX4_STEERING_MODE_DEVICE_MANAGED) 
for (; i; --i) 
if (offset < 0) 
if (!qpn || 
if (is_attach) { 
if (!flow) 
for IB L2 */ 
if (ibdev->iboe.nb.notifier_call) { 
ifier\n"); 
if (ibdev->steering_support == MLX4_STEERING_MODE_DEVICE_MANAGED) { 
if (ibdev->iboe.nb_inet.notifier_call) { 
ifier\n"); 
if IS_ENABLED(CONFIG_IPV6) 
if (unregister_inet6addr_notifier(&ibdev->iboe.nb_inet6)) 
ifier_call = NULL; 
for (p = 0; p < ibdev->num_ports; ++p) 
foreach_port(p, dev, MLX4_PORT_TYPE_IB) 
if (!mlx4_is_master(dev)) 
if (!dm) { 
for tunneling qp update\n"); 
for (i = 0; i < ports; i++) { 
if (!dm[i]) { 
for tunneling qp update work struct\n"); 
if (dm[i]) 
for the slave */ 
if (!ibdev->sriov.is_going_down) 
if (event == MLX4_DEV_EVENT_PORT_MGMT_CHANGE) 
if (p > ibdev->num_ports) 
if (mlx4_is_master(dev) && 
if (p > ibdev->num_ports) 
if (!ew) { 
for events work\n"); 
for port owner, which uses GEN_EQE */ 
if (!wq) 
if (err) 
if (err) 
file : ./test/kernel/drivers/misc/mei/main.c 
[ OK ] open : 4 ok... 
buf : /*
ify it 
for 
iffies.h> 
if (!misc->parent) 
if (!dev) 
if (dev->dev_state != MEI_DEV_ENABLED) { 
if (!cl) 
if (err) 
if (WARN_ON(!cl || !cl->dev)) 
if (cl == &dev->iamthif_cl) { 
if (cl->state == MEI_FILE_CONNECTED) { 
if (cl->read_cb) { 
if (cb) 
if (WARN_ON(!cl || !cl->dev)) 
if (dev->dev_state != MEI_DEV_ENABLED) { 
if (length == 0) { 
if (cl == &dev->iamthif_cl) { 
if (cl->read_cb) { 
if (cb->buf_idx > *offset) 
if (cb->buf_idx > 0 && cb->buf_idx <= *offset) { 
for contiguous reads*/ 
if (*offset > 0) { 
if (err && err != -EBUSY) { 
if (MEI_READ_COMPLETE != cl->reading_state && 
if (file->f_flags & O_NONBLOCK) { 
if (wait_event_interruptible(cl->rx_wait, 
if (signal_pending(current)) 
if (mei_cl_is_transitioning(cl)) { 
if (!cb) { 
if (cl->reading_state != MEI_READ_COMPLETE) { 
if (length == 0 || ubuf == NULL || *offset > cb->buf_idx) { 
if (copy_to_user(ubuf, cb->response_buffer.data + *offset, length)) { 
if ((unsigned long)*offset < cb->buf_idx) 
if (cb_pos) 
if (WARN_ON(!cl || !cl->dev)) 
if (dev->dev_state != MEI_DEV_ENABLED) { 
if (id < 0) { 
if (length == 0) { 
if (length > dev->me_clients[id].props.max_msg_length) { 
if (cl->state != MEI_FILE_CONNECTED) { 
if (cl == &dev->iamthif_cl) { 
if (write_cb) { 
iffies(MEI_IAMTHIF_READ_TIMER); 
if (cl->reading_state == MEI_READ_COMPLETE) { 
if (write_cb) { 
if (cl->reading_state == MEI_IDLE) 
if (!write_cb) { 
if (rets) 
if (rets) { 
if (cl == &dev->iamthif_cl) { 
if (rets) { 
if write failed with status = %d\n", rets); 
if (rets < 0) 
if (WARN_ON(!cl || !cl->dev)) 
if (dev->dev_state != MEI_DEV_ENABLED) { 
if (cl->state != MEI_FILE_INITIALIZING && 
if (i < 0 || dev->me_clients[i].props.fixed_address) { 
if we're connecting to amthif client then we will use the 
if (uuid_le_cmp(data->in_client_uuid, mei_amthif_guid) == 0) { 
if (dev->iamthif_cl.state != MEI_FILE_CONNECTED) { 
if_open_count++; 
if_cl.status; 
if (cmd != IOCTL_MEI_CONNECT_CLIENT) 
if (WARN_ON(!cl || !cl->dev)) 
if (dev->dev_state != MEI_DEV_ENABLED) { 
if (!connect_data) { 
if (copy_from_user(connect_data, (char __user *)data, 
if all is ok, copying the data back to user. */ 
if (copy_to_user((char __user *)data, connect_data, 
ifdef CONFIG_COMPAT 
if 
if (WARN_ON(!cl || !cl->dev)) 
if (!mei_cl_is_connected(cl)) { 
if (cl == &dev->iamthif_cl) 
if (!mei_cl_is_connected(cl)) { 
for mei char device. 
ifdef CONFIG_COMPAT 
if 
if (ret) 
if (mei_dbgfs_register(dev, mei_misc_device.name)) 
file : ./test/kernel/drivers/nfc/nfcmrvl/main.c 
[ OK ] open : 4 ok... 
buf : /*
ify this File in 
if (test_and_set_bit(NFCMRVL_NCI_RUNNING, &priv->flags)) 
if_ops->nci_open(priv); 
if (!test_and_clear_bit(NFCMRVL_NCI_RUNNING, &priv->flags)) 
if_ops->nci_close(priv); 
if (!test_bit(NFCMRVL_NCI_RUNNING, &priv->flags)) 
if_ops->nci_send(priv, skb); 
if_ops *ops, 
if (!priv) 
if_ops = ops; 
if (!priv->ndev) { 
if (rc) { 
if (!skb) 
file : ./test/kernel/drivers/net/wireless/orinoco/main.c 
[ OK ] open : 4 ok... 
buf : /* main.c - (formerly known as dldwd_cs.c, orinoco_cs.c and orinoco.c)
formerly known as dldwd_cs.c, orinoco_cs.c and orinoco.c) 
ific language governing rights and 
forge.net>.  Portions created by David 
for an extended period of time (e.g. suspended, or in 
if it is set, give up on whatever 
if 
if_arp.h> 
formation                                               */ 
for Lucent Orinoco, Prism II based " 
ifdef ORINOCO_DEBUG 
if 
force_monitor; /* = 0 */ 
force_monitor, "Allow monitor mode for all firmware versions"); 
for Ethernet encapsulation over 802.11 */ 
if (priv->prefer_port3) { 
if (orinoco_lock(priv, &flags) != 0) 
if (!err) 
if hw_unavailable is set 
if (orinoco_lock(priv, &flags) != 0) { 
if ((new_mtu < ORINOCO_MIN_MTU) || (new_mtu > ORINOCO_MAX_MTU)) 
if ((new_mtu + ENCAPS_OVERHEAD + sizeof(struct ieee80211_hdr)) > 
if (do_mic) 
if (ntohs(eh->h_proto) > ETH_DATA_LEN) { /* Ethernet-II frame */ 
if (skb_headroom(skb) < ENCAPS_OVERHEAD) { 
for 802.2 headers %d\n", 
for the new header, and copy it in */ 
if (do_mic) { 
if (skb->len % 2) { 
if (!netif_running(dev)) { 
if (netif_queue_stopped(dev)) { 
while transmitter busy!\n", 
if (orinoco_lock(priv, &flags) != 0) { 
while hw_unavailable\n", 
if (!netif_carrier_ok(dev) || 
if (skb->len < ETH_HLEN) 
if (err) 
if (priv->has_alt_txcntl) { 
if (err) { 
if (err) { 
if this isn't done. */ 
if (err) { 
if (tx_control & HERMES_TXCTRL_MIC) { 
if (offset % 2) { 
if (err) { 
if_stop_queue(dev); 
if (err) { 
if (net_ratelimit()) 
if (err == -EIO) 
if (fid != priv->txfid) { 
if_wake_queue(dev); 
if (fid == DUMMY_FID) 
if (err) { 
ifetime 
if (status & (HERMES_TXSTAT_RETRYERR | HERMES_TXSTAT_AGEDERR)) { 
if_wake_queue(dev); 
ifferent APs appear to use 
for some reason */ 
for it (set some address in the 
if 
if (SPY_NUMBER(priv)) { 
if ((fc & IEEE80211_FCTL_TODS) 
if (datalen > IEEE80211_MAX_DATA_LEN + 12) { 
if (!skb) { 
for monitor frame\n", 
if (datalen > 0) { 
if (err) { 
if_rx(skb); 
if (!desc) 
if (err) { 
if (status & HERMES_RXSTAT_BADCRC) { 
if (priv->iw_mode == NL80211_IFTYPE_MONITOR) { 
if (status & HERMES_RXSTAT_UNDECRYPTABLE) { 
if (length < 3) { /* No for even an 802.2 LLC header */ 
if (length > IEEE80211_MAX_DATA_LEN) { 
if (status & HERMES_RXSTAT_MIC) 
for the packet data itself, plus an ethernet 
if (!skb) { 
for Rx\n", 
for it.  The worst 
for aligning the IP header.  */ 
if (err) { 
if (!rx_data) 
if (status & HERMES_RXSTAT_MIC) { 
if (!key) { 
if (memcmp(mic, rxmic, 
ify userspace */ 
if (length >= ENCAPS_OVERHEAD && 
if (fc & IEEE80211_FCTL_FROMDS) 
if (fc & IEEE80211_FCTL_TODS) 
if needed */ 
if_rx(skb); 
if (orinoco_lock(priv, &flags) != 0) 
for_each_entry_safe(rx_data, temp, &priv->rx_list, list) { 
if (suppress_linkstatus) 
if found */ 
for scan results */ 
if (!buf) 
if (orinoco_lock(priv, &flags) != 0) 
if (!priv->bssid_fixed) 
if (strlen(priv->desired_essid) == 0) 
if (err) { 
for the channel of the AP 
for (; offset + atom_len <= len; offset += atom_len) { 
if (memcmp(&atom->bssid, priv->desired_bssid, ETH_ALEN) == 0) { 
if (!found) { 
if (err) 
if (err != 0) 
if (!priv->has_wpa) 
if (err != 0) 
if (ie) { 
if (wrqu.data.length > rem) 
if (wrqu.data.length) 
ify max size or IW_GENERIC_IE_MAX */ 
if (!priv->has_wpa) 
if (err != 0) 
if (ie) { 
if (wrqu.data.length > rem) 
if (wrqu.data.length) 
if (orinoco_lock(priv, &flags) != 0) 
if (!sd) 
if (!sd) 
for_each_entry_safe(sd, temp, &priv->scan_list, list) { 
if (len > 0) { 
formation "event" generated by the card 
formation in question - Jean II */ 
if (err) { 
if (len > sizeof(tallies)) { 
if (err) 
if (len == sizeof(tallies)) 
if (priv->iw_mode == NL80211_IFTYPE_MONITOR) 
if (len != sizeof(linkstatus)) { 
for linkstatus frame (%d bytes)\n", 
if (err) 
if (newstatus == HERMES_LINKSTATUS_AP_OUT_OF_RANGE && 
if (connected) 
if (!ignore_disconnect) 
if (newstatus != priv->last_linkstatus) { 
if (!priv->scan_request && priv->bssid_fixed && 
formation about 
if (len > 4096) { 
for results */ 
if (buf == NULL) { 
if (err) { 
ifdef ORINOCO_DEBUG 
for (i = 1; i < (len * 2); i++) 
if	/* ORINOCO_DEBUG */ 
if (!priv->scan_request) { 
if (len == 0) { 
if (len < (offsetof(struct agere_ext_scan_info, 
if (bss == NULL) 
if (err) 
ific) */ 
for now */ 
formation frame received: " 
if (net_ratelimit()) 
formation frame lost.\n", dev->name); 
if_carrier_off(dev); /* just to make sure */ 
if (err) { 
if (err) { 
if_start_queue(dev); 
if_stop_queue(dev); 
if (!priv->broken_disableport) { 
if (err) { 
if_carrier_off(dev); 
if (priv->do_fw_download && !err) { 
if (err) 
if (!err) 
if ((dev->flags & IFF_PROMISC) || (dev->flags & IFF_ALLMULTI) || 
if (orinoco_lock(priv, &flags) != 0) 
for re-initializing 
if_stop_queue(dev); 
if_carrier_off(dev); 
ify scan cancellation */ 
if (priv->hard_reset) { 
if (err) { 
forming hard reset\n", dev->name, err); 
if (err) { 
while 
if (priv->open && (!priv->hw_unavailable)) { 
if (err) { 
iffies; 
if_device_detach(dev); 
if_tx_lock */ 
if (priv->broken_disableport) { 
if (err) { 
while reconfiguring card\n", dev->name); 
if (err) { 
if (err) { 
while reconfiguring card\n", 
if (err) { 
iffy, 
iffies value the last time we were called */ 
iffy; /* = 0 */ 
if (orinoco_lock(priv, &flags) != 0) { 
for us or not */ 
if (!events) { 
if (jiffies != last_irq_jiffy) 
iffy = jiffies; 
while (events && count--) { 
for now */ 
if (!hermes_present(hw)) { 
if (events & HERMES_EV_TICK) 
if (events & HERMES_EV_WTERR) 
if (events & HERMES_EV_INFDROP) 
if (events & HERMES_EV_INFO) 
if (events & HERMES_EV_RX) 
if (events & HERMES_EV_TXEXC) 
if (events & HERMES_EV_TX) 
if (events & HERMES_EV_ALLOC) 
if defined(CONFIG_PM_SLEEP) && !defined(CONFIG_HERMES_CACHE_FW_ON_INIT) 
ifier, 
ifier); 
fore suspend, and 
if we're downloading firmware. */ 
ifier(struct orinoco_private *priv) 
ifier(&priv->pm_notifier); 
ifier(&priv->pm_notifier); 
ifier(priv) do { } while (0) 
while (0) 
if (err != 0) { 
if (err != 0) { 
if (priv->do_fw_download) { 
if 
if (err) 
if (err != 0) { 
if (priv->has_port3) 
if (priv->has_ibss) 
if (priv->has_wep) 
if (priv->has_wpa) { 
if (orinoco_mic_init(priv)) { 
if (err) 
if (err) { 
if we have it */ 
if (orinoco_wiphy_register(wiphy)) { 
for each network interface 
for each wireless interface 
ific structure for use by the card driver 
if (!wiphy) 
if (sizeof_card) 
ifdef WIRELESS_SPY 
if 
fore anything else touches the 
if defined(CONFIG_HERMES_CACHE_FW_ON_INIT) || defined(CONFIG_PM_SLEEP) 
if 
ifier(priv); 
for use 
if_add(struct orinoco_private *priv, 
if (!dev) 
iftype = NL80211_IFTYPE_STATION; 
ifdef WIRELESS_SPY 
if 
if (ops) 
for setting the MAC addr */ 
if_carrier_off(dev); 
if (ret) 
if_add); 
if_del); 
if the hw is still available. */ 
for_each_entry_safe(rx_data, temp, &priv->rx_list, list) { 
for_each_entry_safe(sd, sdtemp, &priv->scan_list, list) { 
if ((sd->len > 0) && sd->buf) 
ifier(priv); 
if (err) { 
if_device_attach(dev); 
if (priv->open && !priv->hw_unavailable) { 
if (err) 
if (err) 
if_device_detach(dev); 
file : ./test/kernel/drivers/net/wireless/cw1200/main.c 
[ OK ] open : 4 ok... 
buf : /*
for mac80211 ST-Ericsson CW1200 drivers 
ify 
form macaddr=0x00,0x80,0xE1,0x30,0x40,0x50 */ 
form_data MAC address"); 
form_data SDD file"); 
form_data reference clock"); 
ify		= cw1200_sta_notify, 
ifdef CONFIG_PM 
if 
ifdef CONFIG_PM 
for limited wowlan functionalities */ 
if 
if (!hw) 
if (cw1200_ba_rx_tids != -1) 
for all TIDs */ 
for all TIDs */ 
ifdef CONFIG_PM 
if 
if (have_5ghz) 
fore registering wiphy again */ 
if (!sband) 
for (i = 0; i < sband->n_channels; i++) { 
if (macaddr) 
if necessary */ 
if (cw1200_queue_stats_init(&priv->tx_queue_stats, 
for (i = 0; i < 4; ++i) { 
for (; i > 0; i--) 
ifdef CONFIG_PM 
if (err) { 
if 
if (err) { 
ifdef CONFIG_PM 
if 
if (priv->sdd) { 
for (i = 0; i < 4; ++i) 
ifdef CONFIG_PM 
if 
if (!dev) 
if (cw1200_refclk) 
if (cw1200_sdd_path) 
if (err) 
if (err) 
if (wait_event_interruptible_timeout(priv->wsm_startup_done, 
if (err) 
file : ./test/kernel/drivers/net/wireless/libertas/main.c 
[ OK ] open : 4 ok... 
buf : /*
if_arp.h> 
ifo.h> 
ifdef  DEBUG 
if 
if (idx >= sizeof(fw_data_rates)) 
if (!rate) 
for (i = 0; i < sizeof(fw_data_rates); i++) { 
iface_type(struct lbs_private *priv, enum nl80211_iftype type) 
if (priv->wdev->iftype == NL80211_IFTYPE_MONITOR) 
if (!ret) 
if (priv->wdev->iftype == NL80211_IFTYPE_MONITOR) 
if (!ret) 
iface(struct lbs_private *priv) 
if (priv->power_restore) { 
if (ret) 
if (ret) { 
iface_type(priv, priv->wdev->iftype); 
iface type failed\n"); 
if (ret) { 
iface_running = true; 
if (priv->power_save) 
if monitor mode active 
if (!priv->iface_running) { 
if (ret) 
if_carrier_off(dev); 
if_wake_queue(dev); 
iface(struct lbs_private *priv) 
iface_running = false; 
for all commands to complete */ 
if (priv->power_save) 
if (priv->connect_status == LBS_CONNECTED) 
if_stop_queue(dev); 
if (priv->scan_req) 
if_carrier_off(priv->dev); 
iface(priv); 
if commands are pending */ 
if (!priv->wakeup_dev_required) 
if (lbs_iface_active(priv)) 
if (priv->mesh_dev) 
while (list_len) { 
if ((dev->flags & (IFF_UP|IFF_MULTICAST)) != (IFF_UP|IFF_MULTICAST)) 
if_addr_lock_bh(dev); 
for_each_mc_addr(ha, dev) { 
if (i == MRVDRV_MAX_MULTICAST_LIST_SIZE) 
if_addr_unlock_bh(dev); 
if (netif_running(priv->dev)) 
if (priv->mesh_dev && netif_running(priv->mesh_dev)) 
if (dev_flags & IFF_PROMISC) { 
if (dev_flags & IFF_ALLMULTI) { 
if it exists */ 
if (nr_addrs >= 0 && priv->mesh_dev) 
if (nr_addrs < 0) 
if (nr_addrs) { 
if (priv->mac_control != old_mac_control) 
for (;;) { 
if (kthread_should_stop()) 
if (priv->surpriseremoved) 
if (priv->psstate == PS_STATE_SLEEP) 
if (priv->cmd_timed_out) 
if (!priv->fw_ready) 
for it */ 
if (priv->tx_pending_len > 0) 
if (priv->resp_len[priv->resp_idx]) 
if (priv->cur_cmd) 
if (!list_empty(&priv->cmdpendingq) && 
if (kfifo_len(&priv->event_fifo)) 
if (shouldsleep) { 
if (kthread_should_stop()) { 
if (priv->surpriseremoved) { 
if (priv->resp_len[resp_idx]) { 
ifo_len(&priv->event_fifo)) { 
if (kfifo_out(&priv->event_fifo, 
if (priv->wakeup_dev_required) { 
if (priv->exit_deep_sleep(priv)) 
if (priv->cmd_timed_out && priv->cur_cmd) { 
if (!dev->dismantle && priv->reset_card) 
if (!priv->fw_ready) 
if we need to confirm Sleep Request received previously */ 
if (priv->connect_status == LBS_CONNECTED) { 
for firmware sending 
if ((priv->psstate == PS_STATE_SLEEP) || 
if (priv->is_deep_sleep) 
if (!priv->dnld_sent && !priv->cur_cmd) 
if (!priv->dnld_sent && priv->tx_pending_len > 0) { 
if (ret) { 
iffies + (HZ * 5)); 
if (!priv->currenttxskb) { 
for TX feedback */ 
if_wake_queue(priv->dev); 
if_running(priv->mesh_dev)) 
if (ret) 
if available */ 
if (ret == 0) { 
if (ret) 
if (priv->is_deep_sleep) { 
if (ret) { 
if_device_detach(priv->dev); 
if_device_detach(priv->mesh_dev); 
if_device_attach(priv->dev); 
if_device_attach(priv->mesh_dev); 
if (ret) 
if (priv->setup_fw_on_resume) 
if (!priv->cur_cmd) 
if (priv->dnld_sent == DNLD_CMD_SENT) 
if (priv->reset_card) 
if (priv->is_activity_detected) { 
if (priv->is_auto_deep_sleep_enabled && 
iffies + 
if (priv->is_deep_sleep) 
iffies + (priv->auto_deep_sleep_timeout * HZ)/1000); 
if (lbs_allocate_cmd_buffer(priv)) { 
ifo_alloc(&priv->event_fifo, sizeof(u32) * 16, GFP_KERNEL); 
ifo_free(&priv->event_fifo); 
if (IS_ERR(wdev)) { 
iftype = NL80211_IFTYPE_STATION; 
if (lbs_init_adapter(priv)) { 
if (!dev) { 
for network device instance\n"); 
if (IS_ERR(priv->main_thread)) { 
if (priv->wiphy_registered) 
for_firmware_load(priv); 
if (priv->psmode == LBS802_11POWERMODEMAX_PSP) { 
if (priv->is_deep_sleep) { 
if (MRVL_FW_MAJOR_REV(priv->fwrelease) == MRVL_FW_V5) 
if (ret) 
if (!lbs_disablemesh) 
if (lbs_cfg_register(priv)) { 
if (lbs_mesh_activated(priv)) 
if (!priv) 
if (dev->reg_state != NETREG_REGISTERED) 
if_stop_queue(dev); 
if (priv->psstate == PS_STATE_SLEEP) 
ifo_in(&priv->event_fifo, (unsigned char *) &event, sizeof(u32)); 
ify_command_response(struct lbs_private *priv, u8 resp_idx) 
if (priv->psstate == PS_STATE_SLEEP) 
ify_command_response); 
file : ./test/kernel/drivers/net/wireless/brcm80211/brcmsmac/main.c 
[ OK ] open : 4 ok... 
buf : /*
ify, and/or distribute this software for any 
if_ether.h> 
if.h" 
for future when we want to separate 1x1 & 2x2 and 
for fb rate */ 
for PLCPHdr_override */ 
for g_protection_override and n_protection_override */ 
for g_protection_control and n_protection_control */ 
for n_protection */ 
ific 40MHz capabilities */ 
for SGI support (sgi_rx iovar) */ 
ift */ 
ift */ 
format_flags() bit description structure */ 
ifos in HW. 
ifo partition, sw can overwrite if necessary 
fore making changes. 
ifo size table */ 
ifo2ac[] = { 
ifo[] = { 
ifo_sz[][NFIFO] = { 
ifdef DEBUG 
ifo_names[6][0]; 
ifdef DEBUG 
if 
ifo_mapping[IEEE80211_NUM_ACS] = { 
ifos to ieee80211 AC numbers */ 
ifo(u8 ac) 
ifo_mapping[ac]; 
if (fifo >= ARRAY_SIZE(fifo_to_ac_mapping)) 
ifo_to_ac_mapping[fifo]; 
for a given rate */ 
if (is_mcs_rate(rspec)) 
if (is_mcs_rate(rspec)) 
for determining SIFS is the band in use */ 
if aphy is in reset on 4306B0-DB. Need a simple accessible 
forms return all 0). 
if (!wlc->hw->clk) 
ifo tx pending packet counts */ 
for (i = 0; i < ARRAY_SIZE(wlc->hw->di); i++) 
if (CHSPEC_IS40(chanspec)) 
if (CHSPEC_IS20(chanspec)) 
if (cfg == NULL) 
if (wlc == NULL) 
if (wlc->beacon) 
if (wlc->probe_resp) 
if (cfg == NULL) 
if (cfg->current_bss == NULL) 
if (wlc == NULL) { 
if (wlc->pub == NULL) { 
if (wlc->hw == NULL) { 
if (wlc->hw->bandstate[0] == NULL) { 
for (i = 1; i < MAXBANDS; i++) 
if (wlc->modulecb == NULL) { 
if (wlc->default_bss == NULL) { 
if (wlc->bsscfg == NULL) { 
if (wlc->protection == NULL) { 
if (wlc->stf == NULL) { 
if (wlc->bandstate[0] == NULL) { 
for (i = 1; i < MAXBANDS; i++) 
if (wlc->corestate == NULL) { 
if (wlc->corestate->macstat_snapshot == NULL) { 
for standard 11b/g (20us slots) 
for this call. 
if (shortslot) { 
ifs_slot), 0x0207); 
ifs_slot), 0x0212); 
if (rate == 0) { 
if (is_mcs_rate(ratespec)) { 
if (preamble_type == BRCMS_MM_PREAMBLE) 
if (rspec_stc(ratespec) == 0) 
if (wlc->band->bandtype == BRCM_BAND_2G) 
if (is_ofdm_rate(rate)) { 
if (wlc->band->bandtype == BRCM_BAND_2G) 
if (preamble_type & BRCMS_SHORT_PREAMBLE) 
for (i = 0; inits[i].addr != cpu_to_le16(0xffff); i++) { 
if (size == 2) 
if (size == 4) 
for (idx = 0; idx < MHFMAX; idx++) 
ific ucode IHR, SHM, and SCR inits */ 
if (BRCMS_ISNPHY(wlc_hw->band)) 
if (D11REV_IS(wlc_hw->corerev, 24)) { 
if (OFF == clk) {	/* clear gmode bit, put phy into reset */ 
for wlc->band refs in low level code 
if (wlc_hw->sbclk && !wlc_hw->noreset) { 
if (bandunit == 0) 
for ucode with one legitimate case: 
if (!(txs->status & TX_STATUS_AMPDU) 
if (queue >= NFIFO) { 
if (p == NULL) { 
if (txs->phyerr) 
if (txs->frameid != le16_to_cpu(txh->TxFrameID)) { 
if (tx_info->rate_driver_data[0]) 
if (tx_info->flags & IEEE80211_TX_CTL_AMPDU) { 
for AMPDU 
if (supr_status == TX_STATUS_SUPR_BADCH) { 
if (!lastframe) { 
formation to be consumed by Minstrel ht. 
if (queue < IEEE80211_NUM_ACS) { 
ifo2ac[queue]], 
if (txrate[0].flags & IEEE80211_TX_RC_USE_RTS_CTS) 
if ((tx_frame_count > fbl) && (txrate[1].idx >= 0)) { 
for (i = 2; i < IEEE80211_TX_MAX_RATES; i++) { 
if (txs->status & TX_STATUS_ACK_RCV) 
if (lastframe) { 
if (fatal) { 
if (p) 
if (dma && queue < NFIFO) { 
if (dma->txavail > TX_HEADROOM && queue < TX_BCMC_FIFO && 
if more tx status need to be processed. false otherwise. 
fore 
while (n < max_tx_num) { 
if (s1 == 0xffffffff) { 
if (!(s1 & TXS_V)) 
if (*fatal == true) 
if (wlc->bsscfg->type == BRCMS_TYPE_ADHOC) 
ifunction boards */ 
if (BRCMS_ISNPHY(wlc_hw->band) && NREV_LT(wlc_hw->band->phyrev, 2)) { 
ifonum) 
ifo64regs[fifonum].dmaxmt); 
ifo 
for dma_attach */ 
if (wlc_hw->di[0] == NULL) {	/* Init FIFOs */ 
fort data packets) 
if with AP defined */ 
for (i = 0; i < NFIFO; i++) 
for (j = 0; j < NFIFO; j++) { 
for_wake(struct brcms_hardware *wlc_hw) 
force fast clock */ 
if (ai_get_cccaps(wlc_hw->sih) & CC_CAP_PMU) { 
if driver wants it to run on HT. 
if (wlc_hw->clk) { 
if ((ai_get_pmurev(wlc_hw->sih) == 0) && 
forcefastclk = (mode == BCMA_CLKMODE_FAST); 
force HT through cc, 
forcefastclk = ai_clkctl_cc(wlc_hw->sih, mode); 
if (wlc_hw->forcefastclk && wlc_hw->clk) 
if forcefastclk is on since we 
for PM mode. Code below matches the wake override bit with 
forcefastclk but only had the 
if (wlc_hw->forcefastclk) 
for no-change write 
if ((val & ~mask) || idx >= MHFMAX) 
if (band) { 
if changed, and 
if (wlc_hw->clk && (band->mhfs[idx] != save) 
if (bands == BRCM_BAND_ALL) { 
ifos = 0; 
if overridden */ 
if needed */ 
if (val & ~mask) 
if the new maccontrol value is the same as the old, nothing to do */ 
if (wlc_hw->wake_override || (wlc_hw->maccontrol & MCTL_WAKE)) { 
for_wake(wlc_hw); 
if (wlc_hw->wake_override || (wlc_hw->maccontrol & MCTL_WAKE)) 
if maccontrol already has AP == 0 and INFRA == 1 without this 
if ((wlc_hw->maccontrol & (MCTL_AP | MCTL_INFRA)) == MCTL_INFRA) 
if (wlc_hw->mute_override == 0) 
if maccontrol already has AP == 0 and INFRA == 1 without this 
if ((wlc_hw->maccontrol & (MCTL_AP | MCTL_INFRA)) == MCTL_INFRA) 
if MCTL_BIGEND bit set in mac control register, 
while (len > 0) { 
if (be_bit) { 
if not on */ 
forcefastclk; 
if (!fastclk) 
if (BRCMS_ISLCNPHY(wlc->band)) 
if (BRCMS_ISNPHY(wlc->band) && (NREV_GE(wlc->band->phyrev, 3))) 
for (i = 0; i < ARRAY_SIZE(rate_lookup); i++) { 
if (!BRCMS_PHY_11N_CAP(wlc_hw->band)) 
for (i = 0; i < ARRAY_SIZE(rates); i++) { 
ify the value */ 
ific init */ 
ific, update hardware 
for current band 
form a soft reset of the PHY PLL */ 
for NPHY only 
for NPHY and HYPHY) only */ 
if (ON == clk) 
if (ON == clk) 
if (pih == NULL) 
ific reset sequence required for NPHY rev 3 and 4 */ 
form a soft reset of the PHY PLL */ 
if (pih) 
fore accessing it */ 
if (!wlc_hw->up) 
ific initializations */ 
if (wlc->macintstatus) 
if (!CONF_HAS(D11CONF, wlc_hw->corerev)) { 
for board type, major, minor, and tiny version */ 
if (ai_get_boardvendor(wlc_hw->sih) != PCI_VENDOR_ID_BROADCOM) 
if (boardrev == 0) 
if (boardrev <= 0xff) 
if ((brt > 2) || (brt == 0) || (b0 > 9) || (b0 == 0) || (b1 > 9) 
if (!is_zero_ether_addr(sprom->il0mac)) { 
if (wlc_hw->_nbands > 1) 
if plldown is false or 
if (!want && wlc_hw->pllreq) 
if (!wlc_hw->sbclk) { 
if (wlc_hw->band && wlc_hw->band->pi) 
if radio is disabled, otherwise false. 
ifferent registers depending on corerev and boardflag. 
if (!xtal) 
if (!clk) { 
if (D11REV_GE(wlc_hw->corerev, 18)) 
if (!clk) 
if (!xtal) 
ifo) 
for fresh new start 
if (flags == BRCMS_USE_COREFLAGS) 
if not on  */ 
forcefastclk; 
if (bcma_core_is_enabled(wlc_hw->d11core)) { 
for (i = 0; i < NFIFO; i++) 
if ((wlc_hw->di[RX_FIFO]) 
if noreset, just stop the psm and return */ 
if (D11REV_GE(wlc_hw->corerev, 18)) 
if necessary. But 
if (wlc_hw->band && wlc_hw->band->pi) 
if (ai_get_cccaps(wlc_hw->sih) & CC_CAP_PMU) 
if (!fastclk) 
ifo sizes needs to be modified(increased) since the newer cores 
ifofixup(struct brcms_hardware *wlc_hw) 
ifo_nu; 
ifo_def, txfifo_def1; 
ifos start at TXFIFO_START_BLK from the Base address */ 
ifo, set fifo size, reset fifo */ 
for (fifo_nu = 0; fifo_nu < NFIFO; fifo_nu++) { 
ifo_def = (txfifo_startblk & 0xff) | 
ifo_def1 = ((txfifo_startblk >> 8) & 0x1) | 
ifo_cmd = 
ifocmd), txfifo_cmd); 
ifodef1), txfifo_def1); 
ifo_startblk += wlc_hw->xmtfifo_sz[fifo_nu]; 
ifo_sz[TX_AC_BE_FIFO]); 
ifo_sz[TX_AC_VI_FIFO]); 
ifo_sz[TX_AC_VO_FIFO] << 8) | wlc_hw-> 
ifo_sz[TX_ATIM_FIFO] << 8) | wlc_hw-> 
for changing the tsf frac register 
if ((ai_get_chip_id(wlc_hw->sih) == BCMA_CHIP_ID_BCM43224) || 
if (spurmode == WL_SPURAVOID_ON2) {	/* 126Mhz */ 
if (spurmode == WL_SPURAVOID_ON1) {	/* 123Mhz */ 
if (BRCMS_ISLCNPHY(wlc_hw->band)) { 
for mimo antenna diversity feature */ 
if (wlc_hw->antsel_type == ANTSEL_2x4) { 
for wiggling out and oe 
if (wlc_hw->boardflags & BFL_PACTRL) 
for (i = 0; i < count; i++) 
if (wlc_hw->ucode_loaded) 
if (D11REV_IS(wlc_hw->corerev, 17) || D11REV_IS(wlc_hw->corerev, 23)) { 
if (D11REV_IS(wlc_hw->corerev, 24)) { 
if up */ 
for phy module to use */ 
ifoerrors(struct brcms_hardware *wlc_hw) 
for (idx = 0; idx < NFIFO; idx++) { 
if (!intstatus) 
if (intstatus & I_RO) { 
if (intstatus & I_PC) { 
if (intstatus & I_PD) { 
if (intstatus & I_DE) { 
if (intstatus & I_RU) 
if (intstatus & I_XU) { 
if (fatal) { 
if (!wlc_hw->clk) 
if (!wlc_hw->clk) 
ifo_suspend(struct brcms_hardware *wlc_hw, 
ifo = 1 << tx_fifo; 
if not already suspended */ 
if not already */ 
ifos |= fifo; 
fore suspending the FIFO 
if (BRCMS_PHY_11N_CAP(wlc_hw->band)) 
ifo]); 
ifo_resume(struct brcms_hardware *wlc_hw, 
for DMA case 
if (wlc_hw->di[tx_fifo]) 
if (wlc_hw->suspended_fifos == 0) 
ifos &= ~(1 << tx_fifo); 
if (mute_tx) { 
ifo_suspend(wlc_hw, TX_DATA_FIFO); 
ifo_suspend(wlc_hw, TX_AC_BK_FIFO); 
ifos */ 
ifo_resume(wlc_hw, TX_CTL_FIFO); 
ifo_resume(wlc_hw, TX_AC_VI_FIFO); 
if (mute_tx) 
if brcms_deviceremoved(wlc) evaluates to true; 
for us, or we are in some special cases; 
if (brcms_deviceremoved(wlc)) 
if (macintstatus == 0xffffffff) 
if not for us */ 
if (macintstatus & MI_DMAINT) 
ifo interrupt enabled is I_RI in 
if they are updated successfully. false otherwise */ 
if (macintstatus == 0xffffffff) 
if this was our interrupt 
if (!wlc_hw->up || !wlc->macintmask) 
if (macintstatus == 0xffffffff) { 
for us */ 
if (wlc_hw->mac_suspend_depth > 1) 
force the core awake */ 
if (mc == 0xffffffff) { 
if (mi == 0xffffffff) { 
if (!(bcma_read32(core, D11REGOFFS(macintstatus)) & MI_MACSSPNDD)) { 
if (mc == 0xffffffff) { 
if (wlc_hw->mac_suspend_depth > 0) 
if (wlc_hw->clk) 
if (val != (u32) 0xaa5555aa) { 
if (val != (u32) 0x55aaaa55) { 
if ((w != (MCTL_IHR_EN | MCTL_WAKE)) && 
if (on) { 
if ((tmp & CCS_ERSRC_AVAIL_HT) != CCS_ERSRC_AVAIL_HT) 
if ((tmp & 
for status to comply. 
if (dev_gone) 
if (wlc_hw->noreset) 
for (i = 0; i < NFIFO; i++) { 
if (i < TX_BCMC_FIFO) 
ifo_to_ac(i)); 
if (offset & 2) 
if (offset & 2) 
ified type . 
if (len <= 0 || (offset & 1) || (len & 1)) 
for (i = 0; i < len; i += 2) { 
ified type to a buffer . 
if (len <= 0 || (offset & 1) || (len & 1)) 
for (i = 0; i < len; i += 2) { 
if (wlc_hw->up) { 
if (set) { 
if (mboolisset(wlc_hw->pllreq, BRCMS_PLLREQ_FLIP)) { 
if (!mboolisset(wlc_hw->pllreq, req_bit)) 
if (mboolisset(wlc_hw->pllreq, BRCMS_PLLREQ_FLIP)) { 
for now */ 
ifdef DEBUG 
if				/* DEBUG */ 
if (!wlc->pub->up) 
ifdef DEBUG 
ifo  underflow count */ 
for (i = 0; i < NFIFO; i++) 
if				/* DEBUG */ 
ifdef DEBUG 
for rx fifo 0 overflow */ 
if (delta) 
ifo underflows */ 
for (i = 0; i < NFIFO; i++) { 
if (delta) 
ifo %d underflows!\n", 
if				/* DEBUG */ 
for (i = 0; i < NFIFO; i++) { 
if (!brcms_deviceremoved(wlc_hw->wlc)) 
fore core reset */ 
for (i = 0; i < NUMPRIO; i++) { 
ifosz_fixup = false; 
ifo allocation. 
ifosz_fixup = true; 
for ucode to self-suspend after auto-init */ 
if ((bcma_read32(core, D11REGOFFS(macintstatus)) & MI_MACSSPNDD) == 0) 
if (D11REV_IS(wlc_hw->corerev, 17) || D11REV_IS(wlc_hw->corerev, 23)) { 
if (D11REV_IS(wlc_hw->corerev, 24)) { 
ifo sizes needs to be modified(increased) */ 
ifofixup(wlc_hw); 
if (buf[TX_AC_BE_FIFO] != wlc_hw->xmtfifo_sz[TX_AC_BE_FIFO]) { 
if (buf[TX_AC_VI_FIFO] != wlc_hw->xmtfifo_sz[TX_AC_VI_FIFO]) { 
if (buf[TX_AC_BK_FIFO] != wlc_hw->xmtfifo_sz[TX_AC_BK_FIFO]) { 
if (buf[TX_AC_VO_FIFO] != wlc_hw->xmtfifo_sz[TX_AC_VO_FIFO]) { 
if (buf[TX_BCMC_FIFO] != wlc_hw->xmtfifo_sz[TX_BCMC_FIFO]) { 
if (buf[TX_ATIM_FIFO] != wlc_hw->xmtfifo_sz[TX_ATIM_FIFO]) { 
if (err != 0) 
ifo_sz[i], i); 
ific inits done by wlc_bsinit() */ 
ifs_ctl), 0x0FFF); 
for (i = 0; i < NFIFO; i++) { 
if not on */ 
forcefastclk; 
ified band and chanspec */ 
ific initialization */ 
ific inits */ 
if (!fastclk) 
for this locale */ 
if (wlc->stf->ss_algosel_auto) 
for (i = 0; i < rateset->count; i++) { 
if (!(rateset->rates[i] & BRCMS_RATE_FLAG)) 
if (rate > BRCM_MAXRATE) { 
for each 
for 
for (i = 0; i < wlc->band->hw_rateset.count; i++) { 
if (br[rate] != 0) { 
if (is_ofdm_rate(rate)) 
if (br[rate] != 0) 
if (is_ofdm_rate(rate)) { 
if (rate >= BRCM_RATE_24M) 
if (rate >= BRCM_RATE_12M) 
if (wlc->bandlocked || wlc->pub->_nbands == 1) { 
ified chanspec */ 
for (i = 0; i < wlc->pub->_nbands; i++) { 
ified filter flags 
if (filter_flags & (FIF_PROMISC_IN_BSS | FIF_OTHER_BSS)) 
if (filter_flags & FIF_BCN_PRBRESP_PROMISC) 
if (filter_flags & FIF_FCSFAIL) 
if (filter_flags & (FIF_CONTROL | FIF_PSPOLL)) 
for ucode and hw 
if (wlc->home_chanspec == wlc_phy_chanspec_get(wlc->band->pi)) { 
for testing, the 
if (BRCMS_PHY_11N_CAP(wlc->band)) 
if we are not on the home channel */ 
for the table we are reading */ 
for the table we are writing */ 
for a given rate, the LS-nibble of the PLCP SIGNAL field is 
for the given incoming rate 
if (BRCMS_PHY_11N_CAP(wlc->band)) { 
if (wlc->band->gmode) 
for (i = 0; i < rs.count; i++) { 
for a given rate brcms_basic_rate returns the rate at 
if (basic_rate == 0) 
ific init */ 
ific mac configuration */ 
formula:  IDLE_BUSY_RATIO_X_16 = (100-duty_cycle)/duty_cycle*16 */ 
if (duty_cycle > 100 || duty_cycle < 0) { 
if (duty_cycle) 
if (writeToShm) 
if (isOFDM) 
fore; 
if (hps) 
fore = ((v1 & MCTL_WAKE) || ((v1 & MCTL_HPS) == 0)); 
for_wake(wlc->hw); 
if (wlc_hw->band->bandtype == BRCM_BAND_2G && wlc_hw->up) { 
for standard 11b/g (20us slots) or shortslot 11g (9us slots). 
if it is set */ 
if (wlc->shortslot == shortslot) 
if (wlc->home_chanspec != chanspec) { 
if (wlc->pub->associated) 
if necessary */ 
if (wlc_hw->band->bandunit != bandunit) { 
if not up yet 
if (wlc_hw->up) { 
if (!wlc_hw->up) { 
if (!wlc->pub->up) 
for at least one beacon before entering sleeping state */ 
ific initializations */ 
if (!brcms_c_valid_chanspec_db(wlc->cmi, chanspec)) { 
if necessary */ 
if (wlc->band->bandunit != bandunit || wlc->bandinit_pending) { 
if (wlc->bandlocked) { 
if the setband updates 
if (brcms_chspec_bw(old_chanspec) != brcms_chspec_bw(chanspec)) { 
for 40Mhz, remove MCS 32 for 20Mhz 
for beacon based on current 
for non-siso rates or default setting, use the available chains */ 
ify debugging, no 
fore wlc is sufficiently initialized. 
if (wlc->pub->up) { 
if (wlc->pub->up) { 
if the core is out of reset and has clocks */ 
for ucode */ 
ifs = (params->aifs & EDCF_AIFSN_MASK); 
ifs < EDCF_AIFSN_MAX) 
if (acp_shm.aifs < EDCF_AIFSN_MIN 
ifs %d\n", wlc->pub->unit, acp_shm.aifs); 
ifs; 
ifo[aci] * 
for (i = 0; i < (int)sizeof(struct shm_acparams); i += 2) 
ifo[aci] * M_EDCF_QLEN + i, 
if (suspend) 
if (suspend) 
for (i_ac = 0; i_ac < IEEE80211_NUM_ACS; i_ac++, edcf_acp++) { 
ifs = edcf_acp->ACI; 
if (suspend) { 
if HWRADIO feature is disabled */ 
if (!wlc->radio_monitor) 
if (wlc->pub->hw_off) 
if (brcms_b_radio_read_hwdisabled(wlc->hw)) 
while driver is "down" */ 
if (brcms_deviceremoved(wlc)) { 
if (!wlc_hw->up) 
for FIFO error interrupts */ 
if (!wlc->pub->up) 
if (brcms_deviceremoved(wlc)) { 
if radio is disable, driver may be down, quit here */ 
if ((wlc->pub->now % SW_TIMER_MAC_STAT_UPD) == 0) 
if (BRCMS_ISNPHY(wlc->band) && 
if (!wlc->wdtimer) { 
for wdtimer " 
if (!wlc->radio_timer) { 
for radio_timer " 
for (i = 0; i < NFIFO; i++) 
if (wlc->asi == NULL) { 
if (wlc->ampdu == NULL) { 
if ((brcms_c_stf_attach(wlc) != 0)) { 
for each core and band 
if (core->bus->hosttype == BCMA_HOSTTYPE_PCI) 
if (wlc_hw->sih == NULL) { 
ify again the device is supported */ 
if (core->bus->hosttype == BCMA_HOSTTYPE_PCI) { 
if (!brcms_c_isgoodchip(wlc_hw)) { 
force fastclock for the rest of attach 
if (!brcms_b_validate_chip_access(wlc_hw)) { 
if (j == BOARDREV_PROMOTABLE) 
if (!brcms_c_validboardtype(wlc_hw)) { 
if (wlc_hw->boardflags & BFL_NOPLLDOWN) 
if (wlc_hw->deviceid == BCM43224_D11N_ID || 
if ((ai_get_chip_id(wlc_hw->sih) == BCMA_CHIP_ID_BCM43225)) 
if (wlc_hw->physhim == NULL) { 
if (!wlc_hw->phy_sh) { 
for each core and band */ 
if present, is 5Ghz 
ifo size */ 
ifo_sz)); 
ifo_sz[(wlc_hw->corerev - XMTFIFOTBL_STARTREV)]; 
for this band */ 
if (wlc_hw->band->pi == NULL) { 
ify good phy_type & supported phy revision */ 
if (NCONF_HAS(wlc_hw->band->phyrev)) 
if (BRCMS_ISLCNPHY(wlc_hw->band)) { 
for incremental update of 
if (!brcms_b_attach_dmapio(wlc, j, wme)) { 
if possible. 
if (is_broadcast_ether_addr(wlc_hw->etheraddr) || 
if ((wlc->band->antgain == -1) && (wlc->pub->sromrev == 1)) { 
for srom rev 1 is 2 dBm (8 qdbm) */ 
if (wlc->band->antgain == -1) { 
ified gain in whole dbm only.  In order 
if (bandtype == BRCM_BAND_5G) 
if ((aa < 1) || (aa > 15)) { 
if we have a single antenna */ 
if (aa == 2) { 
if (bandtype == BRCM_BAND_5G) 
if (wlc->pub->_nbands > 1 && 
ific default rate set */ 
if (wlc->pub->_n_enab & SUPPORT_11N) 
for (i = 0; i < wlc->pub->_nbands; i++) { 
if (band->bandtype == BRCM_BAND_5G) { 
if (bwcap == BRCMS_N_BW_40ALL) 
if (wlc->wdtimer) { 
if (wlc->radio_timer) { 
if (wlc->asi) { 
if (wlc->ampdu) { 
for (i = 0; i < wlc_hw->_nbands; i++) { 
if (wlc_hw->sih) { 
if crystal is turned 
if (wlc == NULL) 
if (!brcms_c_radio_monitor_stop(wlc)) 
if (wlc_hw->wlc->pub->hw_up) 
force fastclock for the remainder of brcms_c_up(). 
form phy that a POR reset has occurred so 
form(wlc_hw->band->pi); 
if ((wlc_hw->boardflags & BFL_FEM) 
if (! 
force fastclock for the remainder of brcms_c_up(). 
if (brcms_b_radio_read_hwdisabled(wlc_hw)) { 
for retransmit/max rate 
if (!wlc->clk) 
for (ac = 0; ac < IEEE80211_NUM_ACS; ac++) 
if (wlc->pub->hw_off || brcms_deviceremoved(wlc)) 
if (!wlc->pub->hw_up) { 
if ((wlc->pub->boardflags & BFL_FEM) 
if (wlc->pub->boardrev >= 0x1250 
for NDIS) don't call 
if (!wlc->pub->radio_disabled) { 
if (status == -ENOMEDIUM) { 
if (bsscfg->type == BRCMS_TYPE_STATION || 
if (wlc->pub->radio_disabled) { 
if (wlc->bandinit_pending) { 
if (!wlc_hw->up) 
if (dev_gone) 
if (!wlc_hw->up) 
if (dev_gone) { 
if (bcma_core_is_enabled(wlc_hw->d11core)) { 
if (!wlc_hw->noreset) { 
if we are already in the going down path */ 
if (!wlc->pub->up) 
for (i = 0; i < BRCMS_MAXMODULES; i++) { 
if (wlc->WDarmed) { 
if N-support is enabled, allow Gmode set as long as requested 
if ((wlc->pub->_n_enab & SUPPORT_11N) && gmode == GMODE_LEGACY_B) 
ify that we are dealing with 2G band and grab the band pointer */ 
if ((wlc->pub->_nbands > 1) && 
if (config) 
if (!rs.count) 
if (ofdm_basic) { 
for (i = 0; i < rs.count; i++) { 
if (wlc->stf->txstreams == WL_11N_3x3) 
if NMODE is ON */ 
if (nmode == WL_11N_3x3) 
for (i = 0; i < wlc->pub->_nbands; i++) 
for bad count value */ 
if (brcms_c_rate_hwrs_filter_sort_validate 
if (brcms_is_mband_unlocked(wlc)) { 
if (brcms_c_rate_hwrs_filter_sort_validate(&new, 
if (wlc->pub->associated) 
if (channel < 0 || channel > MAXCHANNEL) 
if (!brcms_c_valid_chanspec_db(wlc->cmi, chspec)) 
if (!wlc->pub->up && brcms_is_mband_unlocked(wlc)) { 
fore 
if (wlc->pub->up && (wlc_phy_chanspec_get(wlc->band->pi) != chspec)) { 
if (srl < 1 || srl > RETRY_SHORT_MAX || 
for (ac = 0; ac < IEEE80211_NUM_ACS; ac++) { 
if (wlc->pub->associated) 
if (rs->count > BRCMS_NUMRATES) 
if (wlc->pub->_n_enab & SUPPORT_11N) { 
if (wlc->pub->associated) 
if (!bcmerror) 
if (period == 0) 
if we are 
if (wlc->band->bandtype == BRCM_BAND_5G) 
if (wlc->pub->up && wlc->pub->associated) { 
if (wlc->pub->up) { 
if (wlc->shortslot_override == BRCMS_SHORTSLOT_AUTO) 
for (i = 0; i < BRCMS_MAXMODULES; i++) { 
if (wlc == NULL) 
for (i = 0; i < BRCMS_MAXMODULES; i++) { 
if (vendor != PCI_VENDOR_ID_BROADCOM) { 
if (device == BCM43224_D11N_ID_VEN1 || device == BCM43224_CHIP_ID) 
if ((device == BCM43224_D11N_ID) || (device == BCM43225_D11N2G_ID)) 
if (device == BCM4313_D11N2G_ID || device == BCM4313_CHIP_ID) 
if ((device == BCM43236_D11N_ID) || (device == BCM43236_D11N2G_ID)) 
if (chipinfo->id == BCMA_CHIP_ID_BCM4716) 
ific rate encoding for the PLCP SIGNAL field */ 
for a given rate, the LS-nibble of the PLCP SIGNAL field is 
for a BCMC packet.  The frag field is not used 
for MPDU 
for a frame with following frags = 3 SIFS + 2 ACK + next frag time 
ifs; 
ifs; 
if (next_frag_len) { 
ifs; 
if (is_mcs_rate(ratespec)) { 
if (wlc->band->bandtype == BRCM_BAND_2G) 
if (is_ofdm_rate(ratespec)) { 
if (preamble_type & BRCMS_SHORT_PREAMBLE) 
if the specified rate is supported by the specified band. 
if ((band == BRCM_BAND_AUTO) || (band == wlc->band->bandtype)) 
if (wlc->pub->_nbands > 1) 
ified and we are a single band device */ 
if this is a mimo rate */ 
if ((rspec & RSPEC_RATE_MASK) >= MCS_TABLE_SIZE) 
for (i = 0; i < hw_rateset->count; i++) 
if (verbose) 
if (!ismcs) 
if ((wlc->pub->_n_enab & SUPPORT_11N) && ismcs) { 
if (stf > PHY_TXC1_MODE_SDM) { 
if (rate == 32) { 
if (rate > HIGHEST_SINGLE_STREAM_MCS) { 
if (stf != PHY_TXC1_MODE_SDM) { 
for mcs %d\n", 
for 
if ((stf > PHY_TXC1_MODE_STBC) || 
if (is_ofdm_rate(rate)) { 
if (is_cck_rate(rate)) { 
for non-siso rates */ 
if (ismcs) { 
if (stf == PHY_TXC1_MODE_STBC) { 
for single stream is always 1 */ 
if (override_mcs_only) 
if (issgi) 
if ((rate != 0) 
if necessary. 
for PRQ. 
if ((length << 4) - (usec * 11) > 0) 
if ((length << 3) - (usec * 11) > 0) { 
if ((usec * 11) - (length << 3) >= 8) 
if (rspec_is40mhz(rspec) || (mcs == 32)) 
if (is_mcs_rate(rspec)) 
if (is_ofdm_rate(rspec)) 
for an RTS or CTS frame 
for CTS-TO-SELF w/ frame    = 2 SIFS         + next frame time + 1 ACK 
ifs; 
if (!cts_only) { 
ifs; 
ifs; 
if (ba) 
if (BRCMS_ISLCNPHY(wlc->band)) { 
if (bw < PHY_TXC1_BW_20MHZ) { 
if (is_mcs_rate(rspec)) { 
if (is_cck_rate(rspec) && !BRCMS_ISLCNPHY(wlc->band) 
format 
if (phycfg == -1) { 
ifs = false; 
for use in PLCP computations */ 
if (tx_info->flags & IEEE80211_TX_CTL_ASSIGN_SEQ) { 
if (queue == TX_BCMC_FIFO) { 
for first fragment */ 
for all pkts tx'd in PS mode and for beacons */ 
if rate control algorithm didn't give us a fallback 
if (txrate[1]->idx < 0) 
for (k = 0; k < hw->max_rates; k++) { 
if (!is_mcs) { 
for primay and 
for the frame 
if (!rspec_active(rspec[k])) { 
if (!is_multicast_ether_addr(h->addr1)) { 
if (wlc->pub->_n_enab & SUPPORT_11N) { 
for (k = 0; k < hw->max_rates; k++) { 
if rspec is auto selected 
if (((is_mcs_rate(rspec[k]) && 
if possible */ 
for single stream is always 1 */ 
if (brcms_chspec_bw(wlc->chanspec) == BRCMS_40_MHZ) { 
if (is_mcs_rate(rspec[k])) { 
if ((rspec[k] & RSPEC_RATE_MASK) 
if (wlc->mimo_40txbw != AUTO) 
if dst is using 40 Mhz */ 
if (is_ofdm_rate(rspec[k])) { 
if (wlc->cck_40txbw != AUTO) { 
for probe packets on 
if ((rspec[k] & RSPEC_RATE_MASK) == 32) 
if ((k == 0) || ((k > 0) && is_mcs_rate(rspec[k]))) 
if (txrate[k]->flags & IEEE80211_TX_RC_GREEN_FIELD) 
if ((txrate[k]->flags & IEEE80211_TX_RC_MCS) 
if (is_mcs_rate(rspec[k])) { 
if SGI is selected, then forced mm 
for single stream 
if ((rspec[k] & RSPEC_SHORT_GI) 
if (!is_mcs_rate(rspec[0]) 
for (k = 0; k < hw->max_rates; k++) { 
for nphy, stf of ofdm frames must follow policies */ 
for use with AMPDU's */ 
if ((ieee80211_is_data(h->frame_control) || 
if (is_cck_rate(rspec[1])) { 
for main rate */ 
ifs) { 
if (use_rifs) { 
for fallback rate */ 
if (is_multicast_ether_addr(h->addr1) || use_rifs) 
if (frag == 0) 
if (!is_multicast_ether_addr(h->addr1)) 
if (wlc->band->bandtype == BRCM_BAND_5G) 
if (CHSPEC_IS40(wlc_phy_chanspec_get(wlc->band->pi))) 
if using hardware TKIP MIC */ 
if ((preamble_type[1] == BRCMS_SHORT_PREAMBLE) || 
if (rspec2rate(rspec[1]) != BRCM_RATE_1M) 
for ucode AMPDU aggregation, the new fields are added to 
if (use_rts || use_cts) { 
for (k = 0; k < 2; k++) { 
if (!is_ofdm_rate(rts_rspec[0]) && 
if (!is_ofdm_rate(rts_rspec[1]) && 
if (use_cts) { 
if (use_cts) 
if (use_cts) { 
ifdef SUPPORT_40MHZ 
if ((tx_info->flags & IEEE80211_TX_CTL_AMPDU) && is_mcs_rate(rspec)) 
if 
if ((preamble_type[0] == BRCMS_SHORT_PREAMBLE) || 
if (rspec2rate(rspec[0]) != BRCM_RATE_1M) 
ifted */ 
if (BRCMS_PHY_11N_CAP(wlc->band)) { 
if (use_rts || use_cts) { 
if mixedmode(overloaded with long preamble) 
if they are separated 
if (is_mcs_rate(rspec[0]) && 
if (is_mcs_rate(rspec[1]) && 
if ((scb->flags & SCB_WMECAP) && qos && wlc->edcf_txop[ac]) { 
if (!(tx_info->flags & IEEE80211_TX_CTL_AMPDU) && frag == 0) { 
if (rts) { 
if (use_rifs) { 
if (wlc->edcf_txop[ac] >= (dur - frag_dur)) { 
if (newfragthresh < DOT11_MIN_FRAG_LEN) 
if (newfragthresh > 
if (wlc->fragthresh[queue] != 
for rate %d\n", 
if (dur > wlc->edcf_txop[ac]) 
ifo_names[queue], 
ifo, ret = -ENOSPC; 
ifo = brcms_ac_to_fifo(skb_get_queue_mapping(skb)); 
if (dma->txavail == 0) { 
if there isn't. If we're out of space 
if that happens. 
for tx with no space in DMA ring\n"); 
ifo 
if (fifo == TX_BCMC_FIFO) 
if (frameid != INVALIDFID) { 
form the ucode of the last mcast frame posted 
ifo(wlc, fifo, skb); 
ifo to fail is because 
if it does fail yell loudly. 
ifo; 
ifo = brcms_ac_to_fifo(skb_get_queue_mapping(sdu)); 
if (!brcms_c_tx(wlc, sdu)) 
ifo(struct brcms_c_info *wlc, uint fifo, struct sk_buff *p) 
if (ret	< 0) 
if DMA ring is full. Reserve some free descriptors, 
if (dma->txavail <= TX_HEADROOM && fifo < TX_BCMC_FIFO && 
if (use_rspec) 
if (wlc->band->gmode && wlc->protection->_g && !is_cck_rate(rspec)) 
if the OFDM rate we are protecting is 6 or 9 Mbps, 11 
if (BRCMS_PHY_11N_CAP(wlc->band)) { 
if rspec/rspec_fallback is 40MHz, then send RTS on both 
if (rspec_is40mhz(rspec) && !is_cck_rate(rts_rspec)) 
for ofdm */ 
if (wlc->bcn_li_dtim == 1) 
if ((u16)tsf_l < rx_tsf_0_15) { 
if (rx_tsf_16_31 == 0xffff) 
if (is_mcs_rate(rspec)) { 
if (rspec_is40mhz(rspec)) 
if.c). 
if (rx_status->band == IEEE80211_BAND_5GHZ) 
if (is_cck_rate(rspec)) { 
if (is_ofdm_rate(rspec)) { 
if (plcp3_issgi(plcp[3])) 
if (rxh->RxStatus1 & RXS_DECERR) { 
if (rxh->RxStatus1 & RXS_FCSERR) { 
if (wlc->hw->suspended_fifos) { 
if (ieee80211_is_beacon(hdr->frame_control)) 
for Mixed-mode L-SIG spoofing, return 
if (is_mcs_rate(ratespec)) { 
if (rspec_stc(ratespec) == 0) 
for HT-SIG(2) and HT-STF(1) */ 
ifs; 
ifs = get_sifs(wlc->band); 
for (i = 0; i < rs.count; i++) { 
for the given rate */ 
for the MAC 
ifs; 
for 4 MBSS */ 
if (bcn0) { 
if (bcn1) { 
if (tim_offset != 0) { 
for this config */ 
if both templates are in use, if so sched. an interrupt 
if ((bcma_read32(core, D11REGOFFS(maccommand)) & both_valid) == both_valid) 
if (wlc->beacon_template_virgin) { 
if not clear the int. & remask 
if ((bcma_read32(core, D11REGOFFS(maccommand)) & both_valid) == both_valid) { 
if (!(bcma_read32(core, D11REGOFFS(maccommand)) & MCMD_BCN0VLD)) { 
if (!(bcma_read32(core, D11REGOFFS(maccommand)) & MCMD_BCN1VLD)) { 
for the system. 
if (wlc->pub->up && (bsscfg->type == BRCMS_TYPE_AP || 
if (!wlc->beacon) 
if (!beacon) 
if (wlc->beacon) 
if (!probe_resp) 
if (wlc->probe_resp) 
if (enable) => also deactivate receiving of probe request */ 
if (suspend) 
for probe response frames 
for the call to brcms_c_mod_prb_rsp_rate_table() 
if (suspend) 
if (wlc->pub->up && (bsscfg->type == BRCMS_TYPE_AP || 
if (!wlc->probe_resp) 
ifo_sz_get(struct brcms_hardware *wlc_hw, uint fifo, 
if (fifo >= NFIFO) 
ifo_sz[fifo]; 
if (match_reg_offset == RCM_BSSID_OFFSET) 
for (i = 0; i < NFIFO; i++) { 
if (dmah != NULL) 
for (i = 0; i < ARRAY_SIZE(wlc->hw->di); i++) 
if (wlc->pub->up) 
if more frames need to be processed. false otherwise. 
fore break out. 
for a4 headers or QoS or A-MSDU subframes */ 
if (p->len < 2) { 
if (rxh->RxStatus1 & RXS_FCSERR) { 
if (len < D11_PHY_HDR_LEN + sizeof(h->frame_control)) 
if (is_amsdu) 
if more frames need to be processed. false otherwise. 
fore break out. 
ifo, bool bound) 
if (n >= bound_limit) 
ifo], &recv_frames); 
while (morepending); 
ifo]); 
if another dpc needs to be re-scheduled. false otherwise. 
if (brcms_deviceremoved(wlc)) { 
if (macintstatus & MI_TFS) { 
if (brcms_b_txstatus(wlc->hw, bounded, &fatal)) 
if (fatal) { 
if (macintstatus & (MI_TBTT | MI_DTIM_TBTT)) 
if (macintstatus & MI_ATIMWINEND) { 
if (macintstatus & MI_DMAINT) 
if (macintstatus & MI_BG_NOISE) 
if (macintstatus & MI_GP0) { 
if (macintstatus & MI_TO) 
if (macintstatus & MI_RFDISABLE) { 
if (macintstatus & MI_BCNTPL) 
if macintstatus is non-zero */ 
if associated and up */ 
ifs ? (EDCF_AC_VO_TXOP_AP << 5) : MAXFRAMEBURST_TXOP)); 
ific inits */ 
while the MAC is suspended) */ 
if we have not yet done so */ 
ifos and mute the phy for preism cac time */ 
if they haven't been set by some other 
if (GFIELD(wlc->wme_retries[0], EDCF_SHORT) == 0) { 
for (ac = 0; ac < IEEE80211_NUM_ACS; ac++) 
if (wlc == NULL) 
if defined(DEBUG) 
if 
if (err) 
if (BRCMS_ISNPHY(wlc->band) && (wlc->stf->txstreams == 1)) 
for (i = 0; i < NFIFO; i++) 
for (j = 0; j < wlc->pub->_nbands; j++) { 
if (!brcms_c_attach_stf_ant_init(wlc)) { 
if (wlc->band->bandtype == BRCM_BAND_2G) { 
if (BRCMS_PHY_11N_CAP(wlc->band)) { 
if (err != 0) 
if (!brcms_c_timers_init(wlc, unit)) { 
if (!wlc->cmi) { 
if (BRCMS_SGI_CAP_PHY(wlc)) { 
if (BRCMS_ISSSLPNPHY(wlc->band)) { 
if (perr) 
if (wlc) 
if (perr) 
file : ./test/kernel/drivers/net/wireless/libertas_tf/main.c 
[ OK ] open : 4 ok... 
buf : /*
ify 
ifdef DEBUG 
if 
ific values for the modulation rates. */ 
if (priv->cmd_response_rxed) { 
if (priv->cmd_timed_out && priv->cur_cmd) { 
if (++priv->nr_retries > 10) { 
for immediate resubmission */ 
if (!priv->fw_ready) { 
if (!priv->cur_cmd) 
if (ret) { 
if (!priv->cur_cmd) { 
if = NULL; 
if (lbtf_allocate_cmd_buffer(priv)) 
if 
if ((priv->vif->type == NL80211_IFTYPE_AP) && 
if (priv->skb_to_tx) { 
if (priv->surpriseremoved) { 
if (err) { 
if (!priv->fw_ready) 
if (priv->hw_prog_firmware(card)) 
if (ret) 
if ((priv->fwrelease < LBTF_FW_VER_MIN) || 
for_each_entry(cmdnode, &priv->cmdpendingq, list) { 
while ((skb = skb_dequeue(&priv->bc_ps_buf))) 
if *vif) 
if (priv->vif != NULL) 
if = vif; 
if = NULL; 
if->addr); 
if *vif) 
if (priv->vif->type == NL80211_IFTYPE_AP || 
if = NULL; 
if (conf->chandef.chan->center_freq != priv->cur_freq) { 
if (!mc_count || mc_count > MRVDRV_MAX_MULTICAST_LIST_SIZE) 
for_each(ha, mc_list) 
if (!changed_flags) { 
if (*new_flags & (FIF_PROMISC_IN_BSS)) 
if (*new_flags & (FIF_ALLMULTI) || 
if (multicast) { 
if (priv->nr_of_multicastmacaddr) { 
if (priv->mac_control != old_mac_control) 
if *vif, 
if (changes & (BSS_CHANGED_BEACON | BSS_CHANGED_BEACON_INT)) { 
if); 
if (changes & BSS_CHANGED_BSSID) { 
if (changes & BSS_CHANGED_ERP_PREAMBLE) { 
if (idx != 0) 
if (!(prxpd->status & cpu_to_le16(MRVDRV_RXPD_STATUS_OK))) 
if (prxpd->rx_rate > 4) 
if (need_padding) { 
if (!hw) 
if (lbtf_init_adapter(priv)) 
if (ieee80211_register_hw(hw)) 
if (!(info->flags & IEEE80211_TX_CTL_NO_ACK) && !fail) 
if (!priv->skb_to_tx && skb_queue_empty(&priv->bc_ps_buf)) 
if (priv->vif->type != NL80211_IFTYPE_AP) 
if (skb_queue_empty(&priv->bc_ps_buf)) { 
if))) { 
if (tx_buff_bc) { 
if); 
if (lbtf_wq == NULL) { 
file : ./test/kernel/drivers/net/wireless/ath/carl9170/main.c 
[ OK ] open : 4 ok... 
buf : /*
ify 
for more details. 
ify, and/or distribute this software for any 
for_each_entry_rcu(tid_info, &ar->tx_ampdu_list, list) { 
if (tid_info->state == CARL9170_TID_STATE_SHUTDOWN) { 
while (!list_empty(&tid_gc)) { 
while ((skb = __skb_dequeue(&tid_info->queue))) 
if (drop_queued) { 
for (i = 0; i < ar->hw->queues; i++) { 
while ((skb = skb_dequeue(&ar->tx_pending[i]))) { 
if (info->flags & IEEE80211_TX_CTL_AMPDU) 
for all other outstanding frames to timeout. */ 
for_completion_timeout(&ar->tx_flush, HZ) == 0); 
for_each_entry_rcu(tid_info, &ar->tx_ampdu_list, list) { 
while ((skb = __skb_dequeue(&tid_info->queue))) 
while ((skb = __skb_dequeue(&free))) 
if_info *cvif; 
for (i = 0; i < ar->hw->queues; i++) { 
while (!skb_queue_empty(&ar->tx_status[i])) { 
for (i = 0; i < ar->hw->queues; i++) 
for (i = 0; i < DIV_ROUND_UP(ar->fw.mem_blocks, BITS_PER_LONG); i++) 
if, &ar->vif_list, list) { 
if->beacon); 
ifs = ai_fs;						\ 
while (0) 
iffies; 
if the firmware does not support it. 
for (i = 0; i < ar->hw->queues; i++) { 
if (err) 
if (err) 
if (err) 
if (ar->fw.rx_filter) { 
if (err) 
if (err) 
for (i = 0; i < AR9170_CAM_MAX_USER + 4; i++) { 
if (err) 
if (err) 
if (i < AR9170_CAM_MAX_USER) { 
if (err) 
iffies(msecs_to_jiffies(CARL9170_STAT_WORK))); 
ifdef CONFIG_CARL9170_LEDS 
if /* CONFIG_CARL9170_LEDS */ 
if (IS_ACCEPTING_CMD(ar)) { 
if (!ar->force_usb_reset) { 
if (net_ratelimit()) { 
if (!err && !ar->force_usb_reset) { 
ifferent reset events. 
if (atomic_inc_return(&ar->pending_restarts) > 1) { 
if (!WARN_ON(r == CARL9170_RR_NO_REASON) || 
if (!ar->registered) 
if (!IS_ACCEPTING_CMD(ar) || ar->needs_full_reset) 
force_usb_reset = true; 
if (!IS_STARTED(ar)) 
if (err) 
if *vif) 
if (!vif) { 
if->addr, ETH_ALEN); 
for IBSS RSN is not supported by this driver. 
ify mac80211 and tell 
forget about any HW crypto offload for now. 
if->type != NL80211_IFTYPE_STATION) && 
for P2P. 
if->p2p; 
if *vif) 
if *main_vif, *old_main = NULL; 
if_id = -1, err = 0; 
if (vif_priv->active) { 
if the vif survived the _restart call. 
if_id = vif_priv->id; 
if_priv->beacon); 
for 
if_list is 
if = carl9170_get_main_vif(ar); 
if->type) { 
if (vif->type == NL80211_IFTYPE_STATION) 
if (main_vif->p2p && vif->p2p && 
if; 
if ((vif->type == NL80211_IFTYPE_STATION) || 
if->type == NL80211_IFTYPE_AP) || 
if_id = bitmap_find_free_region(&ar->vif_bitmap, ar->fw.vif_num, 0); 
if_priv[vif_id].id != vif_id); 
if_priv->id = vif_id; 
ifs++; 
if the main interface is being replaced. 
if_priv->list, &ar->vif_list); 
if_priv->list, &ar->vif_list); 
if = carl9170_get_main_vif(ar); 
if_priv); 
if (old_main) { 
if data [id, addr] is safe. 
if (err) 
if); 
if_id, vif->addr); 
if (ar->fw.tx_seq_table) { 
if (err) 
if (err && (vif_id >= 0)) { 
if_bitmap, vif_id, 0); 
if_priv[vif_id].vif, NULL); 
if (ar->vifs > 1) 
if *vif) 
if *main_vif; 
if (WARN_ON_ONCE(!vif_priv->active)) 
ifs--; 
if = carl9170_get_main_vif(ar); 
if_priv->active = false; 
if_priv->enable_beacon = false; 
if_priv[id].vif, NULL); 
if (ar->vifs) { 
if(ar))); 
if_priv->beacon); 
if_bitmap, id, 0); 
if (ar->vifs == 1) 
if (!ar->ps.off_override) 
if (ps != ar->ps.state) { 
if (err) 
if (ar->ps.state && !ps) { 
if (ps) 
iffies; 
if (IS_STARTED(ar)) 
if (noise) { 
if (err) 
if (ar->fw.hw_counters) { 
if (err) 
if (flush) 
if (err) 
iffies(msecs_to_jiffies(CARL9170_STAT_WORK))); 
if (changed & IEEE80211_CONF_CHANGE_LISTEN_INTERVAL) { 
if (changed & IEEE80211_CONF_CHANGE_PS) { 
if (err) 
if (changed & IEEE80211_CONF_CHANGE_SMPS) { 
if (changed & IEEE80211_CONF_CHANGE_CHANNEL) { 
for 5 GHz */ 
if (err) 
if (err) 
if (err) 
if (err) 
ifs_ack(ar); 
if (err) 
if (changed & IEEE80211_CONF_CHANGE_POWER) { 
if (err) 
for_each(ha, mc_list) 
if (!IS_ACCEPTING_CMD(ar)) 
iffer bit and 
if (*new_flags & FIF_ALLMULTI) 
if (multicast != ar->cur_mc_hash) 
if (changed_flags & (FIF_OTHER_BSS | FIF_PROMISC_IN_BSS)) { 
if (ar->fw.rx_filter && changed_flags & ar->rx_filter_caps) { 
if (!ar->fw.ba_filter) 
if (!(*new_flags & (FIF_FCSFAIL | FIF_PLCPFAIL))) 
if (!(*new_flags & FIF_CONTROL)) 
if (!(*new_flags & FIF_PSPOLL)) 
if (!(*new_flags & (FIF_OTHER_BSS | FIF_PROMISC_IN_BSS))) { 
if *vif, 
if_info *vif_priv; 
if_priv = (void *) vif->drv_priv; 
if (WARN_ON(!main_vif)) 
if (changed & BSS_CHANGED_BEACON_ENABLED) { 
if_priv->enable_beacon = bss_conf->enable_beacon; 
if_list, list) { 
if (changed & BSS_CHANGED_BEACON) { 
if (err) 
if (changed & (BSS_CHANGED_BEACON_ENABLED | BSS_CHANGED_BEACON | 
if (main_vif != vif) { 
if->bss_conf.dtim_period; 
fore a hard limit for the broadcast traffic should 
if (vif->type != NL80211_IFTYPE_STATION && 
if (err) 
if (changed & BSS_CHANGED_HT) { 
if (err) 
if (main_vif != vif) 
if (changed & BSS_CHANGED_BSSID) { 
if (err) 
if (changed & BSS_CHANGED_ASSOC) { 
if (err) 
if (changed & BSS_CHANGED_ERP_SLOT) { 
if (err) 
if (changed & BSS_CHANGED_BASIC_RATES) { 
if (err) 
if *vif) 
if (WARN_ON(err)) 
if *vif, 
if (ar->disable_offload || !vif) 
fortunate, because some machines cannot handle 
if (!is_main_vif(ar, vif)) { 
for offloading 
if ((vif->type != NL80211_IFTYPE_STATION && 
if (cmd == SET_KEY) { 
if (!(key->flags & IEEE80211_KEY_FLAG_PAIRWISE)) { 
for (i = 0; i < 64; i++) 
if (i == 64) 
if (err) 
if (key->cipher == WLAN_CIPHER_SUITE_TKIP) { 
if (err) 
if (i < 64) 
if (!IS_STARTED(ar)) { 
if (key->hw_key_idx < 64) { 
if (err) 
if (key->cipher == WLAN_CIPHER_SUITE_TKIP) { 
if (err) 
if (err) 
if (!ar->rx_software_decryption) { 
if *vif, 
if (sta->ht_cap.ht_supported) { 
for station. 
for (i = 0; i < ARRAY_SIZE(sta_info->agg); i++) 
if *vif, 
if (sta->ht_cap.ht_supported) { 
for (i = 0; i < ARRAY_SIZE(sta_info->agg); i++) { 
if (!tid_info) 
if (tid_info->state > CARL9170_TID_STATE_SHUTDOWN) 
if (cleanup) 
if *vif, u16 queue, 
if (queue < ar->hw->queues) { 
if (!IS_STARTED(ar)) 
if *vif, 
if (modparam_noht) 
if (!sta_info->ht_sta) 
if (rcu_dereference(sta_info->agg[tid])) { 
if (!tid_info) { 
if = vif; 
if, sta->addr, tid); 
if (tid_info) { 
if (tid_info->state > CARL9170_TID_STATE_SHUTDOWN) 
if, sta->addr, tid); 
if (tid_info) { 
if (WARN_ON_ONCE(!tid_info)) 
ifdef CONFIG_CARL9170_WPC 
if (!(ar->features & CARL9170_WPS_BUTTON)) 
if (!input) 
if (err) { 
if /* CONFIG_CARL9170_WPC */ 
if (!IS_ACCEPTING_CMD(ar) || !ar->rng.initialized) 
while (count) { 
if (err) 
for (i = 0; i < transfer; i++) 
if (ar->rng.cache_idx >= ARRAY_SIZE(ar->rng.cache)) { 
if (ret) { 
if (ar->rng.initialized) { 
if (WARN_ON(ar->rng.initialized)) 
if (err) { 
if (err) { 
if /* CONFIG_CARL9170_HWRNG */ 
if (!chan) 
if (idx == chan->hw_value) { 
if (err) 
for (b = 0; b < IEEE80211_NUM_BANDS; b++) { 
if (!band) 
for (i = 0; i < band->n_channels; i++) { 
if (ar->channel == chan) 
if (ar->fw.hw_counters) { 
if *vif, 
if_bitmap, ar->fw.vif_num) 
ify(struct ieee80211_hw *hw, 
ify_cmd cmd, 
if (atomic_read(&sta_info->pending_frames)) 
ify		= carl9170_op_sta_notify, 
for rx stream reconstruction. 
if (!skb) 
if (!hw) 
fore we have to _switch_ to a 
ifs = 0; 
for (i = 0; i < ar->hw->queues; i++) { 
if_bitmap, ar->fw.vif_num); 
if (!modparam_noht) { 
if_data_size = sizeof(struct carl9170_vif_info); 
for (i = 0; i < ARRAY_SIZE(ar->noise); i++) 
ifndef __CHECKER__ 
if 
for (i = 0; i < sizeof(ar->eeprom) / RB; i++) { 
if (err) 
if (ar->eeprom.length == cpu_to_le16(0xffff)) 
if (rx_streams != tx_streams) { 
if (ar->eeprom.operating_flags & AR9170_OPFLAG_2GHZ) { 
if (ar->eeprom.operating_flags & AR9170_OPFLAG_5GHZ) { 
if (!bands) 
if (!ar->survey) 
ifier(struct wiphy *wiphy, 
ifier_apply(wiphy, request, &ar->common.regulatory); 
if (WARN_ON(ar->mem_bitmap)) 
if (!ar->mem_bitmap) 
if (err) 
if (err) 
ifier); 
if (modparam_noht) { 
if_num; i++) { 
if_priv[i].vif = NULL; 
if (err) 
if (!ath_is_world_regd(regulatory)) 
ifdef CONFIG_CARL9170_DEBUGFS 
if /* CONFIG_CARL9170_DEBUGFS */ 
if (err) 
ifdef CONFIG_CARL9170_LEDS 
if (err) 
if /* CONFIG_CARL9170_LEDS */ 
if (err) 
if /* CONFIG_CARL9170_WPC */ 
if (err) 
if /* CONFIG_CARL9170_HWRNG */ 
if (!ar->registered) 
ifdef CONFIG_CARL9170_LEDS 
if /* CONFIG_CARL9170_LEDS */ 
if /* CONFIG_CARL9170_DEBUGFS */ 
if (ar->wps.pbc) { 
if /* CONFIG_CARL9170_WPC */ 
if /* CONFIG_CARL9170_HWRNG */ 
file : ./test/kernel/drivers/net/wireless/ath/ath9k/main.c 
[ OK ] open : 4 ok... 
buf : /*
ify, and/or distribute this software for any 
if *vif); 
for "Minimum MPDU Start Spacing": 
for 1/4 us 
for 1 us 
for 4 us 
for 16 us 
if (txq->axq_depth || !list_empty(&txq->axq_acq)) 
if (++sc->ps_usecount != 1) 
if (power_mode != ATH9K_PM_AWAKE) { 
if (--sc->ps_usecount != 0) 
if (sc->ps_idle) { 
if (sc->ps_enabled && 
if (ath9k_hw_btcoex_is_enabled(sc->sc_ah)) 
ifdef CONFIG_ATH9K_BTCOEX_SUPPORT 
if 
if (AR_SREV_9340(sc->sc_ah) || AR_SREV_9330(sc->sc_ah)) 
iffies(ATH_PLL_WORK_INTERVAL)); 
if (!ath_drain_all_txq(sc)) 
if (!ath_stoprecv(sc)) 
if (ath_startrecv(sc) != 0) { 
if (!(sc->hw->conf.flags & IEEE80211_CONF_OFFCHANNEL) && start) { 
if (ah->opmode == NL80211_IFTYPE_STATION && 
for (i = 0; i < ATH9K_NUM_TX_QUEUES; i++) { 
if (!(sc->hw->conf.flags & IEEE80211_CONF_OFFCHANNEL)) { 
if (!hchan) { 
if (!ath_prepare_reset(sc)) 
if (r) { 
if (ath9k_hw_mci_is_enabled(sc->sc_ah) && 
if (!ath_complete_reset(sc, true)) 
if (test_bit(ATH_OP_INVALID, &common->op_flags)) 
if (ah->curchan) 
for the old channel before switching */ 
for the new channel, unless we're switching 
if (!offchannel && sc->cur_survey != &sc->survey[pos]) { 
if (!(sc->survey[pos].filled & SURVEY_INFO_IN_USE)) { 
if (r) 
for the old 
if (old_pos >= 0) 
if on a DFS channel. Spectral 
if (hw->conf.radar_enabled) { 
ific DFS configuration */ 
if requested. */ 
if *vif) 
if = vif; 
if (status & ATH9K_INT_FATAL) { 
if ((ah->config.hw_hang_checks & HW_BB_WATCHDOG) && 
if (ar9003_hw_bb_watchdog_check(ah)) { 
if (status & ATH9K_INT_GTT) { 
if ((sc->gtt_cnt >= MAX_GTT_CNT) && !ath9k_hw_check_alive(ah)) { 
if ((status & ATH9K_INT_TSFOOR) && sc->ps_enabled) { 
if (ah->caps.hw_caps & ATH9K_HW_CAP_EDMA) 
if (status & rxmask) { 
for high priority Rx first */ 
if (status & ATH9K_INT_TX) { 
for the 
if (status & ATH9K_INT_GENTIMER) 
if the IRQ is shared. 
if (test_bit(ATH_OP_INVALID, &common->op_flags)) 
for us */ 
if (test_bit(ATH_OP_HW_RESET, &common->op_flags)) { 
for the interrupt.  Note 
for bits */ 
for me (should have been caught above). 
if (!status) 
if (status & SCHED_INTR) 
if ((status & ATH9K_INT_FATAL) || ((status & ATH9K_INT_RXORN) && 
if ((ah->config.hw_hang_checks & HW_BB_WATCHDOG) && 
ifdef CONFIG_ATH9K_WOW 
if (atomic_read(&sc->wow_sleep_proc_intr) == 0) { 
if 
if (status & ATH9K_INT_TXURN) 
if (status & ATH9K_INT_RXEOL) { 
if (!(ah->caps.hw_caps & ATH9K_HW_CAP_AUTOSLEEP)) 
if (ATH_DBG_WARN_ON_ONCE(sc->ps_idle)) 
if (sched) { 
ifdef CONFIG_ATH9K_DEBUGFS 
if 
if (r) { 
if (ah->caps.hw_caps & ATH9K_HW_CAP_EDMA) 
if (ah->config.hw_hang_checks & HW_BB_WATCHDOG) 
for AR9003/AR9004 chips 
if (AR_SREV_9300_20_OR_LATER(ah)) 
if (ah->caps.hw_caps & ATH9K_HW_CAP_HT) 
if (!ath_complete_reset(sc, false)) 
if (ah->led_pin >= 0) { 
if (sc->ps_enabled) { 
for normal data frames, so we 
if (ieee80211_is_data(hdr->frame_control) && 
for a TX frame while in PS mode\n"); 
if (unlikely(sc->sc_ah->power_mode == ATH9K_PM_NETWORK_SLEEP)) { 
while in 
if needed, also for RX of buffered frames. 
if (!(sc->sc_ah->caps.hw_caps & ATH9K_HW_CAP_AUTOSLEEP)) 
if (ieee80211_is_pspoll(hdr->frame_control)) { 
while the hardware is in full sleep, it first needs a full 
if (unlikely(sc->sc_ah->power_mode == ATH9K_PM_FULL_SLEEP)) { 
while HW is in FULL_SLEEP mode\n"); 
if (ath_tx_start(hw, skb, &txctl) != 0) { 
if (test_bit(ATH_OP_INVALID, &common->op_flags)) { 
fore setting the invalid flag. */ 
if (ah->led_pin >= 0) { 
if (sc->rx.frag) { 
if (!ah->curchan) 
if_iter(void *data, u8 *mac, struct ieee80211_vif *vif) 
if (iter_data->has_hw_macaddr) { 
for (i = 0; i < ETH_ALEN; i++) 
if->type) { 
if_iter(void *data, u8 *mac, struct ieee80211_vif *vif) 
if *avp = (void *)vif->drv_priv; 
if (avp->primary_sta_vif) 
if *vif, 
if (vif) 
if_iter, iter_data); 
if *vif) 
if_iter_data iter_data; 
if, &iter_data); 
if (iter_data.naps > 0) { 
if (iter_data.nmeshes) 
if (iter_data.nwds) 
if (iter_data.nadhocs) 
if ((iter_data.nstations + iter_data.nadhocs + iter_data.nmeshes) > 0) 
if (ah->opmode == NL80211_IFTYPE_STATION && 
if_iter, sc); 
if *vif) 
if *avp = (void *)vif->drv_priv; 
if (config_enabled(CONFIG_ATH9K_TX99)) { 
if = vif; 
ifs++; 
if); 
if (ath9k_uses_beacons(vif->type)) 
if = vif; 
if = vif; 
if *vif, 
if (config_enabled(CONFIG_ATH9K_TX99)) { 
if (ath9k_uses_beacons(vif->type)) 
if->type = new_type; 
if); 
if (ath9k_uses_beacons(vif->type)) 
if *avp) 
if (!avp || !avp->noa.has_next_tsf) 
if (!avp->noa.absent) 
if (target_tsf - tsf < ATH_P2P_PS_STOP_TIME) 
if *vif) 
if *avp = (void *)vif->drv_priv; 
if (avp == sc->p2p_ps_vif) { 
ifs--; 
if (ath9k_uses_beacons(vif->type)) 
if (config_enabled(CONFIG_ATH9K_TX99)) 
if (!(ah->caps.hw_caps & ATH9K_HW_CAP_AUTOSLEEP)) { 
if (config_enabled(CONFIG_ATH9K_TX99)) 
if (!(ah->caps.hw_caps & ATH9K_HW_CAP_AUTOSLEEP)) { 
if (ah->imask & ATH9K_INT_TIM_TIMER) { 
if (config_enabled(CONFIG_ATH9K_TX99)) 
if (!ath9k_hw_ops(ah)->spectral_scan_trigger) { 
for some reason 
if (!ath9k_hw_ops(ah)->spectral_scan_trigger) { 
for "background"? 
if (changed & IEEE80211_CONF_CHANGE_IDLE) { 
if (sc->ps_idle) { 
for STA mode. 
if (changed & IEEE80211_CONF_CHANGE_PS) { 
if (conf->flags & IEEE80211_CONF_PS) 
if (changed & IEEE80211_CONF_CHANGE_MONITOR) { 
if ((changed & IEEE80211_CONF_CHANGE_CHANNEL) || reset_channel) { 
if (changed & IEEE80211_CONF_CHANGE_POWER) { 
if *vif, 
if); 
if->type != NL80211_IFTYPE_AP_VLAN) 
if, sta, &ps_key); 
if *vif, 
if (!an->ps_key) 
if *vif, 
if, sta); 
for (i = 0; i < ARRAY_SIZE(an->key_idx); i++) { 
ify(struct ieee80211_hw *hw, 
ify_cmd cmd, 
if *vif, u16 queue, 
if (queue >= IEEE80211_NUM_ACS) 
ifs = params->aifs; 
ifs: %d, cw_min: %d, cw_max: %d, txop: %d\n", 
if (ret) 
if *vif, 
if (ath9k_modparam_nohwcrypt) 
if ((vif->type == NL80211_IFTYPE_ADHOC || 
for the RSN IBSS group keys. This 
for group addressed 
if (sta) 
if (sta) 
if, sta, key); 
if (key->cipher == WLAN_CIPHER_SUITE_TKIP) 
if (sc->sc_ah->sw_mgmt_crypto && 
if (an && key->hw_key_idx) { 
for (i = 0; i < ARRAY_SIZE(an->key_idx); i++) { 
if (an) { 
for (i = 0; i < ARRAY_SIZE(an->key_idx); i++) { 
if *vif) 
if *avp = (void *)vif->drv_priv; 
if = true; 
if (sc->sc_ah->opmode != NL80211_IFTYPE_STATION) 
if (ath9k_hw_mci_is_enabled(sc->sc_ah)) 
if->addr, common->curbssid); 
if->bss_conf; 
if (test_bit(ATH_OP_PRIM_STA_VIF, &common->op_flags)) 
if (bss_conf->assoc) 
if *avp = sc->p2p_ps_vif; 
if (!avp) 
if (!avp->noa.absent) 
if (!avp->noa.has_next_tsf || 
if = avp->vif; 
if (!sta) 
if (an->sleeping == !!avp->noa.absent) 
if (an->sleeping) 
if *vif) 
if (!sc->p2p_ps_timer) 
if (vif->type != NL80211_IFTYPE_STATION || !vif->p2p) 
if = avp; 
if->bss_conf.p2p_noa_attr, &avp->noa, tsf); 
if *vif, 
if *avp = (void *)vif->drv_priv; 
if (changed & BSS_CHANGED_ASSOC) { 
if (avp->primary_sta_vif && !bss_conf->assoc) { 
if = false; 
if (!test_bit(ATH_OP_PRIM_STA_VIF, &common->op_flags) && 
if (ath9k_hw_mci_is_enabled(sc->sc_ah)) 
if (changed & BSS_CHANGED_IBSS) { 
if ((changed & BSS_CHANGED_BEACON_ENABLED) || 
if, changed); 
if (bss_conf->use_short_slot) 
if (vif->type == NL80211_IFTYPE_AP) { 
for more details 
if (changed & BSS_CHANGED_P2P_PS) { 
if (!(sc->ps_flags & PS_BEACON_SYNC)) 
if (changed & CHECK_ANI) 
if *vif) 
if *vif, 
if *vif) 
if *vif, 
if (!ret) 
if (!flush) 
if (config_enabled(CONFIG_ATH9K_TX99)) 
if (idx == 0) 
if (sband && idx >= sband->n_channels) { 
if (!sband) 
if (!sband || idx >= sband->n_channels) { 
if (config_enabled(CONFIG_ATH9K_TX99)) 
for (i = 0; i < ATH9K_NUM_TX_QUEUES; i++) { 
if (!sc->tx.txq[i].axq_depth) 
if (npend) 
if *vif, 
if (ah->ah_flags & AH_UNPLUGGED) { 
if (test_bit(ATH_OP_INVALID, &common->op_flags)) { 
if (wait_event_timeout(sc->tx_wait, !ath9k_has_tx_pending(sc), 
if (drop) { 
if (!drain_txq) 
for (i = 0; i < ATH9K_NUM_TX_QUEUES; i++) { 
if (ath9k_has_pending_frames(sc, &sc->tx.txq[i])) 
if *vif; 
if = sc->beacon.bslot[0]; 
if (!vif->bss_conf.enable_beacon) 
if->drv_priv; 
if (!bf || !bf->bf_mpdu) 
if (status == -EINPROGRESS) 
for (i = 0; cap && new; i++, cap >>= 1) { 
if (new & BIT(0)) 
if (AR_SREV_9300_20_OR_LATER(ah)) 
if (ah->caps.rx_chainmask != 1) 
if (!validate_antenna_mask(ah, rx_ant) || !tx_ant) 
if (ah->caps.rx_chainmask == 1) 
if not all rx chains are enabled */ 
ify         = ath9k_sta_notify, 
ifdef CONFIG_ATH9K_WOW 
if 
if 
if 
file : ./test/kernel/drivers/net/wireless/ath/ath6kl/main.c 
[ OK ] open : 4 ok... 
buf : /*
ify, and/or distribute this software for any 
if-ops.h" 
if *vif, u8 *node_addr) 
if (is_zero_ether_addr(node_addr)) 
if->nw_type == AP_NETWORK) ? AP_MAX_NUM_STA : 0; 
for (i = 0; i < max_conn; i++) { 
for (ctr = 0; ctr < AP_MAX_NUM_STA; ctr++) { 
if *vif, u8 *mac, u16 aid, 
if->ar; 
if (ielen <= ATH6KL_MAX_IE) 
if, vif->aggr_cntxt, sta->aggr_conn); 
if any */ 
if (sta->mgmt_psq_len != 0) { 
for_each_entry_safe(entry, tmp, &sta->mgmt_psq, list) { 
if (is_zero_ether_addr(mac)) 
if (is_broadcast_ether_addr(mac)) { 
for (i = 0; i < AP_MAX_NUM_STA; i++) { 
for (i = 0; i < AP_MAX_NUM_STA; i++) { 
if (cookie != NULL) { 
for (i = 0; i < MAX_COOKIE_NUM; i++) 
if (!ar || !cookie) 
for this. 
if_diag_read32(ar, address, value); 
for this. 
if_diag_write32(ar, address, value); 
if (WARN_ON(length % 4)) 
for (count = 0; count < length / 4; count++, address += 4) { 
if (ret) 
if (WARN_ON(length % 4)) 
for (count = 0; count < length / 4; count++, address += 4) { 
if (ret) 
if (!buf) 
if (ret) 
if (debug_hdr_addr == 0) { 
for debug_hdr_addr\n"); 
if (ret) 
if (ret) 
if (length != 0 && (le32_to_cpu(debug_buf.length) <= 
if (ret) 
if (ret) 
if (WARN_ON(loop == 0)) { 
while (address != firstbuf); 
if *vif) 
for (index = 0; index <= WMI_MAX_KEY_INDEX; index++) { 
if (index == vif->def_txkey_index) 
if->ar->wmi, vif->fw_vif_idx, 
if->wep_key_list[index].key_len, 
if->wep_key_list[index].key, 
if *vif, u16 channel) 
if->auth_mode) { 
if (vif->prwise_crypto == WEP_CRYPT) 
if (!ik->valid || ik->key_type != WAPI_CRYPT) 
for WAPI, we need to set the delayed group key, continue: */ 
if (!ik->valid) 
for the initial group key for AP mode\n"); 
if->fw_vif_idx, ik->key_index, ik->key_type, 
if (res) { 
if (ar->last_ch != channel) 
ify(vif, channel, WMI_11G_HT20); 
if->flags); 
if *vif, u16 aid, u8 *mac_addr, 
if (assoc_req_len > sizeof(struct ieee80211_hdr_3addr)) { 
if (ieee80211_is_assoc_req(mgmt->frame_control) && 
if (ieee80211_is_reassoc_req(mgmt->frame_control) && 
while (pos && pos + 1 < ies + ies_len) { 
if (pos[0] == WLAN_EID_RSN) 
if (pos[0] == WLAN_EID_VENDOR_SPECIFIC && 
if (pos[5] == 0x01) 
if (pos[5] == 0x04) { 
if (pos[0] == 0x44 && wpa_ie == NULL) { 
for BSS AC Access Delay. As 
if, mac_addr, aid, wpa_ie, 
if->ndev, mac_addr, &sinfo, GFP_KERNEL); 
if *vif = netdev_priv(dev); 
if); 
if (test_bit(CONNECTED, &vif->flags) || 
if->ar->wmi, vif->fw_vif_idx); 
ification. 
if->flags); 
if (strlen(ar->wiphy->fw_version) == 0) { 
if *vif, int status) 
if (status != WMI_SCAN_STATUS_SUCCESS) 
if, aborted); 
if->flags); 
if *vif, u16 channel) 
if->profile.ch = cpu_to_le16(channel); 
if (vif->rsn_capab && 
if->fw_vif_idx, 
if->rsn_capab, 
if->fw_vif_idx, 
if->nw_type); 
if *vif; 
if (!ar->want_ch_switch) 
if, &ar->vif_list, list) { 
if, channel); 
if->fw_vif_idx); 
if->nw_type, res); 
if *vif, u16 channel, u8 *bssid, 
if->ar; 
if->bssid, bssid, sizeof(vif->bssid)); 
if ((vif->nw_type == INFRA_NETWORK)) { 
if->listen_intvl_t, 0); 
if_wake_queue(vif->ndev); 
if->if_lock); 
if->flags); 
if->if_lock); 
if->reconnect_flag = 0; 
if (!ar->usr_bss_filter) { 
if->fw_vif_idx, 
if *vif, u8 keyid, bool ismcast) 
if->ar; 
if (vif->nw_type == AP_NETWORK) { 
if (!sta) 
if->ndev, sta->mac, 
if, keyid, ismcast); 
if->ar; 
if (len < sizeof(*tgt_stats)) 
for (ac = 0; ac < WMM_NUM_AC; ac++) 
if (test_bit(STATS_UPDATE_PEND, &vif->flags)) { 
if *vif, u8 *ptr, u32 len) 
if->ar; 
if (vif->nw_type == AP_NETWORK) { 
for (ac = 0; ac < AP_MAX_NUM_STA; ac++) { 
if, ptr, len); 
if *vif, u8 aid) 
if->ar; 
if (!conn) 
for this station. 
if (psq_empty) 
if (conn->mgmt_psq_len > 0) { 
if->fw_vif_idx, 
if->ndev); 
if (psq_empty) 
if *vif) 
if->ar; 
fore the host could clear the 'Indicate 
if (!ar->sta_list_index) 
if (mcastq_empty) 
for the frame to go out */ 
while ((skb = skb_dequeue(&ar->mcastpsq)) != NULL) { 
if->ndev); 
if->flags); 
if->fw_vif_idx, MCAST_AID, 0); 
if->ar; 
if switching channels */ 
if->fw_vif_idx; 
if->profile.ch); 
if (prot_reason_status == WMI_AP_REASON_MAX_STA) { 
if->ndev, bssid, 
if (prot_reason_status == WMI_AP_REASON_ACL) { 
if->ndev, bssid, 
if (!ath6kl_remove_sta(ar, bssid, prot_reason_status)) 
if no more associated STAs, empty the mcast PS q */ 
if (test_bit(WMI_READY, &ar->flag)) 
if (!is_broadcast_ether_addr(bssid)) { 
if->ndev, bssid, GFP_KERNEL); 
if (memcmp(vif->ndev->dev_addr, bssid, ETH_ALEN) == 0) { 
if->flags); 
if, reason, bssid, 
if->aggr_cntxt->aggr_conn); 
if (reason == DISCONNECT_CMD) { 
if->fw_vif_idx, 
if->flags); 
if->reconnect_flag == 1))) { 
ifs waiting for new channel */ 
if->if_lock); 
if_carrier_off(vif->ndev); 
if ((reason != CSERV_DISCONNECT) || (vif->reconnect_flag != 1)) 
if (reason != CSERV_DISCONNECT) 
if_stop_queue(vif->ndev); 
if->bss_ch = 0; 
if *ath6kl_vif_first(struct ath6kl *ar) 
if (list_empty(&ar->vif_list)) { 
if = list_first_entry(&ar->vif_list, struct ath6kl_vif, list); 
if; 
if *vif = netdev_priv(dev); 
if (test_bit(CONNECTED, &vif->flags)) { 
if_wake_queue(dev); 
if_carrier_off(dev); 
if *vif = netdev_priv(dev); 
if); 
if *vif = netdev_priv(dev); 
if *vif = netdev_priv(dev); 
if ((features & NETIF_F_RXCSUM) && 
format_cmd(ar->wmi, 
if (err) { 
if (!(features & NETIF_F_RXCSUM) && 
format_cmd(ar->wmi, 
if (err) { 
if *vif = netdev_priv(ndev); 
if (!test_bit(WMI_READY, &vif->ar->flag) || 
if (mc_all_on) 
if->flags); 
if->ar->fw_capabilities)) { 
if (!(ndev->flags & IFF_MULTICAST)) { 
if->flags); 
if->flags); 
if->ar->wmi, vif->fw_vif_idx, 
if (ret) { 
if (test_bit(NETDEV_MCAST_ALL_ON, &vif->flags)) 
if->mc_filter, list) { 
for_each_mc_addr(ha, ndev) { 
if (!found) { 
if->ar->wmi, 
if (ret) { 
for_each_mc_addr(ha, ndev) { 
if->mc_filter, list) { 
if (!found) { 
if (!mc_filter) { 
if->ar->wmi, 
if (ret) { 
if->mc_filter); 
file : ./test/kernel/drivers/net/wireless/ath/main.c 
[ OK ] open : 4 ok... 
buf : /*
ify, and/or distribute this software for any 
for Atheros wireless LAN cards."); 
for the 
fortunately this means we may get 8 KB here from the 
if (skb != NULL) { 
if (off != 0) 
format vaf; 
if (common && common->hw && common->hw->wiphy) 
file : ./test/kernel/drivers/net/wireless/ath/wil6210/main.c 
[ OK ] open : 4 ok... 
buf : /*
ify, and/or distribute this software for any 
if_arp.h> 
form - it uses 64-bit transactions 
if (count%4 != 0) it will wrap */ 
for (count += 4; count > 4; count -= 4) 
for (count += 4; count > 4; count -= 4) 
if (sta->status != wil_sta_unused) { 
for (i = 0; i < WIL_STA_TID_NUM; i++) { 
for (i = 0; i < ARRAY_SIZE(wil->vring_tx); i++) { 
if (bssid) { 
if (cid >= 0) /* disconnect 1 peer */ 
for (cid = 0; cid < WIL6210_MAX_CID; cid++) 
iftype) { 
if (test_bit(wil_status_fwconnected, &wil->status)) { 
if (test_bit(wil_status_fwconnecting, &wil->status)) { 
if (bssid) 
if (no_fw_recovery) 
if less then WIL6210_FW_RECOVERY_TO 
if (time_is_after_jiffies(wil->last_fw_recovery + 
for a long time */ 
iffies; 
iftype) { 
for (i = 0; i < WIL6210_MAX_TX_RINGS; i++) { 
if (cid < 0) { 
for connection CID %d\n", cid); 
if (rc == 0) { 
if (!wil->wmi_wq) 
if (!wil->wmi_wq_conn) { 
iffies; 
if (rev_id == 1) { 
if (delay++ > 100) { 
while (hw_state != HW_MACHINE_BOOT_DONE); 
for_fw_ready(struct wil6210_priv *wil) 
for_completion_timeout(&wil->wmi_ready, to); 
iffies_to_msecs(to-left), wil->hw_version); 
if (test_bit(wil_status_napi_en, &wil->status)) { 
if (wil->scan_request) { 
for FW ready */ 
if_carrier_on(ndev); 
if_tx_stop_all_queues(ndev); 
if (rc) 
if (rc) 
iftype) { 
for other commands */ 
if (wil->scan_request) { 
for (i = 0; i < ARRAY_SIZE(wil->sta); i++) { 
file : ./test/kernel/drivers/net/wireless/ath/wcn36xx/main.c 
[ OK ] open : 4 ok... 
buf : /*
ify, and/or distribute this software for any 
form_device.h> 
for .hw_value. */ 
ifdef CONFIG_PM 
if 
if->type ? 
if (x >= ARRAY_SIZE(wcn36xx_caps_names)) 
for (i = 0; i < MAX_FEATURE_SUPPORTED; i++) { 
if (get_feat_caps(wcn->fw_feat_caps, DOT11AC)) { 
if (ret) { 
for Mgmt BD headers and Data BD headers */ 
if (ret) { 
if (ret) { 
if (!wcn->hal_buf) { 
if (ret) { 
if (ret) { 
if (!wcn36xx_is_fw_version(wcn, 1, 2, 2, 24)) { 
if (ret) 
if (ret) { 
if_list); 
if *vif = NULL; 
if (changed & IEEE80211_CONF_CHANGE_CHANNEL) { 
if_list, list) { 
if, 
if, ch); 
if (control->sta) 
if (wcn36xx_start_tx(wcn, sta_priv, skb)) 
if *vif, 
if *vif_priv = (struct wcn36xx_vif *)vif->drv_priv; 
if_priv->encrypt_type = WCN36XX_HAL_ED_WEP40; 
if_priv->encrypt_type = WCN36XX_HAL_ED_WEP40; 
if_priv->encrypt_type = WCN36XX_HAL_ED_CCMP; 
if_priv->encrypt_type = WCN36XX_HAL_ED_TKIP; 
if (WCN36XX_HAL_ED_TKIP == vif_priv->encrypt_type) { 
if (IEEE80211_KEY_FLAG_PAIRWISE & key_conf->flags) { 
if (NL80211_IFTYPE_STATION == vif->type) 
if, 
if_priv->encrypt_type, 
if, sta_priv)); 
if_priv->encrypt_type, 
if ((WLAN_CIPHER_SUITE_WEP40 == key_conf->cipher) || 
if_priv->encrypt_type, 
if, sta_priv)); 
if (!(IEEE80211_KEY_FLAG_PAIRWISE & key_conf->flags)) { 
if_priv->encrypt_type, 
if disassociated */ 
if_priv->encrypt_type, 
if, sta_priv)); 
if (band == IEEE80211_BAND_2GHZ) { 
for (i = 0; i < size; i++) { 
for (i = 0; i < size; i++) { 
if (sta->ht_cap.ht_supported) { 
if *vif, 
if *vif_priv = (struct wcn36xx_vif *)vif->drv_priv; 
if, changed); 
if_priv->dtim_period = bss_conf->dtim_period; 
if (bss_conf->ps) { 
if); 
if (changed & BSS_CHANGED_BSSID) { 
if (!is_zero_ether_addr(bss_conf->bssid)) { 
if_priv->bss_index = 0xff; 
if->addr, WCN36XX_HW_CHANNEL(wcn)); 
if_priv->is_joining = false; 
if (changed & BSS_CHANGED_SSID) { 
if_priv->ssid.length = bss_conf->ssid_len; 
if (changed & BSS_CHANGED_ASSOC) { 
if (bss_conf->assoc) { 
if %pM AID=%d\n", 
if->addr, 
if, bss_conf->bssid); 
if->addr, 
if, sta, 
if, sta); 
if %pM AID=%d\n", 
if->addr, 
if->addr, 
if (changed & BSS_CHANGED_AP_PROBE_RESP) { 
if); 
if, skb); 
if (changed & BSS_CHANGED_BEACON_ENABLED || 
if (bss_conf->enable_beacon) { 
if_priv->bss_index = 0xff; 
if->addr, false); 
if (!skb) { 
if, skb, tim_off, 0); 
if (vif->type == NL80211_IFTYPE_ADHOC || 
if->addr, vif->addr, 
if->addr, vif->addr, 
if); 
if *vif) 
if *vif_priv = (struct wcn36xx_vif *)vif->drv_priv; 
if_priv->list); 
if *vif) 
if *vif_priv = (struct wcn36xx_vif *)vif->drv_priv; 
if, vif->type); 
if->type || 
if->type)) { 
if->type); 
if_priv->list, &wcn->vif_list); 
if *vif, 
if *vif_priv = (struct wcn36xx_vif *)vif->drv_priv; 
if %p sta %pM\n", 
if_priv->sta = sta_priv; 
if (NL80211_IFTYPE_STATION != vif->type) { 
if, sta); 
if *vif, 
if *vif_priv = (struct wcn36xx_vif *)vif->drv_priv; 
if %p sta %pM index %d\n", 
if_priv->sta = NULL; 
ifdef CONFIG_PM 
if 
if *vif, 
if, sta_priv)); 
if, sta_priv)); 
if, sta_priv)); 
if, sta->addr, tid); 
if, sta_priv)); 
if, sta->addr, tid); 
ifdef CONFIG_PM 
if 
ifdef CONFIG_PM 
if 
if_data_size = sizeof(struct wcn36xx_vif); 
form_get_resources(struct wcn36xx *wcn, 
form_get_resource_byname(pdev, IORESOURCE_IRQ, 
if (!res) { 
form_get_resource_byname(pdev, IORESOURCE_IRQ, 
if (!res) { 
form_get_resource_byname(pdev, IORESOURCE_MEM, 
if (!res) { 
if (!wcn->mmio) { 
form_device *pdev) 
form probe\n"); 
if (!hw) { 
form_set_drvdata(pdev, hw); 
form_data; 
if (!wcn->ctrl_ops->get_hw_mac(addr)) { 
form_get_resources(wcn, pdev); 
if (ret) 
form_device *pdev) 
form remove\n"); 
form_device_id wcn36xx_platform_id_table[] = { 
form, wcn36xx_platform_id_table); 
form_id_table, 
form_driver_register(&wcn36xx_driver); 
form_driver_unregister(&wcn36xx_driver); 
file : ./test/kernel/drivers/net/wireless/b43legacy/main.c 
[ OK ] open : 4 ok... 
buf : /*
ify 
for more details. 
ifth Floor, 
if_arp.h> 
if defined(CONFIG_B43LEGACY_DMA) && defined(CONFIG_B43LEGACY_PIO) 
if defined(CONFIG_B43LEGACY_DMA) 
if defined(CONFIG_B43LEGACY_PIO) 
if 
for the firmware files to load."); 
for all devices. 
for all devices, so we don't 
if (!wl || !wl->current_dev) 
if (b43legacy_status(wl->current_dev) < B43legacy_STAT_STARTED) 
format vaf; 
if (!b43legacy_ratelimit(wl)) 
format vaf; 
if (!b43legacy_ratelimit(wl)) 
format vaf; 
if (!b43legacy_ratelimit(wl)) 
if B43legacy_DEBUG 
format vaf; 
if /* DEBUG */ 
if (status & B43legacy_MACCTL_BE) 
if (routing == B43legacy_SHM_SHARED) { 
if (offset & 0x0003) { 
if (routing == B43legacy_SHM_SHARED) { 
if (offset & 0x0003) { 
if (routing == B43legacy_SHM_SHARED) { 
if (offset & 0x0003) { 
if (routing == B43legacy_SHM_SHARED) { 
if (offset & 0x0003) { 
if any of the high registers changed (overflew). 
if (dev->dev->id.revision >= 3) { 
while (unlikely(high != high2)); 
while (v3 != test3 || v2 != test2 || v1 != test1); 
if (dev->dev->id.revision >= 3) { 
if (!mac) 
if (!bssid) 
if (!mac) 
for (i = 0; i < ARRAY_SIZE(mac_bssid); i += sizeof(u32)) { 
if (dev->phy.type != B43legacy_PHYTYPE_G) 
fore calling this. 
for (i = 0; i < 5; i++) 
if (phy->radio_ver == 0x2050 && phy->radio_rev <= 0x5) 
for (i = 0x00; i < max_loop; i++) { 
if (value & 0x0080) 
for (i = 0x00; i < 0x0A; i++) { 
if (value & 0x0400) 
for (i = 0x00; i < 0x0A; i++) { 
if (!(value & 0x0100)) 
if (phy->radio_ver == 0x2050 && phy->radio_rev <= 0x5) 
for the PLL to turn on. */ 
if (flags & B43legacy_TMSLOW_GMODE) { 
while (1) { 
if (!(v0 & 0x00000001)) 
for_ampdu = !!(tmp & 0x0020); 
if (dev->dev->id.revision < 5) 
while (1) { 
if (!(dummy & 0x00000001)) 
if (dev->noisecalc.calculation_running) 
if (dev->noisecalc.channel_at_start != phy->channel) 
if (noise[0] == 0x7F || noise[1] == 0x7F || 
if (dev->noisecalc.nr_samples == 8) { 
for (i = 0; i < 8; i++) { 
if (tmp >= 8) 
if (tmp == 8) 
if (b43legacy_is_mode(dev->wl, NL80211_IFTYPE_AP)) { 
if (1/*FIXME: the last PSpoll frame was sent successfully */) 
if (b43legacy_is_mode(dev->wl, NL80211_IFTYPE_ADHOC)) 
if (dev->dfq_valid) { 
while (1) { 
if (!(tmp & 0x00000008)) 
for (i = 2; i < size; i += sizeof(u32)) { 
if (i + 1 < size) 
if (i + 2 < size) 
if (i + 3 < size) 
for (i = 0; i < variable_len - 2; ) { 
if (ie_id == 5) { 
formation Element */ 
if (variable_len < ie_len + 2 + i) 
if (ie_len < 4) 
if (!tim_found) { 
if, 
for packet transfer */ 
if (B43legacy_WARN_ON(src_size < ie_start)) 
if (unlikely(!dest_data)) 
formation Elements, except the TIM. */ 
for ( ; src_pos < src_size - 2; src_pos += elem_size) { 
if (src_data[src_pos] == 5) { 
if, 
if (unlikely(!probe_resp_data)) 
for 
if (wl->beacon0_uploaded) 
if (wl->beacon1_uploaded) 
if (!b43legacy_is_mode(wl, NL80211_IFTYPE_AP)) 
if busy. */ 
if (unlikely(wl->beacon_templates_virgin)) { 
fore. 
if (!beacon0_valid) { 
if (!beacon1_valid) { 
if (likely(dev && (b43legacy_status(dev) >= B43legacy_STAT_INITIALIZED))) { 
if the 
while we are updating it. */ 
if); 
if (wl->current_beacon) 
if (dev->dev->id.revision >= 3) { 
for (i = 0; i < ARRAY_SIZE(dma_reason); i++) { 
if (unlikely(reason & B43legacy_IRQ_MAC_TXERR)) 
if (unlikely(reason & B43legacy_IRQ_PHY_TXERR)) { 
if (unlikely(atomic_dec_and_test(&dev->phy.txerr_cnt))) { 
if (unlikely(merged_dma_reason & (B43legacy_DMAIRQ_FATALMASK | 
if (merged_dma_reason & B43legacy_DMAIRQ_FATALMASK) { 
if (merged_dma_reason & B43legacy_DMAIRQ_NONFATALMASK) 
if (unlikely(reason & B43legacy_IRQ_UCODE_DEBUG)) 
if (reason & B43legacy_IRQ_TBTT_INDI) 
if (reason & B43legacy_IRQ_ATIM_END) 
if (reason & B43legacy_IRQ_BEACON) 
if (reason & B43legacy_IRQ_PMQ) 
if (reason & B43legacy_IRQ_TXFIFO_FLUSH_OK) 
if (reason & B43legacy_IRQ_NOISESAMPLE_OK) 
for received data. */ 
if (b43legacy_using_pio(dev)) 
if (dma_reason[3] & B43legacy_DMAIRQ_RX_DONE) { 
if (reason & B43legacy_IRQ_TX_OK) 
if (rxctl & B43legacy_PIO_RXCTL_DATAAVAILABLE) 
if (b43legacy_using_pio(dev) && 
ific workaround to the dma_reasons */ 
if (unlikely(b43legacy_status(dev) < B43legacy_STAT_STARTED)) 
if (reason == 0xffffffff) /* shared IRQ */ 
if (!reason) 
if (!name) 
if (async) { 
if (err) { 
for_completion(&dev->fw_load_complete); 
if (err) { 
if ((*fw)->size < sizeof(struct b43legacy_fw_header)) 
format; 
if (size != (*fw)->size - sizeof(struct b43legacy_fw_header)) 
format; 
if (hdr->ver != 1) 
format; 
format; 
format: 
if (!fw->ucode) { 
if (rev == 4) 
if (err) 
if (!fw->pcm) { 
if (err) 
if (!fw->initvals) { 
if ((rev >= 5) && (rev <= 10)) 
if (rev == 2 || rev == 4) 
if (err) 
if (!fw->initvals_band) { 
if ((rev >= 5) && (rev <= 10)) 
if (rev >= 11) 
if (rev == 2 || rev == 4) 
if (err) 
if (err) 
for PHY %u, " 
for (i = 0; i < 64; i++) 
for (i = 0; i < 4096; i += 2) 
for (i = 0; i < len; i++) { 
if (dev->fw.pcm) { 
for autoinc bit in SHM_HW */ 
for (i = 0; i < len; i++) { 
for the microcode to load and respond */ 
while (1) { 
if (tmp == B43legacy_IRQ_MAC_SUSPENDED) 
if (i >= B43legacy_IRQWAIT_MAX_RETRIES) { 
if (signal_pending(current)) { 
if (fwrev > 0x128) { 
for (i = 0; i < count; i++) { 
format; 
if (offset >= 0x1000) 
format; 
if (array_size < sizeof(iv->data.d32)) 
format; 
if (array_size < sizeof(iv->data.d16)) 
format; 
if (array_size) 
format; 
format: 
if (err) 
if (fw->initvals_band) { 
if (err) 
if (dev->dev->bus->chip_id == 0x4301) { 
if (dev->dev->bus->sprom.boardflags_lo & B43legacy_BFL_PACTRL) { 
if (dev->dev->id.revision >= 2) 
ifdef CONFIG_SSB_DRIVER_PCICORE 
if 
if (!gpiodev) 
for example. */ 
ifdef CONFIG_SSB_DRIVER_PCICORE 
if 
if (!gpiodev) 
if (dev->mac_suspended == 0) { 
if (dev->mac_suspended == 0) { 
fore suspending MAC. Otherwise 
for (i = 40; i; i--) { 
if (tmp & B43legacy_IRQ_MAC_SUSPENDED) 
if (b43legacy_is_mode(wl, NL80211_IFTYPE_AP)) 
if (b43legacy_is_mode(wl, NL80211_IFTYPE_ADHOC)) 
if (wl->filter_flags & FIF_CONTROL) 
if (wl->filter_flags & FIF_FCSFAIL) 
if (wl->filter_flags & FIF_PLCPFAIL) 
if (wl->filter_flags & FIF_PROMISC_IN_BSS) 
if (wl->filter_flags & FIF_BCN_PRBRESP_PROMISC) 
if (dev->dev->id.revision <= 4) 
if ((ctl & B43legacy_MACCTL_INFRA) && 
if (dev->dev->bus->chip_id == 0x4306 && 
if (is_ofdm) { 
for management frames sent by firmware. */ 
if (dev->phy.gmode) 
if (err) 
if (err) 
if (err) 
if (err) 
if (phy->type == B43legacy_PHYTYPE_B) { 
if (dev->dev->id.revision < 5) 
if (b43legacy_using_pio(dev)) { 
if (dev->dev->id.revision < 3) { 
if (phy->type != B43legacy_PHYTYPE_G || phy->rev < 2) 
if (dev->dev->bus->sprom.boardflags_lo & B43legacy_BFL_RSSI) { 
if (state % 8 == 0) 
if (state % 4 == 0) 
if (state % 2 == 0) 
if (unlikely(b43legacy_status(dev) != B43legacy_STAT_STARTED)) 
if (b43legacy_debug(dev, B43legacy_DBG_PWORK_STOP)) 
if (b43legacy_debug(dev, B43legacy_DBG_PWORK_FAST)) 
iffies_relative(HZ * 15); 
if (b43legacy_shm_read32(dev, B43legacy_SHM_SHARED, 0) != 
if (b43legacy_shm_read32(dev, B43legacy_SHM_SHARED, 0) != 
if ((value | B43legacy_MACCTL_GMODE) != 
if (value) 
if (dev->dev->id.revision >= 5) 
ifdef CONFIG_B43LEGACY_HWRNG 
if 
ifdef CONFIG_B43LEGACY_HWRNG 
if 
ifdef CONFIG_B43LEGACY_HWRNG 
if (err) { 
if 
if (unlikely(!dev || b43legacy_status(dev) < B43legacy_STAT_STARTED)) { 
for (queue_num = 0; queue_num < B43legacy_QOS_QUEUE_NUM; queue_num++) { 
while (skb_queue_len(&wl->tx_queue[queue_num])) { 
if (b43legacy_using_pio(dev)) 
if (err == -ENOSPC) { 
if (unlikely(err)) 
if (!err) 
if (unlikely(skb->len < 2 + 2 + 6)) { 
if (!wl->tx_queue_stopped[skb->queue_mapping]) 
if *vif, u16 queue, 
for_phymode(struct b43legacy_wl *wl, 
for_each_entry(d, &wl->devlist, list) { 
for_phymode(wl, new_mode, &up_dev, &gmode); 
for %s-PHY mode\n", 
if ((up_dev == wl->current_dev) && 
if (prev_status >= B43legacy_STAT_STARTED) 
if (prev_status >= B43legacy_STAT_INITIALIZED) 
if (down_dev != up_dev) 
if (prev_status >= B43legacy_STAT_INITIALIZED) { 
if (err) { 
for newly selected %s-PHY mode\n", 
if (prev_status >= B43legacy_STAT_STARTED) { 
if (err) { 
for " 
force this to avoid overflowing 
if (changed & IEEE80211_CONF_CHANGE_RETRY_LIMITS) 
if (!changed) 
if necessary). */ 
if (phy->type == B43legacy_PHYTYPE_B) 
if (err) 
while reconfiguring the device. 
if (b43legacy_status(dev) < B43legacy_STAT_STARTED) { 
if (conf->chandef.chan->hw_value != phy->channel) 
if (conf->power_level != 0) { 
for RX and management frame TX. */ 
if (wl->radio_enabled != phy->radio_on) { 
if (!dev->radio_hw_enable) 
for (i = 0; i < sband->n_bitrates; i++) { 
if (b43legacy_is_cck_rate(rate->hw_value)) { 
if (b43legacy_is_cck_rate(rate->hw_value)) { 
if *vif, 
if != vif); 
while reconfiguring the device. 
if (b43legacy_status(dev) < B43legacy_STAT_STARTED) { 
if (changed & BSS_CHANGED_BSSID) { 
if (conf->bssid) 
if (b43legacy_status(dev) >= B43legacy_STAT_INITIALIZED) { 
if (changed & BSS_CHANGED_BSSID) 
if (changed & BSS_CHANGED_BEACON_INT && 
if (changed & BSS_CHANGED_BASIC_RATES) 
if (changed & BSS_CHANGED_ERP_SLOT) { 
if (!dev) { 
if (changed && b43legacy_status(dev) >= B43legacy_STAT_INITIALIZED) 
if (b43legacy_status(dev) < B43legacy_STAT_STARTED) 
fore than 
for (queue_num = 0; queue_num < B43legacy_QOS_QUEUE_NUM; queue_num++) { 
while (skb_queue_len(&wl->tx_queue[queue_num])) 
if (err) { 
if (phy_rev != 2 && phy_rev != 4 
if (phy_rev > 8) 
if (unsupported) { 
if (dev->dev->bus->chip_id == 0x4317) { 
if (dev->dev->bus->chip_rev == 1) 
if ((radio_ver & 0xFFF0) != 0x2050) 
if (radio_ver != 0x2050) 
if (unsupported) { 
for_init(struct b43legacy_wldev *dev, 
if (lo) 
for (i = 0; i < ARRAY_SIZE(phy->nrssi); i++) 
for (i = 0; i < ARRAY_SIZE(phy->nrssi_lt); i++) 
for_init(struct b43legacy_wldev *dev) 
for_init(dev, &dev->phy); 
if (b43legacy_is_mode(dev->wl, NL80211_IFTYPE_ADHOC) || idle) 
if ((dev->phy.radio_ver == 0x2050) && (dev->phy.radio_rev == 8)) 
if (b43legacy_is_mode(dev->wl, NL80211_IFTYPE_ADHOC)) 
if (b43legacy_status(dev) != B43legacy_STAT_INITIALIZED) 
if (phy->dyn_tssi_tbl) 
if (dev->wl->current_beacon) { 
for_init(struct b43legacy_wldev *dev) 
for (i = 0; i < ARRAY_SIZE(phy->nrssi); i++) 
for (i = 0; i < ARRAY_SIZE(phy->nrssi_lt); i++) 
if (phy->_lo_pairs) 
if (err) 
if (!ssb_device_is_enabled(dev->dev)) { 
if ((phy->type == B43legacy_PHYTYPE_B) || 
if (!phy->_lo_pairs) 
for_init(dev); 
if (err) 
for_init(dev); 
if (err) 
if (phy->type == B43legacy_PHYTYPE_G) { 
if (phy->rev == 1) 
if (sprom->boardflags_lo & B43legacy_BFL_PACTRL) 
if (phy->type == B43legacy_PHYTYPE_B) { 
if (phy->rev >= 2 && phy->radio_ver == 0x2050) 
if (phy->type == B43legacy_PHYTYPE_B) 
if (b43legacy_using_pio(dev)) 
if (!err) 
while (err == -EAGAIN); 
if (phy->dyn_tssi_tbl) 
if *vif) 
if (vif->type != NL80211_IFTYPE_AP && 
if->type != NL80211_IFTYPE_WDS && 
if (wl->operating) 
if->type); 
if = vif; 
if->addr, ETH_ALEN); 
if *vif) 
if->type); 
if != vif); 
ific information to make sure 
if (b43legacy_status(dev) < B43legacy_STAT_INITIALIZED) { 
if (err) 
if (b43legacy_status(dev) < B43legacy_STAT_STARTED) { 
if (err) { 
if (b43legacy_status(dev) >= B43legacy_STAT_STARTED) 
if (idx != 0) 
if (prev_status >= B43legacy_STAT_STARTED) 
if (prev_status >= B43legacy_STAT_INITIALIZED) 
if (prev_status >= B43legacy_STAT_INITIALIZED) { 
if (err) 
if (prev_status >= B43legacy_STAT_STARTED) { 
if (err) { 
if (err) 
if (err) 
if (have_bphy) { 
if (have_gphy) { 
for gathering basic information about the HW, only. 
if (err) { 
if (dev->dev->id.revision >= 5) { 
if (!have_gphy) 
if (dev->dev->id.revision == 4) 
if (err) 
if this device supports multiband. */ 
if (err) 
if (err) 
if (!wl->current_dev) 
if (!wldev) 
if (modparam_pio) 
if (err) 
if (bus->boardinfo.vendor == PCI_VENDOR_ID_APPLE && 
if (!hw) { 
if (is_valid_ether_addr(sprom->et1mac)) 
for (queue_num = 0; queue_num < B43legacy_QOS_QUEUE_NUM; queue_num++) { 
if (!wl) { 
if (err) 
if (err) 
if (first) 
fore unregistering from ieee80211, 
if (!wldev->fw.ucode) 
if (wl->current_dev == wldev) 
if (list_empty(&wl->devlist)) 
form a hardware reset. This can be called from any context. */ 
if we are in shutdown. */ 
ifdef CONFIG_PM 
if (wldev->suspend_init_status >= B43legacy_STAT_STARTED) 
if (wldev->suspend_init_status >= B43legacy_STAT_INITIALIZED) 
if (wldev->suspend_init_status >= B43legacy_STAT_INITIALIZED) { 
if (err) { 
if (wldev->suspend_init_status >= B43legacy_STAT_STARTED) { 
if (err) { 
if	/* CONFIG_PM */ 
ifdef CONFIG_B43LEGACY_PCI_AUTOSELECT 
if 
if 
if 
if 
if (err) 
file : ./test/kernel/drivers/net/wireless/rtlwifi/rtl8723com/main.c 
[ OK ] open : 4 ok... 
buf : /******************************************************************************
ify it 
for 
formation: 
ifi.h" 
file : ./test/kernel/drivers/net/wireless/rtlwifi/rtl8192c/main.c 
[ OK ] open : 4 ok... 
buf : /******************************************************************************
ify it 
for 
if not, write to the Free Software Foundation, Inc., 
formation: 
ifi.h" 
file : ./test/kernel/drivers/net/wireless/mwifiex/main.c 
[ OK ] open : 4 ok... 
buf : /*
ify this File in 
ifth Floor, Boston, MA 02110-1301 USA or on the 
ifiex " VERSION " (%s) "; 
ifiex_private *priv = (struct mwifiex_private *)data; 
if (adapter->surprise_removed) 
if (adapter->scan_delay_cnt == MWIFIEX_MAX_SCAN_DELAY_CNT || 
for_each_entry_safe(cmd_node, tmp_node, 
ifiex_insert_cmd_to_free_q(adapter, cmd_node); 
ifiex_cmd_lock, flags); 
ifiex_cmd_lock, flags); 
if (!atomic_read(&priv->adapter->is_tx_received)) { 
if (adapter->empty_tx_q_cnt == MWIFIEX_MAX_EMPTY_TX_Q_CNT) { 
for 200msec. Get scan command from 
ifiex_insert_cmd_to_pending_q(adapter, cmd_node, 
iffies + 
if (atomic_read(&priv->adapter->is_tx_received)) 
forms all the necessary 
formed - 
ific operations table in adapter 
fore exiting. 
ifiex_register(void *card, struct mwifiex_if_ops *if_ops, 
ifiex_adapter *adapter; 
ifiex_adapter), GFP_KERNEL); 
ific operations in adapter */ 
ific initialization has been deferred until now .. */ 
if (adapter->if_ops.init_if(adapter)) 
for (i = 0; i < MWIFIEX_MAX_BSS_NUM; i++) { 
ifiex_private), GFP_KERNEL); 
ifiex_init_lock_list(adapter); 
ifiex_cmd_timeout_func; 
ifiex_register with error\n"); 
for (i = 0; i < adapter->priv_num; i++) 
forms all the necessary 
formed - 
ifiex_unregister(struct mwifiex_adapter *adapter) 
if (adapter->if_ops.cleanup_if) 
for (i = 0; i < adapter->priv_num; i++) { 
ifiex_free_curr_bcn(adapter->priv[i]); 
if required 
ifiex_main_process(struct mwifiex_adapter *adapter) 
if already processing */ 
ifiex_processing = true; 
if ((adapter->hw_status == MWIFIEX_HW_STATUS_CLOSING) || 
if any */ 
if (adapter->hs_activated) 
if (adapter->if_ops.process_int_status) 
if ((adapter->ps_state == PS_STATE_SLEEP) && 
ifiex_wmm_lists_empty(adapter))) { 
if_ops.wakeup(adapter); 
if (IS_CARD_RX_RCVD(adapter)) { 
if (adapter->ps_state == PS_STATE_SLEEP) 
if (adapter->pm_wakeup_fw_try) 
if (adapter->ps_state != PS_STATE_AWAKE || 
if ((adapter->scan_processing && 
ifiex_wmm_lists_empty(adapter)) { 
for USB */ 
while ((skb = skb_dequeue(&adapter->usb_rx_data_q))) 
for event */ 
ifiex_process_event(adapter); 
for Cmd Resp */ 
ifiex_process_cmdresp(adapter); 
if (adapter->hw_status == MWIFIEX_HW_STATUS_INIT_DONE) { 
ifiex_init_fw_complete(adapter); 
if we need to confirm Sleep Request 
if (adapter->ps_state == PS_STATE_PRE_SLEEP) { 
ifiex_check_ps_cond(adapter); 
if ((adapter->ps_state == PS_STATE_SLEEP) || 
if (!adapter->cmd_sent && !adapter->curr_cmd) { 
if ((!adapter->scan_processing || adapter->scan_delay_cnt) && 
ifiex_wmm_process_tx(adapter); 
ifiex_hs_activated_event 
if (adapter->delay_null_pkt && !adapter->cmd_sent && 
ifiex_wmm_lists_empty(adapter)) { 
ifiex_get_priv(adapter, MWIFIEX_BSS_ROLE_STA), 
while (true); 
if ((adapter->int_status) || IS_CARD_RX_RCVD(adapter)) { 
ifiex_processing = false; 
if (adapter->hw_status == MWIFIEX_HW_STATUS_CLOSING) 
ifiex_main_process); 
ifiex_free_adapter(struct mwifiex_adapter *adapter) 
ifiex_unregister(adapter); 
ifiex_terminate_workqueue(struct mwifiex_adapter *adapter) 
ifiex_fw_dpc(const struct firmware *firmware, void *context) 
ifiex_private *priv; 
ifiex_fw_image fw; 
if (!firmware) { 
ifiex_fw_image)); 
if (adapter->if_ops.dnld_fw) 
ifiex_dnld_fw(adapter, &fw); 
if (cal_data_cfg) { 
if (adapter->if_ops.enable_int) { 
ifiex_init_fw(adapter); 
if (!ret) { 
ifiex_init to complete */ 
if (adapter->hw_status != MWIFIEX_HW_STATUS_READY) 
if (mwifiex_register_cfg80211(adapter)) { 
ifiex_add_virtual_intf(adapter->wiphy, "mlan%d", 
if (IS_ERR(wdev)) { 
ifiex_drv_get_driver_version(adapter, fmt, sizeof(fmt) - 1); 
if (adapter->if_ops.disable_int) 
if (adapter->if_ops.unregister_dev) 
if ((adapter->hw_status == MWIFIEX_HW_STATUS_FW_READY) || 
ifiex\n", __func__); 
if (mwifiex_shutdown_drv(adapter) == -EINPROGRESS) 
ifiex_terminate_workqueue(adapter); 
if (adapter->cal_data) { 
if (adapter->firmware) { 
if (init_failed) 
ifiex_init_hw_fw(struct mwifiex_adapter *adapter) 
ifiex_fw_dpc); 
for open. 
ifiex_open(struct net_device *dev) 
for close. 
ifiex_close(struct net_device *dev) 
if (priv->scan_request) { 
ifiex_queue_tx_pkt(struct mwifiex_private *priv, struct sk_buff *skb) 
ifiex_1d_to_wmm_queue[skb->priority]; 
if (!netif_tx_queue_stopped(txq)) { 
ifiex_wmm_add_buf_txqueue(priv, skb); 
for data transmission. 
ifiex_hard_start_xmit(struct sk_buff *skb, struct net_device *dev) 
ifiex_txinfo *tx_info; 
iffies, priv->bss_type, priv->bss_num); 
if (!skb->len || (skb->len > ETH_FRAME_LEN)) { 
if (skb_headroom(skb) < MWIFIEX_MIN_DATA_HEADER_LEN) { 
if (unlikely(!new_skb)) { 
fore it was sent to the firmware. 
for aggregate delay calculation for stats and 
ifiex_queue_tx_pkt(priv, skb); 
for setting MAC address. 
ifiex_set_mac_address(struct net_device *dev, void *addr) 
ifiex_send_cmd(priv, HostCmd_CMD_802_11_MAC_ADDRESS, 
if (!ret) 
for setting multicast list. 
ifiex_set_multicast_list(struct net_device *dev) 
ifiex_multicast_list mcast_list; 
if (dev->flags & IFF_ALLMULTI || 
ifiex_copy_mcast_addr(&mcast_list, dev); 
for transmission timeout. 
ifiex_tx_timeout(struct net_device *dev) 
iffies, priv->tx_timeout_cnt, priv->bss_type, priv->bss_num); 
if (priv->tx_timeout_cnt > TX_TIMEOUT_THRESHOLD && 
if_ops.card_reset(priv->adapter); 
for statistics retrieval. 
ifiex_get_stats(struct net_device *dev) 
ifiex_netdev_select_wmm_queue(struct net_device *dev, struct sk_buff *skb, 
ify8021d(skb, NULL); 
ifiex_netdev_ops = { 
ifiex_close, 
ifiex_set_mac_address, 
ifiex_get_stats, 
ifiex_netdev_select_wmm_queue, 
ifiex_init_priv_params(struct mwifiex_private *priv, 
ifiex_netdev_ops; 
ifiex_ie) * MAX_MGMT_IE_INDEX); 
if command is pending. 
ifiex_adapter *adapter) 
ifiex_main_work_queue(struct work_struct *work) 
ifiex_adapter, main_work); 
ifiex_main_process(adapter); 
ifiex_add_card(void *card, struct semaphore *sem, 
ifiex_adapter *adapter; 
if (mwifiex_register(card, if_ops, (void **)&adapter)) { 
iface_type = iface_type; 
if (!adapter->workqueue) 
ifiex_main_work_queue); 
formation from the card. */ 
ifiex device\n", __func__); 
if (mwifiex_init_hw_fw(adapter)) { 
if (adapter->if_ops.unregister_dev) 
if ((adapter->hw_status == MWIFIEX_HW_STATUS_FW_READY) || 
ifiex\n", __func__); 
if (mwifiex_shutdown_drv(adapter) == -EINPROGRESS) 
ifiex_terminate_workqueue(adapter); 
ifiex_free_adapter(adapter); 
ifiex_add_card); 
ifiex_remove_card(struct mwifiex_adapter *adapter, struct semaphore *sem) 
if (down_interruptible(sem)) 
if (!adapter) 
if (adapter->if_ops.disable_int) 
for (i = 0; i < adapter->priv_num; i++) { 
if (priv && priv->netdev) { 
if (netif_carrier_ok(priv->netdev)) 
ifiex_shutdown_drv...\n"); 
if (mwifiex_shutdown_drv(adapter) == -EINPROGRESS) 
ifiex_shutdown_drv done\n"); 
for (i = 0; i < adapter->priv_num; i++) { 
if (!priv) 
if (priv->wdev && priv->netdev) 
ifiex_terminate_workqueue(adapter); 
if (adapter->if_ops.unregister_dev) 
ifiex_free_adapter(adapter); 
ifiex_remove_card); 
if configured. 
ifiex_init_module(void) 
ifiex_debugfs_init(); 
if available. 
ifiex_cleanup_module(void) 
ifiex_debugfs_remove(); 
ifiex_init_module); 
file : ./test/kernel/drivers/net/wireless/iwlwifi/dvm/main.c 
[ OK ] open : 4 ok... 
buf : /******************************************************************************
ify it 
for 
if not, write to the Free Software Foundation, Inc., 
formation: 
if_arp.h> 
for Linux" 
if 
for_each_context(priv, ctx) { 
if (ctx->active.rx_chain != ctx->staging.rx_chain) 
while ((tim_idx < (frame_size - 2)) && 
if ((tim_idx < (frame_size - 1)) && (beacon[tim_idx] == WLAN_EID_TIM)) { 
if (!priv->beacon_ctx) { 
if (WARN_ON(!priv->beacon_skb)) 
if (!priv->beacon_cmd) 
if (!tx_beacon_cmd) 
ife_time = TX_CMD_LIFE_TIME_INFINITE; 
if (info->control.rates[0].idx < 0 || 
for 5 GHz start at 0 */ 
if (rate >= IWL_FIRST_CCK_RATE && rate <= IWL_LAST_CCK_RATE) 
if (!priv->beacon_ctx) { 
if (priv->beacon_ctx->vif->type != NL80211_IFTYPE_AP) { 
ifications even in 
if not in AP mode */ 
if (!beacon) { 
if (test_bit(STATUS_EXIT_PENDING, &priv->status)) 
if rf-kill is on */ 
if (test_bit(STATUS_EXIT_PENDING, &priv->status)) 
if rf-kill is on */ 
fore BT Config cmd 
for_each_context(priv, ctx) { 
if (flags & CMD_ASYNC) 
for calibrating the TXPOWER. 
if (test_bit(STATUS_EXIT_PENDING, &priv->status)) 
if rf-kill is on */ 
if (mode == 0) 
for SRAM reads */ 
if (WARN_ON(num_events > capacity - start_idx)) 
for mode 0 (no timestamp). 
for (i = 0; i < num_events; i++) { 
if (mode == 0) { 
ifi_dev_ucode_cont_event( 
if (iwlagn_hw_valid_rtc_data_addr(base)) { 
fortunately, the uCode doesn't use temporary variables. 
if (unlikely(next_entry == capacity)) 
fore 
if (unlikely(next_entry < priv->event_log.next_entry && 
if (num_wraps == priv->event_log.num_wraps) { 
if (num_wraps - priv->event_log.num_wraps > 1) 
ifi_dev_ucode_wrap_event(priv->trans->dev, 
if (next_entry < priv->event_log.next_entry) { 
form continuous uCode event logging operation 
if (test_bit(STATUS_EXIT_PENDING, &priv->status)) 
if (priv->event_log.ucode_trace) { 
iffies + msecs_to_jiffies(UCODE_TRACE_PERIOD)); 
if (test_bit(STATUS_EXIT_PENDING, &priv->status)) 
if rf-kill is on */ 
ifo_flush(priv); 
ifo[] = { 
ifo[] = { 
if (ucode_flags & IWL_UCODE_TLV_FLAGS_PAN) 
for (i = 0; i < NUM_IWL_RXON_CTX; i++) 
ifo, 
ifo, 
if (priv->lib->support_ct_kill_exit) { 
if (ret) 
if (ret) 
if (IWL_UCODE_API(priv->fw->ucode_ver) > 1) { 
if (!iwlwifi_mod_params.bt_coex_active) 
if (iwl_dvm_send_cmd_pdu(priv, REPLY_BT_CONFIG, 
ification received 
if (iwl_is_rfkill(priv)) 
if (priv->event_log.ucode_trace) { 
iffies); 
fore any calibration request */ 
if (priv->lib->bt_params->bt_sco_disable) 
force change uCode BT state machine */ 
if (ret) 
if (ret) 
if (priv->lib->bt_params) { 
form runtime calibrations, including DC calibration. 
if (iwl_is_associated_ctx(ctx) && !priv->wowlan) { 
for_each_context(priv, tmp) 
if (!priv->wowlan) { 
for unassociated operation */ 
if (ret) 
if we're getting there in the 
for_each_context(priv, ctx) { 
formation that is not stored as part 
if (priv->lib->bt_params) 
if we are not actually 
if (!exit_pending) 
if (priv->mac80211_registered) 
if (test_bit(STATUS_EXIT_PENDING, &priv->status) || 
if (priv->start_calib) { 
for (i = IWLAGN_FIRST_AMPDU_QUEUE; i < IWL_MAX_HW_QUEUES; i++) 
for (i = 0; i < IWL_MAX_HW_QUEUES; i++) 
if (test_bit(STATUS_EXIT_PENDING, &priv->status)) 
if (test_and_clear_bit(STATUS_FW_ERROR, &priv->status)) { 
if (priv->mac80211_registered) 
fore registrating with mac80211\n"); 
if (priv->lib->bt_params) 
if (priv->lib->bt_params) 
iffies = jiffies; 
if (priv->lib->bt_params && 
ifdef CONFIG_IWLWIFI_DEBUGFS 
if 
if (priv->cfg->ht_params) 
for_aggregation = 
ific setup */ 
ifdef CONFIG_IWLWIFI_DEBUG 
if 
if 
if 
if (data->sku_cap_11n_enable && 
if (!data->sku_cap_11n_enable && !data->sku_cap_band_24GHz_enable && 
if (priv->cfg->rx_with_siso_diversity) 
if (!hw) { 
if (WARN_ON(!priv->lib)) 
ifi_mod_params.amsdu_size_8K; 
ifo = IWLAGN_CMD_FIFO_NUM; 
if (ucode_flags & IWL_UCODE_TLV_FLAGS_PAN) { 
ifi_mod_params.ant_coupling > 
if (iwl_trans_start_hw(priv->trans)) 
if (iwl_read_eeprom(priv->trans, &priv->eeprom_blob, 
if (!priv->nvm_data) 
if (iwl_nvm_check_version(priv->nvm_data, priv->trans)) 
if (iwl_eeprom_init_hw_params(priv)) 
if (num_mac > 1) { 
if (!(priv->nvm_data->sku_cap_ipan_enable)) { 
if not PAN, then don't support P2P -- might be a uCode 
for (i = 0; i < IWL_MAX_HW_QUEUES; i++) { 
if (i < IWLAGN_FIRST_AMPDU_QUEUE && 
if (iwl_init_drv(priv)) 
if (iwlagn_mac_setup_register(priv, &fw->ucode_capa)) 
if (iwl_dbgfs_register(priv, dbgfs_dir)) 
if_stop_queue(dev); */ 
if (num < max) 
for (i = 0; i < max; i++) { 
if (priv->cur_ucode == IWL_UCODE_INIT) { 
if (!base) 
if (!iwlagn_hw_valid_rtc_data_addr(base)) { 
for %s uCode\n", 
if (ERROR_START_OFFSET <= table.valid * ERROR_ELEM_SIZE) { 
ifi_dev_ucode_error(trans->dev, table.error_id, table.tsf_low, 
if timestamp recorded */ 
if (num_events == 0) 
if (priv->cur_ucode == IWL_UCODE_INIT) { 
if (!base) 
if (mode == 0) 
for SRAM reads */ 
for mode 0 (no timestamp). 
for (i = 0; i < num_events; i++) { 
if (mode == 0) { 
if (bufsz) { 
ifi_dev_ucode_event(trans->dev, 0, 
if (bufsz) { 
ifi_dev_ucode_event(trans->dev, time, 
fore the next ont that uCode would fill. 
if (num_wraps) { 
if (next_entry < size) { 
if (priv->cur_ucode == IWL_UCODE_INIT) { 
if (!base) 
if (!base) 
if (!iwlagn_hw_valid_rtc_data_addr(base)) { 
for %s uCode\n", 
if (capacity > logsize) { 
if (next_entry > logsize) { 
if nothing in log */ 
if (!(iwl_have_debug_level(IWL_DL_FW_ERRORS)) && !full_log) 
ifdef CONFIG_IWLWIFI_DEBUG 
if (full_log) 
if (!*buf) 
if (iwl_have_debug_level(IWL_DL_FW_ERRORS) || full_log) { 
if uCode has wrapped back to top of log, 
if (num_wraps) 
if 
iffies; 
ification_waits(&priv->notif_wait); 
if (!ondemand) { 
iffies = jiffies; 
iffies); 
if (reload_msec <= IWL_MIN_RELOAD_DURATION) { 
if (priv->reload_count >= IWL_MAX_CONTINUE_RELOAD_CNT) { 
if (!test_bit(STATUS_EXIT_PENDING, &priv->status)) { 
if (!iwl_check_for_ct_kill(priv)) { 
if (priv->nvm_data->radio_cfg_type <= EEPROM_RF_CONFIG_TYPE_MAX) { 
for uCode use */ 
fore PERST# is asserted), 
if (priv->lib->nic_config) 
if (WARN_ON_ONCE(mq == IWL_INVALID_MAC80211_QUEUE)) 
if (atomic_inc_return(&priv->queue_stop_count[mq]) > 1) { 
if (WARN_ON_ONCE(mq == IWL_INVALID_MAC80211_QUEUE)) 
if (atomic_dec_return(&priv->queue_stop_count[mq]) > 0) { 
if (!priv->passive_no_rx) 
ift_passive_no_rx(struct iwl_priv *priv) 
if (!priv->passive_no_rx) 
for (mq = 0; mq < IWLAGN_FIRST_AMPDU_QUEUE; mq++) { 
if (state) 
if (ret) { 
if (ret) { 
file : ./test/kernel/drivers/net/wireless/p54/main.c 
[ OK ] open : 4 ok... 
buf : /*
for mac80211 Prism54 drivers 
ify 
if *vif, 
ify the firmware that we don't want or we don't 
for this station anymore. 
ify(struct ieee80211_hw *dev, struct ieee80211_vif *vif, 
ify_cmd) { 
if (skb->len <= sizeof(mgmt)) 
while (pos < end) { 
if (pos[0] == ie) 
format_ie_tim(struct sk_buff *skb) 
for this mess is ... the firmware. 
if (!tim) 
if (dtim_len < 3) 
if (dtim_len > 3) 
if *vif) 
if); 
format_ie_tim(beacon); 
ifies that the driver does not need 
if (err) 
if (err) 
if (err) { 
for (i = 0; i < P54_QUEUE_NUM; i++) { 
if *vif) 
if->driver_flags |= IEEE80211_VIF_BEACON_FILTER; 
if (priv->mode != NL80211_IFTYPE_MONITOR) { 
if = vif; 
if->type; 
if->addr, ETH_ALEN); 
if *vif) 
if = NULL; 
fore attempting a mode transition. 
if (le32_to_cpu(priv->beacon_req_id) != 0) { 
for_completion_interruptible_timeout(&priv->beacon_comp, HZ); 
for_stats(struct ieee80211_hw *dev) 
if (ret) 
for_completion_interruptible_timeout(&priv->stat_comp, HZ); 
if (chan) { 
if (changed & IEEE80211_CONF_CHANGE_POWER) 
if (changed & IEEE80211_CONF_CHANGE_CHANNEL) { 
for_stats(dev)); 
if (ret) { 
if (changed & IEEE80211_CONF_CHANGE_PS) { 
for_stats(dev)); 
if (ret) 
for_stats(dev)); 
for_stats(dev)); 
if (ret) 
for_stats(dev)); 
for the global broadcast MAC. 
for_each(ha, mc_list) { 
if (i >= ARRAY_SIZE(priv->mc_maclist)) 
if (changed_flags & (FIF_PROMISC_IN_BSS | FIF_OTHER_BSS)) 
if (changed_flags & FIF_ALLMULTI || multicast) 
if *vif, u16 queue, 
if (queue < dev->queues) { 
if (unlikely(priv->mode == NL80211_IFTYPE_UNSPECIFIED)) 
if necessary. 
if *vif, 
if (changed & BSS_CHANGED_BSSID) { 
if (changed & BSS_CHANGED_BEACON) { 
if); 
if (changed & (BSS_CHANGED_ERP_SLOT | BSS_CHANGED_BEACON)) { 
if (changed & BSS_CHANGED_BASIC_RATES) { 
if (priv->fw_var >= 0x500) 
if (changed & BSS_CHANGED_ASSOC) { 
if *vif, struct ieee80211_sta *sta, 
if (modparam_nohwcrypt) 
if (key->flags & IEEE80211_KEY_FLAG_RX_MGMT) { 
fortunately most/all firmwares are trying to decrypt 
if (cmd == SET_KEY) { 
if (!(priv->privacy_caps & (BR_DESC_PRIV_CAP_MICHAEL | 
if (!(priv->privacy_caps & BR_DESC_PRIV_CAP_WEP)) { 
if (!(priv->privacy_caps & BR_DESC_PRIV_CAP_AESCCMP)) { 
if (slot < 0) { 
for outgoing frames is always 
if (slot == 0xff) { 
if (sta) 
if (ret) { 
if (idx >= priv->chan_num) 
for (tries = 0; tries < MAX_TRIES; tries++) { 
if (chan && chan->hw_value == idx) { 
for_stats(dev); 
if (err) 
if (in_use) { 
if  (survey->channel_time != 0) { 
for 100ms, this ought to be enough to 
for (i = P54_QUEUE_MGMT; i < P54_QUEUE_NUM; i++) 
if *vif, 
if we wait for one second 
while ((total = p54_flush_count(priv) && i--)) { 
ify		= p54_sta_notify, 
if (!dev) 
ificially if the RC algorithm wants just two rates, so 
ificantly. 
if (err) { 
ifdef CONFIG_P54_LEDS 
if (err) { 
if /* CONFIG_P54_LEDS */ 
for (i = 0; i < IEEE80211_NUM_BANDS; i++) 
ifdef CONFIG_P54_LEDS 
if /* CONFIG_P54_LEDS */ 
file : ./test/kernel/drivers/net/wireless/b43/main.c 
[ OK ] open : 4 ok... 
buf : /*
ify 
for more details. 
ifth Floor, 
if_arp.h> 
for the .fw files to load."); 
if overlaps with the brcmsmac driver)"); 
if 
if 
for all devices. 
for all devices, so we don't 
if *vif, 
if (!wl || !wl->current_dev) 
if (b43_status(wl->current_dev) < B43_STAT_STARTED) 
format vaf; 
if (b43_modparam_verbose < B43_VERBOSITY_INFO) 
if (!b43_ratelimit(wl)) 
format vaf; 
if (b43_modparam_verbose < B43_VERBOSITY_ERROR) 
if (!b43_ratelimit(wl)) 
format vaf; 
if (b43_modparam_verbose < B43_VERBOSITY_WARN) 
if (!b43_ratelimit(wl)) 
format vaf; 
if (b43_modparam_verbose < B43_VERBOSITY_DEBUG) 
if (macctl & B43_MACCTL_BE) 
if (routing == B43_SHM_SHARED) { 
if (offset & 0x0003) { 
if (routing == B43_SHM_SHARED) { 
if (offset & 0x0003) { 
if (routing == B43_SHM_SHARED) { 
if (offset & 0x0003) { 
if (routing == B43_SHM_SHARED) { 
if (offset & 0x0003) { 
if we 
if we 
if (!mac) 
for (i = 0; i < ARRAY_SIZE(mac_bssid); i += sizeof(u32)) { 
for all but a G PHY. */ 
for BCM4311 
if (ofdm) { 
for (i = 0; i < 5; i++) 
if (dev->dev->core_rev < 11) 
if (phy->type == B43_PHYTYPE_N || phy->type == B43_PHYTYPE_LP || 
if (!pa_on && phy->type == B43_PHYTYPE_N) 
if (phy->radio_ver == 0x2050 && phy->radio_rev <= 0x5) 
for (i = 0x00; i < max_loop; i++) { 
if (value & 0x0080) 
for (i = 0x00; i < 0x0A; i++) { 
if (value & 0x0400) 
for (i = 0x00; i < 0x19; i++) { 
if (!(value & 0x0100)) 
if (phy->radio_ver == 0x2050 && phy->radio_rev <= 0x5) 
for (i = 0; i < B43_SEC_KEYSIZE; i += 2) { 
if (b43_new_kidx_api(dev)) 
if (addr) { 
if it doesn't the packet is returned without modification (and software 
if it does, the rc4 key is computed, and decryption is tried. 
ified by the ucode). 
if we have a correct iv32 but a wrong phase1key, all 
if (!modparam_hwtkip) 
if (b43_new_kidx_api(dev)) 
if (b43_debug(dev, B43_DBG_KEYS)) { 
for (i = 0; i < 10; i += 2) { 
if *vif, 
if (B43_WARN_ON(!modparam_hwtkip)) 
if (WARN_ON(!sta)) 
if (b43_new_kidx_api(dev)) 
if (index >= pairwise_keys_start) 
if (algorithm == B43_SEC_ALGO_TKIP) { 
if (index >= pairwise_keys_start) /* clear it */ 
if (key) 
if (index >= pairwise_keys_start) 
if (algorithm == B43_SEC_ALGO_TKIP && key_len == 32) 
if (key_len > B43_SEC_KEYSIZE) 
for (i = 0; i < ARRAY_SIZE(dev->key); i++) { 
if (index < 0) { 
for the key. */ 
for (i = pairwise_keys_start; 
if (!dev->key[i].keyconf) { 
if (index < 0) { 
if ((index <= 3) && !b43_new_kidx_api(dev)) { 
if (B43_WARN_ON((index < 0) || (index >= ARRAY_SIZE(dev->key)))) 
if ((index <= 3) && !b43_new_kidx_api(dev)) { 
if (b43_new_kidx_api(dev)) 
for (i = 0; i < count; i++) 
if (!b43_debug(dev, B43_DBG_KEYS)) 
if (b43_new_kidx_api(dev)) { 
for (index = 0; index < count; index++) { 
for (i = 0; i < B43_SEC_KEYSIZE; i += 2) { 
if (index >= pairwise_keys_start) { 
for (i = 0; i < 14; i += 2) { 
if (ps_flags & B43_PS_ENABLED) { 
if (ps_flags & B43_PS_DISABLED) { 
if (ps_flags & B43_PS_AWAKE) { 
if (ps_flags & B43_PS_ASLEEP) { 
force awake-on and hwps-off */ 
if (hwps) 
if (awake) 
if (awake && dev->dev->core_rev >= 5) { 
for the microcode to wake up. */ 
if (ucstat != B43_SHM_SH_UCODESTAT_SLEEP) 
ifdef CONFIG_B43_BCMA 
if (gmode) 
if 
if (gmode) 
if (dev->phy.type == B43_PHYTYPE_N) 
for the PLL to turn on. */ 
if 
ifdef CONFIG_B43_BCMA 
if 
if 
if (dev->phy.ops) 
if (gmode) 
while (1) { 
if (!(v0 & 0x00000001)) 
for_ampdu = !!(tmp & 0x0020); 
if (dev->dev->core_rev < 5) 
while (1) { 
if (!(dummy & 0x00000001)) 
if (dev->phy.type != B43_PHYTYPE_G) 
if (dev->noisecalc.calculation_running) 
if (dev->phy.type != B43_PHYTYPE_G) 
ifferent channel in the meantime since we 
if (noise[0] == 0x7F || noise[1] == 0x7F || 
if (dev->noisecalc.nr_samples == 8) { 
for (i = 0; i < 8; i++) { 
if (tmp >= 8) 
if (tmp == 8) 
if (b43_is_mode(dev->wl, NL80211_IFTYPE_AP)) { 
if (1 /*FIXME: the last PSpoll frame was sent successfully */ ) 
if (b43_is_mode(dev->wl, NL80211_IFTYPE_ADHOC)) 
if (dev->dfq_valid) { 
while (1) { 
if (!(tmp & 0x00000008)) 
for (i = 2; i < size; i += sizeof(u32)) { 
if (i + 1 < size) 
if (i + 2 < size) 
if (i + 3 < size) 
if the use of the antenna that ieee80211 told us to 
ifier we got from ieee80211. */ 
if (antenna_nr == 0) { 
if (dev->phy.gmode) 
if (!(antenna_mask & (1 << (antenna_nr - 1)))) { 
if (b43_is_cck_rate(rate)) 
for (i = 0; i < variable_len - 2; ) { 
if (ie_id == 5) { 
formation Element */ 
if (variable_len < ie_len + 2 + i) 
if (ie_len < 4) 
if (!tim_found) { 
ify TIM do it behind the beacon, this 
for example, when doing mesh networking. 
if (wl->beacon0_uploaded) 
if (wl->beacon1_uploaded) 
if (!b43_is_mode(wl, NL80211_IFTYPE_AP) && 
if busy. */ 
if (unlikely(wl->beacon_templates_virgin)) { 
fore. 
if (!beacon0_valid) { 
if (!beacon1_valid) { 
if (old_irq_mask != dev->irq_mask) { 
if (b43_read32(dev, B43_MMIO_GEN_IRQ_MASK)) { 
if (likely(dev && (b43_status(dev) >= B43_STAT_INITIALIZED))) { 
if the firmware 
while we are updating it. */ 
if); 
if (wl->current_beacon) 
if (dev->dev->core_rev >= 3) { 
for the panic. */ 
if (!dev->fw.opensource) 
for this IRQ. */ 
if (!B43_DEBUG) 
if (!buf) { 
for (i = 0; i < 4096; i += 2) { 
if (!B43_DEBUG) 
for (i = 0, cnt = 0; i < 64; i++) { 
if (cnt == 0) 
if (cnt == 6) { 
if (!B43_DEBUG) 
for unknown reason: %u\n", 
if (unlikely(b43_status(dev) != B43_STAT_STARTED)) 
for (i = 0; i < ARRAY_SIZE(dma_reason); i++) { 
if (unlikely(reason & B43_IRQ_MAC_TXERR)) 
if (unlikely(reason & B43_IRQ_PHY_TXERR)) { 
if (unlikely(atomic_dec_and_test(&dev->phy.txerr_cnt))) { 
if (unlikely(merged_dma_reason & (B43_DMAIRQ_FATALMASK))) { 
if we get fatal DMA errors! */ 
if (unlikely(reason & B43_IRQ_UCODE_DEBUG)) 
if (reason & B43_IRQ_TBTT_INDI) 
if (reason & B43_IRQ_ATIM_END) 
if (reason & B43_IRQ_BEACON) 
if (reason & B43_IRQ_PMQ) 
if (reason & B43_IRQ_TXFIFO_FLUSH_OK) 
if (reason & B43_IRQ_NOISESAMPLE_OK) 
for received data. */ 
if (B43_DEBUG) 
if (dma_reason[0] & B43_DMAIRQ_RX_DONE) { 
if (reason & B43_IRQ_TX_OK) 
if B43_DEBUG 
for (i = 0; i < ARRAY_SIZE(dev->irq_bit_count); i++) { 
if 
if (reason == 0xffffffff)	/* shared IRQ */ 
if (!reason) 
for the IRQ thread handler. */ 
if (unlikely(b43_status(dev) < B43_STAT_STARTED)) 
if (ret == IRQ_WAKE_THREAD) 
for this driver version. " \ 
if (error) 
if (!name) { 
if (fw->filename) { 
for all possible 
if (async) { 
if (err < 0) { 
for_completion(&ctx->dev->fw_load_complete); 
if (err == -ENOENT) { 
if (err) { 
if (ctx->blob->size < sizeof(struct b43_fw_header)) 
format; 
if (size != ctx->blob->size - sizeof(struct b43_fw_header)) 
format; 
if (hdr->ver != 1) 
format; 
format; 
format: 
format error.\n", ctx->fwname); 
for HT and LCN were found by trying one by one */ 
if ((rev >= 5) && (rev <= 10)) { 
if ((rev >= 11) && (rev <= 12)) { 
if (rev == 13) { 
if (rev == 14) { 
if (rev == 15) { 
if (rev >= 16) 
if (rev == 29) 
if (rev == 24) 
if (err) 
if ((rev >= 5) && (rev <= 10)) 
if (rev >= 11) 
if (err == -ENOENT) { 
if (err) 
if ((rev >= 5) && (rev <= 10)) { 
if (tmshigh & B43_TMSHIGH_HAVE_2GHZ_PHY) 
if ((rev >= 5) && (rev <= 10)) 
if (rev >= 13) 
if (rev >= 16) 
if ((rev >= 11) && (rev <= 12)) 
if (rev == 13) 
if (rev == 14) 
if (rev >= 15) 
if (rev == 29) 
if (rev == 24) 
if (err) 
if ((rev >= 5) && (rev <= 10)) { 
if (tmshigh & B43_TMSHIGH_HAVE_2GHZ_PHY) 
if (rev >= 11) 
if ((rev >= 5) && (rev <= 10)) 
if (rev >= 11) 
if (rev >= 16) 
if ((rev >= 11) && (rev <= 12)) 
if (rev == 13) 
if (rev == 14) 
if (rev >= 15) 
if (rev == 29) 
if (rev == 24) 
if (err) 
for your device (wl-core rev %u)\n", rev); 
for your device (wl-core rev %u)\n", rev); 
for your device (wl-core rev %u)\n", rev); 
if (!ctx) 
if (!err) 
if (ctx->fatal_failure) 
if (!err) 
if(ctx->fatal_failure) 
for (i = 0; i < B43_NR_FWTYPES; i++) { 
if (strlen(errmsg)) 
if (!modparam_qos || dev->fw.opensource) 
if (err) 
for (i = 0; i < 64; i++) 
for (i = 0; i < 4096; i += 2) 
for (i = 0; i < len; i++) { 
if (dev->fw.pcm.data) { 
for autoinc bit in SHM_HW */ 
for (i = 0; i < len; i++) { 
for the microcode to load and respond */ 
while (1) { 
if (tmp == B43_IRQ_MAC_SUSPENDED) 
if (i >= 20) { 
if (fwrev <= 0x128) { 
if (dev->fw.rev >= 598) 
format = B43_FW_HDR_598; 
format = B43_FW_HDR_410; 
format = B43_FW_HDR_351; 
if (dev->fw.opensource) { 
if (!(fwcapa & B43_FWCAPA_HWCRYPTO) || dev->fw.pcm_request_failed) { 
if (dev->fw.pcm_request_failed) { 
if (dev->fw.hdr_format == B43_FW_HDR_351) { 
for old fw 
for old firmware will be removed soon " 
for (i = 0; i < count; i++) { 
format; 
if (offset >= 0x1000) 
format; 
if (array_size < sizeof(iv->data.d32)) 
format; 
if (array_size < sizeof(iv->data.d16)) 
format; 
if (array_size) 
format; 
format: 
if (!fw->initvals_band.data) 
ifdef CONFIG_B43_SSB 
ifdef CONFIG_SSB_DRIVER_PCICORE 
if 
ifdef CONFIG_B43_SSB 
if 
if (dev->dev->chip_id == 0x4301) { 
if (dev->dev->chip_id == 0x5354) { 
if (0 /* FIXME: conditional unknown */ ) { 
if (dev->dev->bus_sprom->boardflags_lo & B43_BFL_PACTRL) { 
ifdef CONFIG_B43_BCMA 
if 
if (gpiodev) 
if 
for example. */ 
ifdef CONFIG_B43_SSB 
if 
ifdef CONFIG_B43_BCMA 
if 
if (gpiodev) 
if 
if (b43_debug(dev, B43_DBG_FIRMWARE)) { 
if ((fwstate != B43_SHM_SH_UCODESTAT_SUSP) && 
if (dev->mac_suspended == 0) { 
if (dev->mac_suspended == 0) { 
force pci to flush the write */ 
for (i = 35; i; i--) { 
if (tmp & B43_IRQ_MAC_SUSPENDED) 
for (i = 40; i; i--) { 
if (tmp & B43_IRQ_MAC_SUSPENDED) 
ifdef CONFIG_B43_BCMA 
if (on) 
if 
if (on) 
if 
if (b43_is_mode(wl, NL80211_IFTYPE_AP) || 
if (b43_is_mode(wl, NL80211_IFTYPE_ADHOC)) 
if (wl->filter_flags & FIF_CONTROL) 
if (wl->filter_flags & FIF_FCSFAIL) 
if (wl->filter_flags & FIF_PLCPFAIL) 
if (wl->filter_flags & FIF_PROMISC_IN_BSS) 
if (wl->filter_flags & FIF_BCN_PRBRESP_PROMISC) 
if (dev->dev->core_rev <= 4) 
if ((ctl & B43_MACCTL_INFRA) && !(ctl & B43_MACCTL_AP)) { 
if (0  /* ctl & B43_MACCTL_AP */) 
if (is_ofdm) { 
if (dev->phy.type == B43_PHYTYPE_A) 
for the PHY TX Control Words. */ 
for management frames sent by firmware. */ 
if (dev->phy.gmode) 
if (err) 
if (err) 
if (err) 
if (err) 
if (err) 
if (phy->ops->interf_mitigation) 
if (phy->ops->set_rx_antenna) 
if (phy->type == B43_PHYTYPE_B) { 
if (dev->dev->core_rev < 5) 
if (dev->dev->core_rev < 3) { 
ifdef CONFIG_B43_BCMA 
if 
if 
if (ops->pwork_60sec) 
if (dev->fw.opensource) { 
if (unlikely(wdr)) { 
if (phy->ops->pwork_15sec) 
if B43_DEBUG 
for (i = 0; i < ARRAY_SIZE(dev->irq_bit_count); i++) { 
if 
if (state % 4 == 0) 
if (state % 2 == 0) 
if (unlikely(b43_status(dev) != B43_STAT_STARTED)) 
if (b43_debug(dev, B43_DBG_PWORK_STOP)) 
if (b43_debug(dev, B43_DBG_PWORK_FAST)) 
iffies_relative(HZ * 15); 
if communication with the device works correctly. */ 
for read/write and endianness problems. */ 
if (b43_shm_read32(dev, B43_SHM_SHARED, 0) != 0x55AAAA55) 
if (b43_shm_read32(dev, B43_SHM_SHARED, 0) != 0xAA5555AA) 
if unaligned 32bit SHM_SHARED access works properly. 
if (b43_shm_read32(dev, B43_SHM_SHARED, 2) != 0x55663344) 
if (b43_shm_read16(dev, B43_SHM_SHARED, 0) != 0x1122 || 
if ((dev->dev->core_rev >= 3) && (dev->dev->core_rev <= 10)) { 
if (b43_read16(dev, B43_MMIO_TSF_CFP_START_LOW) != 0xBBBB) 
if (b43_read16(dev, B43_MMIO_TSF_CFP_START_HIGH) != 0xCCCC) 
if (v != (B43_MACCTL_GMODE | B43_MACCTL_IHR_ENABLED)) 
ifdef CONFIG_B43_HWRNG 
if (likely(dev && b43_status(dev) >= B43_STAT_INITIALIZED)) { 
if /* CONFIG_B43_HWRNG */ 
ifdef CONFIG_B43_HWRNG 
if /* CONFIG_B43_HWRNG */ 
ifdef CONFIG_B43_HWRNG 
if (err) { 
if /* CONFIG_B43_HWRNG */ 
if (unlikely(!dev || b43_status(dev) < B43_STAT_STARTED)) { 
for (queue_num = 0; queue_num < B43_QOS_QUEUE_NUM; queue_num++) { 
while (skb_queue_len(&wl->tx_queue[queue_num])) { 
if (b43_using_pio_transfers(dev)) 
if (err == -ENOSPC) { 
if (unlikely(err)) 
if (!err) 
if B43_DEBUG 
if 
if (unlikely(skb->len < 2 + 2 + 6)) { 
if (!wl->tx_queue_stopped[skb->queue_mapping]) { 
if (!dev->qos_enabled) 
ifs; 
ifs; 
for (i = 0; i < ARRAY_SIZE(params); i++) { 
if (!dev->qos_enabled) 
for (i = 0; i < ARRAY_SIZE(wl->qos_params); i++) { 
for (i = 0; i < ARRAY_SIZE(wl->qos_params); i++) { 
ifs = 2; 
ifs = 2; 
ifs = 3; 
ifs = 7; 
if (!dev->qos_enabled) { 
if *vif, u16 _queue, 
if (queue >= ARRAY_SIZE(wl->qos_params)) { 
if (unlikely(!dev || (b43_status(dev) < B43_STAT_INITIALIZED))) 
if *vif) 
if (dev && (b43_status(dev) >= B43_STAT_INITIALIZED)) 
if *vif, u64 tsf) 
if (dev && (b43_status(dev) >= B43_STAT_INITIALIZED)) 
if (!((gmode && phy->supports_2ghz) || 
if (!!phy->gmode == !!gmode) { 
for band switching */ 
ifdef CONFIG_B43_BCMA 
if (gmode) 
if 
if (gmode) 
if 
force this to avoid overflowing 
if necessary). This might change the active core. */ 
if (err) 
if the core changed */ 
if (conf_is_ht(conf)) 
if (changed & IEEE80211_CONF_CHANGE_RETRY_LIMITS) 
if (!changed) 
if (conf->chandef.chan->hw_value != phy->channel) 
if (conf->power_level != 0) { 
for RX and management frame TX. */ 
if (phy->ops->set_rx_antenna) 
if (wl->radio_enabled != phy->radio_on) { 
if (!dev->radio_hw_enable) { 
if (wl->vif && reload_bss) 
for (i = 0; i < sband->n_bitrates; i++) { 
if (b43_is_cck_rate(rate->hw_value)) { 
if (b43_is_cck_rate(rate->hw_value)) { 
if *vif, 
if (!dev || b43_status(dev) < B43_STAT_STARTED) 
if != vif); 
if (conf->bssid) 
if (b43_status(dev) >= B43_STAT_INITIALIZED) { 
if (changed & BSS_CHANGED_BSSID) 
for AP/mesh mode. */ 
if (changed & BSS_CHANGED_BASIC_RATES) 
if (changed & BSS_CHANGED_ERP_SLOT) { 
if *vif, struct ieee80211_sta *sta, 
if (modparam_nohwcrypt) 
if ((vif->type == NL80211_IFTYPE_ADHOC || 
for the RSN IBSS group keys. This 
for group addressed 
if (!dev || b43_status(dev) < B43_STAT_INITIALIZED) 
if (dev->fw.pcm_request_failed || !dev->hwcrypto_enabled) { 
for the crypto engine. 
if (index > 3) 
if (algorithm == B43_SEC_ALGO_TKIP && 
if (key->flags & IEEE80211_KEY_FLAG_PAIRWISE) { 
if (err) 
if (algorithm == B43_SEC_ALGO_WEP40 || 
if (algorithm == B43_SEC_ALGO_TKIP) 
if (err) 
if (!err) { 
for keyidx: %d, " 
if (!dev) { 
if (changed && b43_status(dev) >= B43_STAT_INITIALIZED) 
ifferent from the passed in dev, 
while we unlocked the mutex. */ 
if (!dev) 
if (!dev || b43_status(dev) < B43_STAT_STARTED) 
if (!dev || b43_status(dev) < B43_STAT_STARTED) { 
while we were unlocked. */ 
if (b43_bus_host_is_sdio(dev->dev)) { 
if (b43_bus_host_is_sdio(dev->dev)) { 
if (!dev) 
if (dev != orig_dev) { 
for (queue_num = 0; queue_num < B43_QOS_QUEUE_NUM; queue_num++) { 
while (skb_queue_len(&wl->tx_queue[queue_num])) { 
if (b43_bus_host_is_sdio(dev->dev)) { 
if (err) { 
if (err) { 
if (phy_rev >= 4) 
if (phy_rev != 2 && phy_rev != 4 && phy_rev != 6 
if (phy_rev > 9) 
ifdef CONFIG_B43_PHY_N 
if (phy_rev > 9) 
if 
if (phy_rev > 2) 
if 
if (phy_rev > 1) 
if 
if (phy_rev > 1) 
if 
if (unsupported) { 
if (dev->dev->core_rev >= 24) { 
for (tmp = 0; tmp < 3; tmp++) { 
for our "ver" and has separated "ver" */ 
if (dev->dev->chip_id == 0x4317) { 
if (dev->dev->chip_rev == 1) 
if (radio_manuf != 0x17F /* Broadcom */) 
if (radio_ver != 0x2060) 
if (radio_rev != 1) 
if (radio_manuf != 0x17F) 
if ((radio_ver & 0xFFF0) != 0x2050) 
if (radio_ver != 0x2050) 
if (radio_ver != 0x2055 && radio_ver != 0x2056) 
if (radio_ver != 0x2062 && radio_ver != 0x2063) 
if (radio_ver != 0x2059) 
if (radio_ver != 0x2064) 
if (unsupported) { 
for_init(struct b43_wldev *dev, 
iffies; 
if B43_DEBUG 
if 
for_init(struct b43_wldev *dev) 
for_init(dev, &dev->phy); 
if (b43_modparam_verbose < B43_VERBOSITY_DEBUG) 
if (!modparam_btcoex) 
if (!(sprom->boardflags_lo & B43_BFL_BTCOEXIST)) 
if (dev->phy.type != B43_PHYTYPE_B && !dev->phy.gmode) 
if (sprom->boardflags_lo & B43_BFL_BTCMOD) 
if (!modparam_btcoex) 
ifdef CONFIG_B43_SSB 
if 
if ((bus->chip_id == 0x4311 && bus->chip_rev == 2) || 
if (dev->phy.type == B43_PHYTYPE_A) 
if (b43_is_mode(dev->wl, NL80211_IFTYPE_ADHOC) || idle) 
if ((dev->phy.radio_ver == 0x2050) && (dev->phy.radio_rev == 8)) 
if (b43_is_mode(dev->wl, NL80211_IFTYPE_ADHOC)) { 
if (dev->phy.type == B43_PHYTYPE_A) 
if (!dev || b43_status(dev) != B43_STAT_INITIALIZED) 
ifdef CONFIG_B43_BCMA 
if 
if 
if (dev->wl->current_beacon) { 
if (err) 
if (!b43_device_is_enabled(dev)) 
for_init(dev); 
ifdef CONFIG_B43_BCMA 
if 
if 
if (phy->ops->prepare_hardware) { 
if (err) 
if (err) 
if (phy->type == B43_PHYTYPE_G) { 
if (phy->rev == 1) 
if (sprom->boardflags_lo & B43_BFL_PACTRL) 
if (phy->radio_ver == 0x2050) { 
if (phy->radio_rev < 6) 
if (sprom->boardflags_lo & B43_BFL_XTAL_NOSLOW) 
if defined(CONFIG_B43_SSB) && defined(CONFIG_SSB_DRIVER_PCICORE) 
if 
if (phy->type == B43_PHYTYPE_B) 
if (b43_bus_host_is_pcmcia(dev->dev) || 
if (dev->use_pio) { 
formance.\n"); 
if (err) 
if *vif) 
if (vif->type != NL80211_IFTYPE_AP && 
if->type != NL80211_IFTYPE_STATION && 
if->type != NL80211_IFTYPE_ADHOC) 
if (wl->operating) 
if->type); 
if = vif; 
if->addr, ETH_ALEN); 
if (err == 0) 
if *vif) 
if->type); 
if != vif); 
ific information to make sure 
if (b43_status(dev) < B43_STAT_INITIALIZED) { 
if (err) 
if (b43_status(dev) < B43_STAT_STARTED) { 
if (err) { 
if device doesn't support rfkill irq */ 
if initialization was 
if (!err) 
if (!dev) 
if (b43_status(dev) >= B43_STAT_STARTED) { 
if (!dev) 
ify(struct ieee80211_hw *hw, 
ify_cmd notify_cmd, 
if || wl->vif != vif); 
if (dev && (b43_status(dev) >= B43_STAT_INITIALIZED)) { 
ifier(struct ieee80211_hw *hw) 
if (dev && (b43_status(dev) >= B43_STAT_INITIALIZED)) { 
if (idx != 0) 
ify		= b43_op_sta_notify, 
ifier, 
if (prev_status >= B43_STAT_STARTED) { 
if (!dev) { 
if (prev_status >= B43_STAT_INITIALIZED) 
if (prev_status >= B43_STAT_INITIALIZED) { 
if (err) 
if (prev_status >= B43_STAT_STARTED) { 
if (err) { 
if (err) 
if (err) { 
if (wl->vif) 
if (have_2ghz_phy) 
if (dev->phy.type == B43_PHYTYPE_N) { 
if (have_5ghz_phy) 
ifdef CONFIG_B43_BCMA 
if 
if (dev->dev->bus_type == B43_BUS_SSB && 
if 
if (dev->dev->bus_sprom->dev_id) 
for gathering basic information about the HW, only. 
if (err) { 
for the first init needs */ 
ifdef CONFIG_B43_BCMA 
if 
if (dev->dev->core_rev >= 5) { 
if 
if (err) 
if (!have_2ghz_phy && !have_5ghz_phy) { 
if (err) 
if (err) 
if (err) 
if (!wl->current_dev) 
if (!wldev) 
if (err) 
ifdef CONFIG_B43_SSB 
if (bus->boardinfo.vendor == SSB_BOARDVENDOR_DELL && 
if (bus->boardinfo.vendor == PCI_VENDOR_ID_APPLE && 
if (bus->bustype == SSB_BUSTYPE_PCI) { 
if (IS_PDEV(pdev, BROADCOM, 0x4318, ASUSTEK, 0x100F) || 
if 
if (!hw) { 
if (is_valid_ether_addr(sprom->et1mac)) 
for (queue_num = 0; queue_num < B43_QOS_QUEUE_NUM; queue_num++) { 
ifdef CONFIG_B43_BCMA 
if (!modparam_allhwsupport && 
for cores revisions 0x17 and 0x18 disabled by module param allhwsupport=0. Try b43.allhwsupport=1\n"); 
if (!dev) 
if (IS_ERR(wl)) { 
if (err) 
fore unregistering from ieee80211, 
if (!wldev->fw.ucode.data) 
if (wl->current_dev == wldev && wl->hw_registred) { 
if 
if (!dev) 
if (wl) { 
if (IS_ERR(wl)) { 
if (err) 
fore unregistering from ieee80211, 
if (!wldev->fw.ucode.data) 
if (wl->current_dev == wldev && wl->hw_registred) { 
if /* CONFIG_B43_SSB */ 
form a hardware reset. This can be called from any context. */ 
if we are in shutdown. */ 
ifdef CONFIG_B43_PCI_AUTOSELECT 
if 
if 
if 
if 
if 
if (err) 
if (err) 
ifdef CONFIG_B43_BCMA 
if (err) 
if 
if (err) 
if 
ifdef CONFIG_B43_SSB 
if 
if 
ifdef CONFIG_B43_SSB 
if 
if 
file : ./test/kernel/drivers/net/wireless/ti/wl12xx/main.c 
[ OK ] open : 4 ok... 
buf : /*
ify it under the terms of the GNU General Public License 
for more details. 
if not, write to the Free Software 
form_device.h> 
ife_time           = 512000, 
ifsn       = 3, 
ifsn       = 7, 
ifsn       = CONF_TX_AIFS_PIFS, 
ifsn       = CONF_TX_AIFS_PIFS, 
forced_ps                   = false, 
for wl127x chips is given in the 
for wl128x chips. 
iff             = 0xff,       /* default */ 
ift = 4, 
ift = 10, 
ific rate */ 
ific rate */ 
if (wl->chip.id != CHIP_ID_128X_PG20) { 
if (ret < 0) 
ify_chip(struct wl1271 *wl) 
if (ret < 0) 
if (ret < 0) 
if (ret < 0) 
if (ret < 0) 
if (ret < 0) 
for data ready */ 
if (ret < 0) 
while (!(val & OCP_READY_MASK) && --timeout); 
if OK */ 
if (out) 
if (ret < 0) 
if (spare_reg == 0xFFFF) 
if (ret < 0) 
if (ret < 0) 
for 15msec, to let the HW settle */ 
if (ret < 0) 
if (tcxo_detection & TCXO_DET_FAILED) 
if (ret < 0) 
if (fref_detection & FREF_CLK_DETECT_FAIL) 
if (ret < 0) 
if (ret < 0) 
if (ret < 0) 
if (spare_reg == 0xFFFF) 
if (ret < 0) 
if (priv->tcxo_clock == WL12XX_TCXOCLOCK_16_8 || 
if (ret < 0) 
if (pll_config == 0xFFFF) 
while FREF is used to sync 
if (priv->ref_clock == WL12XX_REFCLOCK_26_XTAL || 
if (!wl128x_switch_tcxo_to_fref(wl)) 
if (ret < 0) 
if (sys_clk_cfg == 0xFFFF) 
if (sys_clk_cfg & PRCM_CM_EN_MUX_WLAN_FREF) 
if (priv->tcxo_clock == WL12XX_TCXOCLOCK_16_368 || 
if (!wl128x_switch_tcxo_to_fref(wl)) 
if (!wl128x_is_tcxo_valid(wl)) 
if (!wl128x_is_fref_valid(wl)) 
if (WL127X_PG_GET_MAJOR(wl->hw_pg_ver) < 3) 
if (priv->ref_clock == CONF_REF_CLK_19_2_E || 
if (priv->ref_clock == CONF_REF_CLK_26_E || 
if (priv->ref_clock != CONF_REF_CLK_19_2_E) { 
if (ret < 0) 
if (ret < 0) 
if (ret < 0) 
if (ret < 0) 
if (ret < 0) 
if (ret < 0) 
if (ret < 0) 
if (ret < 0) 
form soft reset */ 
if (ret < 0) 
iffies + usecs_to_jiffies(SOFT_RESET_MAX_TIME); 
while (1) { 
if (ret < 0) 
if ((boot_data & ACX_SLV_SOFT_RESET_BIT) == 0) 
if (time_after(jiffies, timeout)) { 
if (ret < 0) 
if (wl->chip.id == CHIP_ID_128X_PG20) { 
if (ret < 0) 
if (ret < 0) 
if (ret < 0) 
if (ret < 0) 
ify-write DRPW_SCRATCH_START register (see next state) 
fore taking DRPw out of reset */ 
if (ret < 0) 
if (wl->chip.id == CHIP_ID_128X_PG20) 
if (ret < 0) 
if (ret < 0) 
if (ret < 0) 
if (ret < 0) 
if (ret < 0) 
if (ret < 0) 
if (ret < 0) 
if (wl->chip.id == CHIP_ID_128X_PG20) { 
if (ret < 0) 
fore the firmware is loaded */ 
if (ret < 0) 
if (ret < 0) 
if (ret < 0) 
if (ret < 0) 
if (ret < 0) 
if (ret < 0) 
if (ret < 0) 
if (ret < 0) 
if (ret < 0) 
if (ret < 0) 
if (wl->chip.id == CHIP_ID_128X_PG20) { 
if (wl->chip.id == CHIP_ID_128X_PG20) { 
ife: %d mem: %d extra: %d", 
ife_time), 
ife: %d mem: %d", 
ife_time), 
if (rx_desc & RX_BUF_UNALIGNED_PAYLOAD) 
if (data_len < sizeof(*desc) || 
if (wl->fw_status->tx_results_counter == 
if (wl->chip.id == CHIP_ID_128X_PG20) { 
if (ret < 0) 
if (wl->plt_mode == PLT_FEM_DETECT) 
if (ret < 0) 
if (wl->quirks & WLCORE_QUIRK_TX_BLOCKSIZE_ALIGN) 
fore wl1271_acx_init_mem_config() */ 
if (ret < 0) 
if (ret < 0) 
if (wl->plt_mode == PLT_FEM_DETECT) 
if (ret < 0) 
if (ret < 0) 
if *wlvif) 
if (wl->chip.id == CHIP_ID_128X_PG20) { 
if the PG is >= (2, 1) */ 
if the PG is >= (3, 1) */ 
if (ret < 0) 
if (ret < 0) 
if (ret < 0) 
if (wl->chip.id == CHIP_ID_128X_PG20) 
if (ret >= 0 && ver) 
if (wl12xx_mac_in_fuse(wl)) 
if (ret < 0) 
if (ret < 0) 
if (wl->plt_mode == PLT_FEM_DETECT) 
if (ret < 0) 
if (ret < 0) 
if (ret < 0) 
for CAM power saving (ie. always active) */ 
if (ret < 0) 
if (ret < 0) 
while we are WL1271_STATE_OFF the IRQ 
if (is_gem) 
if *vif, 
if, sta, key_conf); 
if (test_bit(hlid, (unsigned long *)&wl->fw_fast_lnk_map)) 
for low priority */ 
ify_chip		= wl12xx_identify_chip, 
for_event		= wl12xx_wait_for_event, 
if		= NULL, 
iface_limit wl12xx_iface_limits[] = { 
iface_combination 
iface_limits, 
ifferent_channels = 1, 
form_data *pdata = pdev_data->pdata; 
iface_combinations = wl12xx_iface_combinations; 
if (!fref_param) { 
if (!strcmp(fref_param, "19.2")) 
if (!strcmp(fref_param, "26")) 
if (!strcmp(fref_param, "26x")) 
if (!strcmp(fref_param, "38.4")) 
if (!strcmp(fref_param, "38.4x")) 
if (!strcmp(fref_param, "52")) 
if (!tcxo_param) { 
if (!strcmp(tcxo_param, "19.2")) 
if (!strcmp(tcxo_param, "26")) 
if (!strcmp(tcxo_param, "38.4")) 
if (!strcmp(tcxo_param, "52")) 
if (!strcmp(tcxo_param, "16.368")) 
if (!strcmp(tcxo_param, "32.736")) 
if (!strcmp(tcxo_param, "16.8")) 
if (!strcmp(tcxo_param, "33.6")) 
if (!priv->rx_mem_addr) 
form_device *pdev) 
if (IS_ERR(hw)) { 
if (ret) 
form_device *pdev) 
if (!wl) 
form_device_id wl12xx_id_table[] = { 
form, wl12xx_id_table); 
form_driver(wl12xx_driver); 
file : ./test/kernel/drivers/net/wireless/ti/wl18xx/main.c 
[ OK ] open : 4 ok... 
buf : /*
ify it under the terms of the GNU General Public License 
for more details. 
if not, write to the Free Software 
form_device.h> 
ific rate */ 
ific rate */ 
ife_time           = 512000, 
ifsn       = 3, 
ifsn       = 7, 
ifsn       = CONF_TX_AIFS_PIFS, 
ifsn       = CONF_TX_AIFS_PIFS, 
forced_ps                   = false, 
iff             = 0xff,       /* default */ 
ift = 4, 
ift = 10, 
ify_chip(struct wl1271 *wl) 
for PLT */ 
if (ret < 0) 
if (ret < 0) 
if (ret < 0) 
if (ret < 0) 
if (ret < 0) 
if (ret < 0) 
if (ret < 0) 
if (wl18xx_clk_table[clk_freq].swallow) { 
if (ret < 0) 
if (ret < 0) 
if (ret < 0) 
if (ret < 0) 
if (ret < 0) 
if (ret < 0) 
if (ret < 0) 
if (ret < 0) 
if (ret < 0) 
if (ret < 0) 
if (ret < 0) 
if (ret < 0) 
if (ret < 0) 
if this is all needed */ 
if (ret < 0) 
if (ret < 0) 
if (ret < 0) 
for FDSP code RAM corruption (needed for PG2.1 
if (ret < 0) 
if (ret < 0) 
if (ret < 0) 
if (!params) { 
if (ret < 0) 
if (ret < 0) 
if (ret < 0) 
if (ret < 0) 
if (ret < 0) 
if (ret < 0) 
if (ret < 0) 
if (ret < 0) 
if only the last frame is to be padded, we unset this bit on Tx */ 
ife: %d mem: %d", desc->hlid, 
ife_time), 
if (rx_desc & RX_BUF_PADDED_PAYLOAD) 
if (data_len < sizeof(*desc)) 
if (wl->quirks & WLCORE_QUIRK_TX_BLOCKSIZE_ALIGN) { 
if (wl->quirks & WLCORE_QUIRK_RX_BLOCKSIZE_ALIGN) { 
if_cfg_bitmap(wl, host_cfg_bitmap, 
if (ret < 0) 
if (ret < 0) 
if (checksum_param) { 
if (ret != 0) 
if (!checksum_param) { 
if (skb->ip_summed != CHECKSUM_PARTIAL) { 
if (WARN_ON(ip_hdr_offset >= (1<<7))) { 
if (desc->status & WL18XX_RX_CHECKSUM_MASK) 
forced through config 
ify the wlvif->rate_set instead 
if *wlvif) 
if (wlvif->channel_type == NL80211_CHAN_HT40MINUS || 
if (wl18xx_is_mimo_supported(wl)) { 
if *wlvif) 
if->channel_type == NL80211_CHAN_HT40PLUS) { 
if (WARN_ON(wlvif->band != IEEE80211_BAND_5GHZ)) 
if (wl18xx_is_mimo_supported(wl) && 
if a peer doesn't 
if (ret < 0) 
if (ret < 0) 
if (ret < 0) 
if ((rom <= 0xE) && (package_type == WL18XX_PACKAGE_TYPE_WSP)) 
if (ret < 0) 
if (ver) 
if (ret < 0) { 
if (fw->size != WL18XX_CONF_SIZE) { 
if (conf_file->header.magic != cpu_to_le32(WL18XX_CONF_MAGIC)) { 
if (conf_file->header.version != cpu_to_le32(WL18XX_CONF_VERSION)) { 
for 18xx */ 
if (ret < 0) 
if (ret < 0) 
if (ret < 0) 
if (ret < 0) 
if (!wl->fuse_oui_addr && !wl->fuse_nic_addr) { 
if (priv->extra_spare_key_count) 
if *vif, 
fore: %d", 
if, sta, key_conf); 
if (special_enc) { 
if (cmd == DISABLE_KEY) { 
if (!change_spare) 
if (priv->extra_spare_key_count) 
if (wl->quirks & WLCORE_QUIRK_TX_PAD_LAST_FRAME) { 
ifications */ 
if *wlvif, 
if (!(changed & IEEE80211_RC_BW_CHANGED)) 
if (WARN_ON(wlvif->bss_type != BSS_TYPE_STA_BSS)) 
fore association */ 
if (wlvif->sta.role_chan_type == NL80211_CHAN_HT40MINUS || 
if->sta.hlid, wide); 
if_to_vif(wlvif)); 
if (test_bit(hlid, (unsigned long *)&suspend_bitmap)) 
if (test_bit(hlid, (unsigned long *)&wl->fw_fast_lnk_map) && 
if (test_bit(hlid, (unsigned long *)&suspend_bitmap)) 
if (test_bit(hlid, (unsigned long *)&wl->fw_fast_lnk_map) && 
ify_chip	= wl18xx_identify_chip, 
for_event	= wl18xx_wait_for_event, 
for wide channels in 2Ghz */ 
for wide channels in 5Ghz */ 
for SISO 20 */ 
for MIMO rates in 20mhz channel */ 
iface_limit wl18xx_iface_limits[] = { 
iface_limit wl18xx_iface_ap_limits[] = { 
iface_combination 
iface_limits, 
ifferent_channels = 2, 
iface_ap_limits, 
ifferent_channels = 1, 
iface_combinations = wl18xx_iface_combinations; 
if (num_rx_desc_param != -1) 
if (ret < 0) 
if (board_type_param) { 
if (!strcmp(board_type_param, "hdk")) { 
if (!strcmp(board_type_param, "dvp")) { 
if (!strcmp(board_type_param, "evb")) { 
if (!strcmp(board_type_param, "com8")) { 
if (priv->conf.phy.board_type >= NUM_BOARD_TYPES) { 
if (low_band_component_param != -1) 
if (low_band_component_type_param != -1) 
if (high_band_component_param != -1) 
if (high_band_component_type_param != -1) 
if (pwr_limit_reference_11_abg_param != -1) 
if (n_antennas_2_param != -1) 
if (n_antennas_5_param != -1) 
if (dc2dc_param != -1) 
if (ht_mode_param) { 
if (!strcmp(ht_mode_param, "wide")) 
if (!strcmp(ht_mode_param, "siso20")) 
if (priv->conf.ht.mode == HT_MODE_DEFAULT) { 
if (wl18xx_is_mimo_supported(wl)) 
if (priv->conf.ht.mode == HT_MODE_WIDE) { 
if (priv->conf.ht.mode == HT_MODE_SISO20) { 
if (!checksum_param) { 
if = NULL; 
form_device *pdev) 
if (IS_ERR(hw)) { 
if (ret) 
form_device_id wl18xx_id_table[] = { 
form, wl18xx_id_table); 
form_driver(wl18xx_driver); 
file : ./test/kernel/drivers/net/wireless/ti/wlcore/main.c 
[ OK ] open : 4 ok... 
buf : 
ify it under the terms of the GNU General Public License 
for more details. 
if not, write to the Free Software 
if *vif, 
if *wlvif); 
if (WARN_ON(wlvif->bss_type != BSS_TYPE_STA_BSS)) 
if (!test_bit(WLVIF_FLAG_STA_ASSOCIATED, &wlvif->flags)) 
if (test_and_set_bit(WLVIF_FLAG_STA_STATE_SENT, &wlvif->flags)) 
if, wlvif->sta.hlid); 
ify(struct wiphy *wiphy, 
for (i = 0; i < band->n_channels; i++) { 
if (ch->flags & IEEE80211_CHAN_DISABLED) 
if (ch->flags & IEEE80211_CHAN_RADAR) 
if *wlvif, 
if, enable); 
if (enable) 
if->flags); 
if *wlvif) 
if rx_streaming is disabled */ 
if (period && 
if, true); 
if, false); 
if->rx_streaming_timer); 
if *wlvif = container_of(work, struct wl12xx_vif, 
if->wl; 
if (test_bit(WLVIF_FLAG_RX_STREAMING_STARTED, &wlvif->flags) || 
if (!wl->conf.rx_streaming.interval) 
if (ret < 0) 
if, true); 
if->rx_streaming_timer, 
if *wlvif = container_of(work, struct wl12xx_vif, 
if->wl; 
if (!test_bit(WLVIF_FLAG_RX_STREAMING_STARTED, &wlvif->flags)) 
if (ret < 0) 
if, false); 
if *wlvif = (struct wl12xx_vif *)data; 
if->rx_streaming_disable_work); 
if the watchdog is not armed, don't do anything */ 
iffies(wl->conf.tx.tx_watchdog_timeout)); 
if (unlikely(wl->state != WLCORE_STATE_ON)) 
if (unlikely(wl->tx_allocated_blocks == 0)) 
if a ROC is in progress, we might not have any Tx for a long 
if (find_first_bit(wl->roc_map, WL12XX_MAX_ROLES) < WL12XX_MAX_ROLES) { 
for %d ms due to ROC", 
if a scan is in progress, we might not have any Tx for a long 
if (wl->scan.state != WL1271_SCAN_STATE_IDLE) { 
for %d ms due to scan", 
for a long time for a sleeping station, 
if (wl->active_sta_count) { 
for %d ms. AP has " 
for %d ms. Starting recovery", 
if (fwlog_mem_blocks != -1) { 
if (fwlog_param) { 
if (!strcmp(fwlog_param, "ondemand")) { 
if (!strcmp(fwlog_param, "dbgpins")) { 
if (!strcmp(fwlog_param, "disable")) { 
if (bug_on_recovery != -1) 
if (no_recovery != -1) 
if *wlvif, 
if the STA is asleep with too little 
if (!fw_ps || tx_pkts < WL1271_PS_STA_MAX_PACKETS) 
if the STA is asleep with enough blocks in FW. 
for the global and broadcast AP links 
if (wl->active_link_count > (wl->ap_count*2 + 1) && fw_ps && 
if, hlid, true); 
if *wlvif, 
if (wl->ap_fw_ps_map != cur_fw_ps_map) { 
if->ap.sta_hlid_map, wl->num_links) 
if *wlvif; 
if (ret < 0) 
for (i = 0; i < NUM_TX_QUEUES; i++) { 
for_each_set_bit(i, wl->links_map, wl->num_links) { 
iff = (status->counters.tx_lnk_free_pkts[i] - 
if (diff == 0) 
iff; 
iff; 
if (likely(wl->tx_blocks_freed <= status->total_released_blks)) 
if (freed_blocks) { 
fore 
if more blocks are available now, tx work can be scheduled */ 
for AP update num of allocated TX blocks per link and ps status */ 
if, status); 
while ((skb = skb_dequeue(&wl->deferred_rx_queue))) 
while ((skb = skb_dequeue(&wl->deferred_tx_queue))) 
while (skb_queue_len(&wl->deferred_rx_queue)); 
if (wl->platform_quirks & WL12XX_PLATFORM_QUIRK_EDGE_IRQ) 
if (unlikely(wl->state != WLCORE_STATE_ON)) 
if (ret < 0) 
while (!done && loopcount--) { 
fore acknowledging the chip. Since the mutex is held, 
if (ret < 0) 
if (!intr) { 
if (unlikely(intr & WL1271_ACX_INTR_WATCHDOG)) { 
if (unlikely(intr & WL1271_ACX_SW_INTR_WATCHDOG)) { 
if (likely(intr & WL1271_ACX_INTR_DATA)) { 
if (ret < 0) 
if any tx blocks were freed */ 
if (!test_bit(WL1271_FLAG_FW_TX_BUSY, &wl->flags) && 
if (ret < 0) 
for tx results */ 
if (ret < 0) 
if (defer_count > WL1271_DEFERRED_QUEUE_LIMIT) 
if (intr & WL1271_ACX_INTR_EVENT_A) { 
if (ret < 0) 
if (intr & WL1271_ACX_INTR_EVENT_B) { 
if (ret < 0) 
if (intr & WL1271_ACX_INTR_INIT_COMPLETE) 
if (intr & WL1271_ACX_INTR_HW_AVAILABLE) 
if (wl->elp_compl) { 
if (test_bit(WL1271_FLAG_SUSPENDED, &wl->flags)) { 
if (ret) 
if (!test_bit(WL1271_FLAG_FW_TX_BUSY, &wl->flags) && 
if_counter_data { 
if *cur_vif; 
if_count_iter(void *data, u8 *mac, 
if_counter_data *counter = data; 
if (counter->cur_vif == vif) 
if_count(struct ieee80211_hw *hw, 
if_counter_data *data) 
if = cur_vif; 
if_count_iter, data); 
if (plt) { 
if_count() here because 
if (wl->last_vif_count > 1 && wl->mr_fw_name) { 
if (wl->fw_type == fw_type) 
if (ret < 0) { 
if (fw->size % 4) { 
if (!wl->fw) { 
for the firmware"); 
if (wl->state == WLCORE_STATE_ON) { 
if ((wl->quirks & WLCORE_QUIRK_FWLOG_NOT_IMPLEMENTED) || 
if (!block) 
if the fw is hanged or if 
if (wl1271_ps_elp_wakeup(wl)) 
if (!wl->watchdog_recovery && 
if (ret < 0) 
if (!addr) 
if (wl->conf.fwlog.mode == WL12XX_FWLOG_CONTINUOUS) { 
if (ret < 0) { 
if (ret < 0) 
if (!wl12xx_copy_fwlog(wl, block + offset, 
while (addr && (addr != end_of_log)); 
if (ret < 0) 
if (ret < 0) 
if (ret < 0) 
if *wlvif; 
if (wl->state == WLCORE_STATE_OFF || wl->plt) 
if (!test_bit(WL1271_FLAG_INTENDED_FW_RECOVERY, &wl->flags)) { 
if (wl->conf.recovery.no_recovery) { 
if_list)) { 
if, list); 
if, false); 
if (!wl->raw_fw_status) 
if (!wl->fw_status) 
if = kzalloc(sizeof(*wl->tx_res_if), GFP_KERNEL); 
if (ret < 0) 
if (ret < 0) 
if (ret < 0) 
if (ret < 0) 
ify the code and since the performance impact is 
for all different 
if the bus supports blocksize alignment and, if it 
if (!wl1271_set_block_size(wl)) 
if (ret < 0) 
if (ret < 0) 
if (wl->state != WLCORE_STATE_OFF) { 
while (retries) { 
if (ret < 0) 
if (plt_mode != PLT_CHIP_AWAKE) { 
if (ret < 0) 
fore setting the state to OFF. 
if (!wl->plt) { 
if *vif = info->control.vif; 
if (!vif) { 
if = wl12xx_vif_to_data(vif); 
if, skb, control->sta); 
if the link is invalid or the queue is stopped 
for any reason but watermark. Watermark is a "soft"-stop so we 
if (hlid == WL12XX_INVALID_LINK_ID || 
if, q) && 
if->tx_queue_count[q]++; 
if (wlvif->tx_queue_count[q] >= WL1271_TX_QUEUE_HIGH_WATERMARK && 
for q %d", q); 
ific setup must run before the first TX packet - 
fore that, the tx_work will not be initialized! 
if (!test_bit(WL1271_FLAG_FW_TX_BUSY, &wl->flags) && 
if one is already pending */ 
if (!test_bit(WL1271_FLAG_FW_TX_BUSY, &wl->flags)) 
formance wise 
if (!skb) { 
ifdef CONFIG_PM 
if (!p->mask) { 
ifferent offsets 
ify that the total number of fields 
for this pattern won't exceed FW limits (8) 
if there's a pattern which crosses Ethernet/IP header 
for (i = 0; i < p->pattern_len; i++) { 
if (!in_field) { 
if (i == WL1271_RX_FILTER_ETH_HEADER_SIZE) { 
if (in_field) { 
if (in_field) { 
if (num_fields > WL1271_RX_FILTER_MAX_FIELDS) { 
if (fields_size > WL1271_RX_FILTER_MAX_FIELDS_SIZE) { 
if (filter == NULL) 
for (i = 0; i < filter->num_fields; i++) 
if (filter->num_fields == WL1271_RX_FILTER_MAX_FIELDS) { 
if (!field->pattern) { 
for (i = 0; i < filter->num_fields; i++) 
for (i = 0; i < filter->num_fields; i++) { 
if (!filter) { 
while (i < p->pattern_len) { 
for (j = i; j < p->pattern_len; j++) { 
if (i < WL1271_RX_FILTER_ETH_HEADER_SIZE && 
if (i < WL1271_RX_FILTER_ETH_HEADER_SIZE) { 
if (ret) 
if (!wow || wow->any || !wow->n_patterns) { 
if (ret) 
if (ret) 
if (WARN_ON(wow->n_patterns > WL1271_MAX_RX_FILTERS)) 
fore clearing current FW state */ 
if (ret) { 
if (ret) 
if (ret) 
for (i = 0; i < wow->n_patterns; i++) { 
if (ret) { 
if (ret) 
if *wlvif, 
if (!test_bit(WLVIF_FLAG_STA_ASSOCIATED, &wlvif->flags)) 
if (ret < 0) 
if (ret < 0) 
if ((wl->conf.conn.suspend_wake_up_event == 
if, 
if (ret < 0) 
if *wlvif) 
if (!test_bit(WLVIF_FLAG_AP_STARTED, &wlvif->flags)) 
if (ret < 0) 
if, true); 
if *wlvif, 
if (wlvif->bss_type == BSS_TYPE_STA_BSS) 
if (wlvif->bss_type == BSS_TYPE_AP_BSS) 
if *wlvif) 
if->bss_type == BSS_TYPE_AP_BSS; 
if ((!is_ap) && (!is_sta)) 
if (is_sta && !test_bit(WLVIF_FLAG_STA_ASSOCIATED, &wlvif->flags)) 
if (ret < 0) 
if (is_sta) { 
if ((wl->conf.conn.suspend_wake_up_event == 
if, 
if (ret < 0) 
if (is_ap) { 
if *wlvif; 
form the recovery before suspending */ 
form recovery"); 
if(wl, wlvif) { 
if (ret < 0) { 
for spinlock as interrupts are disabled. 
if above tx_flush failed. We will detect 
if *wlvif; 
if 
if (test_and_clear_bit(WL1271_FLAG_PENDING_WORK, &wl->flags)) 
fore calling any SDIO functions */ 
if (run_irq_work) { 
if recovery is pending */ 
if (ret) 
if (pending_recovery) { 
forgotten recovery on resume"); 
if(wl, wlvif) { 
form a spurious recovery. 
if 
fore downloading and 
if (wl->state == WLCORE_STATE_OFF) { 
fore the cancel_work calls below, so that the work 
while doing so without deadlocking. 
if (!test_bit(WL1271_FLAG_RECOVERY_IN_PROGRESS, &wl->flags)) 
ify MAC80211 about the remaining pending TX frames */ 
if (test_and_clear_bit(WL1271_FLAG_RECOVERY_IN_PROGRESS, &wl->flags)) 
formed after the cancel_work calls and the associated 
fore all these vars have been reset. 
for (i = 0; i < NUM_TX_QUEUES; i++) { 
if); 
if *vif; 
if = container_of(dwork, struct wl12xx_vif, channel_switch_work); 
if->role_id); 
if (unlikely(wl->state != WLCORE_STATE_ON)) 
if (!test_and_clear_bit(WLVIF_FLAG_CS_PROGRESS, &wlvif->flags)) 
if = wl12xx_wlvif_to_vif(wlvif); 
if (ret < 0) 
if); 
if *vif; 
if = container_of(dwork, struct wl12xx_vif, connection_loss_work); 
if->role_id); 
if (unlikely(wl->state != WLCORE_STATE_ON)) 
if (!test_bit(WLVIF_FLAG_STA_ASSOCIATED, &wlvif->flags)) 
if = wl12xx_wlvif_to_vif(wlvif); 
if *wlvif; 
if = container_of(dwork, struct wl12xx_vif, 
if->wl; 
if (unlikely(wl->state != WLCORE_STATE_ON)) 
while we were stuck on the mutex. 
iffies + 
if (!time_after(time_spare, wlvif->pending_auth_reply_time)) 
if (ret < 0) 
if active */ 
if (policy >= WL12XX_MAX_RATE_POLICIES) 
if (WARN_ON(*idx >= WL12XX_MAX_RATE_POLICIES)) 
if (policy >= WLCORE_MAX_KLV_TEMPLATES) 
if (WARN_ON(*idx >= WLCORE_MAX_KLV_TEMPLATES)) 
if *wlvif) 
if (wlvif->p2p) 
if (wlvif->p2p) 
if->bss_type); 
if_data(struct wl1271 *wl, struct ieee80211_vif *vif) 
if, 0, offsetof(struct wl12xx_vif, persistent)); 
if->p2p = 1; 
if->bss_type = BSS_TYPE_STA_BSS; 
if->bss_type = BSS_TYPE_IBSS; 
if->p2p = 1; 
if->bss_type = BSS_TYPE_AP_BSS; 
if->bss_type = MAX_BSS_TYPE; 
if->role_id = WL12XX_INVALID_ROLE_ID; 
if->dev_hlid = WL12XX_INVALID_LINK_ID; 
if->bss_type == BSS_TYPE_IBSS) { 
if->sta.hlid = WL12XX_INVALID_LINK_ID; 
if->sta.ap_rate_idx); 
if->sta.klv_template_id); 
if->basic_rate = CONF_TX_RATE_MASK_BASIC; 
if->ap.bcast_hlid = WL12XX_INVALID_LINK_ID; 
if->ap.mgmt_rate_idx); 
for (i = 0; i < CONF_TX_MAX_AC_COUNT; i++) 
if->ap.ucast_rate_idx[i]); 
if basic_rate shouldn't be 
for STA above). 
if->basic_rate = CONF_TX_ENABLED_RATES; 
for STA, check it */ 
if->bitrate_masks[IEEE80211_BAND_2GHZ] = wl->conf.tx.basic_rate; 
if->beacon_int = WL1271_DEFAULT_BEACON_INT; 
while we treat them 
if->band = wl->band; 
if->power_level = wl->power_level; 
if->rx_streaming_enable_work, 
if->rx_streaming_disable_work, 
if->channel_switch_work, 
if->connection_loss_work, 
if->pending_auth_complete_work, 
if->list); 
if); 
while (retries) { 
if (ret < 0) 
if (ret < 0) 
if (ret < 0) 
while we are WLCORE_STATE_OFF the IRQ 
if (!booted) { 
if 11a is supported (info from the NVS), so disable 
if (!wl->enable_11a) 
if *wlvif) 
if_count, so it must be called before 
if_counter_data vif_counter_data, 
if_count = vif_counter_data.counter; 
if count if this is a new vif */ 
if_count++; 
if the device is OFF */ 
if a single fw is used */ 
if (vif_count > 1 && current_fw == WL12XX_FW_TYPE_NORMAL) 
if (vif_count <= 1 && current_fw == WL12XX_FW_TYPE_MULTI) 
forced psm". Make sure the sta is in psm against the ap, 
force_active_psm(struct wl1271 *wl) 
if_sta(wl, wlvif) { 
if */ 
if among those iterated */ 
if *vif) 
if (WARN_ON_ONCE(vif->hw_queue[0] == IEEE80211_INVAL_HW_QUEUE)) 
if (iter_data->cur_running || vif == iter_data->vif) { 
if->hw_queue[0] / NUM_TX_QUEUES, iter_data->hw_queue_map); 
if *wlvif) 
if = vif; 
if is already running in mac80211 (resume/recovery) */ 
if->hw_queue_base = vif->hw_queue[0]; 
if->hw_queue_base); 
if (q_base >= WLCORE_NUM_MAC_ADDRESSES) 
if->hw_queue_base = q_base * NUM_TX_QUEUES; 
if->hw_queue_base); 
for (i = 0; i < NUM_TX_QUEUES; i++) { 
if->hw_queue[i] = wlvif->hw_queue_base + i; 
for cab queues per interface */ 
if->cab_queue = NUM_TX_QUEUES * WLCORE_NUM_MAC_ADDRESSES + 
if->cab_queue = IEEE80211_INVAL_HW_QUEUE; 
if *vif) 
if *wlvif = wl12xx_vif_to_data(vif); 
if (wl->plt) { 
while in PLT mode"); 
if->driver_flags |= IEEE80211_VIF_BEACON_FILTER | 
if_type_p2p(vif), vif->addr); 
if (ret < 0) 
fore __wl1271_op_remove_interface is complete, so 
if (test_bit(WL1271_FLAG_RECOVERY_IN_PROGRESS, &wl->flags) || 
if_data(wl, vif); 
if->wl = wl; 
if (role_type == WL12XX_INVALID_ROLE_TYPE) { 
if); 
if (wl12xx_need_fw_change(wl, vif_count, true)) { 
force_active_psm(wl); 
if (wl->state == WLCORE_STATE_OFF) { 
while uploading the nvs 
if->addr, ETH_ALEN); 
if (ret < 0) 
if->addr, 
if (ret < 0) 
if_specific(wl, vif); 
if->list, &wl->wlvif_list); 
if (wlvif->bss_type == BSS_TYPE_AP_BSS) 
if *vif, 
if *wlvif = wl12xx_vif_to_data(vif); 
if->bss_type == BSS_TYPE_AP_BSS); 
if (!test_and_clear_bit(WLVIF_FLAG_INITIALIZED, &wlvif->flags)) 
if (wl->state == WLCORE_STATE_OFF) 
if (wl->scan.state != WL1271_SCAN_STATE_IDLE && 
fore idling scan. This 
if = NULL; 
if (wl->sched_vif == wlvif) 
if (wl->roc_vif == vif) { 
if (!test_bit(WL1271_FLAG_RECOVERY_IN_PROGRESS, &wl->flags)) { 
if (ret < 0) 
if (wlvif->bss_type == BSS_TYPE_STA_BSS || 
if (wl12xx_dev_role_started(wlvif)) 
if->role_id); 
if(wl, wlvif); 
if->dev_hlid = WL12XX_INVALID_LINK_ID; 
if->bss_type == BSS_TYPE_IBSS) { 
if->sta.basic_rate_idx); 
if->sta.p2p_rate_idx); 
if->ap.bcast_hlid = WL12XX_INVALID_LINK_ID; 
if->ap.mgmt_rate_idx); 
for (i = 0; i < CONF_TX_MAX_AC_COUNT; i++) 
if->ap.ucast_rate_idx[i]); 
if->probereq); 
if (wl->last_wlvif == wlvif) 
if->list); 
if->role_id = WL12XX_INVALID_ROLE_ID; 
if (is_ap) 
if (test_bit(WL1271_FLAG_RECOVERY_IN_PROGRESS, &wl->flags) && 
if (wl->ap_count == 0 && is_ap) { 
if (wl->ap_count == 0 && is_ap && wl->sta_count) { 
for power according to debugfs */ 
for ELP power saving */ 
if->rx_streaming_timer); 
if->rx_streaming_disable_work); 
if->channel_switch_work); 
if *vif) 
if *wlvif = wl12xx_vif_to_data(vif); 
if_counter_data vif_count; 
if (wl->state == WLCORE_STATE_OFF || 
if can be null here if someone shuts down the interface 
if(wl, iter) { 
if, true); 
if); 
force_active_psm(wl); 
if *vif, 
if); 
if->p2p = p2p; 
if *wlvif) 
if->bss_type == BSS_TYPE_IBSS); 
forming a JOIN while associated 
for JOIN during association 
for now, unless it starts bothering 
if (test_bit(WLVIF_FLAG_STA_ASSOCIATED, &wlvif->flags)) 
while associated."); 
if->encryption_type = KEY_NONE; 
if); 
if (wl->quirks & WLCORE_QUIRK_START_STA_FAILS) { 
for wl12xx fw 
if); 
if); 
if *wlvif, struct sk_buff *skb, 
if (!ptr) { 
if (ssid_len > IEEE80211_MAX_SSID_LEN) { 
if->ssid_len = ssid_len; 
if *wlvif) 
if (wlvif->bss_type != BSS_TYPE_STA_BSS) 
if); 
if, skb, ieoffset); 
if *wlvif, 
if->aid = bss_conf->aid; 
if->beacon_int = bss_conf->beacon_int; 
if->flags); 
if, wlvif->aid); 
for hardware connection maintenance 
if->probereq); 
if, 
if, wlvif->probereq, ieoffset); 
if, true); 
if, true); 
if, wlvif->aid); 
if); 
if, 
if (ret < 0) 
while mac80211 default 
if, STATION_ACTIVE_MODE); 
if (sta_rate_set) { 
if->band); 
if (ret < 0) 
if *wlvif) 
if->bss_type == BSS_TYPE_STA_BSS; 
if (sta && 
if (!sta && 
if (sta) { 
if->aid = 0; 
if->probereq); 
if, false); 
if, false); 
if, false); 
if (test_and_clear_bit(WLVIF_FLAG_CS_PROGRESS, &wlvif->flags)) { 
if); 
if->channel_switch_work); 
if, 
if *wlvif) 
if->rate_set = wlvif->basic_rate_set; 
if->flags); 
if (idle) { 
if (wl->sched_vif == wlvif) 
if->flags); 
if (conf->power_level != wlvif->power_level) { 
if (ret < 0) 
if->power_level = conf->power_level; 
if *wlvif; 
if (changed & IEEE80211_CONF_CHANGE_POWER) 
if (unlikely(wl->state != WLCORE_STATE_ON)) 
if (ret < 0) 
if(wl, wlvif) { 
if (ret < 0) 
if (!fp) { 
if (netdev_hw_addr_list_count(mc_list) > ACX_MC_ADDRESS_GROUP_MAX) { 
for_each(ha, mc_list) { 
if *wlvif; 
if (unlikely(wl->state != WLCORE_STATE_ON)) 
if (ret < 0) 
if(wl, wlvif) { 
if (*total & FIF_ALLMULTI) 
if (fp) 
if (ret < 0) 
if *wlvif, 
if (key_size > MAX_KEY_SIZE) 
for (i = 0; i < MAX_NUM_KEYS; i++) { 
if (wlvif->ap.recorded_keys[i]->id == id) { 
if (i == MAX_NUM_KEYS) 
if (!ap_key) 
if->ap.recorded_keys[i] = ap_key; 
if *wlvif) 
for (i = 0; i < MAX_NUM_KEYS; i++) { 
if->ap.recorded_keys[i] = NULL; 
for (i = 0; i < MAX_NUM_KEYS; i++) { 
if (wlvif->ap.recorded_keys[i] == NULL) 
if->ap.recorded_keys[i]; 
if (hlid == WL12XX_INVALID_LINK_ID) 
if, KEY_ADD_OR_REPLACE, 
if (ret < 0) 
if (key->key_type == KEY_WEP) 
if (wep_key_added) { 
if->ap.bcast_hlid); 
if); 
if *wlvif, 
if->bss_type == BSS_TYPE_AP_BSS); 
if (sta) { 
if->ap.bcast_hlid; 
if (!test_bit(WLVIF_FLAG_AP_STARTED, &wlvif->flags)) { 
if (action != KEY_ADD_OR_REPLACE) 
if, id, 
if, action, 
if (ret < 0) 
if (is_zero_ether_addr(addr)) { 
if (action == KEY_REMOVE && !is_broadcast_ether_addr(addr)) 
if hlid was already deleted */ 
if->sta.hlid == WL12XX_INVALID_LINK_ID) 
if, action, 
if (ret < 0) 
if *vif, 
if (might_change_spare) { 
if (unlikely(wl->state != WLCORE_STATE_ON)) { 
if (ret < 0) 
if, sta, key_conf); 
if (might_change_spare) 
if *vif, 
if *wlvif = wl12xx_vif_to_data(vif); 
if (wlvif->bss_type == BSS_TYPE_AP_BSS) 
if->ap.bcast_hlid; 
if->sta.hlid; 
if, KEY_ADD_OR_REPLACE, 
if (ret < 0) { 
if the unicast (or common) 
if (wlvif->bss_type == BSS_TYPE_STA_BSS && 
if->encryption_type != key_type) { 
if); 
if, KEY_REMOVE, 
if (ret < 0) { 
if *vif, 
if *wlvif = wl12xx_vif_to_data(vif); 
if (key_idx == -1) 
if (unlikely(wl->state != WLCORE_STATE_ON)) { 
if (ret < 0) 
if->default_key = key_idx; 
if (wlvif->encryption_type == KEY_WEP) { 
if->sta.hlid); 
if (!(wl->quirks & WLCORE_QUIRK_REGDOMAIN_CONF)) 
if (unlikely(wl->state != WLCORE_STATE_ON)) 
if (ret < 0) 
if (ret < 0) { 
if *vif, 
if (req->n_ssids) { 
if (unlikely(wl->state != WLCORE_STATE_ON)) { 
if we do - in this case 
if (ret < 0) 
if there is any role in ROC */ 
if, ssid, len, req); 
if *vif) 
if *wlvif = wl12xx_vif_to_data(vif); 
if (unlikely(wl->state != WLCORE_STATE_ON)) 
if (wl->scan.state == WL1271_SCAN_STATE_IDLE) 
if (ret < 0) 
if (wl->scan.state != WL1271_SCAN_STATE_DONE) { 
if (ret < 0) 
fore idling scan. This 
if = NULL; 
if *vif, 
if *wlvif = wl12xx_vif_to_data(vif); 
if (unlikely(wl->state != WLCORE_STATE_ON)) { 
if (ret < 0) 
if, req, ies); 
if = wlvif; 
if *vif) 
if *wlvif = wl12xx_vif_to_data(vif); 
if (unlikely(wl->state != WLCORE_STATE_ON)) 
if (ret < 0) 
if); 
if (unlikely(wl->state != WLCORE_STATE_ON)) { 
if (ret < 0) 
if (ret < 0) 
if *wlvif; 
if (unlikely(wl->state != WLCORE_STATE_ON)) { 
if (ret < 0) 
if(wl, wlvif) { 
if (ret < 0) 
if (!ie) 
if (!ie) 
if *vif) 
if); 
if->role_id, 
if (ret < 0) 
if->flags); 
if *vif, 
if *wlvif = wl12xx_vif_to_data(vif); 
if the SSID is set correctly */ 
if->role_id, 
if (probe_rsp_len + bss_conf->ssid_len > WL1271_CMD_TEMPL_MAX_SIZE) { 
if (!ptr) { 
if->role_id, 
if *vif, 
if *wlvif = wl12xx_vif_to_data(vif); 
if (changed & BSS_CHANGED_ERP_SLOT) { 
if, SLOT_TIME_SHORT); 
if, SLOT_TIME_LONG); 
if (changed & BSS_CHANGED_ERP_PREAMBLE) { 
if, ACX_PREAMBLE_SHORT); 
if, ACX_PREAMBLE_LONG); 
if (bss_conf->use_cts_prot) 
if, 
if (ret < 0) { 
if *vif, 
if *wlvif = wl12xx_vif_to_data(vif); 
if); 
if (!beacon) { 
if, beacon, ieoffset); 
if->basic_rate_set); 
if->role_id, tmpl_id, 
if (ret < 0) { 
if->wmm_enabled = 
if (test_bit(WLVIF_FLAG_AP_PROBE_RESP_SET, &wlvif->flags)) 
forbids including the p2p ie when responding to probe 
if (is_ap) 
if->role_id, 
if (ret < 0) 
if *vif, 
if *wlvif = wl12xx_vif_to_data(vif); 
if (changed & BSS_CHANGED_BEACON_INT) { 
if->beacon_int = bss_conf->beacon_int; 
if->basic_rate_set); 
if (changed & BSS_CHANGED_BEACON) { 
if (ret < 0) 
if (ret != 0) 
if *vif, 
if *wlvif = wl12xx_vif_to_data(vif); 
if (changed & BSS_CHANGED_BASIC_RATES) { 
if->basic_rate_set = wl1271_tx_enabled_rates_get(wl, rates, 
if->basic_rate = wl1271_tx_min_rate_get(wl, 
if); 
if); 
if->basic_rate, vif); 
if, true); 
if, bss_conf, changed); 
if (changed & BSS_CHANGED_BEACON_ENABLED) { 
if (!test_bit(WLVIF_FLAG_AP_STARTED, &wlvif->flags)) { 
if (ret < 0) 
if); 
if->flags); 
if (test_bit(WLVIF_FLAG_AP_STARTED, &wlvif->flags)) { 
if (test_bit(wlvif->role_id, wl->roc_map)) 
if); 
if->flags); 
if->flags); 
if, bss_conf, changed); 
formation change */ 
if, 
if (ret < 0) { 
formation failed %d", ret); 
if *wlvif, 
if->beacon_int = bss_conf->beacon_int; 
if->basic_rate_set = 
if->band); 
if->basic_rate_set); 
if->rate_set = 
if->band); 
while not connected */ 
if); 
if (ret < 0) 
if); 
if_to_vif(wlvif)); 
if); 
if *wlvif) 
for the current band */ 
if->basic_rate = wl1271_tx_min_rate_get(wl, wlvif->basic_rate_set); 
if (ret < 0) 
if (wlvif->bss_type == BSS_TYPE_STA_BSS && 
if); 
if->flags); 
if *vif, 
if *wlvif = wl12xx_vif_to_data(vif); 
if->bss_type == BSS_TYPE_IBSS); 
if (is_ibss) { 
if (ret < 0) 
if (changed & BSS_CHANGED_IBSS) { 
if->flags); 
if); 
if ((changed & BSS_CHANGED_BEACON_INT) && ibss_joined) 
for filtering etc) */ 
if ((changed & BSS_CHANGED_BEACON_ENABLED) && ibss_joined) { 
if (changed & BSS_CHANGED_IDLE && !is_ibss) 
if (changed & BSS_CHANGED_CQM) { 
if (bss_conf->cqm_rssi_thold) 
if, enable, 
if (ret < 0) 
if->rssi_thold = bss_conf->cqm_rssi_thold; 
if, bss_conf->bssid); 
if->band]; 
if (changed & BSS_CHANGED_BSSID) { 
if, bss_conf, 
if (ret < 0) 
for filtering etc) */ 
if); 
if (changed & BSS_CHANGED_IBSS) { 
if (bss_conf->ibss_joined) { 
if->basic_rate_set = 
if->band); 
if->basic_rate_set); 
if->rate_set = CONF_TX_IBSS_DEFAULT_RATES; 
if (ret < 0) 
if ((changed & BSS_CHANGED_BEACON_INFO) && bss_conf->dtim_period) { 
if, true); 
if, bss_conf, changed); 
if (do_join) { 
if (ret < 0) { 
if (changed & BSS_CHANGED_ASSOC) { 
if, bss_conf, 
if (ret < 0) 
if (test_bit(WLVIF_FLAG_STA_AUTHORIZED, &wlvif->flags)) 
if); 
if (changed & BSS_CHANGED_PS) { 
if->flags) && 
if (wl->conf.conn.forced_ps) { 
forced"; 
if, ps_mode); 
if (!bss_conf->ps && 
if, 
if (ret < 0) 
if (sta_exists) { 
if->rate_set, 
if (ret < 0) { 
if (enabled) { 
formation(wl, wlvif, 
if (ret < 0) { 
formation failed %d", 
if ((changed & BSS_CHANGED_ARP_FILTER) || 
if->sta.qos = bss_conf->qos; 
if (bss_conf->arp_addr_cnt == 1 && bss_conf->assoc) { 
if); 
if, 
if->ip_addr = 0; 
if (ret < 0) 
if *vif, 
if *wlvif = wl12xx_vif_to_data(vif); 
if->role_id, (int)changed); 
if our association 
if (!is_ap && (changed & BSS_CHANGED_ASSOC)) 
if (is_ap && (changed & BSS_CHANGED_BEACON_ENABLED) && 
if (unlikely(wl->state != WLCORE_STATE_ON)) 
if (unlikely(!test_bit(WLVIF_FLAG_INITIALIZED, &wlvif->flags))) 
if (ret < 0) 
if ((changed & BSS_CHANGED_TXPOWER) && 
if, bss_conf->txpower); 
if->power_level = bss_conf->txpower; 
if, bss_conf, changed); 
if, bss_conf, changed); 
if_chanctx(struct ieee80211_hw *hw, 
if *wlvif = wl12xx_vif_to_data(vif); 
if->role_id, channel, cfg80211_get_chandef_type(&ctx->def)); 
if->band = ctx->def.chan->band; 
if->channel_type = cfg80211_get_chandef_type(&ctx->def); 
if); 
if_chanctx(struct ieee80211_hw *hw, 
if *wlvif = wl12xx_vif_to_data(vif); 
if->role_id, 
if *vif, u16 queue, 
if *wlvif = wl12xx_vif_to_data(vif); 
if (params->uapsd) 
if (!test_bit(WLVIF_FLAG_INITIALIZED, &wlvif->flags)) 
if (ret < 0) 
if, wl1271_tx_get_queue(queue), 
ifs, params->txop << 5); 
if, wl1271_tx_get_queue(queue), 
if *vif) 
if *wlvif = wl12xx_vif_to_data(vif); 
if (unlikely(wl->state != WLCORE_STATE_ON)) 
if (ret < 0) 
if, &mactime); 
if (idx != 0) 
if *wlvif, 
if (wl->active_sta_count >= wl->max_ap_stations) { 
if, &wl_sta->hlid); 
if this is a recovery/resume */ 
if->ap.sta_hlid_map); 
if *wlvif, u8 hlid) 
if *vif = wl12xx_wlvif_to_vif(wlvif); 
if->ap.sta_hlid_map); 
if, wl->links[hlid].addr); 
for 
if (test_bit(WL1271_FLAG_RECOVERY_IN_PROGRESS, &wl->flags)) 
if, &hlid); 
fore complaining. 
if (wl->active_sta_count == 0) 
if *wlvif, 
if, sta); 
if, sta, hlid); 
if, hlid); 
if *wlvif, 
if (WARN_ON(!test_bit(id, wlvif->ap.sta_hlid_map))) 
if, wl_sta->hlid); 
if, wl_sta->hlid); 
if_possible(struct wl1271 *wl, 
if (find_first_bit(wl->roc_map, 
if (WARN_ON(wlvif->role_id == WL12XX_INVALID_ROLE_ID)) 
if, wlvif->role_id, wlvif->band, wlvif->channel); 
if *wlvif, 
if (in_conn) { 
if (!wlvif->ap_pending_auth_reply && 
if_possible(wl, wlvif); 
if->inconn_count++; 
if->ap_pending_auth_reply = true; 
if (wl_sta && !wl_sta->in_connection) 
if (WARN_ON(!wl_sta && !wlvif->ap_pending_auth_reply)) 
if (WARN_ON(wl_sta && !wlvif->inconn_count)) 
if (wl_sta) { 
if->inconn_count--; 
if->ap_pending_auth_reply = false; 
if (!wlvif->inconn_count && !wlvif->ap_pending_auth_reply && 
if->role_id); 
if *wlvif, 
if->bss_type == BSS_TYPE_AP_BSS; 
if (is_ap && 
if, sta); 
if, wl_sta, true); 
if (is_ap && 
if, sta); 
if (is_ap && 
if, wl_sta->hlid); 
if (ret) 
if, wl_sta, false); 
if (is_sta && 
if->flags); 
if (ret) 
if (is_sta && 
if->flags); 
if (is_sta && 
if (test_bit(wlvif->role_id, wl->roc_map)) 
if (is_sta && 
if (find_first_bit(wl->roc_map, 
if->role_id == WL12XX_INVALID_ROLE_ID); 
if->band, wlvif->channel); 
if *vif, 
if *wlvif = wl12xx_vif_to_data(vif); 
if (unlikely(wl->state != WLCORE_STATE_ON)) { 
if (ret < 0) 
if, sta, old_state, new_state); 
if (new_state < old_state) 
if *vif, 
if *wlvif = wl12xx_vif_to_data(vif); 
if (WARN_ON(tid > 0xFF)) 
if (unlikely(wl->state != WLCORE_STATE_ON)) { 
if (wlvif->bss_type == BSS_TYPE_STA_BSS) { 
if (wlvif->bss_type == BSS_TYPE_AP_BSS) { 
if (ret < 0) 
if (!wlvif->ba_support || !wlvif->ba_allowed) { 
if (wl->ba_rx_session_count >= wl->ba_rx_session_count_max) { 
if (*ba_bitmap & BIT(tid)) { 
if (!ret) { 
if (!(*ba_bitmap & BIT(tid))) { 
for now, and don't fail the function. 
if (!ret) { 
for all TX APDU commands. 
if *vif, 
if *wlvif = wl12xx_vif_to_data(vif); 
for (i = 0; i < WLCORE_NUM_BANDS; i++) 
if (unlikely(wl->state != WLCORE_STATE_ON)) 
if (wlvif->bss_type == BSS_TYPE_STA_BSS && 
if (ret < 0) 
if); 
if->basic_rate_set); 
if *wlvif; 
if (unlikely(wl->state == WLCORE_STATE_OFF)) { 
for_each_wlvif_sta(wl, wlvif) { 
if, false); 
if (unlikely(wl->state != WLCORE_STATE_ON)) { 
if (ret < 0) 
if as param */ 
for_each_wlvif_sta(wl, wlvif) { 
if, ch_switch); 
if->flags); 
if->beacon_int) * 
if->channel_switch_work, 
iffies(5000)); 
if *vif, 
if *vif, 
if *wlvif = wl12xx_vif_to_data(vif); 
if->role_id); 
if (unlikely(wl->state != WLCORE_STATE_ON)) 
if we can't ROC right now */ 
if (ret < 0) 
if, chan->band, channel); 
if = vif; 
iffies(duration)); 
if *wlvif; 
if (unlikely(!wl->roc_vif)) 
if = wl12xx_vif_to_data(wl->roc_vif); 
if); 
if = NULL; 
if (unlikely(wl->state != WLCORE_STATE_ON)) { 
if (ret < 0) 
if (!ret) 
if */ 
if *vif, 
if *wlvif = wl12xx_vif_to_data(vif); 
if, sta, changed); 
if *vif, 
if *wlvif = wl12xx_vif_to_data(vif); 
if (unlikely(wl->state != WLCORE_STATE_ON)) 
if (ret < 0) 
if, rssi_dbm); 
if (unlikely(wl->state != WLCORE_STATE_ON)) 
if in the TX queue or the FW */ 
for WL1273 */ 
for WL1273 */ 
ifdef CONFIG_PM 
if 
if_chanctx = wlcore_op_assign_vif_chanctx, 
if (unlikely(rate >= wl->hw_tx_rate_tbl_size)) { 
if (unlikely(idx == CONF_HW_RXTX_RATE_UNSUPPORTED)) { 
if (nic + WLCORE_NUM_MAC_ADDRESSES - wl->num_mac_addr > 0xffffff) 
for (i = 0; i < wl->num_mac_addr; i++) { 
if (wl->num_mac_addr < WLCORE_NUM_MAC_ADDRESSES) { 
if (ret < 0) 
if (ret < 0) 
if (ret < 0) 
if (wl->ops->get_mac) 
if (wl->mac80211_registered) 
if (wl->nvs_len >= 12) { 
ify the casting, we assume it is at 
if the MAC address is zeroed in the NVS derive from fuse */ 
if (ret < 0) { 
if (wl->plt) 
if (wl->quirks & WLCORE_QUIRK_TKIP_HEADER_SPACE) 
for a template, without 
for (i = 0; i < ARRAY_SIZE(wl1271_channels); i++) { 
for (i = 0; i < ARRAY_SIZE(wl1271_channels_5ghz); i++) { 
ify them on a per-device basis. 
ifier = wl1271_reg_notify; 
iface_combinations = wl->iface_combinations; 
if_data_size = sizeof(struct wl12xx_vif); 
if (!hw) { 
if (!wl->priv) { 
if_list); 
for (i = 0; i < NUM_TX_QUEUES; i++) 
if (!wl->freezable_wq) { 
form_quirks = 0; 
for (i = 0; i < wl->num_tx_desc; i++) 
if (!wl->aggr_buf) { 
if (!wl->dummy_packet) { 
for the FW log */ 
if (!wl->fwlog) { 
if (!wl->mbox) { 
if (!wl->buffer_32) { 
if); 
ifdef CONFIG_PM 
if 
form_device *pdev = wl->pdev; 
form_data *pdata = pdev_data->pdata; 
if (fw) { 
if (!wl->nvs) { 
if (ret < 0) 
form_get_irq(pdev, 0); 
if_ops = pdev_data->if_ops; 
form_quirks & WL12XX_PLATFORM_QUIRK_EDGE_IRQ) { 
if (ret < 0) { 
ifdef CONFIG_PM 
if (!ret) { 
if (pdata->pwr_in_suspend) 
if 
if (ret < 0) { 
ify_chip(wl); 
if (ret) 
if (ret) 
if (ret) 
form_device *pdev) 
if (!wl->ops || !wl->ptable) 
form_set_drvdata(pdev, wl); 
if (ret < 0) { 
form_device *pdev) 
for_completion(&wl->nvs_loading_complete); 
if (wl->irq_wake_enabled) { 
file : ./test/kernel/drivers/net/wireless/ti/wl1251/main.c 
[ OK ] open : 4 ok... 
buf : /*
ify it under the terms of the GNU General Public License 
for more details. 
if not, write to the Free Software 
if_ops->enable_irq(wl); 
if_ops->disable_irq(wl); 
if_ops->power(wl, false); 
if_ops->power(wl, true); 
if (ret < 0) { 
if (fw->size % 4) { 
if (!wl->fw) { 
for the firmware"); 
if (ret < 0) { 
if (fw->size % 4) { 
if (!wl->nvs) { 
for the nvs file"); 
if (!(elp_reg & ELPCTRL_WLAN_READY)) 
if (ret < 0) 
if_ops->reset(wl); 
if chip id is valid */ 
if (wl->fw == NULL) { 
if (ret < 0) 
if (wl->nvs == NULL && !wl->use_eeprom) { 
if (ret < 0) 
if (wl->state == WL1251_STATE_OFF) 
if (ret < 0) 
if (wl->data_path) { 
if (intr == 0) { 
if (intr & WL1251_ACX_INTR_RX0_DATA) { 
if (intr & WL1251_ACX_INTR_RX1_DATA) { 
if (intr & WL1251_ACX_INTR_TX_RESULT) { 
if (intr & WL1251_ACX_INTR_EVENT_A) { 
if (intr & WL1251_ACX_INTR_EVENT_B) { 
if (intr & WL1251_ACX_INTR_INIT_COMPLETE) 
if (--ctr == 0) 
while (intr); 
if (ret < 0) 
if we are not associated, 
for association to work. 
if (is_zero_ether_addr(wl->bssid)) 
if (ret < 0) 
if (ret < 0) 
ific setup must run before the first TX packet - 
fore that, the tx_work will not be initialized! 
if (skb_queue_len(&wl->tx_queue) >= WL1251_TX_QUEUE_HIGH_WATERMARK) { 
if (wl->state != WL1251_STATE_OFF) { 
if (ret < 0) 
if (ret < 0) 
if (ret < 0) 
if (ret < 0) 
if (ret < 0) 
if (wl->scanning) { 
ify MAC80211 about the remaining pending TX frames */ 
if *vif) 
if->driver_flags |= IEEE80211_VIF_BEACON_FILTER | 
if->type, vif->addr); 
if (wl->vif) { 
if = vif; 
if (!ether_addr_equal_unaligned(wl->mac_addr, vif->addr)) { 
if (ret < 0) 
if *vif) 
if = NULL; 
if (wl->bss_type == BSS_TYPE_IBSS) { 
if); 
if (ret) 
if (ret < 0) 
if (changed & IEEE80211_CONF_CHANGE_MONITOR) { 
if (conf->flags & IEEE80211_CONF_MONITOR) { 
if (ret < 0) 
if (channel != wl->channel) { 
for channel switching when no 
if (wl->vif == NULL) { 
if (ret < 0) 
if (wl1251_can_do_pm(conf, wl) && !wl->psm_requested) { 
if we're already associated. 
if (ret < 0) 
if (!wl1251_can_do_pm(conf, wl) && wl->psm_requested) { 
if (wl->station_mode != STATION_ACTIVE_MODE) { 
if (ret < 0) 
if (changed & IEEE80211_CONF_CHANGE_IDLE && !wl->scanning) { 
if (ret < 0) 
if (ret < 0) 
if (ret < 0) 
if (conf->power_level != wl->power_level) { 
if (ret < 0) 
if (unlikely(wl->state == WL1251_STATE_OFF)) 
if (!fp) { 
if (netdev_hw_addr_list_count(mc_list) > ACX_MC_ADDRESS_GROUP_MAX) { 
for_each(ha, mc_list) { 
if (changed == 0) { 
if (*total & FIF_PROMISC_IN_BSS) { 
if (*total & FIF_ALLMULTI) 
if (*total & FIF_FCSFAIL) 
if (*total & FIF_BCN_PRBRESP_PROMISC) { 
if (*total & FIF_CONTROL) 
if (*total & FIF_OTHER_BSS || is_zero_ether_addr(wl->bssid)) 
if (*total & FIF_PROBE_REQ) 
if (wl->state == WL1251_STATE_OFF) 
if (ret < 0) 
if (*total & FIF_ALLMULTI || *total & FIF_PROMISC_IN_BSS) 
if (fp) 
if (ret < 0) 
if (is_broadcast_ether_addr(addr)) 
if (is_broadcast_ether_addr(addr)) 
if (is_broadcast_ether_addr(addr)) 
if *vif, 
if (!wl_cmd) { 
if (is_zero_ether_addr(addr)) { 
if (wl->monitor_present) { 
if (ret < 0) 
if (ret < 0) { 
if (wl_cmd->key_type != KEY_WEP_DEFAULT) 
if ((wl_cmd->key_type == KEY_TKIP_MIC_GROUP) || 
form: 
if (ret < 0) { 
if *vif, 
if (req->n_ssids) { 
if (wl->scanning) { 
if (ret < 0) 
if (hw->conf.flags & IEEE80211_CONF_IDLE) { 
if (ret < 0) 
if (ret < 0) 
if, ssid, ssid_len, 
if (!skb) { 
if (req->ie_len) 
if (ret < 0) 
if (ret < 0) 
if (ret < 0) { 
if (hw->conf.flags & IEEE80211_CONF_IDLE) 
if (ret < 0) 
if (ret < 0) 
if *vif, 
if (ret < 0) 
if (changed & BSS_CHANGED_CQM) { 
if (ret < 0) 
if ((changed & BSS_CHANGED_BSSID) && 
if (!is_zero_ether_addr(wl->bssid)) { 
if (ret < 0) 
if (ret < 0) 
if (ret < 0) 
if (changed & BSS_CHANGED_ASSOC) { 
if); 
if (ret < 0) 
if (ret < 0) 
if (changed & BSS_CHANGED_ERP_SLOT) { 
if (ret < 0) { 
if (changed & BSS_CHANGED_ERP_PREAMBLE) { 
if (changed & BSS_CHANGED_ERP_CTS_PROT) { 
if (ret < 0) { 
if (changed & BSS_CHANGED_ARP_FILTER) { 
if (ret < 0) 
if (changed & BSS_CHANGED_BEACON) { 
if (!beacon) 
if (ret < 0) { 
if (ret < 0) 
if (ret < 0) 
if *vif, u16 queue, 
if (ret < 0) 
ifs, params->txop * 32); 
if (params->uapsd) 
if (ret < 0) 
if (idx != 0) 
iffies + msecs_to_jiffies(100); 
while (1) { 
if (time_after(jiffies, timeout)) 
for (i = 0; i < len; i++) { 
if (ret < 0) 
if (ret < 0) { 
for (i = 0; i < ETH_ALEN; i++) 
if (wl->mac80211_registered) 
if (ret < 0) { 
if (wl->use_eeprom) 
if (ret) 
if (!hw) { 
if = NULL; 
for (i = 0; i < FW_TX_CMPLT_BLOCK_SIZE; i++) 
if (!wl->rx_descriptor) { 
for rx descriptor"); 
file : ./test/kernel/drivers/net/ethernet/atheros/alx/main.c 
[ OK ] open : 4 ok... 
buf : /*
ify it 
for more details. 
ify, and/or distribute this software for any 
if_vlan.h> 
if (dma_unmap_len(txb, size)) { 
if (txb->skb) { 
if (++next == alx->rx_ringsz) 
while (!cur_buf->skb && next != rxq->read_idx) { 
if (!skb) 
if (dma_mapping_error(&alx->hw.pdev->dev, dma)) { 
fortunately, RX descriptor buffers must be 4-byte 
if (WARN_ON(dma & 3)) { 
if (++next == alx->rx_ringsz) 
if (count) { 
fore updating hardware */ 
if (txq->write_idx >= txq->read_idx) 
if (sw_read_idx != hw_read_idx) { 
while (sw_read_idx != hw_read_idx && budget > 0) { 
if (skb) { 
if (++sw_read_idx == alx->tx_ringsz) 
if (netif_queue_stopped(alx->dev) && netif_carrier_ok(alx->dev) && 
if_wake_queue(alx->dev); 
while (budget > 0) { 
if (!(rrd->word3 & cpu_to_le32(1 << RRD_UPDATED_SHIFT))) 
if (ALX_GET_FIELD(le32_to_cpu(rrd->word0), 
if (rrd->word3 & cpu_to_le32(1 << RRD_ERR_RES_SHIFT) || 
if (alx->dev->features & NETIF_F_RXCSUM && 
if (++rxq->read_idx == alx->rx_ringsz) 
if (++rxq->rrd_read_idx == alx->rx_ringsz) 
if (++rfd_cleaned > ALX_RX_ALLOC_THRESH) 
if (rfd_cleaned) 
if (!complete) 
if (intr & ALX_ISR_FATAL) { 
if (intr & ALX_ISR_ALERT) 
if (intr & ALX_ISR_PHY) { 
if (intr & (ALX_ISR_TX_Q0 | ALX_ISR_RX_Q0)) { 
if (write_int_mask) 
if (intr & ALX_ISR_DIS || !(intr & alx->int_mask)) 
if (!txq->bufs) 
for (i = 0; i < alx->tx_ringsz; i++) 
if (rxq == NULL) 
for (i = 0; i < alx->rx_ringsz; i++) { 
if (cur_buf->skb) { 
if (!alx_refill_rx_ring(alx, GFP_KERNEL)) 
if (!(netdev->flags & IFF_ALLMULTI)) { 
for_each_mc_addr(ha, netdev) 
if (netdev->flags & IFF_PROMISC) 
if (netdev->flags & IFF_ALLMULTI) 
if (!is_valid_ether_addr(addr->sa_data)) 
if (netdev->addr_assign_type & NET_ADDR_RANDOM) 
if (!alx->txq.bufs) 
if (!alx->rxq.bufs) 
for high 32 bits 
if (!alx->descmem.virt) 
for next block */ 
for next block */ 
if (err) 
if_napi_add(alx->dev, &alx->napi, alx_poll, 64); 
if_napi_del(&alx->napi); 
if (!pci_enable_msi(alx->hw.pdev)) { 
if (!err) 
if (!err) 
if (alx->msi) { 
ify_hw(struct alx_priv *alx) 
if (rev > ALX_REV_C0) 
ify_hw(alx); 
if (netdev->mtu > ALX_MAX_TSO_PKT_SIZE) 
if_stop(struct alx_priv *alx) 
if (netif_carrier_ok(alx->dev)) { 
if_tx_disable(alx->dev); 
if_stop(alx); 
if ((max_frame < ALX_MIN_FRAME_SIZE) || 
if (netdev->mtu == mtu) 
if (netif_running(netdev)) 
if_start(struct alx_priv *alx) 
if_carrier_on(alx->dev); 
if (!resume) 
if (err) 
if (err) 
if (!resume) 
forever 
if (err < 0) 
if (old_speed == hw->link_speed) 
if (hw->link_speed != SPEED_UNKNOWN) { 
if (old_speed == SPEED_UNKNOWN) 
if_stop(alx); 
if (err) 
if (err) 
if (skb->ip_summed != CHECKSUM_PARTIAL) 
if (cso & 1) 
if (dma_mapping_error(&alx->hw.pdev->dev, dma)) 
for (f = 0; f < skb_shinfo(skb)->nr_frags; f++) { 
if (++txq->write_idx == alx->tx_ringsz) 
if (dma_mapping_error(&alx->hw.pdev->dev, dma)) 
if (++txq->write_idx == alx->tx_ringsz) 
while (f != txq->write_idx) { 
if (++f == alx->tx_ringsz) 
if (alx_tpd_avail(alx) < tpdreq) { 
if (alx_tx_csum(skb, first)) 
if (alx_map_tx_skb(alx, skb) < 0) 
fore updating hardware */ 
if (alx_tpd_avail(alx) < alx->tx_ringsz/8) 
if (prtad != hw->mdio.prtad) 
if (devad == MDIO_DEVAD_NONE) 
if (err) 
if (prtad != hw->mdio.prtad) 
if (devad == MDIO_DEVAD_NONE) 
ifreq *ifr, int cmd) 
if (!netif_running(netdev)) 
if_mii(ifr), cmd); 
if (alx->msi) 
if 
ifo_errors   = hw_stats->rx_ov_rxf; 
ifo_errors    = hw_stats->tx_underrun; 
ifdef CONFIG_NET_POLL_CONTROLLER 
if 
if (err) 
for the high 32 bits, so only a single, aligned, 
if (!dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(64))) { 
if (err) { 
if (err) { 
if (!pdev->pm_cap) { 
if (!netdev) { 
if (!hw->hw_addr) { 
if (ent->driver_data & ALX_DEV_QUIRK_MSI_INTX_DISABLE_BUG) 
if (err) { 
if (!phy_configured) 
if (err) { 
if (!phy_configured) { 
if (err) { 
if (alx_get_perm_macaddr(hw, hw->perm_addr)) { 
if (!alx_get_phy_info(hw)) { 
if_carrier_off(netdev); 
if (err) { 
ifdef CONFIG_PM_SLEEP 
if (!netif_running(alx->dev)) 
if_device_detach(alx->dev); 
if (!netif_running(alx->dev)) 
if_device_attach(alx->dev); 
if 
if (netif_running(netdev)) { 
if (state == pci_channel_io_perm_failure) 
if (pci_enable_device(pdev)) { 
if (!alx_reset_mac(hw)) 
if (netif_running(netdev)) { 
if_device_attach(netdev); 
file : ./test/kernel/drivers/net/ethernet/mellanox/mlx5/core/main.c 
[ OK ] open : 4 ok... 
buf : /*
forms, with or 
form must reproduce the above 
if (err) { 
if (err) { 
if (err) { 
if (err) { 
if (!(pci_resource_flags(pdev, 0) & IORESOURCE_MEM)) { 
if (err) 
if (nvec <= MLX5_EQ_VEC_COMP_BASE) 
if (!table->msix_arr) 
for (i = 0; i < nvec; i++) 
if (nvec < 0) 
if (!query_out) 
if (!set_ctx) { 
if (err) 
if (err) { 
if (dev->profile->mask & MLX5_PROF_MASK_QP_SIZE) 
if (err) { 
if (err) 
if (err) 
if (out.hdr.status) 
if (err) 
if (out.hdr.status) 
if (!priv->dbg_root) 
if (err) { 
if (err) { 
if (err) { 
if (!dev->iseg) { 
if (err) { 
if (err) { 
if (err) { 
if (err) { 
if (err) { 
if (err) { 
if (err) { 
if (err) { 
if (err) { 
if (err) { 
if (err) { 
if (err) { 
if (err) { 
if (err) { 
if (mlx5_cmd_teardown_hca(dev)) { 
if (mlx5_cmd_teardown_hca(dev)) { 
if (!mlx5_core_wq) { 
file : ./test/kernel/drivers/net/ethernet/mellanox/mlx4/main.c 
[ OK ] open : 4 ok... 
buf : /*
forms, with or 
form must reproduce the above 
ifdef CONFIG_MLX4_DEBUG 
if > 0"); 
ifdef CONFIG_PCI_MSI 
if nonzero"); 
if /* CONFIG_PCI_MSI */ 
if num_vfs > 0\n" 
for example:" 
for IB, 2 for Ethernet"); 
for (i = 0; i < dev->caps.num_ports - 1; i++) { 
if (!(dev->caps.flags & MLX4_DEV_CAP_FLAG_DPDP)) { 
for (i = 0; i < dev->caps.num_ports; i++) { 
for port %d is not supported on this HCA\n", 
for (i = 1; i <= dev->caps.num_ports; ++i) 
if (err) { 
if (dev_cap->min_page_sz > PAGE_SIZE) { 
if (dev_cap->num_ports > MLX4_MAX_PORTS) { 
if (dev_cap->uar_size > pci_resource_len(dev->pdev, 2)) { 
for (i = 1; i <= dev->caps.num_ports; ++i) { 
ifference between an 
for EQ doorbells */ 
for ConnectX-1 and -2 */ 
ifunction devices (for now at least) */ 
for (i = 1; i <= dev->caps.num_ports; ++i) { 
if (dev->caps.supported_type[i]) { 
if (dev->caps.supported_type[i] == MLX4_PORT_TYPE_ETH) 
if only IB is supported, assign IB */ 
if IB and ETH are supported, we set the port 
if user selected none, take the FW hint */ 
if 3 conditions are true: 
ifferent types are supported on the port 
form sense_port FW command to try and set the correct 
if (mlx4_priv(dev)->sense.sense_allowed[i] && dev->caps.default_sense[i]) { 
if (sensed_port != MLX4_PORT_TYPE_NONE) 
if (dev->caps.log_num_macs > dev_cap->log_max_macs[i]) { 
for port %d, reducing to %d\n", 
if (dev->caps.log_num_vlans > dev_cap->log_max_vlans[i]) { 
for port %d, reducing to %d\n", 
if (!enable_64b_cqe_eqe && !mlx4_is_slave(dev)) { 
if ((dev->caps.flags & 
if (!err2 && lnkcap2) { /* PCIe r3.0-compliant */ 
if (lnkcap2 & PCI_EXP_LNKCAP2_SLS_5_0GB) 
if (lnkcap2 & PCI_EXP_LNKCAP2_SLS_2_5GB) 
if (!err1) { 
if (!lnkcap2) { /* pre-r3.0 */ 
if (lnkcap1 & PCI_EXP_LNKCAP_SLS_2_5GB) 
if (*speed == PCI_SPEED_UNKNOWN || *width == PCIE_LNK_WIDTH_UNKNOWN) { 
if (err) { 
if (err || speed == PCI_SPEED_UNKNOWN || 
if (width != width_cap || speed != speed_cap) 
ifferent than device's capability\n"); 
if there are live vf, return the num of them*/ 
for (i = 1/*the ppf is 0*/; i < dev->num_slaves; ++i) { 
if (s_state->active && s_state->last_cmd != 
if (qpn >= dev->phys_caps.base_tunnel_sqpn + 8 * MLX4_MFUNC_MAX || 
if (qpn >= dev->phys_caps.base_tunnel_sqpn) 
if (!mlx4_is_master(dev)) 
if (!mlx4_is_master(dev)) 
if (!mlx4_is_master(dev)) 
if (!mlx4_is_master(dev)) 
if (dev->caps.steering_mode == MLX4_STEERING_MODE_DEVICE_MANAGED) { 
if (err) { 
if the hca has an unknown global capability 
if (hca_param.global_caps) { 
if (err) { 
if (err) 
if (page_size > PAGE_SIZE) { 
if (dev->caps.uar_page_size != PAGE_SIZE) { 
if (err) { 
if ((func_cap.pf_context_behaviour | PF_CONTEXT_BEHAVIOUR_MASK) != 
if (dev->caps.num_ports > MLX4_MAX_PORTS) { 
if (!dev->caps.qp0_tunnel || !dev->caps.qp0_proxy || 
for (i = 1; i <= dev->caps.num_ports; ++i) { 
if (err) { 
for port %d, aborting (%d)\n", 
if (mlx4_get_slave_pkey_gid_tbl_len(dev, i, 
if (dev->caps.uar_page_size * (dev->caps.num_uars - 
if (hca_param.dev_cap_enabled & MLX4_DEV_CAP_64B_EQE_ENABLED) { 
if (hca_param.dev_cap_enabled & MLX4_DEV_CAP_64B_CQE_ENABLED) { 
for (port = 1; port <= dev->caps.num_ports; port++) { 
if (dev->caps.port_type[port] == MLX4_PORT_TYPE_ETH) 
if (has_eth_port) 
if (has_ib_port || (dev->caps.flags & MLX4_DEV_CAP_FLAG_IBOE)) 
for (port = 0; port <  dev->caps.num_ports; port++) { 
if (port_types[port] != dev->caps.port_type[port + 1]) 
if (change) { 
for (port = 1; port <= dev->caps.num_ports; port++) { 
if (err) { 
if (err) { 
if (mdev->caps.possible_type[info->port] == MLX4_PORT_TYPE_AUTO) 
if (!strcmp(buf, "ib\n")) 
if (!strcmp(buf, "eth\n")) 
if (!strcmp(buf, "auto\n")) 
for (i = 0; i < mdev->caps.num_ports; i++) { 
if (types[i] == MLX4_PORT_TYPE_AUTO) 
if (!(mdev->caps.flags & MLX4_DEV_CAP_FLAG_DPDP) && 
for (i = 1; i <= mdev->caps.num_ports; i++) { 
if (err) { 
for both ports (should be the same)\n"); 
if (err) 
ified, no need to remember the temporary types 
for (i = 0; i < mdev->caps.num_ports; i++) 
if (mdev->caps.port_type[info->port] == MLX4_PORT_TYPE_ETH) 
for IB ports\n"); 
if (mdev->caps.port_type[info->port] == MLX4_PORT_TYPE_ETH) { 
for IB ports\n"); 
if (!err) 
if (err || ibta_mtu < 0) { 
for (port = 1; port <= mdev->caps.num_ports; port++) { 
if (err) { 
if (!priv->fw.fw_icm) { 
if (err) { 
if (err) { 
if (err) 
if (err) 
if (err) 
if (err) 
if (err) { 
if (!priv->fw.aux_icm) { 
if (err) { 
if (err) { 
if (err) { 
while the driver 
if (err) { 
if (err) { 
if (err) { 
if (err) { 
if (err) { 
ift, 
if (err) { 
if (err) { 
if (err) { 
for simplicity just map the whole multicast 
if (err) { 
if (mlx4_comm_cmd(dev, MLX4_COMM_CMD_RESET, 0, MLX4_COMM_TIME)) 
if (!dev->caps.bf_reg_size) 
if (!priv->bf_mapping) 
if (mlx4_priv(dev)->bf_mapping) 
for (i = 0; i < 10; i++) { 
if (clockhi == clockhi1) 
if (!priv->clock_mapping) 
if (priv->clock_mapping) 
if (mlx4_is_slave(dev)) 
if (atomic_read(&pf_loading)) { 
if we are in the middle of flr the slave will try 
fore leaving.*/ 
if (MLX4_DELAY_RESET_SLAVE == ret_from_reset) { 
if (MLX4_COMM_GET_IF_REV(cmd_channel_ver) != 
if (mlx4_comm_cmd(dev, MLX4_COMM_CMD_VHCR0, dma >> 48, 
if (mlx4_comm_cmd(dev, MLX4_COMM_CMD_VHCR1, dma >> 32, 
if (mlx4_comm_cmd(dev, MLX4_COMM_CMD_VHCR2, dma >> 16, 
if (mlx4_comm_cmd(dev, MLX4_COMM_CMD_VHCR_EN, dma, MLX4_COMM_TIME)) 
for (i = 1; i <= dev->caps.num_ports; i++) { 
for (i = MLX4_MIN_MGM_LOG_ENTRY_SIZE; i <= MLX4_MAX_MGM_LOG_ENTRY_SIZE; 
if (qp_per_entry <= 4 * ((1 << i) / 16 - 2)) 
if (mlx4_log_num_mgm_entry_size == -1 && 
if (dev->caps.flags & MLX4_DEV_CAP_FLAG_VEP_UC_STEER && 
if (dev->caps.flags & MLX4_DEV_CAP_FLAG_VEP_UC_STEER || 
if (dev->caps.steering_mode == MLX4_STEERING_MODE_DEVICE_MANAGED && 
if (!mlx4_is_slave(dev)) { 
if (err) { 
if (err) { 
if (err) 
if (err) { 
if (err) 
if (mlx4_is_master(dev)) 
if (dev->caps.steering_mode == 
if ((long long) icm_size < 0) { 
if (dev->caps.flags & MLX4_DEV_CAP_FLAG_MEM_WINDOW || 
if (err) 
if (err) { 
if (dev->caps.flags2 & MLX4_DEV_CAP_FLAG2_TS) { 
if (err) { 
if (!dev->caps.hca_core_clock) { 
if (map_internal_clock(dev)) { 
if (err) { 
if (err) { 
if (map_bf_area(dev)) 
if (!mlx4_is_slave(dev)) 
if (err) { 
if (mlx4_is_slave(dev)) { 
if (mlx4_is_slave(dev)) 
if (!mlx4_is_slave(dev)) 
if (!mlx4_is_slave(dev)) { 
if (!(dev->caps.flags & MLX4_DEV_CAP_FLAG_COUNTERS)) 
if (!(dev->caps.flags & MLX4_DEV_CAP_FLAG_COUNTERS)) 
if (*idx == -1) 
if (mlx4_is_mfunc(dev)) { 
if (!err) 
if (mlx4_is_mfunc(dev)) { 
if (err) { 
if (err) { 
if (!priv->kar) { 
if (err) { 
if (err) { 
if (err) { 
if (!mlx4_is_slave(dev)) { 
if (err) { 
if (err) { 
if (err) { 
if (err) { 
if (err) { 
if (err) { 
if (err) { 
if (err && err != -ENOENT) { 
if (!mlx4_is_slave(dev)) { 
for (port = 1; port <= dev->caps.num_ports; port++) { 
if (err) 
if (mlx4_is_master(dev)) { 
for (i = 0; i < dev->num_slaves; i++) { 
if (mlx4_is_mfunc(dev)) 
if (err) { 
if (!mlx4_is_slave(dev)) 
if (msi_x) { 
if (!entries) 
for (i = 0; i < nreq; ++i) 
if (nreq < 0) { 
if (nreq < MSIX_LEGACY_SZ + 
for (i = 0; i < nreq; ++i) 
for (i = 0; i < 2; ++i) 
if (!mlx4_is_slave(dev)) { 
if (mlx4_is_mfunc(dev)) 
if (err) { 
for port %d\n", port); 
if (mlx4_is_mfunc(dev)) 
if (err) { 
for port %d\n", port); 
if (info->port < 0) 
if (!priv->steer) 
for (i = 0; i < num_entries; i++) 
for (i = 0; i < num_entries; i++) { 
for_each_entry_safe(pqp, tmp_pqp, 
for_each_entry_safe(entry, tmp_entry, 
for_each_entry_safe(pqp, tmp_pqp, 
if (pci_channel_offline(dev->pdev)) 
if (!owner) { 
if (pci_channel_offline(dev->pdev)) 
if (!owner) { 
if (err) { 
for (i = 0; i < sizeof(nvfs)/sizeof(nvfs[0]) && i < num_vfs_argc; 
if (nvfs[i] < 0) { 
for (i = 0; i < sizeof(prb_vf)/sizeof(prb_vf[0]) && i < probe_vfs_argc; 
if (prb_vf[i] < 0 || prb_vf[i] > nvfs[i]) { 
if (total_vfs >= MLX4_MAX_NUM_VF) { 
for (i = 0; i < MLX4_MAX_PORTS; i++) { 
for port (%d) than allowed (%d)\n", 
for BARs. 
if (!(pci_dev_data & MLX4_PCI_DEV_IS_VF) && 
if (!(pci_resource_flags(pdev, 2) & IORESOURCE_MEM)) { 
if (err) { 
if (err) { 
if (err) { 
if (err) { 
if (err) { 
if this device is a virtual function */ 
if (total_vfs) { 
for (i = 0; i < sizeof(nvfs)/sizeof(nvfs[0]) && 
if (i == sizeof(nvfs)/sizeof(nvfs[0])) { 
if ((extended_func_num(pdev) - vfs_offset) 
for physical 
if already taken, skip -- do not allow multiple PFs */ 
if (err) { 
if (total_vfs) { 
if (NULL == dev->dev_vfs) { 
for VFs\n"); 
if (err) { 
fore we touch the PCI capabilities or 
if (err) { 
if (err) { 
fore posting commands. Also, init num_slaves before calling 
if (mlx4_is_mfunc(dev)) { 
if (err) { 
if (err) { 
if the device is functioning at its maximum possible speed. 
for this call, just warn the user in case of PCI 
if (!mlx4_is_slave(dev)) 
if (mlx4_is_master(dev)) { 
if (err) { 
if (sriov_initialized) { 
foreach_port(i, dev, MLX4_PORT_TYPE_IB) 
if (ib_ports && 
for (i = 0; i < sizeof(nvfs)/sizeof(nvfs[0]); i++) { 
for (j = 0; j < nvfs[i]; ++sum, ++j) { 
if (err) 
if ((mlx4_is_mfunc(dev)) && 
if (!mlx4_is_slave(dev)) { 
if (err) 
if (err == -EBUSY && (dev->flags & MLX4_FLAG_MSI_X) && 
if (err) 
for (port = 1; port <= dev->caps.num_ports; port++) { 
if (err) 
if (err) 
if (mlx4_is_master(dev) && dev->num_vfs) 
for (--port; port >= 1; --port) 
if (!mlx4_is_slave(dev)) 
if (mlx4_is_master(dev)) 
if (mlx4_is_slave(dev)) { 
if (dev->flags & MLX4_FLAG_MSI_X) 
if (mlx4_is_slave(dev)) 
if (dev->flags & MLX4_FLAG_SRIOV) 
if (!mlx4_is_slave(dev)) 
if (mlx4_is_master(dev) && dev->num_vfs) 
if (!priv) 
if (priv->removed) 
while there are alive vf's */ 
for (p = 1; p <= dev->caps.num_ports; p++) { 
if (mlx4_is_master(dev)) 
if (mlx4_is_master(dev)) 
if (!mlx4_is_slave(dev)) 
if (mlx4_is_master(dev)) 
if (mlx4_is_slave(dev)) 
if (dev->flags & MLX4_FLAG_MSI_X) 
if (dev->flags & MLX4_FLAG_SRIOV) { 
if (!mlx4_is_slave(dev)) 
ify_params(void) 
if (log_num_vlan != 0) 
if (use_prio != 0) 
if ((log_mtts_per_seg < 1) || (log_mtts_per_seg > 7)) { 
if module param for ports type has legal combination */ 
if (mlx4_log_num_mgm_entry_size != -1 && 
if (mlx4_verify_params()) 
if (!mlx4_wq) 
if (ret < 0) 
file : ./test/kernel/net/batman-adv/main.c 
[ OK ] open : 4 ok... 
buf : /* Copyright (C) 2007-2014 B.A.T.M.A.N. contributors:
ify it under the terms of version 2 of the GNU General Public 
for more details. 
if not, see <http://www.gnu.org/licenses/>. 
if_vlan.h> 
if_list have to be rtnl_lock()'ed, 
if_list; 
iface *); 
if_list); 
if (!batadv_event_workqueue) 
ifier(&batadv_hard_if_notifier); 
ifier(&batadv_hard_if_notifier); 
iface) 
forw_bat_list_lock); 
ifdef CONFIG_BATMAN_ADV_MCAST 
if 
if_vlan_list_lock); 
forw_bat_list); 
ifdef CONFIG_BATMAN_ADV_MCAST 
if 
ifdef CONFIG_BATMAN_ADV_MCAST 
if 
if_vlan_list); 
if (ret < 0) 
if (ret < 0) 
if (ret < 0) 
if (ret < 0) 
if (ret < 0) 
iface); 
iface) 
for 
for later execution. 
if the given mac address belongs to any of the real 
formation 
iface *hard_iface; 
iface, &batadv_hardif_list, list) { 
if (hard_iface->soft_iface != bat_priv->soft_iface) 
if (batadv_compare_eth(hard_iface->net_dev->dev_addr, addr)) { 
if_get - called from debugfs table printing 
if found or NULL otherwise. 
iface * 
iface *primary_if; 
if (!primary_if) { 
ify interfaces to enable it\n", 
if (primary_if->if_status == BATADV_IF_ACTIVE) 
if_free_ref(primary_if); 
if; 
for a 
ifdef CONFIG_BATMAN_ADV_NC 
if 
if (skb->priority >= 256 && skb->priority <= 263) 
if (!ethhdr) 
if (!vhdr) 
if (!ip_hdr) 
if (!ip6_hdr) 
iface *recv_if) 
iface *hard_iface; 
iface = container_of(ptype, struct batadv_hard_iface, 
if (!skb) 
if (unlikely(!pskb_may_pull(skb, 2))) 
if (unlikely(skb->mac_len != ETH_HLEN || !skb_mac_header(skb))) 
if (!hard_iface->soft_iface) 
iface->soft_iface); 
if (hard_iface->if_status != BATADV_IF_ACTIVE) 
if (batadv_ogm_packet->version != BATADV_COMPAT_VERSION) { 
if not, we have to free the skb. 
iface); 
for 
for (i = 0; i < ARRAY_SIZE(batadv_rx_handler); i++) 
for (i = BATADV_UNICAST_MIN; i <= BATADV_UNICAST_MAX; i++) 
for sizes */ 
iface *)) 
iface *); 
if ((curr != batadv_recv_unhandled_packet) && 
for_each_entry(bat_algo_ops_tmp, &batadv_algo_list, list) { 
if (bat_algo_ops_tmp) { 
for now) */ 
iface_disable || 
iface_set || 
if (!bat_algo_ops) 
for_each_entry(bat_algo_ops, &batadv_algo_list, list) { 
while ((len = skb_seq_read(consumed, &data, &st)) != 0) { 
if (atomic_dec_and_test(&tvlv_handler->refcount)) 
formation 
for 
for_each_entry_rcu(tvlv_handler_tmp, 
if (tvlv_handler_tmp->type != type) 
if (tvlv_handler_tmp->version != version) 
if (!atomic_inc_not_zero(&tvlv_handler_tmp->refcount)) 
if (atomic_dec_and_test(&tvlv->refcount)) 
formation 
for 
if found or NULL otherwise. 
for_each_entry(tvlv_tmp, &bat_priv->tvlv.container_list, list) { 
if (tvlv_tmp->tvlv_hdr.version != version) 
if (!atomic_inc_not_zero(&tvlv_tmp->refcount)) 
formation 
for_each_entry(tvlv, &bat_priv->tvlv.container_list, list) { 
if (!tvlv) 
formation 
formation 
if (!tvlv_value) 
if (!tvlv_new) 
if kmalloc should fail */ 
formation 
for the OGM itself 
if (!ret) 
if (!tvlv_value_len) 
for_each_entry(tvlv, &bat_priv->tvlv.container_list, list) { 
formation 
if handler was not found or the return value of the handler 
if (!tvlv_handler) 
if (ogm_source) { 
if (!orig_node) 
if (!src) 
if (!dst) 
if (!tvlv_handler->unicast_handler) 
formation 
ifnotfound = BATADV_TVLV_HANDLER_OGM_CIFNOTFND; 
while (tvlv_value_len >= sizeof(*tvlv_hdr)) { 
if (tvlv_value_cont_len > tvlv_value_len) 
if (tvlv_handler) 
if (!ogm_source) 
for_each_entry_rcu(tvlv_handler, 
if ((tvlv_handler->flags & BATADV_TVLV_HANDLER_OGM_CIFNOTFND) && 
ifnotfound, NULL, 0); 
formation 
if (!batadv_ogm_packet) 
if (!tvlv_value_len) 
for ogm tvlv payload and/or unicast 
formation 
if (tvlv_handler) { 
if (!tvlv_handler) 
formation 
if (!tvlv_handler) 
ified host 
formation 
if (!orig_node) 
if (!skb) 
if (batadv_send_skb_to_orig(skb, orig_node, NULL) != NET_XMIT_DROP) 
if (skb && !ret) 
if (orig_node) 
ifier from skb if any 
if (ethhdr->h_proto != htons(ETH_P_8021Q)) 
if (!pskb_may_pull(skb, header_len + VLAN_ETH_HLEN)) 
for the given vlan 
ifier for which the AP isolation attributed as to be 
if AP isolation is on for the VLAN idenfied by vid, false 
if_vlan *vlan; 
for its 
if_vlan_get(bat_priv, vid); 
if_vlan_free_ref(vlan); 
if (name_len > 0 && algo_name[name_len - 1] == '\n') 
if (!bat_algo_ops) { 
file : ./test/kernel/net/mac80211/main.c 
[ OK ] open : 4 ok... 
buf : /*
ify 
if_arp.h> 
if (atomic_read(&local->iff_promiscs)) 
if (atomic_read(&local->iff_allmultis)) 
if (local->monitors || test_bit(SCAN_SW_SCANNING, &local->scanning) || 
if (local->fif_probe_req || local->probe_req_reg) 
if (local->fif_fcsfail) 
if (local->fif_plcpfail) 
if (local->fif_control) 
if (local->fif_other_bss) 
if (local->fif_pspoll) 
if_data *sdata; 
if (local->scan_chandef.chan) { 
if (local->tmp_channel) { 
if (!cfg80211_chandef_identical(&chandef, &local->_oper_chandef)) 
if (offchannel_flag || 
if (!conf_is_ht(&local->hw.conf)) { 
if (local->hw.conf.smps_mode != local->smps_mode) { 
for_each_entry_rcu(sdata, &local->interfaces, list) { 
if (sdata->vif.type == NL80211_IFTYPE_AP_VLAN) 
if.bss_conf.txpower); 
if (local->hw.conf.power_level != power) { 
if (!local->use_chanctx) 
if (changed && local->open_count) { 
if hardware rfkill 
ify(struct ieee80211_sub_if_data *sdata, 
if (!changed || sdata->vif.type == NL80211_IFTYPE_AP_VLAN) 
if.bss_conf, changed); 
if.bss_conf.use_cts_prot = false; 
if.bss_conf.use_short_slot = false; 
while ((skb = skb_dequeue(&local->skb_queue)) || 
for scan work complete */ 
while this is in progress. 
ifdef CONFIG_INET 
ifaddr *ifa = arg; 
ifa_notifier); 
if_data *sdata; 
if_managed *ifmgd; 
if (!wdev) 
if (wdev->wiphy != local->hw.wiphy) 
if.bss_conf; 
if (sdata->vif.type != NL80211_IFTYPE_STATION) 
if (!idev) 
ifmgd = &sdata->u.mgd; 
ifa = idev->ifa_list; 
while (ifa) { 
ifa->ifa_address; 
if associated (which also implies it is up) */ 
ify(sdata, 
if 
ifa6_changed(struct notifier_block *nb, 
ifaddr *ifa = (struct inet6_ifaddr *)arg; 
ifa->idev->dev; 
ifa6_notifier); 
if_data *sdata; 
if (!wdev || wdev->wiphy != local->hw.wiphy) 
if (sdata->vif.type != NL80211_IFTYPE_STATION) 
if 
if (WARN_ON(!ops->tx || !ops->start || !ops->stop || !ops->config || 
if (WARN_ON(ops->sta_state && (ops->sta_add || ops->sta_remove))) 
if_chanctx + 
if (WARN_ON(i != 0 && i != 5)) 
for both our ieee80211_local and for 
if (!wiphy) 
if (ops->remain_on_channel) 
if (!ops->hw_scan) 
if (!ops->set_key) 
iflist_mtx); 
for (i = 0; i < IEEE80211_MAX_QUEUES; i++) { 
ifies the ciphers, we have nothing to do... */ 
if driver relies on mac80211 cipher defs */ 
if (!have_mfp) 
if (!have_wep) { 
if (!local->hw.wiphy->cipher_suites) { 
ifies cipher schemes only 
if we have WEP40 and WEP104 */ 
if we have AES_CMAC */ 
if (!suites) 
if (have_wep) { 
if (have_mfp) 
for (r = 0; r < local->hw.n_cipher_schemes; r++) 
if (!suites) 
for (r = 0; r < local->hw.wiphy->n_cipher_suites; r++) { 
if (suite == WLAN_CIPHER_SUITE_WEP40 || 
if (hw->flags & IEEE80211_HW_QUEUE_CONTROL && 
ifdef CONFIG_PM 
if 
iface_combinations; i++) { 
iface_combinations[i]; 
if (local->hw.wiphy->interface_modes & BIT(NL80211_IFTYPE_WDS)) 
iface_combinations; i++) { 
iface_combinations[i]; 
if (WARN_ON(hw->netdev_features & ~feature_whitelist)) 
if (hw->max_report_rates == 0) 
for (band = 0; band < IEEE80211_NUM_BANDS; band++) { 
if (!sband) 
if (!dflt_chandef.chan) { 
if (!local->use_chanctx && !local->_oper_chandef.chan) { 
if (max_bitrates < sband->n_bitrates) 
if (sband->ht_cap.ht_supported) 
for RX chains, hopefully it's the same */ 
if (local->hw.wiphy->interface_modes & BIT(NL80211_IFTYPE_AP)) { 
iftypes |= BIT(NL80211_IFTYPE_AP_VLAN); 
iftypes |= BIT(NL80211_IFTYPE_MONITOR); 
iface_combinations; i++) { 
iface_combinations[i]; 
for (j = 0; j < c->n_limits; j++) 
if (!local->int_scan_req) 
for (band = 0; band < IEEE80211_NUM_BANDS; band++) { 
ifndef CONFIG_MAC80211_MESH 
if 
if (local->hw.wiphy->interface_modes & BIT(NL80211_IFTYPE_MESH_POINT)) 
if (local->hw.flags & IEEE80211_HW_SIGNAL_DBM) { 
if (local->hw.flags & IEEE80211_HW_SIGNAL_UNSPEC) { 
if (hw->max_signal <= 0) { 
formation -- SSID is the driver's responsibility. 
if (supp_ht) 
if (supp_vht) 
if (!local->ops->hw_scan) { 
if (local->hw.wiphy->max_scan_ie_len) 
if (result < 0) 
if (!local->ops->remain_on_channel) 
if (local->hw.wiphy->flags & WIPHY_FLAG_SUPPORTS_TDLS) 
if (result < 0) 
for feature tests (QoS, HT) internally 
if (hw->queues > IEEE80211_MAX_QUEUES) 
if (!local->workqueue) { 
for sending the frame, 
if the driver doesn't specify a max listen interval we 
if (local->hw.max_listen_interval == 0) 
forced_timeout = -1; 
if (result < 0) 
if (result < 0) { 
if supported */ 
if_add(local, "wlan%d", NULL, 
if (result) 
iface\n"); 
ifier.notifier_call = 
ifier(PM_QOS_NETWORK_LATENCY, 
if (result) { 
ifdef CONFIG_INET 
ifier(&local->ifa_notifier); 
ifa; 
if IS_ENABLED(CONFIG_IPV6) 
ifier(&local->ifa6_notifier); 
ifa6; 
if IS_ENABLED(CONFIG_IPV6) 
ifdef CONFIG_INET 
if 
if defined(CONFIG_INET) || defined(CONFIG_IPV6) 
ifier(PM_QOS_NETWORK_LATENCY, 
if 
if (local->wiphy_ciphers_allocated) 
if_napi_add(napi_dev, napi, poll, weight); 
ifier(PM_QOS_NETWORK_LATENCY, 
ifdef CONFIG_INET 
if 
ifier(&local->ifa6_notifier); 
if (skb_queue_len(&local->skb_queue) || 
iflist_mtx); 
if (local->wiphy_ciphers_allocated) 
for_each(&local->ack_status_frames, 
if (ret) 
if (ret) 
if (ret) 
iface_init(); 
iface_exit(); 
