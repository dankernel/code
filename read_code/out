list print :      (nil) ( 0x21ca040       INIT)  0x21ca060 
list print :  0x21ca040 ( 0x21ca060         if)  0x21ca080 
list print :  0x21ca060 ( 0x21ca080        for)  0x21ca0a0 
list print :  0x21ca080 ( 0x21ca0a0      while)      (nil) 
[ OK ] open : 3 ok... 
STR : /*
STR :  *  kernel/sched/core.c
STR :  *
STR :  *  Kernel scheduler and related syscalls
STR :  *
STR :  *  Copyright (C) 1991-2002  Linus Torvalds
STR :  *
STR :  *  1996-12-23  Modified by Dave Grothe to fix bugs in semaphores and
STR :  *		make semaphores SMP safe
STR :  *  1998-11-19	Implemented schedule_timeout() and related stuff
STR :  *		by Andrea Arcangeli
STR :  *  2002-01-04	New ultra-scalable O(1) scheduler by Ingo Molnar:
STR :  *		hybrid priority-list and round-robin design with
STR :  *		an array-switch method of distributing timeslices
STR :  *		and per-CPU runqueues.  Cleanups and useful suggestions
STR :  *		by Davide Libenzi, preemptible kernel bits by Robert Love.
STR :  *  2003-09-03	Interactivity tuning by Con Kolivas.
STR :  *  2004-04-02	Scheduler domains code by Nick Piggin
STR :  *  2007-04-15  Work begun on replacing all interactivity tuning with a
STR :  *              fair scheduling design by Con Kolivas.
STR :  *  2007-05-05  Load balancing (smp-nice) and other improvements
STR :  *              by Peter Williams
STR :  *  2007-05-06  Interactivity improvements to CFS by Mike Galbraith
STR :  *  2007-07-01  Group scheduling enhancements by Srivatsa Vaddagiri
STR :  *  2007-11-29  RT balancing improvements by Steven Rostedt, Gregory Haskins,
STR :  *              Thomas Gleixner, Mike Kravetz
STR :  */
STR : 
STR : #include <linux/mm.h>
STR : #include <linux/module.h>
STR : #include <linux/nmi.h>
STR : #include <linux/init.h>
STR : #include <linux/uaccess.h>
STR : #include <linux/highmem.h>
STR : #include <asm/mmu_context.h>
STR : #include <linux/interrupt.h>
STR : #include <linux/capability.h>
STR : #include <linux/completion.h>
STR : #include <linux/kernel_stat.h>
STR : #include <linux/debug_locks.h>
STR : #include <linux/perf_event.h>
STR : #include <linux/security.h>
STR : #include <linux/notifier.h>
STR : #include <linux/profile.h>
STR : #include <linux/freezer.h>
STR : #include <linux/vmalloc.h>
STR : #include <linux/blkdev.h>
STR : #include <linux/delay.h>
STR : #include <linux/pid_namespace.h>
STR : #include <linux/smp.h>
STR : #include <linux/threads.h>
STR : #include <linux/timer.h>
STR : #include <linux/rcupdate.h>
STR : #include <linux/cpu.h>
STR : #include <linux/cpuset.h>
STR : #include <linux/percpu.h>
STR : #include <linux/proc_fs.h>
STR : #include <linux/seq_file.h>
STR : #include <linux/sysctl.h>
STR : #include <linux/syscalls.h>
STR : #include <linux/times.h>
STR : #include <linux/tsacct_kern.h>
STR : #include <linux/kprobes.h>
STR : #include <linux/delayacct.h>
STR : #include <linux/unistd.h>
STR : #include <linux/pagemap.h>
STR : #include <linux/hrtimer.h>
STR : #include <linux/tick.h>
STR : #include <linux/debugfs.h>
STR : #include <linux/ctype.h>
STR : #include <linux/ftrace.h>
STR : #include <linux/slab.h>
STR : #include <linux/init_task.h>
STR : #include <linux/binfmts.h>
STR : #include <linux/context_tracking.h>
STR : 
STR : #include <asm/switch_to.h>
STR : #include <asm/tlb.h>
STR : #include <asm/irq_regs.h>
STR : #include <asm/mutex.h>
STR : #ifdef CONFIG_PARAVIRT
STR : #include <asm/paravirt.h>
STR : #endif
STR : 
STR : #include "sched.h"
STR : #include "../workqueue_internal.h"
STR : #include "../smpboot.h"
STR : 
STR : #define CREATE_TRACE_POINTS
STR : #include <trace/events/sched.h>
STR : 
STR : void start_bandwidth_timer(struct hrtimer *period_timer, ktime_t period)
STR : {
STR : 	unsigned long delta;
STR : 	ktime_t soft, hard, now;
STR : 
STR : 	for (;;) {
STR : 		if (hrtimer_active(period_timer))
STR : 			break;
STR : 
STR : 		now = hrtimer_cb_get_time(period_timer);
STR : 		hrtimer_forward(period_timer, now, period);
STR : 
STR : 		soft = hrtimer_get_softexpires(period_timer);
STR : 		hard = hrtimer_get_expires(period_timer);
STR : 		delta = ktime_to_ns(ktime_sub(hard, soft));
STR : 		__hrtimer_start_range_ns(period_timer, soft, delta,
STR : 					 HRTIMER_MODE_ABS_PINNED, 0);
STR : 	}
STR : }
STR : 
STR : DEFINE_MUTEX(sched_domains_mutex);
STR : DEFINE_PER_CPU_SHARED_ALIGNED(struct rq, runqueues);
STR : 
STR : static void update_rq_clock_task(struct rq *rq, s64 delta);
STR : 
STR : void update_rq_clock(struct rq *rq)
STR : {
STR : 	s64 delta;
STR : 
STR : 	if (rq->skip_clock_update > 0)
STR : 		return;
STR : 
STR : 	delta = sched_clock_cpu(cpu_of(rq)) - rq->clock;
STR : 	rq->clock += delta;
STR : 	update_rq_clock_task(rq, delta);
STR : }
STR : 
STR : /*
STR :  * Debugging: various feature bits
STR :  */
STR : 
STR : #define SCHED_FEAT(name, enabled)	\
STR : 	(1UL << __SCHED_FEAT_##name) * enabled |
STR : 
STR : const_debug unsigned int sysctl_sched_features =
STR : #include "features.h"
STR : 	0;
STR : 
STR : #undef SCHED_FEAT
STR : 
STR : #ifdef CONFIG_SCHED_DEBUG
STR : #define SCHED_FEAT(name, enabled)	\
STR : 	#name ,
STR : 
STR : static const char * const sched_feat_names[] = {
STR : #include "features.h"
STR : };
STR : 
STR : #undef SCHED_FEAT
STR : 
STR : static int sched_feat_show(struct seq_file *m, void *v)
STR : {
STR : 	int i;
STR : 
STR : 	for (i = 0; i < __SCHED_FEAT_NR; i++) {
STR : 		if (!(sysctl_sched_features & (1UL << i)))
STR : 			seq_puts(m, "NO_");
STR : 		seq_printf(m, "%s ", sched_feat_names[i]);
STR : 	}
STR : 	seq_puts(m, "\n");
STR : 
STR : 	return 0;
STR : }
STR : 
STR : #ifdef HAVE_JUMP_LABEL
STR : 
STR : #define jump_label_key__true  STATIC_KEY_INIT_TRUE
STR : #define jump_label_key__false STATIC_KEY_INIT_FALSE
STR : 
STR : #define SCHED_FEAT(name, enabled)	\
STR : 	jump_label_key__##enabled ,
STR : 
STR : struct static_key sched_feat_keys[__SCHED_FEAT_NR] = {
STR : #include "features.h"
STR : };
STR : 
STR : #undef SCHED_FEAT
STR : 
STR : static void sched_feat_disable(int i)
STR : {
STR : 	if (static_key_enabled(&sched_feat_keys[i]))
STR : 		static_key_slow_dec(&sched_feat_keys[i]);
STR : }
STR : 
STR : static void sched_feat_enable(int i)
STR : {
STR : 	if (!static_key_enabled(&sched_feat_keys[i]))
STR : 		static_key_slow_inc(&sched_feat_keys[i]);
STR : }
STR : #else
STR : static void sched_feat_disable(int i) { };
STR : static void sched_feat_enable(int i) { };
STR : #endif /* HAVE_JUMP_LABEL */
STR : 
STR : static int sched_feat_set(char *cmp)
STR : {
STR : 	int i;
STR : 	int neg = 0;
STR : 
STR : 	if (strncmp(cmp, "NO_", 3) == 0) {
STR : 		neg = 1;
STR : 		cmp += 3;
STR : 	}
STR : 
STR : 	for (i = 0; i < __SCHED_FEAT_NR; i++) {
STR : 		if (strcmp(cmp, sched_feat_names[i]) == 0) {
STR : 			if (neg) {
STR : 				sysctl_sched_features &= ~(1UL << i);
STR : 				sched_feat_disable(i);
STR : 			} else {
STR : 				sysctl_sched_features |= (1UL << i);
STR : 				sched_feat_enable(i);
STR : 			}
STR : 			break;
STR : 		}
STR : 	}
STR : 
STR : 	return i;
STR : }
STR : 
STR : static ssize_t
STR : sched_feat_write(struct file *filp, const char __user *ubuf,
STR : 		size_t cnt, loff_t *ppos)
STR : {
STR : 	char buf[64];
STR : 	char *cmp;
STR : 	int i;
STR : 
STR : 	if (cnt > 63)
STR : 		cnt = 63;
STR : 
STR : 	if (copy_from_user(&buf, ubuf, cnt))
STR : 		return -EFAULT;
STR : 
STR : 	buf[cnt] = 0;
STR : 	cmp = strstrip(buf);
STR : 
STR : 	i = sched_feat_set(cmp);
STR : 	if (i == __SCHED_FEAT_NR)
STR : 		return -EINVAL;
STR : 
STR : 	*ppos += cnt;
STR : 
STR : 	return cnt;
STR : }
STR : 
STR : static int sched_feat_open(struct inode *inode, struct file *filp)
STR : {
STR : 	return single_open(filp, sched_feat_show, NULL);
STR : }
STR : 
STR : static const struct file_operations sched_feat_fops = {
STR : 	.open		= sched_feat_open,
STR : 	.write		= sched_feat_write,
STR : 	.read		= seq_read,
STR : 	.llseek		= seq_lseek,
STR : 	.release	= single_release,
STR : };
STR : 
STR : static __init int sched_init_debug(void)
STR : {
STR : 	debugfs_create_file("sched_features", 0644, NULL, NULL,
STR : 			&sched_feat_fops);
STR : 
STR : 	return 0;
STR : }
STR : late_initcall(sched_init_debug);
STR : #endif /* CONFIG_SCHED_DEBUG */
STR : 
STR : /*
STR :  * Number of tasks to iterate in a single balance run.
STR :  * Limited because this is done with IRQs disabled.
STR :  */
STR : const_debug unsigned int sysctl_sched_nr_migrate = 32;
STR : 
STR : /*
STR :  * period over which we average the RT time consumption, measured
STR :  * in ms.
STR :  *
STR :  * default: 1s
STR :  */
STR : const_debug unsigned int sysctl_sched_time_avg = MSEC_PER_SEC;
STR : 
STR : /*
STR :  * period over which we measure -rt task cpu usage in us.
STR :  * default: 1s
STR :  */
STR : unsigned int sysctl_sched_rt_period = 1000000;
STR : 
STR : __read_mostly int scheduler_running;
STR : 
STR : /*
STR :  * part of the period that we allow rt tasks to run in us.
STR :  * default: 0.95s
STR :  */
STR : int sysctl_sched_rt_runtime = 950000;
STR : 
STR : /*
STR :  * __task_rq_lock - lock the rq @p resides on.
STR :  */
STR : static inline struct rq *__task_rq_lock(struct task_struct *p)
STR : 	__acquires(rq->lock)
STR : {
STR : 	struct rq *rq;
STR : 
STR : 	lockdep_assert_held(&p->pi_lock);
STR : 
STR : 	for (;;) {
STR : 		rq = task_rq(p);
STR : 		raw_spin_lock(&rq->lock);
STR : 		if (likely(rq == task_rq(p)))
STR : 			return rq;
STR : 		raw_spin_unlock(&rq->lock);
STR : 	}
STR : }
STR : 
STR : /*
STR :  * task_rq_lock - lock p->pi_lock and lock the rq @p resides on.
STR :  */
STR : static struct rq *task_rq_lock(struct task_struct *p, unsigned long *flags)
STR : 	__acquires(p->pi_lock)
STR : 	__acquires(rq->lock)
STR : {
STR : 	struct rq *rq;
STR : 
STR : 	for (;;) {
STR : 		raw_spin_lock_irqsave(&p->pi_lock, *flags);
STR : 		rq = task_rq(p);
STR : 		raw_spin_lock(&rq->lock);
STR : 		if (likely(rq == task_rq(p)))
STR : 			return rq;
STR : 		raw_spin_unlock(&rq->lock);
STR : 		raw_spin_unlock_irqrestore(&p->pi_lock, *flags);
STR : 	}
STR : }
STR : 
STR : static void __task_rq_unlock(struct rq *rq)
STR : 	__releases(rq->lock)
STR : {
STR : 	raw_spin_unlock(&rq->lock);
STR : }
STR : 
STR : static inline void
STR : task_rq_unlock(struct rq *rq, struct task_struct *p, unsigned long *flags)
STR : 	__releases(rq->lock)
STR : 	__releases(p->pi_lock)
STR : {
STR : 	raw_spin_unlock(&rq->lock);
STR : 	raw_spin_unlock_irqrestore(&p->pi_lock, *flags);
STR : }
STR : 
STR : /*
STR :  * this_rq_lock - lock this runqueue and disable interrupts.
STR :  */
STR : static struct rq *this_rq_lock(void)
STR : 	__acquires(rq->lock)
STR : {
STR : 	struct rq *rq;
STR : 
STR : 	local_irq_disable();
STR : 	rq = this_rq();
STR : 	raw_spin_lock(&rq->lock);
STR : 
STR : 	return rq;
STR : }
STR : 
STR : #ifdef CONFIG_SCHED_HRTICK
STR : /*
STR :  * Use HR-timers to deliver accurate preemption points.
STR :  */
STR : 
STR : static void hrtick_clear(struct rq *rq)
STR : {
STR : 	if (hrtimer_active(&rq->hrtick_timer))
STR : 		hrtimer_cancel(&rq->hrtick_timer);
STR : }
STR : 
STR : /*
STR :  * High-resolution timer tick.
STR :  * Runs from hardirq context with interrupts disabled.
STR :  */
STR : static enum hrtimer_restart hrtick(struct hrtimer *timer)
STR : {
STR : 	struct rq *rq = container_of(timer, struct rq, hrtick_timer);
STR : 
STR : 	WARN_ON_ONCE(cpu_of(rq) != smp_processor_id());
STR : 
STR : 	raw_spin_lock(&rq->lock);
STR : 	update_rq_clock(rq);
STR : 	rq->curr->sched_class->task_tick(rq, rq->curr, 1);
STR : 	raw_spin_unlock(&rq->lock);
STR : 
STR : 	return HRTIMER_NORESTART;
STR : }
STR : 
STR : #ifdef CONFIG_SMP
STR : 
STR : static int __hrtick_restart(struct rq *rq)
STR : {
STR : 	struct hrtimer *timer = &rq->hrtick_timer;
STR : 	ktime_t time = hrtimer_get_softexpires(timer);
STR : 
STR : 	return __hrtimer_start_range_ns(timer, time, 0, HRTIMER_MODE_ABS_PINNED, 0);
STR : }
STR : 
STR : /*
STR :  * called from hardirq (IPI) context
STR :  */
STR : static void __hrtick_start(void *arg)
STR : {
STR : 	struct rq *rq = arg;
STR : 
STR : 	raw_spin_lock(&rq->lock);
STR : 	__hrtick_restart(rq);
STR : 	rq->hrtick_csd_pending = 0;
STR : 	raw_spin_unlock(&rq->lock);
STR : }
STR : 
STR : /*
STR :  * Called to set the hrtick timer state.
STR :  *
STR :  * called with rq->lock held and irqs disabled
STR :  */
STR : void hrtick_start(struct rq *rq, u64 delay)
STR : {
STR : 	struct hrtimer *timer = &rq->hrtick_timer;
STR : 	ktime_t time = ktime_add_ns(timer->base->get_time(), delay);
STR : 
STR : 	hrtimer_set_expires(timer, time);
STR : 
STR : 	if (rq == this_rq()) {
STR : 		__hrtick_restart(rq);
STR : 	} else if (!rq->hrtick_csd_pending) {
STR : 		__smp_call_function_single(cpu_of(rq), &rq->hrtick_csd, 0);
STR : 		rq->hrtick_csd_pending = 1;
STR : 	}
STR : }
STR : 
STR : static int
STR : hotplug_hrtick(struct notifier_block *nfb, unsigned long action, void *hcpu)
STR : {
STR : 	int cpu = (int)(long)hcpu;
STR : 
STR : 	switch (action) {
STR : 	case CPU_UP_CANCELED:
STR : 	case CPU_UP_CANCELED_FROZEN:
STR : 	case CPU_DOWN_PREPARE:
STR : 	case CPU_DOWN_PREPARE_FROZEN:
STR : 	case CPU_DEAD:
STR : 	case CPU_DEAD_FROZEN:
STR : 		hrtick_clear(cpu_rq(cpu));
STR : 		return NOTIFY_OK;
STR : 	}
STR : 
STR : 	return NOTIFY_DONE;
STR : }
STR : 
STR : static __init void init_hrtick(void)
STR : {
STR : 	hotcpu_notifier(hotplug_hrtick, 0);
STR : }
STR : #else
STR : /*
STR :  * Called to set the hrtick timer state.
STR :  *
STR :  * called with rq->lock held and irqs disabled
STR :  */
STR : void hrtick_start(struct rq *rq, u64 delay)
STR : {
STR : 	__hrtimer_start_range_ns(&rq->hrtick_timer, ns_to_ktime(delay), 0,
STR : 			HRTIMER_MODE_REL_PINNED, 0);
STR : }
STR : 
STR : static inline void init_hrtick(void)
STR : {
STR : }
STR : #endif /* CONFIG_SMP */
STR : 
STR : static void init_rq_hrtick(struct rq *rq)
STR : {
STR : #ifdef CONFIG_SMP
STR : 	rq->hrtick_csd_pending = 0;
STR : 
STR : 	rq->hrtick_csd.flags = 0;
STR : 	rq->hrtick_csd.func = __hrtick_start;
STR : 	rq->hrtick_csd.info = rq;
STR : #endif
STR : 
STR : 	hrtimer_init(&rq->hrtick_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
STR : 	rq->hrtick_timer.function = hrtick;
STR : }
STR : #else	/* CONFIG_SCHED_HRTICK */
STR : static inline void hrtick_clear(struct rq *rq)
STR : {
STR : }
STR : 
STR : static inline void init_rq_hrtick(struct rq *rq)
STR : {
STR : }
STR : 
STR : static inline void init_hrtick(void)
STR : {
STR : }
STR : #endif	/* CONFIG_SCHED_HRTICK */
STR : 
STR : /*
STR :  * resched_task - mark a task 'to be rescheduled now'.
STR :  *
STR :  * On UP this means the setting of the need_resched flag, on SMP it
STR :  * might also involve a cross-CPU call to trigger the scheduler on
STR :  * the target CPU.
STR :  */
STR : void resched_task(struct task_struct *p)
STR : {
STR : 	int cpu;
STR : 
STR : 	lockdep_assert_held(&task_rq(p)->lock);
STR : 
STR : 	if (test_tsk_need_resched(p))
STR : 		return;
STR : 
STR : 	set_tsk_need_resched(p);
STR : 
STR : 	cpu = task_cpu(p);
STR : 	if (cpu == smp_processor_id()) {
STR : 		set_preempt_need_resched();
STR : 		return;
STR : 	}
STR : 
STR : 	/* NEED_RESCHED must be visible before we test polling */
STR : 	smp_mb();
STR : 	if (!tsk_is_polling(p))
STR : 		smp_send_reschedule(cpu);
STR : }
STR : 
STR : void resched_cpu(int cpu)
STR : {
STR : 	struct rq *rq = cpu_rq(cpu);
STR : 	unsigned long flags;
STR : 
STR : 	if (!raw_spin_trylock_irqsave(&rq->lock, flags))
STR : 		return;
STR : 	resched_task(cpu_curr(cpu));
STR : 	raw_spin_unlock_irqrestore(&rq->lock, flags);
STR : }
STR : 
STR : #ifdef CONFIG_SMP
STR : #ifdef CONFIG_NO_HZ_COMMON
STR : /*
STR :  * In the semi idle case, use the nearest busy cpu for migrating timers
STR :  * from an idle cpu.  This is good for power-savings.
STR :  *
STR :  * We don't do similar optimization for completely idle system, as
STR :  * selecting an idle cpu will add more delays to the timers than intended
STR :  * (as that cpu's timer base may not be uptodate wrt jiffies etc).
STR :  */
STR : int get_nohz_timer_target(void)
STR : {
STR : 	int cpu = smp_processor_id();
STR : 	int i;
STR : 	struct sched_domain *sd;
STR : 
STR : 	rcu_read_lock();
STR : 	for_each_domain(cpu, sd) {
STR : 		for_each_cpu(i, sched_domain_span(sd)) {
STR : 			if (!idle_cpu(i)) {
STR : 				cpu = i;
STR : 				goto unlock;
STR : 			}
STR : 		}
STR : 	}
STR : unlock:
STR : 	rcu_read_unlock();
STR : 	return cpu;
STR : }
STR : /*
STR :  * When add_timer_on() enqueues a timer into the timer wheel of an
STR :  * idle CPU then this timer might expire before the next timer event
STR :  * which is scheduled to wake up that CPU. In case of a completely
STR :  * idle system the next event might even be infinite time into the
STR :  * future. wake_up_idle_cpu() ensures that the CPU is woken up and
STR :  * leaves the inner idle loop so the newly added timer is taken into
STR :  * account when the CPU goes back to idle and evaluates the timer
STR :  * wheel for the next timer event.
STR :  */
STR : static void wake_up_idle_cpu(int cpu)
STR : {
STR : 	struct rq *rq = cpu_rq(cpu);
STR : 
STR : 	if (cpu == smp_processor_id())
STR : 		return;
STR : 
STR : 	/*
STR : 	 * This is safe, as this function is called with the timer
STR : 	 * wheel base lock of (cpu) held. When the CPU is on the way
STR : 	 * to idle and has not yet set rq->curr to idle then it will
STR : 	 * be serialized on the timer wheel base lock and take the new
STR : 	 * timer into account automatically.
STR : 	 */
STR : 	if (rq->curr != rq->idle)
STR : 		return;
STR : 
STR : 	/*
STR : 	 * We can set TIF_RESCHED on the idle task of the other CPU
STR : 	 * lockless. The worst case is that the other CPU runs the
STR : 	 * idle task through an additional NOOP schedule()
STR : 	 */
STR : 	set_tsk_need_resched(rq->idle);
STR : 
STR : 	/* NEED_RESCHED must be visible before we test polling */
STR : 	smp_mb();
STR : 	if (!tsk_is_polling(rq->idle))
STR : 		smp_send_reschedule(cpu);
STR : }
STR : 
STR : static bool wake_up_full_nohz_cpu(int cpu)
STR : {
STR : 	if (tick_nohz_full_cpu(cpu)) {
STR : 		if (cpu != smp_processor_id() ||
STR : 		    tick_nohz_tick_stopped())
STR : 			smp_send_reschedule(cpu);
STR : 		return true;
STR : 	}
STR : 
STR : 	return false;
STR : }
STR : 
STR : void wake_up_nohz_cpu(int cpu)
STR : {
STR : 	if (!wake_up_full_nohz_cpu(cpu))
STR : 		wake_up_idle_cpu(cpu);
STR : }
STR : 
STR : static inline bool got_nohz_idle_kick(void)
STR : {
STR : 	int cpu = smp_processor_id();
STR : 
STR : 	if (!test_bit(NOHZ_BALANCE_KICK, nohz_flags(cpu)))
STR : 		return false;
STR : 
STR : 	if (idle_cpu(cpu) && !need_resched())
STR : 		return true;
STR : 
STR : 	/*
STR : 	 * We can't run Idle Load Balance on this CPU for this time so we
STR : 	 * cancel it and clear NOHZ_BALANCE_KICK
STR : 	 */
STR : 	clear_bit(NOHZ_BALANCE_KICK, nohz_flags(cpu));
STR : 	return false;
STR : }
STR : 
STR : #else /* CONFIG_NO_HZ_COMMON */
STR : 
STR : static inline bool got_nohz_idle_kick(void)
STR : {
STR : 	return false;
STR : }
STR : 
STR : #endif /* CONFIG_NO_HZ_COMMON */
STR : 
STR : #ifdef CONFIG_NO_HZ_FULL
STR : bool sched_can_stop_tick(void)
STR : {
STR :        struct rq *rq;
STR : 
STR :        rq = this_rq();
STR : 
STR :        /* Make sure rq->nr_running update is visible after the IPI */
STR :        smp_rmb();
STR : 
STR :        /* More than one running task need preemption */
STR :        if (rq->nr_running > 1)
STR :                return false;
STR : 
STR :        return true;
STR : }
STR : #endif /* CONFIG_NO_HZ_FULL */
STR : 
STR : void sched_avg_update(struct rq *rq)
STR : {
STR : 	s64 period = sched_avg_period();
STR : 
STR : 	while ((s64)(rq_clock(rq) - rq->age_stamp) > period) {
STR : 		/*
STR : 		 * Inline assembly required to prevent the compiler
STR : 		 * optimising this loop into a divmod call.
STR : 		 * See __iter_div_u64_rem() for another example of this.
STR : 		 */
STR : 		asm("" : "+rm" (rq->age_stamp));
STR : 		rq->age_stamp += period;
STR : 		rq->rt_avg /= 2;
STR : 	}
STR : }
STR : 
STR : #endif /* CONFIG_SMP */
STR : 
STR : #if defined(CONFIG_RT_GROUP_SCHED) || (defined(CONFIG_FAIR_GROUP_SCHED) && \
STR : 			(defined(CONFIG_SMP) || defined(CONFIG_CFS_BANDWIDTH)))
STR : /*
STR :  * Iterate task_group tree rooted at *from, calling @down when first entering a
STR :  * node and @up when leaving it for the final time.
STR :  *
STR :  * Caller must hold rcu_lock or sufficient equivalent.
STR :  */
STR : int walk_tg_tree_from(struct task_group *from,
STR : 			     tg_visitor down, tg_visitor up, void *data)
STR : {
STR : 	struct task_group *parent, *child;
STR : 	int ret;
STR : 
STR : 	parent = from;
STR : 
STR : down:
STR : 	ret = (*down)(parent, data);
STR : 	if (ret)
STR : 		goto out;
STR : 	list_for_each_entry_rcu(child, &parent->children, siblings) {
STR : 		parent = child;
STR : 		goto down;
STR : 
STR : up:
STR : 		continue;
STR : 	}
STR : 	ret = (*up)(parent, data);
STR : 	if (ret || parent == from)
STR : 		goto out;
STR : 
STR : 	child = parent;
STR : 	parent = parent->parent;
STR : 	if (parent)
STR : 		goto up;
STR : out:
STR : 	return ret;
STR : }
STR : 
STR : int tg_nop(struct task_group *tg, void *data)
STR : {
STR : 	return 0;
STR : }
STR : #endif
STR : 
STR : static void set_load_weight(struct task_struct *p)
STR : {
STR : 	int prio = p->static_prio - MAX_RT_PRIO;
STR : 	struct load_weight *load = &p->se.load;
STR : 
STR : 	/*
STR : 	 * SCHED_IDLE tasks get minimal weight:
STR : 	 */
STR : 	if (p->policy == SCHED_IDLE) {
STR : 		load->weight = scale_load(WEIGHT_IDLEPRIO);
STR : 		load->inv_weight = WMULT_IDLEPRIO;
STR : 		return;
STR : 	}
STR : 
STR : 	load->weight = scale_load(prio_to_weight[prio]);
STR : 	load->inv_weight = prio_to_wmult[prio];
STR : }
STR : 
STR : static void enqueue_task(struct rq *rq, struct task_struct *p, int flags)
STR : {
STR : 	update_rq_clock(rq);
STR : 	sched_info_queued(rq, p);
STR : 	p->sched_class->enqueue_task(rq, p, flags);
STR : }
STR : 
STR : static void dequeue_task(struct rq *rq, struct task_struct *p, int flags)
STR : {
STR : 	update_rq_clock(rq);
STR : 	sched_info_dequeued(rq, p);
STR : 	p->sched_class->dequeue_task(rq, p, flags);
STR : }
STR : 
STR : void activate_task(struct rq *rq, struct task_struct *p, int flags)
STR : {
STR : 	if (task_contributes_to_load(p))
STR : 		rq->nr_uninterruptible--;
STR : 
STR : 	enqueue_task(rq, p, flags);
STR : }
STR : 
STR : void deactivate_task(struct rq *rq, struct task_struct *p, int flags)
STR : {
STR : 	if (task_contributes_to_load(p))
STR : 		rq->nr_uninterruptible++;
STR : 
STR : 	dequeue_task(rq, p, flags);
STR : }
STR : 
STR : static void update_rq_clock_task(struct rq *rq, s64 delta)
STR : {
STR : /*
STR :  * In theory, the compile should just see 0 here, and optimize out the call
STR :  * to sched_rt_avg_update. But I don't trust it...
STR :  */
STR : #if defined(CONFIG_IRQ_TIME_ACCOUNTING) || defined(CONFIG_PARAVIRT_TIME_ACCOUNTING)
STR : 	s64 steal = 0, irq_delta = 0;
STR : #endif
STR : #ifdef CONFIG_IRQ_TIME_ACCOUNTING
STR : 	irq_delta = irq_time_read(cpu_of(rq)) - rq->prev_irq_time;
STR : 
STR : 	/*
STR : 	 * Since irq_time is only updated on {soft,}irq_exit, we might run into
STR : 	 * this case when a previous update_rq_clock() happened inside a
STR : 	 * {soft,}irq region.
STR : 	 *
STR : 	 * When this happens, we stop ->clock_task and only update the
STR : 	 * prev_irq_time stamp to account for the part that fit, so that a next
STR : 	 * update will consume the rest. This ensures ->clock_task is
STR : 	 * monotonic.
STR : 	 *
STR : 	 * It does however cause some slight miss-attribution of {soft,}irq
STR : 	 * time, a more accurate solution would be to update the irq_time using
STR : 	 * the current rq->clock timestamp, except that would require using
STR : 	 * atomic ops.
STR : 	 */
STR : 	if (irq_delta > delta)
STR : 		irq_delta = delta;
STR : 
STR : 	rq->prev_irq_time += irq_delta;
STR : 	delta -= irq_delta;
STR : #endif
STR : #ifdef CONFIG_PARAVIRT_TIME_ACCOUNTING
STR : 	if (static_key_false((&paravirt_steal_rq_enabled))) {
STR : 		u64 st;
STR : 
STR : 		steal = paravirt_steal_clock(cpu_of(rq));
STR : 		steal -= rq->prev_steal_time_rq;
STR : 
STR : 		if (unlikely(steal > delta))
STR : 			steal = delta;
STR : 
STR : 		st = steal_ticks(steal);
STR : 		steal = st * TICK_NSEC;
STR : 
STR : 		rq->prev_steal_time_rq += steal;
STR : 
STR : 		delta -= steal;
STR : 	}
STR : #endif
STR : 
STR : 	rq->clock_task += delta;
STR : 
STR : #if defined(CONFIG_IRQ_TIME_ACCOUNTING) || defined(CONFIG_PARAVIRT_TIME_ACCOUNTING)
STR : 	if ((irq_delta + steal) && sched_feat(NONTASK_POWER))
STR : 		sched_rt_avg_update(rq, irq_delta + steal);
STR : #endif
STR : }
STR : 
STR : void sched_set_stop_task(int cpu, struct task_struct *stop)
STR : {
STR : 	struct sched_param param = { .sched_priority = MAX_RT_PRIO - 1 };
STR : 	struct task_struct *old_stop = cpu_rq(cpu)->stop;
STR : 
STR : 	if (stop) {
STR : 		/*
STR : 		 * Make it appear like a SCHED_FIFO task, its something
STR : 		 * userspace knows about and won't get confused about.
STR : 		 *
STR : 		 * Also, it will make PI more or less work without too
STR : 		 * much confusion -- but then, stop work should not
STR : 		 * rely on PI working anyway.
STR : 		 */
STR : 		sched_setscheduler_nocheck(stop, SCHED_FIFO, &param);
STR : 
STR : 		stop->sched_class = &stop_sched_class;
STR : 	}
STR : 
STR : 	cpu_rq(cpu)->stop = stop;
STR : 
STR : 	if (old_stop) {
STR : 		/*
STR : 		 * Reset it back to a normal scheduling class so that
STR : 		 * it can die in pieces.
STR : 		 */
STR : 		old_stop->sched_class = &rt_sched_class;
STR : 	}
STR : }
STR : 
STR : /*
STR :  * __normal_prio - return the priority that is based on the static prio
STR :  */
STR : static inline int __normal_prio(struct task_struct *p)
STR : {
STR : 	return p->static_prio;
STR : }
STR : 
STR : /*
STR :  * Calculate the expected normal priority: i.e. priority
STR :  * without taking RT-inheritance into account. Might be
STR :  * boosted by interactivity modifiers. Changes upon fork,
STR :  * setprio syscalls, and whenever the interactivity
STR :  * estimator recalculates.
STR :  */
STR : static inline int normal_prio(struct task_struct *p)
STR : {
STR : 	int prio;
STR : 
STR : 	if (task_has_dl_policy(p))
STR : 		prio = MAX_DL_PRIO-1;
STR : 	else if (task_has_rt_policy(p))
STR : 		prio = MAX_RT_PRIO-1 - p->rt_priority;
STR : 	else
STR : 		prio = __normal_prio(p);
STR : 	return prio;
STR : }
STR : 
STR : /*
STR :  * Calculate the current priority, i.e. the priority
STR :  * taken into account by the scheduler. This value might
STR :  * be boosted by RT tasks, or might be boosted by
STR :  * interactivity modifiers. Will be RT if the task got
STR :  * RT-boosted. If not then it returns p->normal_prio.
STR :  */
STR : static int effective_prio(struct task_struct *p)
STR : {
STR : 	p->normal_prio = normal_prio(p);
STR : 	/*
STR : 	 * If we are RT tasks or we were boosted to RT priority,
STR : 	 * keep the priority unchanged. Otherwise, update priority
STR : 	 * to the normal priority:
STR : 	 */
STR : 	if (!rt_prio(p->prio))
STR : 		return p->normal_prio;
STR : 	return p->prio;
STR : }
STR : 
STR : /**
STR :  * task_curr - is this task currently executing on a CPU?
STR :  * @p: the task in question.
STR :  *
STR :  * Return: 1 if the task is currently executing. 0 otherwise.
STR :  */
STR : inline int task_curr(const struct task_struct *p)
STR : {
STR : 	return cpu_curr(task_cpu(p)) == p;
STR : }
STR : 
STR : static inline void check_class_changed(struct rq *rq, struct task_struct *p,
STR : 				       const struct sched_class *prev_class,
STR : 				       int oldprio)
STR : {
STR : 	if (prev_class != p->sched_class) {
STR : 		if (prev_class->switched_from)
STR : 			prev_class->switched_from(rq, p);
STR : 		p->sched_class->switched_to(rq, p);
STR : 	} else if (oldprio != p->prio || dl_task(p))
STR : 		p->sched_class->prio_changed(rq, p, oldprio);
STR : }
STR : 
STR : void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags)
STR : {
STR : 	const struct sched_class *class;
STR : 
STR : 	if (p->sched_class == rq->curr->sched_class) {
STR : 		rq->curr->sched_class->check_preempt_curr(rq, p, flags);
STR : 	} else {
STR : 		for_each_class(class) {
STR : 			if (class == rq->curr->sched_class)
STR : 				break;
STR : 			if (class == p->sched_class) {
STR : 				resched_task(rq->curr);
STR : 				break;
STR : 			}
STR : 		}
STR : 	}
STR : 
STR : 	/*
STR : 	 * A queue event has occurred, and we're going to schedule.  In
STR : 	 * this case, we can save a useless back to back clock update.
STR : 	 */
STR : 	if (rq->curr->on_rq && test_tsk_need_resched(rq->curr))
STR : 		rq->skip_clock_update = 1;
STR : }
STR : 
STR : #ifdef CONFIG_SMP
STR : void set_task_cpu(struct task_struct *p, unsigned int new_cpu)
STR : {
STR : #ifdef CONFIG_SCHED_DEBUG
STR : 	/*
STR : 	 * We should never call set_task_cpu() on a blocked task,
STR : 	 * ttwu() will sort out the placement.
STR : 	 */
STR : 	WARN_ON_ONCE(p->state != TASK_RUNNING && p->state != TASK_WAKING &&
STR : 			!(task_preempt_count(p) & PREEMPT_ACTIVE));
STR : 
STR : #ifdef CONFIG_LOCKDEP
STR : 	/*
STR : 	 * The caller should hold either p->pi_lock or rq->lock, when changing
STR : 	 * a task's CPU. ->pi_lock for waking tasks, rq->lock for runnable tasks.
STR : 	 *
STR : 	 * sched_move_task() holds both and thus holding either pins the cgroup,
STR : 	 * see task_group().
STR : 	 *
STR : 	 * Furthermore, all task_rq users should acquire both locks, see
STR : 	 * task_rq_lock().
STR : 	 */
STR : 	WARN_ON_ONCE(debug_locks && !(lockdep_is_held(&p->pi_lock) ||
STR : 				      lockdep_is_held(&task_rq(p)->lock)));
STR : #endif
STR : #endif
STR : 
STR : 	trace_sched_migrate_task(p, new_cpu);
STR : 
STR : 	if (task_cpu(p) != new_cpu) {
STR : 		if (p->sched_class->migrate_task_rq)
STR : 			p->sched_class->migrate_task_rq(p, new_cpu);
STR : 		p->se.nr_migrations++;
STR : 		perf_sw_event(PERF_COUNT_SW_CPU_MIGRATIONS, 1, NULL, 0);
STR : 	}
STR : 
STR : 	__set_task_cpu(p, new_cpu);
STR : }
STR : 
STR : static void __migrate_swap_task(struct task_struct *p, int cpu)
STR : {
STR : 	if (p->on_rq) {
STR : 		struct rq *src_rq, *dst_rq;
STR : 
STR : 		src_rq = task_rq(p);
STR : 		dst_rq = cpu_rq(cpu);
STR : 
STR : 		deactivate_task(src_rq, p, 0);
STR : 		set_task_cpu(p, cpu);
STR : 		activate_task(dst_rq, p, 0);
STR : 		check_preempt_curr(dst_rq, p, 0);
STR : 	} else {
STR : 		/*
STR : 		 * Task isn't running anymore; make it appear like we migrated
STR : 		 * it before it went to sleep. This means on wakeup we make the
STR : 		 * previous cpu our targer instead of where it really is.
STR : 		 */
STR : 		p->wake_cpu = cpu;
STR : 	}
STR : }
STR : 
STR : struct migration_swap_arg {
STR : 	struct task_struct *src_task, *dst_task;
STR : 	int src_cpu, dst_cpu;
STR : };
STR : 
STR : static int migrate_swap_stop(void *data)
STR : {
STR : 	struct migration_swap_arg *arg = data;
STR : 	struct rq *src_rq, *dst_rq;
STR : 	int ret = -EAGAIN;
STR : 
STR : 	src_rq = cpu_rq(arg->src_cpu);
STR : 	dst_rq = cpu_rq(arg->dst_cpu);
STR : 
STR : 	double_raw_lock(&arg->src_task->pi_lock,
STR : 			&arg->dst_task->pi_lock);
STR : 	double_rq_lock(src_rq, dst_rq);
STR : 	if (task_cpu(arg->dst_task) != arg->dst_cpu)
STR : 		goto unlock;
STR : 
STR : 	if (task_cpu(arg->src_task) != arg->src_cpu)
STR : 		goto unlock;
STR : 
STR : 	if (!cpumask_test_cpu(arg->dst_cpu, tsk_cpus_allowed(arg->src_task)))
STR : 		goto unlock;
STR : 
STR : 	if (!cpumask_test_cpu(arg->src_cpu, tsk_cpus_allowed(arg->dst_task)))
STR : 		goto unlock;
STR : 
STR : 	__migrate_swap_task(arg->src_task, arg->dst_cpu);
STR : 	__migrate_swap_task(arg->dst_task, arg->src_cpu);
STR : 
STR : 	ret = 0;
STR : 
STR : unlock:
STR : 	double_rq_unlock(src_rq, dst_rq);
STR : 	raw_spin_unlock(&arg->dst_task->pi_lock);
STR : 	raw_spin_unlock(&arg->src_task->pi_lock);
STR : 
STR : 	return ret;
STR : }
STR : 
STR : /*
STR :  * Cross migrate two tasks
STR :  */
STR : int migrate_swap(struct task_struct *cur, struct task_struct *p)
STR : {
STR : 	struct migration_swap_arg arg;
STR : 	int ret = -EINVAL;
STR : 
STR : 	arg = (struct migration_swap_arg){
STR : 		.src_task = cur,
STR : 		.src_cpu = task_cpu(cur),
STR : 		.dst_task = p,
STR : 		.dst_cpu = task_cpu(p),
STR : 	};
STR : 
STR : 	if (arg.src_cpu == arg.dst_cpu)
STR : 		goto out;
STR : 
STR : 	/*
STR : 	 * These three tests are all lockless; this is OK since all of them
STR : 	 * will be re-checked with proper locks held further down the line.
STR : 	 */
STR : 	if (!cpu_active(arg.src_cpu) || !cpu_active(arg.dst_cpu))
STR : 		goto out;
STR : 
STR : 	if (!cpumask_test_cpu(arg.dst_cpu, tsk_cpus_allowed(arg.src_task)))
STR : 		goto out;
STR : 
STR : 	if (!cpumask_test_cpu(arg.src_cpu, tsk_cpus_allowed(arg.dst_task)))
STR : 		goto out;
STR : 
STR : 	trace_sched_swap_numa(cur, arg.src_cpu, p, arg.dst_cpu);
STR : 	ret = stop_two_cpus(arg.dst_cpu, arg.src_cpu, migrate_swap_stop, &arg);
STR : 
STR : out:
STR : 	return ret;
STR : }
STR : 
STR : struct migration_arg {
STR : 	struct task_struct *task;
STR : 	int dest_cpu;
STR : };
STR : 
STR : static int migration_cpu_stop(void *data);
STR : 
STR : /*
STR :  * wait_task_inactive - wait for a thread to unschedule.
STR :  *
STR :  * If @match_state is nonzero, it's the @p->state value just checked and
STR :  * not expected to change.  If it changes, i.e. @p might have woken up,
STR :  * then return zero.  When we succeed in waiting for @p to be off its CPU,
STR :  * we return a positive number (its total switch count).  If a second call
STR :  * a short while later returns the same number, the caller can be sure that
STR :  * @p has remained unscheduled the whole time.
STR :  *
STR :  * The caller must ensure that the task *will* unschedule sometime soon,
STR :  * else this function might spin for a *long* time. This function can't
STR :  * be called with interrupts off, or it may introduce deadlock with
STR :  * smp_call_function() if an IPI is sent by the same process we are
STR :  * waiting to become inactive.
STR :  */
STR : unsigned long wait_task_inactive(struct task_struct *p, long match_state)
STR : {
STR : 	unsigned long flags;
STR : 	int running, on_rq;
STR : 	unsigned long ncsw;
STR : 	struct rq *rq;
STR : 
STR : 	for (;;) {
STR : 		/*
STR : 		 * We do the initial early heuristics without holding
STR : 		 * any task-queue locks at all. We'll only try to get
STR : 		 * the runqueue lock when things look like they will
STR : 		 * work out!
STR : 		 */
STR : 		rq = task_rq(p);
STR : 
STR : 		/*
STR : 		 * If the task is actively running on another CPU
STR : 		 * still, just relax and busy-wait without holding
STR : 		 * any locks.
STR : 		 *
STR : 		 * NOTE! Since we don't hold any locks, it's not
STR : 		 * even sure that "rq" stays as the right runqueue!
STR : 		 * But we don't care, since "task_running()" will
STR : 		 * return false if the runqueue has changed and p
STR : 		 * is actually now running somewhere else!
STR : 		 */
STR : 		while (task_running(rq, p)) {
STR : 			if (match_state && unlikely(p->state != match_state))
STR : 				return 0;
STR : 			cpu_relax();
STR : 		}
STR : 
STR : 		/*
STR : 		 * Ok, time to look more closely! We need the rq
STR : 		 * lock now, to be *sure*. If we're wrong, we'll
STR : 		 * just go back and repeat.
STR : 		 */
STR : 		rq = task_rq_lock(p, &flags);
STR : 		trace_sched_wait_task(p);
STR : 		running = task_running(rq, p);
STR : 		on_rq = p->on_rq;
STR : 		ncsw = 0;
STR : 		if (!match_state || p->state == match_state)
STR : 			ncsw = p->nvcsw | LONG_MIN; /* sets MSB */
STR : 		task_rq_unlock(rq, p, &flags);
STR : 
STR : 		/*
STR : 		 * If it changed from the expected state, bail out now.
STR : 		 */
STR : 		if (unlikely(!ncsw))
STR : 			break;
STR : 
STR : 		/*
STR : 		 * Was it really running after all now that we
STR : 		 * checked with the proper locks actually held?
STR : 		 *
STR : 		 * Oops. Go back and try again..
STR : 		 */
STR : 		if (unlikely(running)) {
STR : 			cpu_relax();
STR : 			continue;
STR : 		}
STR : 
STR : 		/*
STR : 		 * It's not enough that it's not actively running,
STR : 		 * it must be off the runqueue _entirely_, and not
STR : 		 * preempted!
STR : 		 *
STR : 		 * So if it was still runnable (but just not actively
STR : 		 * running right now), it's preempted, and we should
STR : 		 * yield - it could be a while.
STR : 		 */
STR : 		if (unlikely(on_rq)) {
STR : 			ktime_t to = ktime_set(0, NSEC_PER_SEC/HZ);
STR : 
STR : 			set_current_state(TASK_UNINTERRUPTIBLE);
STR : 			schedule_hrtimeout(&to, HRTIMER_MODE_REL);
STR : 			continue;
STR : 		}
STR : 
STR : 		/*
STR : 		 * Ahh, all good. It wasn't running, and it wasn't
STR : 		 * runnable, which means that it will never become
STR : 		 * running in the future either. We're all done!
STR : 		 */
STR : 		break;
STR : 	}
STR : 
STR : 	return ncsw;
STR : }
STR : 
STR : /***
STR :  * kick_process - kick a running thread to enter/exit the kernel
STR :  * @p: the to-be-kicked thread
STR :  *
STR :  * Cause a process which is running on another CPU to enter
STR :  * kernel-mode, without any delay. (to get signals handled.)
STR :  *
STR :  * NOTE: this function doesn't have to take the runqueue lock,
STR :  * because all it wants to ensure is that the remote task enters
STR :  * the kernel. If the IPI races and the task has been migrated
STR :  * to another CPU then no harm is done and the purpose has been
STR :  * achieved as well.
STR :  */
STR : void kick_process(struct task_struct *p)
STR : {
STR : 	int cpu;
STR : 
STR : 	preempt_disable();
STR : 	cpu = task_cpu(p);
STR : 	if ((cpu != smp_processor_id()) && task_curr(p))
STR : 		smp_send_reschedule(cpu);
STR : 	preempt_enable();
STR : }
STR : EXPORT_SYMBOL_GPL(kick_process);
STR : #endif /* CONFIG_SMP */
STR : 
STR : #ifdef CONFIG_SMP
STR : /*
STR :  * ->cpus_allowed is protected by both rq->lock and p->pi_lock
STR :  */
STR : static int select_fallback_rq(int cpu, struct task_struct *p)
STR : {
STR : 	int nid = cpu_to_node(cpu);
STR : 	const struct cpumask *nodemask = NULL;
STR : 	enum { cpuset, possible, fail } state = cpuset;
STR : 	int dest_cpu;
STR : 
STR : 	/*
STR : 	 * If the node that the cpu is on has been offlined, cpu_to_node()
STR : 	 * will return -1. There is no cpu on the node, and we should
STR : 	 * select the cpu on the other node.
STR : 	 */
STR : 	if (nid != -1) {
STR : 		nodemask = cpumask_of_node(nid);
STR : 
STR : 		/* Look for allowed, online CPU in same node. */
STR : 		for_each_cpu(dest_cpu, nodemask) {
STR : 			if (!cpu_online(dest_cpu))
STR : 				continue;
STR : 			if (!cpu_active(dest_cpu))
STR : 				continue;
STR : 			if (cpumask_test_cpu(dest_cpu, tsk_cpus_allowed(p)))
STR : 				return dest_cpu;
STR : 		}
STR : 	}
STR : 
STR : 	for (;;) {
STR : 		/* Any allowed, online CPU? */
STR : 		for_each_cpu(dest_cpu, tsk_cpus_allowed(p)) {
STR : 			if (!cpu_online(dest_cpu))
STR : 				continue;
STR : 			if (!cpu_active(dest_cpu))
STR : 				continue;
STR : 			goto out;
STR : 		}
STR : 
STR : 		switch (state) {
STR : 		case cpuset:
STR : 			/* No more Mr. Nice Guy. */
STR : 			cpuset_cpus_allowed_fallback(p);
STR : 			state = possible;
STR : 			break;
STR : 
STR : 		case possible:
STR : 			do_set_cpus_allowed(p, cpu_possible_mask);
STR : 			state = fail;
STR : 			break;
STR : 
STR : 		case fail:
STR : 			BUG();
STR : 			break;
STR : 		}
STR : 	}
STR : 
STR : out:
STR : 	if (state != cpuset) {
STR : 		/*
STR : 		 * Don't tell them about moving exiting tasks or
STR : 		 * kernel threads (both mm NULL), since they never
STR : 		 * leave kernel.
STR : 		 */
STR : 		if (p->mm && printk_ratelimit()) {
STR : 			printk_sched("process %d (%s) no longer affine to cpu%d\n",
STR : 					task_pid_nr(p), p->comm, cpu);
STR : 		}
STR : 	}
STR : 
STR : 	return dest_cpu;
STR : }
STR : 
STR : /*
STR :  * The caller (fork, wakeup) owns p->pi_lock, ->cpus_allowed is stable.
STR :  */
STR : static inline
STR : int select_task_rq(struct task_struct *p, int cpu, int sd_flags, int wake_flags)
STR : {
STR : 	cpu = p->sched_class->select_task_rq(p, cpu, sd_flags, wake_flags);
STR : 
STR : 	/*
STR : 	 * In order not to call set_task_cpu() on a blocking task we need
STR : 	 * to rely on ttwu() to place the task on a valid ->cpus_allowed
STR : 	 * cpu.
STR : 	 *
STR : 	 * Since this is common to all placement strategies, this lives here.
STR : 	 *
STR : 	 * [ this allows ->select_task() to simply return task_cpu(p) and
STR : 	 *   not worry about this generic constraint ]
STR : 	 */
STR : 	if (unlikely(!cpumask_test_cpu(cpu, tsk_cpus_allowed(p)) ||
STR : 		     !cpu_online(cpu)))
STR : 		cpu = select_fallback_rq(task_cpu(p), p);
STR : 
STR : 	return cpu;
STR : }
STR : 
STR : static void update_avg(u64 *avg, u64 sample)
STR : {
STR : 	s64 diff = sample - *avg;
STR : 	*avg += diff >> 3;
STR : }
STR : #endif
STR : 
STR : static void
STR : ttwu_stat(struct task_struct *p, int cpu, int wake_flags)
STR : {
STR : #ifdef CONFIG_SCHEDSTATS
STR : 	struct rq *rq = this_rq();
STR : 
STR : #ifdef CONFIG_SMP
STR : 	int this_cpu = smp_processor_id();
STR : 
STR : 	if (cpu == this_cpu) {
STR : 		schedstat_inc(rq, ttwu_local);
STR : 		schedstat_inc(p, se.statistics.nr_wakeups_local);
STR : 	} else {
STR : 		struct sched_domain *sd;
STR : 
STR : 		schedstat_inc(p, se.statistics.nr_wakeups_remote);
STR : 		rcu_read_lock();
STR : 		for_each_domain(this_cpu, sd) {
STR : 			if (cpumask_test_cpu(cpu, sched_domain_span(sd))) {
STR : 				schedstat_inc(sd, ttwu_wake_remote);
STR : 				break;
STR : 			}
STR : 		}
STR : 		rcu_read_unlock();
STR : 	}
STR : 
STR : 	if (wake_flags & WF_MIGRATED)
STR : 		schedstat_inc(p, se.statistics.nr_wakeups_migrate);
STR : 
STR : #endif /* CONFIG_SMP */
STR : 
STR : 	schedstat_inc(rq, ttwu_count);
STR : 	schedstat_inc(p, se.statistics.nr_wakeups);
STR : 
STR : 	if (wake_flags & WF_SYNC)
STR : 		schedstat_inc(p, se.statistics.nr_wakeups_sync);
STR : 
STR : #endif /* CONFIG_SCHEDSTATS */
STR : }
STR : 
STR : static void ttwu_activate(struct rq *rq, struct task_struct *p, int en_flags)
STR : {
STR : 	activate_task(rq, p, en_flags);
STR : 	p->on_rq = 1;
STR : 
STR : 	/* if a worker is waking up, notify workqueue */
STR : 	if (p->flags & PF_WQ_WORKER)
STR : 		wq_worker_waking_up(p, cpu_of(rq));
STR : }
STR : 
STR : /*
STR :  * Mark the task runnable and perform wakeup-preemption.
STR :  */
STR : static void
STR : ttwu_do_wakeup(struct rq *rq, struct task_struct *p, int wake_flags)
STR : {
STR : 	check_preempt_curr(rq, p, wake_flags);
STR : 	trace_sched_wakeup(p, true);
STR : 
STR : 	p->state = TASK_RUNNING;
STR : #ifdef CONFIG_SMP
STR : 	if (p->sched_class->task_woken)
STR : 		p->sched_class->task_woken(rq, p);
STR : 
STR : 	if (rq->idle_stamp) {
STR : 		u64 delta = rq_clock(rq) - rq->idle_stamp;
STR : 		u64 max = 2*rq->max_idle_balance_cost;
STR : 
STR : 		update_avg(&rq->avg_idle, delta);
STR : 
STR : 		if (rq->avg_idle > max)
STR : 			rq->avg_idle = max;
STR : 
STR : 		rq->idle_stamp = 0;
STR : 	}
STR : #endif
STR : }
STR : 
STR : static void
STR : ttwu_do_activate(struct rq *rq, struct task_struct *p, int wake_flags)
STR : {
STR : #ifdef CONFIG_SMP
STR : 	if (p->sched_contributes_to_load)
STR : 		rq->nr_uninterruptible--;
STR : #endif
STR : 
STR : 	ttwu_activate(rq, p, ENQUEUE_WAKEUP | ENQUEUE_WAKING);
STR : 	ttwu_do_wakeup(rq, p, wake_flags);
STR : }
STR : 
STR : /*
STR :  * Called in case the task @p isn't fully descheduled from its runqueue,
STR :  * in this case we must do a remote wakeup. Its a 'light' wakeup though,
STR :  * since all we need to do is flip p->state to TASK_RUNNING, since
STR :  * the task is still ->on_rq.
STR :  */
STR : static int ttwu_remote(struct task_struct *p, int wake_flags)
STR : {
STR : 	struct rq *rq;
STR : 	int ret = 0;
STR : 
STR : 	rq = __task_rq_lock(p);
STR : 	if (p->on_rq) {
STR : 		/* check_preempt_curr() may use rq clock */
STR : 		update_rq_clock(rq);
STR : 		ttwu_do_wakeup(rq, p, wake_flags);
STR : 		ret = 1;
STR : 	}
STR : 	__task_rq_unlock(rq);
STR : 
STR : 	return ret;
STR : }
STR : 
STR : #ifdef CONFIG_SMP
STR : static void sched_ttwu_pending(void)
STR : {
STR : 	struct rq *rq = this_rq();
STR : 	struct llist_node *llist = llist_del_all(&rq->wake_list);
STR : 	struct task_struct *p;
STR : 
STR : 	raw_spin_lock(&rq->lock);
STR : 
STR : 	while (llist) {
STR : 		p = llist_entry(llist, struct task_struct, wake_entry);
STR : 		llist = llist_next(llist);
STR : 		ttwu_do_activate(rq, p, 0);
STR : 	}
STR : 
STR : 	raw_spin_unlock(&rq->lock);
STR : }
STR : 
STR : void scheduler_ipi(void)
STR : {
STR : 	/*
STR : 	 * Fold TIF_NEED_RESCHED into the preempt_count; anybody setting
STR : 	 * TIF_NEED_RESCHED remotely (for the first time) will also send
STR : 	 * this IPI.
STR : 	 */
STR : 	preempt_fold_need_resched();
STR : 
STR : 	if (llist_empty(&this_rq()->wake_list)
STR : 			&& !tick_nohz_full_cpu(smp_processor_id())
STR : 			&& !got_nohz_idle_kick())
STR : 		return;
STR : 
STR : 	/*
STR : 	 * Not all reschedule IPI handlers call irq_enter/irq_exit, since
STR : 	 * traditionally all their work was done from the interrupt return
STR : 	 * path. Now that we actually do some work, we need to make sure
STR : 	 * we do call them.
STR : 	 *
STR : 	 * Some archs already do call them, luckily irq_enter/exit nest
STR : 	 * properly.
STR : 	 *
STR : 	 * Arguably we should visit all archs and update all handlers,
STR : 	 * however a fair share of IPIs are still resched only so this would
STR : 	 * somewhat pessimize the simple resched case.
STR : 	 */
STR : 	irq_enter();
STR : 	tick_nohz_full_check();
STR : 	sched_ttwu_pending();
STR : 
STR : 	/*
STR : 	 * Check if someone kicked us for doing the nohz idle load balance.
STR : 	 */
STR : 	if (unlikely(got_nohz_idle_kick())) {
STR : 		this_rq()->idle_balance = 1;
STR : 		raise_softirq_irqoff(SCHED_SOFTIRQ);
STR : 	}
STR : 	irq_exit();
STR : }
STR : 
STR : static void ttwu_queue_remote(struct task_struct *p, int cpu)
STR : {
STR : 	if (llist_add(&p->wake_entry, &cpu_rq(cpu)->wake_list))
STR : 		smp_send_reschedule(cpu);
STR : }
STR : 
STR : bool cpus_share_cache(int this_cpu, int that_cpu)
STR : {
STR : 	return per_cpu(sd_llc_id, this_cpu) == per_cpu(sd_llc_id, that_cpu);
STR : }
STR : #endif /* CONFIG_SMP */
STR : 
STR : static void ttwu_queue(struct task_struct *p, int cpu)
STR : {
STR : 	struct rq *rq = cpu_rq(cpu);
STR : 
STR : #if defined(CONFIG_SMP)
STR : 	if (sched_feat(TTWU_QUEUE) && !cpus_share_cache(smp_processor_id(), cpu)) {
STR : 		sched_clock_cpu(cpu); /* sync clocks x-cpu */
STR : 		ttwu_queue_remote(p, cpu);
STR : 		return;
STR : 	}
STR : #endif
STR : 
STR : 	raw_spin_lock(&rq->lock);
STR : 	ttwu_do_activate(rq, p, 0);
STR : 	raw_spin_unlock(&rq->lock);
STR : }
STR : 
STR : /**
STR :  * try_to_wake_up - wake up a thread
STR :  * @p: the thread to be awakened
STR :  * @state: the mask of task states that can be woken
STR :  * @wake_flags: wake modifier flags (WF_*)
STR :  *
STR :  * Put it on the run-queue if it's not already there. The "current"
STR :  * thread is always on the run-queue (except when the actual
STR :  * re-schedule is in progress), and as such you're allowed to do
STR :  * the simpler "current->state = TASK_RUNNING" to mark yourself
STR :  * runnable without the overhead of this.
STR :  *
STR :  * Return: %true if @p was woken up, %false if it was already running.
STR :  * or @state didn't match @p's state.
STR :  */
STR : static int
STR : try_to_wake_up(struct task_struct *p, unsigned int state, int wake_flags)
STR : {
STR : 	unsigned long flags;
STR : 	int cpu, success = 0;
STR : 
STR : 	/*
STR : 	 * If we are going to wake up a thread waiting for CONDITION we
STR : 	 * need to ensure that CONDITION=1 done by the caller can not be
STR : 	 * reordered with p->state check below. This pairs with mb() in
STR : 	 * set_current_state() the waiting thread does.
STR : 	 */
STR : 	smp_mb__before_spinlock();
STR : 	raw_spin_lock_irqsave(&p->pi_lock, flags);
STR : 	if (!(p->state & state))
STR : 		goto out;
STR : 
STR : 	success = 1; /* we're going to change ->state */
STR : 	cpu = task_cpu(p);
STR : 
STR : 	if (p->on_rq && ttwu_remote(p, wake_flags))
STR : 		goto stat;
STR : 
STR : #ifdef CONFIG_SMP
STR : 	/*
STR : 	 * If the owning (remote) cpu is still in the middle of schedule() with
STR : 	 * this task as prev, wait until its done referencing the task.
STR : 	 */
STR : 	while (p->on_cpu)
STR : 		cpu_relax();
STR : 	/*
STR : 	 * Pairs with the smp_wmb() in finish_lock_switch().
STR : 	 */
STR : 	smp_rmb();
STR : 
STR : 	p->sched_contributes_to_load = !!task_contributes_to_load(p);
STR : 	p->state = TASK_WAKING;
STR : 
STR : 	if (p->sched_class->task_waking)
STR : 		p->sched_class->task_waking(p);
STR : 
STR : 	cpu = select_task_rq(p, p->wake_cpu, SD_BALANCE_WAKE, wake_flags);
STR : 	if (task_cpu(p) != cpu) {
STR : 		wake_flags |= WF_MIGRATED;
STR : 		set_task_cpu(p, cpu);
STR : 	}
STR : #endif /* CONFIG_SMP */
STR : 
STR : 	ttwu_queue(p, cpu);
STR : stat:
STR : 	ttwu_stat(p, cpu, wake_flags);
STR : out:
STR : 	raw_spin_unlock_irqrestore(&p->pi_lock, flags);
STR : 
STR : 	return success;
STR : }
STR : 
STR : /**
STR :  * try_to_wake_up_local - try to wake up a local task with rq lock held
STR :  * @p: the thread to be awakened
STR :  *
STR :  * Put @p on the run-queue if it's not already there. The caller must
STR :  * ensure that this_rq() is locked, @p is bound to this_rq() and not
STR :  * the current task.
STR :  */
STR : static void try_to_wake_up_local(struct task_struct *p)
STR : {
STR : 	struct rq *rq = task_rq(p);
STR : 
STR : 	if (WARN_ON_ONCE(rq != this_rq()) ||
STR : 	    WARN_ON_ONCE(p == current))
STR : 		return;
STR : 
STR : 	lockdep_assert_held(&rq->lock);
STR : 
STR : 	if (!raw_spin_trylock(&p->pi_lock)) {
STR : 		raw_spin_unlock(&rq->lock);
STR : 		raw_spin_lock(&p->pi_lock);
STR : 		raw_spin_lock(&rq->lock);
STR : 	}
STR : 
STR : 	if (!(p->state & TASK_NORMAL))
STR : 		goto out;
STR : 
STR : 	if (!p->on_rq)
STR : 		ttwu_activate(rq, p, ENQUEUE_WAKEUP);
STR : 
STR : 	ttwu_do_wakeup(rq, p, 0);
STR : 	ttwu_stat(p, smp_processor_id(), 0);
STR : out:
STR : 	raw_spin_unlock(&p->pi_lock);
STR : }
STR : 
STR : /**
STR :  * wake_up_process - Wake up a specific process
STR :  * @p: The process to be woken up.
STR :  *
STR :  * Attempt to wake up the nominated process and move it to the set of runnable
STR :  * processes.
STR :  *
STR :  * Return: 1 if the process was woken up, 0 if it was already running.
STR :  *
STR :  * It may be assumed that this function implies a write memory barrier before
STR :  * changing the task state if and only if any tasks are woken up.
STR :  */
STR : int wake_up_process(struct task_struct *p)
STR : {
STR : 	WARN_ON(task_is_stopped_or_traced(p));
STR : 	return try_to_wake_up(p, TASK_NORMAL, 0);
STR : }
STR : EXPORT_SYMBOL(wake_up_process);
STR : 
STR : int wake_up_state(struct task_struct *p, unsigned int state)
STR : {
STR : 	return try_to_wake_up(p, state, 0);
STR : }
STR : 
STR : /*
STR :  * Perform scheduler related setup for a newly forked process p.
STR :  * p is forked by current.
STR :  *
STR :  * __sched_fork() is basic setup used by init_idle() too:
STR :  */
STR : static void __sched_fork(unsigned long clone_flags, struct task_struct *p)
STR : {
STR : 	p->on_rq			= 0;
STR : 	p->se.on_rq			= 0;
STR : 	p->se.exec_start		= 0;
STR : 	p->se.sum_exec_runtime		= 0;
STR : 	p->se.prev_sum_exec_runtime	= 0;
STR : 	p->se.nr_migrations		= 0;
STR : 	p->se.vruntime			= 0;
STR : 	INIT_LIST_HEAD(&p->se.group_node);
STR : 
STR : #ifdef CONFIG_SCHEDSTATS
STR : 	memset(&p->se.statistics, 0, sizeof(p->se.statistics));
STR : #endif
STR : 
STR : 	RB_CLEAR_NODE(&p->dl.rb_node);
STR : 	hrtimer_init(&p->dl.dl_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
STR : 	p->dl.dl_runtime = p->dl.runtime = 0;
STR : 	p->dl.dl_deadline = p->dl.deadline = 0;
STR : 	p->dl.dl_period = 0;
STR : 	p->dl.flags = 0;
STR : 
STR : 	INIT_LIST_HEAD(&p->rt.run_list);
STR : 
STR : #ifdef CONFIG_PREEMPT_NOTIFIERS
STR : 	INIT_HLIST_HEAD(&p->preempt_notifiers);
STR : #endif
STR : 
STR : #ifdef CONFIG_NUMA_BALANCING
STR : 	if (p->mm && atomic_read(&p->mm->mm_users) == 1) {
STR : 		p->mm->numa_next_scan = jiffies + msecs_to_jiffies(sysctl_numa_balancing_scan_delay);
STR : 		p->mm->numa_scan_seq = 0;
STR : 	}
STR : 
STR : 	if (clone_flags & CLONE_VM)
STR : 		p->numa_preferred_nid = current->numa_preferred_nid;
STR : 	else
STR : 		p->numa_preferred_nid = -1;
STR : 
STR : 	p->node_stamp = 0ULL;
STR : 	p->numa_scan_seq = p->mm ? p->mm->numa_scan_seq : 0;
STR : 	p->numa_scan_period = sysctl_numa_balancing_scan_delay;
STR : 	p->numa_work.next = &p->numa_work;
STR : 	p->numa_faults = NULL;
STR : 	p->numa_faults_buffer = NULL;
STR : 
STR : 	INIT_LIST_HEAD(&p->numa_entry);
STR : 	p->numa_group = NULL;
STR : #endif /* CONFIG_NUMA_BALANCING */
STR : }
STR : 
STR : #ifdef CONFIG_NUMA_BALANCING
STR : #ifdef CONFIG_SCHED_DEBUG
STR : void set_numabalancing_state(bool enabled)
STR : {
STR : 	if (enabled)
STR : 		sched_feat_set("NUMA");
STR : 	else
STR : 		sched_feat_set("NO_NUMA");
STR : }
STR : #else
STR : __read_mostly bool numabalancing_enabled;
STR : 
STR : void set_numabalancing_state(bool enabled)
STR : {
STR : 	numabalancing_enabled = enabled;
STR : }
STR : #endif /* CONFIG_SCHED_DEBUG */
STR : 
STR : #ifdef CONFIG_PROC_SYSCTL
STR : int sysctl_numa_balancing(struct ctl_table *table, int write,
STR : 			 void __user *buffer, size_t *lenp, loff_t *ppos)
STR : {
STR : 	struct ctl_table t;
STR : 	int err;
STR : 	int state = numabalancing_enabled;
STR : 
STR : 	if (write && !capable(CAP_SYS_ADMIN))
STR : 		return -EPERM;
STR : 
STR : 	t = *table;
STR : 	t.data = &state;
STR : 	err = proc_dointvec_minmax(&t, write, buffer, lenp, ppos);
STR : 	if (err < 0)
STR : 		return err;
STR : 	if (write)
STR : 		set_numabalancing_state(state);
STR : 	return err;
STR : }
STR : #endif
STR : #endif
STR : 
STR : /*
STR :  * fork()/clone()-time setup:
STR :  */
STR : int sched_fork(unsigned long clone_flags, struct task_struct *p)
STR : {
STR : 	unsigned long flags;
STR : 	int cpu = get_cpu();
STR : 
STR : 	__sched_fork(clone_flags, p);
STR : 	/*
STR : 	 * We mark the process as running here. This guarantees that
STR : 	 * nobody will actually run it, and a signal or other external
STR : 	 * event cannot wake it up and insert it on the runqueue either.
STR : 	 */
STR : 	p->state = TASK_RUNNING;
STR : 
STR : 	/*
STR : 	 * Make sure we do not leak PI boosting priority to the child.
STR : 	 */
STR : 	p->prio = current->normal_prio;
STR : 
STR : 	/*
STR : 	 * Revert to default priority/policy on fork if requested.
STR : 	 */
STR : 	if (unlikely(p->sched_reset_on_fork)) {
STR : 		if (task_has_dl_policy(p) || task_has_rt_policy(p)) {
STR : 			p->policy = SCHED_NORMAL;
STR : 			p->static_prio = NICE_TO_PRIO(0);
STR : 			p->rt_priority = 0;
STR : 		} else if (PRIO_TO_NICE(p->static_prio) < 0)
STR : 			p->static_prio = NICE_TO_PRIO(0);
STR : 
STR : 		p->prio = p->normal_prio = __normal_prio(p);
STR : 		set_load_weight(p);
STR : 
STR : 		/*
STR : 		 * We don't need the reset flag anymore after the fork. It has
STR : 		 * fulfilled its duty:
STR : 		 */
STR : 		p->sched_reset_on_fork = 0;
STR : 	}
STR : 
STR : 	if (dl_prio(p->prio)) {
STR : 		put_cpu();
STR : 		return -EAGAIN;
STR : 	} else if (rt_prio(p->prio)) {
STR : 		p->sched_class = &rt_sched_class;
STR : 	} else {
STR : 		p->sched_class = &fair_sched_class;
STR : 	}
STR : 
STR : 	if (p->sched_class->task_fork)
STR : 		p->sched_class->task_fork(p);
STR : 
STR : 	/*
STR : 	 * The child is not yet in the pid-hash so no cgroup attach races,
STR : 	 * and the cgroup is pinned to this child due to cgroup_fork()
STR : 	 * is ran before sched_fork().
STR : 	 *
STR : 	 * Silence PROVE_RCU.
STR : 	 */
STR : 	raw_spin_lock_irqsave(&p->pi_lock, flags);
STR : 	set_task_cpu(p, cpu);
STR : 	raw_spin_unlock_irqrestore(&p->pi_lock, flags);
STR : 
STR : #if defined(CONFIG_SCHEDSTATS) || defined(CONFIG_TASK_DELAY_ACCT)
STR : 	if (likely(sched_info_on()))
STR : 		memset(&p->sched_info, 0, sizeof(p->sched_info));
STR : #endif
STR : #if defined(CONFIG_SMP)
STR : 	p->on_cpu = 0;
STR : #endif
STR : 	init_task_preempt_count(p);
STR : #ifdef CONFIG_SMP
STR : 	plist_node_init(&p->pushable_tasks, MAX_PRIO);
STR : 	RB_CLEAR_NODE(&p->pushable_dl_tasks);
STR : #endif
STR : 
STR : 	put_cpu();
STR : 	return 0;
STR : }
STR : 
STR : unsigned long to_ratio(u64 period, u64 runtime)
STR : {
STR : 	if (runtime == RUNTIME_INF)
STR : 		return 1ULL << 20;
STR : 
STR : 	/*
STR : 	 * Doing this here saves a lot of checks in all
STR : 	 * the calling paths, and returning zero seems
STR : 	 * safe for them anyway.
STR : 	 */
STR : 	if (period == 0)
STR : 		return 0;
STR : 
STR : 	return div64_u64(runtime << 20, period);
STR : }
STR : 
STR : #ifdef CONFIG_SMP
STR : inline struct dl_bw *dl_bw_of(int i)
STR : {
STR : 	return &cpu_rq(i)->rd->dl_bw;
STR : }
STR : 
STR : static inline int dl_bw_cpus(int i)
STR : {
STR : 	struct root_domain *rd = cpu_rq(i)->rd;
STR : 	int cpus = 0;
STR : 
STR : 	for_each_cpu_and(i, rd->span, cpu_active_mask)
STR : 		cpus++;
STR : 
STR : 	return cpus;
STR : }
STR : #else
STR : inline struct dl_bw *dl_bw_of(int i)
STR : {
STR : 	return &cpu_rq(i)->dl.dl_bw;
STR : }
STR : 
STR : static inline int dl_bw_cpus(int i)
STR : {
STR : 	return 1;
STR : }
STR : #endif
STR : 
STR : static inline
STR : void __dl_clear(struct dl_bw *dl_b, u64 tsk_bw)
STR : {
STR : 	dl_b->total_bw -= tsk_bw;
STR : }
STR : 
STR : static inline
STR : void __dl_add(struct dl_bw *dl_b, u64 tsk_bw)
STR : {
STR : 	dl_b->total_bw += tsk_bw;
STR : }
STR : 
STR : static inline
STR : bool __dl_overflow(struct dl_bw *dl_b, int cpus, u64 old_bw, u64 new_bw)
STR : {
STR : 	return dl_b->bw != -1 &&
STR : 	       dl_b->bw * cpus < dl_b->total_bw - old_bw + new_bw;
STR : }
STR : 
STR : /*
STR :  * We must be sure that accepting a new task (or allowing changing the
STR :  * parameters of an existing one) is consistent with the bandwidth
STR :  * constraints. If yes, this function also accordingly updates the currently
STR :  * allocated bandwidth to reflect the new situation.
STR :  *
STR :  * This function is called while holding p's rq->lock.
STR :  */
STR : static int dl_overflow(struct task_struct *p, int policy,
STR : 		       const struct sched_attr *attr)
STR : {
STR : 
STR : 	struct dl_bw *dl_b = dl_bw_of(task_cpu(p));
STR : 	u64 period = attr->sched_period ?: attr->sched_deadline;
STR : 	u64 runtime = attr->sched_runtime;
STR : 	u64 new_bw = dl_policy(policy) ? to_ratio(period, runtime) : 0;
STR : 	int cpus, err = -1;
STR : 
STR : 	if (new_bw == p->dl.dl_bw)
STR : 		return 0;
STR : 
STR : 	/*
STR : 	 * Either if a task, enters, leave, or stays -deadline but changes
STR : 	 * its parameters, we may need to update accordingly the total
STR : 	 * allocated bandwidth of the container.
STR : 	 */
STR : 	raw_spin_lock(&dl_b->lock);
STR : 	cpus = dl_bw_cpus(task_cpu(p));
STR : 	if (dl_policy(policy) && !task_has_dl_policy(p) &&
STR : 	    !__dl_overflow(dl_b, cpus, 0, new_bw)) {
STR : 		__dl_add(dl_b, new_bw);
STR : 		err = 0;
STR : 	} else if (dl_policy(policy) && task_has_dl_policy(p) &&
STR : 		   !__dl_overflow(dl_b, cpus, p->dl.dl_bw, new_bw)) {
STR : 		__dl_clear(dl_b, p->dl.dl_bw);
STR : 		__dl_add(dl_b, new_bw);
STR : 		err = 0;
STR : 	} else if (!dl_policy(policy) && task_has_dl_policy(p)) {
STR : 		__dl_clear(dl_b, p->dl.dl_bw);
STR : 		err = 0;
STR : 	}
STR : 	raw_spin_unlock(&dl_b->lock);
STR : 
STR : 	return err;
STR : }
STR : 
STR : extern void init_dl_bw(struct dl_bw *dl_b);
STR : 
STR : /*
STR :  * wake_up_new_task - wake up a newly created task for the first time.
STR :  *
STR :  * This function will do some initial scheduler statistics housekeeping
STR :  * that must be done for every newly created context, then puts the task
STR :  * on the runqueue and wakes it.
STR :  */
STR : void wake_up_new_task(struct task_struct *p)
STR : {
STR : 	unsigned long flags;
STR : 	struct rq *rq;
STR : 
STR : 	raw_spin_lock_irqsave(&p->pi_lock, flags);
STR : #ifdef CONFIG_SMP
STR : 	/*
STR : 	 * Fork balancing, do it here and not earlier because:
STR : 	 *  - cpus_allowed can change in the fork path
STR : 	 *  - any previously selected cpu might disappear through hotplug
STR : 	 */
STR : 	set_task_cpu(p, select_task_rq(p, task_cpu(p), SD_BALANCE_FORK, 0));
STR : #endif
STR : 
STR : 	/* Initialize new task's runnable average */
STR : 	init_task_runnable_average(p);
STR : 	rq = __task_rq_lock(p);
STR : 	activate_task(rq, p, 0);
STR : 	p->on_rq = 1;
STR : 	trace_sched_wakeup_new(p, true);
STR : 	check_preempt_curr(rq, p, WF_FORK);
STR : #ifdef CONFIG_SMP
STR : 	if (p->sched_class->task_woken)
STR : 		p->sched_class->task_woken(rq, p);
STR : #endif
STR : 	task_rq_unlock(rq, p, &flags);
STR : }
STR : 
STR : #ifdef CONFIG_PREEMPT_NOTIFIERS
STR : 
STR : /**
STR :  * preempt_notifier_register - tell me when current is being preempted & rescheduled
STR :  * @notifier: notifier struct to register
STR :  */
STR : void preempt_notifier_register(struct preempt_notifier *notifier)
STR : {
STR : 	hlist_add_head(&notifier->link, &current->preempt_notifiers);
STR : }
STR : EXPORT_SYMBOL_GPL(preempt_notifier_register);
STR : 
STR : /**
STR :  * preempt_notifier_unregister - no longer interested in preemption notifications
STR :  * @notifier: notifier struct to unregister
STR :  *
STR :  * This is safe to call from within a preemption notifier.
STR :  */
STR : void preempt_notifier_unregister(struct preempt_notifier *notifier)
STR : {
STR : 	hlist_del(&notifier->link);
STR : }
STR : EXPORT_SYMBOL_GPL(preempt_notifier_unregister);
STR : 
STR : static void fire_sched_in_preempt_notifiers(struct task_struct *curr)
STR : {
STR : 	struct preempt_notifier *notifier;
STR : 
STR : 	hlist_for_each_entry(notifier, &curr->preempt_notifiers, link)
STR : 		notifier->ops->sched_in(notifier, raw_smp_processor_id());
STR : }
STR : 
STR : static void
STR : fire_sched_out_preempt_notifiers(struct task_struct *curr,
STR : 				 struct task_struct *next)
STR : {
STR : 	struct preempt_notifier *notifier;
STR : 
STR : 	hlist_for_each_entry(notifier, &curr->preempt_notifiers, link)
STR : 		notifier->ops->sched_out(notifier, next);
STR : }
STR : 
STR : #else /* !CONFIG_PREEMPT_NOTIFIERS */
STR : 
STR : static void fire_sched_in_preempt_notifiers(struct task_struct *curr)
STR : {
STR : }
STR : 
STR : static void
STR : fire_sched_out_preempt_notifiers(struct task_struct *curr,
STR : 				 struct task_struct *next)
STR : {
STR : }
STR : 
STR : #endif /* CONFIG_PREEMPT_NOTIFIERS */
STR : 
STR : /**
STR :  * prepare_task_switch - prepare to switch tasks
STR :  * @rq: the runqueue preparing to switch
STR :  * @prev: the current task that is being switched out
STR :  * @next: the task we are going to switch to.
STR :  *
STR :  * This is called with the rq lock held and interrupts off. It must
STR :  * be paired with a subsequent finish_task_switch after the context
STR :  * switch.
STR :  *
STR :  * prepare_task_switch sets up locking and calls architecture specific
STR :  * hooks.
STR :  */
STR : static inline void
STR : prepare_task_switch(struct rq *rq, struct task_struct *prev,
STR : 		    struct task_struct *next)
STR : {
STR : 	trace_sched_switch(prev, next);
STR : 	sched_info_switch(rq, prev, next);
STR : 	perf_event_task_sched_out(prev, next);
STR : 	fire_sched_out_preempt_notifiers(prev, next);
STR : 	prepare_lock_switch(rq, next);
STR : 	prepare_arch_switch(next);
STR : }
STR : 
STR : /**
STR :  * finish_task_switch - clean up after a task-switch
STR :  * @rq: runqueue associated with task-switch
STR :  * @prev: the thread we just switched away from.
STR :  *
STR :  * finish_task_switch must be called after the context switch, paired
STR :  * with a prepare_task_switch call before the context switch.
STR :  * finish_task_switch will reconcile locking set up by prepare_task_switch,
STR :  * and do any other architecture-specific cleanup actions.
STR :  *
STR :  * Note that we may have delayed dropping an mm in context_switch(). If
STR :  * so, we finish that here outside of the runqueue lock. (Doing it
STR :  * with the lock held can cause deadlocks; see schedule() for
STR :  * details.)
STR :  */
STR : static void finish_task_switch(struct rq *rq, struct task_struct *prev)
STR : 	__releases(rq->lock)
STR : {
STR : 	struct mm_struct *mm = rq->prev_mm;
STR : 	long prev_state;
STR : 
STR : 	rq->prev_mm = NULL;
STR : 
STR : 	/*
STR : 	 * A task struct has one reference for the use as "current".
STR : 	 * If a task dies, then it sets TASK_DEAD in tsk->state and calls
STR : 	 * schedule one last time. The schedule call will never return, and
STR : 	 * the scheduled task must drop that reference.
STR : 	 * The test for TASK_DEAD must occur while the runqueue locks are
STR : 	 * still held, otherwise prev could be scheduled on another cpu, die
STR : 	 * there before we look at prev->state, and then the reference would
STR : 	 * be dropped twice.
STR : 	 *		Manfred Spraul <manfred@colorfullife.com>
STR : 	 */
STR : 	prev_state = prev->state;
STR : 	vtime_task_switch(prev);
STR : 	finish_arch_switch(prev);
STR : 	perf_event_task_sched_in(prev, current);
STR : 	finish_lock_switch(rq, prev);
STR : 	finish_arch_post_lock_switch();
STR : 
STR : 	fire_sched_in_preempt_notifiers(current);
STR : 	if (mm)
STR : 		mmdrop(mm);
STR : 	if (unlikely(prev_state == TASK_DEAD)) {
STR : 		task_numa_free(prev);
STR : 
STR : 		if (prev->sched_class->task_dead)
STR : 			prev->sched_class->task_dead(prev);
STR : 
STR : 		/*
STR : 		 * Remove function-return probe instances associated with this
STR : 		 * task and put them back on the free list.
STR : 		 */
STR : 		kprobe_flush_task(prev);
STR : 		put_task_struct(prev);
STR : 	}
STR : 
STR : 	tick_nohz_task_switch(current);
STR : }
STR : 
STR : #ifdef CONFIG_SMP
STR : 
STR : /* assumes rq->lock is held */
STR : static inline void pre_schedule(struct rq *rq, struct task_struct *prev)
STR : {
STR : 	if (prev->sched_class->pre_schedule)
STR : 		prev->sched_class->pre_schedule(rq, prev);
STR : }
STR : 
STR : /* rq->lock is NOT held, but preemption is disabled */
STR : static inline void post_schedule(struct rq *rq)
STR : {
STR : 	if (rq->post_schedule) {
STR : 		unsigned long flags;
STR : 
STR : 		raw_spin_lock_irqsave(&rq->lock, flags);
STR : 		if (rq->curr->sched_class->post_schedule)
STR : 			rq->curr->sched_class->post_schedule(rq);
STR : 		raw_spin_unlock_irqrestore(&rq->lock, flags);
STR : 
STR : 		rq->post_schedule = 0;
STR : 	}
STR : }
STR : 
STR : #else
STR : 
STR : static inline void pre_schedule(struct rq *rq, struct task_struct *p)
STR : {
STR : }
STR : 
STR : static inline void post_schedule(struct rq *rq)
STR : {
STR : }
STR : 
STR : #endif
STR : 
STR : /**
STR :  * schedule_tail - first thing a freshly forked thread must call.
STR :  * @prev: the thread we just switched away from.
STR :  */
STR : asmlinkage void schedule_tail(struct task_struct *prev)
STR : 	__releases(rq->lock)
STR : {
STR : 	struct rq *rq = this_rq();
STR : 
STR : 	finish_task_switch(rq, prev);
STR : 
STR : 	/*
STR : 	 * FIXME: do we need to worry about rq being invalidated by the
STR : 	 * task_switch?
STR : 	 */
STR : 	post_schedule(rq);
STR : 
STR : #ifdef __ARCH_WANT_UNLOCKED_CTXSW
STR : 	/* In this case, finish_task_switch does not reenable preemption */
STR : 	preempt_enable();
STR : #endif
STR : 	if (current->set_child_tid)
STR : 		put_user(task_pid_vnr(current), current->set_child_tid);
STR : }
STR : 
STR : /*
STR :  * context_switch - switch to the new MM and the new
STR :  * thread's register state.
STR :  */
STR : static inline void
STR : context_switch(struct rq *rq, struct task_struct *prev,
STR : 	       struct task_struct *next)
STR : {
STR : 	struct mm_struct *mm, *oldmm;
STR : 
STR : 	prepare_task_switch(rq, prev, next);
STR : 
STR : 	mm = next->mm;
STR : 	oldmm = prev->active_mm;
STR : 	/*
STR : 	 * For paravirt, this is coupled with an exit in switch_to to
STR : 	 * combine the page table reload and the switch backend into
STR : 	 * one hypercall.
STR : 	 */
STR : 	arch_start_context_switch(prev);
STR : 
STR : 	if (!mm) {
STR : 		next->active_mm = oldmm;
STR : 		atomic_inc(&oldmm->mm_count);
STR : 		enter_lazy_tlb(oldmm, next);
STR : 	} else
STR : 		switch_mm(oldmm, mm, next);
STR : 
STR : 	if (!prev->mm) {
STR : 		prev->active_mm = NULL;
STR : 		rq->prev_mm = oldmm;
STR : 	}
STR : 	/*
STR : 	 * Since the runqueue lock will be released by the next
STR : 	 * task (which is an invalid locking op but in the case
STR : 	 * of the scheduler it's an obvious special-case), so we
STR : 	 * do an early lockdep release here:
STR : 	 */
STR : #ifndef __ARCH_WANT_UNLOCKED_CTXSW
STR : 	spin_release(&rq->lock.dep_map, 1, _THIS_IP_);
STR : #endif
STR : 
STR : 	context_tracking_task_switch(prev, next);
STR : 	/* Here we just switch the register state and the stack. */
STR : 	switch_to(prev, next, prev);
STR : 
STR : 	barrier();
STR : 	/*
STR : 	 * this_rq must be evaluated again because prev may have moved
STR : 	 * CPUs since it called schedule(), thus the 'rq' on its stack
STR : 	 * frame will be invalid.
STR : 	 */
STR : 	finish_task_switch(this_rq(), prev);
STR : }
STR : 
STR : /*
STR :  * nr_running and nr_context_switches:
STR :  *
STR :  * externally visible scheduler statistics: current number of runnable
STR :  * threads, total number of context switches performed since bootup.
STR :  */
STR : unsigned long nr_running(void)
STR : {
STR : 	unsigned long i, sum = 0;
STR : 
STR : 	for_each_online_cpu(i)
STR : 		sum += cpu_rq(i)->nr_running;
STR : 
STR : 	return sum;
STR : }
STR : 
STR : unsigned long long nr_context_switches(void)
STR : {
STR : 	int i;
STR : 	unsigned long long sum = 0;
STR : 
STR : 	for_each_possible_cpu(i)
STR : 		sum += cpu_rq(i)->nr_switches;
STR : 
STR : 	return sum;
STR : }
STR : 
STR : unsigned long nr_iowait(void)
STR : {
STR : 	unsigned long i, sum = 0;
STR : 
STR : 	for_each_possible_cpu(i)
STR : 		sum += atomic_read(&cpu_rq(i)->nr_iowait);
STR : 
STR : 	return sum;
STR : }
STR : 
STR : unsigned long nr_iowait_cpu(int cpu)
STR : {
STR : 	struct rq *this = cpu_rq(cpu);
STR : 	return atomic_read(&this->nr_iowait);
STR : }
STR : 
STR : #ifdef CONFIG_SMP
STR : 
STR : /*
STR :  * sched_exec - execve() is a valuable balancing opportunity, because at
STR :  * this point the task has the smallest effective memory and cache footprint.
STR :  */
STR : void sched_exec(void)
STR : {
STR : 	struct task_struct *p = current;
STR : 	unsigned long flags;
STR : 	int dest_cpu;
STR : 
STR : 	raw_spin_lock_irqsave(&p->pi_lock, flags);
STR : 	dest_cpu = p->sched_class->select_task_rq(p, task_cpu(p), SD_BALANCE_EXEC, 0);
STR : 	if (dest_cpu == smp_processor_id())
STR : 		goto unlock;
STR : 
STR : 	if (likely(cpu_active(dest_cpu))) {
STR : 		struct migration_arg arg = { p, dest_cpu };
STR : 
STR : 		raw_spin_unlock_irqrestore(&p->pi_lock, flags);
STR : 		stop_one_cpu(task_cpu(p), migration_cpu_stop, &arg);
STR : 		return;
STR : 	}
STR : unlock:
STR : 	raw_spin_unlock_irqrestore(&p->pi_lock, flags);
STR : }
STR : 
STR : #endif
STR : 
STR : DEFINE_PER_CPU(struct kernel_stat, kstat);
STR : DEFINE_PER_CPU(struct kernel_cpustat, kernel_cpustat);
STR : 
STR : EXPORT_PER_CPU_SYMBOL(kstat);
STR : EXPORT_PER_CPU_SYMBOL(kernel_cpustat);
STR : 
STR : /*
STR :  * Return any ns on the sched_clock that have not yet been accounted in
STR :  * @p in case that task is currently running.
STR :  *
STR :  * Called with task_rq_lock() held on @rq.
STR :  */
STR : static u64 do_task_delta_exec(struct task_struct *p, struct rq *rq)
STR : {
STR : 	u64 ns = 0;
STR : 
STR : 	if (task_current(rq, p)) {
STR : 		update_rq_clock(rq);
STR : 		ns = rq_clock_task(rq) - p->se.exec_start;
STR : 		if ((s64)ns < 0)
STR : 			ns = 0;
STR : 	}
STR : 
STR : 	return ns;
STR : }
STR : 
STR : unsigned long long task_delta_exec(struct task_struct *p)
STR : {
STR : 	unsigned long flags;
STR : 	struct rq *rq;
STR : 	u64 ns = 0;
STR : 
STR : 	rq = task_rq_lock(p, &flags);
STR : 	ns = do_task_delta_exec(p, rq);
STR : 	task_rq_unlock(rq, p, &flags);
STR : 
STR : 	return ns;
STR : }
STR : 
STR : /*
STR :  * Return accounted runtime for the task.
STR :  * In case the task is currently running, return the runtime plus current's
STR :  * pending runtime that have not been accounted yet.
STR :  */
STR : unsigned long long task_sched_runtime(struct task_struct *p)
STR : {
STR : 	unsigned long flags;
STR : 	struct rq *rq;
STR : 	u64 ns = 0;
STR : 
STR : #if defined(CONFIG_64BIT) && defined(CONFIG_SMP)
STR : 	/*
STR : 	 * 64-bit doesn't need locks to atomically read a 64bit value.
STR : 	 * So we have a optimization chance when the task's delta_exec is 0.
STR : 	 * Reading ->on_cpu is racy, but this is ok.
STR : 	 *
STR : 	 * If we race with it leaving cpu, we'll take a lock. So we're correct.
STR : 	 * If we race with it entering cpu, unaccounted time is 0. This is
STR : 	 * indistinguishable from the read occurring a few cycles earlier.
STR : 	 */
STR : 	if (!p->on_cpu)
STR : 		return p->se.sum_exec_runtime;
STR : #endif
STR : 
STR : 	rq = task_rq_lock(p, &flags);
STR : 	ns = p->se.sum_exec_runtime + do_task_delta_exec(p, rq);
STR : 	task_rq_unlock(rq, p, &flags);
STR : 
STR : 	return ns;
STR : }
STR : 
STR : /*
STR :  * This function gets called by the timer code, with HZ frequency.
STR :  * We call it with interrupts disabled.
STR :  */
STR : void scheduler_tick(void)
STR : {
STR : 	int cpu = smp_processor_id();
STR : 	struct rq *rq = cpu_rq(cpu);
STR : 	struct task_struct *curr = rq->curr;
STR : 
STR : 	sched_clock_tick();
STR : 
STR : 	raw_spin_lock(&rq->lock);
STR : 	update_rq_clock(rq);
STR : 	curr->sched_class->task_tick(rq, curr, 0);
STR : 	update_cpu_load_active(rq);
STR : 	raw_spin_unlock(&rq->lock);
STR : 
STR : 	perf_event_task_tick();
STR : 
STR : #ifdef CONFIG_SMP
STR : 	rq->idle_balance = idle_cpu(cpu);
STR : 	trigger_load_balance(rq);
STR : #endif
STR : 	rq_last_tick_reset(rq);
STR : }
STR : 
STR : #ifdef CONFIG_NO_HZ_FULL
STR : /**
STR :  * scheduler_tick_max_deferment
STR :  *
STR :  * Keep at least one tick per second when a single
STR :  * active task is running because the scheduler doesn't
STR :  * yet completely support full dynticks environment.
STR :  *
STR :  * This makes sure that uptime, CFS vruntime, load
STR :  * balancing, etc... continue to move forward, even
STR :  * with a very low granularity.
STR :  *
STR :  * Return: Maximum deferment in nanoseconds.
STR :  */
STR : u64 scheduler_tick_max_deferment(void)
STR : {
STR : 	struct rq *rq = this_rq();
STR : 	unsigned long next, now = ACCESS_ONCE(jiffies);
STR : 
STR : 	next = rq->last_sched_tick + HZ;
STR : 
STR : 	if (time_before_eq(next, now))
STR : 		return 0;
STR : 
STR : 	return jiffies_to_nsecs(next - now);
STR : }
STR : #endif
STR : 
STR : notrace unsigned long get_parent_ip(unsigned long addr)
STR : {
STR : 	if (in_lock_functions(addr)) {
STR : 		addr = CALLER_ADDR2;
STR : 		if (in_lock_functions(addr))
STR : 			addr = CALLER_ADDR3;
STR : 	}
STR : 	return addr;
STR : }
STR : 
STR : #if defined(CONFIG_PREEMPT) && (defined(CONFIG_DEBUG_PREEMPT) || \
STR : 				defined(CONFIG_PREEMPT_TRACER))
STR : 
STR : void __kprobes preempt_count_add(int val)
STR : {
STR : #ifdef CONFIG_DEBUG_PREEMPT
STR : 	/*
STR : 	 * Underflow?
STR : 	 */
STR : 	if (DEBUG_LOCKS_WARN_ON((preempt_count() < 0)))
STR : 		return;
STR : #endif
STR : 	__preempt_count_add(val);
STR : #ifdef CONFIG_DEBUG_PREEMPT
STR : 	/*
STR : 	 * Spinlock count overflowing soon?
STR : 	 */
STR : 	DEBUG_LOCKS_WARN_ON((preempt_count() & PREEMPT_MASK) >=
STR : 				PREEMPT_MASK - 10);
STR : #endif
STR : 	if (preempt_count() == val)
STR : 		trace_preempt_off(CALLER_ADDR0, get_parent_ip(CALLER_ADDR1));
STR : }
STR : EXPORT_SYMBOL(preempt_count_add);
STR : 
STR : void __kprobes preempt_count_sub(int val)
STR : {
STR : #ifdef CONFIG_DEBUG_PREEMPT
STR : 	/*
STR : 	 * Underflow?
STR : 	 */
STR : 	if (DEBUG_LOCKS_WARN_ON(val > preempt_count()))
STR : 		return;
STR : 	/*
STR : 	 * Is the spinlock portion underflowing?
STR : 	 */
STR : 	if (DEBUG_LOCKS_WARN_ON((val < PREEMPT_MASK) &&
STR : 			!(preempt_count() & PREEMPT_MASK)))
STR : 		return;
STR : #endif
STR : 
STR : 	if (preempt_count() == val)
STR : 		trace_preempt_on(CALLER_ADDR0, get_parent_ip(CALLER_ADDR1));
STR : 	__preempt_count_sub(val);
STR : }
STR : EXPORT_SYMBOL(preempt_count_sub);
STR : 
STR : #endif
STR : 
STR : /*
STR :  * Print scheduling while atomic bug:
STR :  */
STR : static noinline void __schedule_bug(struct task_struct *prev)
STR : {
STR : 	if (oops_in_progress)
STR : 		return;
STR : 
STR : 	printk(KERN_ERR "BUG: scheduling while atomic: %s/%d/0x%08x\n",
STR : 		prev->comm, prev->pid, preempt_count());
STR : 
STR : 	debug_show_held_locks(prev);
STR : 	print_modules();
STR : 	if (irqs_disabled())
STR : 		print_irqtrace_events(prev);
STR : 	dump_stack();
STR : 	add_taint(TAINT_WARN, LOCKDEP_STILL_OK);
STR : }
STR : 
STR : /*
STR :  * Various schedule()-time debugging checks and statistics:
STR :  */
STR : static inline void schedule_debug(struct task_struct *prev)
STR : {
STR : 	/*
STR : 	 * Test if we are atomic. Since do_exit() needs to call into
STR : 	 * schedule() atomically, we ignore that path. Otherwise whine
STR : 	 * if we are scheduling when we should not.
STR : 	 */
STR : 	if (unlikely(in_atomic_preempt_off() && prev->state != TASK_DEAD))
STR : 		__schedule_bug(prev);
STR : 	rcu_sleep_check();
STR : 
STR : 	profile_hit(SCHED_PROFILING, __builtin_return_address(0));
STR : 
STR : 	schedstat_inc(this_rq(), sched_count);
STR : }
STR : 
STR : static void put_prev_task(struct rq *rq, struct task_struct *prev)
STR : {
STR : 	if (prev->on_rq || rq->skip_clock_update < 0)
STR : 		update_rq_clock(rq);
STR : 	prev->sched_class->put_prev_task(rq, prev);
STR : }
STR : 
STR : /*
STR :  * Pick up the highest-prio task:
STR :  */
STR : static inline struct task_struct *
STR : pick_next_task(struct rq *rq)
STR : {
STR : 	const struct sched_class *class;
STR : 	struct task_struct *p;
STR : 
STR : 	/*
STR : 	 * Optimization: we know that if all tasks are in
STR : 	 * the fair class we can call that function directly:
STR : 	 */
STR : 	if (likely(rq->nr_running == rq->cfs.h_nr_running)) {
STR : 		p = fair_sched_class.pick_next_task(rq);
STR : 		if (likely(p))
STR : 			return p;
STR : 	}
STR : 
STR : 	for_each_class(class) {
STR : 		p = class->pick_next_task(rq);
STR : 		if (p)
STR : 			return p;
STR : 	}
STR : 
STR : 	BUG(); /* the idle class will always have a runnable task */
STR : }
STR : 
STR : /*
STR :  * __schedule() is the main scheduler function.
STR :  *
STR :  * The main means of driving the scheduler and thus entering this function are:
STR :  *
STR :  *   1. Explicit blocking: mutex, semaphore, waitqueue, etc.
STR :  *
STR :  *   2. TIF_NEED_RESCHED flag is checked on interrupt and userspace return
STR :  *      paths. For example, see arch/x86/entry_64.S.
STR :  *
STR :  *      To drive preemption between tasks, the scheduler sets the flag in timer
STR :  *      interrupt handler scheduler_tick().
STR :  *
STR :  *   3. Wakeups don't really cause entry into schedule(). They add a
STR :  *      task to the run-queue and that's it.
STR :  *
STR :  *      Now, if the new task added to the run-queue preempts the current
STR :  *      task, then the wakeup sets TIF_NEED_RESCHED and schedule() gets
STR :  *      called on the nearest possible occasion:
STR :  *
STR :  *       - If the kernel is preemptible (CONFIG_PREEMPT=y):
STR :  *
STR :  *         - in syscall or exception context, at the next outmost
STR :  *           preempt_enable(). (this might be as soon as the wake_up()'s
STR :  *           spin_unlock()!)
STR :  *
STR :  *         - in IRQ context, return from interrupt-handler to
STR :  *           preemptible context
STR :  *
STR :  *       - If the kernel is not preemptible (CONFIG_PREEMPT is not set)
STR :  *         then at the next:
STR :  *
STR :  *          - cond_resched() call
STR :  *          - explicit schedule() call
STR :  *          - return from syscall or exception to user-space
STR :  *          - return from interrupt-handler to user-space
STR :  */
STR : static void __sched __schedule(void)
STR : {
STR : 	struct task_struct *prev, *next;
STR : 	unsigned long *switch_count;
STR : 	struct rq *rq;
STR : 	int cpu;
STR : 
STR : need_resched:
STR : 	preempt_disable();
STR : 	cpu = smp_processor_id();
STR : 	rq = cpu_rq(cpu);
STR : 	rcu_note_context_switch(cpu);
STR : 	prev = rq->curr;
STR : 
STR : 	schedule_debug(prev);
STR : 
STR : 	if (sched_feat(HRTICK))
STR : 		hrtick_clear(rq);
STR : 
STR : 	/*
STR : 	 * Make sure that signal_pending_state()->signal_pending() below
STR : 	 * can't be reordered with __set_current_state(TASK_INTERRUPTIBLE)
STR : 	 * done by the caller to avoid the race with signal_wake_up().
STR : 	 */
STR : 	smp_mb__before_spinlock();
STR : 	raw_spin_lock_irq(&rq->lock);
STR : 
STR : 	switch_count = &prev->nivcsw;
STR : 	if (prev->state && !(preempt_count() & PREEMPT_ACTIVE)) {
STR : 		if (unlikely(signal_pending_state(prev->state, prev))) {
STR : 			prev->state = TASK_RUNNING;
STR : 		} else {
STR : 			deactivate_task(rq, prev, DEQUEUE_SLEEP);
STR : 			prev->on_rq = 0;
STR : 
STR : 			/*
STR : 			 * If a worker went to sleep, notify and ask workqueue
STR : 			 * whether it wants to wake up a task to maintain
STR : 			 * concurrency.
STR : 			 */
STR : 			if (prev->flags & PF_WQ_WORKER) {
STR : 				struct task_struct *to_wakeup;
STR : 
STR : 				to_wakeup = wq_worker_sleeping(prev, cpu);
STR : 				if (to_wakeup)
STR : 					try_to_wake_up_local(to_wakeup);
STR : 			}
STR : 		}
STR : 		switch_count = &prev->nvcsw;
STR : 	}
STR : 
STR : 	pre_schedule(rq, prev);
STR : 
STR : 	if (unlikely(!rq->nr_running))
STR : 		idle_balance(cpu, rq);
STR : 
STR : 	put_prev_task(rq, prev);
STR : 	next = pick_next_task(rq);
STR : 	clear_tsk_need_resched(prev);
STR : 	clear_preempt_need_resched();
STR : 	rq->skip_clock_update = 0;
STR : 
STR : 	if (likely(prev != next)) {
STR : 		rq->nr_switches++;
STR : 		rq->curr = next;
STR : 		++*switch_count;
STR : 
STR : 		context_switch(rq, prev, next); /* unlocks the rq */
STR : 		/*
STR : 		 * The context switch have flipped the stack from under us
STR : 		 * and restored the local variables which were saved when
STR : 		 * this task called schedule() in the past. prev == current
STR : 		 * is still correct, but it can be moved to another cpu/rq.
STR : 		 */
STR : 		cpu = smp_processor_id();
STR : 		rq = cpu_rq(cpu);
STR : 	} else
STR : 		raw_spin_unlock_irq(&rq->lock);
STR : 
STR : 	post_schedule(rq);
STR : 
STR : 	sched_preempt_enable_no_resched();
STR : 	if (need_resched())
STR : 		goto need_resched;
STR : }
STR : 
STR : static inline void sched_submit_work(struct task_struct *tsk)
STR : {
STR : 	if (!tsk->state || tsk_is_pi_blocked(tsk))
STR : 		return;
STR : 	/*
STR : 	 * If we are going to sleep and we have plugged IO queued,
STR : 	 * make sure to submit it to avoid deadlocks.
STR : 	 */
STR : 	if (blk_needs_flush_plug(tsk))
STR : 		blk_schedule_flush_plug(tsk);
STR : }
STR : 
STR : asmlinkage void __sched schedule(void)
STR : {
STR : 	struct task_struct *tsk = current;
STR : 
STR : 	sched_submit_work(tsk);
STR : 	__schedule();
STR : }
STR : EXPORT_SYMBOL(schedule);
STR : 
STR : #ifdef CONFIG_CONTEXT_TRACKING
STR : asmlinkage void __sched schedule_user(void)
STR : {
STR : 	/*
STR : 	 * If we come here after a random call to set_need_resched(),
STR : 	 * or we have been woken up remotely but the IPI has not yet arrived,
STR : 	 * we haven't yet exited the RCU idle mode. Do it here manually until
STR : 	 * we find a better solution.
STR : 	 */
STR : 	user_exit();
STR : 	schedule();
STR : 	user_enter();
STR : }
STR : #endif
STR : 
STR : /**
STR :  * schedule_preempt_disabled - called with preemption disabled
STR :  *
STR :  * Returns with preemption disabled. Note: preempt_count must be 1
STR :  */
STR : void __sched schedule_preempt_disabled(void)
STR : {
STR : 	sched_preempt_enable_no_resched();
STR : 	schedule();
STR : 	preempt_disable();
STR : }
STR : 
STR : #ifdef CONFIG_PREEMPT
STR : /*
STR :  * this is the entry point to schedule() from in-kernel preemption
STR :  * off of preempt_enable. Kernel preemptions off return from interrupt
STR :  * occur there and call schedule directly.
STR :  */
STR : asmlinkage void __sched notrace preempt_schedule(void)
STR : {
STR : 	/*
STR : 	 * If there is a non-zero preempt_count or interrupts are disabled,
STR : 	 * we do not want to preempt the current task. Just return..
STR : 	 */
STR : 	if (likely(!preemptible()))
STR : 		return;
STR : 
STR : 	do {
STR : 		__preempt_count_add(PREEMPT_ACTIVE);
STR : 		__schedule();
STR : 		__preempt_count_sub(PREEMPT_ACTIVE);
STR : 
STR : 		/*
STR : 		 * Check again in case we missed a preemption opportunity
STR : 		 * between schedule and now.
STR : 		 */
STR : 		barrier();
STR : 	} while (need_resched());
STR : }
STR : EXPORT_SYMBOL(preempt_schedule);
STR : #endif /* CONFIG_PREEMPT */
STR : 
STR : /*
STR :  * this is the entry point to schedule() from kernel preemption
STR :  * off of irq context.
STR :  * Note, that this is called and return with irqs disabled. This will
STR :  * protect us against recursive calling from irq.
STR :  */
STR : asmlinkage void __sched preempt_schedule_irq(void)
STR : {
STR : 	enum ctx_state prev_state;
STR : 
STR : 	/* Catch callers which need to be fixed */
STR : 	BUG_ON(preempt_count() || !irqs_disabled());
STR : 
STR : 	prev_state = exception_enter();
STR : 
STR : 	do {
STR : 		__preempt_count_add(PREEMPT_ACTIVE);
STR : 		local_irq_enable();
STR : 		__schedule();
STR : 		local_irq_disable();
STR : 		__preempt_count_sub(PREEMPT_ACTIVE);
STR : 
STR : 		/*
STR : 		 * Check again in case we missed a preemption opportunity
STR : 		 * between schedule and now.
STR : 		 */
STR : 		barrier();
STR : 	} while (need_resched());
STR : 
STR : 	exception_exit(prev_state);
STR : }
STR : 
STR : int default_wake_function(wait_queue_t *curr, unsigned mode, int wake_flags,
STR : 			  void *key)
STR : {
STR : 	return try_to_wake_up(curr->private, mode, wake_flags);
STR : }
STR : EXPORT_SYMBOL(default_wake_function);
STR : 
STR : static long __sched
STR : sleep_on_common(wait_queue_head_t *q, int state, long timeout)
STR : {
STR : 	unsigned long flags;
STR : 	wait_queue_t wait;
STR : 
STR : 	init_waitqueue_entry(&wait, current);
STR : 
STR : 	__set_current_state(state);
STR : 
STR : 	spin_lock_irqsave(&q->lock, flags);
STR : 	__add_wait_queue(q, &wait);
STR : 	spin_unlock(&q->lock);
STR : 	timeout = schedule_timeout(timeout);
STR : 	spin_lock_irq(&q->lock);
STR : 	__remove_wait_queue(q, &wait);
STR : 	spin_unlock_irqrestore(&q->lock, flags);
STR : 
STR : 	return timeout;
STR : }
STR : 
STR : void __sched interruptible_sleep_on(wait_queue_head_t *q)
STR : {
STR : 	sleep_on_common(q, TASK_INTERRUPTIBLE, MAX_SCHEDULE_TIMEOUT);
STR : }
STR : EXPORT_SYMBOL(interruptible_sleep_on);
STR : 
STR : long __sched
STR : interruptible_sleep_on_timeout(wait_queue_head_t *q, long timeout)
STR : {
STR : 	return sleep_on_common(q, TASK_INTERRUPTIBLE, timeout);
STR : }
STR : EXPORT_SYMBOL(interruptible_sleep_on_timeout);
STR : 
STR : void __sched sleep_on(wait_queue_head_t *q)
STR : {
STR : 	sleep_on_common(q, TASK_UNINTERRUPTIBLE, MAX_SCHEDULE_TIMEOUT);
STR : }
STR : EXPORT_SYMBOL(sleep_on);
STR : 
STR : long __sched sleep_on_timeout(wait_queue_head_t *q, long timeout)
STR : {
STR : 	return sleep_on_common(q, TASK_UNINTERRUPTIBLE, timeout);
STR : }
STR : EXPORT_SYMBOL(sleep_on_timeout);
STR : 
STR : #ifdef CONFIG_RT_MUTEXES
STR : 
STR : /*
STR :  * rt_mutex_setprio - set the current priority of a task
STR :  * @p: task
STR :  * @prio: prio value (kernel-internal form)
STR :  *
STR :  * This function changes the 'effective' priority of a task. It does
STR :  * not touch ->normal_prio like __setscheduler().
STR :  *
STR :  * Used by the rt_mutex code to implement priority inheritance logic.
STR :  */
STR : void rt_mutex_setprio(struct task_struct *p, int prio)
STR : {
STR : 	int oldprio, on_rq, running, enqueue_flag = 0;
STR : 	struct rq *rq;
STR : 	const struct sched_class *prev_class;
STR : 
STR : 	BUG_ON(prio > MAX_PRIO);
STR : 
STR : 	rq = __task_rq_lock(p);
STR : 
STR : 	/*
STR : 	 * Idle task boosting is a nono in general. There is one
STR : 	 * exception, when PREEMPT_RT and NOHZ is active:
STR : 	 *
STR : 	 * The idle task calls get_next_timer_interrupt() and holds
STR : 	 * the timer wheel base->lock on the CPU and another CPU wants
STR : 	 * to access the timer (probably to cancel it). We can safely
STR : 	 * ignore the boosting request, as the idle CPU runs this code
STR : 	 * with interrupts disabled and will complete the lock
STR : 	 * protected section without being interrupted. So there is no
STR : 	 * real need to boost.
STR : 	 */
STR : 	if (unlikely(p == rq->idle)) {
STR : 		WARN_ON(p != rq->curr);
STR : 		WARN_ON(p->pi_blocked_on);
STR : 		goto out_unlock;
STR : 	}
STR : 
STR : 	trace_sched_pi_setprio(p, prio);
STR : 	p->pi_top_task = rt_mutex_get_top_task(p);
STR : 	oldprio = p->prio;
STR : 	prev_class = p->sched_class;
STR : 	on_rq = p->on_rq;
STR : 	running = task_current(rq, p);
STR : 	if (on_rq)
STR : 		dequeue_task(rq, p, 0);
STR : 	if (running)
STR : 		p->sched_class->put_prev_task(rq, p);
STR : 
STR : 	/*
STR : 	 * Boosting condition are:
STR : 	 * 1. -rt task is running and holds mutex A
STR : 	 *      --> -dl task blocks on mutex A
STR : 	 *
STR : 	 * 2. -dl task is running and holds mutex A
STR : 	 *      --> -dl task blocks on mutex A and could preempt the
STR : 	 *          running task
STR : 	 */
STR : 	if (dl_prio(prio)) {
STR : 		if (!dl_prio(p->normal_prio) || (p->pi_top_task &&
STR : 			dl_entity_preempt(&p->pi_top_task->dl, &p->dl))) {
STR : 			p->dl.dl_boosted = 1;
STR : 			p->dl.dl_throttled = 0;
STR : 			enqueue_flag = ENQUEUE_REPLENISH;
STR : 		} else
STR : 			p->dl.dl_boosted = 0;
STR : 		p->sched_class = &dl_sched_class;
STR : 	} else if (rt_prio(prio)) {
STR : 		if (dl_prio(oldprio))
STR : 			p->dl.dl_boosted = 0;
STR : 		if (oldprio < prio)
STR : 			enqueue_flag = ENQUEUE_HEAD;
STR : 		p->sched_class = &rt_sched_class;
STR : 	} else {
STR : 		if (dl_prio(oldprio))
STR : 			p->dl.dl_boosted = 0;
STR : 		p->sched_class = &fair_sched_class;
STR : 	}
STR : 
STR : 	p->prio = prio;
STR : 
STR : 	if (running)
STR : 		p->sched_class->set_curr_task(rq);
STR : 	if (on_rq)
STR : 		enqueue_task(rq, p, enqueue_flag);
STR : 
STR : 	check_class_changed(rq, p, prev_class, oldprio);
STR : out_unlock:
STR : 	__task_rq_unlock(rq);
STR : }
STR : #endif
STR : 
STR : void set_user_nice(struct task_struct *p, long nice)
STR : {
STR : 	int old_prio, delta, on_rq;
STR : 	unsigned long flags;
STR : 	struct rq *rq;
STR : 
STR : 	if (TASK_NICE(p) == nice || nice < -20 || nice > 19)
STR : 		return;
STR : 	/*
STR : 	 * We have to be careful, if called from sys_setpriority(),
STR : 	 * the task might be in the middle of scheduling on another CPU.
STR : 	 */
STR : 	rq = task_rq_lock(p, &flags);
STR : 	/*
STR : 	 * The RT priorities are set via sched_setscheduler(), but we still
STR : 	 * allow the 'normal' nice value to be set - but as expected
STR : 	 * it wont have any effect on scheduling until the task is
STR : 	 * SCHED_DEADLINE, SCHED_FIFO or SCHED_RR:
STR : 	 */
STR : 	if (task_has_dl_policy(p) || task_has_rt_policy(p)) {
STR : 		p->static_prio = NICE_TO_PRIO(nice);
STR : 		goto out_unlock;
STR : 	}
STR : 	on_rq = p->on_rq;
STR : 	if (on_rq)
STR : 		dequeue_task(rq, p, 0);
STR : 
STR : 	p->static_prio = NICE_TO_PRIO(nice);
STR : 	set_load_weight(p);
STR : 	old_prio = p->prio;
STR : 	p->prio = effective_prio(p);
STR : 	delta = p->prio - old_prio;
STR : 
STR : 	if (on_rq) {
STR : 		enqueue_task(rq, p, 0);
STR : 		/*
STR : 		 * If the task increased its priority or is running and
STR : 		 * lowered its priority, then reschedule its CPU:
STR : 		 */
STR : 		if (delta < 0 || (delta > 0 && task_running(rq, p)))
STR : 			resched_task(rq->curr);
STR : 	}
STR : out_unlock:
STR : 	task_rq_unlock(rq, p, &flags);
STR : }
STR : EXPORT_SYMBOL(set_user_nice);
STR : 
STR : /*
STR :  * can_nice - check if a task can reduce its nice value
STR :  * @p: task
STR :  * @nice: nice value
STR :  */
STR : int can_nice(const struct task_struct *p, const int nice)
STR : {
STR : 	/* convert nice value [19,-20] to rlimit style value [1,40] */
STR : 	int nice_rlim = 20 - nice;
STR : 
STR : 	return (nice_rlim <= task_rlimit(p, RLIMIT_NICE) ||
STR : 		capable(CAP_SYS_NICE));
STR : }
STR : 
STR : #ifdef __ARCH_WANT_SYS_NICE
STR : 
STR : /*
STR :  * sys_nice - change the priority of the current process.
STR :  * @increment: priority increment
STR :  *
STR :  * sys_setpriority is a more generic, but much slower function that
STR :  * does similar things.
STR :  */
STR : SYSCALL_DEFINE1(nice, int, increment)
STR : {
STR : 	long nice, retval;
STR : 
STR : 	/*
STR : 	 * Setpriority might change our priority at the same moment.
STR : 	 * We don't have to worry. Conceptually one call occurs first
STR : 	 * and we have a single winner.
STR : 	 */
STR : 	if (increment < -40)
STR : 		increment = -40;
STR : 	if (increment > 40)
STR : 		increment = 40;
STR : 
STR : 	nice = TASK_NICE(current) + increment;
STR : 	if (nice < -20)
STR : 		nice = -20;
STR : 	if (nice > 19)
STR : 		nice = 19;
STR : 
STR : 	if (increment < 0 && !can_nice(current, nice))
STR : 		return -EPERM;
STR : 
STR : 	retval = security_task_setnice(current, nice);
STR : 	if (retval)
STR : 		return retval;
STR : 
STR : 	set_user_nice(current, nice);
STR : 	return 0;
STR : }
STR : 
STR : #endif
STR : 
STR : /**
STR :  * task_prio - return the priority value of a given task.
STR :  * @p: the task in question.
STR :  *
STR :  * Return: The priority value as seen by users in /proc.
STR :  * RT tasks are offset by -200. Normal tasks are centered
STR :  * around 0, value goes from -16 to +15.
STR :  */
STR : int task_prio(const struct task_struct *p)
STR : {
STR : 	return p->prio - MAX_RT_PRIO;
STR : }
STR : 
STR : /**
STR :  * task_nice - return the nice value of a given task.
STR :  * @p: the task in question.
STR :  *
STR :  * Return: The nice value [ -20 ... 0 ... 19 ].
STR :  */
STR : int task_nice(const struct task_struct *p)
STR : {
STR : 	return TASK_NICE(p);
STR : }
STR : EXPORT_SYMBOL(task_nice);
STR : 
STR : /**
STR :  * idle_cpu - is a given cpu idle currently?
STR :  * @cpu: the processor in question.
STR :  *
STR :  * Return: 1 if the CPU is currently idle. 0 otherwise.
STR :  */
STR : int idle_cpu(int cpu)
STR : {
STR : 	struct rq *rq = cpu_rq(cpu);
STR : 
STR : 	if (rq->curr != rq->idle)
STR : 		return 0;
STR : 
STR : 	if (rq->nr_running)
STR : 		return 0;
STR : 
STR : #ifdef CONFIG_SMP
STR : 	if (!llist_empty(&rq->wake_list))
STR : 		return 0;
STR : #endif
STR : 
STR : 	return 1;
STR : }
STR : 
STR : /**
STR :  * idle_task - return the idle task for a given cpu.
STR :  * @cpu: the processor in question.
STR :  *
STR :  * Return: The idle task for the cpu @cpu.
STR :  */
STR : struct task_struct *idle_task(int cpu)
STR : {
STR : 	return cpu_rq(cpu)->idle;
STR : }
STR : 
STR : /**
STR :  * find_process_by_pid - find a process with a matching PID value.
STR :  * @pid: the pid in question.
STR :  *
STR :  * The task of @pid, if found. %NULL otherwise.
STR :  */
STR : static struct task_struct *find_process_by_pid(pid_t pid)
STR : {
STR : 	return pid ? find_task_by_vpid(pid) : current;
STR : }
STR : 
STR : /*
STR :  * This function initializes the sched_dl_entity of a newly becoming
STR :  * SCHED_DEADLINE task.
STR :  *
STR :  * Only the static values are considered here, the actual runtime and the
STR :  * absolute deadline will be properly calculated when the task is enqueued
STR :  * for the first time with its new policy.
STR :  */
STR : static void
STR : __setparam_dl(struct task_struct *p, const struct sched_attr *attr)
STR : {
STR : 	struct sched_dl_entity *dl_se = &p->dl;
STR : 
STR : 	init_dl_task_timer(dl_se);
STR : 	dl_se->dl_runtime = attr->sched_runtime;
STR : 	dl_se->dl_deadline = attr->sched_deadline;
STR : 	dl_se->dl_period = attr->sched_period ?: dl_se->dl_deadline;
STR : 	dl_se->flags = attr->sched_flags;
STR : 	dl_se->dl_bw = to_ratio(dl_se->dl_period, dl_se->dl_runtime);
STR : 	dl_se->dl_throttled = 0;
STR : 	dl_se->dl_new = 1;
STR : }
STR : 
STR : /* Actually do priority change: must hold pi & rq lock. */
STR : static void __setscheduler(struct rq *rq, struct task_struct *p,
STR : 			   const struct sched_attr *attr)
STR : {
STR : 	int policy = attr->sched_policy;
STR : 
STR : 	if (policy == -1) /* setparam */
STR : 		policy = p->policy;
STR : 
STR : 	p->policy = policy;
STR : 
STR : 	if (dl_policy(policy))
STR : 		__setparam_dl(p, attr);
STR : 	else if (fair_policy(policy))
STR : 		p->static_prio = NICE_TO_PRIO(attr->sched_nice);
STR : 
STR : 	/*
STR : 	 * __sched_setscheduler() ensures attr->sched_priority == 0 when
STR : 	 * !rt_policy. Always setting this ensures that things like
STR : 	 * getparam()/getattr() don't report silly values for !rt tasks.
STR : 	 */
STR : 	p->rt_priority = attr->sched_priority;
STR : 
STR : 	p->normal_prio = normal_prio(p);
STR : 	p->prio = rt_mutex_getprio(p);
STR : 
STR : 	if (dl_prio(p->prio))
STR : 		p->sched_class = &dl_sched_class;
STR : 	else if (rt_prio(p->prio))
STR : 		p->sched_class = &rt_sched_class;
STR : 	else
STR : 		p->sched_class = &fair_sched_class;
STR : 
STR : 	set_load_weight(p);
STR : }
STR : 
STR : static void
STR : __getparam_dl(struct task_struct *p, struct sched_attr *attr)
STR : {
STR : 	struct sched_dl_entity *dl_se = &p->dl;
STR : 
STR : 	attr->sched_priority = p->rt_priority;
STR : 	attr->sched_runtime = dl_se->dl_runtime;
STR : 	attr->sched_deadline = dl_se->dl_deadline;
STR : 	attr->sched_period = dl_se->dl_period;
STR : 	attr->sched_flags = dl_se->flags;
STR : }
STR : 
STR : /*
STR :  * This function validates the new parameters of a -deadline task.
STR :  * We ask for the deadline not being zero, and greater or equal
STR :  * than the runtime, as well as the period of being zero or
STR :  * greater than deadline. Furthermore, we have to be sure that
STR :  * user parameters are above the internal resolution of 1us (we
STR :  * check sched_runtime only since it is always the smaller one) and
STR :  * below 2^63 ns (we have to check both sched_deadline and
STR :  * sched_period, as the latter can be zero).
STR :  */
STR : static bool
STR : __checkparam_dl(const struct sched_attr *attr)
STR : {
STR : 	/* deadline != 0 */
STR : 	if (attr->sched_deadline == 0)
STR : 		return false;
STR : 
STR : 	/*
STR : 	 * Since we truncate DL_SCALE bits, make sure we're at least
STR : 	 * that big.
STR : 	 */
STR : 	if (attr->sched_runtime < (1ULL << DL_SCALE))
STR : 		return false;
STR : 
STR : 	/*
STR : 	 * Since we use the MSB for wrap-around and sign issues, make
STR : 	 * sure it's not set (mind that period can be equal to zero).
STR : 	 */
STR : 	if (attr->sched_deadline & (1ULL << 63) ||
STR : 	    attr->sched_period & (1ULL << 63))
STR : 		return false;
STR : 
STR : 	/* runtime <= deadline <= period (if period != 0) */
STR : 	if ((attr->sched_period != 0 &&
STR : 	     attr->sched_period < attr->sched_deadline) ||
STR : 	    attr->sched_deadline < attr->sched_runtime)
STR : 		return false;
STR : 
STR : 	return true;
STR : }
STR : 
STR : /*
STR :  * check the target process has a UID that matches the current process's
STR :  */
STR : static bool check_same_owner(struct task_struct *p)
STR : {
STR : 	const struct cred *cred = current_cred(), *pcred;
STR : 	bool match;
STR : 
STR : 	rcu_read_lock();
STR : 	pcred = __task_cred(p);
STR : 	match = (uid_eq(cred->euid, pcred->euid) ||
STR : 		 uid_eq(cred->euid, pcred->uid));
STR : 	rcu_read_unlock();
STR : 	return match;
STR : }
STR : 
STR : static int __sched_setscheduler(struct task_struct *p,
STR : 				const struct sched_attr *attr,
STR : 				bool user)
STR : {
STR : 	int retval, oldprio, oldpolicy = -1, on_rq, running;
STR : 	int policy = attr->sched_policy;
STR : 	unsigned long flags;
STR : 	const struct sched_class *prev_class;
STR : 	struct rq *rq;
STR : 	int reset_on_fork;
STR : 
STR : 	/* may grab non-irq protected spin_locks */
STR : 	BUG_ON(in_interrupt());
STR : recheck:
STR : 	/* double check policy once rq lock held */
STR : 	if (policy < 0) {
STR : 		reset_on_fork = p->sched_reset_on_fork;
STR : 		policy = oldpolicy = p->policy;
STR : 	} else {
STR : 		reset_on_fork = !!(attr->sched_flags & SCHED_FLAG_RESET_ON_FORK);
STR : 
STR : 		if (policy != SCHED_DEADLINE &&
STR : 				policy != SCHED_FIFO && policy != SCHED_RR &&
STR : 				policy != SCHED_NORMAL && policy != SCHED_BATCH &&
STR : 				policy != SCHED_IDLE)
STR : 			return -EINVAL;
STR : 	}
STR : 
STR : 	if (attr->sched_flags & ~(SCHED_FLAG_RESET_ON_FORK))
STR : 		return -EINVAL;
STR : 
STR : 	/*
STR : 	 * Valid priorities for SCHED_FIFO and SCHED_RR are
STR : 	 * 1..MAX_USER_RT_PRIO-1, valid priority for SCHED_NORMAL,
STR : 	 * SCHED_BATCH and SCHED_IDLE is 0.
STR : 	 */
STR : 	if ((p->mm && attr->sched_priority > MAX_USER_RT_PRIO-1) ||
STR : 	    (!p->mm && attr->sched_priority > MAX_RT_PRIO-1))
STR : 		return -EINVAL;
STR : 	if ((dl_policy(policy) && !__checkparam_dl(attr)) ||
STR : 	    (rt_policy(policy) != (attr->sched_priority != 0)))
STR : 		return -EINVAL;
STR : 
STR : 	/*
STR : 	 * Allow unprivileged RT tasks to decrease priority:
STR : 	 */
STR : 	if (user && !capable(CAP_SYS_NICE)) {
STR : 		if (fair_policy(policy)) {
STR : 			if (attr->sched_nice < TASK_NICE(p) &&
STR : 			    !can_nice(p, attr->sched_nice))
STR : 				return -EPERM;
STR : 		}
STR : 
STR : 		if (rt_policy(policy)) {
STR : 			unsigned long rlim_rtprio =
STR : 					task_rlimit(p, RLIMIT_RTPRIO);
STR : 
STR : 			/* can't set/change the rt policy */
STR : 			if (policy != p->policy && !rlim_rtprio)
STR : 				return -EPERM;
STR : 
STR : 			/* can't increase priority */
STR : 			if (attr->sched_priority > p->rt_priority &&
STR : 			    attr->sched_priority > rlim_rtprio)
STR : 				return -EPERM;
STR : 		}
STR : 
STR : 		 /*
STR : 		  * Can't set/change SCHED_DEADLINE policy at all for now
STR : 		  * (safest behavior); in the future we would like to allow
STR : 		  * unprivileged DL tasks to increase their relative deadline
STR : 		  * or reduce their runtime (both ways reducing utilization)
STR : 		  */
STR : 		if (dl_policy(policy))
STR : 			return -EPERM;
STR : 
STR : 		/*
STR : 		 * Treat SCHED_IDLE as nice 20. Only allow a switch to
STR : 		 * SCHED_NORMAL if the RLIMIT_NICE would normally permit it.
STR : 		 */
STR : 		if (p->policy == SCHED_IDLE && policy != SCHED_IDLE) {
STR : 			if (!can_nice(p, TASK_NICE(p)))
STR : 				return -EPERM;
STR : 		}
STR : 
STR : 		/* can't change other user's priorities */
STR : 		if (!check_same_owner(p))
STR : 			return -EPERM;
STR : 
STR : 		/* Normal users shall not reset the sched_reset_on_fork flag */
STR : 		if (p->sched_reset_on_fork && !reset_on_fork)
STR : 			return -EPERM;
STR : 	}
STR : 
STR : 	if (user) {
STR : 		retval = security_task_setscheduler(p);
STR : 		if (retval)
STR : 			return retval;
STR : 	}
STR : 
STR : 	/*
STR : 	 * make sure no PI-waiters arrive (or leave) while we are
STR : 	 * changing the priority of the task:
STR : 	 *
STR : 	 * To be able to change p->policy safely, the appropriate
STR : 	 * runqueue lock must be held.
STR : 	 */
STR : 	rq = task_rq_lock(p, &flags);
STR : 
STR : 	/*
STR : 	 * Changing the policy of the stop threads its a very bad idea
STR : 	 */
STR : 	if (p == rq->stop) {
STR : 		task_rq_unlock(rq, p, &flags);
STR : 		return -EINVAL;
STR : 	}
STR : 
STR : 	/*
STR : 	 * If not changing anything there's no need to proceed further:
STR : 	 */
STR : 	if (unlikely(policy == p->policy)) {
STR : 		if (fair_policy(policy) && attr->sched_nice != TASK_NICE(p))
STR : 			goto change;
STR : 		if (rt_policy(policy) && attr->sched_priority != p->rt_priority)
STR : 			goto change;
STR : 		if (dl_policy(policy))
STR : 			goto change;
STR : 
STR : 		task_rq_unlock(rq, p, &flags);
STR : 		return 0;
STR : 	}
STR : change:
STR : 
STR : 	if (user) {
STR : #ifdef CONFIG_RT_GROUP_SCHED
STR : 		/*
STR : 		 * Do not allow realtime tasks into groups that have no runtime
STR : 		 * assigned.
STR : 		 */
STR : 		if (rt_bandwidth_enabled() && rt_policy(policy) &&
STR : 				task_group(p)->rt_bandwidth.rt_runtime == 0 &&
STR : 				!task_group_is_autogroup(task_group(p))) {
STR : 			task_rq_unlock(rq, p, &flags);
STR : 			return -EPERM;
STR : 		}
STR : #endif
STR : #ifdef CONFIG_SMP
STR : 		if (dl_bandwidth_enabled() && dl_policy(policy)) {
STR : 			cpumask_t *span = rq->rd->span;
STR : 
STR : 			/*
STR : 			 * Don't allow tasks with an affinity mask smaller than
STR : 			 * the entire root_domain to become SCHED_DEADLINE. We
STR : 			 * will also fail if there's no bandwidth available.
STR : 			 */
STR : 			if (!cpumask_subset(span, &p->cpus_allowed) ||
STR : 			    rq->rd->dl_bw.bw == 0) {
STR : 				task_rq_unlock(rq, p, &flags);
STR : 				return -EPERM;
STR : 			}
STR : 		}
STR : #endif
STR : 	}
STR : 
STR : 	/* recheck policy now with rq lock held */
STR : 	if (unlikely(oldpolicy != -1 && oldpolicy != p->policy)) {
STR : 		policy = oldpolicy = -1;
STR : 		task_rq_unlock(rq, p, &flags);
STR : 		goto recheck;
STR : 	}
STR : 
STR : 	/*
STR : 	 * If setscheduling to SCHED_DEADLINE (or changing the parameters
STR : 	 * of a SCHED_DEADLINE task) we need to check if enough bandwidth
STR : 	 * is available.
STR : 	 */
STR : 	if ((dl_policy(policy) || dl_task(p)) && dl_overflow(p, policy, attr)) {
STR : 		task_rq_unlock(rq, p, &flags);
STR : 		return -EBUSY;
STR : 	}
STR : 
STR : 	on_rq = p->on_rq;
STR : 	running = task_current(rq, p);
STR : 	if (on_rq)
STR : 		dequeue_task(rq, p, 0);
STR : 	if (running)
STR : 		p->sched_class->put_prev_task(rq, p);
STR : 
STR : 	p->sched_reset_on_fork = reset_on_fork;
STR : 
STR : 	oldprio = p->prio;
STR : 	prev_class = p->sched_class;
STR : 	__setscheduler(rq, p, attr);
STR : 
STR : 	if (running)
STR : 		p->sched_class->set_curr_task(rq);
STR : 	if (on_rq)
STR : 		enqueue_task(rq, p, 0);
STR : 
STR : 	check_class_changed(rq, p, prev_class, oldprio);
STR : 	task_rq_unlock(rq, p, &flags);
STR : 
STR : 	rt_mutex_adjust_pi(p);
STR : 
STR : 	return 0;
STR : }
STR : 
STR : static int _sched_setscheduler(struct task_struct *p, int policy,
STR : 			       const struct sched_param *param, bool check)
STR : {
STR : 	struct sched_attr attr = {
STR : 		.sched_policy   = policy,
STR : 		.sched_priority = param->sched_priority,
STR : 		.sched_nice	= PRIO_TO_NICE(p->static_prio),
STR : 	};
STR : 
STR : 	/*
STR : 	 * Fixup the legacy SCHED_RESET_ON_FORK hack
STR : 	 */
STR : 	if (policy & SCHED_RESET_ON_FORK) {
STR : 		attr.sched_flags |= SCHED_FLAG_RESET_ON_FORK;
STR : 		policy &= ~SCHED_RESET_ON_FORK;
STR : 		attr.sched_policy = policy;
STR : 	}
STR : 
STR : 	return __sched_setscheduler(p, &attr, check);
STR : }
STR : /**
STR :  * sched_setscheduler - change the scheduling policy and/or RT priority of a thread.
STR :  * @p: the task in question.
STR :  * @policy: new policy.
STR :  * @param: structure containing the new RT priority.
STR :  *
STR :  * Return: 0 on success. An error code otherwise.
STR :  *
STR :  * NOTE that the task may be already dead.
STR :  */
STR : int sched_setscheduler(struct task_struct *p, int policy,
STR : 		       const struct sched_param *param)
STR : {
STR : 	return _sched_setscheduler(p, policy, param, true);
STR : }
STR : EXPORT_SYMBOL_GPL(sched_setscheduler);
STR : 
STR : int sched_setattr(struct task_struct *p, const struct sched_attr *attr)
STR : {
STR : 	return __sched_setscheduler(p, attr, true);
STR : }
STR : EXPORT_SYMBOL_GPL(sched_setattr);
STR : 
STR : /**
STR :  * sched_setscheduler_nocheck - change the scheduling policy and/or RT priority of a thread from kernelspace.
STR :  * @p: the task in question.
STR :  * @policy: new policy.
STR :  * @param: structure containing the new RT priority.
STR :  *
STR :  * Just like sched_setscheduler, only don't bother checking if the
STR :  * current context has permission.  For example, this is needed in
STR :  * stop_machine(): we create temporary high priority worker threads,
STR :  * but our caller might not have that capability.
STR :  *
STR :  * Return: 0 on success. An error code otherwise.
STR :  */
STR : int sched_setscheduler_nocheck(struct task_struct *p, int policy,
STR : 			       const struct sched_param *param)
STR : {
STR : 	return _sched_setscheduler(p, policy, param, false);
STR : }
STR : 
STR : static int
STR : do_sched_setscheduler(pid_t pid, int policy, struct sched_param __user *param)
STR : {
STR : 	struct sched_param lparam;
STR : 	struct task_struct *p;
STR : 	int retval;
STR : 
STR : 	if (!param || pid < 0)
STR : 		return -EINVAL;
STR : 	if (copy_from_user(&lparam, param, sizeof(struct sched_param)))
STR : 		return -EFAULT;
STR : 
STR : 	rcu_read_lock();
STR : 	retval = -ESRCH;
STR : 	p = find_process_by_pid(pid);
STR : 	if (p != NULL)
STR : 		retval = sched_setscheduler(p, policy, &lparam);
STR : 	rcu_read_unlock();
STR : 
STR : 	return retval;
STR : }
STR : 
STR : /*
STR :  * Mimics kernel/events/core.c perf_copy_attr().
STR :  */
STR : static int sched_copy_attr(struct sched_attr __user *uattr,
STR : 			   struct sched_attr *attr)
STR : {
STR : 	u32 size;
STR : 	int ret;
STR : 
STR : 	if (!access_ok(VERIFY_WRITE, uattr, SCHED_ATTR_SIZE_VER0))
STR : 		return -EFAULT;
STR : 
STR : 	/*
STR : 	 * zero the full structure, so that a short copy will be nice.
STR : 	 */
STR : 	memset(attr, 0, sizeof(*attr));
STR : 
STR : 	ret = get_user(size, &uattr->size);
STR : 	if (ret)
STR : 		return ret;
STR : 
STR : 	if (size > PAGE_SIZE)	/* silly large */
STR : 		goto err_size;
STR : 
STR : 	if (!size)		/* abi compat */
STR : 		size = SCHED_ATTR_SIZE_VER0;
STR : 
STR : 	if (size < SCHED_ATTR_SIZE_VER0)
STR : 		goto err_size;
STR : 
STR : 	/*
STR : 	 * If we're handed a bigger struct than we know of,
STR : 	 * ensure all the unknown bits are 0 - i.e. new
STR : 	 * user-space does not rely on any kernel feature
STR : 	 * extensions we dont know about yet.
STR : 	 */
STR : 	if (size > sizeof(*attr)) {
STR : 		unsigned char __user *addr;
STR : 		unsigned char __user *end;
STR : 		unsigned char val;
STR : 
STR : 		addr = (void __user *)uattr + sizeof(*attr);
STR : 		end  = (void __user *)uattr + size;
STR : 
STR : 		for (; addr < end; addr++) {
STR : 			ret = get_user(val, addr);
STR : 			if (ret)
STR : 				return ret;
STR : 			if (val)
STR : 				goto err_size;
STR : 		}
STR : 		size = sizeof(*attr);
STR : 	}
STR : 
STR : 	ret = copy_from_user(attr, uattr, size);
STR : 	if (ret)
STR : 		return -EFAULT;
STR : 
STR : 	/*
STR : 	 * XXX: do we want to be lenient like existing syscalls; or do we want
STR : 	 * to be strict and return an error on out-of-bounds values?
STR : 	 */
STR : 	attr->sched_nice = clamp(attr->sched_nice, -20, 19);
STR : 
STR : out:
STR : 	return ret;
STR : 
STR : err_size:
STR : 	put_user(sizeof(*attr), &uattr->size);
STR : 	ret = -E2BIG;
STR : 	goto out;
STR : }
STR : 
STR : /**
STR :  * sys_sched_setscheduler - set/change the scheduler policy and RT priority
STR :  * @pid: the pid in question.
STR :  * @policy: new policy.
STR :  * @param: structure containing the new RT priority.
STR :  *
STR :  * Return: 0 on success. An error code otherwise.
STR :  */
STR : SYSCALL_DEFINE3(sched_setscheduler, pid_t, pid, int, policy,
STR : 		struct sched_param __user *, param)
STR : {
STR : 	/* negative values for policy are not valid */
STR : 	if (policy < 0)
STR : 		return -EINVAL;
STR : 
STR : 	return do_sched_setscheduler(pid, policy, param);
STR : }
STR : 
STR : /**
STR :  * sys_sched_setparam - set/change the RT priority of a thread
STR :  * @pid: the pid in question.
STR :  * @param: structure containing the new RT priority.
STR :  *
STR :  * Return: 0 on success. An error code otherwise.
STR :  */
STR : SYSCALL_DEFINE2(sched_setparam, pid_t, pid, struct sched_param __user *, param)
STR : {
STR : 	return do_sched_setscheduler(pid, -1, param);
STR : }
STR : 
STR : /**
STR :  * sys_sched_setattr - same as above, but with extended sched_attr
STR :  * @pid: the pid in question.
STR :  * @uattr: structure containing the extended parameters.
STR :  */
STR : SYSCALL_DEFINE3(sched_setattr, pid_t, pid, struct sched_attr __user *, uattr,
STR : 			       unsigned int, flags)
STR : {
STR : 	struct sched_attr attr;
STR : 	struct task_struct *p;
STR : 	int retval;
STR : 
STR : 	if (!uattr || pid < 0 || flags)
STR : 		return -EINVAL;
STR : 
STR : 	retval = sched_copy_attr(uattr, &attr);
STR : 	if (retval)
STR : 		return retval;
STR : 
STR : 	if ((int)attr.sched_policy < 0)
STR : 		return -EINVAL;
STR : 
STR : 	rcu_read_lock();
STR : 	retval = -ESRCH;
STR : 	p = find_process_by_pid(pid);
STR : 	if (p != NULL)
STR : 		retval = sched_setattr(p, &attr);
STR : 	rcu_read_unlock();
STR : 
STR : 	return retval;
STR : }
STR : 
STR : /**
STR :  * sys_sched_getscheduler - get the policy (scheduling class) of a thread
STR :  * @pid: the pid in question.
STR :  *
STR :  * Return: On success, the policy of the thread. Otherwise, a negative error
STR :  * code.
STR :  */
STR : SYSCALL_DEFINE1(sched_getscheduler, pid_t, pid)
STR : {
STR : 	struct task_struct *p;
STR : 	int retval;
STR : 
STR : 	if (pid < 0)
STR : 		return -EINVAL;
STR : 
STR : 	retval = -ESRCH;
STR : 	rcu_read_lock();
STR : 	p = find_process_by_pid(pid);
STR : 	if (p) {
STR : 		retval = security_task_getscheduler(p);
STR : 		if (!retval)
STR : 			retval = p->policy
STR : 				| (p->sched_reset_on_fork ? SCHED_RESET_ON_FORK : 0);
STR : 	}
STR : 	rcu_read_unlock();
STR : 	return retval;
STR : }
STR : 
STR : /**
STR :  * sys_sched_getparam - get the RT priority of a thread
STR :  * @pid: the pid in question.
STR :  * @param: structure containing the RT priority.
STR :  *
STR :  * Return: On success, 0 and the RT priority is in @param. Otherwise, an error
STR :  * code.
STR :  */
STR : SYSCALL_DEFINE2(sched_getparam, pid_t, pid, struct sched_param __user *, param)
STR : {
STR : 	struct sched_param lp = { .sched_priority = 0 };
STR : 	struct task_struct *p;
STR : 	int retval;
STR : 
STR : 	if (!param || pid < 0)
STR : 		return -EINVAL;
STR : 
STR : 	rcu_read_lock();
STR : 	p = find_process_by_pid(pid);
STR : 	retval = -ESRCH;
STR : 	if (!p)
STR : 		goto out_unlock;
STR : 
STR : 	retval = security_task_getscheduler(p);
STR : 	if (retval)
STR : 		goto out_unlock;
STR : 
STR : 	if (task_has_rt_policy(p))
STR : 		lp.sched_priority = p->rt_priority;
STR : 	rcu_read_unlock();
STR : 
STR : 	/*
STR : 	 * This one might sleep, we cannot do it with a spinlock held ...
STR : 	 */
STR : 	retval = copy_to_user(param, &lp, sizeof(*param)) ? -EFAULT : 0;
STR : 
STR : 	return retval;
STR : 
STR : out_unlock:
STR : 	rcu_read_unlock();
STR : 	return retval;
STR : }
STR : 
STR : static int sched_read_attr(struct sched_attr __user *uattr,
STR : 			   struct sched_attr *attr,
STR : 			   unsigned int usize)
STR : {
STR : 	int ret;
STR : 
STR : 	if (!access_ok(VERIFY_WRITE, uattr, usize))
STR : 		return -EFAULT;
STR : 
STR : 	/*
STR : 	 * If we're handed a smaller struct than we know of,
STR : 	 * ensure all the unknown bits are 0 - i.e. old
STR : 	 * user-space does not get uncomplete information.
STR : 	 */
STR : 	if (usize < sizeof(*attr)) {
STR : 		unsigned char *addr;
STR : 		unsigned char *end;
STR : 
STR : 		addr = (void *)attr + usize;
STR : 		end  = (void *)attr + sizeof(*attr);
STR : 
STR : 		for (; addr < end; addr++) {
STR : 			if (*addr)
STR : 				goto err_size;
STR : 		}
STR : 
STR : 		attr->size = usize;
STR : 	}
STR : 
STR : 	ret = copy_to_user(uattr, attr, attr->size);
STR : 	if (ret)
STR : 		return -EFAULT;
STR : 
STR : out:
STR : 	return ret;
STR : 
STR : err_size:
STR : 	ret = -E2BIG;
STR : 	goto out;
STR : }
STR : 
STR : /**
STR :  * sys_sched_getattr - similar to sched_getparam, but with sched_attr
STR :  * @pid: the pid in question.
STR :  * @uattr: structure containing the extended parameters.
STR :  * @size: sizeof(attr) for fwd/bwd comp.
STR :  */
STR : SYSCALL_DEFINE4(sched_getattr, pid_t, pid, struct sched_attr __user *, uattr,
STR : 		unsigned int, size, unsigned int, flags)
STR : {
STR : 	struct sched_attr attr = {
STR : 		.size = sizeof(struct sched_attr),
STR : 	};
STR : 	struct task_struct *p;
STR : 	int retval;
STR : 
STR : 	if (!uattr || pid < 0 || size > PAGE_SIZE ||
STR : 	    size < SCHED_ATTR_SIZE_VER0 || flags)
STR : 		return -EINVAL;
STR : 
STR : 	rcu_read_lock();
STR : 	p = find_process_by_pid(pid);
STR : 	retval = -ESRCH;
STR : 	if (!p)
STR : 		goto out_unlock;
STR : 
STR : 	retval = security_task_getscheduler(p);
STR : 	if (retval)
STR : 		goto out_unlock;
STR : 
STR : 	attr.sched_policy = p->policy;
STR : 	if (p->sched_reset_on_fork)
STR : 		attr.sched_flags |= SCHED_FLAG_RESET_ON_FORK;
STR : 	if (task_has_dl_policy(p))
STR : 		__getparam_dl(p, &attr);
STR : 	else if (task_has_rt_policy(p))
STR : 		attr.sched_priority = p->rt_priority;
STR : 	else
STR : 		attr.sched_nice = TASK_NICE(p);
STR : 
STR : 	rcu_read_unlock();
STR : 
STR : 	retval = sched_read_attr(uattr, &attr, size);
STR : 	return retval;
STR : 
STR : out_unlock:
STR : 	rcu_read_unlock();
STR : 	return retval;
STR : }
STR : 
STR : long sched_setaffinity(pid_t pid, const struct cpumask *in_mask)
STR : {
STR : 	cpumask_var_t cpus_allowed, new_mask;
STR : 	struct task_struct *p;
STR : 	int retval;
STR : 
STR : 	rcu_read_lock();
STR : 
STR : 	p = find_process_by_pid(pid);
STR : 	if (!p) {
STR : 		rcu_read_unlock();
STR : 		return -ESRCH;
STR : 	}
STR : 
STR : 	/* Prevent p going away */
STR : 	get_task_struct(p);
STR : 	rcu_read_unlock();
STR : 
STR : 	if (p->flags & PF_NO_SETAFFINITY) {
STR : 		retval = -EINVAL;
STR : 		goto out_put_task;
STR : 	}
STR : 	if (!alloc_cpumask_var(&cpus_allowed, GFP_KERNEL)) {
STR : 		retval = -ENOMEM;
STR : 		goto out_put_task;
STR : 	}
STR : 	if (!alloc_cpumask_var(&new_mask, GFP_KERNEL)) {
STR : 		retval = -ENOMEM;
STR : 		goto out_free_cpus_allowed;
STR : 	}
STR : 	retval = -EPERM;
STR : 	if (!check_same_owner(p)) {
STR : 		rcu_read_lock();
STR : 		if (!ns_capable(__task_cred(p)->user_ns, CAP_SYS_NICE)) {
STR : 			rcu_read_unlock();
STR : 			goto out_unlock;
STR : 		}
STR : 		rcu_read_unlock();
STR : 	}
STR : 
STR : 	retval = security_task_setscheduler(p);
STR : 	if (retval)
STR : 		goto out_unlock;
STR : 
STR : 
STR : 	cpuset_cpus_allowed(p, cpus_allowed);
STR : 	cpumask_and(new_mask, in_mask, cpus_allowed);
STR : 
STR : 	/*
STR : 	 * Since bandwidth control happens on root_domain basis,
STR : 	 * if admission test is enabled, we only admit -deadline
STR : 	 * tasks allowed to run on all the CPUs in the task's
STR : 	 * root_domain.
STR : 	 */
STR : #ifdef CONFIG_SMP
STR : 	if (task_has_dl_policy(p)) {
STR : 		const struct cpumask *span = task_rq(p)->rd->span;
STR : 
STR : 		if (dl_bandwidth_enabled() && !cpumask_subset(span, new_mask)) {
STR : 			retval = -EBUSY;
STR : 			goto out_unlock;
STR : 		}
STR : 	}
STR : #endif
STR : again:
STR : 	retval = set_cpus_allowed_ptr(p, new_mask);
STR : 
STR : 	if (!retval) {
STR : 		cpuset_cpus_allowed(p, cpus_allowed);
STR : 		if (!cpumask_subset(new_mask, cpus_allowed)) {
STR : 			/*
STR : 			 * We must have raced with a concurrent cpuset
STR : 			 * update. Just reset the cpus_allowed to the
STR : 			 * cpuset's cpus_allowed
STR : 			 */
STR : 			cpumask_copy(new_mask, cpus_allowed);
STR : 			goto again;
STR : 		}
STR : 	}
STR : out_unlock:
STR : 	free_cpumask_var(new_mask);
STR : out_free_cpus_allowed:
STR : 	free_cpumask_var(cpus_allowed);
STR : out_put_task:
STR : 	put_task_struct(p);
STR : 	return retval;
STR : }
STR : 
STR : static int get_user_cpu_mask(unsigned long __user *user_mask_ptr, unsigned len,
STR : 			     struct cpumask *new_mask)
STR : {
STR : 	if (len < cpumask_size())
STR : 		cpumask_clear(new_mask);
STR : 	else if (len > cpumask_size())
STR : 		len = cpumask_size();
STR : 
STR : 	return copy_from_user(new_mask, user_mask_ptr, len) ? -EFAULT : 0;
STR : }
STR : 
STR : /**
STR :  * sys_sched_setaffinity - set the cpu affinity of a process
STR :  * @pid: pid of the process
STR :  * @len: length in bytes of the bitmask pointed to by user_mask_ptr
STR :  * @user_mask_ptr: user-space pointer to the new cpu mask
STR :  *
STR :  * Return: 0 on success. An error code otherwise.
STR :  */
STR : SYSCALL_DEFINE3(sched_setaffinity, pid_t, pid, unsigned int, len,
STR : 		unsigned long __user *, user_mask_ptr)
STR : {
STR : 	cpumask_var_t new_mask;
STR : 	int retval;
STR : 
STR : 	if (!alloc_cpumask_var(&new_mask, GFP_KERNEL))
STR : 		return -ENOMEM;
STR : 
STR : 	retval = get_user_cpu_mask(user_mask_ptr, len, new_mask);
STR : 	if (retval == 0)
STR : 		retval = sched_setaffinity(pid, new_mask);
STR : 	free_cpumask_var(new_mask);
STR : 	return retval;
STR : }
STR : 
STR : long sched_getaffinity(pid_t pid, struct cpumask *mask)
STR : {
STR : 	struct task_struct *p;
STR : 	unsigned long flags;
STR : 	int retval;
STR : 
STR : 	rcu_read_lock();
STR : 
STR : 	retval = -ESRCH;
STR : 	p = find_process_by_pid(pid);
STR : 	if (!p)
STR : 		goto out_unlock;
STR : 
STR : 	retval = security_task_getscheduler(p);
STR : 	if (retval)
STR : 		goto out_unlock;
STR : 
STR : 	raw_spin_lock_irqsave(&p->pi_lock, flags);
STR : 	cpumask_and(mask, &p->cpus_allowed, cpu_active_mask);
STR : 	raw_spin_unlock_irqrestore(&p->pi_lock, flags);
STR : 
STR : out_unlock:
STR : 	rcu_read_unlock();
STR : 
STR : 	return retval;
STR : }
STR : 
STR : /**
STR :  * sys_sched_getaffinity - get the cpu affinity of a process
STR :  * @pid: pid of the process
STR :  * @len: length in bytes of the bitmask pointed to by user_mask_ptr
STR :  * @user_mask_ptr: user-space pointer to hold the current cpu mask
STR :  *
STR :  * Return: 0 on success. An error code otherwise.
STR :  */
STR : SYSCALL_DEFINE3(sched_getaffinity, pid_t, pid, unsigned int, len,
STR : 		unsigned long __user *, user_mask_ptr)
STR : {
STR : 	int ret;
STR : 	cpumask_var_t mask;
STR : 
STR : 	if ((len * BITS_PER_BYTE) < nr_cpu_ids)
STR : 		return -EINVAL;
STR : 	if (len & (sizeof(unsigned long)-1))
STR : 		return -EINVAL;
STR : 
STR : 	if (!alloc_cpumask_var(&mask, GFP_KERNEL))
STR : 		return -ENOMEM;
STR : 
STR : 	ret = sched_getaffinity(pid, mask);
STR : 	if (ret == 0) {
STR : 		size_t retlen = min_t(size_t, len, cpumask_size());
STR : 
STR : 		if (copy_to_user(user_mask_ptr, mask, retlen))
STR : 			ret = -EFAULT;
STR : 		else
STR : 			ret = retlen;
STR : 	}
STR : 	free_cpumask_var(mask);
STR : 
STR : 	return ret;
STR : }
STR : 
STR : /**
STR :  * sys_sched_yield - yield the current processor to other threads.
STR :  *
STR :  * This function yields the current CPU to other tasks. If there are no
STR :  * other threads running on this CPU then this function will return.
STR :  *
STR :  * Return: 0.
STR :  */
STR : SYSCALL_DEFINE0(sched_yield)
STR : {
STR : 	struct rq *rq = this_rq_lock();
STR : 
STR : 	schedstat_inc(rq, yld_count);
STR : 	current->sched_class->yield_task(rq);
STR : 
STR : 	/*
STR : 	 * Since we are going to call schedule() anyway, there's
STR : 	 * no need to preempt or enable interrupts:
STR : 	 */
STR : 	__release(rq->lock);
STR : 	spin_release(&rq->lock.dep_map, 1, _THIS_IP_);
STR : 	do_raw_spin_unlock(&rq->lock);
STR : 	sched_preempt_enable_no_resched();
STR : 
STR : 	schedule();
STR : 
STR : 	return 0;
STR : }
STR : 
STR : static void __cond_resched(void)
STR : {
STR : 	__preempt_count_add(PREEMPT_ACTIVE);
STR : 	__schedule();
STR : 	__preempt_count_sub(PREEMPT_ACTIVE);
STR : }
STR : 
STR : int __sched _cond_resched(void)
STR : {
STR : 	if (should_resched()) {
STR : 		__cond_resched();
STR : 		return 1;
STR : 	}
STR : 	return 0;
STR : }
STR : EXPORT_SYMBOL(_cond_resched);
STR : 
STR : /*
STR :  * __cond_resched_lock() - if a reschedule is pending, drop the given lock,
STR :  * call schedule, and on return reacquire the lock.
STR :  *
STR :  * This works OK both with and without CONFIG_PREEMPT. We do strange low-level
STR :  * operations here to prevent schedule() from being called twice (once via
STR :  * spin_unlock(), once by hand).
STR :  */
STR : int __cond_resched_lock(spinlock_t *lock)
STR : {
STR : 	int resched = should_resched();
STR : 	int ret = 0;
STR : 
STR : 	lockdep_assert_held(lock);
STR : 
STR : 	if (spin_needbreak(lock) || resched) {
STR : 		spin_unlock(lock);
STR : 		if (resched)
STR : 			__cond_resched();
STR : 		else
STR : 			cpu_relax();
STR : 		ret = 1;
STR : 		spin_lock(lock);
STR : 	}
STR : 	return ret;
STR : }
STR : EXPORT_SYMBOL(__cond_resched_lock);
STR : 
STR : int __sched __cond_resched_softirq(void)
STR : {
STR : 	BUG_ON(!in_softirq());
STR : 
STR : 	if (should_resched()) {
STR : 		local_bh_enable();
STR : 		__cond_resched();
STR : 		local_bh_disable();
STR : 		return 1;
STR : 	}
STR : 	return 0;
STR : }
STR : EXPORT_SYMBOL(__cond_resched_softirq);
STR : 
STR : /**
STR :  * yield - yield the current processor to other threads.
STR :  *
STR :  * Do not ever use this function, there's a 99% chance you're doing it wrong.
STR :  *
STR :  * The scheduler is at all times free to pick the calling task as the most
STR :  * eligible task to run, if removing the yield() call from your code breaks
STR :  * it, its already broken.
STR :  *
STR :  * Typical broken usage is:
STR :  *
STR :  * while (!event)
STR :  * 	yield();
STR :  *
STR :  * where one assumes that yield() will let 'the other' process run that will
STR :  * make event true. If the current task is a SCHED_FIFO task that will never
STR :  * happen. Never use yield() as a progress guarantee!!
STR :  *
STR :  * If you want to use yield() to wait for something, use wait_event().
STR :  * If you want to use yield() to be 'nice' for others, use cond_resched().
STR :  * If you still want to use yield(), do not!
STR :  */
STR : void __sched yield(void)
STR : {
STR : 	set_current_state(TASK_RUNNING);
STR : 	sys_sched_yield();
STR : }
STR : EXPORT_SYMBOL(yield);
STR : 
STR : /**
STR :  * yield_to - yield the current processor to another thread in
STR :  * your thread group, or accelerate that thread toward the
STR :  * processor it's on.
STR :  * @p: target task
STR :  * @preempt: whether task preemption is allowed or not
STR :  *
STR :  * It's the caller's job to ensure that the target task struct
STR :  * can't go away on us before we can do any checks.
STR :  *
STR :  * Return:
STR :  *	true (>0) if we indeed boosted the target task.
STR :  *	false (0) if we failed to boost the target.
STR :  *	-ESRCH if there's no task to yield to.
STR :  */
STR : bool __sched yield_to(struct task_struct *p, bool preempt)
STR : {
STR : 	struct task_struct *curr = current;
STR : 	struct rq *rq, *p_rq;
STR : 	unsigned long flags;
STR : 	int yielded = 0;
STR : 
STR : 	local_irq_save(flags);
STR : 	rq = this_rq();
STR : 
STR : again:
STR : 	p_rq = task_rq(p);
STR : 	/*
STR : 	 * If we're the only runnable task on the rq and target rq also
STR : 	 * has only one task, there's absolutely no point in yielding.
STR : 	 */
STR : 	if (rq->nr_running == 1 && p_rq->nr_running == 1) {
STR : 		yielded = -ESRCH;
STR : 		goto out_irq;
STR : 	}
STR : 
STR : 	double_rq_lock(rq, p_rq);
STR : 	if (task_rq(p) != p_rq) {
STR : 		double_rq_unlock(rq, p_rq);
STR : 		goto again;
STR : 	}
STR : 
STR : 	if (!curr->sched_class->yield_to_task)
STR : 		goto out_unlock;
STR : 
STR : 	if (curr->sched_class != p->sched_class)
STR : 		goto out_unlock;
STR : 
STR : 	if (task_running(p_rq, p) || p->state)
STR : 		goto out_unlock;
STR : 
STR : 	yielded = curr->sched_class->yield_to_task(rq, p, preempt);
STR : 	if (yielded) {
STR : 		schedstat_inc(rq, yld_count);
STR : 		/*
STR : 		 * Make p's CPU reschedule; pick_next_entity takes care of
STR : 		 * fairness.
STR : 		 */
STR : 		if (preempt && rq != p_rq)
STR : 			resched_task(p_rq->curr);
STR : 	}
STR : 
STR : out_unlock:
STR : 	double_rq_unlock(rq, p_rq);
STR : out_irq:
STR : 	local_irq_restore(flags);
STR : 
STR : 	if (yielded > 0)
STR : 		schedule();
STR : 
STR : 	return yielded;
STR : }
STR : EXPORT_SYMBOL_GPL(yield_to);
STR : 
STR : /*
STR :  * This task is about to go to sleep on IO. Increment rq->nr_iowait so
STR :  * that process accounting knows that this is a task in IO wait state.
STR :  */
STR : void __sched io_schedule(void)
STR : {
STR : 	struct rq *rq = raw_rq();
STR : 
STR : 	delayacct_blkio_start();
STR : 	atomic_inc(&rq->nr_iowait);
STR : 	blk_flush_plug(current);
STR : 	current->in_iowait = 1;
STR : 	schedule();
STR : 	current->in_iowait = 0;
STR : 	atomic_dec(&rq->nr_iowait);
STR : 	delayacct_blkio_end();
STR : }
STR : EXPORT_SYMBOL(io_schedule);
STR : 
STR : long __sched io_schedule_timeout(long timeout)
STR : {
STR : 	struct rq *rq = raw_rq();
STR : 	long ret;
STR : 
STR : 	delayacct_blkio_start();
STR : 	atomic_inc(&rq->nr_iowait);
STR : 	blk_flush_plug(current);
STR : 	current->in_iowait = 1;
STR : 	ret = schedule_timeout(timeout);
STR : 	current->in_iowait = 0;
STR : 	atomic_dec(&rq->nr_iowait);
STR : 	delayacct_blkio_end();
STR : 	return ret;
STR : }
STR : 
STR : /**
STR :  * sys_sched_get_priority_max - return maximum RT priority.
STR :  * @policy: scheduling class.
STR :  *
STR :  * Return: On success, this syscall returns the maximum
STR :  * rt_priority that can be used by a given scheduling class.
STR :  * On failure, a negative error code is returned.
STR :  */
STR : SYSCALL_DEFINE1(sched_get_priority_max, int, policy)
STR : {
STR : 	int ret = -EINVAL;
STR : 
STR : 	switch (policy) {
STR : 	case SCHED_FIFO:
STR : 	case SCHED_RR:
STR : 		ret = MAX_USER_RT_PRIO-1;
STR : 		break;
STR : 	case SCHED_DEADLINE:
STR : 	case SCHED_NORMAL:
STR : 	case SCHED_BATCH:
STR : 	case SCHED_IDLE:
STR : 		ret = 0;
STR : 		break;
STR : 	}
STR : 	return ret;
STR : }
STR : 
STR : /**
STR :  * sys_sched_get_priority_min - return minimum RT priority.
STR :  * @policy: scheduling class.
STR :  *
STR :  * Return: On success, this syscall returns the minimum
STR :  * rt_priority that can be used by a given scheduling class.
STR :  * On failure, a negative error code is returned.
STR :  */
STR : SYSCALL_DEFINE1(sched_get_priority_min, int, policy)
STR : {
STR : 	int ret = -EINVAL;
STR : 
STR : 	switch (policy) {
STR : 	case SCHED_FIFO:
STR : 	case SCHED_RR:
STR : 		ret = 1;
STR : 		break;
STR : 	case SCHED_DEADLINE:
STR : 	case SCHED_NORMAL:
STR : 	case SCHED_BATCH:
STR : 	case SCHED_IDLE:
STR : 		ret = 0;
STR : 	}
STR : 	return ret;
STR : }
STR : 
STR : /**
STR :  * sys_sched_rr_get_interval - return the default timeslice of a process.
STR :  * @pid: pid of the process.
STR :  * @interval: userspace pointer to the timeslice value.
STR :  *
STR :  * this syscall writes the default timeslice value of a given process
STR :  * into the user-space timespec buffer. A value of '0' means infinity.
STR :  *
STR :  * Return: On success, 0 and the timeslice is in @interval. Otherwise,
STR :  * an error code.
STR :  */
STR : SYSCALL_DEFINE2(sched_rr_get_interval, pid_t, pid,
STR : 		struct timespec __user *, interval)
STR : {
STR : 	struct task_struct *p;
STR : 	unsigned int time_slice;
STR : 	unsigned long flags;
STR : 	struct rq *rq;
STR : 	int retval;
STR : 	struct timespec t;
STR : 
STR : 	if (pid < 0)
STR : 		return -EINVAL;
STR : 
STR : 	retval = -ESRCH;
STR : 	rcu_read_lock();
STR : 	p = find_process_by_pid(pid);
STR : 	if (!p)
STR : 		goto out_unlock;
STR : 
STR : 	retval = security_task_getscheduler(p);
STR : 	if (retval)
STR : 		goto out_unlock;
STR : 
STR : 	rq = task_rq_lock(p, &flags);
STR : 	time_slice = 0;
STR : 	if (p->sched_class->get_rr_interval)
STR : 		time_slice = p->sched_class->get_rr_interval(rq, p);
STR : 	task_rq_unlock(rq, p, &flags);
STR : 
STR : 	rcu_read_unlock();
STR : 	jiffies_to_timespec(time_slice, &t);
STR : 	retval = copy_to_user(interval, &t, sizeof(t)) ? -EFAULT : 0;
STR : 	return retval;
STR : 
STR : out_unlock:
STR : 	rcu_read_unlock();
STR : 	return retval;
STR : }
STR : 
STR : static const char stat_nam[] = TASK_STATE_TO_CHAR_STR;
STR : 
STR : void sched_show_task(struct task_struct *p)
STR : {
STR : 	unsigned long free = 0;
STR : 	int ppid;
STR : 	unsigned state;
STR : 
STR : 	state = p->state ? __ffs(p->state) + 1 : 0;
STR : 	printk(KERN_INFO "%-15.15s %c", p->comm,
STR : 		state < sizeof(stat_nam) - 1 ? stat_nam[state] : '?');
STR : #if BITS_PER_LONG == 32
STR : 	if (state == TASK_RUNNING)
STR : 		printk(KERN_CONT " running  ");
STR : 	else
STR : 		printk(KERN_CONT " %08lx ", thread_saved_pc(p));
STR : #else
STR : 	if (state == TASK_RUNNING)
STR : 		printk(KERN_CONT "  running task    ");
STR : 	else
STR : 		printk(KERN_CONT " %016lx ", thread_saved_pc(p));
STR : #endif
STR : #ifdef CONFIG_DEBUG_STACK_USAGE
STR : 	free = stack_not_used(p);
STR : #endif
STR : 	rcu_read_lock();
STR : 	ppid = task_pid_nr(rcu_dereference(p->real_parent));
STR : 	rcu_read_unlock();
STR : 	printk(KERN_CONT "%5lu %5d %6d 0x%08lx\n", free,
STR : 		task_pid_nr(p), ppid,
STR : 		(unsigned long)task_thread_info(p)->flags);
STR : 
STR : 	print_worker_info(KERN_INFO, p);
STR : 	show_stack(p, NULL);
STR : }
STR : 
STR : void show_state_filter(unsigned long state_filter)
STR : {
STR : 	struct task_struct *g, *p;
STR : 
STR : #if BITS_PER_LONG == 32
STR : 	printk(KERN_INFO
STR : 		"  task                PC stack   pid father\n");
STR : #else
STR : 	printk(KERN_INFO
STR : 		"  task                        PC stack   pid father\n");
STR : #endif
STR : 	rcu_read_lock();
STR : 	do_each_thread(g, p) {
STR : 		/*
STR : 		 * reset the NMI-timeout, listing all files on a slow
STR : 		 * console might take a lot of time:
STR : 		 */
STR : 		touch_nmi_watchdog();
STR : 		if (!state_filter || (p->state & state_filter))
STR : 			sched_show_task(p);
STR : 	} while_each_thread(g, p);
STR : 
STR : 	touch_all_softlockup_watchdogs();
STR : 
STR : #ifdef CONFIG_SCHED_DEBUG
STR : 	sysrq_sched_debug_show();
STR : #endif
STR : 	rcu_read_unlock();
STR : 	/*
STR : 	 * Only show locks if all tasks are dumped:
STR : 	 */
STR : 	if (!state_filter)
STR : 		debug_show_all_locks();
STR : }
STR : 
STR : void init_idle_bootup_task(struct task_struct *idle)
STR : {
STR : 	idle->sched_class = &idle_sched_class;
STR : }
STR : 
STR : /**
STR :  * init_idle - set up an idle thread for a given CPU
STR :  * @idle: task in question
STR :  * @cpu: cpu the idle task belongs to
STR :  *
STR :  * NOTE: this function does not set the idle thread's NEED_RESCHED
STR :  * flag, to make booting more robust.
STR :  */
STR : void init_idle(struct task_struct *idle, int cpu)
STR : {
STR : 	struct rq *rq = cpu_rq(cpu);
STR : 	unsigned long flags;
STR : 
STR : 	raw_spin_lock_irqsave(&rq->lock, flags);
STR : 
STR : 	__sched_fork(0, idle);
STR : 	idle->state = TASK_RUNNING;
STR : 	idle->se.exec_start = sched_clock();
STR : 
STR : 	do_set_cpus_allowed(idle, cpumask_of(cpu));
STR : 	/*
STR : 	 * We're having a chicken and egg problem, even though we are
STR : 	 * holding rq->lock, the cpu isn't yet set to this cpu so the
STR : 	 * lockdep check in task_group() will fail.
STR : 	 *
STR : 	 * Similar case to sched_fork(). / Alternatively we could
STR : 	 * use task_rq_lock() here and obtain the other rq->lock.
STR : 	 *
STR : 	 * Silence PROVE_RCU
STR : 	 */
STR : 	rcu_read_lock();
STR : 	__set_task_cpu(idle, cpu);
STR : 	rcu_read_unlock();
STR : 
STR : 	rq->curr = rq->idle = idle;
STR : #if defined(CONFIG_SMP)
STR : 	idle->on_cpu = 1;
STR : #endif
STR : 	raw_spin_unlock_irqrestore(&rq->lock, flags);
STR : 
STR : 	/* Set the preempt count _outside_ the spinlocks! */
STR : 	init_idle_preempt_count(idle, cpu);
STR : 
STR : 	/*
STR : 	 * The idle tasks have their own, simple scheduling class:
STR : 	 */
STR : 	idle->sched_class = &idle_sched_class;
STR : 	ftrace_graph_init_idle_task(idle, cpu);
STR : 	vtime_init_idle(idle, cpu);
STR : #if defined(CONFIG_SMP)
STR : 	sprintf(idle->comm, "%s/%d", INIT_TASK_COMM, cpu);
STR : #endif
STR : }
STR : 
STR : #ifdef CONFIG_SMP
STR : void do_set_cpus_allowed(struct task_struct *p, const struct cpumask *new_mask)
STR : {
STR : 	if (p->sched_class && p->sched_class->set_cpus_allowed)
STR : 		p->sched_class->set_cpus_allowed(p, new_mask);
STR : 
STR : 	cpumask_copy(&p->cpus_allowed, new_mask);
STR : 	p->nr_cpus_allowed = cpumask_weight(new_mask);
STR : }
STR : 
STR : /*
STR :  * This is how migration works:
STR :  *
STR :  * 1) we invoke migration_cpu_stop() on the target CPU using
STR :  *    stop_one_cpu().
STR :  * 2) stopper starts to run (implicitly forcing the migrated thread
STR :  *    off the CPU)
STR :  * 3) it checks whether the migrated task is still in the wrong runqueue.
STR :  * 4) if it's in the wrong runqueue then the migration thread removes
STR :  *    it and puts it into the right queue.
STR :  * 5) stopper completes and stop_one_cpu() returns and the migration
STR :  *    is done.
STR :  */
STR : 
STR : /*
STR :  * Change a given task's CPU affinity. Migrate the thread to a
STR :  * proper CPU and schedule it away if the CPU it's executing on
STR :  * is removed from the allowed bitmask.
STR :  *
STR :  * NOTE: the caller must have a valid reference to the task, the
STR :  * task must not exit() & deallocate itself prematurely. The
STR :  * call is not atomic; no spinlocks may be held.
STR :  */
STR : int set_cpus_allowed_ptr(struct task_struct *p, const struct cpumask *new_mask)
STR : {
STR : 	unsigned long flags;
STR : 	struct rq *rq;
STR : 	unsigned int dest_cpu;
STR : 	int ret = 0;
STR : 
STR : 	rq = task_rq_lock(p, &flags);
STR : 
STR : 	if (cpumask_equal(&p->cpus_allowed, new_mask))
STR : 		goto out;
STR : 
STR : 	if (!cpumask_intersects(new_mask, cpu_active_mask)) {
STR : 		ret = -EINVAL;
STR : 		goto out;
STR : 	}
STR : 
STR : 	do_set_cpus_allowed(p, new_mask);
STR : 
STR : 	/* Can the task run on the task's current CPU? If so, we're done */
STR : 	if (cpumask_test_cpu(task_cpu(p), new_mask))
STR : 		goto out;
STR : 
STR : 	dest_cpu = cpumask_any_and(cpu_active_mask, new_mask);
STR : 	if (p->on_rq) {
STR : 		struct migration_arg arg = { p, dest_cpu };
STR : 		/* Need help from migration thread: drop lock and wait. */
STR : 		task_rq_unlock(rq, p, &flags);
STR : 		stop_one_cpu(cpu_of(rq), migration_cpu_stop, &arg);
STR : 		tlb_migrate_finish(p->mm);
STR : 		return 0;
STR : 	}
STR : out:
STR : 	task_rq_unlock(rq, p, &flags);
STR : 
STR : 	return ret;
STR : }
STR : EXPORT_SYMBOL_GPL(set_cpus_allowed_ptr);
STR : 
STR : /*
STR :  * Move (not current) task off this cpu, onto dest cpu. We're doing
STR :  * this because either it can't run here any more (set_cpus_allowed()
STR :  * away from this CPU, or CPU going down), or because we're
STR :  * attempting to rebalance this task on exec (sched_exec).
STR :  *
STR :  * So we race with normal scheduler movements, but that's OK, as long
STR :  * as the task is no longer on this CPU.
STR :  *
STR :  * Returns non-zero if task was successfully migrated.
STR :  */
STR : static int __migrate_task(struct task_struct *p, int src_cpu, int dest_cpu)
STR : {
STR : 	struct rq *rq_dest, *rq_src;
STR : 	int ret = 0;
STR : 
STR : 	if (unlikely(!cpu_active(dest_cpu)))
STR : 		return ret;
STR : 
STR : 	rq_src = cpu_rq(src_cpu);
STR : 	rq_dest = cpu_rq(dest_cpu);
STR : 
STR : 	raw_spin_lock(&p->pi_lock);
STR : 	double_rq_lock(rq_src, rq_dest);
STR : 	/* Already moved. */
STR : 	if (task_cpu(p) != src_cpu)
STR : 		goto done;
STR : 	/* Affinity changed (again). */
STR : 	if (!cpumask_test_cpu(dest_cpu, tsk_cpus_allowed(p)))
STR : 		goto fail;
STR : 
STR : 	/*
STR : 	 * If we're not on a rq, the next wake-up will ensure we're
STR : 	 * placed properly.
STR : 	 */
STR : 	if (p->on_rq) {
STR : 		dequeue_task(rq_src, p, 0);
STR : 		set_task_cpu(p, dest_cpu);
STR : 		enqueue_task(rq_dest, p, 0);
STR : 		check_preempt_curr(rq_dest, p, 0);
STR : 	}
STR : done:
STR : 	ret = 1;
STR : fail:
STR : 	double_rq_unlock(rq_src, rq_dest);
STR : 	raw_spin_unlock(&p->pi_lock);
STR : 	return ret;
STR : }
STR : 
STR : #ifdef CONFIG_NUMA_BALANCING
STR : /* Migrate current task p to target_cpu */
STR : int migrate_task_to(struct task_struct *p, int target_cpu)
STR : {
STR : 	struct migration_arg arg = { p, target_cpu };
STR : 	int curr_cpu = task_cpu(p);
STR : 
STR : 	if (curr_cpu == target_cpu)
STR : 		return 0;
STR : 
STR : 	if (!cpumask_test_cpu(target_cpu, tsk_cpus_allowed(p)))
STR : 		return -EINVAL;
STR : 
STR : 	/* TODO: This is not properly updating schedstats */
STR : 
STR : 	trace_sched_move_numa(p, curr_cpu, target_cpu);
STR : 	return stop_one_cpu(curr_cpu, migration_cpu_stop, &arg);
STR : }
STR : 
STR : /*
STR :  * Requeue a task on a given node and accurately track the number of NUMA
STR :  * tasks on the runqueues
STR :  */
STR : void sched_setnuma(struct task_struct *p, int nid)
STR : {
STR : 	struct rq *rq;
STR : 	unsigned long flags;
STR : 	bool on_rq, running;
STR : 
STR : 	rq = task_rq_lock(p, &flags);
STR : 	on_rq = p->on_rq;
STR : 	running = task_current(rq, p);
STR : 
STR : 	if (on_rq)
STR : 		dequeue_task(rq, p, 0);
STR : 	if (running)
STR : 		p->sched_class->put_prev_task(rq, p);
STR : 
STR : 	p->numa_preferred_nid = nid;
STR : 
STR : 	if (running)
STR : 		p->sched_class->set_curr_task(rq);
STR : 	if (on_rq)
STR : 		enqueue_task(rq, p, 0);
STR : 	task_rq_unlock(rq, p, &flags);
STR : }
STR : #endif
STR : 
STR : /*
STR :  * migration_cpu_stop - this will be executed by a highprio stopper thread
STR :  * and performs thread migration by bumping thread off CPU then
STR :  * 'pushing' onto another runqueue.
STR :  */
STR : static int migration_cpu_stop(void *data)
STR : {
STR : 	struct migration_arg *arg = data;
STR : 
STR : 	/*
STR : 	 * The original target cpu might have gone down and we might
STR : 	 * be on another cpu but it doesn't matter.
STR : 	 */
STR : 	local_irq_disable();
STR : 	__migrate_task(arg->task, raw_smp_processor_id(), arg->dest_cpu);
STR : 	local_irq_enable();
STR : 	return 0;
STR : }
STR : 
STR : #ifdef CONFIG_HOTPLUG_CPU
STR : 
STR : /*
STR :  * Ensures that the idle task is using init_mm right before its cpu goes
STR :  * offline.
STR :  */
STR : void idle_task_exit(void)
STR : {
STR : 	struct mm_struct *mm = current->active_mm;
STR : 
STR : 	BUG_ON(cpu_online(smp_processor_id()));
STR : 
STR : 	if (mm != &init_mm)
STR : 		switch_mm(mm, &init_mm, current);
STR : 	mmdrop(mm);
STR : }
STR : 
STR : /*
STR :  * Since this CPU is going 'away' for a while, fold any nr_active delta
STR :  * we might have. Assumes we're called after migrate_tasks() so that the
STR :  * nr_active count is stable.
STR :  *
STR :  * Also see the comment "Global load-average calculations".
STR :  */
STR : static void calc_load_migrate(struct rq *rq)
STR : {
STR : 	long delta = calc_load_fold_active(rq);
STR : 	if (delta)
STR : 		atomic_long_add(delta, &calc_load_tasks);
STR : }
STR : 
STR : /*
STR :  * Migrate all tasks from the rq, sleeping tasks will be migrated by
STR :  * try_to_wake_up()->select_task_rq().
STR :  *
STR :  * Called with rq->lock held even though we'er in stop_machine() and
STR :  * there's no concurrency possible, we hold the required locks anyway
STR :  * because of lock validation efforts.
STR :  */
STR : static void migrate_tasks(unsigned int dead_cpu)
STR : {
STR : 	struct rq *rq = cpu_rq(dead_cpu);
STR : 	struct task_struct *next, *stop = rq->stop;
STR : 	int dest_cpu;
STR : 
STR : 	/*
STR : 	 * Fudge the rq selection such that the below task selection loop
STR : 	 * doesn't get stuck on the currently eligible stop task.
STR : 	 *
STR : 	 * We're currently inside stop_machine() and the rq is either stuck
STR : 	 * in the stop_machine_cpu_stop() loop, or we're executing this code,
STR : 	 * either way we should never end up calling schedule() until we're
STR : 	 * done here.
STR : 	 */
STR : 	rq->stop = NULL;
STR : 
STR : 	/*
STR : 	 * put_prev_task() and pick_next_task() sched
STR : 	 * class method both need to have an up-to-date
STR : 	 * value of rq->clock[_task]
STR : 	 */
STR : 	update_rq_clock(rq);
STR : 
STR : 	for ( ; ; ) {
STR : 		/*
STR : 		 * There's this thread running, bail when that's the only
STR : 		 * remaining thread.
STR : 		 */
STR : 		if (rq->nr_running == 1)
STR : 			break;
STR : 
STR : 		next = pick_next_task(rq);
STR : 		BUG_ON(!next);
STR : 		next->sched_class->put_prev_task(rq, next);
STR : 
STR : 		/* Find suitable destination for @next, with force if needed. */
STR : 		dest_cpu = select_fallback_rq(dead_cpu, next);
STR : 		raw_spin_unlock(&rq->lock);
STR : 
STR : 		__migrate_task(next, dead_cpu, dest_cpu);
STR : 
STR : 		raw_spin_lock(&rq->lock);
STR : 	}
STR : 
STR : 	rq->stop = stop;
STR : }
STR : 
STR : #endif /* CONFIG_HOTPLUG_CPU */
STR : 
STR : #if defined(CONFIG_SCHED_DEBUG) && defined(CONFIG_SYSCTL)
STR : 
STR : static struct ctl_table sd_ctl_dir[] = {
STR : 	{
STR : 		.procname	= "sched_domain",
STR : 		.mode		= 0555,
STR : 	},
STR : 	{}
STR : };
STR : 
STR : static struct ctl_table sd_ctl_root[] = {
STR : 	{
STR : 		.procname	= "kernel",
STR : 		.mode		= 0555,
STR : 		.child		= sd_ctl_dir,
STR : 	},
STR : 	{}
STR : };
STR : 
STR : static struct ctl_table *sd_alloc_ctl_entry(int n)
STR : {
STR : 	struct ctl_table *entry =
STR : 		kcalloc(n, sizeof(struct ctl_table), GFP_KERNEL);
STR : 
STR : 	return entry;
STR : }
STR : 
STR : static void sd_free_ctl_entry(struct ctl_table **tablep)
STR : {
STR : 	struct ctl_table *entry;
STR : 
STR : 	/*
STR : 	 * In the intermediate directories, both the child directory and
STR : 	 * procname are dynamically allocated and could fail but the mode
STR : 	 * will always be set. In the lowest directory the names are
STR : 	 * static strings and all have proc handlers.
STR : 	 */
STR : 	for (entry = *tablep; entry->mode; entry++) {
STR : 		if (entry->child)
STR : 			sd_free_ctl_entry(&entry->child);
STR : 		if (entry->proc_handler == NULL)
STR : 			kfree(entry->procname);
STR : 	}
STR : 
STR : 	kfree(*tablep);
STR : 	*tablep = NULL;
STR : }
STR : 
STR : static int min_load_idx = 0;
STR : static int max_load_idx = CPU_LOAD_IDX_MAX-1;
STR : 
STR : static void
STR : set_table_entry(struct ctl_table *entry,
STR : 		const char *procname, void *data, int maxlen,
STR : 		umode_t mode, proc_handler *proc_handler,
STR : 		bool load_idx)
STR : {
STR : 	entry->procname = procname;
STR : 	entry->data = data;
STR : 	entry->maxlen = maxlen;
STR : 	entry->mode = mode;
STR : 	entry->proc_handler = proc_handler;
STR : 
STR : 	if (load_idx) {
STR : 		entry->extra1 = &min_load_idx;
STR : 		entry->extra2 = &max_load_idx;
STR : 	}
STR : }
STR : 
STR : static struct ctl_table *
STR : sd_alloc_ctl_domain_table(struct sched_domain *sd)
STR : {
STR : 	struct ctl_table *table = sd_alloc_ctl_entry(13);
STR : 
STR : 	if (table == NULL)
STR : 		return NULL;
STR : 
STR : 	set_table_entry(&table[0], "min_interval", &sd->min_interval,
STR : 		sizeof(long), 0644, proc_doulongvec_minmax, false);
STR : 	set_table_entry(&table[1], "max_interval", &sd->max_interval,
STR : 		sizeof(long), 0644, proc_doulongvec_minmax, false);
STR : 	set_table_entry(&table[2], "busy_idx", &sd->busy_idx,
STR : 		sizeof(int), 0644, proc_dointvec_minmax, true);
STR : 	set_table_entry(&table[3], "idle_idx", &sd->idle_idx,
STR : 		sizeof(int), 0644, proc_dointvec_minmax, true);
STR : 	set_table_entry(&table[4], "newidle_idx", &sd->newidle_idx,
STR : 		sizeof(int), 0644, proc_dointvec_minmax, true);
STR : 	set_table_entry(&table[5], "wake_idx", &sd->wake_idx,
STR : 		sizeof(int), 0644, proc_dointvec_minmax, true);
STR : 	set_table_entry(&table[6], "forkexec_idx", &sd->forkexec_idx,
STR : 		sizeof(int), 0644, proc_dointvec_minmax, true);
STR : 	set_table_entry(&table[7], "busy_factor", &sd->busy_factor,
STR : 		sizeof(int), 0644, proc_dointvec_minmax, false);
STR : 	set_table_entry(&table[8], "imbalance_pct", &sd->imbalance_pct,
STR : 		sizeof(int), 0644, proc_dointvec_minmax, false);
STR : 	set_table_entry(&table[9], "cache_nice_tries",
STR : 		&sd->cache_nice_tries,
STR : 		sizeof(int), 0644, proc_dointvec_minmax, false);
STR : 	set_table_entry(&table[10], "flags", &sd->flags,
STR : 		sizeof(int), 0644, proc_dointvec_minmax, false);
STR : 	set_table_entry(&table[11], "name", sd->name,
STR : 		CORENAME_MAX_SIZE, 0444, proc_dostring, false);
STR : 	/* &table[12] is terminator */
STR : 
STR : 	return table;
STR : }
STR : 
STR : static struct ctl_table *sd_alloc_ctl_cpu_table(int cpu)
STR : {
STR : 	struct ctl_table *entry, *table;
STR : 	struct sched_domain *sd;
STR : 	int domain_num = 0, i;
STR : 	char buf[32];
STR : 
STR : 	for_each_domain(cpu, sd)
STR : 		domain_num++;
STR : 	entry = table = sd_alloc_ctl_entry(domain_num + 1);
STR : 	if (table == NULL)
STR : 		return NULL;
STR : 
STR : 	i = 0;
STR : 	for_each_domain(cpu, sd) {
STR : 		snprintf(buf, 32, "domain%d", i);
STR : 		entry->procname = kstrdup(buf, GFP_KERNEL);
STR : 		entry->mode = 0555;
STR : 		entry->child = sd_alloc_ctl_domain_table(sd);
STR : 		entry++;
STR : 		i++;
STR : 	}
STR : 	return table;
STR : }
STR : 
STR : static struct ctl_table_header *sd_sysctl_header;
STR : static void register_sched_domain_sysctl(void)
STR : {
STR : 	int i, cpu_num = num_possible_cpus();
STR : 	struct ctl_table *entry = sd_alloc_ctl_entry(cpu_num + 1);
STR : 	char buf[32];
STR : 
STR : 	WARN_ON(sd_ctl_dir[0].child);
STR : 	sd_ctl_dir[0].child = entry;
STR : 
STR : 	if (entry == NULL)
STR : 		return;
STR : 
STR : 	for_each_possible_cpu(i) {
STR : 		snprintf(buf, 32, "cpu%d", i);
STR : 		entry->procname = kstrdup(buf, GFP_KERNEL);
STR : 		entry->mode = 0555;
STR : 		entry->child = sd_alloc_ctl_cpu_table(i);
STR : 		entry++;
STR : 	}
STR : 
STR : 	WARN_ON(sd_sysctl_header);
STR : 	sd_sysctl_header = register_sysctl_table(sd_ctl_root);
STR : }
STR : 
STR : /* may be called multiple times per register */
STR : static void unregister_sched_domain_sysctl(void)
STR : {
STR : 	if (sd_sysctl_header)
STR : 		unregister_sysctl_table(sd_sysctl_header);
STR : 	sd_sysctl_header = NULL;
STR : 	if (sd_ctl_dir[0].child)
STR : 		sd_free_ctl_entry(&sd_ctl_dir[0].child);
STR : }
STR : #else
STR : static void register_sched_domain_sysctl(void)
STR : {
STR : }
STR : static void unregister_sched_domain_sysctl(void)
STR : {
STR : }
STR : #endif
STR : 
STR : static void set_rq_online(struct rq *rq)
STR : {
STR : 	if (!rq->online) {
STR : 		const struct sched_class *class;
STR : 
STR : 		cpumask_set_cpu(rq->cpu, rq->rd->online);
STR : 		rq->online = 1;
STR : 
STR : 		for_each_class(class) {
STR : 			if (class->rq_online)
STR : 				class->rq_online(rq);
STR : 		}
STR : 	}
STR : }
STR : 
STR : static void set_rq_offline(struct rq *rq)
STR : {
STR : 	if (rq->online) {
STR : 		const struct sched_class *class;
STR : 
STR : 		for_each_class(class) {
STR : 			if (class->rq_offline)
STR : 				class->rq_offline(rq);
STR : 		}
STR : 
STR : 		cpumask_clear_cpu(rq->cpu, rq->rd->online);
STR : 		rq->online = 0;
STR : 	}
STR : }
STR : 
STR : /*
STR :  * migration_call - callback that gets triggered when a CPU is added.
STR :  * Here we can start up the necessary migration thread for the new CPU.
STR :  */
STR : static int
STR : migration_call(struct notifier_block *nfb, unsigned long action, void *hcpu)
STR : {
STR : 	int cpu = (long)hcpu;
STR : 	unsigned long flags;
STR : 	struct rq *rq = cpu_rq(cpu);
STR : 
STR : 	switch (action & ~CPU_TASKS_FROZEN) {
STR : 
STR : 	case CPU_UP_PREPARE:
STR : 		rq->calc_load_update = calc_load_update;
STR : 		break;
STR : 
STR : 	case CPU_ONLINE:
STR : 		/* Update our root-domain */
STR : 		raw_spin_lock_irqsave(&rq->lock, flags);
STR : 		if (rq->rd) {
STR : 			BUG_ON(!cpumask_test_cpu(cpu, rq->rd->span));
STR : 
STR : 			set_rq_online(rq);
STR : 		}
STR : 		raw_spin_unlock_irqrestore(&rq->lock, flags);
STR : 		break;
STR : 
STR : #ifdef CONFIG_HOTPLUG_CPU
STR : 	case CPU_DYING:
STR : 		sched_ttwu_pending();
STR : 		/* Update our root-domain */
STR : 		raw_spin_lock_irqsave(&rq->lock, flags);
STR : 		if (rq->rd) {
STR : 			BUG_ON(!cpumask_test_cpu(cpu, rq->rd->span));
STR : 			set_rq_offline(rq);
STR : 		}
STR : 		migrate_tasks(cpu);
STR : 		BUG_ON(rq->nr_running != 1); /* the migration thread */
STR : 		raw_spin_unlock_irqrestore(&rq->lock, flags);
STR : 		break;
STR : 
STR : 	case CPU_DEAD:
STR : 		calc_load_migrate(rq);
STR : 		break;
STR : #endif
STR : 	}
STR : 
STR : 	update_max_interval();
STR : 
STR : 	return NOTIFY_OK;
STR : }
STR : 
STR : /*
STR :  * Register at high priority so that task migration (migrate_all_tasks)
STR :  * happens before everything else.  This has to be lower priority than
STR :  * the notifier in the perf_event subsystem, though.
STR :  */
STR : static struct notifier_block migration_notifier = {
STR : 	.notifier_call = migration_call,
STR : 	.priority = CPU_PRI_MIGRATION,
STR : };
STR : 
STR : static int sched_cpu_active(struct notifier_block *nfb,
STR : 				      unsigned long action, void *hcpu)
STR : {
STR : 	switch (action & ~CPU_TASKS_FROZEN) {
STR : 	case CPU_DOWN_FAILED:
STR : 		set_cpu_active((long)hcpu, true);
STR : 		return NOTIFY_OK;
STR : 	default:
STR : 		return NOTIFY_DONE;
STR : 	}
STR : }
STR : 
STR : static int sched_cpu_inactive(struct notifier_block *nfb,
STR : 					unsigned long action, void *hcpu)
STR : {
STR : 	unsigned long flags;
STR : 	long cpu = (long)hcpu;
STR : 
STR : 	switch (action & ~CPU_TASKS_FROZEN) {
STR : 	case CPU_DOWN_PREPARE:
STR : 		set_cpu_active(cpu, false);
STR : 
STR : 		/* explicitly allow suspend */
STR : 		if (!(action & CPU_TASKS_FROZEN)) {
STR : 			struct dl_bw *dl_b = dl_bw_of(cpu);
STR : 			bool overflow;
STR : 			int cpus;
STR : 
STR : 			raw_spin_lock_irqsave(&dl_b->lock, flags);
STR : 			cpus = dl_bw_cpus(cpu);
STR : 			overflow = __dl_overflow(dl_b, cpus, 0, 0);
STR : 			raw_spin_unlock_irqrestore(&dl_b->lock, flags);
STR : 
STR : 			if (overflow)
STR : 				return notifier_from_errno(-EBUSY);
STR : 		}
STR : 		return NOTIFY_OK;
STR : 	}
STR : 
STR : 	return NOTIFY_DONE;
STR : }
STR : 
STR : static int __init migration_init(void)
STR : {
STR : 	void *cpu = (void *)(long)smp_processor_id();
STR : 	int err;
STR : 
STR : 	/* Initialize migration for the boot CPU */
STR : 	err = migration_call(&migration_notifier, CPU_UP_PREPARE, cpu);
STR : 	BUG_ON(err == NOTIFY_BAD);
STR : 	migration_call(&migration_notifier, CPU_ONLINE, cpu);
STR : 	register_cpu_notifier(&migration_notifier);
STR : 
STR : 	/* Register cpu active notifiers */
STR : 	cpu_notifier(sched_cpu_active, CPU_PRI_SCHED_ACTIVE);
STR : 	cpu_notifier(sched_cpu_inactive, CPU_PRI_SCHED_INACTIVE);
STR : 
STR : 	return 0;
STR : }
STR : early_initcall(migration_init);
STR : #endif
STR : 
STR : #ifdef CONFIG_SMP
STR : 
STR : static cpumask_var_t sched_domains_tmpmask; /* sched_domains_mutex */
STR : 
STR : #ifdef CONFIG_SCHED_DEBUG
STR : 
STR : static __read_mostly int sched_debug_enabled;
STR : 
STR : static int __init sched_debug_setup(char *str)
STR : {
STR : 	sched_debug_enabled = 1;
STR : 
STR : 	return 0;
STR : }
STR : early_param("sched_debug", sched_debug_setup);
STR : 
STR : static inline bool sched_debug(void)
STR : {
STR : 	return sched_debug_enabled;
STR : }
STR : 
STR : static int sched_domain_debug_one(struct sched_domain *sd, int cpu, int level,
STR : 				  struct cpumask *groupmask)
STR : {
STR : 	struct sched_group *group = sd->groups;
STR : 	char str[256];
STR : 
STR : 	cpulist_scnprintf(str, sizeof(str), sched_domain_span(sd));
STR : 	cpumask_clear(groupmask);
STR : 
STR : 	printk(KERN_DEBUG "%*s domain %d: ", level, "", level);
STR : 
STR : 	if (!(sd->flags & SD_LOAD_BALANCE)) {
STR : 		printk("does not load-balance\n");
STR : 		if (sd->parent)
STR : 			printk(KERN_ERR "ERROR: !SD_LOAD_BALANCE domain"
STR : 					" has parent");
STR : 		return -1;
STR : 	}
STR : 
STR : 	printk(KERN_CONT "span %s level %s\n", str, sd->name);
STR : 
STR : 	if (!cpumask_test_cpu(cpu, sched_domain_span(sd))) {
STR : 		printk(KERN_ERR "ERROR: domain->span does not contain "
STR : 				"CPU%d\n", cpu);
STR : 	}
STR : 	if (!cpumask_test_cpu(cpu, sched_group_cpus(group))) {
STR : 		printk(KERN_ERR "ERROR: domain->groups does not contain"
STR : 				" CPU%d\n", cpu);
STR : 	}
STR : 
STR : 	printk(KERN_DEBUG "%*s groups:", level + 1, "");
STR : 	do {
STR : 		if (!group) {
STR : 			printk("\n");
STR : 			printk(KERN_ERR "ERROR: group is NULL\n");
STR : 			break;
STR : 		}
STR : 
STR : 		/*
STR : 		 * Even though we initialize ->power to something semi-sane,
STR : 		 * we leave power_orig unset. This allows us to detect if
STR : 		 * domain iteration is still funny without causing /0 traps.
STR : 		 */
STR : 		if (!group->sgp->power_orig) {
STR : 			printk(KERN_CONT "\n");
STR : 			printk(KERN_ERR "ERROR: domain->cpu_power not "
STR : 					"set\n");
STR : 			break;
STR : 		}
STR : 
STR : 		if (!cpumask_weight(sched_group_cpus(group))) {
STR : 			printk(KERN_CONT "\n");
STR : 			printk(KERN_ERR "ERROR: empty group\n");
STR : 			break;
STR : 		}
STR : 
STR : 		if (!(sd->flags & SD_OVERLAP) &&
STR : 		    cpumask_intersects(groupmask, sched_group_cpus(group))) {
STR : 			printk(KERN_CONT "\n");
STR : 			printk(KERN_ERR "ERROR: repeated CPUs\n");
STR : 			break;
STR : 		}
STR : 
STR : 		cpumask_or(groupmask, groupmask, sched_group_cpus(group));
STR : 
STR : 		cpulist_scnprintf(str, sizeof(str), sched_group_cpus(group));
STR : 
STR : 		printk(KERN_CONT " %s", str);
STR : 		if (group->sgp->power != SCHED_POWER_SCALE) {
STR : 			printk(KERN_CONT " (cpu_power = %d)",
STR : 				group->sgp->power);
STR : 		}
STR : 
STR : 		group = group->next;
STR : 	} while (group != sd->groups);
STR : 	printk(KERN_CONT "\n");
STR : 
STR : 	if (!cpumask_equal(sched_domain_span(sd), groupmask))
STR : 		printk(KERN_ERR "ERROR: groups don't span domain->span\n");
STR : 
STR : 	if (sd->parent &&
STR : 	    !cpumask_subset(groupmask, sched_domain_span(sd->parent)))
STR : 		printk(KERN_ERR "ERROR: parent span is not a superset "
STR : 			"of domain->span\n");
STR : 	return 0;
STR : }
STR : 
STR : static void sched_domain_debug(struct sched_domain *sd, int cpu)
STR : {
STR : 	int level = 0;
STR : 
STR : 	if (!sched_debug_enabled)
STR : 		return;
STR : 
STR : 	if (!sd) {
STR : 		printk(KERN_DEBUG "CPU%d attaching NULL sched-domain.\n", cpu);
STR : 		return;
STR : 	}
STR : 
STR : 	printk(KERN_DEBUG "CPU%d attaching sched-domain:\n", cpu);
STR : 
STR : 	for (;;) {
STR : 		if (sched_domain_debug_one(sd, cpu, level, sched_domains_tmpmask))
STR : 			break;
STR : 		level++;
STR : 		sd = sd->parent;
STR : 		if (!sd)
STR : 			break;
STR : 	}
STR : }
STR : #else /* !CONFIG_SCHED_DEBUG */
STR : # define sched_domain_debug(sd, cpu) do { } while (0)
STR : static inline bool sched_debug(void)
STR : {
STR : 	return false;
STR : }
STR : #endif /* CONFIG_SCHED_DEBUG */
STR : 
STR : static int sd_degenerate(struct sched_domain *sd)
STR : {
STR : 	if (cpumask_weight(sched_domain_span(sd)) == 1)
STR : 		return 1;
STR : 
STR : 	/* Following flags need at least 2 groups */
STR : 	if (sd->flags & (SD_LOAD_BALANCE |
STR : 			 SD_BALANCE_NEWIDLE |
STR : 			 SD_BALANCE_FORK |
STR : 			 SD_BALANCE_EXEC |
STR : 			 SD_SHARE_CPUPOWER |
STR : 			 SD_SHARE_PKG_RESOURCES)) {
STR : 		if (sd->groups != sd->groups->next)
STR : 			return 0;
STR : 	}
STR : 
STR : 	/* Following flags don't use groups */
STR : 	if (sd->flags & (SD_WAKE_AFFINE))
STR : 		return 0;
STR : 
STR : 	return 1;
STR : }
STR : 
STR : static int
STR : sd_parent_degenerate(struct sched_domain *sd, struct sched_domain *parent)
STR : {
STR : 	unsigned long cflags = sd->flags, pflags = parent->flags;
STR : 
STR : 	if (sd_degenerate(parent))
STR : 		return 1;
STR : 
STR : 	if (!cpumask_equal(sched_domain_span(sd), sched_domain_span(parent)))
STR : 		return 0;
STR : 
STR : 	/* Flags needing groups don't count if only 1 group in parent */
STR : 	if (parent->groups == parent->groups->next) {
STR : 		pflags &= ~(SD_LOAD_BALANCE |
STR : 				SD_BALANCE_NEWIDLE |
STR : 				SD_BALANCE_FORK |
STR : 				SD_BALANCE_EXEC |
STR : 				SD_SHARE_CPUPOWER |
STR : 				SD_SHARE_PKG_RESOURCES |
STR : 				SD_PREFER_SIBLING);
STR : 		if (nr_node_ids == 1)
STR : 			pflags &= ~SD_SERIALIZE;
STR : 	}
STR : 	if (~cflags & pflags)
STR : 		return 0;
STR : 
STR : 	return 1;
STR : }
STR : 
STR : static void free_rootdomain(struct rcu_head *rcu)
STR : {
STR : 	struct root_domain *rd = container_of(rcu, struct root_domain, rcu);
STR : 
STR : 	cpupri_cleanup(&rd->cpupri);
STR : 	cpudl_cleanup(&rd->cpudl);
STR : 	free_cpumask_var(rd->dlo_mask);
STR : 	free_cpumask_var(rd->rto_mask);
STR : 	free_cpumask_var(rd->online);
STR : 	free_cpumask_var(rd->span);
STR : 	kfree(rd);
STR : }
STR : 
STR : static void rq_attach_root(struct rq *rq, struct root_domain *rd)
STR : {
STR : 	struct root_domain *old_rd = NULL;
STR : 	unsigned long flags;
STR : 
STR : 	raw_spin_lock_irqsave(&rq->lock, flags);
STR : 
STR : 	if (rq->rd) {
STR : 		old_rd = rq->rd;
STR : 
STR : 		if (cpumask_test_cpu(rq->cpu, old_rd->online))
STR : 			set_rq_offline(rq);
STR : 
STR : 		cpumask_clear_cpu(rq->cpu, old_rd->span);
STR : 
STR : 		/*
STR : 		 * If we dont want to free the old_rd yet then
STR : 		 * set old_rd to NULL to skip the freeing later
STR : 		 * in this function:
STR : 		 */
STR : 		if (!atomic_dec_and_test(&old_rd->refcount))
STR : 			old_rd = NULL;
STR : 	}
STR : 
STR : 	atomic_inc(&rd->refcount);
STR : 	rq->rd = rd;
STR : 
STR : 	cpumask_set_cpu(rq->cpu, rd->span);
STR : 	if (cpumask_test_cpu(rq->cpu, cpu_active_mask))
STR : 		set_rq_online(rq);
STR : 
STR : 	raw_spin_unlock_irqrestore(&rq->lock, flags);
STR : 
STR : 	if (old_rd)
STR : 		call_rcu_sched(&old_rd->rcu, free_rootdomain);
STR : }
STR : 
STR : static int init_rootdomain(struct root_domain *rd)
STR : {
STR : 	memset(rd, 0, sizeof(*rd));
STR : 
STR : 	if (!alloc_cpumask_var(&rd->span, GFP_KERNEL))
STR : 		goto out;
STR : 	if (!alloc_cpumask_var(&rd->online, GFP_KERNEL))
STR : 		goto free_span;
STR : 	if (!alloc_cpumask_var(&rd->dlo_mask, GFP_KERNEL))
STR : 		goto free_online;
STR : 	if (!alloc_cpumask_var(&rd->rto_mask, GFP_KERNEL))
STR : 		goto free_dlo_mask;
STR : 
STR : 	init_dl_bw(&rd->dl_bw);
STR : 	if (cpudl_init(&rd->cpudl) != 0)
STR : 		goto free_dlo_mask;
STR : 
STR : 	if (cpupri_init(&rd->cpupri) != 0)
STR : 		goto free_rto_mask;
STR : 	return 0;
STR : 
STR : free_rto_mask:
STR : 	free_cpumask_var(rd->rto_mask);
STR : free_dlo_mask:
STR : 	free_cpumask_var(rd->dlo_mask);
STR : free_online:
STR : 	free_cpumask_var(rd->online);
STR : free_span:
STR : 	free_cpumask_var(rd->span);
STR : out:
STR : 	return -ENOMEM;
STR : }
STR : 
STR : /*
STR :  * By default the system creates a single root-domain with all cpus as
STR :  * members (mimicking the global state we have today).
STR :  */
STR : struct root_domain def_root_domain;
STR : 
STR : static void init_defrootdomain(void)
STR : {
STR : 	init_rootdomain(&def_root_domain);
STR : 
STR : 	atomic_set(&def_root_domain.refcount, 1);
STR : }
STR : 
STR : static struct root_domain *alloc_rootdomain(void)
STR : {
STR : 	struct root_domain *rd;
STR : 
STR : 	rd = kmalloc(sizeof(*rd), GFP_KERNEL);
STR : 	if (!rd)
STR : 		return NULL;
STR : 
STR : 	if (init_rootdomain(rd) != 0) {
STR : 		kfree(rd);
STR : 		return NULL;
STR : 	}
STR : 
STR : 	return rd;
STR : }
STR : 
STR : static void free_sched_groups(struct sched_group *sg, int free_sgp)
STR : {
STR : 	struct sched_group *tmp, *first;
STR : 
STR : 	if (!sg)
STR : 		return;
STR : 
STR : 	first = sg;
STR : 	do {
STR : 		tmp = sg->next;
STR : 
STR : 		if (free_sgp && atomic_dec_and_test(&sg->sgp->ref))
STR : 			kfree(sg->sgp);
STR : 
STR : 		kfree(sg);
STR : 		sg = tmp;
STR : 	} while (sg != first);
STR : }
STR : 
STR : static void free_sched_domain(struct rcu_head *rcu)
STR : {
STR : 	struct sched_domain *sd = container_of(rcu, struct sched_domain, rcu);
STR : 
STR : 	/*
STR : 	 * If its an overlapping domain it has private groups, iterate and
STR : 	 * nuke them all.
STR : 	 */
STR : 	if (sd->flags & SD_OVERLAP) {
STR : 		free_sched_groups(sd->groups, 1);
STR : 	} else if (atomic_dec_and_test(&sd->groups->ref)) {
STR : 		kfree(sd->groups->sgp);
STR : 		kfree(sd->groups);
STR : 	}
STR : 	kfree(sd);
STR : }
STR : 
STR : static void destroy_sched_domain(struct sched_domain *sd, int cpu)
STR : {
STR : 	call_rcu(&sd->rcu, free_sched_domain);
STR : }
STR : 
STR : static void destroy_sched_domains(struct sched_domain *sd, int cpu)
STR : {
STR : 	for (; sd; sd = sd->parent)
STR : 		destroy_sched_domain(sd, cpu);
STR : }
STR : 
STR : /*
STR :  * Keep a special pointer to the highest sched_domain that has
STR :  * SD_SHARE_PKG_RESOURCE set (Last Level Cache Domain) for this
STR :  * allows us to avoid some pointer chasing select_idle_sibling().
STR :  *
STR :  * Also keep a unique ID per domain (we use the first cpu number in
STR :  * the cpumask of the domain), this allows us to quickly tell if
STR :  * two cpus are in the same cache domain, see cpus_share_cache().
STR :  */
STR : DEFINE_PER_CPU(struct sched_domain *, sd_llc);
STR : DEFINE_PER_CPU(int, sd_llc_size);
STR : DEFINE_PER_CPU(int, sd_llc_id);
STR : DEFINE_PER_CPU(struct sched_domain *, sd_numa);
STR : DEFINE_PER_CPU(struct sched_domain *, sd_busy);
STR : DEFINE_PER_CPU(struct sched_domain *, sd_asym);
STR : 
STR : static void update_top_cache_domain(int cpu)
STR : {
STR : 	struct sched_domain *sd;
STR : 	struct sched_domain *busy_sd = NULL;
STR : 	int id = cpu;
STR : 	int size = 1;
STR : 
STR : 	sd = highest_flag_domain(cpu, SD_SHARE_PKG_RESOURCES);
STR : 	if (sd) {
STR : 		id = cpumask_first(sched_domain_span(sd));
STR : 		size = cpumask_weight(sched_domain_span(sd));
STR : 		busy_sd = sd->parent; /* sd_busy */
STR : 	}
STR : 	rcu_assign_pointer(per_cpu(sd_busy, cpu), busy_sd);
STR : 
STR : 	rcu_assign_pointer(per_cpu(sd_llc, cpu), sd);
STR : 	per_cpu(sd_llc_size, cpu) = size;
STR : 	per_cpu(sd_llc_id, cpu) = id;
STR : 
STR : 	sd = lowest_flag_domain(cpu, SD_NUMA);
STR : 	rcu_assign_pointer(per_cpu(sd_numa, cpu), sd);
STR : 
STR : 	sd = highest_flag_domain(cpu, SD_ASYM_PACKING);
STR : 	rcu_assign_pointer(per_cpu(sd_asym, cpu), sd);
STR : }
STR : 
STR : /*
STR :  * Attach the domain 'sd' to 'cpu' as its base domain. Callers must
STR :  * hold the hotplug lock.
STR :  */
STR : static void
STR : cpu_attach_domain(struct sched_domain *sd, struct root_domain *rd, int cpu)
STR : {
STR : 	struct rq *rq = cpu_rq(cpu);
STR : 	struct sched_domain *tmp;
STR : 
STR : 	/* Remove the sched domains which do not contribute to scheduling. */
STR : 	for (tmp = sd; tmp; ) {
STR : 		struct sched_domain *parent = tmp->parent;
STR : 		if (!parent)
STR : 			break;
STR : 
STR : 		if (sd_parent_degenerate(tmp, parent)) {
STR : 			tmp->parent = parent->parent;
STR : 			if (parent->parent)
STR : 				parent->parent->child = tmp;
STR : 			/*
STR : 			 * Transfer SD_PREFER_SIBLING down in case of a
STR : 			 * degenerate parent; the spans match for this
STR : 			 * so the property transfers.
STR : 			 */
STR : 			if (parent->flags & SD_PREFER_SIBLING)
STR : 				tmp->flags |= SD_PREFER_SIBLING;
STR : 			destroy_sched_domain(parent, cpu);
STR : 		} else
STR : 			tmp = tmp->parent;
STR : 	}
STR : 
STR : 	if (sd && sd_degenerate(sd)) {
STR : 		tmp = sd;
STR : 		sd = sd->parent;
STR : 		destroy_sched_domain(tmp, cpu);
STR : 		if (sd)
STR : 			sd->child = NULL;
STR : 	}
STR : 
STR : 	sched_domain_debug(sd, cpu);
STR : 
STR : 	rq_attach_root(rq, rd);
STR : 	tmp = rq->sd;
STR : 	rcu_assign_pointer(rq->sd, sd);
STR : 	destroy_sched_domains(tmp, cpu);
STR : 
STR : 	update_top_cache_domain(cpu);
STR : }
STR : 
STR : /* cpus with isolated domains */
STR : static cpumask_var_t cpu_isolated_map;
STR : 
STR : /* Setup the mask of cpus configured for isolated domains */
STR : static int __init isolated_cpu_setup(char *str)
STR : {
STR : 	alloc_bootmem_cpumask_var(&cpu_isolated_map);
STR : 	cpulist_parse(str, cpu_isolated_map);
STR : 	return 1;
STR : }
STR : 
STR : __setup("isolcpus=", isolated_cpu_setup);
STR : 
STR : static const struct cpumask *cpu_cpu_mask(int cpu)
STR : {
STR : 	return cpumask_of_node(cpu_to_node(cpu));
STR : }
STR : 
STR : struct sd_data {
STR : 	struct sched_domain **__percpu sd;
STR : 	struct sched_group **__percpu sg;
STR : 	struct sched_group_power **__percpu sgp;
STR : };
STR : 
STR : struct s_data {
STR : 	struct sched_domain ** __percpu sd;
STR : 	struct root_domain	*rd;
STR : };
STR : 
STR : enum s_alloc {
STR : 	sa_rootdomain,
STR : 	sa_sd,
STR : 	sa_sd_storage,
STR : 	sa_none,
STR : };
STR : 
STR : struct sched_domain_topology_level;
STR : 
STR : typedef struct sched_domain *(*sched_domain_init_f)(struct sched_domain_topology_level *tl, int cpu);
STR : typedef const struct cpumask *(*sched_domain_mask_f)(int cpu);
STR : 
STR : #define SDTL_OVERLAP	0x01
STR : 
STR : struct sched_domain_topology_level {
STR : 	sched_domain_init_f init;
STR : 	sched_domain_mask_f mask;
STR : 	int		    flags;
STR : 	int		    numa_level;
STR : 	struct sd_data      data;
STR : };
STR : 
STR : /*
STR :  * Build an iteration mask that can exclude certain CPUs from the upwards
STR :  * domain traversal.
STR :  *
STR :  * Asymmetric node setups can result in situations where the domain tree is of
STR :  * unequal depth, make sure to skip domains that already cover the entire
STR :  * range.
STR :  *
STR :  * In that case build_sched_domains() will have terminated the iteration early
STR :  * and our sibling sd spans will be empty. Domains should always include the
STR :  * cpu they're built on, so check that.
STR :  *
STR :  */
STR : static void build_group_mask(struct sched_domain *sd, struct sched_group *sg)
STR : {
STR : 	const struct cpumask *span = sched_domain_span(sd);
STR : 	struct sd_data *sdd = sd->private;
STR : 	struct sched_domain *sibling;
STR : 	int i;
STR : 
STR : 	for_each_cpu(i, span) {
STR : 		sibling = *per_cpu_ptr(sdd->sd, i);
STR : 		if (!cpumask_test_cpu(i, sched_domain_span(sibling)))
STR : 			continue;
STR : 
STR : 		cpumask_set_cpu(i, sched_group_mask(sg));
STR : 	}
STR : }
STR : 
STR : /*
STR :  * Return the canonical balance cpu for this group, this is the first cpu
STR :  * of this group that's also in the iteration mask.
STR :  */
STR : int group_balance_cpu(struct sched_group *sg)
STR : {
STR : 	return cpumask_first_and(sched_group_cpus(sg), sched_group_mask(sg));
STR : }
STR : 
STR : static int
STR : build_overlap_sched_groups(struct sched_domain *sd, int cpu)
STR : {
STR : 	struct sched_group *first = NULL, *last = NULL, *groups = NULL, *sg;
STR : 	const struct cpumask *span = sched_domain_span(sd);
STR : 	struct cpumask *covered = sched_domains_tmpmask;
STR : 	struct sd_data *sdd = sd->private;
STR : 	struct sched_domain *child;
STR : 	int i;
STR : 
STR : 	cpumask_clear(covered);
STR : 
STR : 	for_each_cpu(i, span) {
STR : 		struct cpumask *sg_span;
STR : 
STR : 		if (cpumask_test_cpu(i, covered))
STR : 			continue;
STR : 
STR : 		child = *per_cpu_ptr(sdd->sd, i);
STR : 
STR : 		/* See the comment near build_group_mask(). */
STR : 		if (!cpumask_test_cpu(i, sched_domain_span(child)))
STR : 			continue;
STR : 
STR : 		sg = kzalloc_node(sizeof(struct sched_group) + cpumask_size(),
STR : 				GFP_KERNEL, cpu_to_node(cpu));
STR : 
STR : 		if (!sg)
STR : 			goto fail;
STR : 
STR : 		sg_span = sched_group_cpus(sg);
STR : 		if (child->child) {
STR : 			child = child->child;
STR : 			cpumask_copy(sg_span, sched_domain_span(child));
STR : 		} else
STR : 			cpumask_set_cpu(i, sg_span);
STR : 
STR : 		cpumask_or(covered, covered, sg_span);
STR : 
STR : 		sg->sgp = *per_cpu_ptr(sdd->sgp, i);
STR : 		if (atomic_inc_return(&sg->sgp->ref) == 1)
STR : 			build_group_mask(sd, sg);
STR : 
STR : 		/*
STR : 		 * Initialize sgp->power such that even if we mess up the
STR : 		 * domains and no possible iteration will get us here, we won't
STR : 		 * die on a /0 trap.
STR : 		 */
STR : 		sg->sgp->power = SCHED_POWER_SCALE * cpumask_weight(sg_span);
STR : 		sg->sgp->power_orig = sg->sgp->power;
STR : 
STR : 		/*
STR : 		 * Make sure the first group of this domain contains the
STR : 		 * canonical balance cpu. Otherwise the sched_domain iteration
STR : 		 * breaks. See update_sg_lb_stats().
STR : 		 */
STR : 		if ((!groups && cpumask_test_cpu(cpu, sg_span)) ||
STR : 		    group_balance_cpu(sg) == cpu)
STR : 			groups = sg;
STR : 
STR : 		if (!first)
STR : 			first = sg;
STR : 		if (last)
STR : 			last->next = sg;
STR : 		last = sg;
STR : 		last->next = first;
STR : 	}
STR : 	sd->groups = groups;
STR : 
STR : 	return 0;
STR : 
STR : fail:
STR : 	free_sched_groups(first, 0);
STR : 
STR : 	return -ENOMEM;
STR : }
STR : 
STR : static int get_group(int cpu, struct sd_data *sdd, struct sched_group **sg)
STR : {
STR : 	struct sched_domain *sd = *per_cpu_ptr(sdd->sd, cpu);
STR : 	struct sched_domain *child = sd->child;
STR : 
STR : 	if (child)
STR : 		cpu = cpumask_first(sched_domain_span(child));
STR : 
STR : 	if (sg) {
STR : 		*sg = *per_cpu_ptr(sdd->sg, cpu);
STR : 		(*sg)->sgp = *per_cpu_ptr(sdd->sgp, cpu);
STR : 		atomic_set(&(*sg)->sgp->ref, 1); /* for claim_allocations */
STR : 	}
STR : 
STR : 	return cpu;
STR : }
STR : 
STR : /*
STR :  * build_sched_groups will build a circular linked list of the groups
STR :  * covered by the given span, and will set each group's ->cpumask correctly,
STR :  * and ->cpu_power to 0.
STR :  *
STR :  * Assumes the sched_domain tree is fully constructed
STR :  */
STR : static int
STR : build_sched_groups(struct sched_domain *sd, int cpu)
STR : {
STR : 	struct sched_group *first = NULL, *last = NULL;
STR : 	struct sd_data *sdd = sd->private;
STR : 	const struct cpumask *span = sched_domain_span(sd);
STR : 	struct cpumask *covered;
STR : 	int i;
STR : 
STR : 	get_group(cpu, sdd, &sd->groups);
STR : 	atomic_inc(&sd->groups->ref);
STR : 
STR : 	if (cpu != cpumask_first(span))
STR : 		return 0;
STR : 
STR : 	lockdep_assert_held(&sched_domains_mutex);
STR : 	covered = sched_domains_tmpmask;
STR : 
STR : 	cpumask_clear(covered);
STR : 
STR : 	for_each_cpu(i, span) {
STR : 		struct sched_group *sg;
STR : 		int group, j;
STR : 
STR : 		if (cpumask_test_cpu(i, covered))
STR : 			continue;
STR : 
STR : 		group = get_group(i, sdd, &sg);
STR : 		cpumask_clear(sched_group_cpus(sg));
STR : 		sg->sgp->power = 0;
STR : 		cpumask_setall(sched_group_mask(sg));
STR : 
STR : 		for_each_cpu(j, span) {
STR : 			if (get_group(j, sdd, NULL) != group)
STR : 				continue;
STR : 
STR : 			cpumask_set_cpu(j, covered);
STR : 			cpumask_set_cpu(j, sched_group_cpus(sg));
STR : 		}
STR : 
STR : 		if (!first)
STR : 			first = sg;
STR : 		if (last)
STR : 			last->next = sg;
STR : 		last = sg;
STR : 	}
STR : 	last->next = first;
STR : 
STR : 	return 0;
STR : }
STR : 
STR : /*
STR :  * Initialize sched groups cpu_power.
STR :  *
STR :  * cpu_power indicates the capacity of sched group, which is used while
STR :  * distributing the load between different sched groups in a sched domain.
STR :  * Typically cpu_power for all the groups in a sched domain will be same unless
STR :  * there are asymmetries in the topology. If there are asymmetries, group
STR :  * having more cpu_power will pickup more load compared to the group having
STR :  * less cpu_power.
STR :  */
STR : static void init_sched_groups_power(int cpu, struct sched_domain *sd)
STR : {
STR : 	struct sched_group *sg = sd->groups;
STR : 
STR : 	WARN_ON(!sg);
STR : 
STR : 	do {
STR : 		sg->group_weight = cpumask_weight(sched_group_cpus(sg));
STR : 		sg = sg->next;
STR : 	} while (sg != sd->groups);
STR : 
STR : 	if (cpu != group_balance_cpu(sg))
STR : 		return;
STR : 
STR : 	update_group_power(sd, cpu);
STR : 	atomic_set(&sg->sgp->nr_busy_cpus, sg->group_weight);
STR : }
STR : 
STR : int __weak arch_sd_sibling_asym_packing(void)
STR : {
STR :        return 0*SD_ASYM_PACKING;
STR : }
STR : 
STR : /*
STR :  * Initializers for schedule domains
STR :  * Non-inlined to reduce accumulated stack pressure in build_sched_domains()
STR :  */
STR : 
STR : #ifdef CONFIG_SCHED_DEBUG
STR : # define SD_INIT_NAME(sd, type)		sd->name = #type
STR : #else
STR : # define SD_INIT_NAME(sd, type)		do { } while (0)
STR : #endif
STR : 
STR : #define SD_INIT_FUNC(type)						\
STR : static noinline struct sched_domain *					\
STR : sd_init_##type(struct sched_domain_topology_level *tl, int cpu) 	\
STR : {									\
STR : 	struct sched_domain *sd = *per_cpu_ptr(tl->data.sd, cpu);	\
STR : 	*sd = SD_##type##_INIT;						\
STR : 	SD_INIT_NAME(sd, type);						\
STR : 	sd->private = &tl->data;					\
STR : 	return sd;							\
STR : }
STR : 
STR : SD_INIT_FUNC(CPU)
STR : #ifdef CONFIG_SCHED_SMT
STR :  SD_INIT_FUNC(SIBLING)
STR : #endif
STR : #ifdef CONFIG_SCHED_MC
STR :  SD_INIT_FUNC(MC)
STR : #endif
STR : #ifdef CONFIG_SCHED_BOOK
STR :  SD_INIT_FUNC(BOOK)
STR : #endif
STR : 
STR : static int default_relax_domain_level = -1;
STR : int sched_domain_level_max;
STR : 
STR : static int __init setup_relax_domain_level(char *str)
STR : {
STR : 	if (kstrtoint(str, 0, &default_relax_domain_level))
STR : 		pr_warn("Unable to set relax_domain_level\n");
STR : 
STR : 	return 1;
STR : }
STR : __setup("relax_domain_level=", setup_relax_domain_level);
STR : 
STR : static void set_domain_attribute(struct sched_domain *sd,
STR : 				 struct sched_domain_attr *attr)
STR : {
STR : 	int request;
STR : 
STR : 	if (!attr || attr->relax_domain_level < 0) {
STR : 		if (default_relax_domain_level < 0)
STR : 			return;
STR : 		else
STR : 			request = default_relax_domain_level;
STR : 	} else
STR : 		request = attr->relax_domain_level;
STR : 	if (request < sd->level) {
STR : 		/* turn off idle balance on this domain */
STR : 		sd->flags &= ~(SD_BALANCE_WAKE|SD_BALANCE_NEWIDLE);
STR : 	} else {
STR : 		/* turn on idle balance on this domain */
STR : 		sd->flags |= (SD_BALANCE_WAKE|SD_BALANCE_NEWIDLE);
STR : 	}
STR : }
STR : 
STR : static void __sdt_free(const struct cpumask *cpu_map);
STR : static int __sdt_alloc(const struct cpumask *cpu_map);
STR : 
STR : static void __free_domain_allocs(struct s_data *d, enum s_alloc what,
STR : 				 const struct cpumask *cpu_map)
STR : {
STR : 	switch (what) {
STR : 	case sa_rootdomain:
STR : 		if (!atomic_read(&d->rd->refcount))
STR : 			free_rootdomain(&d->rd->rcu); /* fall through */
STR : 	case sa_sd:
STR : 		free_percpu(d->sd); /* fall through */
STR : 	case sa_sd_storage:
STR : 		__sdt_free(cpu_map); /* fall through */
STR : 	case sa_none:
STR : 		break;
STR : 	}
STR : }
STR : 
STR : static enum s_alloc __visit_domain_allocation_hell(struct s_data *d,
STR : 						   const struct cpumask *cpu_map)
STR : {
STR : 	memset(d, 0, sizeof(*d));
STR : 
STR : 	if (__sdt_alloc(cpu_map))
STR : 		return sa_sd_storage;
STR : 	d->sd = alloc_percpu(struct sched_domain *);
STR : 	if (!d->sd)
STR : 		return sa_sd_storage;
STR : 	d->rd = alloc_rootdomain();
STR : 	if (!d->rd)
STR : 		return sa_sd;
STR : 	return sa_rootdomain;
STR : }
STR : 
STR : /*
STR :  * NULL the sd_data elements we've used to build the sched_domain and
STR :  * sched_group structure so that the subsequent __free_domain_allocs()
STR :  * will not free the data we're using.
STR :  */
STR : static void claim_allocations(int cpu, struct sched_domain *sd)
STR : {
STR : 	struct sd_data *sdd = sd->private;
STR : 
STR : 	WARN_ON_ONCE(*per_cpu_ptr(sdd->sd, cpu) != sd);
STR : 	*per_cpu_ptr(sdd->sd, cpu) = NULL;
STR : 
STR : 	if (atomic_read(&(*per_cpu_ptr(sdd->sg, cpu))->ref))
STR : 		*per_cpu_ptr(sdd->sg, cpu) = NULL;
STR : 
STR : 	if (atomic_read(&(*per_cpu_ptr(sdd->sgp, cpu))->ref))
STR : 		*per_cpu_ptr(sdd->sgp, cpu) = NULL;
STR : }
STR : 
STR : #ifdef CONFIG_SCHED_SMT
STR : static const struct cpumask *cpu_smt_mask(int cpu)
STR : {
STR : 	return topology_thread_cpumask(cpu);
STR : }
STR : #endif
STR : 
STR : /*
STR :  * Topology list, bottom-up.
STR :  */
STR : static struct sched_domain_topology_level default_topology[] = {
STR : #ifdef CONFIG_SCHED_SMT
STR : 	{ sd_init_SIBLING, cpu_smt_mask, },
STR : #endif
STR : #ifdef CONFIG_SCHED_MC
STR : 	{ sd_init_MC, cpu_coregroup_mask, },
STR : #endif
STR : #ifdef CONFIG_SCHED_BOOK
STR : 	{ sd_init_BOOK, cpu_book_mask, },
STR : #endif
STR : 	{ sd_init_CPU, cpu_cpu_mask, },
STR : 	{ NULL, },
STR : };
STR : 
STR : static struct sched_domain_topology_level *sched_domain_topology = default_topology;
STR : 
STR : #define for_each_sd_topology(tl)			\
STR : 	for (tl = sched_domain_topology; tl->init; tl++)
STR : 
STR : #ifdef CONFIG_NUMA
STR : 
STR : static int sched_domains_numa_levels;
STR : static int *sched_domains_numa_distance;
STR : static struct cpumask ***sched_domains_numa_masks;
STR : static int sched_domains_curr_level;
STR : 
STR : static inline int sd_local_flags(int level)
STR : {
STR : 	if (sched_domains_numa_distance[level] > RECLAIM_DISTANCE)
STR : 		return 0;
STR : 
STR : 	return SD_BALANCE_EXEC | SD_BALANCE_FORK | SD_WAKE_AFFINE;
STR : }
STR : 
STR : static struct sched_domain *
STR : sd_numa_init(struct sched_domain_topology_level *tl, int cpu)
STR : {
STR : 	struct sched_domain *sd = *per_cpu_ptr(tl->data.sd, cpu);
STR : 	int level = tl->numa_level;
STR : 	int sd_weight = cpumask_weight(
STR : 			sched_domains_numa_masks[level][cpu_to_node(cpu)]);
STR : 
STR : 	*sd = (struct sched_domain){
STR : 		.min_interval		= sd_weight,
STR : 		.max_interval		= 2*sd_weight,
STR : 		.busy_factor		= 32,
STR : 		.imbalance_pct		= 125,
STR : 		.cache_nice_tries	= 2,
STR : 		.busy_idx		= 3,
STR : 		.idle_idx		= 2,
STR : 		.newidle_idx		= 0,
STR : 		.wake_idx		= 0,
STR : 		.forkexec_idx		= 0,
STR : 
STR : 		.flags			= 1*SD_LOAD_BALANCE
STR : 					| 1*SD_BALANCE_NEWIDLE
STR : 					| 0*SD_BALANCE_EXEC
STR : 					| 0*SD_BALANCE_FORK
STR : 					| 0*SD_BALANCE_WAKE
STR : 					| 0*SD_WAKE_AFFINE
STR : 					| 0*SD_SHARE_CPUPOWER
STR : 					| 0*SD_SHARE_PKG_RESOURCES
STR : 					| 1*SD_SERIALIZE
STR : 					| 0*SD_PREFER_SIBLING
STR : 					| 1*SD_NUMA
STR : 					| sd_local_flags(level)
STR : 					,
STR : 		.last_balance		= jiffies,
STR : 		.balance_interval	= sd_weight,
STR : 	};
STR : 	SD_INIT_NAME(sd, NUMA);
STR : 	sd->private = &tl->data;
STR : 
STR : 	/*
STR : 	 * Ugly hack to pass state to sd_numa_mask()...
STR : 	 */
STR : 	sched_domains_curr_level = tl->numa_level;
STR : 
STR : 	return sd;
STR : }
STR : 
STR : static const struct cpumask *sd_numa_mask(int cpu)
STR : {
STR : 	return sched_domains_numa_masks[sched_domains_curr_level][cpu_to_node(cpu)];
STR : }
STR : 
STR : static void sched_numa_warn(const char *str)
STR : {
STR : 	static int done = false;
STR : 	int i,j;
STR : 
STR : 	if (done)
STR : 		return;
STR : 
STR : 	done = true;
STR : 
STR : 	printk(KERN_WARNING "ERROR: %s\n\n", str);
STR : 
STR : 	for (i = 0; i < nr_node_ids; i++) {
STR : 		printk(KERN_WARNING "  ");
STR : 		for (j = 0; j < nr_node_ids; j++)
STR : 			printk(KERN_CONT "%02d ", node_distance(i,j));
STR : 		printk(KERN_CONT "\n");
STR : 	}
STR : 	printk(KERN_WARNING "\n");
STR : }
STR : 
STR : static bool find_numa_distance(int distance)
STR : {
STR : 	int i;
STR : 
STR : 	if (distance == node_distance(0, 0))
STR : 		return true;
STR : 
STR : 	for (i = 0; i < sched_domains_numa_levels; i++) {
STR : 		if (sched_domains_numa_distance[i] == distance)
STR : 			return true;
STR : 	}
STR : 
STR : 	return false;
STR : }
STR : 
STR : static void sched_init_numa(void)
STR : {
STR : 	int next_distance, curr_distance = node_distance(0, 0);
STR : 	struct sched_domain_topology_level *tl;
STR : 	int level = 0;
STR : 	int i, j, k;
STR : 
STR : 	sched_domains_numa_distance = kzalloc(sizeof(int) * nr_node_ids, GFP_KERNEL);
STR : 	if (!sched_domains_numa_distance)
STR : 		return;
STR : 
STR : 	/*
STR : 	 * O(nr_nodes^2) deduplicating selection sort -- in order to find the
STR : 	 * unique distances in the node_distance() table.
STR : 	 *
STR : 	 * Assumes node_distance(0,j) includes all distances in
STR : 	 * node_distance(i,j) in order to avoid cubic time.
STR : 	 */
STR : 	next_distance = curr_distance;
STR : 	for (i = 0; i < nr_node_ids; i++) {
STR : 		for (j = 0; j < nr_node_ids; j++) {
STR : 			for (k = 0; k < nr_node_ids; k++) {
STR : 				int distance = node_distance(i, k);
STR : 
STR : 				if (distance > curr_distance &&
STR : 				    (distance < next_distance ||
STR : 				     next_distance == curr_distance))
STR : 					next_distance = distance;
STR : 
STR : 				/*
STR : 				 * While not a strong assumption it would be nice to know
STR : 				 * about cases where if node A is connected to B, B is not
STR : 				 * equally connected to A.
STR : 				 */
STR : 				if (sched_debug() && node_distance(k, i) != distance)
STR : 					sched_numa_warn("Node-distance not symmetric");
STR : 
STR : 				if (sched_debug() && i && !find_numa_distance(distance))
STR : 					sched_numa_warn("Node-0 not representative");
STR : 			}
STR : 			if (next_distance != curr_distance) {
STR : 				sched_domains_numa_distance[level++] = next_distance;
STR : 				sched_domains_numa_levels = level;
STR : 				curr_distance = next_distance;
STR : 			} else break;
STR : 		}
STR : 
STR : 		/*
STR : 		 * In case of sched_debug() we verify the above assumption.
STR : 		 */
STR : 		if (!sched_debug())
STR : 			break;
STR : 	}
STR : 	/*
STR : 	 * 'level' contains the number of unique distances, excluding the
STR : 	 * identity distance node_distance(i,i).
STR : 	 *
STR : 	 * The sched_domains_numa_distance[] array includes the actual distance
STR : 	 * numbers.
STR : 	 */
STR : 
STR : 	/*
STR : 	 * Here, we should temporarily reset sched_domains_numa_levels to 0.
STR : 	 * If it fails to allocate memory for array sched_domains_numa_masks[][],
STR : 	 * the array will contain less then 'level' members. This could be
STR : 	 * dangerous when we use it to iterate array sched_domains_numa_masks[][]
STR : 	 * in other functions.
STR : 	 *
STR : 	 * We reset it to 'level' at the end of this function.
STR : 	 */
STR : 	sched_domains_numa_levels = 0;
STR : 
STR : 	sched_domains_numa_masks = kzalloc(sizeof(void *) * level, GFP_KERNEL);
STR : 	if (!sched_domains_numa_masks)
STR : 		return;
STR : 
STR : 	/*
STR : 	 * Now for each level, construct a mask per node which contains all
STR : 	 * cpus of nodes that are that many hops away from us.
STR : 	 */
STR : 	for (i = 0; i < level; i++) {
STR : 		sched_domains_numa_masks[i] =
STR : 			kzalloc(nr_node_ids * sizeof(void *), GFP_KERNEL);
STR : 		if (!sched_domains_numa_masks[i])
STR : 			return;
STR : 
STR : 		for (j = 0; j < nr_node_ids; j++) {
STR : 			struct cpumask *mask = kzalloc(cpumask_size(), GFP_KERNEL);
STR : 			if (!mask)
STR : 				return;
STR : 
STR : 			sched_domains_numa_masks[i][j] = mask;
STR : 
STR : 			for (k = 0; k < nr_node_ids; k++) {
STR : 				if (node_distance(j, k) > sched_domains_numa_distance[i])
STR : 					continue;
STR : 
STR : 				cpumask_or(mask, mask, cpumask_of_node(k));
STR : 			}
STR : 		}
STR : 	}
STR : 
STR : 	tl = kzalloc((ARRAY_SIZE(default_topology) + level) *
STR : 			sizeof(struct sched_domain_topology_level), GFP_KERNEL);
STR : 	if (!tl)
STR : 		return;
STR : 
STR : 	/*
STR : 	 * Copy the default topology bits..
STR : 	 */
STR : 	for (i = 0; default_topology[i].init; i++)
STR : 		tl[i] = default_topology[i];
STR : 
STR : 	/*
STR : 	 * .. and append 'j' levels of NUMA goodness.
STR : 	 */
STR : 	for (j = 0; j < level; i++, j++) {
STR : 		tl[i] = (struct sched_domain_topology_level){
STR : 			.init = sd_numa_init,
STR : 			.mask = sd_numa_mask,
STR : 			.flags = SDTL_OVERLAP,
STR : 			.numa_level = j,
STR : 		};
STR : 	}
STR : 
STR : 	sched_domain_topology = tl;
STR : 
STR : 	sched_domains_numa_levels = level;
STR : }
STR : 
STR : static void sched_domains_numa_masks_set(int cpu)
STR : {
STR : 	int i, j;
STR : 	int node = cpu_to_node(cpu);
STR : 
STR : 	for (i = 0; i < sched_domains_numa_levels; i++) {
STR : 		for (j = 0; j < nr_node_ids; j++) {
STR : 			if (node_distance(j, node) <= sched_domains_numa_distance[i])
STR : 				cpumask_set_cpu(cpu, sched_domains_numa_masks[i][j]);
STR : 		}
STR : 	}
STR : }
STR : 
STR : static void sched_domains_numa_masks_clear(int cpu)
STR : {
STR : 	int i, j;
STR : 	for (i = 0; i < sched_domains_numa_levels; i++) {
STR : 		for (j = 0; j < nr_node_ids; j++)
STR : 			cpumask_clear_cpu(cpu, sched_domains_numa_masks[i][j]);
STR : 	}
STR : }
STR : 
STR : /*
STR :  * Update sched_domains_numa_masks[level][node] array when new cpus
STR :  * are onlined.
STR :  */
STR : static int sched_domains_numa_masks_update(struct notifier_block *nfb,
STR : 					   unsigned long action,
STR : 					   void *hcpu)
STR : {
STR : 	int cpu = (long)hcpu;
STR : 
STR : 	switch (action & ~CPU_TASKS_FROZEN) {
STR : 	case CPU_ONLINE:
STR : 		sched_domains_numa_masks_set(cpu);
STR : 		break;
STR : 
STR : 	case CPU_DEAD:
STR : 		sched_domains_numa_masks_clear(cpu);
STR : 		break;
STR : 
STR : 	default:
STR : 		return NOTIFY_DONE;
STR : 	}
STR : 
STR : 	return NOTIFY_OK;
STR : }
STR : #else
STR : static inline void sched_init_numa(void)
STR : {
STR : }
STR : 
STR : static int sched_domains_numa_masks_update(struct notifier_block *nfb,
STR : 					   unsigned long action,
STR : 					   void *hcpu)
STR : {
STR : 	return 0;
STR : }
STR : #endif /* CONFIG_NUMA */
STR : 
STR : static int __sdt_alloc(const struct cpumask *cpu_map)
STR : {
STR : 	struct sched_domain_topology_level *tl;
STR : 	int j;
STR : 
STR : 	for_each_sd_topology(tl) {
STR : 		struct sd_data *sdd = &tl->data;
STR : 
STR : 		sdd->sd = alloc_percpu(struct sched_domain *);
STR : 		if (!sdd->sd)
STR : 			return -ENOMEM;
STR : 
STR : 		sdd->sg = alloc_percpu(struct sched_group *);
STR : 		if (!sdd->sg)
STR : 			return -ENOMEM;
STR : 
STR : 		sdd->sgp = alloc_percpu(struct sched_group_power *);
STR : 		if (!sdd->sgp)
STR : 			return -ENOMEM;
STR : 
STR : 		for_each_cpu(j, cpu_map) {
STR : 			struct sched_domain *sd;
STR : 			struct sched_group *sg;
STR : 			struct sched_group_power *sgp;
STR : 
STR : 		       	sd = kzalloc_node(sizeof(struct sched_domain) + cpumask_size(),
STR : 					GFP_KERNEL, cpu_to_node(j));
STR : 			if (!sd)
STR : 				return -ENOMEM;
STR : 
STR : 			*per_cpu_ptr(sdd->sd, j) = sd;
STR : 
STR : 			sg = kzalloc_node(sizeof(struct sched_group) + cpumask_size(),
STR : 					GFP_KERNEL, cpu_to_node(j));
STR : 			if (!sg)
STR : 				return -ENOMEM;
STR : 
STR : 			sg->next = sg;
STR : 
STR : 			*per_cpu_ptr(sdd->sg, j) = sg;
STR : 
STR : 			sgp = kzalloc_node(sizeof(struct sched_group_power) + cpumask_size(),
STR : 					GFP_KERNEL, cpu_to_node(j));
STR : 			if (!sgp)
STR : 				return -ENOMEM;
STR : 
STR : 			*per_cpu_ptr(sdd->sgp, j) = sgp;
STR : 		}
STR : 	}
STR : 
STR : 	return 0;
STR : }
STR : 
STR : static void __sdt_free(const struct cpumask *cpu_map)
STR : {
STR : 	struct sched_domain_topology_level *tl;
STR : 	int j;
STR : 
STR : 	for_each_sd_topology(tl) {
STR : 		struct sd_data *sdd = &tl->data;
STR : 
STR : 		for_each_cpu(j, cpu_map) {
STR : 			struct sched_domain *sd;
STR : 
STR : 			if (sdd->sd) {
STR : 				sd = *per_cpu_ptr(sdd->sd, j);
STR : 				if (sd && (sd->flags & SD_OVERLAP))
STR : 					free_sched_groups(sd->groups, 0);
STR : 				kfree(*per_cpu_ptr(sdd->sd, j));
STR : 			}
STR : 
STR : 			if (sdd->sg)
STR : 				kfree(*per_cpu_ptr(sdd->sg, j));
STR : 			if (sdd->sgp)
STR : 				kfree(*per_cpu_ptr(sdd->sgp, j));
STR : 		}
STR : 		free_percpu(sdd->sd);
STR : 		sdd->sd = NULL;
STR : 		free_percpu(sdd->sg);
STR : 		sdd->sg = NULL;
STR : 		free_percpu(sdd->sgp);
STR : 		sdd->sgp = NULL;
STR : 	}
STR : }
STR : 
STR : struct sched_domain *build_sched_domain(struct sched_domain_topology_level *tl,
STR : 		const struct cpumask *cpu_map, struct sched_domain_attr *attr,
STR : 		struct sched_domain *child, int cpu)
STR : {
STR : 	struct sched_domain *sd = tl->init(tl, cpu);
STR : 	if (!sd)
STR : 		return child;
STR : 
STR : 	cpumask_and(sched_domain_span(sd), cpu_map, tl->mask(cpu));
STR : 	if (child) {
STR : 		sd->level = child->level + 1;
STR : 		sched_domain_level_max = max(sched_domain_level_max, sd->level);
STR : 		child->parent = sd;
STR : 		sd->child = child;
STR : 	}
STR : 	set_domain_attribute(sd, attr);
STR : 
STR : 	return sd;
STR : }
STR : 
STR : /*
STR :  * Build sched domains for a given set of cpus and attach the sched domains
STR :  * to the individual cpus
STR :  */
STR : static int build_sched_domains(const struct cpumask *cpu_map,
STR : 			       struct sched_domain_attr *attr)
STR : {
STR : 	enum s_alloc alloc_state;
STR : 	struct sched_domain *sd;
STR : 	struct s_data d;
STR : 	int i, ret = -ENOMEM;
STR : 
STR : 	alloc_state = __visit_domain_allocation_hell(&d, cpu_map);
STR : 	if (alloc_state != sa_rootdomain)
STR : 		goto error;
STR : 
STR : 	/* Set up domains for cpus specified by the cpu_map. */
STR : 	for_each_cpu(i, cpu_map) {
STR : 		struct sched_domain_topology_level *tl;
STR : 
STR : 		sd = NULL;
STR : 		for_each_sd_topology(tl) {
STR : 			sd = build_sched_domain(tl, cpu_map, attr, sd, i);
STR : 			if (tl == sched_domain_topology)
STR : 				*per_cpu_ptr(d.sd, i) = sd;
STR : 			if (tl->flags & SDTL_OVERLAP || sched_feat(FORCE_SD_OVERLAP))
STR : 				sd->flags |= SD_OVERLAP;
STR : 			if (cpumask_equal(cpu_map, sched_domain_span(sd)))
STR : 				break;
STR : 		}
STR : 	}
STR : 
STR : 	/* Build the groups for the domains */
STR : 	for_each_cpu(i, cpu_map) {
STR : 		for (sd = *per_cpu_ptr(d.sd, i); sd; sd = sd->parent) {
STR : 			sd->span_weight = cpumask_weight(sched_domain_span(sd));
STR : 			if (sd->flags & SD_OVERLAP) {
STR : 				if (build_overlap_sched_groups(sd, i))
STR : 					goto error;
STR : 			} else {
STR : 				if (build_sched_groups(sd, i))
STR : 					goto error;
STR : 			}
STR : 		}
STR : 	}
STR : 
STR : 	/* Calculate CPU power for physical packages and nodes */
STR : 	for (i = nr_cpumask_bits-1; i >= 0; i--) {
STR : 		if (!cpumask_test_cpu(i, cpu_map))
STR : 			continue;
STR : 
STR : 		for (sd = *per_cpu_ptr(d.sd, i); sd; sd = sd->parent) {
STR : 			claim_allocations(i, sd);
STR : 			init_sched_groups_power(i, sd);
STR : 		}
STR : 	}
STR : 
STR : 	/* Attach the domains */
STR : 	rcu_read_lock();
STR : 	for_each_cpu(i, cpu_map) {
STR : 		sd = *per_cpu_ptr(d.sd, i);
STR : 		cpu_attach_domain(sd, d.rd, i);
STR : 	}
STR : 	rcu_read_unlock();
STR : 
STR : 	ret = 0;
STR : error:
STR : 	__free_domain_allocs(&d, alloc_state, cpu_map);
STR : 	return ret;
STR : }
STR : 
STR : static cpumask_var_t *doms_cur;	/* current sched domains */
STR : static int ndoms_cur;		/* number of sched domains in 'doms_cur' */
STR : static struct sched_domain_attr *dattr_cur;
STR : 				/* attribues of custom domains in 'doms_cur' */
STR : 
STR : /*
STR :  * Special case: If a kmalloc of a doms_cur partition (array of
STR :  * cpumask) fails, then fallback to a single sched domain,
STR :  * as determined by the single cpumask fallback_doms.
STR :  */
STR : static cpumask_var_t fallback_doms;
STR : 
STR : /*
STR :  * arch_update_cpu_topology lets virtualized architectures update the
STR :  * cpu core maps. It is supposed to return 1 if the topology changed
STR :  * or 0 if it stayed the same.
STR :  */
STR : int __attribute__((weak)) arch_update_cpu_topology(void)
STR : {
STR : 	return 0;
STR : }
STR : 
STR : cpumask_var_t *alloc_sched_domains(unsigned int ndoms)
STR : {
STR : 	int i;
STR : 	cpumask_var_t *doms;
STR : 
STR : 	doms = kmalloc(sizeof(*doms) * ndoms, GFP_KERNEL);
STR : 	if (!doms)
STR : 		return NULL;
STR : 	for (i = 0; i < ndoms; i++) {
STR : 		if (!alloc_cpumask_var(&doms[i], GFP_KERNEL)) {
STR : 			free_sched_domains(doms, i);
STR : 			return NULL;
STR : 		}
STR : 	}
STR : 	return doms;
STR : }
STR : 
STR : void free_sched_domains(cpumask_var_t doms[], unsigned int ndoms)
STR : {
STR : 	unsigned int i;
STR : 	for (i = 0; i < ndoms; i++)
STR : 		free_cpumask_var(doms[i]);
STR : 	kfree(doms);
STR : }
STR : 
STR : /*
STR :  * Set up scheduler domains and groups. Callers must hold the hotplug lock.
STR :  * For now this just excludes isolated cpus, but could be used to
STR :  * exclude other special cases in the future.
STR :  */
STR : static int init_sched_domains(const struct cpumask *cpu_map)
STR : {
STR : 	int err;
STR : 
STR : 	arch_update_cpu_topology();
STR : 	ndoms_cur = 1;
STR : 	doms_cur = alloc_sched_domains(ndoms_cur);
STR : 	if (!doms_cur)
STR : 		doms_cur = &fallback_doms;
STR : 	cpumask_andnot(doms_cur[0], cpu_map, cpu_isolated_map);
STR : 	err = build_sched_domains(doms_cur[0], NULL);
STR : 	register_sched_domain_sysctl();
STR : 
STR : 	return err;
STR : }
STR : 
STR : /*
STR :  * Detach sched domains from a group of cpus specified in cpu_map
STR :  * These cpus will now be attached to the NULL domain
STR :  */
STR : static void detach_destroy_domains(const struct cpumask *cpu_map)
STR : {
STR : 	int i;
STR : 
STR : 	rcu_read_lock();
STR : 	for_each_cpu(i, cpu_map)
STR : 		cpu_attach_domain(NULL, &def_root_domain, i);
STR : 	rcu_read_unlock();
STR : }
STR : 
STR : /* handle null as "default" */
STR : static int dattrs_equal(struct sched_domain_attr *cur, int idx_cur,
STR : 			struct sched_domain_attr *new, int idx_new)
STR : {
STR : 	struct sched_domain_attr tmp;
STR : 
STR : 	/* fast path */
STR : 	if (!new && !cur)
STR : 		return 1;
STR : 
STR : 	tmp = SD_ATTR_INIT;
STR : 	return !memcmp(cur ? (cur + idx_cur) : &tmp,
STR : 			new ? (new + idx_new) : &tmp,
STR : 			sizeof(struct sched_domain_attr));
STR : }
STR : 
STR : /*
STR :  * Partition sched domains as specified by the 'ndoms_new'
STR :  * cpumasks in the array doms_new[] of cpumasks. This compares
STR :  * doms_new[] to the current sched domain partitioning, doms_cur[].
STR :  * It destroys each deleted domain and builds each new domain.
STR :  *
STR :  * 'doms_new' is an array of cpumask_var_t's of length 'ndoms_new'.
STR :  * The masks don't intersect (don't overlap.) We should setup one
STR :  * sched domain for each mask. CPUs not in any of the cpumasks will
STR :  * not be load balanced. If the same cpumask appears both in the
STR :  * current 'doms_cur' domains and in the new 'doms_new', we can leave
STR :  * it as it is.
STR :  *
STR :  * The passed in 'doms_new' should be allocated using
STR :  * alloc_sched_domains.  This routine takes ownership of it and will
STR :  * free_sched_domains it when done with it. If the caller failed the
STR :  * alloc call, then it can pass in doms_new == NULL && ndoms_new == 1,
STR :  * and partition_sched_domains() will fallback to the single partition
STR :  * 'fallback_doms', it also forces the domains to be rebuilt.
STR :  *
STR :  * If doms_new == NULL it will be replaced with cpu_online_mask.
STR :  * ndoms_new == 0 is a special case for destroying existing domains,
STR :  * and it will not create the default domain.
STR :  *
STR :  * Call with hotplug lock held
STR :  */
STR : void partition_sched_domains(int ndoms_new, cpumask_var_t doms_new[],
STR : 			     struct sched_domain_attr *dattr_new)
STR : {
STR : 	int i, j, n;
STR : 	int new_topology;
STR : 
STR : 	mutex_lock(&sched_domains_mutex);
STR : 
STR : 	/* always unregister in case we don't destroy any domains */
STR : 	unregister_sched_domain_sysctl();
STR : 
STR : 	/* Let architecture update cpu core mappings. */
STR : 	new_topology = arch_update_cpu_topology();
STR : 
STR : 	n = doms_new ? ndoms_new : 0;
STR : 
STR : 	/* Destroy deleted domains */
STR : 	for (i = 0; i < ndoms_cur; i++) {
STR : 		for (j = 0; j < n && !new_topology; j++) {
STR : 			if (cpumask_equal(doms_cur[i], doms_new[j])
STR : 			    && dattrs_equal(dattr_cur, i, dattr_new, j))
STR : 				goto match1;
STR : 		}
STR : 		/* no match - a current sched domain not in new doms_new[] */
STR : 		detach_destroy_domains(doms_cur[i]);
STR : match1:
STR : 		;
STR : 	}
STR : 
STR : 	n = ndoms_cur;
STR : 	if (doms_new == NULL) {
STR : 		n = 0;
STR : 		doms_new = &fallback_doms;
STR : 		cpumask_andnot(doms_new[0], cpu_active_mask, cpu_isolated_map);
STR : 		WARN_ON_ONCE(dattr_new);
STR : 	}
STR : 
STR : 	/* Build new domains */
STR : 	for (i = 0; i < ndoms_new; i++) {
STR : 		for (j = 0; j < n && !new_topology; j++) {
STR : 			if (cpumask_equal(doms_new[i], doms_cur[j])
STR : 			    && dattrs_equal(dattr_new, i, dattr_cur, j))
STR : 				goto match2;
STR : 		}
STR : 		/* no match - add a new doms_new */
STR : 		build_sched_domains(doms_new[i], dattr_new ? dattr_new + i : NULL);
STR : match2:
STR : 		;
STR : 	}
STR : 
STR : 	/* Remember the new sched domains */
STR : 	if (doms_cur != &fallback_doms)
STR : 		free_sched_domains(doms_cur, ndoms_cur);
STR : 	kfree(dattr_cur);	/* kfree(NULL) is safe */
STR : 	doms_cur = doms_new;
STR : 	dattr_cur = dattr_new;
STR : 	ndoms_cur = ndoms_new;
STR : 
STR : 	register_sched_domain_sysctl();
STR : 
STR : 	mutex_unlock(&sched_domains_mutex);
STR : }
STR : 
STR : static int num_cpus_frozen;	/* used to mark begin/end of suspend/resume */
STR : 
STR : /*
STR :  * Update cpusets according to cpu_active mask.  If cpusets are
STR :  * disabled, cpuset_update_active_cpus() becomes a simple wrapper
STR :  * around partition_sched_domains().
STR :  *
STR :  * If we come here as part of a suspend/resume, don't touch cpusets because we
STR :  * want to restore it back to its original state upon resume anyway.
STR :  */
STR : static int cpuset_cpu_active(struct notifier_block *nfb, unsigned long action,
STR : 			     void *hcpu)
STR : {
STR : 	switch (action) {
STR : 	case CPU_ONLINE_FROZEN:
STR : 	case CPU_DOWN_FAILED_FROZEN:
STR : 
STR : 		/*
STR : 		 * num_cpus_frozen tracks how many CPUs are involved in suspend
STR : 		 * resume sequence. As long as this is not the last online
STR : 		 * operation in the resume sequence, just build a single sched
STR : 		 * domain, ignoring cpusets.
STR : 		 */
STR : 		num_cpus_frozen--;
STR : 		if (likely(num_cpus_frozen)) {
STR : 			partition_sched_domains(1, NULL, NULL);
STR : 			break;
STR : 		}
STR : 
STR : 		/*
STR : 		 * This is the last CPU online operation. So fall through and
STR : 		 * restore the original sched domains by considering the
STR : 		 * cpuset configurations.
STR : 		 */
STR : 
STR : 	case CPU_ONLINE:
STR : 	case CPU_DOWN_FAILED:
STR : 		cpuset_update_active_cpus(true);
STR : 		break;
STR : 	default:
STR : 		return NOTIFY_DONE;
STR : 	}
STR : 	return NOTIFY_OK;
STR : }
STR : 
STR : static int cpuset_cpu_inactive(struct notifier_block *nfb, unsigned long action,
STR : 			       void *hcpu)
STR : {
STR : 	switch (action) {
STR : 	case CPU_DOWN_PREPARE:
STR : 		cpuset_update_active_cpus(false);
STR : 		break;
STR : 	case CPU_DOWN_PREPARE_FROZEN:
STR : 		num_cpus_frozen++;
STR : 		partition_sched_domains(1, NULL, NULL);
STR : 		break;
STR : 	default:
STR : 		return NOTIFY_DONE;
STR : 	}
STR : 	return NOTIFY_OK;
STR : }
STR : 
STR : void __init sched_init_smp(void)
STR : {
STR : 	cpumask_var_t non_isolated_cpus;
STR : 
STR : 	alloc_cpumask_var(&non_isolated_cpus, GFP_KERNEL);
STR : 	alloc_cpumask_var(&fallback_doms, GFP_KERNEL);
STR : 
STR : 	sched_init_numa();
STR : 
STR : 	/*
STR : 	 * There's no userspace yet to cause hotplug operations; hence all the
STR : 	 * cpu masks are stable and all blatant races in the below code cannot
STR : 	 * happen.
STR : 	 */
STR : 	mutex_lock(&sched_domains_mutex);
STR : 	init_sched_domains(cpu_active_mask);
STR : 	cpumask_andnot(non_isolated_cpus, cpu_possible_mask, cpu_isolated_map);
STR : 	if (cpumask_empty(non_isolated_cpus))
STR : 		cpumask_set_cpu(smp_processor_id(), non_isolated_cpus);
STR : 	mutex_unlock(&sched_domains_mutex);
STR : 
STR : 	hotcpu_notifier(sched_domains_numa_masks_update, CPU_PRI_SCHED_ACTIVE);
STR : 	hotcpu_notifier(cpuset_cpu_active, CPU_PRI_CPUSET_ACTIVE);
STR : 	hotcpu_notifier(cpuset_cpu_inactive, CPU_PRI_CPUSET_INACTIVE);
STR : 
STR : 	init_hrtick();
STR : 
STR : 	/* Move init over to a non-isolated CPU */
STR : 	if (set_cpus_allowed_ptr(current, non_isolated_cpus) < 0)
STR : 		BUG();
STR : 	sched_init_granularity();
STR : 	free_cpumask_var(non_isolated_cpus);
STR : 
STR : 	init_sched_rt_class();
STR : 	init_sched_dl_class();
STR : }
STR : #else
STR : void __init sched_init_smp(void)
STR : {
STR : 	sched_init_granularity();
STR : }
STR : #endif /* CONFIG_SMP */
STR : 
STR : const_debug unsigned int sysctl_timer_migration = 1;
STR : 
STR : int in_sched_functions(unsigned long addr)
STR : {
STR : 	return in_lock_functions(addr) ||
STR : 		(addr >= (unsigned long)__sched_text_start
STR : 		&& addr < (unsigned long)__sched_text_end);
STR : }
STR : 
STR : #ifdef CONFIG_CGROUP_SCHED
STR : /*
STR :  * Default task group.
STR :  * Every task in system belongs to this group at bootup.
STR :  */
STR : struct task_group root_task_group;
STR : LIST_HEAD(task_groups);
STR : #endif
STR : 
STR : DECLARE_PER_CPU(cpumask_var_t, load_balance_mask);
STR : 
STR : void __init sched_init(void)
STR : {
STR : 	int i, j;
STR : 	unsigned long alloc_size = 0, ptr;
STR : 
STR : #ifdef CONFIG_FAIR_GROUP_SCHED
STR : 	alloc_size += 2 * nr_cpu_ids * sizeof(void **);
STR : #endif
STR : #ifdef CONFIG_RT_GROUP_SCHED
STR : 	alloc_size += 2 * nr_cpu_ids * sizeof(void **);
STR : #endif
STR : #ifdef CONFIG_CPUMASK_OFFSTACK
STR : 	alloc_size += num_possible_cpus() * cpumask_size();
STR : #endif
STR : 	if (alloc_size) {
STR : 		ptr = (unsigned long)kzalloc(alloc_size, GFP_NOWAIT);
STR : 
STR : #ifdef CONFIG_FAIR_GROUP_SCHED
STR : 		root_task_group.se = (struct sched_entity **)ptr;
STR : 		ptr += nr_cpu_ids * sizeof(void **);
STR : 
STR : 		root_task_group.cfs_rq = (struct cfs_rq **)ptr;
STR : 		ptr += nr_cpu_ids * sizeof(void **);
STR : 
STR : #endif /* CONFIG_FAIR_GROUP_SCHED */
STR : #ifdef CONFIG_RT_GROUP_SCHED
STR : 		root_task_group.rt_se = (struct sched_rt_entity **)ptr;
STR : 		ptr += nr_cpu_ids * sizeof(void **);
STR : 
STR : 		root_task_group.rt_rq = (struct rt_rq **)ptr;
STR : 		ptr += nr_cpu_ids * sizeof(void **);
STR : 
STR : #endif /* CONFIG_RT_GROUP_SCHED */
STR : #ifdef CONFIG_CPUMASK_OFFSTACK
STR : 		for_each_possible_cpu(i) {
STR : 			per_cpu(load_balance_mask, i) = (void *)ptr;
STR : 			ptr += cpumask_size();
STR : 		}
STR : #endif /* CONFIG_CPUMASK_OFFSTACK */
STR : 	}
STR : 
STR : 	init_rt_bandwidth(&def_rt_bandwidth,
STR : 			global_rt_period(), global_rt_runtime());
STR : 	init_dl_bandwidth(&def_dl_bandwidth,
STR : 			global_rt_period(), global_rt_runtime());
STR : 
STR : #ifdef CONFIG_SMP
STR : 	init_defrootdomain();
STR : #endif
STR : 
STR : #ifdef CONFIG_RT_GROUP_SCHED
STR : 	init_rt_bandwidth(&root_task_group.rt_bandwidth,
STR : 			global_rt_period(), global_rt_runtime());
STR : #endif /* CONFIG_RT_GROUP_SCHED */
STR : 
STR : #ifdef CONFIG_CGROUP_SCHED
STR : 	list_add(&root_task_group.list, &task_groups);
STR : 	INIT_LIST_HEAD(&root_task_group.children);
STR : 	INIT_LIST_HEAD(&root_task_group.siblings);
STR : 	autogroup_init(&init_task);
STR : 
STR : #endif /* CONFIG_CGROUP_SCHED */
STR : 
STR : 	for_each_possible_cpu(i) {
STR : 		struct rq *rq;
STR : 
STR : 		rq = cpu_rq(i);
STR : 		raw_spin_lock_init(&rq->lock);
STR : 		rq->nr_running = 0;
STR : 		rq->calc_load_active = 0;
STR : 		rq->calc_load_update = jiffies + LOAD_FREQ;
STR : 		init_cfs_rq(&rq->cfs);
STR : 		init_rt_rq(&rq->rt, rq);
STR : 		init_dl_rq(&rq->dl, rq);
STR : #ifdef CONFIG_FAIR_GROUP_SCHED
STR : 		root_task_group.shares = ROOT_TASK_GROUP_LOAD;
STR : 		INIT_LIST_HEAD(&rq->leaf_cfs_rq_list);
STR : 		/*
STR : 		 * How much cpu bandwidth does root_task_group get?
STR : 		 *
STR : 		 * In case of task-groups formed thr' the cgroup filesystem, it
STR : 		 * gets 100% of the cpu resources in the system. This overall
STR : 		 * system cpu resource is divided among the tasks of
STR : 		 * root_task_group and its child task-groups in a fair manner,
STR : 		 * based on each entity's (task or task-group's) weight
STR : 		 * (se->load.weight).
STR : 		 *
STR : 		 * In other words, if root_task_group has 10 tasks of weight
STR : 		 * 1024) and two child groups A0 and A1 (of weight 1024 each),
STR : 		 * then A0's share of the cpu resource is:
STR : 		 *
STR : 		 *	A0's bandwidth = 1024 / (10*1024 + 1024 + 1024) = 8.33%
STR : 		 *
STR : 		 * We achieve this by letting root_task_group's tasks sit
STR : 		 * directly in rq->cfs (i.e root_task_group->se[] = NULL).
STR : 		 */
STR : 		init_cfs_bandwidth(&root_task_group.cfs_bandwidth);
STR : 		init_tg_cfs_entry(&root_task_group, &rq->cfs, NULL, i, NULL);
STR : #endif /* CONFIG_FAIR_GROUP_SCHED */
STR : 
STR : 		rq->rt.rt_runtime = def_rt_bandwidth.rt_runtime;
STR : #ifdef CONFIG_RT_GROUP_SCHED
STR : 		INIT_LIST_HEAD(&rq->leaf_rt_rq_list);
STR : 		init_tg_rt_entry(&root_task_group, &rq->rt, NULL, i, NULL);
STR : #endif
STR : 
STR : 		for (j = 0; j < CPU_LOAD_IDX_MAX; j++)
STR : 			rq->cpu_load[j] = 0;
STR : 
STR : 		rq->last_load_update_tick = jiffies;
STR : 
STR : #ifdef CONFIG_SMP
STR : 		rq->sd = NULL;
STR : 		rq->rd = NULL;
STR : 		rq->cpu_power = SCHED_POWER_SCALE;
STR : 		rq->post_schedule = 0;
STR : 		rq->active_balance = 0;
STR : 		rq->next_balance = jiffies;
STR : 		rq->push_cpu = 0;
STR : 		rq->cpu = i;
STR : 		rq->online = 0;
STR : 		rq->idle_stamp = 0;
STR : 		rq->avg_idle = 2*sysctl_sched_migration_cost;
STR : 		rq->max_idle_balance_cost = sysctl_sched_migration_cost;
STR : 
STR : 		INIT_LIST_HEAD(&rq->cfs_tasks);
STR : 
STR : 		rq_attach_root(rq, &def_root_domain);
STR : #ifdef CONFIG_NO_HZ_COMMON
STR : 		rq->nohz_flags = 0;
STR : #endif
STR : #ifdef CONFIG_NO_HZ_FULL
STR : 		rq->last_sched_tick = 0;
STR : #endif
STR : #endif
STR : 		init_rq_hrtick(rq);
STR : 		atomic_set(&rq->nr_iowait, 0);
STR : 	}
STR : 
STR : 	set_load_weight(&init_task);
STR : 
STR : #ifdef CONFIG_PREEMPT_NOTIFIERS
STR : 	INIT_HLIST_HEAD(&init_task.preempt_notifiers);
STR : #endif
STR : 
STR : 	/*
STR : 	 * The boot idle thread does lazy MMU switching as well:
STR : 	 */
STR : 	atomic_inc(&init_mm.mm_count);
STR : 	enter_lazy_tlb(&init_mm, current);
STR : 
STR : 	/*
STR : 	 * Make us the idle thread. Technically, schedule() should not be
STR : 	 * called from this thread, however somewhere below it might be,
STR : 	 * but because we are the idle thread, we just pick up running again
STR : 	 * when this runqueue becomes "idle".
STR : 	 */
STR : 	init_idle(current, smp_processor_id());
STR : 
STR : 	calc_load_update = jiffies + LOAD_FREQ;
STR : 
STR : 	/*
STR : 	 * During early bootup we pretend to be a normal task:
STR : 	 */
STR : 	current->sched_class = &fair_sched_class;
STR : 
STR : #ifdef CONFIG_SMP
STR : 	zalloc_cpumask_var(&sched_domains_tmpmask, GFP_NOWAIT);
STR : 	/* May be allocated at isolcpus cmdline parse time */
STR : 	if (cpu_isolated_map == NULL)
STR : 		zalloc_cpumask_var(&cpu_isolated_map, GFP_NOWAIT);
STR : 	idle_thread_set_boot_cpu();
STR : #endif
STR : 	init_sched_fair_class();
STR : 
STR : 	scheduler_running = 1;
STR : }
STR : 
STR : #ifdef CONFIG_DEBUG_ATOMIC_SLEEP
STR : static inline int preempt_count_equals(int preempt_offset)
STR : {
STR : 	int nested = (preempt_count() & ~PREEMPT_ACTIVE) + rcu_preempt_depth();
STR : 
STR : 	return (nested == preempt_offset);
STR : }
STR : 
STR : void __might_sleep(const char *file, int line, int preempt_offset)
STR : {
STR : 	static unsigned long prev_jiffy;	/* ratelimiting */
STR : 
STR : 	rcu_sleep_check(); /* WARN_ON_ONCE() by default, no rate limit reqd. */
STR : 	if ((preempt_count_equals(preempt_offset) && !irqs_disabled()) ||
STR : 	    system_state != SYSTEM_RUNNING || oops_in_progress)
STR : 		return;
STR : 	if (time_before(jiffies, prev_jiffy + HZ) && prev_jiffy)
STR : 		return;
STR : 	prev_jiffy = jiffies;
STR : 
STR : 	printk(KERN_ERR
STR : 		"BUG: sleeping function called from invalid context at %s:%d\n",
STR : 			file, line);
STR : 	printk(KERN_ERR
STR : 		"in_atomic(): %d, irqs_disabled(): %d, pid: %d, name: %s\n",
STR : 			in_atomic(), irqs_disabled(),
STR : 			current->pid, current->comm);
STR : 
STR : 	debug_show_held_locks(current);
STR : 	if (irqs_disabled())
STR : 		print_irqtrace_events(current);
STR : 	dump_stack();
STR : }
STR : EXPORT_SYMBOL(__might_sleep);
STR : #endif
STR : 
STR : #ifdef CONFIG_MAGIC_SYSRQ
STR : static void normalize_task(struct rq *rq, struct task_struct *p)
STR : {
STR : 	const struct sched_class *prev_class = p->sched_class;
STR : 	struct sched_attr attr = {
STR : 		.sched_policy = SCHED_NORMAL,
STR : 	};
STR : 	int old_prio = p->prio;
STR : 	int on_rq;
STR : 
STR : 	on_rq = p->on_rq;
STR : 	if (on_rq)
STR : 		dequeue_task(rq, p, 0);
STR : 	__setscheduler(rq, p, &attr);
STR : 	if (on_rq) {
STR : 		enqueue_task(rq, p, 0);
STR : 		resched_task(rq->curr);
STR : 	}
STR : 
STR : 	check_class_changed(rq, p, prev_class, old_prio);
STR : }
STR : 
STR : void normalize_rt_tasks(void)
STR : {
STR : 	struct task_struct *g, *p;
STR : 	unsigned long flags;
STR : 	struct rq *rq;
STR : 
STR : 	read_lock_irqsave(&tasklist_lock, flags);
STR : 	do_each_thread(g, p) {
STR : 		/*
STR : 		 * Only normalize user tasks:
STR : 		 */
STR : 		if (!p->mm)
STR : 			continue;
STR : 
STR : 		p->se.exec_start		= 0;
STR : #ifdef CONFIG_SCHEDSTATS
STR : 		p->se.statistics.wait_start	= 0;
STR : 		p->se.statistics.sleep_start	= 0;
STR : 		p->se.statistics.block_start	= 0;
STR : #endif
STR : 
STR : 		if (!dl_task(p) && !rt_task(p)) {
STR : 			/*
STR : 			 * Renice negative nice level userspace
STR : 			 * tasks back to 0:
STR : 			 */
STR : 			if (TASK_NICE(p) < 0 && p->mm)
STR : 				set_user_nice(p, 0);
STR : 			continue;
STR : 		}
STR : 
STR : 		raw_spin_lock(&p->pi_lock);
STR : 		rq = __task_rq_lock(p);
STR : 
STR : 		normalize_task(rq, p);
STR : 
STR : 		__task_rq_unlock(rq);
STR : 		raw_spin_unlock(&p->pi_lock);
STR : 	} while_each_thread(g, p);
STR : 
STR : 	read_unlock_irqrestore(&tasklist_lock, flags);
STR : }
STR : 
STR : #endif /* CONFIG_MAGIC_SYSRQ */
STR : 
STR : #if defined(CONFIG_IA64) || defined(CONFIG_KGDB_KDB)
STR : /*
STR :  * These functions are only useful for the IA64 MCA handling, or kdb.
STR :  *
STR :  * They can only be called when the whole system has been
STR :  * stopped - every CPU needs to be quiescent, and no scheduling
STR :  * activity can take place. Using them for anything else would
STR :  * be a serious bug, and as a result, they aren't even visible
STR :  * under any other configuration.
STR :  */
STR : 
STR : /**
STR :  * curr_task - return the current task for a given cpu.
STR :  * @cpu: the processor in question.
STR :  *
STR :  * ONLY VALID WHEN THE WHOLE SYSTEM IS STOPPED!
STR :  *
STR :  * Return: The current task for @cpu.
STR :  */
STR : struct task_struct *curr_task(int cpu)
STR : {
STR : 	return cpu_curr(cpu);
STR : }
STR : 
STR : #endif /* defined(CONFIG_IA64) || defined(CONFIG_KGDB_KDB) */
STR : 
STR : #ifdef CONFIG_IA64
STR : /**
STR :  * set_curr_task - set the current task for a given cpu.
STR :  * @cpu: the processor in question.
STR :  * @p: the task pointer to set.
STR :  *
STR :  * Description: This function must only be used when non-maskable interrupts
STR :  * are serviced on a separate stack. It allows the architecture to switch the
STR :  * notion of the current task on a cpu in a non-blocking manner. This function
STR :  * must be called with all CPU's synchronized, and interrupts disabled, the
STR :  * and caller must save the original value of the current task (see
STR :  * curr_task() above) and restore that value before reenabling interrupts and
STR :  * re-starting the system.
STR :  *
STR :  * ONLY VALID WHEN THE WHOLE SYSTEM IS STOPPED!
STR :  */
STR : void set_curr_task(int cpu, struct task_struct *p)
STR : {
STR : 	cpu_curr(cpu) = p;
STR : }
STR : 
STR : #endif
STR : 
STR : #ifdef CONFIG_CGROUP_SCHED
STR : /* task_group_lock serializes the addition/removal of task groups */
STR : static DEFINE_SPINLOCK(task_group_lock);
STR : 
STR : static void free_sched_group(struct task_group *tg)
STR : {
STR : 	free_fair_sched_group(tg);
STR : 	free_rt_sched_group(tg);
STR : 	autogroup_free(tg);
STR : 	kfree(tg);
STR : }
STR : 
STR : /* allocate runqueue etc for a new task group */
STR : struct task_group *sched_create_group(struct task_group *parent)
STR : {
STR : 	struct task_group *tg;
STR : 
STR : 	tg = kzalloc(sizeof(*tg), GFP_KERNEL);
STR : 	if (!tg)
STR : 		return ERR_PTR(-ENOMEM);
STR : 
STR : 	if (!alloc_fair_sched_group(tg, parent))
STR : 		goto err;
STR : 
STR : 	if (!alloc_rt_sched_group(tg, parent))
STR : 		goto err;
STR : 
STR : 	return tg;
STR : 
STR : err:
STR : 	free_sched_group(tg);
STR : 	return ERR_PTR(-ENOMEM);
STR : }
STR : 
STR : void sched_online_group(struct task_group *tg, struct task_group *parent)
STR : {
STR : 	unsigned long flags;
STR : 
STR : 	spin_lock_irqsave(&task_group_lock, flags);
STR : 	list_add_rcu(&tg->list, &task_groups);
STR : 
STR : 	WARN_ON(!parent); /* root should already exist */
STR : 
STR : 	tg->parent = parent;
STR : 	INIT_LIST_HEAD(&tg->children);
STR : 	list_add_rcu(&tg->siblings, &parent->children);
STR : 	spin_unlock_irqrestore(&task_group_lock, flags);
STR : }
STR : 
STR : /* rcu callback to free various structures associated with a task group */
STR : static void free_sched_group_rcu(struct rcu_head *rhp)
STR : {
STR : 	/* now it should be safe to free those cfs_rqs */
STR : 	free_sched_group(container_of(rhp, struct task_group, rcu));
STR : }
STR : 
STR : /* Destroy runqueue etc associated with a task group */
STR : void sched_destroy_group(struct task_group *tg)
STR : {
STR : 	/* wait for possible concurrent references to cfs_rqs complete */
STR : 	call_rcu(&tg->rcu, free_sched_group_rcu);
STR : }
STR : 
STR : void sched_offline_group(struct task_group *tg)
STR : {
STR : 	unsigned long flags;
STR : 	int i;
STR : 
STR : 	/* end participation in shares distribution */
STR : 	for_each_possible_cpu(i)
STR : 		unregister_fair_sched_group(tg, i);
STR : 
STR : 	spin_lock_irqsave(&task_group_lock, flags);
STR : 	list_del_rcu(&tg->list);
STR : 	list_del_rcu(&tg->siblings);
STR : 	spin_unlock_irqrestore(&task_group_lock, flags);
STR : }
STR : 
STR : /* change task's runqueue when it moves between groups.
STR :  *	The caller of this function should have put the task in its new group
STR :  *	by now. This function just updates tsk->se.cfs_rq and tsk->se.parent to
STR :  *	reflect its new group.
STR :  */
STR : void sched_move_task(struct task_struct *tsk)
STR : {
STR : 	struct task_group *tg;
STR : 	int on_rq, running;
STR : 	unsigned long flags;
STR : 	struct rq *rq;
STR : 
STR : 	rq = task_rq_lock(tsk, &flags);
STR : 
STR : 	running = task_current(rq, tsk);
STR : 	on_rq = tsk->on_rq;
STR : 
STR : 	if (on_rq)
STR : 		dequeue_task(rq, tsk, 0);
STR : 	if (unlikely(running))
STR : 		tsk->sched_class->put_prev_task(rq, tsk);
STR : 
STR : 	tg = container_of(task_css_check(tsk, cpu_cgroup_subsys_id,
STR : 				lockdep_is_held(&tsk->sighand->siglock)),
STR : 			  struct task_group, css);
STR : 	tg = autogroup_task_group(tsk, tg);
STR : 	tsk->sched_task_group = tg;
STR : 
STR : #ifdef CONFIG_FAIR_GROUP_SCHED
STR : 	if (tsk->sched_class->task_move_group)
STR : 		tsk->sched_class->task_move_group(tsk, on_rq);
STR : 	else
STR : #endif
STR : 		set_task_rq(tsk, task_cpu(tsk));
STR : 
STR : 	if (unlikely(running))
STR : 		tsk->sched_class->set_curr_task(rq);
STR : 	if (on_rq)
STR : 		enqueue_task(rq, tsk, 0);
STR : 
STR : 	task_rq_unlock(rq, tsk, &flags);
STR : }
STR : #endif /* CONFIG_CGROUP_SCHED */
STR : 
STR : #ifdef CONFIG_RT_GROUP_SCHED
STR : /*
STR :  * Ensure that the real time constraints are schedulable.
STR :  */
STR : static DEFINE_MUTEX(rt_constraints_mutex);
STR : 
STR : /* Must be called with tasklist_lock held */
STR : static inline int tg_has_rt_tasks(struct task_group *tg)
STR : {
STR : 	struct task_struct *g, *p;
STR : 
STR : 	do_each_thread(g, p) {
STR : 		if (rt_task(p) && task_rq(p)->rt.tg == tg)
STR : 			return 1;
STR : 	} while_each_thread(g, p);
STR : 
STR : 	return 0;
STR : }
STR : 
STR : struct rt_schedulable_data {
STR : 	struct task_group *tg;
STR : 	u64 rt_period;
STR : 	u64 rt_runtime;
STR : };
STR : 
STR : static int tg_rt_schedulable(struct task_group *tg, void *data)
STR : {
STR : 	struct rt_schedulable_data *d = data;
STR : 	struct task_group *child;
STR : 	unsigned long total, sum = 0;
STR : 	u64 period, runtime;
STR : 
STR : 	period = ktime_to_ns(tg->rt_bandwidth.rt_period);
STR : 	runtime = tg->rt_bandwidth.rt_runtime;
STR : 
STR : 	if (tg == d->tg) {
STR : 		period = d->rt_period;
STR : 		runtime = d->rt_runtime;
STR : 	}
STR : 
STR : 	/*
STR : 	 * Cannot have more runtime than the period.
STR : 	 */
STR : 	if (runtime > period && runtime != RUNTIME_INF)
STR : 		return -EINVAL;
STR : 
STR : 	/*
STR : 	 * Ensure we don't starve existing RT tasks.
STR : 	 */
STR : 	if (rt_bandwidth_enabled() && !runtime && tg_has_rt_tasks(tg))
STR : 		return -EBUSY;
STR : 
STR : 	total = to_ratio(period, runtime);
STR : 
STR : 	/*
STR : 	 * Nobody can have more than the global setting allows.
STR : 	 */
STR : 	if (total > to_ratio(global_rt_period(), global_rt_runtime()))
STR : 		return -EINVAL;
STR : 
STR : 	/*
STR : 	 * The sum of our children's runtime should not exceed our own.
STR : 	 */
STR : 	list_for_each_entry_rcu(child, &tg->children, siblings) {
STR : 		period = ktime_to_ns(child->rt_bandwidth.rt_period);
STR : 		runtime = child->rt_bandwidth.rt_runtime;
STR : 
STR : 		if (child == d->tg) {
STR : 			period = d->rt_period;
STR : 			runtime = d->rt_runtime;
STR : 		}
STR : 
STR : 		sum += to_ratio(period, runtime);
STR : 	}
STR : 
STR : 	if (sum > total)
STR : 		return -EINVAL;
STR : 
STR : 	return 0;
STR : }
STR : 
STR : static int __rt_schedulable(struct task_group *tg, u64 period, u64 runtime)
STR : {
STR : 	int ret;
STR : 
STR : 	struct rt_schedulable_data data = {
STR : 		.tg = tg,
STR : 		.rt_period = period,
STR : 		.rt_runtime = runtime,
STR : 	};
STR : 
STR : 	rcu_read_lock();
STR : 	ret = walk_tg_tree(tg_rt_schedulable, tg_nop, &data);
STR : 	rcu_read_unlock();
STR : 
STR : 	return ret;
STR : }
STR : 
STR : static int tg_set_rt_bandwidth(struct task_group *tg,
STR : 		u64 rt_period, u64 rt_runtime)
STR : {
STR : 	int i, err = 0;
STR : 
STR : 	mutex_lock(&rt_constraints_mutex);
STR : 	read_lock(&tasklist_lock);
STR : 	err = __rt_schedulable(tg, rt_period, rt_runtime);
STR : 	if (err)
STR : 		goto unlock;
STR : 
STR : 	raw_spin_lock_irq(&tg->rt_bandwidth.rt_runtime_lock);
STR : 	tg->rt_bandwidth.rt_period = ns_to_ktime(rt_period);
STR : 	tg->rt_bandwidth.rt_runtime = rt_runtime;
STR : 
STR : 	for_each_possible_cpu(i) {
STR : 		struct rt_rq *rt_rq = tg->rt_rq[i];
STR : 
STR : 		raw_spin_lock(&rt_rq->rt_runtime_lock);
STR : 		rt_rq->rt_runtime = rt_runtime;
STR : 		raw_spin_unlock(&rt_rq->rt_runtime_lock);
STR : 	}
STR : 	raw_spin_unlock_irq(&tg->rt_bandwidth.rt_runtime_lock);
STR : unlock:
STR : 	read_unlock(&tasklist_lock);
STR : 	mutex_unlock(&rt_constraints_mutex);
STR : 
STR : 	return err;
STR : }
STR : 
STR : static int sched_group_set_rt_runtime(struct task_group *tg, long rt_runtime_us)
STR : {
STR : 	u64 rt_runtime, rt_period;
STR : 
STR : 	rt_period = ktime_to_ns(tg->rt_bandwidth.rt_period);
STR : 	rt_runtime = (u64)rt_runtime_us * NSEC_PER_USEC;
STR : 	if (rt_runtime_us < 0)
STR : 		rt_runtime = RUNTIME_INF;
STR : 
STR : 	return tg_set_rt_bandwidth(tg, rt_period, rt_runtime);
STR : }
STR : 
STR : static long sched_group_rt_runtime(struct task_group *tg)
STR : {
STR : 	u64 rt_runtime_us;
STR : 
STR : 	if (tg->rt_bandwidth.rt_runtime == RUNTIME_INF)
STR : 		return -1;
STR : 
STR : 	rt_runtime_us = tg->rt_bandwidth.rt_runtime;
STR : 	do_div(rt_runtime_us, NSEC_PER_USEC);
STR : 	return rt_runtime_us;
STR : }
STR : 
STR : static int sched_group_set_rt_period(struct task_group *tg, long rt_period_us)
STR : {
STR : 	u64 rt_runtime, rt_period;
STR : 
STR : 	rt_period = (u64)rt_period_us * NSEC_PER_USEC;
STR : 	rt_runtime = tg->rt_bandwidth.rt_runtime;
STR : 
STR : 	if (rt_period == 0)
STR : 		return -EINVAL;
STR : 
STR : 	return tg_set_rt_bandwidth(tg, rt_period, rt_runtime);
STR : }
STR : 
STR : static long sched_group_rt_period(struct task_group *tg)
STR : {
STR : 	u64 rt_period_us;
STR : 
STR : 	rt_period_us = ktime_to_ns(tg->rt_bandwidth.rt_period);
STR : 	do_div(rt_period_us, NSEC_PER_USEC);
STR : 	return rt_period_us;
STR : }
STR : #endif /* CONFIG_RT_GROUP_SCHED */
STR : 
STR : #ifdef CONFIG_RT_GROUP_SCHED
STR : static int sched_rt_global_constraints(void)
STR : {
STR : 	int ret = 0;
STR : 
STR : 	mutex_lock(&rt_constraints_mutex);
STR : 	read_lock(&tasklist_lock);
STR : 	ret = __rt_schedulable(NULL, 0, 0);
STR : 	read_unlock(&tasklist_lock);
STR : 	mutex_unlock(&rt_constraints_mutex);
STR : 
STR : 	return ret;
STR : }
STR : 
STR : static int sched_rt_can_attach(struct task_group *tg, struct task_struct *tsk)
STR : {
STR : 	/* Don't accept realtime tasks when there is no way for them to run */
STR : 	if (rt_task(tsk) && tg->rt_bandwidth.rt_runtime == 0)
STR : 		return 0;
STR : 
STR : 	return 1;
STR : }
STR : 
STR : #else /* !CONFIG_RT_GROUP_SCHED */
STR : static int sched_rt_global_constraints(void)
STR : {
STR : 	unsigned long flags;
STR : 	int i, ret = 0;
STR : 
STR : 	raw_spin_lock_irqsave(&def_rt_bandwidth.rt_runtime_lock, flags);
STR : 	for_each_possible_cpu(i) {
STR : 		struct rt_rq *rt_rq = &cpu_rq(i)->rt;
STR : 
STR : 		raw_spin_lock(&rt_rq->rt_runtime_lock);
STR : 		rt_rq->rt_runtime = global_rt_runtime();
STR : 		raw_spin_unlock(&rt_rq->rt_runtime_lock);
STR : 	}
STR : 	raw_spin_unlock_irqrestore(&def_rt_bandwidth.rt_runtime_lock, flags);
STR : 
STR : 	return ret;
STR : }
STR : #endif /* CONFIG_RT_GROUP_SCHED */
STR : 
STR : static int sched_dl_global_constraints(void)
STR : {
STR : 	u64 runtime = global_rt_runtime();
STR : 	u64 period = global_rt_period();
STR : 	u64 new_bw = to_ratio(period, runtime);
STR : 	int cpu, ret = 0;
STR : 	unsigned long flags;
STR : 
STR : 	/*
STR : 	 * Here we want to check the bandwidth not being set to some
STR : 	 * value smaller than the currently allocated bandwidth in
STR : 	 * any of the root_domains.
STR : 	 *
STR : 	 * FIXME: Cycling on all the CPUs is overdoing, but simpler than
STR : 	 * cycling on root_domains... Discussion on different/better
STR : 	 * solutions is welcome!
STR : 	 */
STR : 	for_each_possible_cpu(cpu) {
STR : 		struct dl_bw *dl_b = dl_bw_of(cpu);
STR : 
STR : 		raw_spin_lock_irqsave(&dl_b->lock, flags);
STR : 		if (new_bw < dl_b->total_bw)
STR : 			ret = -EBUSY;
STR : 		raw_spin_unlock_irqrestore(&dl_b->lock, flags);
STR : 
STR : 		if (ret)
STR : 			break;
STR : 	}
STR : 
STR : 	return ret;
STR : }
STR : 
STR : static void sched_dl_do_global(void)
STR : {
STR : 	u64 new_bw = -1;
STR : 	int cpu;
STR : 	unsigned long flags;
STR : 
STR : 	def_dl_bandwidth.dl_period = global_rt_period();
STR : 	def_dl_bandwidth.dl_runtime = global_rt_runtime();
STR : 
STR : 	if (global_rt_runtime() != RUNTIME_INF)
STR : 		new_bw = to_ratio(global_rt_period(), global_rt_runtime());
STR : 
STR : 	/*
STR : 	 * FIXME: As above...
STR : 	 */
STR : 	for_each_possible_cpu(cpu) {
STR : 		struct dl_bw *dl_b = dl_bw_of(cpu);
STR : 
STR : 		raw_spin_lock_irqsave(&dl_b->lock, flags);
STR : 		dl_b->bw = new_bw;
STR : 		raw_spin_unlock_irqrestore(&dl_b->lock, flags);
STR : 	}
STR : }
STR : 
STR : static int sched_rt_global_validate(void)
STR : {
STR : 	if (sysctl_sched_rt_period <= 0)
STR : 		return -EINVAL;
STR : 
STR : 	if ((sysctl_sched_rt_runtime != RUNTIME_INF) &&
STR : 		(sysctl_sched_rt_runtime > sysctl_sched_rt_period))
STR : 		return -EINVAL;
STR : 
STR : 	return 0;
STR : }
STR : 
STR : static void sched_rt_do_global(void)
STR : {
STR : 	def_rt_bandwidth.rt_runtime = global_rt_runtime();
STR : 	def_rt_bandwidth.rt_period = ns_to_ktime(global_rt_period());
STR : }
STR : 
STR : int sched_rt_handler(struct ctl_table *table, int write,
STR : 		void __user *buffer, size_t *lenp,
STR : 		loff_t *ppos)
STR : {
STR : 	int old_period, old_runtime;
STR : 	static DEFINE_MUTEX(mutex);
STR : 	int ret;
STR : 
STR : 	mutex_lock(&mutex);
STR : 	old_period = sysctl_sched_rt_period;
STR : 	old_runtime = sysctl_sched_rt_runtime;
STR : 
STR : 	ret = proc_dointvec(table, write, buffer, lenp, ppos);
STR : 
STR : 	if (!ret && write) {
STR : 		ret = sched_rt_global_validate();
STR : 		if (ret)
STR : 			goto undo;
STR : 
STR : 		ret = sched_rt_global_constraints();
STR : 		if (ret)
STR : 			goto undo;
STR : 
STR : 		ret = sched_dl_global_constraints();
STR : 		if (ret)
STR : 			goto undo;
STR : 
STR : 		sched_rt_do_global();
STR : 		sched_dl_do_global();
STR : 	}
STR : 	if (0) {
STR : undo:
STR : 		sysctl_sched_rt_period = old_period;
STR : 		sysctl_sched_rt_runtime = old_runtime;
STR : 	}
STR : 	mutex_unlock(&mutex);
STR : 
STR : 	return ret;
STR : }
STR : 
STR : int sched_rr_handler(struct ctl_table *table, int write,
STR : 		void __user *buffer, size_t *lenp,
STR : 		loff_t *ppos)
STR : {
STR : 	int ret;
STR : 	static DEFINE_MUTEX(mutex);
STR : 
STR : 	mutex_lock(&mutex);
STR : 	ret = proc_dointvec(table, write, buffer, lenp, ppos);
STR : 	/* make sure that internally we keep jiffies */
STR : 	/* also, writing zero resets timeslice to default */
STR : 	if (!ret && write) {
STR : 		sched_rr_timeslice = sched_rr_timeslice <= 0 ?
STR : 			RR_TIMESLICE : msecs_to_jiffies(sched_rr_timeslice);
STR : 	}
STR : 	mutex_unlock(&mutex);
STR : 	return ret;
STR : }
STR : 
STR : #ifdef CONFIG_CGROUP_SCHED
STR : 
STR : static inline struct task_group *css_tg(struct cgroup_subsys_state *css)
STR : {
STR : 	return css ? container_of(css, struct task_group, css) : NULL;
STR : }
STR : 
STR : static struct cgroup_subsys_state *
STR : cpu_cgroup_css_alloc(struct cgroup_subsys_state *parent_css)
STR : {
STR : 	struct task_group *parent = css_tg(parent_css);
STR : 	struct task_group *tg;
STR : 
STR : 	if (!parent) {
STR : 		/* This is early initialization for the top cgroup */
STR : 		return &root_task_group.css;
STR : 	}
STR : 
STR : 	tg = sched_create_group(parent);
STR : 	if (IS_ERR(tg))
STR : 		return ERR_PTR(-ENOMEM);
STR : 
STR : 	return &tg->css;
STR : }
STR : 
STR : static int cpu_cgroup_css_online(struct cgroup_subsys_state *css)
STR : {
STR : 	struct task_group *tg = css_tg(css);
STR : 	struct task_group *parent = css_tg(css_parent(css));
STR : 
STR : 	if (parent)
STR : 		sched_online_group(tg, parent);
STR : 	return 0;
STR : }
STR : 
STR : static void cpu_cgroup_css_free(struct cgroup_subsys_state *css)
STR : {
STR : 	struct task_group *tg = css_tg(css);
STR : 
STR : 	sched_destroy_group(tg);
STR : }
STR : 
STR : static void cpu_cgroup_css_offline(struct cgroup_subsys_state *css)
STR : {
STR : 	struct task_group *tg = css_tg(css);
STR : 
STR : 	sched_offline_group(tg);
STR : }
STR : 
STR : static int cpu_cgroup_can_attach(struct cgroup_subsys_state *css,
STR : 				 struct cgroup_taskset *tset)
STR : {
STR : 	struct task_struct *task;
STR : 
STR : 	cgroup_taskset_for_each(task, css, tset) {
STR : #ifdef CONFIG_RT_GROUP_SCHED
STR : 		if (!sched_rt_can_attach(css_tg(css), task))
STR : 			return -EINVAL;
STR : #else
STR : 		/* We don't support RT-tasks being in separate groups */
STR : 		if (task->sched_class != &fair_sched_class)
STR : 			return -EINVAL;
STR : #endif
STR : 	}
STR : 	return 0;
STR : }
STR : 
STR : static void cpu_cgroup_attach(struct cgroup_subsys_state *css,
STR : 			      struct cgroup_taskset *tset)
STR : {
STR : 	struct task_struct *task;
STR : 
STR : 	cgroup_taskset_for_each(task, css, tset)
STR : 		sched_move_task(task);
STR : }
STR : 
STR : static void cpu_cgroup_exit(struct cgroup_subsys_state *css,
STR : 			    struct cgroup_subsys_state *old_css,
STR : 			    struct task_struct *task)
STR : {
STR : 	/*
STR : 	 * cgroup_exit() is called in the copy_process() failure path.
STR : 	 * Ignore this case since the task hasn't ran yet, this avoids
STR : 	 * trying to poke a half freed task state from generic code.
STR : 	 */
STR : 	if (!(task->flags & PF_EXITING))
STR : 		return;
STR : 
STR : 	sched_move_task(task);
STR : }
STR : 
STR : #ifdef CONFIG_FAIR_GROUP_SCHED
STR : static int cpu_shares_write_u64(struct cgroup_subsys_state *css,
STR : 				struct cftype *cftype, u64 shareval)
STR : {
STR : 	return sched_group_set_shares(css_tg(css), scale_load(shareval));
STR : }
STR : 
STR : static u64 cpu_shares_read_u64(struct cgroup_subsys_state *css,
STR : 			       struct cftype *cft)
STR : {
STR : 	struct task_group *tg = css_tg(css);
STR : 
STR : 	return (u64) scale_load_down(tg->shares);
STR : }
STR : 
STR : #ifdef CONFIG_CFS_BANDWIDTH
STR : static DEFINE_MUTEX(cfs_constraints_mutex);
STR : 
STR : const u64 max_cfs_quota_period = 1 * NSEC_PER_SEC; /* 1s */
STR : const u64 min_cfs_quota_period = 1 * NSEC_PER_MSEC; /* 1ms */
STR : 
STR : static int __cfs_schedulable(struct task_group *tg, u64 period, u64 runtime);
STR : 
STR : static int tg_set_cfs_bandwidth(struct task_group *tg, u64 period, u64 quota)
STR : {
STR : 	int i, ret = 0, runtime_enabled, runtime_was_enabled;
STR : 	struct cfs_bandwidth *cfs_b = &tg->cfs_bandwidth;
STR : 
STR : 	if (tg == &root_task_group)
STR : 		return -EINVAL;
STR : 
STR : 	/*
STR : 	 * Ensure we have at some amount of bandwidth every period.  This is
STR : 	 * to prevent reaching a state of large arrears when throttled via
STR : 	 * entity_tick() resulting in prolonged exit starvation.
STR : 	 */
STR : 	if (quota < min_cfs_quota_period || period < min_cfs_quota_period)
STR : 		return -EINVAL;
STR : 
STR : 	/*
STR : 	 * Likewise, bound things on the otherside by preventing insane quota
STR : 	 * periods.  This also allows us to normalize in computing quota
STR : 	 * feasibility.
STR : 	 */
STR : 	if (period > max_cfs_quota_period)
STR : 		return -EINVAL;
STR : 
STR : 	mutex_lock(&cfs_constraints_mutex);
STR : 	ret = __cfs_schedulable(tg, period, quota);
STR : 	if (ret)
STR : 		goto out_unlock;
STR : 
STR : 	runtime_enabled = quota != RUNTIME_INF;
STR : 	runtime_was_enabled = cfs_b->quota != RUNTIME_INF;
STR : 	/*
STR : 	 * If we need to toggle cfs_bandwidth_used, off->on must occur
STR : 	 * before making related changes, and on->off must occur afterwards
STR : 	 */
STR : 	if (runtime_enabled && !runtime_was_enabled)
STR : 		cfs_bandwidth_usage_inc();
STR : 	raw_spin_lock_irq(&cfs_b->lock);
STR : 	cfs_b->period = ns_to_ktime(period);
STR : 	cfs_b->quota = quota;
STR : 
STR : 	__refill_cfs_bandwidth_runtime(cfs_b);
STR : 	/* restart the period timer (if active) to handle new period expiry */
STR : 	if (runtime_enabled && cfs_b->timer_active) {
STR : 		/* force a reprogram */
STR : 		cfs_b->timer_active = 0;
STR : 		__start_cfs_bandwidth(cfs_b);
STR : 	}
STR : 	raw_spin_unlock_irq(&cfs_b->lock);
STR : 
STR : 	for_each_possible_cpu(i) {
STR : 		struct cfs_rq *cfs_rq = tg->cfs_rq[i];
STR : 		struct rq *rq = cfs_rq->rq;
STR : 
STR : 		raw_spin_lock_irq(&rq->lock);
STR : 		cfs_rq->runtime_enabled = runtime_enabled;
STR : 		cfs_rq->runtime_remaining = 0;
STR : 
STR : 		if (cfs_rq->throttled)
STR : 			unthrottle_cfs_rq(cfs_rq);
STR : 		raw_spin_unlock_irq(&rq->lock);
STR : 	}
STR : 	if (runtime_was_enabled && !runtime_enabled)
STR : 		cfs_bandwidth_usage_dec();
STR : out_unlock:
STR : 	mutex_unlock(&cfs_constraints_mutex);
STR : 
STR : 	return ret;
STR : }
STR : 
STR : int tg_set_cfs_quota(struct task_group *tg, long cfs_quota_us)
STR : {
STR : 	u64 quota, period;
STR : 
STR : 	period = ktime_to_ns(tg->cfs_bandwidth.period);
STR : 	if (cfs_quota_us < 0)
STR : 		quota = RUNTIME_INF;
STR : 	else
STR : 		quota = (u64)cfs_quota_us * NSEC_PER_USEC;
STR : 
STR : 	return tg_set_cfs_bandwidth(tg, period, quota);
STR : }
STR : 
STR : long tg_get_cfs_quota(struct task_group *tg)
STR : {
STR : 	u64 quota_us;
STR : 
STR : 	if (tg->cfs_bandwidth.quota == RUNTIME_INF)
STR : 		return -1;
STR : 
STR : 	quota_us = tg->cfs_bandwidth.quota;
STR : 	do_div(quota_us, NSEC_PER_USEC);
STR : 
STR : 	return quota_us;
STR : }
STR : 
STR : int tg_set_cfs_period(struct task_group *tg, long cfs_period_us)
STR : {
STR : 	u64 quota, period;
STR : 
STR : 	period = (u64)cfs_period_us * NSEC_PER_USEC;
STR : 	quota = tg->cfs_bandwidth.quota;
STR : 
STR : 	return tg_set_cfs_bandwidth(tg, period, quota);
STR : }
STR : 
STR : long tg_get_cfs_period(struct task_group *tg)
STR : {
STR : 	u64 cfs_period_us;
STR : 
STR : 	cfs_period_us = ktime_to_ns(tg->cfs_bandwidth.period);
STR : 	do_div(cfs_period_us, NSEC_PER_USEC);
STR : 
STR : 	return cfs_period_us;
STR : }
STR : 
STR : static s64 cpu_cfs_quota_read_s64(struct cgroup_subsys_state *css,
STR : 				  struct cftype *cft)
STR : {
STR : 	return tg_get_cfs_quota(css_tg(css));
STR : }
STR : 
STR : static int cpu_cfs_quota_write_s64(struct cgroup_subsys_state *css,
STR : 				   struct cftype *cftype, s64 cfs_quota_us)
STR : {
STR : 	return tg_set_cfs_quota(css_tg(css), cfs_quota_us);
STR : }
STR : 
STR : static u64 cpu_cfs_period_read_u64(struct cgroup_subsys_state *css,
STR : 				   struct cftype *cft)
STR : {
STR : 	return tg_get_cfs_period(css_tg(css));
STR : }
STR : 
STR : static int cpu_cfs_period_write_u64(struct cgroup_subsys_state *css,
STR : 				    struct cftype *cftype, u64 cfs_period_us)
STR : {
STR : 	return tg_set_cfs_period(css_tg(css), cfs_period_us);
STR : }
STR : 
STR : struct cfs_schedulable_data {
STR : 	struct task_group *tg;
STR : 	u64 period, quota;
STR : };
STR : 
STR : /*
STR :  * normalize group quota/period to be quota/max_period
STR :  * note: units are usecs
STR :  */
STR : static u64 normalize_cfs_quota(struct task_group *tg,
STR : 			       struct cfs_schedulable_data *d)
STR : {
STR : 	u64 quota, period;
STR : 
STR : 	if (tg == d->tg) {
STR : 		period = d->period;
STR : 		quota = d->quota;
STR : 	} else {
STR : 		period = tg_get_cfs_period(tg);
STR : 		quota = tg_get_cfs_quota(tg);
STR : 	}
STR : 
STR : 	/* note: these should typically be equivalent */
STR : 	if (quota == RUNTIME_INF || quota == -1)
STR : 		return RUNTIME_INF;
STR : 
STR : 	return to_ratio(period, quota);
STR : }
STR : 
STR : static int tg_cfs_schedulable_down(struct task_group *tg, void *data)
STR : {
STR : 	struct cfs_schedulable_data *d = data;
STR : 	struct cfs_bandwidth *cfs_b = &tg->cfs_bandwidth;
STR : 	s64 quota = 0, parent_quota = -1;
STR : 
STR : 	if (!tg->parent) {
STR : 		quota = RUNTIME_INF;
STR : 	} else {
STR : 		struct cfs_bandwidth *parent_b = &tg->parent->cfs_bandwidth;
STR : 
STR : 		quota = normalize_cfs_quota(tg, d);
STR : 		parent_quota = parent_b->hierarchal_quota;
STR : 
STR : 		/*
STR : 		 * ensure max(child_quota) <= parent_quota, inherit when no
STR : 		 * limit is set
STR : 		 */
STR : 		if (quota == RUNTIME_INF)
STR : 			quota = parent_quota;
STR : 		else if (parent_quota != RUNTIME_INF && quota > parent_quota)
STR : 			return -EINVAL;
STR : 	}
STR : 	cfs_b->hierarchal_quota = quota;
STR : 
STR : 	return 0;
STR : }
STR : 
STR : static int __cfs_schedulable(struct task_group *tg, u64 period, u64 quota)
STR : {
STR : 	int ret;
STR : 	struct cfs_schedulable_data data = {
STR : 		.tg = tg,
STR : 		.period = period,
STR : 		.quota = quota,
STR : 	};
STR : 
STR : 	if (quota != RUNTIME_INF) {
STR : 		do_div(data.period, NSEC_PER_USEC);
STR : 		do_div(data.quota, NSEC_PER_USEC);
STR : 	}
STR : 
STR : 	rcu_read_lock();
STR : 	ret = walk_tg_tree(tg_cfs_schedulable_down, tg_nop, &data);
STR : 	rcu_read_unlock();
STR : 
STR : 	return ret;
STR : }
STR : 
STR : static int cpu_stats_show(struct seq_file *sf, void *v)
STR : {
STR : 	struct task_group *tg = css_tg(seq_css(sf));
STR : 	struct cfs_bandwidth *cfs_b = &tg->cfs_bandwidth;
STR : 
STR : 	seq_printf(sf, "nr_periods %d\n", cfs_b->nr_periods);
STR : 	seq_printf(sf, "nr_throttled %d\n", cfs_b->nr_throttled);
STR : 	seq_printf(sf, "throttled_time %llu\n", cfs_b->throttled_time);
STR : 
STR : 	return 0;
STR : }
STR : #endif /* CONFIG_CFS_BANDWIDTH */
STR : #endif /* CONFIG_FAIR_GROUP_SCHED */
STR : 
STR : #ifdef CONFIG_RT_GROUP_SCHED
STR : static int cpu_rt_runtime_write(struct cgroup_subsys_state *css,
STR : 				struct cftype *cft, s64 val)
STR : {
STR : 	return sched_group_set_rt_runtime(css_tg(css), val);
STR : }
STR : 
STR : static s64 cpu_rt_runtime_read(struct cgroup_subsys_state *css,
STR : 			       struct cftype *cft)
STR : {
STR : 	return sched_group_rt_runtime(css_tg(css));
STR : }
STR : 
STR : static int cpu_rt_period_write_uint(struct cgroup_subsys_state *css,
STR : 				    struct cftype *cftype, u64 rt_period_us)
STR : {
STR : 	return sched_group_set_rt_period(css_tg(css), rt_period_us);
STR : }
STR : 
STR : static u64 cpu_rt_period_read_uint(struct cgroup_subsys_state *css,
STR : 				   struct cftype *cft)
STR : {
STR : 	return sched_group_rt_period(css_tg(css));
STR : }
STR : #endif /* CONFIG_RT_GROUP_SCHED */
STR : 
STR : static struct cftype cpu_files[] = {
STR : #ifdef CONFIG_FAIR_GROUP_SCHED
STR : 	{
STR : 		.name = "shares",
STR : 		.read_u64 = cpu_shares_read_u64,
STR : 		.write_u64 = cpu_shares_write_u64,
STR : 	},
STR : #endif
STR : #ifdef CONFIG_CFS_BANDWIDTH
STR : 	{
STR : 		.name = "cfs_quota_us",
STR : 		.read_s64 = cpu_cfs_quota_read_s64,
STR : 		.write_s64 = cpu_cfs_quota_write_s64,
STR : 	},
STR : 	{
STR : 		.name = "cfs_period_us",
STR : 		.read_u64 = cpu_cfs_period_read_u64,
STR : 		.write_u64 = cpu_cfs_period_write_u64,
STR : 	},
STR : 	{
STR : 		.name = "stat",
STR : 		.seq_show = cpu_stats_show,
STR : 	},
STR : #endif
STR : #ifdef CONFIG_RT_GROUP_SCHED
STR : 	{
STR : 		.name = "rt_runtime_us",
STR : 		.read_s64 = cpu_rt_runtime_read,
STR : 		.write_s64 = cpu_rt_runtime_write,
STR : 	},
STR : 	{
STR : 		.name = "rt_period_us",
STR : 		.read_u64 = cpu_rt_period_read_uint,
STR : 		.write_u64 = cpu_rt_period_write_uint,
STR : 	},
STR : #endif
STR : 	{ }	/* terminate */
STR : };
STR : 
STR : struct cgroup_subsys cpu_cgroup_subsys = {
STR : 	.name		= "cpu",
STR : 	.css_alloc	= cpu_cgroup_css_alloc,
STR : 	.css_free	= cpu_cgroup_css_free,
STR : 	.css_online	= cpu_cgroup_css_online,
STR : 	.css_offline	= cpu_cgroup_css_offline,
STR : 	.can_attach	= cpu_cgroup_can_attach,
STR : 	.attach		= cpu_cgroup_attach,
STR : 	.exit		= cpu_cgroup_exit,
STR : 	.subsys_id	= cpu_cgroup_subsys_id,
STR : 	.base_cftypes	= cpu_files,
STR : 	.early_init	= 1,
STR : };
STR : 
STR : #endif	/* CONFIG_CGROUP_SCHED */
STR : 
STR : void dump_cpu_task(int cpu)
STR : {
STR : 	pr_info("Task dump for CPU %d:\n", cpu);
STR : 	sched_show_task(cpu_curr(cpu));
STR : }
